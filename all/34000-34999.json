[{"original_method":"/**\n     * Applies a constraint for the specified name and consraint value.\n     *\n     * @param constraintName The name of the constraint\n     * @param constrainingValue The constraining value\n     *\n     * @throws ConstraintException Thrown when the specified constraint is not supported by this ConstrainedProperty. Use <code>supportsContraint(String constraintName)<\/code> to check before calling\n     */\n    public void applyConstraint(String constraintName, Object constrainingValue) {\n\n        if (constraints.containsKey(constraintName)) {\n            if (constrainingValue == null) {\n                appliedConstraints.remove(constraintName);\n            }\n            else {\n                try {\n                    Constraint c = instantiateConstraint(constraintName);\n\n                    c.setOwningClass(owningClass);\n                    c.setPropertyName(propertyName);\n                    c.setParameter(constrainingValue);\n                    appliedConstraints.put(constraintName, c);\n                }\n                catch (Exception e) {\n                    LOG.error(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                    throw new ConstraintException(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                }\n            }\n        }\n        else if (bean.isWritableProperty(constraintName)) {\n            bean.setPropertyValue(constraintName, constrainingValue);\n        }\n        else {\n            throw new ConstraintException(\"Constraint [\" + constraintName + \"] is not supported for property [\" +\n                    propertyName + \"] of class [\" + owningClass + \"] with type [\" + propertyType + \"]\");\n        }\n    }","id":34000,"modified_method":"/**\n     * Applies a constraint for the specified name and consraint value.\n     *\n     * @param constraintName The name of the constraint\n     * @param constrainingValue The constraining value\n     *\n     * @throws ConstraintException Thrown when the specified constraint is not supported by this ConstrainedProperty. Use <code>supportsContraint(String constraintName)<\/code> to check before calling\n     */\n    public void applyConstraint(String constraintName, Object constrainingValue) {\n\n        if (constraints.containsKey(constraintName)) {\n            if (constrainingValue == null) {\n                appliedConstraints.remove(constraintName);\n            }\n            else {\n                try {\n                    Constraint c = instantiateConstraint(constraintName, true);\n                    if(c != null) {\n                        c.setParameter(constrainingValue);\n                        appliedConstraints.put(constraintName, c);\n                    }\n                }\n                catch (Exception e) {\n                    LOG.error(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                    throw new ConstraintException(\"Exception thrown applying constraint [\" + constraintName +\n                            \"] to class [\" + owningClass + \"] for value [\" + constrainingValue + \"]: \" + e.getMessage(), e);\n                }\n            }\n        }\n        else if (bean.isWritableProperty(constraintName)) {\n            bean.setPropertyValue(constraintName, constrainingValue);\n        }\n        else {\n            throw new ConstraintException(\"Constraint [\" + constraintName + \"] is not supported for property [\" +\n                    propertyName + \"] of class [\" + owningClass + \"] with type [\" + propertyType + \"]\");\n        }\n    }","commit_id":"4bfe85d7977ec12f088f73515b3910c0359306f3","url":"https://github.com/grails/grails-core"},{"original_method":"private Constraint instantiateConstraint(String constraintName) throws InstantiationException, IllegalAccessException {\n        Object constraintFactory = constraints.get(constraintName);\n        if (constraintFactory instanceof ConstraintFactory) {\n            return ((ConstraintFactory)constraintFactory).newInstance();\n        }\n\n        return (Constraint)((Class<?>)constraintFactory).newInstance();\n    }","id":34001,"modified_method":"private Constraint instantiateConstraint(String constraintName, boolean validate) throws InstantiationException, IllegalAccessException {\n        List<Object> candidateConstraints = constraints.get(constraintName);\n\n        for (Object constraintFactory : candidateConstraints) {\n\n            Constraint c;\n            if (constraintFactory instanceof ConstraintFactory) {\n                c = ((ConstraintFactory)constraintFactory).newInstance();\n            }\n            else {\n                c = (Constraint)((Class<?>)constraintFactory).newInstance();\n            }\n\n            c.setOwningClass(owningClass);\n            c.setPropertyName(propertyName);\n\n            if(validate && c.isValid()) {\n\n                return c;\n            }\n            else if(!validate) {\n                return c;\n            }\n\n        }\n        return null;\n    }","commit_id":"4bfe85d7977ec12f088f73515b3910c0359306f3","url":"https://github.com/grails/grails-core"},{"original_method":"public static void registerNewConstraint(String name, ConstraintFactory factory) {\n        Assert.hasLength(name, \"Argument [name] cannot be null or blank\");\n        Assert.notNull(factory, \"Argument [factory] cannot be null\");\n        constraints.put(name, factory);\n    }","id":34002,"modified_method":"public static void registerNewConstraint(String name, ConstraintFactory factory) {\n        Assert.hasLength(name, \"Argument [name] cannot be null or blank\");\n        Assert.notNull(factory, \"Argument [factory] cannot be null\");\n        List<Object> objects = getOrInitializeConstraint(name);\n        objects.add(factory);\n    }","commit_id":"4bfe85d7977ec12f088f73515b3910c0359306f3","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    public JetTypeInfo visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context) {\n        JetExpression left = expression.getLeft();\n        JetTypeReference right = expression.getRight();\n        JetType result = null;\n        DataFlowInfo dataFlowInfo = context.dataFlowInfo;\n        if (right != null) {\n            JetType targetType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, right, context.trace, true);\n            IElementType operationType = expression.getOperationReference().getReferencedNameElementType();\n\n            boolean tryWithNoExpectedType = true;\n            if (isTypeFlexible(left) || operationType == JetTokens.COLON) {\n                TemporaryBindingTrace temporaryTraceWithExpectedType = TemporaryBindingTrace.create(\n                        context.trace, \"trace for resolve RHSExpression\", expression);\n                ExpressionTypingContext contextWithTemporaryTrace = context.replaceBindingTrace(temporaryTraceWithExpectedType).replaceExpectedType(targetType);\n                JetTypeInfo typeInfo = facade.getTypeInfo(left, contextWithTemporaryTrace);\n                if (typeInfo.getType() != null && checkBinaryWithTypeRHS(expression, contextWithTemporaryTrace, targetType, typeInfo.getType())) {\n                    temporaryTraceWithExpectedType.commit();\n                    dataFlowInfo = typeInfo.getDataFlowInfo();\n                    tryWithNoExpectedType = false;\n                }\n            }\n\n            if (tryWithNoExpectedType) {\n                ExpressionTypingContext contextWithNoExpectedType = context.replaceExpectedType(NO_EXPECTED_TYPE);\n                JetTypeInfo typeInfo = facade.getTypeInfo(left, contextWithNoExpectedType);\n                if (typeInfo.getType() != null) {\n                    checkBinaryWithTypeRHS(expression, contextWithNoExpectedType, targetType, typeInfo.getType());\n                    dataFlowInfo = typeInfo.getDataFlowInfo();\n                    if (operationType == JetTokens.AS_KEYWORD) {\n                        DataFlowValue value = DataFlowValueFactory.INSTANCE.createDataFlowValue(left, typeInfo.getType(), context.trace.getBindingContext());\n                        dataFlowInfo = dataFlowInfo.establishSubtyping(value, targetType);\n                    }\n                }\n            }\n\n            result = operationType == JetTokens.AS_SAFE ? TypeUtils.makeNullable(targetType) : targetType;\n        }\n        else {\n            dataFlowInfo = facade.getTypeInfo(left, context.replaceExpectedType(NO_EXPECTED_TYPE)).getDataFlowInfo();\n        }\n        return DataFlowUtils.checkType(result, expression, context, dataFlowInfo);\n    }","id":34003,"modified_method":"@Override\n    public JetTypeInfo visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context) {\n        ExpressionTypingContext contextWithNoExpectedType =\n                context.replaceExpectedType(NO_EXPECTED_TYPE).replaceResolveMode(ResolveMode.TOP_LEVEL_CALL);\n        JetExpression left = expression.getLeft();\n        JetTypeReference right = expression.getRight();\n        if (right == null) {\n            JetTypeInfo leftTypeInfo = facade.getTypeInfo(left, contextWithNoExpectedType);\n            return JetTypeInfo.create(null, leftTypeInfo.getDataFlowInfo());\n        }\n\n        JetType targetType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, right, context.trace, true);\n        IElementType operationType = expression.getOperationReference().getReferencedNameElementType();\n\n        if (isTypeFlexible(left) || operationType == JetTokens.COLON) {\n\n            JetTypeInfo typeInfo = facade.getTypeInfo(left, contextWithNoExpectedType.replaceExpectedType(targetType));\n            checkBinaryWithTypeRHS(expression, context, targetType, typeInfo.getType());\n            return DataFlowUtils.checkType(targetType, expression, context, typeInfo.getDataFlowInfo());\n        }\n\n        JetTypeInfo typeInfo = facade.getTypeInfo(left, contextWithNoExpectedType);\n\n        DataFlowInfo dataFlowInfo = context.dataFlowInfo;\n        if (typeInfo.getType() != null) {\n            checkBinaryWithTypeRHS(expression, contextWithNoExpectedType, targetType, typeInfo.getType());\n            dataFlowInfo = typeInfo.getDataFlowInfo();\n            if (operationType == JetTokens.AS_KEYWORD) {\n                DataFlowValue value = DataFlowValueFactory.INSTANCE.createDataFlowValue(left, typeInfo.getType(), context.trace.getBindingContext());\n                dataFlowInfo = dataFlowInfo.establishSubtyping(value, targetType);\n            }\n        }\n        JetType result = operationType == JetTokens.AS_SAFE ? TypeUtils.makeNullable(targetType) : targetType;\n        return DataFlowUtils.checkType(result, expression, context, dataFlowInfo);\n    }","commit_id":"6429239f3f17bea8265de02ffa66052f2886a40a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean checkBinaryWithTypeRHS(\n            JetBinaryExpressionWithTypeRHS expression,\n            ExpressionTypingContext context,\n            @NotNull JetType targetType,\n            JetType actualType\n    ) {\n        JetSimpleNameExpression operationSign = expression.getOperationReference();\n        IElementType operationType = operationSign.getReferencedNameElementType();\n        if (operationType == JetTokens.COLON) {\n            if (!noExpectedType(targetType) && !JetTypeChecker.INSTANCE.isSubtypeOf(actualType, targetType)) {\n                context.trace.report(TYPE_MISMATCH.on(expression.getLeft(), targetType, actualType));\n                return false;\n            }\n            return true;\n        }\n        else if (operationType == JetTokens.AS_KEYWORD || operationType == JetTokens.AS_SAFE) {\n            checkForCastImpossibility(expression, actualType, targetType, context);\n            return true;\n        }\n        else {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"binary operation with type RHS\"));\n            return false;\n        }\n    }","id":34004,"modified_method":"private static void checkBinaryWithTypeRHS(\n            @NotNull JetBinaryExpressionWithTypeRHS expression,\n            @NotNull ExpressionTypingContext context,\n            @NotNull JetType targetType,\n            @Nullable JetType actualType\n    ) {\n        if (actualType == null) return;\n        JetSimpleNameExpression operationSign = expression.getOperationReference();\n        IElementType operationType = operationSign.getReferencedNameElementType();\n        if (operationType == JetTokens.COLON) {\n            return;\n        }\n        if (operationType != JetTokens.AS_KEYWORD && operationType != JetTokens.AS_SAFE) {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"binary operation with type RHS\"));\n            return;\n        }\n        checkForCastImpossibility(expression, actualType, targetType, context);\n    }","commit_id":"6429239f3f17bea8265de02ffa66052f2886a40a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor, F extends D> OverloadResolutionResultsImpl<F> doResolveCallOrGetCachedResults(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull List<ResolutionTask<D, F>> prioritizedTasks,\n            @NotNull CallTransformer<D, F> callTransformer,\n            @NotNull TracingStrategy tracing\n    ) {\n        Call call = context.call;\n        tracing.bindCall(context.trace, call);\n\n        OverloadResolutionResultsImpl<F> results = null;\n        TemporaryBindingTrace traceToResolveCall = TemporaryBindingTrace.create(context.trace, \"trace to resolve call\", call);\n        if (!CallResolverUtil.isInvokeCallOnVariable(call)) {\n            ResolutionResultsCache.CachedData data = context.resolutionResultsCache.get(call);\n            if (data != null) {\n                DelegatingBindingTrace deltasTraceForResolve = data.getResolutionTrace();\n                deltasTraceForResolve.addAllMyDataTo(traceToResolveCall);\n                //noinspection unchecked\n                results = (OverloadResolutionResultsImpl<F>) data.getResolutionResults();\n            }\n        }\n        if (results == null) {\n            BasicCallResolutionContext newContext = context.replaceBindingTrace(traceToResolveCall);\n            results = doResolveCallAndRecordDebugInfo(newContext, prioritizedTasks, callTransformer, tracing);\n            DelegatingBindingTrace deltasTraceForTypeInference = ((OverloadResolutionResultsImpl) results).getTrace();\n            if (deltasTraceForTypeInference != null) {\n                deltasTraceForTypeInference.addAllMyDataTo(traceToResolveCall);\n            }\n            completeTypeInferenceDependentOnFunctionLiterals(newContext, results, tracing);\n            cacheResults(context, results, traceToResolveCall, tracing);\n        }\n        traceToResolveCall.commit();\n\n        if (context.contextDependency == ContextDependency.INDEPENDENT) {\n            results = callCompleter.completeCall(context, results, tracing);\n        }\n\n        return results;\n    }","id":34005,"modified_method":"private <D extends CallableDescriptor, F extends D> OverloadResolutionResultsImpl<F> doResolveCallOrGetCachedResults(\n            @NotNull BasicCallResolutionContext context,\n            @NotNull List<ResolutionTask<D, F>> prioritizedTasks,\n            @NotNull CallTransformer<D, F> callTransformer,\n            @NotNull TracingStrategy tracing\n    ) {\n        Call call = context.call;\n        tracing.bindCall(context.trace, call);\n\n        OverloadResolutionResultsImpl<F> results = null;\n        TemporaryBindingTrace traceToResolveCall = TemporaryBindingTrace.create(context.trace, \"trace to resolve call\", call);\n        if (!CallResolverUtil.isInvokeCallOnVariable(call)) {\n            ResolutionResultsCache.CachedData data = context.resolutionResultsCache.get(call);\n            if (data != null) {\n                DelegatingBindingTrace deltasTraceForResolve = data.getResolutionTrace();\n                deltasTraceForResolve.addAllMyDataTo(traceToResolveCall);\n                //noinspection unchecked\n                results = (OverloadResolutionResultsImpl<F>) data.getResolutionResults();\n            }\n        }\n        if (results == null) {\n            BasicCallResolutionContext newContext = context.replaceBindingTrace(traceToResolveCall);\n            recordScopeAndDataFlowInfo(newContext, newContext.call.getCalleeExpression());\n            results = doResolveCall(newContext, prioritizedTasks, callTransformer, tracing);\n            DelegatingBindingTrace deltasTraceForTypeInference = ((OverloadResolutionResultsImpl) results).getTrace();\n            if (deltasTraceForTypeInference != null) {\n                deltasTraceForTypeInference.addAllMyDataTo(traceToResolveCall);\n            }\n            completeTypeInferenceDependentOnFunctionLiterals(newContext, results, tracing);\n            cacheResults(context, results, traceToResolveCall, tracing);\n        }\n        traceToResolveCall.commit();\n\n        if (context.contextDependency == ContextDependency.INDEPENDENT) {\n            results = callCompleter.completeCall(context, results, tracing);\n        }\n\n        return results;\n    }","commit_id":"0b9c62ab541ba14b84c77d180df5ae5231f2fb12","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private JetTypeInfo getTypeInfo(@NotNull JetExpression expression, ExpressionTypingContext context, JetVisitor<JetTypeInfo, ExpressionTypingContext> visitor) {\n        JetTypeInfo recordedTypeInfo = BindingContextUtils.getRecordedTypeInfo(expression, context.trace.getBindingContext());\n        if (recordedTypeInfo != null) {\n            return recordedTypeInfo;\n        }\n        JetTypeInfo result;\n        try {\n            result = expression.accept(visitor, context);\n            // Some recursive definitions (object expressions) must put their types in the cache manually:\n            if (context.trace.get(BindingContext.PROCESSED, expression)) {\n                return JetTypeInfo.create(context.trace.getBindingContext().get(BindingContext.EXPRESSION_TYPE, expression),\n                                          result.getDataFlowInfo());\n            }\n\n            if (result.getType() instanceof DeferredType) {\n                result = JetTypeInfo.create(((DeferredType) result.getType()).getDelegate(), result.getDataFlowInfo());\n            }\n            if (result.getType() != null) {\n                context.trace.record(BindingContext.EXPRESSION_TYPE, expression, result.getType());\n            }\n\n        }\n        catch (ReenteringLazyValueComputationException e) {\n            context.trace.report(TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM.on(expression));\n            result = JetTypeInfo.create(null, context.dataFlowInfo);\n        }\n\n        if (!context.trace.get(BindingContext.PROCESSED, expression) && !BindingContextUtils.isExpressionWithValidReference(expression, context.trace.getBindingContext())) {\n            context.trace.record(BindingContext.RESOLUTION_SCOPE, expression, context.scope);\n        }\n        context.trace.record(BindingContext.PROCESSED, expression);\n        if (result.getDataFlowInfo() != DataFlowInfo.EMPTY) {\n            context.trace.record(BindingContext.EXPRESSION_DATA_FLOW_INFO, expression, result.getDataFlowInfo());\n        }\n        return result;\n    }","id":34006,"modified_method":"@NotNull\n    private JetTypeInfo getTypeInfo(@NotNull JetExpression expression, ExpressionTypingContext context, JetVisitor<JetTypeInfo, ExpressionTypingContext> visitor) {\n        JetTypeInfo recordedTypeInfo = BindingContextUtils.getRecordedTypeInfo(expression, context.trace.getBindingContext());\n        if (recordedTypeInfo != null) {\n            return recordedTypeInfo;\n        }\n        JetTypeInfo result;\n        try {\n            result = expression.accept(visitor, context);\n            // Some recursive definitions (object expressions) must put their types in the cache manually:\n            if (context.trace.get(BindingContext.PROCESSED, expression)) {\n                return JetTypeInfo.create(context.trace.getBindingContext().get(BindingContext.EXPRESSION_TYPE, expression),\n                                          result.getDataFlowInfo());\n            }\n\n            if (result.getType() instanceof DeferredType) {\n                result = JetTypeInfo.create(((DeferredType) result.getType()).getDelegate(), result.getDataFlowInfo());\n            }\n            if (result.getType() != null) {\n                context.trace.record(BindingContext.EXPRESSION_TYPE, expression, result.getType());\n            }\n\n        }\n        catch (ReenteringLazyValueComputationException e) {\n            context.trace.report(TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM.on(expression));\n            result = JetTypeInfo.create(null, context.dataFlowInfo);\n        }\n\n        context.trace.record(BindingContext.PROCESSED, expression);\n        recordScopeAndDataFlowInfo(context.replaceDataFlowInfo(result.getDataFlowInfo()), expression);\n        return result;\n    }","commit_id":"0b9c62ab541ba14b84c77d180df5ae5231f2fb12","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * @return Generate a default document descriptor from the Maven project\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     */\n    private DocumentModel generateDefaultDocDescriptor()\n        throws IOException, MojoExecutionException\n    {\n        DocumentMeta meta = new DocumentMeta();\n        meta.setTitle( getProjectName() );\n        meta.setDescription( project.getDescription() );\n        meta.setAuthors( getAuthors() );\n        meta.setCreator( System.getProperty( \"user.name\" ) );\n        meta.setCreationDate( new Date() );\n        // Note: no default keywords\n\n        DocumentCover cover = new DocumentCover();\n        cover.setCoverTitle( getProjectName() );\n        cover.setCoverVersion( project.getVersion() );\n        cover.setCoverType( i18n.getString( \"pdf-plugin\", getDefaultLocale(), \"toc.type\" ) );\n        cover.setCoverdate( ISO_8601_FORMAT.format( Calendar.getInstance().getTime() ) );\n        cover.setProjectName( getProjectName() );\n        cover.setCompanyName( getProjectOrganizationName() );\n        cover.setAuthors( getAuthors() );\n\n        DocumentModel docModel = new DocumentModel();\n        docModel.setModelEncoding( getProjectModelEncoding() );\n        docModel.setOutputName( project.getArtifactId() );\n        docModel.setMeta( meta );\n        docModel.setCover( cover );\n\n        // Populate docModel from defaultDecorationModel\n        DecorationModel decorationModel = getDefaultDecorationModel();\n\n        if ( decorationModel != null )\n        {\n            DocumentTOC toc = new DocumentTOC();\n\n            toc.setName( i18n.getString( \"pdf-plugin\", getDefaultLocale(), \"toc.title\" ) );\n\n            for ( Iterator it = decorationModel.getMenus().iterator(); it.hasNext(); )\n            {\n                Menu menu = (Menu) it.next();\n\n                for ( Iterator it2 = menu.getItems().iterator(); it2.hasNext(); )\n                {\n                    MenuItem item = (MenuItem) it2.next();\n\n                    DocumentTOCItem documentTOCItem = new DocumentTOCItem();\n                    documentTOCItem.setName( item.getName() );\n                    documentTOCItem.setRef( item.getHref() );\n                    toc.addItem( documentTOCItem );\n                }\n            }\n\n            docModel.setToc( toc );\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            File outputDir = new File( project.getBuild().getDirectory(), \"pdf\" );\n\n            if ( outputDir.isFile() )\n            {\n                throw new IOException( outputDir + \" is not a directory!\" );\n            }\n\n            if ( !outputDir.exists() )\n            {\n                outputDir.mkdirs();\n            }\n\n            File doc = FileUtils.createTempFile( \"pdf\", \".xml\", outputDir );\n\n            getLog().debug( \"Generated a default document model: \" + doc.getAbsolutePath() );\n\n            DocumentXpp3Writer xpp3 = new DocumentXpp3Writer();\n            Writer w = null;\n            try\n            {\n                w = WriterFactory.newPlatformWriter( doc );\n                xpp3.write( w, docModel );\n            }\n            finally\n            {\n                IOUtil.close( w );\n            }\n        }\n\n        return docModel;\n    }","id":34007,"modified_method":"/**\n     * @param locale not null\n     * @return Generate a default document descriptor from the Maven project\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     */\n    private DocumentModel generateDefaultDocDescriptor( Locale locale )\n        throws IOException, MojoExecutionException\n    {\n        DocumentMeta meta = new DocumentMeta();\n        meta.setAuthors( getAuthors() );\n        meta.setCreationDate( new Date() );\n        meta.setCreator( System.getProperty( \"user.name\" ) );\n        meta.setDate( new Date() );\n        meta.setDescription( project.getDescription() );\n        meta.setGenerator( getDefaultGenerator() );\n        meta.setInitialCreator( System.getProperty( \"user.name\" ) );\n        meta.setLanguage( locale.getLanguage() );\n        //meta.setPageSize( pageSize );\n        meta.setSubject( getProjectName() );\n        meta.setTitle( getProjectName() );\n\n        DocumentCover cover = new DocumentCover();\n        cover.setAuthors( getAuthors() );\n        //cover.setCompanyLogo( companyLogo );\n        cover.setCompanyName( getProjectOrganizationName() );\n        cover.setCoverDate( new Date() );\n        cover.setCoverSubTitle( \"v. \" + project.getVersion() );\n        cover.setCoverTitle( getProjectName() );\n        cover.setCoverType( i18n.getString( \"pdf-plugin\", getDefaultLocale(), \"toc.type\" ) );\n        cover.setCoverVersion( project.getVersion() );\n        //cover.setProjectLogo( projectLogo );\n        cover.setProjectName( getProjectName() );\n\n        DocumentModel docModel = new DocumentModel();\n        docModel.setModelEncoding( getProjectModelEncoding() );\n        docModel.setOutputName( project.getArtifactId() );\n        docModel.setMeta( meta );\n        docModel.setCover( cover );\n\n        // Populate docModel from defaultDecorationModel\n        DecorationModel decorationModel = getDefaultDecorationModel();\n        if ( decorationModel != null )\n        {\n            DocumentTOC toc = new DocumentTOC();\n\n            toc.setName( i18n.getString( \"pdf-plugin\", getDefaultLocale(), \"toc.title\" ) );\n\n            for ( Iterator it = decorationModel.getMenus().iterator(); it.hasNext(); )\n            {\n                Menu menu = (Menu) it.next();\n\n                for ( Iterator it2 = menu.getItems().iterator(); it2.hasNext(); )\n                {\n                    MenuItem item = (MenuItem) it2.next();\n\n                    DocumentTOCItem documentTOCItem = new DocumentTOCItem();\n                    documentTOCItem.setName( item.getName() );\n                    documentTOCItem.setRef( item.getHref() );\n                    toc.addItem( documentTOCItem );\n                }\n            }\n\n            docModel.setToc( toc );\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            File outputDir = new File( project.getBuild().getDirectory(), \"pdf\" );\n\n            if ( outputDir.isFile() )\n            {\n                throw new IOException( outputDir + \" is not a directory!\" );\n            }\n\n            if ( !outputDir.exists() )\n            {\n                outputDir.mkdirs();\n            }\n\n            File doc = FileUtils.createTempFile( \"pdf\", \".xml\", outputDir );\n\n            getLog().debug( \"Generated a default document model: \" + doc.getAbsolutePath() );\n\n            DocumentXpp3Writer xpp3 = new DocumentXpp3Writer();\n            Writer w = null;\n            try\n            {\n                w = WriterFactory.newXmlWriter( doc );\n                xpp3.write( w, docModel );\n            }\n            finally\n            {\n                IOUtil.close( w );\n            }\n        }\n\n        return docModel;\n    }","commit_id":"c6fdae3b4038307fc25a6dca336fe2d073a09a8a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Parse the decoration model to find the skin artifact and copy its resources to the output dir.\n     *\n     * @param locale not null\n     * @throws MojoExecutionException if any\n     * @see #getDefaultDecorationModel()\n     */\n    private void copyResources( Locale locale )\n        throws MojoExecutionException\n    {\n        DecorationModel decorationModel = getDefaultDecorationModel();\n\n        File skinFile;\n        try\n        {\n            skinFile =\n                siteTool.getSkinArtifactFromRepository( localRepository, project.getRemoteArtifactRepositories(),\n                                                        decorationModel ).getFile();\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n\n        if ( skinFile == null )\n        {\n            return;\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Copy resources from skin artifact: '\" + skinFile + \"'...\" );\n        }\n\n        try\n        {\n            SiteRenderingContext context =\n                siteRenderer.createContextForSkin( skinFile, new HashMap(), decorationModel, project.getName(),\n                                                   locale );\n            context.addSiteDirectory( new File( siteDirectory, locale.getLanguage() ) );\n\n            for ( Iterator i = context.getSiteDirectories().iterator(); i.hasNext(); )\n            {\n                File siteDirectoryFile = (File) i.next();\n\n                siteRenderer.copyResources( context, new File( siteDirectoryFile, \"resources\" ), workingDirectory );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"IOException: \" + e.getMessage(), e );\n        }\n    }","id":34008,"modified_method":"/**\n     * Parse the decoration model to find the skin artifact and copy its resources to the output dir.\n     *\n     * @param locale not null\n     * @throws MojoExecutionException if any\n     * @see #getDefaultDecorationModel()\n     */\n    private void copyResources( Locale locale )\n        throws MojoExecutionException\n    {\n        DecorationModel decorationModel = getDefaultDecorationModel();\n\n        if ( decorationModel == null )\n        {\n            return;\n        }\n\n        File skinFile;\n        try\n        {\n            skinFile =\n                siteTool.getSkinArtifactFromRepository( localRepository, project.getRemoteArtifactRepositories(),\n                                                        decorationModel ).getFile();\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n\n        if ( skinFile == null )\n        {\n            return;\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Copy resources from skin artifact: '\" + skinFile + \"'...\" );\n        }\n\n        try\n        {\n            SiteRenderingContext context =\n                siteRenderer.createContextForSkin( skinFile, new HashMap(), decorationModel, project.getName(),\n                                                   locale );\n            context.addSiteDirectory( new File( siteDirectory, locale.getLanguage() ) );\n\n            for ( Iterator i = context.getSiteDirectories().iterator(); i.hasNext(); )\n            {\n                File siteDirectoryFile = (File) i.next();\n\n                siteRenderer.copyResources( context, new File( siteDirectoryFile, \"resources\" ), workingDirectory );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"IOException: \" + e.getMessage(), e );\n        }\n    }","commit_id":"c6fdae3b4038307fc25a6dca336fe2d073a09a8a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( \"fo\".equals( implementation ) )\n        {\n            this.docRenderer = foRenderer;\n        }\n        else if ( \"itext\".equals( implementation ) )\n        {\n            this.docRenderer = itextRenderer;\n        }\n        else\n        {\n            throw new MojoFailureException( \"Not a valid implementation: \" + implementation );\n        }\n\n        try\n        {\n            List localesList = siteTool.getAvailableLocales( locales );\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                File workingDir = getWorkingDirectory( locale, defaultLocale );\n\n                File siteDirectoryFile = siteDirectory;\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n                }\n\n                // Copy extra-resources\n                copyResources( locale );\n\n                docRenderer.render( siteDirectoryFile, workingDir, getDocumentModel() );\n            }\n\n            if ( !outputDirectory.getCanonicalPath().equals( workingDirectory.getCanonicalPath() ) )\n            {\n                List pdfs = FileUtils.getFiles( workingDirectory, \"**/*.pdf\", null );\n                for ( Iterator it = pdfs.iterator(); it.hasNext(); )\n                {\n                    File pdf = (File) it.next();\n\n                    FileUtils.copyFile( pdf, new File( outputDirectory, pdf.getName() ) );\n                    pdf.delete();\n                }\n            }\n        }\n        catch ( DocumentRendererException e )\n        {\n            throw new MojoExecutionException( \"Error during document generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during document generation\", e );\n        }\n    }","id":34009,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( \"fo\".equals( implementation ) )\n        {\n            this.docRenderer = foRenderer;\n        }\n        else if ( \"itext\".equals( implementation ) )\n        {\n            this.docRenderer = itextRenderer;\n        }\n        else\n        {\n            throw new MojoFailureException( \"Not a valid implementation: \" + implementation );\n        }\n\n        try\n        {\n            List localesList = siteTool.getAvailableLocales( locales );\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                File workingDir = getWorkingDirectory( locale, defaultLocale );\n\n                File siteDirectoryFile = siteDirectory;\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n                }\n\n                // Copy extra-resources\n                copyResources( locale );\n\n                docRenderer.render( siteDirectoryFile, workingDir, getDocumentModel( locale ) );\n            }\n\n            if ( !outputDirectory.getCanonicalPath().equals( workingDirectory.getCanonicalPath() ) )\n            {\n                List pdfs = FileUtils.getFiles( workingDirectory, \"**/*.pdf\", null );\n                for ( Iterator it = pdfs.iterator(); it.hasNext(); )\n                {\n                    File pdf = (File) it.next();\n\n                    FileUtils.copyFile( pdf, new File( outputDirectory, pdf.getName() ) );\n                    pdf.delete();\n                }\n            }\n        }\n        catch ( DocumentRendererException e )\n        {\n            throw new MojoExecutionException( \"Error during document generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during document generation\", e );\n        }\n    }","commit_id":"c6fdae3b4038307fc25a6dca336fe2d073a09a8a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Constructs a DocumentModel for the current project. The model is either read from\n     * a descriptor file, if it exists, or constructed from information in the pom and site.xml.\n     *\n     * @return DocumentModel.\n     * @throws DocumentRendererException if any.\n     * @throws IOException if any.\n     * @throws MojoExecutionException if any\n     * @see #readAndFilterDocumentDescriptor(MavenProject, File, Log)\n     */\n    private DocumentModel getDocumentModel()\n        throws DocumentRendererException, IOException, MojoExecutionException\n    {\n        if ( docDescriptor.exists() )\n        {\n            return readAndFilterDocumentDescriptor( project, docDescriptor, getLog() );\n        }\n\n        return generateDefaultDocDescriptor();\n    }","id":34010,"modified_method":"/**\n     * Constructs a DocumentModel for the current project. The model is either read from\n     * a descriptor file, if it exists, or constructed from information in the pom and site.xml.\n     *\n     * @param locale not null\n     * @return DocumentModel.\n     * @throws DocumentRendererException if any.\n     * @throws IOException if any.\n     * @throws MojoExecutionException if any\n     * @see #readAndFilterDocumentDescriptor(MavenProject, File, Log)\n     */\n    private DocumentModel getDocumentModel( Locale locale )\n        throws DocumentRendererException, IOException, MojoExecutionException\n    {\n        if ( docDescriptor.exists() )\n        {\n            DocumentModel doc = readAndFilterDocumentDescriptor( project, docDescriptor, getLog() );\n            if ( StringUtils.isEmpty( doc.getMeta().getLanguage() ) )\n            {\n                doc.getMeta().setLanguage( locale.getLanguage() );\n            }\n            if ( StringUtils.isEmpty( doc.getMeta().getGenerator() ) )\n            {\n                doc.getMeta().setGenerator( getDefaultGenerator() );\n            }\n            return doc;\n        }\n\n        return generateDefaultDocDescriptor( locale );\n    }","commit_id":"c6fdae3b4038307fc25a6dca336fe2d073a09a8a","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void saveXWikiDoc(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null) {\n                monitor.startTimer(\"hibernate\");\n            }\n            doc.setStore(this);\n            // Make sure the database name is stored\n            doc.setDatabase(context.getWikiId());\n\n            // If the comment is larger than the max size supported by the Storage, then abbreviate it\n            String comment = doc.getComment();\n            if (comment != null && comment.length() > 1023) {\n                doc.setComment(StringUtils.abbreviate(comment, 1023));\n            }\n\n            if (bTransaction) {\n                checkHibernate(context);\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            // These informations will allow to not look for attachments and objects on loading\n            doc.setElement(XWikiDocument.HAS_ATTACHMENTS, (doc.getAttachmentList().size() != 0));\n            doc.setElement(XWikiDocument.HAS_OBJECTS, (doc.getXObjects().size() != 0));\n\n            // Let's update the class XML since this is the new way to store it\n            // TODO If all the properties are removed, the old xml stays?\n            BaseClass bclass = doc.getXClass();\n            if (bclass != null) {\n                if (bclass.getFieldList().size() > 0) {\n                    doc.setXClassXML(bclass.toXMLString());\n                } else {\n                    doc.setXClassXML(\"\");\n                }\n                bclass.setDirty(false);\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS)) {\n                saveAttachmentList(doc, context, false);\n            }\n            // Remove attachments planned for removal\n            if (doc.getAttachmentsToRemove().size() > 0) {\n                for (XWikiAttachmentToRemove attachment : doc.getAttachmentsToRemove()) {\n                    context.getWiki().getAttachmentStore()\n                        .deleteXWikiAttachment(attachment.getAttachment(), false, context, false);\n                }\n                doc.clearAttachmentsToRemove();\n            }\n\n            // Handle the latest text file\n            if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                Date ndate = new Date();\n                doc.setDate(ndate);\n                if (doc.isContentDirty()) {\n                    doc.setContentUpdateDate(ndate);\n                    doc.setContentAuthorReference(doc.getAuthorReference());\n                }\n                doc.incrementVersion();\n                if (context.getWiki().hasVersioning(context)) {\n                    context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                }\n\n                doc.setContentDirty(false);\n                doc.setMetaDataDirty(false);\n            } else {\n                if (doc.getDocumentArchive() != null) {\n                    // A custom document archive has been provided, we assume it's right\n                    // (we also assume it's custom but that's another matter...)\n                    // Let's make sure we save the archive if we have one\n                    // This is especially needed if we load a document from XML\n                    if (context.getWiki().hasVersioning(context)) {\n                        context.getWiki().getVersioningStore()\n                            .saveXWikiDocArchive(doc.getDocumentArchive(), false, context);\n\n                        // If the version does not exist it means it's a new version so add it to the history\n                        if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                            context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                        }\n                    }\n                } else {\n                    // Make sure the getArchive call has been made once\n                    // with a valid context\n                    try {\n                        if (context.getWiki().hasVersioning(context)) {\n                            doc.getDocumentArchive(context);\n\n                            // If the version does not exist it means it's a new version so register it in the history\n                            if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                                context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                            }\n                        }\n                    } catch (XWikiException e) {\n                        // this is a non critical error\n                    }\n                }\n            }\n\n            // Verify if the document already exists\n            Query query =\n                session.createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n            query.setLong(\"id\", doc.getId());\n            if (query.uniqueResult() == null) {\n                // Reset the creationDate to reflect the date of the first save, not the date of the object creation\n                doc.setCreationDate(new Date());\n                session.save(doc);\n            } else {\n                session.update(doc);\n                // TODO: this is slower!! How can it be improved?\n                // session.saveOrUpdate(doc);\n            }\n\n            // Remove objects planned for removal\n            if (doc.getXObjectsToRemove().size() > 0) {\n                for (BaseObject removedObject : doc.getXObjectsToRemove()) {\n                    deleteXWikiCollection(removedObject, context, false, false);\n                }\n                doc.setXObjectsToRemove(new ArrayList<BaseObject>());\n            }\n\n            if (bclass != null) {\n                bclass.setDocumentReference(doc.getDocumentReference());\n                // Store this XWikiClass in the context so that we can use it in case of recursive usage of classes\n                context.addBaseClass(bclass);\n                // Update instances of the class, in case some properties changed their storage type\n\n                // In case the current document has both a class and instances of that class, we have to take care\n                // not to insert duplicate entities in the session\n                Map<Long, BaseObject> localClassObjects = new HashMap<Long, BaseObject>();\n                if (doc.hasElement(XWikiDocument.HAS_OBJECTS) && doc.getXObjects(doc.getDocumentReference()) != null) {\n                    for (BaseObject obj : doc.getXObjects(doc.getDocumentReference())) {\n                        if (obj != null) {\n                            localClassObjects.put(obj.getId(), obj);\n                        }\n                    }\n                }\n                for (PropertyClass prop : (Collection<PropertyClass>) bclass.getFieldList()) {\n                    // migrate values of list properties\n                    if (prop instanceof StaticListClass || prop instanceof DBListClass) {\n                        ListClass lc = (ListClass) prop;\n                        String[] classes =\n                            {DBStringListProperty.class.getName(), StringListProperty.class.getName(),\n                            StringProperty.class.getName()}; // @see ListClass#newProperty()\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(lc.newProperty().getClass().getName())) {\n                                Query q = session.createQuery(\"select p from \" + oldclass + \" as p, BaseObject as o\"\n                                    + \" where o.className=? and p.id=o.id and p.name=?\");\n                                q.setString(0, bclass.getName()).setString(1, lc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty lp = (BaseProperty) it.next();\n                                    BaseProperty lp1 = lc.newProperty();\n                                    lp1.setId(lp.getId());\n                                    lp1.setName(lp.getName());\n                                    if (lc.isMultiSelect()) {\n                                        List tmp;\n                                        if (lp.getValue() instanceof List) {\n                                            tmp = (List) lp.getValue();\n                                        } else {\n                                            tmp = new ArrayList<String>(1);\n                                            tmp.add(lp.getValue());\n                                        }\n                                        lp1.setValue(tmp);\n                                    } else {\n                                        Object tmp = lp.getValue();\n                                        if (tmp instanceof List && ((List) tmp).size() > 0) {\n                                            tmp = ((List) tmp).get(0);\n                                        }\n                                        lp1.setValue(tmp);\n                                    }\n                                    session.delete(lp);\n                                    session.save(lp1);\n                                }\n                            }\n                        }\n                    }\n                    // migrate values of list properties\n                    else if (prop instanceof NumberClass) {\n                        NumberClass numberClass = (NumberClass) prop;\n                        // @see NumberClass#newProperty()\n                        String[] numberPropertyTypes =\n                            {IntegerProperty.class.getName(), LongProperty.class.getName(),\n                            FloatProperty.class.getName(), DoubleProperty.class.getName()};\n                        for (String numberPropertyType : numberPropertyTypes) {\n                            if (!numberPropertyType.equals(numberClass.newProperty().getClass().getName())) {\n                                Query q = session.createQuery(\"select p from \" + numberPropertyType\n                                    + \" as p, BaseObject as o where o.className=?  and p.id=o.id and p.name=?\");\n                                q.setString(0, bclass.getName()).setString(1, numberClass.getName());\n                                for (BaseProperty oldProperty : (List<BaseProperty>) q.list()) {\n                                    BaseProperty newProperty = numberClass.newProperty();\n                                    newProperty.setId(oldProperty.getId());\n                                    newProperty.setName(oldProperty.getName());\n                                    Number oldValue = (Number) oldProperty.getValue();\n                                    if (oldValue != null) {\n                                        // Convert the old value to the new number type.\n                                        if (numberClass.getNumberType().equals(\"integer\")) {\n                                            newProperty.setValue(Integer.valueOf(oldValue.intValue()));\n                                        } else if (numberClass.getNumberType().equals(\"float\")) {\n                                            newProperty.setValue(Float.valueOf(oldValue.floatValue()));\n                                        } else if (numberClass.getNumberType().equals(\"double\")) {\n                                            newProperty.setValue(Double.valueOf(oldValue.doubleValue()));\n                                        } else if (numberClass.getNumberType().equals(\"long\")) {\n                                            newProperty.setValue(Long.valueOf(oldValue.longValue()));\n                                        }\n                                    }\n                                    session.delete(oldProperty);\n                                    session.save(newProperty);\n                                }\n                            }\n                        }\n                    } else {\n                        // General migration of properties\n                        Query q = session.createQuery(\"select p from BaseProperty as p, BaseObject as o\"\n                            + \" where o.className=? and p.id=o.id and p.name=? and p.classType <> ?\");\n                        q.setString(0, bclass.getName());\n                        q.setString(1, prop.getName());\n                        q.setString(2, prop.newProperty().getClassType());\n                        @SuppressWarnings(\"unchecked\")\n                        List<BaseProperty> brokenProperties = q.list();\n                        for (BaseProperty brokenProperty : brokenProperties) {\n                            BaseProperty newProperty = prop.fromString(brokenProperty.toText());\n                            BaseObject localObject = localClassObjects.get(brokenProperty.getId());\n                            if (localObject != null) {\n                                BaseProperty currentProperty = (BaseProperty) localObject.get(prop.getName());\n                                if (currentProperty != null) {\n                                    newProperty = prop.fromString(currentProperty.toText());\n                                    if (newProperty != null) {\n                                        localObject.put(prop.getName(), newProperty);\n                                    } else {\n                                        localObject.put(prop.getName(), brokenProperty);\n                                    }\n                                }\n                            }\n                            if (newProperty == null) {\n                                this.logger.warn(\"Incompatible data migration when changing field {} of class {}\",\n                                    prop.getName(), prop.getClassName());\n                                continue;\n                            }\n                            newProperty.setId(brokenProperty.getId());\n                            session.delete(brokenProperty);\n                            session.save(newProperty);\n                        }\n                    }\n                }\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                // TODO: Delete all objects for which we don't have a name in the Map\n                for (List<BaseObject> objects : doc.getXObjects().values()) {\n                    for (BaseObject obj : objects) {\n                        if (obj != null) {\n                            obj.setDocumentReference(doc.getDocumentReference());\n                            /* If the object doesn't have a GUID, create it before saving */\n                            if (StringUtils.isEmpty(obj.getGuid())) {\n                                obj.setGuid(UUID.randomUUID().toString());\n                            }\n                            saveXWikiCollection(obj, context, false);\n                        }\n                    }\n                }\n            }\n\n            if (context.getWiki().hasBacklinks(context)) {\n                try {\n                    saveLinks(doc, context, true);\n                } catch (Exception e) {\n                    this.logger\n                        .error(\"Failed to save links for document [{}]\", doc.getDocumentReferenceWithLocale(), e);\n                }\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n\n            doc.setNew(false);\n\n            // We need to ensure that the saved document becomes the original document\n            doc.setOriginalDocument(doc.clone());\n\n        } catch (Exception e) {\n            Object[] args = {this.defaultEntityReferenceSerializer.serialize(doc.getDocumentReference())};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC, \"Exception while saving document {0}\", e, args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null) {\n                monitor.endTimer(\"hibernate\");\n            }\n        }\n    }","id":34011,"modified_method":"@Override\n    public void saveXWikiDoc(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null) {\n                monitor.startTimer(\"hibernate\");\n            }\n            doc.setStore(this);\n            // Make sure the database name is stored\n            doc.setDatabase(context.getWikiId());\n\n            // If the comment is larger than the max size supported by the Storage, then abbreviate it\n            String comment = doc.getComment();\n            if (comment != null && comment.length() > 1023) {\n                doc.setComment(StringUtils.abbreviate(comment, 1023));\n            }\n\n            if (bTransaction) {\n                checkHibernate(context);\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            // These informations will allow to not look for attachments and objects on loading\n            doc.setElement(XWikiDocument.HAS_ATTACHMENTS, (doc.getAttachmentList().size() != 0));\n            doc.setElement(XWikiDocument.HAS_OBJECTS, (doc.getXObjects().size() != 0));\n\n            // Let's update the class XML since this is the new way to store it\n            // TODO If all the properties are removed, the old xml stays?\n            BaseClass bclass = doc.getXClass();\n            if (bclass != null) {\n                if (bclass.getFieldList().size() > 0) {\n                    doc.setXClassXML(bclass.toXMLString());\n                } else {\n                    doc.setXClassXML(\"\");\n                }\n                bclass.setDirty(false);\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS)) {\n                saveAttachmentList(doc, context, false);\n            }\n            // Remove attachments planned for removal\n            if (doc.getAttachmentsToRemove().size() > 0) {\n                for (XWikiAttachmentToRemove attachment : doc.getAttachmentsToRemove()) {\n                    context.getWiki().getAttachmentStore()\n                        .deleteXWikiAttachment(attachment.getAttachment(), false, context, false);\n                }\n                doc.clearAttachmentsToRemove();\n            }\n\n            // Handle the latest text file\n            if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                Date ndate = new Date();\n                doc.setDate(ndate);\n                if (doc.isContentDirty()) {\n                    doc.setContentUpdateDate(ndate);\n                    doc.setContentAuthorReference(doc.getAuthorReference());\n                }\n                doc.incrementVersion();\n                if (context.getWiki().hasVersioning(context)) {\n                    context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                }\n\n                doc.setContentDirty(false);\n                doc.setMetaDataDirty(false);\n            } else {\n                if (doc.getDocumentArchive() != null) {\n                    // A custom document archive has been provided, we assume it's right\n                    // (we also assume it's custom but that's another matter...)\n                    // Let's make sure we save the archive if we have one\n                    // This is especially needed if we load a document from XML\n                    if (context.getWiki().hasVersioning(context)) {\n                        context.getWiki().getVersioningStore()\n                            .saveXWikiDocArchive(doc.getDocumentArchive(), false, context);\n\n                        // If the version does not exist it means it's a new version so add it to the history\n                        if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                            context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                        }\n                    }\n                } else {\n                    // Make sure the getArchive call has been made once\n                    // with a valid context\n                    try {\n                        if (context.getWiki().hasVersioning(context)) {\n                            doc.getDocumentArchive(context);\n\n                            // If the version does not exist it means it's a new version so register it in the history\n                            if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                                context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                            }\n                        }\n                    } catch (XWikiException e) {\n                        // this is a non critical error\n                    }\n                }\n            }\n\n            // Verify if the document already exists\n            Query query =\n                session.createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n            query.setLong(\"id\", doc.getId());\n            if (query.uniqueResult() == null) {\n                if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                    // Reset the creationDate to reflect the date of the first save, not the date of the object creation\n                    doc.setCreationDate(new Date());\n                }\n                session.save(doc);\n            } else {\n                session.update(doc);\n                // TODO: this is slower!! How can it be improved?\n                // session.saveOrUpdate(doc);\n            }\n\n            // Remove objects planned for removal\n            if (doc.getXObjectsToRemove().size() > 0) {\n                for (BaseObject removedObject : doc.getXObjectsToRemove()) {\n                    deleteXWikiCollection(removedObject, context, false, false);\n                }\n                doc.setXObjectsToRemove(new ArrayList<BaseObject>());\n            }\n\n            if (bclass != null) {\n                bclass.setDocumentReference(doc.getDocumentReference());\n                // Store this XWikiClass in the context so that we can use it in case of recursive usage of classes\n                context.addBaseClass(bclass);\n                // Update instances of the class, in case some properties changed their storage type\n\n                // In case the current document has both a class and instances of that class, we have to take care\n                // not to insert duplicate entities in the session\n                Map<Long, BaseObject> localClassObjects = new HashMap<Long, BaseObject>();\n                if (doc.hasElement(XWikiDocument.HAS_OBJECTS) && doc.getXObjects(doc.getDocumentReference()) != null) {\n                    for (BaseObject obj : doc.getXObjects(doc.getDocumentReference())) {\n                        if (obj != null) {\n                            localClassObjects.put(obj.getId(), obj);\n                        }\n                    }\n                }\n                for (PropertyClass prop : (Collection<PropertyClass>) bclass.getFieldList()) {\n                    // migrate values of list properties\n                    if (prop instanceof StaticListClass || prop instanceof DBListClass) {\n                        ListClass lc = (ListClass) prop;\n                        String[] classes =\n                            {DBStringListProperty.class.getName(), StringListProperty.class.getName(),\n                            StringProperty.class.getName()}; // @see ListClass#newProperty()\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(lc.newProperty().getClass().getName())) {\n                                Query q = session.createQuery(\"select p from \" + oldclass + \" as p, BaseObject as o\"\n                                    + \" where o.className=? and p.id=o.id and p.name=?\");\n                                q.setString(0, bclass.getName()).setString(1, lc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty lp = (BaseProperty) it.next();\n                                    BaseProperty lp1 = lc.newProperty();\n                                    lp1.setId(lp.getId());\n                                    lp1.setName(lp.getName());\n                                    if (lc.isMultiSelect()) {\n                                        List tmp;\n                                        if (lp.getValue() instanceof List) {\n                                            tmp = (List) lp.getValue();\n                                        } else {\n                                            tmp = new ArrayList<String>(1);\n                                            tmp.add(lp.getValue());\n                                        }\n                                        lp1.setValue(tmp);\n                                    } else {\n                                        Object tmp = lp.getValue();\n                                        if (tmp instanceof List && ((List) tmp).size() > 0) {\n                                            tmp = ((List) tmp).get(0);\n                                        }\n                                        lp1.setValue(tmp);\n                                    }\n                                    session.delete(lp);\n                                    session.save(lp1);\n                                }\n                            }\n                        }\n                    }\n                    // migrate values of list properties\n                    else if (prop instanceof NumberClass) {\n                        NumberClass numberClass = (NumberClass) prop;\n                        // @see NumberClass#newProperty()\n                        String[] numberPropertyTypes =\n                            {IntegerProperty.class.getName(), LongProperty.class.getName(),\n                            FloatProperty.class.getName(), DoubleProperty.class.getName()};\n                        for (String numberPropertyType : numberPropertyTypes) {\n                            if (!numberPropertyType.equals(numberClass.newProperty().getClass().getName())) {\n                                Query q = session.createQuery(\"select p from \" + numberPropertyType\n                                    + \" as p, BaseObject as o where o.className=?  and p.id=o.id and p.name=?\");\n                                q.setString(0, bclass.getName()).setString(1, numberClass.getName());\n                                for (BaseProperty oldProperty : (List<BaseProperty>) q.list()) {\n                                    BaseProperty newProperty = numberClass.newProperty();\n                                    newProperty.setId(oldProperty.getId());\n                                    newProperty.setName(oldProperty.getName());\n                                    Number oldValue = (Number) oldProperty.getValue();\n                                    if (oldValue != null) {\n                                        // Convert the old value to the new number type.\n                                        if (numberClass.getNumberType().equals(\"integer\")) {\n                                            newProperty.setValue(Integer.valueOf(oldValue.intValue()));\n                                        } else if (numberClass.getNumberType().equals(\"float\")) {\n                                            newProperty.setValue(Float.valueOf(oldValue.floatValue()));\n                                        } else if (numberClass.getNumberType().equals(\"double\")) {\n                                            newProperty.setValue(Double.valueOf(oldValue.doubleValue()));\n                                        } else if (numberClass.getNumberType().equals(\"long\")) {\n                                            newProperty.setValue(Long.valueOf(oldValue.longValue()));\n                                        }\n                                    }\n                                    session.delete(oldProperty);\n                                    session.save(newProperty);\n                                }\n                            }\n                        }\n                    } else {\n                        // General migration of properties\n                        Query q = session.createQuery(\"select p from BaseProperty as p, BaseObject as o\"\n                            + \" where o.className=? and p.id=o.id and p.name=? and p.classType <> ?\");\n                        q.setString(0, bclass.getName());\n                        q.setString(1, prop.getName());\n                        q.setString(2, prop.newProperty().getClassType());\n                        @SuppressWarnings(\"unchecked\")\n                        List<BaseProperty> brokenProperties = q.list();\n                        for (BaseProperty brokenProperty : brokenProperties) {\n                            BaseProperty newProperty = prop.fromString(brokenProperty.toText());\n                            BaseObject localObject = localClassObjects.get(brokenProperty.getId());\n                            if (localObject != null) {\n                                BaseProperty currentProperty = (BaseProperty) localObject.get(prop.getName());\n                                if (currentProperty != null) {\n                                    newProperty = prop.fromString(currentProperty.toText());\n                                    if (newProperty != null) {\n                                        localObject.put(prop.getName(), newProperty);\n                                    } else {\n                                        localObject.put(prop.getName(), brokenProperty);\n                                    }\n                                }\n                            }\n                            if (newProperty == null) {\n                                this.logger.warn(\"Incompatible data migration when changing field {} of class {}\",\n                                    prop.getName(), prop.getClassName());\n                                continue;\n                            }\n                            newProperty.setId(brokenProperty.getId());\n                            session.delete(brokenProperty);\n                            session.save(newProperty);\n                        }\n                    }\n                }\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                // TODO: Delete all objects for which we don't have a name in the Map\n                for (List<BaseObject> objects : doc.getXObjects().values()) {\n                    for (BaseObject obj : objects) {\n                        if (obj != null) {\n                            obj.setDocumentReference(doc.getDocumentReference());\n                            /* If the object doesn't have a GUID, create it before saving */\n                            if (StringUtils.isEmpty(obj.getGuid())) {\n                                obj.setGuid(UUID.randomUUID().toString());\n                            }\n                            saveXWikiCollection(obj, context, false);\n                        }\n                    }\n                }\n            }\n\n            if (context.getWiki().hasBacklinks(context)) {\n                try {\n                    saveLinks(doc, context, true);\n                } catch (Exception e) {\n                    this.logger\n                        .error(\"Failed to save links for document [{}]\", doc.getDocumentReferenceWithLocale(), e);\n                }\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n\n            doc.setNew(false);\n\n            // We need to ensure that the saved document becomes the original document\n            doc.setOriginalDocument(doc.clone());\n\n        } catch (Exception e) {\n            Object[] args = {this.defaultEntityReferenceSerializer.serialize(doc.getDocumentReference())};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC, \"Exception while saving document {0}\", e, args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null) {\n                monitor.endTimer(\"hibernate\");\n            }\n        }\n    }","commit_id":"7641e57612b65591c0fd00659042435e37a1a040","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return Indicate of the authors comming from the events should be kept. Not taken into account if\n     *         {@link #setAuthor(DocumentReference)} is used.\n     */\n    @PropertyName(\"Preserve author\")\n    @PropertyDescription(\n        \"Indicate of the authors comming from the events should be kept. Not taken into account if AUTHOR is set\")\n    public boolean isAuthorPreserved()\n    {\n        return authorPreserved;\n    }","id":34012,"modified_method":"/**\n     * @return Indicate if the authors coming from the events should be kept.\n     */\n    @PropertyName(\"Preserve author\")\n    @PropertyDescription(\n        \"Indicate if the authors comming from the events should be kept. Not taken into account if AUTHOR is set\")\n    public boolean isAuthorPreserved()\n    {\n        return authorPreserved;\n    }","commit_id":"82bbef06b6e8b4e3bef74d86ced4e755ebd97dc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return Indicate of existing document should be deleted before importing the new one\n     */\n    @PropertyName(\"Delete existing document\")\n    @PropertyDescription(\"Indicate of existing document should be deleted before importing the new one\")\n    public boolean isPreviousDeleted()\n    {\n        return this.previousDeleted;\n    }","id":34013,"modified_method":"/**\n     * @return Indicate if existing document should be deleted before importing the new one\n     */\n    @PropertyName(\"Delete existing document\")\n    @PropertyDescription(\"Indicate if existing document should be deleted before importing the new one\")\n    public boolean isPreviousDeleted()\n    {\n        return this.previousDeleted;\n    }","commit_id":"82bbef06b6e8b4e3bef74d86ced4e755ebd97dc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void onWikiAttachment(String name, InputStream content, Long size, FilterEventParameters parameters)\n        throws WikiStreamException\n    {\n        XWikiAttachment attachment = new XWikiAttachment(this.currentDocument, name);\n\n        attachment.setAuthor(\"\");\n\n        try {\n            attachment.setContent(content);\n        } catch (IOException e) {\n            throw new WikiStreamException(\"Failed to set attachment content\", e);\n        }\n\n        if (this.properties.isAuthorSet()) {\n            // TODO\n        }\n\n        if (this.properties.isVersionPreserved()) {\n            if (parameters.containsKey(WikiAttachmentFilter.PARAMETER_REVISION)) {\n                attachment.setVersion(getString(WikiAttachmentFilter.PARAMETER_REVISION, parameters, null));\n            }\n            attachment.setAuthor(getString(WikiAttachmentFilter.PARAMETER_REVISION_AUTHOR, parameters, \"\"));\n            attachment.setComment(getString(WikiAttachmentFilter.PARAMETER_REVISION_COMMENT, parameters, null));\n            attachment.setDate(getDate(WikiAttachmentFilter.PARAMETER_REVISION_DATE, parameters, null));\n\n            String revisions = getString(XWikiWikiAttachmentFilter.PARAMETER_JRCSREVISIONS, parameters, null);\n            if (revisions != null) {\n                try {\n                    attachment.setArchive(revisions);\n                } catch (XWikiException e) {\n                    throw new WikiStreamException(\"Failed to set attachment archive\", e);\n                }\n            }\n\n            attachment.setMetaDataDirty(false);\n        }\n\n        this.currentDocument.getAttachmentList().add(attachment);\n    }","id":34014,"modified_method":"@Override\n    public void onWikiAttachment(String name, InputStream content, Long size, FilterEventParameters parameters)\n        throws WikiStreamException\n    {\n        XWikiAttachment attachment = new XWikiAttachment(this.currentDocument, name);\n\n        attachment.setAuthor(\"\");\n\n        try {\n            attachment.setContent(content);\n        } catch (IOException e) {\n            throw new WikiStreamException(\"Failed to set attachment content\", e);\n        }\n\n        // Author\n\n        if (this.properties.isAuthorPreserved()) {\n            attachment.setAuthor(getString(WikiAttachmentFilter.PARAMETER_REVISION_AUTHOR, parameters, \"\"));            \n        } else {\n            attachment.setAuthor(this.xcontextProvider.get().getUser());            \n        }\n\n        // Version\n\n        if (this.properties.isVersionPreserved()) {\n            if (parameters.containsKey(WikiAttachmentFilter.PARAMETER_REVISION)) {\n                attachment.setVersion(getString(WikiAttachmentFilter.PARAMETER_REVISION, parameters, null));\n            }\n            attachment.setComment(getString(WikiAttachmentFilter.PARAMETER_REVISION_COMMENT, parameters, null));\n            attachment.setDate(getDate(WikiAttachmentFilter.PARAMETER_REVISION_DATE, parameters, null));\n\n            String revisions = getString(XWikiWikiAttachmentFilter.PARAMETER_JRCSREVISIONS, parameters, null);\n            if (revisions != null) {\n                try {\n                    attachment.setArchive(revisions);\n                } catch (XWikiException e) {\n                    throw new WikiStreamException(\"Failed to set attachment archive\", e);\n                }\n            }\n\n            attachment.setMetaDataDirty(false);\n        }\n\n        this.currentDocument.getAttachmentList().add(attachment);\n    }","commit_id":"82bbef06b6e8b4e3bef74d86ced4e755ebd97dc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        // Set content\n        if (this.currentWikiPrinter != null) {\n            this.currentDocument.setContent(this.currentWikiPrinter.getBuffer().toString());\n\n            this.contentListener.setWrappedListener(null);\n            this.currentWikiPrinter = null;\n        }\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            XWikiDocument document =\n                xcontext.getWiki().getDocument(this.currentDocument.getDocumentReferenceWithLocale(), xcontext);\n\n            if (document.isNew()) {\n                document = this.currentDocument;\n            } else {\n                document.loadAttachmentsContent(xcontext);\n                document.apply(this.currentDocument);\n            }\n\n            // Default author\n\n            if (this.properties.isAuthorSet()) {\n                if (document.isNew()) {\n                    document.setCreatorReference(this.properties.getAuthor());\n                }\n                document.setAuthorReference(this.properties.getAuthor());\n                document.setContentAuthorReference(this.properties.getAuthor());\n            }\n\n            // Versions and save document\n\n            if (this.properties.isVersionPreserved()) {\n                if (document.isNew()) {\n                    document.setCreationDate(this.currentCreationDate);\n                    document.setCreator(this.currentCreationAuthor);\n\n                    String revisions = getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, parameters, null);\n                    if (revisions != null) {\n                        try {\n                            document.setDocumentArchive(revisions);\n                        } catch (XWikiException e) {\n                            throw new WikiStreamException(\"Failed to set attachment archive\", e);\n                        }\n                    }\n                }\n\n                document.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n                document.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n                document.setAuthor(getString(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR, parameters, null));\n                document.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n                document.setContentAuthor(getString(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, null));\n                document\n                    .setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n                document.setVersion(version);\n\n                document.setMetaDataDirty(false);\n                document.setContentDirty(false);\n\n                xcontext.getWiki().saveDocument(document, document.getComment(), document.isMinorEdit(), xcontext);\n            } else {\n                xcontext.getWiki().saveDocument(document, this.properties.getSaveComment(), xcontext);\n            }\n        } catch (Exception e) {\n            throw new WikiStreamException(\"Failed to save document\", e);\n        }\n\n        // Cleanup\n\n        this.currentVersion = null;\n        this.currentDocument = null;\n    }","id":34015,"modified_method":"@Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        // Set content\n        if (this.currentWikiPrinter != null) {\n            this.currentDocument.setContent(this.currentWikiPrinter.getBuffer().toString());\n\n            this.contentListener.setWrappedListener(null);\n            this.currentWikiPrinter = null;\n        }\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            XWikiDocument document =\n                xcontext.getWiki().getDocument(this.currentDocument.getDocumentReferenceWithLocale(), xcontext);\n\n            if (document.isNew()) {\n                document = this.currentDocument;\n            } else {\n                if (this.properties.isPreviousDeleted()) {\n                    xcontext.getWiki().deleteDocument(document, xcontext);\n                    document = this.currentDocument;\n                } else {\n                    document.loadAttachmentsContent(xcontext);\n                    document.apply(this.currentDocument);\n                }\n            }\n\n            document.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n\n            // Author\n\n            if (this.properties.isAuthorPreserved()) {\n                if (document.isNew()) {\n                    document.setCreator(this.currentCreationAuthor);\n                }\n                document.setAuthor(getString(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR, parameters, null));\n                document.setContentAuthor(getString(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, null));\n            } else {\n                if (document.isNew()) {\n                    document.setCreatorReference(xcontext.getUserReference());\n                }\n                document.setAuthorReference(xcontext.getUserReference());\n                document.setContentAuthorReference(xcontext.getUserReference());\n            }\n\n            // Versions and save document\n\n            // Don't preserve version or history if we don't delete the previous document\n            if (document.isNew() && this.properties.isVersionPreserved()) {\n                String revisions = getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, parameters, null);\n                if (revisions != null) {\n                    try {\n                        document.setDocumentArchive(revisions);\n                    } catch (XWikiException e) {\n                        throw new WikiStreamException(\"Failed to set attachment archive\", e);\n                    }\n                }\n\n                document.setCreationDate(this.currentCreationDate);\n                document.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n                document.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n                document\n                    .setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n                document.setVersion(version);\n\n                document.setMetaDataDirty(false);\n                document.setContentDirty(false);\n\n                xcontext.getWiki().saveDocument(document, document.getComment(), document.isMinorEdit(), xcontext);\n            } else {\n                xcontext.getWiki().saveDocument(document, this.properties.getSaveComment(), xcontext);\n            }\n        } catch (Exception e) {\n            throw new WikiStreamException(\"Failed to save document\", e);\n        }\n\n        // Cleanup\n\n        this.currentVersion = null;\n        this.currentDocument = null;\n    }","commit_id":"82bbef06b6e8b4e3bef74d86ced4e755ebd97dc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void addToolBar()\n\t{\n\n\t\ttry {\n\t\t\ttoolbar = XulHelper.createToolbar(XUL_FILE_TRANS_GRID_TOOLBAR, transGridComposite, TransGridDelegate.this, new XulMessages());\n\t\t\t\n\t\t\t\n\t\t\t// set the selected icon for the show inactive button.\n\t\t\t// This is not a XUL standard apparently\n\t\t\t//\n\t\t\tXulToolbarButton onlyActiveButton = toolbar.getButtonById(\"show-inactive\");\n\t\t\tif (onlyActiveButton!=null) {\n\t\t\t\tonlyActiveButton.setSelectedImage(GUIResource.getInstance().getImageHideInactive());\n\t\t\t}\n\t\t\n\t\t\t// Add a few default key listeners\n\t\t\t//\n\t\t\tToolBar toolBar = (ToolBar) toolbar.getNativeObject();\n\t\t\taddToolBarListeners();\n\t        toolBar.layout(true, true);\n\t\t} catch (Throwable t ) {\n\t\t\tlog.logError(Const.getStackTracker(t));\n\t\t\tnew ErrorDialog(transGridComposite.getShell(), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Title\"), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Message\", XUL_FILE_TRANS_GRID_TOOLBAR), new Exception(t));\n\t\t}\n\t}","id":34016,"modified_method":"private void addToolBar() {\n\n    try {\n      XulLoader loader = new SwtXulLoader();\n      ResourceBundle bundle = ResourceBundle.getBundle(\"org/pentaho/di/ui/spoon/messages/messages\", LanguageChoice.getInstance().getDefaultLocale());\n      XulDomContainer xulDomContainer = loader.loadXul(XUL_FILE_TRANS_GRID_TOOLBAR, bundle);\n      xulDomContainer.addEventHandler(this);\n      toolbar = (XulToolbar) xulDomContainer.getDocumentRoot().getElementById(\"nav-toolbar\");\n\n      ToolBar swtToolBar = (ToolBar) toolbar.getManagedObject();\n      swtToolBar.layout(true, true);\n    } catch (Throwable t) {\n      log.logError(toString(), Const.getStackTracker(t));\n      new ErrorDialog(transGridComposite.getShell(), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Title\"), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Message\", XUL_FILE_TRANS_GRID_TOOLBAR), new Exception(t));\n    }\n  }","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t *  Add a grid with the execution metrics per step in a table view\n\t *  \n\t */ \n\tpublic void addTransGrid() {\n\n\t\t// First, see if we need to add the extra view...\n\t\t//\n\t\tif (transGraph.extraViewComposite==null || transGraph.extraViewComposite.isDisposed()) {\n\t\t\ttransGraph.addExtraView();\n\t\t} else {\n\t\t\tif (transGridTab!=null && !transGridTab.isDisposed()) {\n\t\t\t\t// just set this one active and get out...\n\t\t\t\t//\n\t\t\t\ttransGraph.extraViewTabFolder.setSelection(transGridTab);\n\t\t\t\treturn; \n\t\t\t}\n\t\t}\n\n\t\ttransGridTab = new CTabItem(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransGridTab.setImage(GUIResource.getInstance().getImageShowGrid());\n\t\ttransGridTab.setText(BaseMessages.getString(PKG, \"Spoon.TransGraph.GridTab.Name\"));\n\n\t\ttransGridComposite = new Composite(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransGridComposite.setLayout(new FormLayout());\n\t\t\n\t\taddToolBar();\n\t\taddToolBarListeners();\n\t\t\n\t\tColumnInfo[] colinf = new ColumnInfo[] { \n                new ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Stepname\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Copynr\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Read\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Written\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Input\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Output\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Updated\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n                new ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Rejected\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Errors\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Active\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Time\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Speed\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.PriorityBufferSizes\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t};\n\n\t\tcolinf[1].setAllignement(SWT.RIGHT);\n\t\tcolinf[2].setAllignement(SWT.RIGHT);\n\t\tcolinf[3].setAllignement(SWT.RIGHT);\n\t\tcolinf[4].setAllignement(SWT.RIGHT);\n\t\tcolinf[5].setAllignement(SWT.RIGHT);\n\t\tcolinf[6].setAllignement(SWT.RIGHT);\n\t\tcolinf[7].setAllignement(SWT.RIGHT);\n\t\tcolinf[8].setAllignement(SWT.RIGHT);\n\t\tcolinf[9].setAllignement(SWT.LEFT);\n\t\tcolinf[10].setAllignement(SWT.RIGHT);\n\t\tcolinf[11].setAllignement(SWT.RIGHT);\n        colinf[12].setAllignement(SWT.RIGHT);\n\n\t\ttransGridView = new TableView(transGraph.getManagedObject(), transGridComposite, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, 1, true, // readonly!\n\t\t\t\tnull, // Listener\n\t\t\t\tspoon.props);\n\t\tFormData fdView = new FormData();\n\t\tfdView.left = new FormAttachment(0,0);\n\t\tfdView.right = new FormAttachment(100,0);\n\t\tfdView.top = new FormAttachment((Control)toolbar.getNativeObject(),0);\n\t\tfdView.bottom = new FormAttachment(100,0);\n\t\ttransGridView.setLayoutData(fdView);\n\t\t\n\t\t// Add a timer to update this view every couple of seconds...\n\t\t//\n\t\tfinal Timer tim = new Timer(\"TransGraph: \" + transGraph.getMeta().getName());\n        final AtomicBoolean busy = new AtomicBoolean(false);\n\n        TimerTask timtask = new TimerTask()\n        {\n            public void run()\n            {\n                if (!spoon.getDisplay().isDisposed())\n                {\n                    spoon.getDisplay().asyncExec(\n                        new Runnable()\n                        {\n                            public void run()\n                            {\n                                if (!busy.get())\n                                {\n                                    busy.set(true);\n                                    refreshView();\n                                    busy.set(false);\n                                }\n                            }\n                        }\n                    );\n                }\n            }\n        };\n\n        tim.schedule(timtask, 0L, REFRESH_TIME); // schedule to repeat a couple of times per second to get fast feedback \n\n        transGridTab.addDisposeListener(new DisposeListener() {\n\t\t\tpublic void widgetDisposed(DisposeEvent disposeEvent) {\n\t\t\t\ttim.cancel();\n\t\t\t}\n\t\t});\n\t\t\n\t\ttransGridTab.setControl(transGridComposite);\n\n\t\ttransGraph.extraViewTabFolder.setSelection(transGridTab);\t\t\n\t}","id":34017,"modified_method":"/**\n\t *  Add a grid with the execution metrics per step in a table view\n\t *  \n\t */ \n\tpublic void addTransGrid() {\n\n\t\t// First, see if we need to add the extra view...\n\t\t//\n\t\tif (transGraph.extraViewComposite==null || transGraph.extraViewComposite.isDisposed()) {\n\t\t\ttransGraph.addExtraView();\n\t\t} else {\n\t\t\tif (transGridTab!=null && !transGridTab.isDisposed()) {\n\t\t\t\t// just set this one active and get out...\n\t\t\t\t//\n\t\t\t\ttransGraph.extraViewTabFolder.setSelection(transGridTab);\n\t\t\t\treturn; \n\t\t\t}\n\t\t}\n\n\t\ttransGridTab = new CTabItem(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransGridTab.setImage(GUIResource.getInstance().getImageShowGrid());\n\t\ttransGridTab.setText(BaseMessages.getString(PKG, \"Spoon.TransGraph.GridTab.Name\"));\n\n\t\ttransGridComposite = new Composite(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransGridComposite.setLayout(new FormLayout());\n\t\t\n\t\taddToolBar();\n\t\t\n\t\tColumnInfo[] colinf = new ColumnInfo[] { \n                new ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Stepname\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Copynr\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Read\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Written\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Input\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Output\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Updated\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n                new ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Rejected\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Errors\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Active\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Time\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.Speed\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"TransLog.Column.PriorityBufferSizes\"), ColumnInfo.COLUMN_TYPE_TEXT, false, true), //$NON-NLS-1$\n\t\t};\n\n\t\tcolinf[1].setAllignement(SWT.RIGHT);\n\t\tcolinf[2].setAllignement(SWT.RIGHT);\n\t\tcolinf[3].setAllignement(SWT.RIGHT);\n\t\tcolinf[4].setAllignement(SWT.RIGHT);\n\t\tcolinf[5].setAllignement(SWT.RIGHT);\n\t\tcolinf[6].setAllignement(SWT.RIGHT);\n\t\tcolinf[7].setAllignement(SWT.RIGHT);\n\t\tcolinf[8].setAllignement(SWT.RIGHT);\n\t\tcolinf[9].setAllignement(SWT.LEFT);\n\t\tcolinf[10].setAllignement(SWT.RIGHT);\n\t\tcolinf[11].setAllignement(SWT.RIGHT);\n        colinf[12].setAllignement(SWT.RIGHT);\n\n\t\ttransGridView = new TableView(transGraph.getManagedObject(), transGridComposite, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, 1, true, // readonly!\n\t\t\t\tnull, // Listener\n\t\t\t\tspoon.props);\n\t\tFormData fdView = new FormData();\n\t\tfdView.left = new FormAttachment(0,0);\n\t\tfdView.right = new FormAttachment(100,0);\n\t\tfdView.top = new FormAttachment((Control)toolbar.getManagedObject(),0);\n\t\tfdView.bottom = new FormAttachment(100,0);\n\t\ttransGridView.setLayoutData(fdView);\n\t\t\n\t\t// Add a timer to update this view every couple of seconds...\n\t\t//\n\t\tfinal Timer tim = new Timer(\"TransGraph: \" + transGraph.getMeta().getName());\n        final AtomicBoolean busy = new AtomicBoolean(false);\n\n        TimerTask timtask = new TimerTask()\n        {\n            public void run()\n            {\n                if (!spoon.getDisplay().isDisposed())\n                {\n                    spoon.getDisplay().asyncExec(\n                        new Runnable()\n                        {\n                            public void run()\n                            {\n                                if (!busy.get())\n                                {\n                                    busy.set(true);\n                                    refreshView();\n                                    busy.set(false);\n                                }\n                            }\n                        }\n                    );\n                }\n            }\n        };\n\n        tim.schedule(timtask, 0L, REFRESH_TIME); // schedule to repeat a couple of times per second to get fast feedback \n\n        transGridTab.addDisposeListener(new DisposeListener() {\n\t\t\tpublic void widgetDisposed(DisposeEvent disposeEvent) {\n\t\t\t\ttim.cancel();\n\t\t\t}\n\t\t});\n\t\t\n\t\ttransGridTab.setControl(transGridComposite);\n\n\t\ttransGraph.extraViewTabFolder.setSelection(transGridTab);\t\t\n\t}","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void showHideInactive() {\n\t\thideInactiveSteps=!hideInactiveSteps;\n\t\t\n\t\t// TODO: change icon\n\t\tXulToolbarButton onlyActiveButton = toolbar.getButtonById(\"show-inactive\");\n\t\tif (onlyActiveButton!=null) {\n\t\t\tonlyActiveButton.setSelection(hideInactiveSteps);\n\t\t\tif (hideInactiveSteps) {\n\t\t\t\tonlyActiveButton.setImage(GUIResource.getInstance().getImageHideInactive());\n\t\t\t} else {\n\t\t\t\tonlyActiveButton.setImage(GUIResource.getInstance().getImageShowInactive());\n\t\t\t}\n\t\t}\n\t}","id":34018,"modified_method":"public void showHideInactive() {\n\t\thideInactiveSteps=!hideInactiveSteps;\n\t\t\n\t\t// TODO: change icon\n\t\tSwtToolbarbutton onlyActiveButton = (SwtToolbarbutton) toolbar.getElementById(\"show-inactive\");\n\t\tif (onlyActiveButton!=null) {\n\t\t\tonlyActiveButton.setSelected(hideInactiveSteps);\n\t\t\tif (hideInactiveSteps) {\n\t\t\t\tonlyActiveButton.setImage(GUIResource.getInstance().getImageHideInactive());\n\t\t\t} else {\n\t\t\t\tonlyActiveButton.setImage(GUIResource.getInstance().getImageShowInactive());\n\t\t\t}\n\t\t}\n\t}","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addLogTableTabs() {\n\t\t\n\t\tlogTables = transMeta.getLogTables();\n\t\t\n\t\tcolumns = new ArrayList<ColumnInfo[]>();\n\t\trowList = new ArrayList<List<Object[]>>();\n\t\tlogTableFields = new ArrayList<List<LogTableField>>();\n\t\twFields = new ArrayList<TableView>();\n\t\twText = new ArrayList<Text>();\n\n\t\t// Create a nested tab folder in the tab item, on the history composite...\n\t\t//\n\t\ttabFolder = new CTabFolder(transHistoryComposite, SWT.MULTI); \n\t    spoon.props.setLook(tabFolder, Props.WIDGET_STYLE_TAB);\n\n\t\tfor (LogTableInterface logTable : logTables) {\n\t\t\tCTabItem tabItem = new CTabItem(tabFolder, SWT.NONE);\n\t\t\t// tabItem.setImage(GUIResource.getInstance().getImageShowHistory());\n\t\t\ttabItem.setText(logTable.getLogTableType());\n\t\t\t\n\t\t\tComposite logTableComposite = new Composite(tabFolder, SWT.NONE);\n\t\t\tlogTableComposite.setLayout(new FormLayout());\n\t\t\tspoon.props.setLook(logTableComposite);\n\t\t\t\n\t\t\ttabItem.setControl(logTableComposite);\n\t\t\t\n\t\t\tSashForm sash = new SashForm(logTableComposite, SWT.VERTICAL);\n\t\t\tsash.setLayout(new FillLayout());\n\t\t\tFormData fdSash = new FormData(); \n\t\t\tfdSash.left   = new FormAttachment(0, 0);  // First one in the left top corner\n\t\t\tfdSash.top    = new FormAttachment(0, 0);\n\t\t\tfdSash.right  = new FormAttachment(100, 0);\n\t\t\tfdSash.bottom = new FormAttachment(100, 0);\n\t\t\tsash.setLayoutData(fdSash);\n\t\t\t\n\t\t\tList<ColumnInfo> columnList = new ArrayList<ColumnInfo>();\n\t\t\tList<LogTableField> fields =new ArrayList<LogTableField>();\n\t\t\t\n\t\t\tfor (LogTableField field : logTable.getFields()) {\n\t\t\t\tif (field.isEnabled() && field.isVisible()) {\n\t\t\t\t\tfields.add(field);\n\t\t\t\t\tif (!field.isLogField()) {\n\t\t\t\t\t\tColumnInfo column = new ColumnInfo(field.getName(), ColumnInfo.COLUMN_TYPE_TEXT, false, true);\n\t\t\t\t\t\tValueMetaInterface valueMeta = new ValueMeta(field.getFieldName(), field.getDataType(), field.getLength(), -1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tswitch(field.getDataType()) {\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER: \n\t\t\t\t\t\t\tvalueMeta.setConversionMask(\"###,###,##0\");\n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.RIGHT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_DATE: \n\t\t\t\t\t\t\tvalueMeta.setConversionMask(\"yyyy/MM/dd HH:mm:ss\");\n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.CENTER);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER: \n\t\t\t\t\t\t\tvalueMeta.setConversionMask(\" ###,###,##0.00;-###,###,##0.00\");\n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.RIGHT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_STRING: \n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.LEFT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolumn.setValueMeta(valueMeta);\n\t\t\t\t\t\tcolumnList.add(column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogTableFields.add(fields);\n\t\t\t\n\t\t\tfinal int FieldsRows=1;\n\t\t\tColumnInfo[] colinf=columnList.toArray(new ColumnInfo[columnList.size()]);\n\t\t\tcolumns.add(colinf); // keep for later\n\t\t\t\t\n\t        TableView tableView =new TableView(transGraph.getManagedObject(), \n\t        \t\t              sash, \n\t\t\t\t\t\t\t\t  SWT.BORDER | SWT.FULL_SELECTION | SWT.SINGLE, \n\t\t\t\t\t\t\t\t  colinf, \n\t\t\t\t\t\t\t\t  FieldsRows,  \n\t\t\t\t\t\t\t\t  true, // readonly!\n\t\t\t\t\t\t\t\t  null,\n\t\t\t\t\t\t\t\t  spoon.props\n\t\t\t\t\t\t\t\t  );\n\t        wFields.add(tableView);\n\t        \n\t        tableView.table.addSelectionListener(new SelectionAdapter() {\n\t        \tpublic void widgetSelected(SelectionEvent arg0) {\n\t        \t\tshowLogEntry();\n\t        \t}\n\t\t\t});\n\t        \n\t        if (logTable.getLogField()!=null) {\n\t\t\t\t\n\t\t\t\tText text = new Text(sash, SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL | SWT.READ_ONLY );\n\t\t\t\tspoon.props.setLook(text);\n\t\t\t\ttext.setVisible(true);\n\t\t\t\twText.add(text);\n\n\t\t\t\tFormData fdText = new FormData();\n\t\t\t\tfdText.left   = new FormAttachment(0, 0);\n\t\t\t\tfdText.top    = new FormAttachment(0, 0);\n\t\t\t\tfdText.right  = new FormAttachment(100, 0);\n\t\t\t\tfdText.bottom = new FormAttachment(100, 0);\n\t\t\t\ttext.setLayoutData(fdText);\n\t\t\t\t\n\t\t\t\tsash.setWeights(new int[] { 70, 30, } );\n\t        } else {\n\t        \twText.add(null);\n\t\t\t\tsash.setWeights(new int[] { 100, } );\n\t        }\n\t\t\t\n\n\n\t\t}\n\t\t\n\t\tFormData fdTabFolder = new FormData(); \n\t\tfdTabFolder.left   = new FormAttachment(0, 0);  // First one in the left top corner\n\t\tfdTabFolder.top    = new FormAttachment((Control)toolbar.getNativeObject(), 0);\n\t\tfdTabFolder.right  = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom = new FormAttachment(100, 0);\n\t\ttabFolder.setLayoutData(fdTabFolder);\n\t\t\n\t}","id":34019,"modified_method":"private void addLogTableTabs() {\n\t\t\n\t\tlogTables = transMeta.getLogTables();\n\t\t\n\t\tcolumns = new ArrayList<ColumnInfo[]>();\n\t\trowList = new ArrayList<List<Object[]>>();\n\t\tlogTableFields = new ArrayList<List<LogTableField>>();\n\t\twFields = new ArrayList<TableView>();\n\t\twText = new ArrayList<Text>();\n\n\t\t// Create a nested tab folder in the tab item, on the history composite...\n\t\t//\n\t\ttabFolder = new CTabFolder(transHistoryComposite, SWT.MULTI); \n\t    spoon.props.setLook(tabFolder, Props.WIDGET_STYLE_TAB);\n\n\t\tfor (LogTableInterface logTable : logTables) {\n\t\t\tCTabItem tabItem = new CTabItem(tabFolder, SWT.NONE);\n\t\t\t// tabItem.setImage(GUIResource.getInstance().getImageShowHistory());\n\t\t\ttabItem.setText(logTable.getLogTableType());\n\t\t\t\n\t\t\tComposite logTableComposite = new Composite(tabFolder, SWT.NONE);\n\t\t\tlogTableComposite.setLayout(new FormLayout());\n\t\t\tspoon.props.setLook(logTableComposite);\n\t\t\t\n\t\t\ttabItem.setControl(logTableComposite);\n\t\t\t\n\t\t\tSashForm sash = new SashForm(logTableComposite, SWT.VERTICAL);\n\t\t\tsash.setLayout(new FillLayout());\n\t\t\tFormData fdSash = new FormData(); \n\t\t\tfdSash.left   = new FormAttachment(0, 0);  // First one in the left top corner\n\t\t\tfdSash.top    = new FormAttachment(0, 0);\n\t\t\tfdSash.right  = new FormAttachment(100, 0);\n\t\t\tfdSash.bottom = new FormAttachment(100, 0);\n\t\t\tsash.setLayoutData(fdSash);\n\t\t\t\n\t\t\tList<ColumnInfo> columnList = new ArrayList<ColumnInfo>();\n\t\t\tList<LogTableField> fields =new ArrayList<LogTableField>();\n\t\t\t\n\t\t\tfor (LogTableField field : logTable.getFields()) {\n\t\t\t\tif (field.isEnabled() && field.isVisible()) {\n\t\t\t\t\tfields.add(field);\n\t\t\t\t\tif (!field.isLogField()) {\n\t\t\t\t\t\tColumnInfo column = new ColumnInfo(field.getName(), ColumnInfo.COLUMN_TYPE_TEXT, false, true);\n\t\t\t\t\t\tValueMetaInterface valueMeta = new ValueMeta(field.getFieldName(), field.getDataType(), field.getLength(), -1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tswitch(field.getDataType()) {\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER: \n\t\t\t\t\t\t\tvalueMeta.setConversionMask(\"###,###,##0\");\n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.RIGHT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_DATE: \n\t\t\t\t\t\t\tvalueMeta.setConversionMask(\"yyyy/MM/dd HH:mm:ss\");\n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.CENTER);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER: \n\t\t\t\t\t\t\tvalueMeta.setConversionMask(\" ###,###,##0.00;-###,###,##0.00\");\n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.RIGHT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ValueMetaInterface.TYPE_STRING: \n\t\t\t\t\t\t\tcolumn.setAllignement(SWT.LEFT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolumn.setValueMeta(valueMeta);\n\t\t\t\t\t\tcolumnList.add(column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogTableFields.add(fields);\n\t\t\t\n\t\t\tfinal int FieldsRows=1;\n\t\t\tColumnInfo[] colinf=columnList.toArray(new ColumnInfo[columnList.size()]);\n\t\t\tcolumns.add(colinf); // keep for later\n\t\t\t\t\n\t        TableView tableView =new TableView(transGraph.getManagedObject(), \n\t        \t\t              sash, \n\t\t\t\t\t\t\t\t  SWT.BORDER | SWT.FULL_SELECTION | SWT.SINGLE, \n\t\t\t\t\t\t\t\t  colinf, \n\t\t\t\t\t\t\t\t  FieldsRows,  \n\t\t\t\t\t\t\t\t  true, // readonly!\n\t\t\t\t\t\t\t\t  null,\n\t\t\t\t\t\t\t\t  spoon.props\n\t\t\t\t\t\t\t\t  );\n\t        wFields.add(tableView);\n\t        \n\t        tableView.table.addSelectionListener(new SelectionAdapter() {\n\t        \tpublic void widgetSelected(SelectionEvent arg0) {\n\t        \t\tshowLogEntry();\n\t        \t}\n\t\t\t});\n\t        \n\t        if (logTable.getLogField()!=null) {\n\t\t\t\t\n\t\t\t\tText text = new Text(sash, SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL | SWT.READ_ONLY );\n\t\t\t\tspoon.props.setLook(text);\n\t\t\t\ttext.setVisible(true);\n\t\t\t\twText.add(text);\n\n\t\t\t\tFormData fdText = new FormData();\n\t\t\t\tfdText.left   = new FormAttachment(0, 0);\n\t\t\t\tfdText.top    = new FormAttachment(0, 0);\n\t\t\t\tfdText.right  = new FormAttachment(100, 0);\n\t\t\t\tfdText.bottom = new FormAttachment(100, 0);\n\t\t\t\ttext.setLayoutData(fdText);\n\t\t\t\t\n\t\t\t\tsash.setWeights(new int[] { 70, 30, } );\n\t        } else {\n\t        \twText.add(null);\n\t\t\t\tsash.setWeights(new int[] { 100, } );\n\t        }\n\t\t\t\n\n\n\t\t}\n\t\t\n\t\tFormData fdTabFolder = new FormData(); \n\t\tfdTabFolder.left   = new FormAttachment(0, 0);  // First one in the left top corner\n\t\tfdTabFolder.top    = new FormAttachment((Control)toolbar.getManagedObject(), 0);\n\t\tfdTabFolder.right  = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom = new FormAttachment(100, 0);\n\t\ttabFolder.setLayoutData(fdTabFolder);\n\t\t\n\t}","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void addTransHistory() {\n\t\t// First, see if we need to add the extra view...\n\t\t//\n\t\tif (transGraph.extraViewComposite==null || transGraph.extraViewComposite.isDisposed()) {\n\t\t\ttransGraph.addExtraView();\n\t\t} else {\n\t\t\tif (transHistoryTab!=null && !transHistoryTab.isDisposed()) {\n\t\t\t\t// just set this one active and get out...\n\t\t\t\t//\n\t\t\t\ttransGraph.extraViewTabFolder.setSelection(transHistoryTab);\n\t\t\t\treturn; \n\t\t\t}\n\t\t}\n\t\t\n\t\ttransMeta = transGraph.getManagedObject();\n\t\t\n\t\t// Add a transLogTab : display the logging...\n\t\t//\n\t\ttransHistoryTab = new CTabItem(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransHistoryTab.setImage(GUIResource.getInstance().getImageShowHistory());\n\t\ttransHistoryTab.setText(BaseMessages.getString(PKG, \"Spoon.TransGraph.HistoryTab.Name\"));\n\t\t\n\t\t// Create a composite, slam everything on there like it was in the history tab.\n\t\t//\n\t\ttransHistoryComposite = new Composite(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransHistoryComposite.setLayout(new FormLayout());\n\t\tspoon.props.setLook(transHistoryComposite);\n\t\t\n\t\taddToolBar();\n\t\taddToolBarListeners();\n\t\taddLogTableTabs();\n\t\ttabFolder.setSelection(0);\n\t\t\n\t\ttransHistoryComposite.pack();\n        transHistoryTab.setControl(transHistoryComposite);\n\t\ttransGraph.extraViewTabFolder.setSelection(transHistoryTab);\n\t\t\n\t\t// Launch a refresh in the background...\n\t\t//\n\t\trefreshHistory();\n\t\t\n\t\tTimer timer = new Timer();\n\t\tTimerTask timerTask = new TimerTask() {\n\t\t\tpublic void run() {\n\t\t\t\tif (displayRefreshNeeded) {\n\t\t\t\t\tdisplayRefreshNeeded = false;\n\t\t\t\t\tfor (int i = 0; i < logTables.size() ; i++) {\n\t\t\t\t\t\tfinal int index = i;\n\t\t\t\t\t\tspoon.getDisplay().syncExec(new Runnable() {\n\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tdisplayHistoryData(logTables.get(index), index, rowList.get(index));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\t\t\n\t\t// Try to refresh every second or so...\n\t\t//\n\t\ttimer.schedule(timerTask, 1000, 1000);\n\t\t\n\t}","id":34020,"modified_method":"public void addTransHistory() {\n\t\t// First, see if we need to add the extra view...\n\t\t//\n\t\tif (transGraph.extraViewComposite==null || transGraph.extraViewComposite.isDisposed()) {\n\t\t\ttransGraph.addExtraView();\n\t\t} else {\n\t\t\tif (transHistoryTab!=null && !transHistoryTab.isDisposed()) {\n\t\t\t\t// just set this one active and get out...\n\t\t\t\t//\n\t\t\t\ttransGraph.extraViewTabFolder.setSelection(transHistoryTab);\n\t\t\t\treturn; \n\t\t\t}\n\t\t}\n\t\t\n\t\ttransMeta = transGraph.getManagedObject();\n\t\t\n\t\t// Add a transLogTab : display the logging...\n\t\t//\n\t\ttransHistoryTab = new CTabItem(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransHistoryTab.setImage(GUIResource.getInstance().getImageShowHistory());\n\t\ttransHistoryTab.setText(BaseMessages.getString(PKG, \"Spoon.TransGraph.HistoryTab.Name\"));\n\t\t\n\t\t// Create a composite, slam everything on there like it was in the history tab.\n\t\t//\n\t\ttransHistoryComposite = new Composite(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransHistoryComposite.setLayout(new FormLayout());\n\t\tspoon.props.setLook(transHistoryComposite);\n\t\t\n\t\taddToolBar();\n\t\taddLogTableTabs();\n\t\ttabFolder.setSelection(0);\n\t\t\n\t\ttransHistoryComposite.pack();\n        transHistoryTab.setControl(transHistoryComposite);\n\t\ttransGraph.extraViewTabFolder.setSelection(transHistoryTab);\n\t\t\n\t\t// Launch a refresh in the background...\n\t\t//\n\t\trefreshHistory();\n\t\t\n\t\tTimer timer = new Timer();\n\t\tTimerTask timerTask = new TimerTask() {\n\t\t\tpublic void run() {\n\t\t\t\tif (displayRefreshNeeded) {\n\t\t\t\t\tdisplayRefreshNeeded = false;\n\t\t\t\t\tfor (int i = 0; i < logTables.size() ; i++) {\n\t\t\t\t\t\tfinal int index = i;\n\t\t\t\t\t\tspoon.getDisplay().syncExec(new Runnable() {\n\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tdisplayHistoryData(logTables.get(index), index, rowList.get(index));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\t\t\n\t\t// Try to refresh every second or so...\n\t\t//\n\t\ttimer.schedule(timerTask, 1000, 1000);\n\t\t\n\t}","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addToolBar()\n\t{\n\n\t\ttry {\n\t\t\ttoolbar = XulHelper.createToolbar(XUL_FILE_TRANS_GRID_TOOLBAR, transHistoryComposite, TransHistoryDelegate.this, new XulMessages());\n\t\t\t\n\t\t\t\n\t\t\t// set the selected icon for the show inactive button.\n\t\t\t// This is not a XUL standard apparently\n\t\t\t//\n\t\t\tXulToolbarButton onlyActiveButton = toolbar.getButtonById(\"show-inactive\");\n\t\t\tif (onlyActiveButton!=null) {\n\t\t\t\tonlyActiveButton.setSelectedImage(GUIResource.getInstance().getImageHideInactive());\n\t\t\t}\n\t\t\n\t\t\t// Add a few default key listeners\n\t\t\t//\n\t\t\tToolBar toolBar = (ToolBar) toolbar.getNativeObject();\n\t\t\t\n\t\t\taddToolBarListeners();\n\t        toolBar.layout(true, true);\n\t\t} catch (Throwable t ) {\n\t\t\tlog.logError(Const.getStackTracker(t));\n\t\t\tnew ErrorDialog(transHistoryComposite.getShell(), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Title\"), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Message\", XUL_FILE_TRANS_GRID_TOOLBAR), new Exception(t));\n\t\t}\n\t}","id":34021,"modified_method":"private void addToolBar() {\n\n    try {\n      XulLoader loader = new SwtXulLoader();\n      ResourceBundle bundle = ResourceBundle.getBundle(\"org/pentaho/di/ui/spoon/messages/messages\", LanguageChoice.getInstance().getDefaultLocale());\n      XulDomContainer xulDomContainer = loader.loadXul(XUL_FILE_TRANS_GRID_TOOLBAR, bundle);\n      xulDomContainer.addEventHandler(this);\n      toolbar = (XulToolbar) xulDomContainer.getDocumentRoot().getElementById(\"nav-toolbar\");\n\n      XulToolbarbutton onlyActiveButton = (XulToolbarbutton) toolbar.getElementById(\"show-inactive\");\n      if (onlyActiveButton != null) {\n        ((ToolItem) onlyActiveButton.getManagedObject()).setImage(GUIResource.getInstance().getImageHideInactive());\n      }\n\n      ToolBar swtToolBar = (ToolBar) toolbar.getManagedObject();\n      swtToolBar.layout(true, true);\n    } catch (Throwable t) {\n      log.logError(toString(), Const.getStackTracker(t));\n      new ErrorDialog(transHistoryComposite.getShell(), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Title\"), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Message\", XUL_FILE_TRANS_GRID_TOOLBAR), new Exception(t));\n    }\n  }","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addToolBar()\n\t{\n\n\t\ttry {\n\t\t\ttoolbar = XulHelper.createToolbar(XUL_FILE_TRANS_LOG_TOOLBAR, transLogComposite, TransLogDelegate.this, new XulMessages());\n\n\t\t\t// Add a few default key listeners\n\t\t\t//\n\t\t\tToolBar toolBar = (ToolBar) toolbar.getNativeObject();\n\t\t\t\n\t\t\taddToolBarListeners();\n\t        toolBar.layout(true, true);\n\t\t} catch (Throwable t ) {\n\t\t\tlog.logError(Const.getStackTracker(t));\n\t\t\tnew ErrorDialog(transLogComposite.getShell(), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Title\"), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Message\", XUL_FILE_TRANS_LOG_TOOLBAR), new Exception(t));\n\t\t}\n\t}","id":34022,"modified_method":"private void addToolBar() {\n\n    try {\n      XulLoader loader = new SwtXulLoader();\n      ResourceBundle bundle = ResourceBundle.getBundle(\"org/pentaho/di/ui/spoon/messages/messages\", LanguageChoice.getInstance().getDefaultLocale());\n      XulDomContainer xulDomContainer = loader.loadXul(XUL_FILE_TRANS_LOG_TOOLBAR, bundle);\n      xulDomContainer.addEventHandler(this);\n      toolbar = (XulToolbar) xulDomContainer.getDocumentRoot().getElementById(\"nav-toolbar\");\n\n      ToolBar swtToolBar = (ToolBar) toolbar.getManagedObject();\n      swtToolBar.layout(true, true);\n    } catch (Throwable t) {\n      log.logError(toString(), Const.getStackTracker(t));\n      new ErrorDialog(transLogComposite.getShell(), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Title\"), BaseMessages.getString(PKG, \"Spoon.Exception.ErrorReadingXULFile.Message\", XUL_FILE_TRANS_LOG_TOOLBAR), new Exception(t));\n    }\n  }","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void pauseLog() {\n\t\tXulToolbarButton pauseContinueButton = toolbar.getButtonById(\"log-pause\");\n\n\t\tif (logBrowser.isPaused()) {\n\t\t\tlogBrowser.setPaused(false);\n\t\t\tif (pauseContinueButton!=null) { \n\t\t\t\tpauseContinueButton.setImage(GUIResource.getInstance().getImagePauseLog());\n\t\t\t}\n\t\t} else {\n\t\t\tlogBrowser.setPaused(true);\n\t\t\tif (pauseContinueButton!=null) { \n\t\t\t\tpauseContinueButton.setImage(GUIResource.getInstance().getImageContinueLog());\n\t\t\t}\n\t\t}\n\t}","id":34023,"modified_method":"public void pauseLog() {\n\t\tSwtToolbarbutton pauseContinueButton = (SwtToolbarbutton) toolbar.getElementById(\"log-pause\");\n\n\t\tif (logBrowser.isPaused()) {\n\t\t\tlogBrowser.setPaused(false);\n\t\t\tif (pauseContinueButton!=null) { \n\t\t\t\tpauseContinueButton.setImage(GUIResource.getInstance().getImagePauseLog());\n\t\t\t}\n\t\t} else {\n\t\t\tlogBrowser.setPaused(true);\n\t\t\tif (pauseContinueButton!=null) { \n\t\t\t\tpauseContinueButton.setImage(GUIResource.getInstance().getImageContinueLog());\n\t\t\t}\n\t\t}\n\t}","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void addTransLog() {\n\t\t// First, see if we need to add the extra view...\n\t\t//\n\t\tif (transGraph.extraViewComposite==null || transGraph.extraViewComposite.isDisposed()) {\n\t\t\ttransGraph.addExtraView();\n\t\t} else {\n\t\t\tif (transLogTab!=null && !transLogTab.isDisposed()) {\n\t\t\t\t// just set this one active and get out...\n\t\t\t\t//\n\t\t\t\ttransGraph.extraViewTabFolder.setSelection(transLogTab);\n\t\t\t\treturn; \n\t\t\t}\n\t\t}\n\t\t\n\t\t// Add a transLogTab : display the logging...\n\t\t//\n\t\ttransLogTab = new CTabItem(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransLogTab.setImage(GUIResource.getInstance().getImageShowLog());\n\t\ttransLogTab.setText(BaseMessages.getString(PKG, \"Spoon.TransGraph.LogTab.Name\"));\n\t\t\n\t\ttransLogComposite = new Composite(transGraph.extraViewTabFolder, SWT.NO_BACKGROUND | SWT.NO_FOCUS);\n\t\ttransLogComposite.setLayout(new FormLayout());\n\t\t\n\t\taddToolBar();\n\t\taddToolBarListeners();\n\t\t\n\t\ttransLogText = new StyledText(transLogComposite, SWT.READ_ONLY | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL);\n\t\tspoon.props.setLook(transLogText);\n\t\tFormData fdText = new FormData();\n\t\tfdText.left = new FormAttachment(0,0);\n\t\tfdText.right = new FormAttachment(100,0);\n\t\tfdText.top = new FormAttachment((Control)toolbar.getNativeObject(),0);\n\t\tfdText.bottom = new FormAttachment(100,0);\n\t\ttransLogText.setLayoutData(fdText);\n\t\t\n\t\tlogBrowser = new LogBrowser(transLogText, transGraph);\n\t\tlogBrowser.installLogSniffer();\n\n\t\t// If the transformation is closed, we should dispose of all the logging information in the buffer and registry for this transformation\n\t\t//\n\t\ttransGraph.addDisposeListener(new DisposeListener() {\n\t\t\tpublic void widgetDisposed(DisposeEvent event) {\n\t\t\t\tif (transGraph.trans!=null) {\n\t\t\t\t\tCentralLogStore.discardLines(transGraph.trans.getLogChannelId(), true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\ttransLogTab.setControl(transLogComposite);\n\t\t\n\t\t\n\t\t\n\t\ttransGraph.extraViewTabFolder.setSelection(transLogTab);\n\t}","id":34024,"modified_method":"public void addTransLog() {\n\t\t// First, see if we need to add the extra view...\n\t\t//\n\t\tif (transGraph.extraViewComposite==null || transGraph.extraViewComposite.isDisposed()) {\n\t\t\ttransGraph.addExtraView();\n\t\t} else {\n\t\t\tif (transLogTab!=null && !transLogTab.isDisposed()) {\n\t\t\t\t// just set this one active and get out...\n\t\t\t\t//\n\t\t\t\ttransGraph.extraViewTabFolder.setSelection(transLogTab);\n\t\t\t\treturn; \n\t\t\t}\n\t\t}\n\t\t\n\t\t// Add a transLogTab : display the logging...\n\t\t//\n\t\ttransLogTab = new CTabItem(transGraph.extraViewTabFolder, SWT.NONE);\n\t\ttransLogTab.setImage(GUIResource.getInstance().getImageShowLog());\n\t\ttransLogTab.setText(BaseMessages.getString(PKG, \"Spoon.TransGraph.LogTab.Name\"));\n\t\t\n\t\ttransLogComposite = new Composite(transGraph.extraViewTabFolder, SWT.NO_BACKGROUND | SWT.NO_FOCUS);\n\t\ttransLogComposite.setLayout(new FormLayout());\n\t\t\n\t\taddToolBar();\n\t\t\n\t\ttransLogText = new StyledText(transLogComposite, SWT.READ_ONLY | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL);\n\t\tspoon.props.setLook(transLogText);\n\t\tFormData fdText = new FormData();\n\t\tfdText.left = new FormAttachment(0,0);\n\t\tfdText.right = new FormAttachment(100,0);\n\t\tfdText.top = new FormAttachment((Control)toolbar.getManagedObject(),0);\n\t\tfdText.bottom = new FormAttachment(100,0);\n\t\ttransLogText.setLayoutData(fdText);\n\t\t\n\t\tlogBrowser = new LogBrowser(transLogText, transGraph);\n\t\tlogBrowser.installLogSniffer();\n\n\t\t// If the transformation is closed, we should dispose of all the logging information in the buffer and registry for this transformation\n\t\t//\n\t\ttransGraph.addDisposeListener(new DisposeListener() {\n\t\t\tpublic void widgetDisposed(DisposeEvent event) {\n\t\t\t\tif (transGraph.trans!=null) {\n\t\t\t\t\tCentralLogStore.discardLines(transGraph.trans.getLogChannelId(), true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\ttransLogTab.setControl(transLogComposite);\n\t\t\n\t\t\n\t\t\n\t\ttransGraph.extraViewTabFolder.setSelection(transLogTab);\n\t}","commit_id":"5719e94d157d53fd4fd3547e01c4949ab0c2466a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean acceptFolderUnderVcs(final VirtualFile vcsRoot, final VirtualFile file) {\n    final String vcsUrl = vcsRoot.getUrl();\n    final MyRootFilter rootFilter = myOtherVcsFolders.get(vcsUrl);\n    if ((rootFilter != null) && (! rootFilter.accept(file))) {\n      return false;\n    }\n    final Boolean excluded = isExcluded(myExcludedFileIndex, file);\n    if (excluded) return false;\n    return true;\n  }","id":34025,"modified_method":"public boolean acceptFolderUnderVcs(final VirtualFile vcsRoot, final VirtualFile file) {\n    final String vcsUrl = vcsRoot.getUrl();\n    final MyRootFilter rootFilter = myOtherVcsFolders.get(vcsUrl);\n    if ((rootFilter != null) && (! rootFilter.accept(file))) {\n      return false;\n    }\n    return !isExcluded(myExcludedFileIndex, file);\n  }","commit_id":"363b2cd981a42d1b0f8c07dc95db7a1ca69db7c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isExcludedFile(VirtualFile file) {\n    return myExcludedFileIndex.isExcluded(file);\n  }","id":34026,"modified_method":"public boolean isExcludedFile(VirtualFile file) {\n    return ProjectRootManager.getInstance(myProject).getFileIndex().isIgnored(file)\n      || myExcludedFileIndex.isExcluded(file);\n  }","commit_id":"d1572d256e6336cadb223ec463eb3fd2a29e3f43","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean isEventIgnored(final VirtualFileEvent event) {\n    return event.isFromRefresh() || ProjectLevelVcsManager.getInstance(myProject).getVcsFor(event.getFile()) != myVcs;\n  }","id":34027,"modified_method":"@Patch\n  protected boolean isEventIgnored(final VirtualFileEvent event) {\n    // MPS Patch: Added condition for ignoring excluded directories (IDEA-67402)\n    return event.isFromRefresh() || ProjectLevelVcsManager.getInstance(myProject).getVcsFor(event.getFile()) != myVcs\n      || ProjectRootManager.getInstance(myProject).getFileIndex().isIgnored(event.getFile());\n  }","commit_id":"d1572d256e6336cadb223ec463eb3fd2a29e3f43","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static final String description(Document d, String tagname) {\n        if (tagname == null || tagname.isEmpty()) {\n            tagname = d.source.toTokens();\n        }\n        StringBuilder sb = new StringBuilder(60);\n        sb.append(d.dc_title());\n        if (!d.dc_description().equals(d.dc_title()) && sb.length() < Request.descrLength - tagname.length()) {\n            sb.append(' ');\n            sb.append(d.dc_description());\n        }\n        if (sb.length() < Request.descrLength - tagname.length()) {\n            sb.append(' ');\n            sb.append(d.dc_subject(','));\n        }\n        if (tagname.length() > 0) {\n            if (sb.length() > Request.descrLength - tagname.length() - 3) {\n                // cut this off because otherwise the tagname is lost.\n                sb.setLength(Request.descrLength - tagname.length() - 3);\n            }\n            sb.append(\" - \");\n            sb.append(tagname);\n        }\n        return sb.toString().trim();\n    }","id":34028,"modified_method":"private static final String description(Document d, String tagname) {\n        if (tagname == null || tagname.isEmpty()) {\n            tagname = d.source.toTokens();\n        }\n        StringBuilder sb = new StringBuilder(60);\n        sb.append(d.dc_title());\n        if (d.dc_description().length > 0) {\n            if (!d.dc_description()[0].equals(d.dc_title()) && sb.length() < Request.descrLength - tagname.length()) {\n                sb.append(' ');\n                sb.append(d.dc_description()[0]);\n            }\n        }\n        if (sb.length() < Request.descrLength - tagname.length()) {\n            sb.append(' ');\n            sb.append(d.dc_subject(','));\n        }\n        if (tagname.length() > 0) {\n            if (sb.length() > Request.descrLength - tagname.length() - 3) {\n                // cut this off because otherwise the tagname is lost.\n                sb.setLength(Request.descrLength - tagname.length() - 3);\n            }\n            sb.append(\" - \");\n            sb.append(tagname);\n        }\n        return sb.toString().trim();\n    }","commit_id":"8f77719091c6b100abf732e1b828d731ca4698cb","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard)env;\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n\r\n        if (post == null) {\r\n            prop.putHTML(\"error_words\", \"\");\r\n            prop.put(\"error_vMode-sentences\", \"1\");\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"url\", \"\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        // get segment\r\n        Segment indexSegment = sb.index;\r\n        final boolean authorized = sb.verifyAuthentication(header);\r\n\r\n        if (post.containsKey(\"words\"))\r\n            prop.putHTML(\"error_words\", post.get(\"words\"));\r\n        else {\r\n            prop.putHTML(\"error_words\", \"\");\r\n        }\r\n\r\n        final String viewMode = post.get(\"viewMode\",\"parsed\");\r\n        prop.put(\"error_vMode-\" + viewMode, \"1\");\r\n\r\n        DigestURI url = null;\r\n        String descr = \"\";\r\n        final int wordCount = 0;\r\n        int size = 0;\r\n        boolean pre = false;\r\n\r\n        // get the url hash from which the content should be loaded\r\n        String urlHash = post.get(\"urlHash\", post.get(\"urlhash\", \"\"));\r\n\r\n        final String urlString = post.get(\"url\", \"\");\r\n        if (urlString.length() > 0) try {\r\n            // this call forces the peer to download  web pages\r\n            // it is therefore protected by the admin password\r\n\r\n            if (!sb.verifyAuthentication(header)) {\r\n                prop.authenticationRequired();\r\n                return prop;\r\n            }\r\n\r\n            // define an url by post parameter\r\n            url = new DigestURI(MultiProtocolURI.unescape(urlString));\r\n            urlHash = ASCII.String(url.hash());\r\n            pre = post.getBoolean(\"pre\");\r\n        } catch (final MalformedURLException e) {}\r\n\r\n        URIMetadataNode urlEntry = null;\r\n        // get the urlEntry that belongs to the url hash\r\n        //boolean ue = urlHash.length() > 0 && indexSegment.exists(ASCII.getBytes(urlHash));\r\n        //if (ue) Log.logInfo(\"ViewFile\", \"exists(\" + urlHash + \")\");\r\n        if (urlHash.length() > 0 && (urlEntry = indexSegment.fulltext().getMetadata(ASCII.getBytes(urlHash))) == null) {\r\n            indexSegment.fulltext().commit(true);\r\n        }\r\n        if (urlHash.length() > 0 && (urlEntry = indexSegment.fulltext().getMetadata(ASCII.getBytes(urlHash))) != null) {\r\n            // get the url that belongs to the entry\r\n            if (urlEntry == null || urlEntry.url() == null) {\r\n                prop.put(\"error\", \"3\");\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n            url = urlEntry.url();\r\n            descr = urlEntry.dc_title();\r\n            //urlEntry.wordCount();\r\n            size = urlEntry.size();\r\n            pre = urlEntry.flags().get(Condenser.flag_cat_indexof);\r\n        }\r\n\r\n        prop.put(\"error_inurldb\", urlEntry == null ? 0 : 1);\r\n\r\n        if (url == null) {\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            prop.put(\"url\", \"\");\r\n            return prop;\r\n        }\r\n        prop.put(\"url\", url.toNormalform(true));\r\n\r\n        // loading the resource content as byte array\r\n        prop.put(\"error_incache\", Cache.has(url.hash()) ? 1 : 0);\r\n\r\n        Response response = null;\r\n        try {\r\n            ClientIdentification.Agent agent = ClientIdentification.getAgent(post.get(\"agentName\", ClientIdentification.yacyInternetCrawlerAgentName));\r\n            response = sb.loader.load(sb.loader.request(url, true, false), authorized ? CacheStrategy.IFEXIST : CacheStrategy.CACHEONLY, Integer.MAX_VALUE, null, agent);\r\n        } catch (final IOException e) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"error loading resource: \" + e.getMessage());\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        if (response == null) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"No resource available\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        final String[] wordArray = wordArray(post.get(\"words\", null));\r\n        final String ext = MultiProtocolURI.getFileExtension(url.getFileName());\r\n        if (viewMode.equals(\"plain\")) {\r\n\r\n            // TODO: how to handle very large files here ?\r\n            String content;\r\n            try {\r\n                content = UTF8.String(response.getContent());\r\n            } catch (final Exception e) {\r\n                prop.put(\"error\", \"4\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            prop.put(\"error\", \"0\");\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_PLAIN_TEXT);\r\n            prop.put(\"viewMode_plainText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n        } else if (viewMode.equals(\"iframeWeb\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_WEB);\r\n            prop.put(\"viewMode_url\", url.toNormalform(true));\r\n\r\n        } else if (viewMode.equals(\"iframeCache\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_CACHE);\r\n            prop.put(\"viewMode_png\", 0);\r\n            prop.put(\"viewMode_html\", 0);\r\n            if (ext.length() > 0 && \"jpg.jpeg.png.gif\".indexOf(ext) >= 0) {\r\n                prop.put(\"viewMode_png\", 1);\r\n                prop.put(\"viewMode_png_url\", url.toNormalform(true));\r\n            } else {\r\n                prop.put(\"viewMode_html\", 1);\r\n                prop.put(\"viewMode_html_url\", url.toNormalform(true));\r\n            }\r\n        } else if (viewMode.equals(\"iframeCitations\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_CITATION_REPORT);\r\n            prop.put(\"viewMode_url\", url.toNormalform(true));\r\n        } else if (viewMode.equals(\"parsed\") || viewMode.equals(\"sentences\")  || viewMode.equals(\"words\") || viewMode.equals(\"links\")) {\r\n            // parsing the resource content\r\n            Document document = null;\r\n            try {\r\n                document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n                if (document == null) {\r\n                    prop.put(\"error\", \"5\");\r\n                    prop.put(\"error_errorText\", \"Unknown error\");\r\n                    prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                    return prop;\r\n                }\r\n            } catch (final Parser.Failure e) {\r\n                prop.put(\"error\", \"5\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            if (viewMode.equals(\"parsed\")) {\r\n                final String content = document.getTextString();\r\n                // content = wikiCode.replaceHTML(content); // added by Marc Nause\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_TEXT);\r\n                prop.put(\"viewMode_title\", document.dc_title());\r\n                prop.put(\"viewMode_creator\", document.dc_creator());\r\n                prop.put(\"viewMode_subject\", document.dc_subject(','));\r\n                prop.put(\"viewMode_description\", document.dc_description());\r\n                prop.put(\"viewMode_publisher\", document.dc_publisher());\r\n                prop.put(\"viewMode_format\", document.dc_format());\r\n                prop.put(\"viewMode_identifier\", document.dc_identifier());\r\n                prop.put(\"viewMode_source\", url.toString());\r\n                prop.put(\"viewMode_lat\", document.lat());\r\n                prop.put(\"viewMode_lon\", document.lon());\r\n                prop.put(\"viewMode_parsedText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n            } else if (viewMode.equals(\"sentences\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_SENTENCES);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        if (sentence.trim().length() > 0) {\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_nr\", i + 1);\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_text\", markup(wordArray, sentence));\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                            dark = !dark;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_sentences\", i);\r\n\r\n            } else if (viewMode.equals(\"words\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_WORDS);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence;\r\n                StringBuilder token;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        Enumeration<StringBuilder> tokens = null;\r\n                        tokens = new WordTokenizer(new SentenceReader(sentence), LibraryProvider.dymLib);\r\n                        while (tokens.hasMoreElements()) {\r\n                            token = tokens.nextElement();\r\n                            if (token.length() > 0) {\r\n                                prop.put(\"viewMode_words_\" + i + \"_nr\", i + 1);\r\n                                prop.put(\"viewMode_words_\" + i + \"_word\", token.toString());\r\n                                prop.put(\"viewMode_words_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                                dark = !dark;\r\n                                i++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_words\", i);\r\n\r\n            } else if (viewMode.equals(\"links\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_LINKLIST);\r\n                boolean dark = true;\r\n                int i = 0;\r\n                i += putMediaInfo(prop, wordArray, i, document.getVideolinks(), \"video\", (i % 2 == 0), document.getAnchors());\r\n                i += putMediaInfo(prop, wordArray, i, document.getAudiolinks(), \"audio\", (i % 2 == 0), document.getAnchors());\r\n                dark = (i % 2 == 0);\r\n\r\n                final Map<DigestURI, ImageEntry> ts = document.getImages();\r\n                final Iterator<ImageEntry> tsi = ts.values().iterator();\r\n                ImageEntry entry;\r\n                while (tsi.hasNext()) {\r\n                    entry = tsi.next();\r\n                    prop.put(\"viewMode_links_\" + i + \"_nr\", i);\r\n                    prop.put(\"viewMode_links_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_type\", \"image\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_text\", (entry.alt().isEmpty()) ? \"&nbsp;\" : markup(wordArray, entry.alt()));\r\n                    prop.put(\"viewMode_links_\" + i + \"_url\", entry.url().toNormalform(true));\r\n                    prop.put(\"viewMode_links_\" + i + \"_link\", markup(wordArray, entry.url().toNormalform(true)));\r\n                    if (entry.width() > 0 && entry.height() > 0) {\r\n                        prop.put(\"viewMode_links_\" + i + \"_rel\", entry.width() + \"x\" + entry.height() + \" Pixel\");\r\n                    } else {\r\n                        prop.put(\"viewMode_links_\" + i + \"_rel\", \"\");\r\n                    }\r\n                    prop.put(\"viewMode_links_\" + i + \"_name\", \"\");\r\n                    dark = !dark;\r\n                    i++;\r\n                }\r\n                i += putMediaInfo(prop, wordArray, i, document.getApplinks(), \"app\", (i % 2 == 0), document.getAnchors());\r\n                i += putMediaInfo(prop, wordArray, i, document.getHyperlinks(), \"link\", (i % 2 == 0), document.getAnchors());\r\n                prop.put(\"viewMode_links\", i);\r\n\r\n            }\r\n            if (document != null) document.close();\r\n        }\r\n        prop.put(\"error\", \"0\");\r\n        prop.put(\"error_url\", url.toNormalform(true));\r\n        prop.put(\"error_hash\", urlHash);\r\n        prop.put(\"error_wordCount\", wordCount);\r\n        prop.putHTML(\"error_desc\", (descr.isEmpty()) ? \"&nbsp;\" : descr);\r\n        prop.putNum(\"error_size\", size);\r\n        prop.put(\"error_mimeTypeAvailable\", (response.getMimeType() == null) ? \"0\" : \"1\");\r\n        prop.put(\"error_mimeTypeAvailable_mimeType\", response.getMimeType());\r\n        Model model = JenaTripleStore.getSubmodelBySubject(YaCyMetadata.hashURI(url.hash()));\r\n        prop.putXML(\"error_triples\", JenaTripleStore.getRDFByModel(model));\r\n\r\n        if (urlEntry == null) {\r\n            prop.put(\"error_referrerHash\", \"\");\r\n            prop.put(\"error_moddate\", \"\");\r\n            prop.put(\"error_loaddate\", \"\");\r\n            prop.put(\"error_freshdate\", \"\");\r\n            prop.put(\"error_hosthash\", \"\");\r\n            prop.putHTML(\"error_dc_creator\", \"\");\r\n            prop.putHTML(\"error_dc_publisher\", \"\");\r\n            prop.putHTML(\"error_dc_subject\", \"\");\r\n            prop.put(\"error_md5\", \"\");\r\n            prop.put(\"error_lat\", \"\");\r\n            prop.put(\"error_lon\", \"\");\r\n            prop.put(\"error_doctype\", \"\");\r\n            prop.put(\"error_language\", \"\");\r\n            prop.put(\"error_flags\", \"\");\r\n            prop.put(\"error_wordCount\", \"\");\r\n            prop.put(\"error_llocal\", \"\");\r\n            prop.put(\"error_lother\", \"\");\r\n            prop.put(\"error_limage\", \"\");\r\n            prop.put(\"error_laudio\", \"\");\r\n            prop.put(\"error_lvideo\", \"\");\r\n            prop.put(\"error_lapp\", \"\");\r\n            prop.put(\"error_collections\", \"\");\r\n        } else {\r\n            prop.put(\"error_referrerHash\", urlEntry.referrerHash());\r\n            prop.put(\"error_moddate\", urlEntry.moddate());\r\n            prop.put(\"error_loaddate\", urlEntry.loaddate());\r\n            prop.put(\"error_freshdate\", urlEntry.freshdate());\r\n            prop.put(\"error_hosthash\", urlEntry.hosthash());\r\n            prop.putHTML(\"error_dc_creator\", urlEntry.dc_creator());\r\n            prop.putHTML(\"error_dc_publisher\", urlEntry.dc_publisher());\r\n            prop.putHTML(\"error_dc_subject\", urlEntry.dc_subject());\r\n            prop.put(\"error_md5\", urlEntry.md5());\r\n            prop.put(\"error_lat\", urlEntry.lat());\r\n            prop.put(\"error_lon\", urlEntry.lon());\r\n            prop.put(\"error_doctype\", Response.doctype2mime(ext, urlEntry.doctype()));\r\n            prop.put(\"error_language\", urlEntry.language());\r\n            prop.put(\"error_flags\", urlEntry.flags().toString());\r\n            prop.put(\"error_wordCount\", urlEntry.wordCount());\r\n            prop.put(\"error_llocal\", urlEntry.llocal());\r\n            prop.put(\"error_lother\", urlEntry.lother());\r\n            prop.put(\"error_limage\", urlEntry.limage());\r\n            prop.put(\"error_laudio\", urlEntry.laudio());\r\n            prop.put(\"error_lvideo\", urlEntry.lvideo());\r\n            prop.put(\"error_lapp\", urlEntry.lapp());\r\n            prop.put(\"error_collections\", Arrays.toString(urlEntry.collections()));\r\n        }\r\n\r\n        return prop;\r\n    }","id":34029,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard)env;\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n\r\n        if (post == null) {\r\n            prop.putHTML(\"error_words\", \"\");\r\n            prop.put(\"error_vMode-sentences\", \"1\");\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"url\", \"\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        // get segment\r\n        Segment indexSegment = sb.index;\r\n        final boolean authorized = sb.verifyAuthentication(header);\r\n\r\n        if (post.containsKey(\"words\"))\r\n            prop.putHTML(\"error_words\", post.get(\"words\"));\r\n        else {\r\n            prop.putHTML(\"error_words\", \"\");\r\n        }\r\n\r\n        final String viewMode = post.get(\"viewMode\",\"parsed\");\r\n        prop.put(\"error_vMode-\" + viewMode, \"1\");\r\n\r\n        DigestURI url = null;\r\n        String descr = \"\";\r\n        final int wordCount = 0;\r\n        int size = 0;\r\n        boolean pre = false;\r\n\r\n        // get the url hash from which the content should be loaded\r\n        String urlHash = post.get(\"urlHash\", post.get(\"urlhash\", \"\"));\r\n\r\n        final String urlString = post.get(\"url\", \"\");\r\n        if (urlString.length() > 0) try {\r\n            // this call forces the peer to download  web pages\r\n            // it is therefore protected by the admin password\r\n\r\n            if (!sb.verifyAuthentication(header)) {\r\n                prop.authenticationRequired();\r\n                return prop;\r\n            }\r\n\r\n            // define an url by post parameter\r\n            url = new DigestURI(MultiProtocolURI.unescape(urlString));\r\n            urlHash = ASCII.String(url.hash());\r\n            pre = post.getBoolean(\"pre\");\r\n        } catch (final MalformedURLException e) {}\r\n\r\n        URIMetadataNode urlEntry = null;\r\n        // get the urlEntry that belongs to the url hash\r\n        //boolean ue = urlHash.length() > 0 && indexSegment.exists(ASCII.getBytes(urlHash));\r\n        //if (ue) Log.logInfo(\"ViewFile\", \"exists(\" + urlHash + \")\");\r\n        if (urlHash.length() > 0 && (urlEntry = indexSegment.fulltext().getMetadata(ASCII.getBytes(urlHash))) == null) {\r\n            indexSegment.fulltext().commit(true);\r\n        }\r\n        if (urlHash.length() > 0 && (urlEntry = indexSegment.fulltext().getMetadata(ASCII.getBytes(urlHash))) != null) {\r\n            // get the url that belongs to the entry\r\n            if (urlEntry == null || urlEntry.url() == null) {\r\n                prop.put(\"error\", \"3\");\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n            url = urlEntry.url();\r\n            descr = urlEntry.dc_title();\r\n            //urlEntry.wordCount();\r\n            size = urlEntry.size();\r\n            pre = urlEntry.flags().get(Condenser.flag_cat_indexof);\r\n        }\r\n\r\n        prop.put(\"error_inurldb\", urlEntry == null ? 0 : 1);\r\n\r\n        if (url == null) {\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            prop.put(\"url\", \"\");\r\n            return prop;\r\n        }\r\n        prop.put(\"url\", url.toNormalform(true));\r\n\r\n        // loading the resource content as byte array\r\n        prop.put(\"error_incache\", Cache.has(url.hash()) ? 1 : 0);\r\n\r\n        Response response = null;\r\n        try {\r\n            ClientIdentification.Agent agent = ClientIdentification.getAgent(post.get(\"agentName\", ClientIdentification.yacyInternetCrawlerAgentName));\r\n            response = sb.loader.load(sb.loader.request(url, true, false), authorized ? CacheStrategy.IFEXIST : CacheStrategy.CACHEONLY, Integer.MAX_VALUE, null, agent);\r\n        } catch (final IOException e) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"error loading resource: \" + e.getMessage());\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        if (response == null) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"No resource available\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        final String[] wordArray = wordArray(post.get(\"words\", null));\r\n        final String ext = MultiProtocolURI.getFileExtension(url.getFileName());\r\n        if (viewMode.equals(\"plain\")) {\r\n\r\n            // TODO: how to handle very large files here ?\r\n            String content;\r\n            try {\r\n                content = UTF8.String(response.getContent());\r\n            } catch (final Exception e) {\r\n                prop.put(\"error\", \"4\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            prop.put(\"error\", \"0\");\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_PLAIN_TEXT);\r\n            prop.put(\"viewMode_plainText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n        } else if (viewMode.equals(\"iframeWeb\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_WEB);\r\n            prop.put(\"viewMode_url\", url.toNormalform(true));\r\n\r\n        } else if (viewMode.equals(\"iframeCache\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_CACHE);\r\n            prop.put(\"viewMode_png\", 0);\r\n            prop.put(\"viewMode_html\", 0);\r\n            if (ext.length() > 0 && \"jpg.jpeg.png.gif\".indexOf(ext) >= 0) {\r\n                prop.put(\"viewMode_png\", 1);\r\n                prop.put(\"viewMode_png_url\", url.toNormalform(true));\r\n            } else {\r\n                prop.put(\"viewMode_html\", 1);\r\n                prop.put(\"viewMode_html_url\", url.toNormalform(true));\r\n            }\r\n        } else if (viewMode.equals(\"iframeCitations\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_CITATION_REPORT);\r\n            prop.put(\"viewMode_url\", url.toNormalform(true));\r\n        } else if (viewMode.equals(\"parsed\") || viewMode.equals(\"sentences\")  || viewMode.equals(\"words\") || viewMode.equals(\"links\")) {\r\n            // parsing the resource content\r\n            Document document = null;\r\n            try {\r\n                document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n                if (document == null) {\r\n                    prop.put(\"error\", \"5\");\r\n                    prop.put(\"error_errorText\", \"Unknown error\");\r\n                    prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                    return prop;\r\n                }\r\n            } catch (final Parser.Failure e) {\r\n                prop.put(\"error\", \"5\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            if (viewMode.equals(\"parsed\")) {\r\n                final String content = document.getTextString();\r\n                // content = wikiCode.replaceHTML(content); // added by Marc Nause\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_TEXT);\r\n                prop.put(\"viewMode_title\", document.dc_title());\r\n                prop.put(\"viewMode_creator\", document.dc_creator());\r\n                prop.put(\"viewMode_subject\", document.dc_subject(','));\r\n                prop.put(\"viewMode_description\", document.dc_description().length == 0 ? new String[]{\"\"} : document.dc_description());\r\n                prop.put(\"viewMode_publisher\", document.dc_publisher());\r\n                prop.put(\"viewMode_format\", document.dc_format());\r\n                prop.put(\"viewMode_identifier\", document.dc_identifier());\r\n                prop.put(\"viewMode_source\", url.toString());\r\n                prop.put(\"viewMode_lat\", document.lat());\r\n                prop.put(\"viewMode_lon\", document.lon());\r\n                prop.put(\"viewMode_parsedText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n            } else if (viewMode.equals(\"sentences\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_SENTENCES);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        if (sentence.trim().length() > 0) {\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_nr\", i + 1);\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_text\", markup(wordArray, sentence));\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                            dark = !dark;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_sentences\", i);\r\n\r\n            } else if (viewMode.equals(\"words\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_WORDS);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence;\r\n                StringBuilder token;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        Enumeration<StringBuilder> tokens = null;\r\n                        tokens = new WordTokenizer(new SentenceReader(sentence), LibraryProvider.dymLib);\r\n                        while (tokens.hasMoreElements()) {\r\n                            token = tokens.nextElement();\r\n                            if (token.length() > 0) {\r\n                                prop.put(\"viewMode_words_\" + i + \"_nr\", i + 1);\r\n                                prop.put(\"viewMode_words_\" + i + \"_word\", token.toString());\r\n                                prop.put(\"viewMode_words_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                                dark = !dark;\r\n                                i++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_words\", i);\r\n\r\n            } else if (viewMode.equals(\"links\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_LINKLIST);\r\n                boolean dark = true;\r\n                int i = 0;\r\n                i += putMediaInfo(prop, wordArray, i, document.getVideolinks(), \"video\", (i % 2 == 0), document.getAnchors());\r\n                i += putMediaInfo(prop, wordArray, i, document.getAudiolinks(), \"audio\", (i % 2 == 0), document.getAnchors());\r\n                dark = (i % 2 == 0);\r\n\r\n                final Map<DigestURI, ImageEntry> ts = document.getImages();\r\n                final Iterator<ImageEntry> tsi = ts.values().iterator();\r\n                ImageEntry entry;\r\n                while (tsi.hasNext()) {\r\n                    entry = tsi.next();\r\n                    prop.put(\"viewMode_links_\" + i + \"_nr\", i);\r\n                    prop.put(\"viewMode_links_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_type\", \"image\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_text\", (entry.alt().isEmpty()) ? \"&nbsp;\" : markup(wordArray, entry.alt()));\r\n                    prop.put(\"viewMode_links_\" + i + \"_url\", entry.url().toNormalform(true));\r\n                    prop.put(\"viewMode_links_\" + i + \"_link\", markup(wordArray, entry.url().toNormalform(true)));\r\n                    if (entry.width() > 0 && entry.height() > 0) {\r\n                        prop.put(\"viewMode_links_\" + i + \"_rel\", entry.width() + \"x\" + entry.height() + \" Pixel\");\r\n                    } else {\r\n                        prop.put(\"viewMode_links_\" + i + \"_rel\", \"\");\r\n                    }\r\n                    prop.put(\"viewMode_links_\" + i + \"_name\", \"\");\r\n                    dark = !dark;\r\n                    i++;\r\n                }\r\n                i += putMediaInfo(prop, wordArray, i, document.getApplinks(), \"app\", (i % 2 == 0), document.getAnchors());\r\n                i += putMediaInfo(prop, wordArray, i, document.getHyperlinks(), \"link\", (i % 2 == 0), document.getAnchors());\r\n                prop.put(\"viewMode_links\", i);\r\n\r\n            }\r\n            if (document != null) document.close();\r\n        }\r\n        prop.put(\"error\", \"0\");\r\n        prop.put(\"error_url\", url.toNormalform(true));\r\n        prop.put(\"error_hash\", urlHash);\r\n        prop.put(\"error_wordCount\", wordCount);\r\n        prop.putHTML(\"error_desc\", (descr.isEmpty()) ? \"&nbsp;\" : descr);\r\n        prop.putNum(\"error_size\", size);\r\n        prop.put(\"error_mimeTypeAvailable\", (response.getMimeType() == null) ? \"0\" : \"1\");\r\n        prop.put(\"error_mimeTypeAvailable_mimeType\", response.getMimeType());\r\n        Model model = JenaTripleStore.getSubmodelBySubject(YaCyMetadata.hashURI(url.hash()));\r\n        prop.putXML(\"error_triples\", JenaTripleStore.getRDFByModel(model));\r\n\r\n        if (urlEntry == null) {\r\n            prop.put(\"error_referrerHash\", \"\");\r\n            prop.put(\"error_moddate\", \"\");\r\n            prop.put(\"error_loaddate\", \"\");\r\n            prop.put(\"error_freshdate\", \"\");\r\n            prop.put(\"error_hosthash\", \"\");\r\n            prop.putHTML(\"error_dc_creator\", \"\");\r\n            prop.putHTML(\"error_dc_publisher\", \"\");\r\n            prop.putHTML(\"error_dc_subject\", \"\");\r\n            prop.put(\"error_md5\", \"\");\r\n            prop.put(\"error_lat\", \"\");\r\n            prop.put(\"error_lon\", \"\");\r\n            prop.put(\"error_doctype\", \"\");\r\n            prop.put(\"error_language\", \"\");\r\n            prop.put(\"error_flags\", \"\");\r\n            prop.put(\"error_wordCount\", \"\");\r\n            prop.put(\"error_llocal\", \"\");\r\n            prop.put(\"error_lother\", \"\");\r\n            prop.put(\"error_limage\", \"\");\r\n            prop.put(\"error_laudio\", \"\");\r\n            prop.put(\"error_lvideo\", \"\");\r\n            prop.put(\"error_lapp\", \"\");\r\n            prop.put(\"error_collections\", \"\");\r\n        } else {\r\n            prop.put(\"error_referrerHash\", urlEntry.referrerHash());\r\n            prop.put(\"error_moddate\", urlEntry.moddate());\r\n            prop.put(\"error_loaddate\", urlEntry.loaddate());\r\n            prop.put(\"error_freshdate\", urlEntry.freshdate());\r\n            prop.put(\"error_hosthash\", urlEntry.hosthash());\r\n            prop.putHTML(\"error_dc_creator\", urlEntry.dc_creator());\r\n            prop.putHTML(\"error_dc_publisher\", urlEntry.dc_publisher());\r\n            prop.putHTML(\"error_dc_subject\", urlEntry.dc_subject());\r\n            prop.put(\"error_md5\", urlEntry.md5());\r\n            prop.put(\"error_lat\", urlEntry.lat());\r\n            prop.put(\"error_lon\", urlEntry.lon());\r\n            prop.put(\"error_doctype\", Response.doctype2mime(ext, urlEntry.doctype()));\r\n            prop.put(\"error_language\", urlEntry.language());\r\n            prop.put(\"error_flags\", urlEntry.flags().toString());\r\n            prop.put(\"error_wordCount\", urlEntry.wordCount());\r\n            prop.put(\"error_llocal\", urlEntry.llocal());\r\n            prop.put(\"error_lother\", urlEntry.lother());\r\n            prop.put(\"error_limage\", urlEntry.limage());\r\n            prop.put(\"error_laudio\", urlEntry.laudio());\r\n            prop.put(\"error_lvideo\", urlEntry.lvideo());\r\n            prop.put(\"error_lapp\", urlEntry.lapp());\r\n            prop.put(\"error_collections\", Arrays.toString(urlEntry.collections()));\r\n        }\r\n\r\n        return prop;\r\n    }","commit_id":"5d71a4c8bc6321a8d2f5d45b00cf11ad1bcd111b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n   * Copies a file or a directory from the Tachyon filesystem to the local filesystem.\n   *\n   * @param srcPath The source {@link TachyonURI} (could be a file or a directory)\n   * @param dstFile The destination file in the local filesystem\n   * @throws IOException\n   */\n  private void copyToLocal(TachyonURI srcPath, File dstFile) throws IOException {\n    TachyonFile srcFd;\n    URIStatus srcStatus;\n    try {\n      srcStatus = mTfs.getStatus(srcPath);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    if (srcStatus.isFolder()) {\n      // make a local directory\n      if (!dstFile.exists()) {\n        if (!dstFile.mkdirs()) {\n          throw new IOException(\"mkdir failure for directory: \" + dstFile.getAbsolutePath());\n        } else {\n          System.out.println(\"Create directory: \" + dstFile.getAbsolutePath());\n        }\n      }\n\n      List<URIStatus> statuses = null;\n      try {\n        statuses = mTfs.listStatus(srcPath);\n      } catch (TachyonException e) {\n        throw new IOException(e.getMessage());\n      }\n\n      List<String> errorMessages = new ArrayList<String>();\n      for (URIStatus status : statuses) {\n        try {\n          copyToLocal(\n              new TachyonURI(srcPath.getScheme(), srcPath.getAuthority(), status.getPath()),\n              new File(dstFile.getAbsolutePath(), status.getName()));\n        } catch (IOException e) {\n          errorMessages.add(e.getMessage());\n        }\n      }\n\n      if (errorMessages.size() != 0) {\n        throw new IOException(Joiner.on('\\n').join(errorMessages));\n      }\n    } else {\n      copyFileToLocal(srcPath, dstFile);\n    }\n  }","id":34030,"modified_method":"/**\n   * Copies a file or a directory from the Tachyon filesystem to the local filesystem.\n   *\n   * @param srcPath The source {@link TachyonURI} (could be a file or a directory)\n   * @param dstFile The destination file in the local filesystem\n   * @throws IOException\n   */\n  private void copyToLocal(TachyonURI srcPath, File dstFile) throws IOException {\n    URIStatus srcStatus;\n    try {\n      srcStatus = mTfs.getStatus(srcPath);\n    } catch (TachyonException e) {\n      throw new IOException(e.getMessage());\n    }\n\n    if (srcStatus.isFolder()) {\n      // make a local directory\n      if (!dstFile.exists()) {\n        if (!dstFile.mkdirs()) {\n          throw new IOException(\"mkdir failure for directory: \" + dstFile.getAbsolutePath());\n        } else {\n          System.out.println(\"Create directory: \" + dstFile.getAbsolutePath());\n        }\n      }\n\n      List<URIStatus> statuses = null;\n      try {\n        statuses = mTfs.listStatus(srcPath);\n      } catch (TachyonException e) {\n        throw new IOException(e.getMessage());\n      }\n\n      List<String> errorMessages = new ArrayList<String>();\n      for (URIStatus status : statuses) {\n        try {\n          copyToLocal(\n              new TachyonURI(srcPath.getScheme(), srcPath.getAuthority(), status.getPath()),\n              new File(dstFile.getAbsolutePath(), status.getName()));\n        } catch (IOException e) {\n          errorMessages.add(e.getMessage());\n        }\n      }\n\n      if (errorMessages.size() != 0) {\n        throw new IOException(Joiner.on('\\n').join(errorMessages));\n      }\n    } else {\n      copyFileToLocal(srcPath, dstFile);\n    }\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void openCloseTest() throws TachyonException, IOException {\n    FileSystemMasterClient fsMasterClient = new FileSystemMasterClient(\n        mLocalTachyonClusterResource.get().getMaster().getAddress(), mMasterTachyonConf);\n    Assert.assertFalse(fsMasterClient.isConnected());\n    fsMasterClient.connect();\n    Assert.assertTrue(fsMasterClient.isConnected());\n    fsMasterClient.create(\"/file\", CreateOptions.defaults());\n    Assert.assertTrue(fsMasterClient.getFileInfo(fsMasterClient.getFileId(\"/file\")) != null);\n    fsMasterClient.disconnect();\n    Assert.assertFalse(fsMasterClient.isConnected());\n    fsMasterClient.connect();\n    Assert.assertTrue(fsMasterClient.isConnected());\n    Assert.assertTrue(fsMasterClient.getFileInfo(fsMasterClient.getFileId(\"/file\")) != null);\n    fsMasterClient.close();\n  }","id":34031,"modified_method":"@Test\n  public void openCloseTest() throws TachyonException, IOException {\n    FileSystemMasterClient fsMasterClient = new FileSystemMasterClient(\n        mLocalTachyonClusterResource.get().getMaster().getAddress(), mMasterTachyonConf);\n    Assert.assertFalse(fsMasterClient.isConnected());\n    fsMasterClient.connect();\n    Assert.assertTrue(fsMasterClient.isConnected());\n    fsMasterClient.createFile(new TachyonURI(\"/file\"), CreateFileOptions.defaults());\n    Assert.assertTrue(fsMasterClient.getFileInfo(fsMasterClient.getFileId(\"/file\")) != null);\n    fsMasterClient.disconnect();\n    Assert.assertFalse(fsMasterClient.isConnected());\n    fsMasterClient.connect();\n    Assert.assertTrue(fsMasterClient.isConnected());\n    Assert.assertTrue(fsMasterClient.getFileInfo(fsMasterClient.getFileId(\"/file\")) != null);\n    fsMasterClient.close();\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setTTLForFileWithNoTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    executeTTLCheckOnce();\n    // Since no valid TTL is set, the file should not be deleted.\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().setTTL(0).build());\n    executeTTLCheckOnce();\n    // TTL is set to 0, the file should have been deleted during last TTL check.\n    mThrown.expect(FileDoesNotExistException.class);\n    mFileSystemMaster.getFileInfo(fileId);\n  }","id":34032,"modified_method":"@Test\n  public void setTTLForFileWithNoTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    executeTTLCheckOnce();\n    // Since no valid TTL is set, the file should not be deleted.\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults().setTTL(0));\n    executeTTLCheckOnce();\n    // TTL is set to 0, the file should have been deleted during last TTL check.\n    mThrown.expect(FileDoesNotExistException.class);\n    mFileSystemMaster.getFileInfo(fileId);\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setSmallerTTLForFileWithTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).setTTL(Constants.HOUR_MS).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    executeTTLCheckOnce();\n    // Since TTL is 1 hour, the file won't be deleted during last TTL check.\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().setTTL(0).build());\n    executeTTLCheckOnce();\n    // TTL is reset to 0, the file should have been deleted during last TTL check.\n    mThrown.expect(FileDoesNotExistException.class);\n    mFileSystemMaster.getFileInfo(fileId);\n  }","id":34033,"modified_method":"@Test\n  public void setSmallerTTLForFileWithTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).setTTL(Constants.HOUR_MS).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    executeTTLCheckOnce();\n    // Since TTL is 1 hour, the file won't be deleted during last TTL check.\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults().setTTL(0));\n    executeTTLCheckOnce();\n    // TTL is reset to 0, the file should have been deleted during last TTL check.\n    mThrown.expect(FileDoesNotExistException.class);\n    mFileSystemMaster.getFileInfo(fileId);\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setNoTTLForFileWithTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).setTTL(0).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    // After setting TTL to NO_TTL, the original TTL will be removed, and the file will not be\n    // deleted during next TTL check.\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().setTTL(Constants.NO_TTL)\n        .build());\n    executeTTLCheckOnce();\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n  }","id":34034,"modified_method":"@Test\n  public void setNoTTLForFileWithTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).setTTL(0).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    // After setting TTL to NO_TTL, the original TTL will be removed, and the file will not be\n    // deleted during next TTL check.\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults().setTTL(0));\n    executeTTLCheckOnce();\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setLargerTTLForFileWithTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).setTTL(0).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().setTTL(Constants.HOUR_MS)\n        .build());\n    executeTTLCheckOnce();\n    // TTL is reset to 1 hour, the file should not be deleted during last TTL check.\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n  }","id":34035,"modified_method":"@Test\n  public void setLargerTTLForFileWithTTLTest() throws Exception {\n    CreateOptions options =\n        new CreateOptions.Builder(MasterContext.getConf()).setBlockSizeBytes(Constants.KB)\n            .setRecursive(true).setTTL(0).build();\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, options);\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults().setTTL(Constants.HOUR_MS));\n    executeTTLCheckOnce();\n    // TTL is reset to 1 hour, the file should not be deleted during last TTL check.\n    Assert.assertEquals(fileId, mFileSystemMaster.getFileInfo(fileId).fileId);\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setStateTest() throws Exception {\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, sNestedFileOptions);\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertFalse(fileInfo.isPinned);\n    Assert.assertEquals(Constants.NO_TTL, fileInfo.getTtl());\n\n    // No State.\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().build());\n    fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertFalse(fileInfo.isPinned);\n    Assert.assertEquals(Constants.NO_TTL, fileInfo.getTtl());\n\n    // Just set pinned flag.\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().setPinned(true).build());\n    fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertTrue(fileInfo.isPinned);\n    Assert.assertEquals(Constants.NO_TTL, fileInfo.getTtl());\n\n    // Both pinned flag and ttl value.\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().setPinned(false).setTTL(1)\n        .build());\n    fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertFalse(fileInfo.isPinned);\n    Assert.assertEquals(1, fileInfo.getTtl());\n\n    // Set ttl for a directory, raise IllegalArgumentException.\n    mThrown.expect(IllegalArgumentException.class);\n    mFileSystemMaster.setState(mFileSystemMaster.getFileId(NESTED_URI),\n        new SetStateOptions.Builder().setTTL(1).build());\n  }","id":34036,"modified_method":"@Test\n  public void setStateTest() throws Exception {\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, sNestedFileOptions);\n    FileInfo fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertFalse(fileInfo.isPinned);\n    Assert.assertEquals(Constants.NO_TTL, fileInfo.getTtl());\n\n    // No State.\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults());\n    fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertFalse(fileInfo.isPinned);\n    Assert.assertEquals(Constants.NO_TTL, fileInfo.getTtl());\n\n    // Just set pinned flag.\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults().setPinned(true));\n    fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertTrue(fileInfo.isPinned);\n    Assert.assertEquals(Constants.NO_TTL, fileInfo.getTtl());\n\n    // Both pinned flag and ttl value.\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults().setPinned(false).setTTL(1));\n    fileInfo = mFileSystemMaster.getFileInfo(fileId);\n    Assert.assertFalse(fileInfo.isPinned);\n    Assert.assertEquals(1, fileInfo.getTtl());\n\n    // Set ttl for a directory, raise IllegalArgumentException.\n    mThrown.expect(IllegalArgumentException.class);\n    mFileSystemMaster.setState(mFileSystemMaster.getFileId(NESTED_URI), SetAttributeOptions\n        .defaults().setTTL(1));\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test Tachyon client connects or disconnects to the Master. When the client connects\n   * successfully to the Master, it can successfully create file or not.\n   *\n   * @param filename\n   * @throws Exception\n   */\n  private void authenticationOperationTest(String filename) throws Exception {\n    FileSystemMasterClient masterClient =\n        new FileSystemMasterClient(mLocalTachyonClusterResource.get().getMaster().getAddress(),\n            mLocalTachyonClusterResource.get().getMasterTachyonConf());\n    Assert.assertFalse(masterClient.isConnected());\n    masterClient.connect();\n    Assert.assertTrue(masterClient.isConnected());\n    masterClient.create(filename, CreateOptions.defaults());\n    Assert.assertNotNull(masterClient.getFileId(filename));\n    masterClient.disconnect();\n    masterClient.close();\n  }","id":34037,"modified_method":"/**\n   * Test Tachyon client connects or disconnects to the Master. When the client connects\n   * successfully to the Master, it can successfully create file or not.\n   *\n   * @param filename\n   * @throws Exception\n   */\n  private void authenticationOperationTest(String filename) throws Exception {\n    FileSystemMasterClient masterClient =\n        new FileSystemMasterClient(mLocalTachyonClusterResource.get().getMaster().getAddress(),\n            mLocalTachyonClusterResource.get().getMasterTachyonConf());\n    Assert.assertFalse(masterClient.isConnected());\n    masterClient.connect();\n    Assert.assertTrue(masterClient.isConnected());\n    masterClient.createFile(new TachyonURI(filename), CreateFileOptions.defaults());\n    Assert.assertNotNull(masterClient.getFileId(filename));\n    masterClient.disconnect();\n    masterClient.close();\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void setStateTest() throws Exception {\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, sNestedFileOptions);\n\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().build());\n\n    Assert.assertEquals(1, mCounters.get(\"SetStateOps\").getCount());\n  }","id":34038,"modified_method":"@Test\n  public void setStateTest() throws Exception {\n    long fileId = mFileSystemMaster.create(NESTED_FILE_URI, sNestedFileOptions);\n\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults());\n\n    Assert.assertEquals(1, mCounters.get(\"SetStateOps\").getCount());\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void filePersistedTest() throws Exception {\n    long fileId = createCompleteFileWithSingleBlock(NESTED_FILE_URI);\n\n    mFileSystemMaster.setState(fileId, new SetStateOptions.Builder().setPersisted(true).build());\n\n    Assert.assertEquals(1, mCounters.get(\"FilesPersisted\").getCount());\n  }","id":34039,"modified_method":"@Test\n  public void filePersistedTest() throws Exception {\n    long fileId = createCompleteFileWithSingleBlock(NESTED_FILE_URI);\n\n    mFileSystemMaster.setState(fileId, SetAttributeOptions.defaults().setPersisted(true));\n\n    Assert.assertEquals(1, mCounters.get(\"FilesPersisted\").getCount());\n  }","commit_id":"5e7db78d73fa5838a00d7760e44ee64d07c2f4fb","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the under storage type\n   */\n  public UnderStorageType getUnderStorageType() {\n    return mUnderStorageType;\n  }","id":34040,"modified_method":"/**\n   * @return the under storage type\n   */\n  public UnderStorageType getUnderStorageType() {\n    return mWriteType.getUnderStorageType();\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the name : value pairs for all the fields\n   */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"CreateFileOptions(\");\n    sb.append(super.toString()).append(\", BlockSizeBytes: \").append(mBlockSizeBytes);\n    sb.append(\", Location Policy: \").append(mLocationPolicy);\n    sb.append(\", TachyonStorageType: \").append(mTachyonStorageType.toString());\n    sb.append(\", UnderStorageType: \").append(mUnderStorageType.toString());\n    sb.append(\", TTL: \").append(mTTL);\n    sb.append(\")\");\n    return sb.toString();\n  }","id":34041,"modified_method":"/**\n   * @return the name : value pairs for all the fields\n   */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"CreateFileOptions(\");\n    sb.append(super.toString()).append(\", BlockSizeBytes: \").append(mBlockSizeBytes);\n    sb.append(\", TTL: \").append(mTTL);\n    sb.append(\", Location Policy: \").append(mLocationPolicy);\n    sb.append(\", WriteType: \").append(mWriteType.toString());\n    sb.append(\")\");\n    return sb.toString();\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return Thrift representation of the options\n   */\n  // TODO(calvin): Rename CreateTOptions to CreateFileTOptions\n  public CreateTOptions toThrift() {\n    CreateTOptions options = new CreateTOptions();\n    options.setBlockSizeBytes(mBlockSizeBytes);\n    options.setPersisted(mUnderStorageType.isSyncPersist());\n    options.setRecursive(mRecursive);\n    options.setTtl(mTTL);\n    return options;\n  }","id":34042,"modified_method":"/**\n   * @return Thrift representation of the options\n   */\n  // TODO(calvin): Rename CreateTOptions to CreateFileTOptions\n  public CreateTOptions toThrift() {\n    CreateTOptions options = new CreateTOptions();\n    options.setBlockSizeBytes(mBlockSizeBytes);\n    options.setPersisted(mWriteType.getUnderStorageType().isSyncPersist());\n    options.setRecursive(mRecursive);\n    options.setTtl(mTTL);\n    return options;\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return representation of this object in the form of {@link OutStreamOptions}\n   */\n  public OutStreamOptions toOutStreamOptions() {\n    OutStreamOptions.Builder builder = new OutStreamOptions.Builder();\n    builder.setBlockSizeBytes(mBlockSizeBytes).setLocationPolicy(mLocationPolicy)\n        .setTachyonStorageType(mTachyonStorageType).setTTL(mTTL)\n        .setUnderStorageType(mUnderStorageType);\n    return builder.build();\n  }","id":34043,"modified_method":"/**\n   * @return representation of this object in the form of {@link OutStreamOptions}\n   */\n  public OutStreamOptions toOutStreamOptions() {\n    return OutStreamOptions.defaults().setBlockSizeBytes(mBlockSizeBytes)\n        .setLocationPolicy(mLocationPolicy).setTTL(mTTL).setWriteType(mWriteType);\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance with defaults from the configuration.\n   */\n  private CreateFileOptions() {\n    mRecursive = true;\n    mBlockSizeBytes = ClientContext.getConf().getBytes(Constants.USER_BLOCK_SIZE_BYTES_DEFAULT);\n    try {\n      mLocationPolicy =\n          CommonUtils\n              .createNewClassInstance(\n                  ClientContext.getConf().<FileWriteLocationPolicy>getClass(\n                      Constants.USER_FILE_WRITE_LOCATION_POLICY),\n                  new Class[]{}, new Object[]{});\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n    WriteType defaultWriteType =\n        ClientContext.getConf().getEnum(Constants.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class);\n    mTachyonStorageType = defaultWriteType.getTachyonStorageType();\n    mUnderStorageType = defaultWriteType.getUnderStorageType();\n    mTTL = Constants.NO_TTL;\n  }","id":34044,"modified_method":"/**\n   * Creates a new instance with defaults from the configuration.\n   */\n  private CreateFileOptions() {\n    TachyonConf conf = ClientContext.getConf();\n    mRecursive = true;\n    mBlockSizeBytes = conf.getBytes(Constants.USER_BLOCK_SIZE_BYTES_DEFAULT);\n    try {\n      mLocationPolicy =\n          CommonUtils.createNewClassInstance(\n              conf.<FileWriteLocationPolicy>getClass(Constants.USER_FILE_WRITE_LOCATION_POLICY),\n              new Class[]{}, new Object[]{});\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n    mWriteType = conf.getEnum(Constants.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class);\n    mTTL = Constants.NO_TTL;\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the Tachyon storage type\n   */\n  public TachyonStorageType getTachyonStorageType() {\n    return mTachyonStorageType;\n  }","id":34045,"modified_method":"/**\n   * @return the Tachyon storage type\n   */\n  public TachyonStorageType getTachyonStorageType() {\n    return mWriteType.getTachyonStorageType();\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @param writeType the {@link tachyon.client.WriteType} to use for this operation. This will\n   *        override both the TachyonStorageType and UnderStorageType.\n   * @return this object\n   */\n  public CreateFileOptions setWriteType(WriteType writeType) {\n    mTachyonStorageType = writeType.getTachyonStorageType();\n    mUnderStorageType = writeType.getUnderStorageType();\n    return this;\n  }","id":34046,"modified_method":"/**\n   * @param writeType the {@link tachyon.client.WriteType} to use for this operation. This will\n   *        override both the TachyonStorageType and UnderStorageType.\n   * @return this object\n   */\n  public CreateFileOptions setWriteType(WriteType writeType) {\n    mWriteType = writeType;\n    return this;\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests that if an exception is thrown by the underlying out stream, and the user is using\n   * {@link UnderStorageType#NO_PERSIST} for their under storage type, the correct exception\n   * message will be thrown.\n   *\n   * @throws  IOException when the write fails\n   */\n  @Test\n  public void cacheWriteExceptionNonSyncPersistTest() throws IOException {\n    OutStreamOptions options = new OutStreamOptions.Builder(ClientContext.getConf())\n        .setBlockSizeBytes(BLOCK_LENGTH).setUnderStorageType(UnderStorageType.NO_PERSIST).build();\n    mTestStream = createTestStream(FILE_NAME, options);\n\n    BufferedBlockOutStream stream = Mockito.mock(BufferedBlockOutStream.class);\n    Whitebox.setInternalState(mTestStream, \"mCurrentBlockOutStream\", stream);\n    Mockito.when(stream.remaining()).thenReturn(BLOCK_LENGTH);\n    Mockito.doThrow(new IOException(\"test error\")).when(stream).write((byte) 7);\n    mThrown.expect(IOException.class);\n    mThrown.expectMessage(ExceptionMessage.FAILED_CACHE.getMessage(\"test error\"));\n    mTestStream.write(7);\n  }","id":34047,"modified_method":"/**\n   * Tests that if an exception is thrown by the underlying out stream, and the user is using\n   * {@link UnderStorageType#NO_PERSIST} for their under storage type, the correct exception\n   * message will be thrown.\n   *\n   * @throws  IOException when the write fails\n   */\n  @Test\n  public void cacheWriteExceptionNonSyncPersistTest() throws IOException {\n    OutStreamOptions options =\n        OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)\n            .setWriteType(WriteType.MUST_CACHE);\n    mTestStream = createTestStream(FILE_NAME, options);\n\n    BufferedBlockOutStream stream = Mockito.mock(BufferedBlockOutStream.class);\n    Whitebox.setInternalState(mTestStream, \"mCurrentBlockOutStream\", stream);\n    Mockito.when(stream.remaining()).thenReturn(BLOCK_LENGTH);\n    Mockito.doThrow(new IOException(\"test error\")).when(stream).write((byte) 7);\n    mThrown.expect(IOException.class);\n    mThrown.expectMessage(ExceptionMessage.FAILED_CACHE.getMessage(\"test error\"));\n    mTestStream.write(7);\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Sets up the different contexts and clients before a test runs.\n   *\n   * @throws Exception when the {@link FileSystemMasterClient} fails\n   */\n  @Before\n  public void before() throws Exception {\n    ClientTestUtils.setSmallBufferSizes();\n\n    // PowerMock enums and final classes\n    mFileSystemContext = PowerMockito.mock(FileSystemContext.class);\n    mBlockStore = PowerMockito.mock(TachyonBlockStore.class);\n    mBlockStoreContext = PowerMockito.mock(BlockStoreContext.class);\n    mFileSystemMasterClient = PowerMockito.mock(FileSystemMasterClient.class);\n    mBlockWorkerClient = PowerMockito.mock(BlockWorkerClient.class);\n\n    Mockito.when(mFileSystemContext.getTachyonBlockStore()).thenReturn(mBlockStore);\n    Mockito.when(mBlockStoreContext.acquireWorkerClient()).thenReturn(mBlockWorkerClient);\n    Mockito.when(mFileSystemContext.acquireMasterClient()).thenReturn(mFileSystemMasterClient);\n    Mockito.when(mFileSystemMasterClient.getFileInfo(Mockito.any(TachyonURI.class))).thenReturn(\n        new FileInfo());\n\n    // Return sequentially increasing numbers for new block ids\n    Mockito.when(mFileSystemMasterClient.getNewBlockIdForFile(FILE_NAME))\n        .thenAnswer(new Answer<Long>() {\n          private long mCount = 0;\n\n          @Override\n          public Long answer(InvocationOnMock invocation) throws Throwable {\n            return mCount ++;\n          }\n        });\n\n    // Set up out streams. When they are created, add them to outStreamMap\n    final Map<Long, TestBufferedBlockOutStream> outStreamMap = Maps.newHashMap();\n    Mockito.when(\n        mBlockStore.getOutStream(Mockito.anyLong(), Mockito.eq(BLOCK_LENGTH), Mockito.anyString()))\n        .thenAnswer(new Answer<BufferedBlockOutStream>() {\n          @Override\n          public BufferedBlockOutStream answer(InvocationOnMock invocation) throws Throwable {\n            Long blockId = invocation.getArgumentAt(0, Long.class);\n            if (!outStreamMap.containsKey(blockId)) {\n              TestBufferedBlockOutStream newStream =\n                  new TestBufferedBlockOutStream(blockId, BLOCK_LENGTH);\n              outStreamMap.put(blockId, newStream);\n            }\n            return outStreamMap.get(blockId);\n          }\n        });\n    BlockWorkerInfo workerInfo =\n        new BlockWorkerInfo(new WorkerNetAddress(\"localhost\", 1, 2, 3), Constants.GB, 0);\n    Mockito.when(mBlockStore.getWorkerInfoList()).thenReturn(Lists.newArrayList(workerInfo));\n    mTachyonOutStreamMap = outStreamMap;\n\n    // Create an under storage stream so that we can check whether it has been flushed\n    final AtomicBoolean underStorageFlushed = new AtomicBoolean(false);\n    mUnderStorageOutputStream = new ByteArrayOutputStream() {\n      @Override\n      public void flush() {\n        underStorageFlushed.set(true);\n      }\n    };\n    mUnderStorageFlushed = underStorageFlushed;\n\n    // Set up underFileStorage so that we can test UnderStorageType.SYNC_PERSIST\n    mUnderFileSystem = ClientMockUtils.mockUnderFileSystem();\n    Mockito.when(mUnderFileSystem.create(Mockito.anyString(), Mockito.eq((int) BLOCK_LENGTH)))\n        .thenReturn(mUnderStorageOutputStream);\n\n    OutStreamOptions options = new OutStreamOptions.Builder(ClientContext.getConf())\n        .setBlockSizeBytes(BLOCK_LENGTH).setUnderStorageType(UnderStorageType.SYNC_PERSIST).build();\n    mTestStream = createTestStream(FILE_NAME, options);\n  }","id":34048,"modified_method":"/**\n   * Sets up the different contexts and clients before a test runs.\n   *\n   * @throws Exception when the {@link FileSystemMasterClient} fails\n   */\n  @Before\n  public void before() throws Exception {\n    ClientTestUtils.setSmallBufferSizes();\n\n    // PowerMock enums and final classes\n    mFileSystemContext = PowerMockito.mock(FileSystemContext.class);\n    mBlockStore = PowerMockito.mock(TachyonBlockStore.class);\n    mBlockStoreContext = PowerMockito.mock(BlockStoreContext.class);\n    mFileSystemMasterClient = PowerMockito.mock(FileSystemMasterClient.class);\n    mBlockWorkerClient = PowerMockito.mock(BlockWorkerClient.class);\n\n    Mockito.when(mFileSystemContext.getTachyonBlockStore()).thenReturn(mBlockStore);\n    Mockito.when(mBlockStoreContext.acquireWorkerClient()).thenReturn(mBlockWorkerClient);\n    Mockito.when(mFileSystemContext.acquireMasterClient()).thenReturn(mFileSystemMasterClient);\n    Mockito.when(mFileSystemMasterClient.getFileInfo(Mockito.any(TachyonURI.class))).thenReturn(\n        new FileInfo());\n\n    // Return sequentially increasing numbers for new block ids\n    Mockito.when(mFileSystemMasterClient.getNewBlockIdForFile(FILE_NAME))\n        .thenAnswer(new Answer<Long>() {\n          private long mCount = 0;\n\n          @Override\n          public Long answer(InvocationOnMock invocation) throws Throwable {\n            return mCount ++;\n          }\n        });\n\n    // Set up out streams. When they are created, add them to outStreamMap\n    final Map<Long, TestBufferedBlockOutStream> outStreamMap = Maps.newHashMap();\n    Mockito.when(\n        mBlockStore.getOutStream(Mockito.anyLong(), Mockito.eq(BLOCK_LENGTH), Mockito.anyString()))\n        .thenAnswer(new Answer<BufferedBlockOutStream>() {\n          @Override\n          public BufferedBlockOutStream answer(InvocationOnMock invocation) throws Throwable {\n            Long blockId = invocation.getArgumentAt(0, Long.class);\n            if (!outStreamMap.containsKey(blockId)) {\n              TestBufferedBlockOutStream newStream =\n                  new TestBufferedBlockOutStream(blockId, BLOCK_LENGTH);\n              outStreamMap.put(blockId, newStream);\n            }\n            return outStreamMap.get(blockId);\n          }\n        });\n    BlockWorkerInfo workerInfo =\n        new BlockWorkerInfo(new WorkerNetAddress(\"localhost\", 1, 2, 3), Constants.GB, 0);\n    Mockito.when(mBlockStore.getWorkerInfoList()).thenReturn(Lists.newArrayList(workerInfo));\n    mTachyonOutStreamMap = outStreamMap;\n\n    // Create an under storage stream so that we can check whether it has been flushed\n    final AtomicBoolean underStorageFlushed = new AtomicBoolean(false);\n    mUnderStorageOutputStream = new ByteArrayOutputStream() {\n      @Override\n      public void flush() {\n        underStorageFlushed.set(true);\n      }\n    };\n    mUnderStorageFlushed = underStorageFlushed;\n\n    // Set up underFileStorage so that we can test UnderStorageType.SYNC_PERSIST\n    mUnderFileSystem = ClientMockUtils.mockUnderFileSystem();\n    Mockito.when(mUnderFileSystem.create(Mockito.anyString(), Mockito.eq((int) BLOCK_LENGTH)))\n        .thenReturn(mUnderStorageOutputStream);\n\n    OutStreamOptions options =\n        OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)\n            .setWriteType(WriteType.CACHE_THROUGH);\n    mTestStream = createTestStream(FILE_NAME, options);\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests the location policy created with different options.\n   */\n  @Test\n  public void locationPolicyTest() throws IOException {\n    OutStreamOptions options = new OutStreamOptions.Builder(ClientContext.getConf())\n        .setBlockSizeBytes(BLOCK_LENGTH).setUnderStorageType(UnderStorageType.NO_PERSIST).build();\n    mTestStream = createTestStream(FILE_NAME, options);\n\n    // by default local first policy used\n    FileWriteLocationPolicy policy = Whitebox.getInternalState(mTestStream, \"mLocationPolicy\");\n    Assert.assertTrue(policy instanceof LocalFirstPolicy);\n\n    // configure a different policy\n    options = new OutStreamOptions.Builder(ClientContext.getConf()).setBlockSizeBytes(BLOCK_LENGTH)\n        .setUnderStorageType(UnderStorageType.NO_PERSIST)\n        .setLocationPolicy(new RoundRobinPolicy()).build();\n    mTestStream = createTestStream(FILE_NAME, options);\n    policy = Whitebox.getInternalState(mTestStream, \"mLocationPolicy\");\n    Assert.assertTrue(policy instanceof RoundRobinPolicy);\n  }","id":34049,"modified_method":"/**\n   * Tests the location policy created with different options.\n   */\n  @Test\n  public void locationPolicyTest() throws IOException {\n    OutStreamOptions options =\n        OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)\n            .setWriteType(WriteType.MUST_CACHE);\n    mTestStream = createTestStream(FILE_NAME, options);\n\n    // by default local first policy used\n    FileWriteLocationPolicy policy = Whitebox.getInternalState(mTestStream, \"mLocationPolicy\");\n    Assert.assertTrue(policy instanceof LocalFirstPolicy);\n\n    // configure a different policy\n    options.setLocationPolicy(new RoundRobinPolicy());\n    mTestStream = createTestStream(FILE_NAME, options);\n    policy = Whitebox.getInternalState(mTestStream, \"mLocationPolicy\");\n    Assert.assertTrue(policy instanceof RoundRobinPolicy);\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"private static OutStreamOptions updateOutStreamOptions(OutStreamOptions options) {\n    // change the under storage type to async\n    OutStreamOptions.Builder builder = new OutStreamOptions.Builder(ClientContext.getConf());\n    builder.setBlockSizeBytes(options.getBlockSizeBytes());\n    builder.setLocationPolicy(options.getLocationPolicy());\n    builder.setTachyonStorageType(options.getTachyonStorageType());\n    builder.setTTL(options.getTTL());\n    builder.setUnderStorageType(UnderStorageType.ASYNC_PERSIST);\n    return builder.build();\n  }","id":34050,"modified_method":"private static OutStreamOptions updateOutStreamOptions(OutStreamOptions options) {\n    return options.setWriteType(WriteType.ASYNC_THROUGH);\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the default {@link OutStreamOptions}\n   */\n  public static OutStreamOptions defaults() {\n    return new Builder().build();\n  }","id":34051,"modified_method":"/**\n   * @return the default {@link OutStreamOptions}\n   */\n  public static OutStreamOptions defaults() {\n    return new OutStreamOptions();\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the under storage type\n   */\n  public UnderStorageType getUnderStorageType() {\n    return mUnderStorageType;\n  }","id":34052,"modified_method":"/**\n   * @return the under storage type\n   */\n  public UnderStorageType getUnderStorageType() {\n    return mWriteType.getUnderStorageType();\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the name : value pairs for all the fields\n   */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"OutStreamOptions(\");\n    sb.append(super.toString()).append(\", BlockSizeBytes: \").append(mBlockSizeBytes);\n    sb.append(\", TachyonStorageType: \").append(mTachyonStorageType.toString());\n    sb.append(\", UnderStorageType: \").append(mUnderStorageType.toString());\n    sb.append(\", TTL: \").append(mTTL);\n    sb.append(\", LocationPolicy: \").append(mLocationPolicy.toString());\n    sb.append(\")\");\n    return sb.toString();\n  }","id":34053,"modified_method":"/**\n   * @return the name : value pairs for all the fields\n   */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"OutStreamOptions(\");\n    sb.append(super.toString()).append(\", BlockSizeBytes: \").append(mBlockSizeBytes);\n    sb.append(\", TTL: \").append(mTTL);\n    sb.append(\", LocationPolicy: \").append(mLocationPolicy.toString());\n    sb.append(\", WriteType: \").append(mWriteType.toString());\n    sb.append(\")\");\n    return sb.toString();\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"private OutStreamOptions(OutStreamOptions.Builder builder) {\n    mBlockSizeBytes = builder.mBlockSizeBytes;\n    mTachyonStorageType = builder.mTachyonStorageType;\n    mTTL = builder.mTTL;\n    mUnderStorageType = builder.mUnderStorageType;\n    mLocationPolicy = builder.mLocationPolicy;\n  }","id":34054,"modified_method":"private OutStreamOptions() {\n    TachyonConf conf = ClientContext.getConf();\n    mBlockSizeBytes = conf.getBytes(Constants.USER_BLOCK_SIZE_BYTES_DEFAULT);\n    mTTL = Constants.NO_TTL;\n    try {\n      mLocationPolicy =\n          CommonUtils.createNewClassInstance(ClientContext.getConf()\n              .<FileWriteLocationPolicy>getClass(Constants.USER_FILE_WRITE_LOCATION_POLICY),\n              new Class[] {}, new Object[] {});\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n    mWriteType = conf.getEnum(Constants.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class);\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @return the Tachyon storage type\n   */\n  public TachyonStorageType getTachyonStorageType() {\n    return mTachyonStorageType;\n  }","id":34055,"modified_method":"/**\n   * @return the Tachyon storage type\n   */\n  public TachyonStorageType getTachyonStorageType() {\n    return mWriteType.getTachyonStorageType();\n  }","commit_id":"738cc5ea13a0ba944e188a9d49518fe1da5830ad","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public CommonCodeStyleSettings getDefaultCommonSettings() {\n    CommonCodeStyleSettings defaultSettings = new CommonCodeStyleSettings(getLanguage());\n    CommonCodeStyleSettings.IndentOptions indentOptions = defaultSettings.initIndentOptions();\n    indentOptions.INDENT_SIZE = 2;\n    indentOptions.CONTINUATION_INDENT_SIZE = 4;\n    indentOptions.TAB_SIZE = 2;\n    defaultSettings.RIGHT_MARGIN = 80;\n    defaultSettings.CALL_PARAMETERS_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.METHOD_PARAMETERS_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.ARRAY_INITIALIZER_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.BINARY_OPERATION_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.ASSIGNMENT_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED; // TODO Remove if not needed.\n    defaultSettings.ARRAY_INITIALIZER_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.TERNARY_OPERATION_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.TERNARY_OPERATION_SIGNS_ON_NEXT_LINE = true;\n    defaultSettings.ALIGN_MULTILINE_TERNARY_OPERATION = false;\n    defaultSettings.ALIGN_MULTILINE_PARAMETERS = false;\n    defaultSettings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE = true;\n    defaultSettings.KEEP_SIMPLE_METHODS_IN_ONE_LINE = true;\n    defaultSettings.KEEP_SIMPLE_CLASSES_IN_ONE_LINE = true;\n    return defaultSettings;\n  }","id":34056,"modified_method":"@Override\n  public CommonCodeStyleSettings getDefaultCommonSettings() {\n    CommonCodeStyleSettings defaultSettings = new CommonCodeStyleSettings(getLanguage());\n    CommonCodeStyleSettings.IndentOptions indentOptions = defaultSettings.initIndentOptions();\n    indentOptions.INDENT_SIZE = 2;\n    indentOptions.CONTINUATION_INDENT_SIZE = 4;\n    indentOptions.TAB_SIZE = 2;\n    defaultSettings.RIGHT_MARGIN = 80;\n    defaultSettings.CALL_PARAMETERS_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.METHOD_PARAMETERS_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.ARRAY_INITIALIZER_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.BINARY_OPERATION_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.ASSIGNMENT_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED; // TODO Remove if not needed.\n    defaultSettings.ARRAY_INITIALIZER_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED;\n    defaultSettings.TERNARY_OPERATION_WRAP = CommonCodeStyleSettings.WRAP_AS_NEEDED | CommonCodeStyleSettings.WRAP_ON_EVERY_ITEM;\n    defaultSettings.TERNARY_OPERATION_SIGNS_ON_NEXT_LINE = true;\n    defaultSettings.ALIGN_MULTILINE_TERNARY_OPERATION = false;\n    defaultSettings.ALIGN_MULTILINE_PARAMETERS = false;\n    defaultSettings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE = true;\n    defaultSettings.KEEP_SIMPLE_METHODS_IN_ONE_LINE = true;\n    defaultSettings.KEEP_SIMPLE_CLASSES_IN_ONE_LINE = true;\n    return defaultSettings;\n  }","commit_id":"af01ce44da28174cf066d4c5eca5e34f773526f5","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"Wrap createChildWrap(ASTNode child, Wrap defaultWrap, Wrap childWrap) {\n    final IElementType childType = child.getElementType();\n    final IElementType elementType = myNode.getElementType();\n    if (childType == COMMA || childType == SEMICOLON) return defaultWrap;\n\n    //\n    // Function definition/call\n    //\n    if (elementType == ARGUMENT_LIST) {\n      if (mySettings.CALL_PARAMETERS_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n        //if (myNode.getFirstChildNode() == child) {\n        //  return createWrap(true); // Allow first arg to wrap.\n        //}\n        if (!mySettings.PREFER_PARAMETERS_WRAP && childWrap != null) {\n          // Not used; PREFER_PARAMETERS_WRAP cannot be changed in the UI.\n          return Wrap.createChildWrap(childWrap, WrappingUtil.getWrapType(mySettings.CALL_PARAMETERS_WRAP), true);\n        }\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n      }\n    }\n\n    if (elementType == FORMAL_PARAMETER_LIST) {\n      if (mySettings.METHOD_PARAMETERS_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n        if (myNode.getFirstChildNode() == child) {\n          return createWrap(mySettings.METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE);\n        }\n        if (childType == RPAREN) {\n          return createWrap(mySettings.METHOD_PARAMETERS_RPAREN_ON_NEXT_LINE);\n        }\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.METHOD_PARAMETERS_WRAP), true);\n      }\n    }\n\n    if (elementType == INITIALIZERS) {\n      if (childType != COLON && isNotFirstInitializer(child)) {\n        return Wrap.createWrap(WrapType.ALWAYS, true);\n      }\n      if (childType == COLON && !DartSpacingProcessor.hasMultipleInitializers(child)) {\n        return Wrap.createWrap(WrapType.NORMAL, true);\n      }\n    }\n\n    //\n    // Wrap after arrows.\n    //\n    if (elementType == FUNCTION_BODY) {\n      if (FormatterUtil.isPrecededBy(child, EXPRESSION_BODY_DEF)) {\n        return createWrap(true);\n      }\n    }\n    if (childType == CALL_EXPRESSION) {\n      if (FormatterUtil.isPrecededBy(child, EXPRESSION_BODY_DEF)) {\n        return createWrap(true);\n      }\n      if (mySettings.CALL_PARAMETERS_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n        if (childType == RPAREN) {\n          return createWrap(mySettings.CALL_PARAMETERS_RPAREN_ON_NEXT_LINE);\n        }\n      }\n    }\n\n    //\n    // If\n    //\n    if (elementType == IF_STATEMENT && childType == ELSE) {\n      return createWrap(mySettings.ELSE_ON_NEW_LINE);\n    }\n\n    //\n    //Binary expressions\n    //\n    if (BINARY_EXPRESSIONS.contains(elementType) && mySettings.BINARY_OPERATION_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n      if ((mySettings.BINARY_OPERATION_SIGN_ON_NEXT_LINE && BINARY_OPERATORS.contains(childType)) ||\n          (!mySettings.BINARY_OPERATION_SIGN_ON_NEXT_LINE && isRightOperand(child))) {\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.BINARY_OPERATION_WRAP), true);\n      }\n    }\n\n    //\n    // Assignment\n    //\n    if (elementType == ASSIGN_EXPRESSION && mySettings.ASSIGNMENT_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n      if (childType != ASSIGNMENT_OPERATOR) {\n        if (FormatterUtil.isPrecededBy(child, ASSIGNMENT_OPERATOR) &&\n            mySettings.PLACE_ASSIGNMENT_SIGN_ON_NEXT_LINE) {\n          return Wrap.createWrap(WrapType.NONE, true);\n        }\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.ASSIGNMENT_WRAP), true);\n      }\n      else if (mySettings.PLACE_ASSIGNMENT_SIGN_ON_NEXT_LINE) {\n        return Wrap.createWrap(WrapType.NORMAL, true);\n      }\n    }\n\n    //\n    // Ternary expressions\n    //\n    if (elementType == TERNARY_EXPRESSION) {\n      if (myNode.getFirstChildNode() != child) {\n        if (mySettings.TERNARY_OPERATION_SIGNS_ON_NEXT_LINE) {\n          //if (!FormatterUtil.isPrecededBy(child, QUEST) &&\n          //    !FormatterUtil.isPrecededBy(child, COLON)) {\n          // TODO Allow ? and : to align on two continuation lines.\n          if (childType == QUEST || childType == COLON) {\n            return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.TERNARY_OPERATION_WRAP), true);\n          }\n        }\n        else if (childType != QUEST && childType != COLON) {\n          return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.TERNARY_OPERATION_WRAP), true);\n        }\n      }\n      return Wrap.createWrap(WrapType.NONE, true);\n    }\n\n    if (childType == HIDE_COMBINATOR || childType == SHOW_COMBINATOR) {\n      return createWrap(true);\n    }\n\n    if (childType == VAR_DECLARATION_LIST && elementType != FOR_LOOP_PARTS) {\n      if (varDeclListContainsVarInit(child)) {\n        return Wrap.createWrap(WrapType.ALWAYS, true);\n      } else {\n        return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n      }\n    }\n    if (childType == VAR_DECLARATION_LIST_PART) {\n      ASTNode parent = myNode.getTreeParent();\n      if (parent != null && parent.getElementType() == FOR_LOOP_PARTS) {\n        return Wrap.createWrap(WrapType.NORMAL, true);\n      } else {\n        if (varDeclListContainsVarInit(myNode)) {\n          return Wrap.createWrap(WrapType.ALWAYS, true);\n        } else {\n          return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n        }\n      }\n    }\n\n    if (elementType == CLASS_DEFINITION) {\n      if (childType == SUPERCLASS || childType == INTERFACES || childType == MIXINS) {\n        return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n      }\n    }\n    if (elementType == MIXIN_APPLICATION && childType == MIXINS) {\n      return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n    }\n\n    return defaultWrap;\n  }","id":34057,"modified_method":"Wrap createChildWrap(ASTNode child, Wrap defaultWrap, Wrap childWrap) {\n    final IElementType childType = child.getElementType();\n    final IElementType elementType = myNode.getElementType();\n    if (childType == COMMA || childType == SEMICOLON) return defaultWrap;\n\n    //\n    // Function definition/call\n    //\n    if (elementType == ARGUMENT_LIST) {\n      if (mySettings.CALL_PARAMETERS_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n        //if (myNode.getFirstChildNode() == child) {\n        //  return createWrap(true); // Allow first arg to wrap.\n        //}\n        if (!mySettings.PREFER_PARAMETERS_WRAP && childWrap != null) {\n          // Not used; PREFER_PARAMETERS_WRAP cannot be changed in the UI.\n          return Wrap.createChildWrap(childWrap, WrappingUtil.getWrapType(mySettings.CALL_PARAMETERS_WRAP), true);\n        }\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n      }\n    }\n\n    if (elementType == FORMAL_PARAMETER_LIST) {\n      if (mySettings.METHOD_PARAMETERS_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n        if (myNode.getFirstChildNode() == child) {\n          return createWrap(mySettings.METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE);\n        }\n        if (childType == RPAREN) {\n          return createWrap(mySettings.METHOD_PARAMETERS_RPAREN_ON_NEXT_LINE);\n        }\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.METHOD_PARAMETERS_WRAP), true);\n      }\n    }\n\n    if (elementType == INITIALIZERS) {\n      if (childType != COLON && isNotFirstInitializer(child)) {\n        return Wrap.createWrap(WrapType.ALWAYS, true);\n      }\n      if (childType == COLON && !DartSpacingProcessor.hasMultipleInitializers(child)) {\n        return Wrap.createWrap(WrapType.NORMAL, true);\n      }\n    }\n\n    //\n    // Wrap after arrows.\n    //\n    if (elementType == FUNCTION_BODY) {\n      if (FormatterUtil.isPrecededBy(child, EXPRESSION_BODY_DEF)) {\n        return createWrap(true);\n      }\n    }\n    if (childType == CALL_EXPRESSION) {\n      if (FormatterUtil.isPrecededBy(child, EXPRESSION_BODY_DEF)) {\n        return createWrap(true);\n      }\n      if (mySettings.CALL_PARAMETERS_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n        if (childType == RPAREN) {\n          return createWrap(mySettings.CALL_PARAMETERS_RPAREN_ON_NEXT_LINE);\n        }\n      }\n    }\n\n    //\n    // If\n    //\n    if (elementType == IF_STATEMENT && childType == ELSE) {\n      return createWrap(mySettings.ELSE_ON_NEW_LINE);\n    }\n\n    //\n    //Binary expressions\n    //\n    if (BINARY_EXPRESSIONS.contains(elementType) && mySettings.BINARY_OPERATION_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n      if ((mySettings.BINARY_OPERATION_SIGN_ON_NEXT_LINE && BINARY_OPERATORS.contains(childType)) ||\n          (!mySettings.BINARY_OPERATION_SIGN_ON_NEXT_LINE && isRightOperand(child))) {\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.BINARY_OPERATION_WRAP), true);\n      }\n    }\n\n    //\n    // Assignment\n    //\n    if (elementType == ASSIGN_EXPRESSION && mySettings.ASSIGNMENT_WRAP != CommonCodeStyleSettings.DO_NOT_WRAP) {\n      if (childType != ASSIGNMENT_OPERATOR) {\n        if (FormatterUtil.isPrecededBy(child, ASSIGNMENT_OPERATOR) &&\n            mySettings.PLACE_ASSIGNMENT_SIGN_ON_NEXT_LINE) {\n          return Wrap.createWrap(WrapType.NONE, true);\n        }\n        return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.ASSIGNMENT_WRAP), true);\n      }\n      else if (mySettings.PLACE_ASSIGNMENT_SIGN_ON_NEXT_LINE) {\n        return Wrap.createWrap(WrapType.NORMAL, true);\n      }\n    }\n\n    //\n    // Ternary expressions\n    //\n    if (elementType == TERNARY_EXPRESSION) {\n      if (myNode.getFirstChildNode() != child) {\n        if (mySettings.TERNARY_OPERATION_SIGNS_ON_NEXT_LINE) {\n          if (childType == QUEST) {\n            final Wrap wrap = Wrap.createWrap(WrappingUtil.getWrapType(mySettings.TERNARY_OPERATION_WRAP), true);\n            myNode.putUserData(DART_TERNARY_EXPRESSION_WRAP_KEY, wrap);\n            return wrap;\n          }\n\n          if (childType == COLON) {\n            final Wrap wrap = myNode.getUserData(DART_TERNARY_EXPRESSION_WRAP_KEY);\n            myNode.putUserData(DART_TERNARY_EXPRESSION_WRAP_KEY, null);\n            return wrap != null ? wrap : Wrap.createWrap(WrappingUtil.getWrapType(mySettings.TERNARY_OPERATION_WRAP), true);\n          }\n        }\n        else if (childType != QUEST && childType != COLON) {\n          return Wrap.createWrap(WrappingUtil.getWrapType(mySettings.TERNARY_OPERATION_WRAP), true);\n        }\n      }\n      return Wrap.createWrap(WrapType.NONE, true);\n    }\n\n    if (childType == HIDE_COMBINATOR || childType == SHOW_COMBINATOR) {\n      return createWrap(true);\n    }\n\n    if (childType == VAR_DECLARATION_LIST && elementType != FOR_LOOP_PARTS) {\n      if (varDeclListContainsVarInit(child)) {\n        return Wrap.createWrap(WrapType.ALWAYS, true);\n      }\n      else {\n        return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n      }\n    }\n    if (childType == VAR_DECLARATION_LIST_PART) {\n      ASTNode parent = myNode.getTreeParent();\n      if (parent != null && parent.getElementType() == FOR_LOOP_PARTS) {\n        return Wrap.createWrap(WrapType.NORMAL, true);\n      }\n      else {\n        if (varDeclListContainsVarInit(myNode)) {\n          return Wrap.createWrap(WrapType.ALWAYS, true);\n        }\n        else {\n          return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n        }\n      }\n    }\n\n    if (elementType == CLASS_DEFINITION) {\n      if (childType == SUPERCLASS || childType == INTERFACES || childType == MIXINS) {\n        return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n      }\n    }\n    if (elementType == MIXIN_APPLICATION && childType == MIXINS) {\n      return Wrap.createWrap(WrapType.CHOP_DOWN_IF_LONG, true);\n    }\n\n    return defaultWrap;\n  }","commit_id":"af01ce44da28174cf066d4c5eca5e34f773526f5","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  protected ASTNode processChild(final List<Block> result,\n                                 ASTNode child,\n                                 @NotNull AlignmentStrategy alignmentStrategy,\n                                 final Wrap defaultWrap,\n                                 final Indent childIndent,\n                                 int childOffset) {\n    final IElementType childType = child.getElementType();\n    if (childType == JavaTokenType.CLASS_KEYWORD || childType == JavaTokenType.INTERFACE_KEYWORD) {\n      myIsAfterClassKeyword = true;\n    }\n    if (childType == JavaElementType.METHOD_CALL_EXPRESSION) {\n      result.add(createMethodCallExpressionBlock(child,\n                                                 arrangeChildWrap(child, defaultWrap),\n                                                 arrangeChildAlignment(child, alignmentStrategy)));\n    }\n    else {\n      final IElementType nodeType = myNode.getElementType();\n\n      if (childType == JavaTokenType.LBRACE && nodeType == JavaElementType.ARRAY_INITIALIZER_EXPRESSION) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.ARRAY_INITIALIZER_WRAP), false);\n        child = processParenthesisBlock(JavaTokenType.LBRACE, JavaTokenType.RBRACE,\n                                  result,\n                                  child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION);\n      }\n      else if (childType == JavaTokenType.LBRACE && nodeType == JavaElementType.ANNOTATION_ARRAY_INITIALIZER) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.ARRAY_INITIALIZER_WRAP), false);\n        child = processParenthesisBlock(JavaTokenType.LBRACE, JavaTokenType.RBRACE,\n                                  result,\n                                  child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION);\n      }\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.EXPRESSION_LIST) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n        if (mySettings.PREFER_PARAMETERS_WRAP) {\n          wrap.ignoreParentWraps();\n        }\n        child = processParenthesisBlock(result,\n                                  child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_PARAMETERS_IN_CALLS);\n      }\n\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.PARAMETER_LIST) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.METHOD_PARAMETERS_WRAP), false);\n        child = processParenthesisBlock(result, child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_PARAMETERS);\n      }\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.ANNOTATION_PARAMETER_LIST) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n        child = processParenthesisBlock(result, child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_PARAMETERS_IN_CALLS);\n      }\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.PARENTH_EXPRESSION) {\n        child = processParenthesisBlock(result, child,\n                                  WrappingStrategy.DO_NOT_WRAP,\n                                  mySettings.ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION);\n      }\n      else if (childType == JavaElementType.ENUM_CONSTANT && myNode instanceof ClassElement) {\n        child = processEnumBlock(result, child, ((ClassElement)myNode).findEnumConstantListDelimiterPlace());\n      }\n      else if (mySettings.TERNARY_OPERATION_SIGNS_ON_NEXT_LINE && isTernaryOperationSign(child)) {\n        child = processTernaryOperationRange(result, child, defaultWrap, childIndent);\n      }\n      else if (childType == JavaElementType.FIELD) {\n        child = processField(result, child, alignmentStrategy, defaultWrap, childIndent);\n      }\n      else if (childType == JavaElementType.LOCAL_VARIABLE\n               || (childType == JavaElementType.DECLARATION_STATEMENT && myNode.getElementType() == JavaElementType.METHOD))\n      {\n        result.add(new SimpleJavaBlock(child, defaultWrap, alignmentStrategy, childIndent, mySettings));\n      }\n      else {\n        final Block block =\n          createJavaBlock(child, mySettings, childIndent, arrangeChildWrap(child, defaultWrap),\n                          AlignmentStrategy.wrap(arrangeChildAlignment(child, alignmentStrategy)), childOffset);\n\n        if (childType == JavaElementType.MODIFIER_LIST && containsAnnotations(child)) {\n          myAnnotationWrap = Wrap.createWrap(getWrapType(getAnnotationWrapType()), true);\n        }\n\n        if (block instanceof AbstractJavaBlock) {\n          final AbstractJavaBlock javaBlock = (AbstractJavaBlock)block;\n          if (nodeType == JavaElementType.METHOD_CALL_EXPRESSION && childType == JavaElementType.REFERENCE_EXPRESSION) {\n            javaBlock.setReservedWrap(getReservedWrap(nodeType), nodeType);\n            javaBlock.setReservedWrap(getReservedWrap(childType), childType);\n          }\n          else if (nodeType == JavaElementType.REFERENCE_EXPRESSION &&\n                   childType == JavaElementType.METHOD_CALL_EXPRESSION) {\n            javaBlock.setReservedWrap(getReservedWrap(nodeType), nodeType);\n            javaBlock.setReservedWrap(getReservedWrap(childType), childType);\n          }\n          else if (nodeType == JavaElementType.BINARY_EXPRESSION) {\n            javaBlock.setReservedWrap(defaultWrap, nodeType);\n          }\n          else if (childType == JavaElementType.MODIFIER_LIST) {\n            javaBlock.setReservedWrap(myAnnotationWrap, JavaElementType.MODIFIER_LIST);\n            if (!lastChildIsAnnotation(child)) {\n              myAnnotationWrap = null;\n            }\n          }\n        }\n\n        result.add(block);\n      }\n    }\n\n\n    return child;\n  }","id":34058,"modified_method":"@Nullable\n  protected ASTNode processChild(final List<Block> result,\n                                 ASTNode child,\n                                 @NotNull AlignmentStrategy alignmentStrategy,\n                                 final Wrap defaultWrap,\n                                 final Indent childIndent,\n                                 int childOffset) {\n    final IElementType childType = child.getElementType();\n    if (childType == JavaTokenType.CLASS_KEYWORD || childType == JavaTokenType.INTERFACE_KEYWORD) {\n      myIsAfterClassKeyword = true;\n    }\n    if (childType == JavaElementType.METHOD_CALL_EXPRESSION) {\n      result.add(createMethodCallExpressionBlock(child,\n                                                 arrangeChildWrap(child, defaultWrap),\n                                                 arrangeChildAlignment(child, alignmentStrategy)));\n    }\n    else {\n      final IElementType nodeType = myNode.getElementType();\n\n      if (childType == JavaTokenType.LBRACE && nodeType == JavaElementType.ARRAY_INITIALIZER_EXPRESSION) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.ARRAY_INITIALIZER_WRAP), false);\n        child = processParenthesisBlock(JavaTokenType.LBRACE, JavaTokenType.RBRACE,\n                                  result,\n                                  child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION);\n      }\n      else if (childType == JavaTokenType.LBRACE && nodeType == JavaElementType.ANNOTATION_ARRAY_INITIALIZER) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.ARRAY_INITIALIZER_WRAP), false);\n        child = processParenthesisBlock(JavaTokenType.LBRACE, JavaTokenType.RBRACE,\n                                  result,\n                                  child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION);\n      }\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.EXPRESSION_LIST) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n        if (mySettings.PREFER_PARAMETERS_WRAP) {\n          wrap.ignoreParentWraps();\n        }\n        child = processParenthesisBlock(result,\n                                  child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_PARAMETERS_IN_CALLS);\n      }\n\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.PARAMETER_LIST) {\n        final Wrap wrap;\n        Wrap reservedWrap = getReservedWrap(JavaElementType.MODIFIER_LIST);\n        // There is a possible case that particular annotated method definition is too long. We may wrap either after annotation\n        // or after opening lbrace then. Our strategy is to wrap after annotation whenever possible.\n        if (reservedWrap == null) {\n          wrap = Wrap.createWrap(getWrapType(mySettings.METHOD_PARAMETERS_WRAP), false);\n        }\n        else {\n          wrap = Wrap.createChildWrap(reservedWrap, getWrapType(mySettings.METHOD_PARAMETERS_WRAP), false);\n        }\n        child = processParenthesisBlock(result, child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_PARAMETERS);\n      }\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.ANNOTATION_PARAMETER_LIST) {\n        final Wrap wrap = Wrap.createWrap(getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n        child = processParenthesisBlock(result, child,\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  mySettings.ALIGN_MULTILINE_PARAMETERS_IN_CALLS);\n      }\n      else if (childType == JavaTokenType.LPARENTH && nodeType == JavaElementType.PARENTH_EXPRESSION) {\n        child = processParenthesisBlock(result, child,\n                                  WrappingStrategy.DO_NOT_WRAP,\n                                  mySettings.ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION);\n      }\n      else if (childType == JavaElementType.ENUM_CONSTANT && myNode instanceof ClassElement) {\n        child = processEnumBlock(result, child, ((ClassElement)myNode).findEnumConstantListDelimiterPlace());\n      }\n      else if (mySettings.TERNARY_OPERATION_SIGNS_ON_NEXT_LINE && isTernaryOperationSign(child)) {\n        child = processTernaryOperationRange(result, child, defaultWrap, childIndent);\n      }\n      else if (childType == JavaElementType.FIELD) {\n        child = processField(result, child, alignmentStrategy, defaultWrap, childIndent);\n      }\n      else if (childType == JavaElementType.LOCAL_VARIABLE\n               || (childType == JavaElementType.DECLARATION_STATEMENT && myNode.getElementType() == JavaElementType.METHOD))\n      {\n        result.add(new SimpleJavaBlock(child, defaultWrap, alignmentStrategy, childIndent, mySettings));\n      }\n      else {\n        final Block block =\n          createJavaBlock(child, mySettings, childIndent, arrangeChildWrap(child, defaultWrap),\n                          AlignmentStrategy.wrap(arrangeChildAlignment(child, alignmentStrategy)), childOffset);\n\n        if (childType == JavaElementType.MODIFIER_LIST && containsAnnotations(child)) {\n          myAnnotationWrap = Wrap.createWrap(getWrapType(getAnnotationWrapType()), true);\n        }\n\n        if (block instanceof AbstractJavaBlock) {\n          final AbstractJavaBlock javaBlock = (AbstractJavaBlock)block;\n          if (nodeType == JavaElementType.METHOD_CALL_EXPRESSION && childType == JavaElementType.REFERENCE_EXPRESSION) {\n            javaBlock.setReservedWrap(getReservedWrap(nodeType), nodeType);\n            javaBlock.setReservedWrap(getReservedWrap(childType), childType);\n          }\n          else if (nodeType == JavaElementType.REFERENCE_EXPRESSION &&\n                   childType == JavaElementType.METHOD_CALL_EXPRESSION) {\n            javaBlock.setReservedWrap(getReservedWrap(nodeType), nodeType);\n            javaBlock.setReservedWrap(getReservedWrap(childType), childType);\n          }\n          else if (nodeType == JavaElementType.BINARY_EXPRESSION) {\n            javaBlock.setReservedWrap(defaultWrap, nodeType);\n          }\n          else if (childType == JavaElementType.MODIFIER_LIST) {\n            javaBlock.setReservedWrap(myAnnotationWrap, JavaElementType.MODIFIER_LIST);\n            if (!lastChildIsAnnotation(child)) {\n              myAnnotationWrap = null;\n            }\n          }\n          else if (childType == JavaElementType.PARAMETER_LIST && nodeType == JavaElementType.METHOD) {\n            // We prefer wrapping after method annotation to wrapping method parameter list, hence, deliver target wrap object\n            // to child block if necessary.\n            if (!result.isEmpty()) {\n              Block firstChildBlock = result.get(0);\n              if (firstChildBlock instanceof AbstractJavaBlock) {\n                AbstractJavaBlock childJavaBlock = (AbstractJavaBlock)firstChildBlock;\n                if (firstChildIsAnnotation(childJavaBlock.getNode())) {\n                  javaBlock.setReservedWrap(childJavaBlock.getReservedWrap(JavaElementType.MODIFIER_LIST), JavaElementType.MODIFIER_LIST);\n                }\n              }\n            }\n          }\n        }\n\n        result.add(block);\n      }\n    }\n\n\n    return child;\n  }","commit_id":"034bcc56c9c2fc92f884fc7b9fd0ecdfc6c49937","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Wrap getChainedMethodCallWrap() {\n    return Wrap.createWrap(mySettings.METHOD_CALL_CHAIN_WRAP, false);\n  }","id":34059,"modified_method":"public Wrap getChainedMethodCallWrap() {\n    return myContext.isInsidePlainGString() ? Wrap.createWrap(WrapType.NONE, false)\n                                            : Wrap.createWrap(mySettings.METHOD_CALL_CHAIN_WRAP, false);\n  }","commit_id":"4cd7b8a0ecae5b80ebf772fbff21e42d9dbb8087","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void execute(final InstallationContext ctx) {\n        final TaskResource tr = this.getResource();\n        ctx.log(\"Installing new subsystem from {}\", tr);\n\n        try {\n            final Subsystem sub = this.rootSubsystem.install(tr.getURL(), tr.getInputStream());\n            sub.start();\n            ctx.addTaskToCurrentCycle(new ChangeStateTask(this.getResourceGroup(), ResourceState.INSTALLED));\n        } catch (final IOException e) {\n            ctx.log(\"Unable to install subsystem {} : {}\", tr, e);\n            ctx.addTaskToCurrentCycle(new ChangeStateTask(this.getResourceGroup(), ResourceState.IGNORED));\n        }\n    }","id":34060,"modified_method":"@Override\n    public void execute(final InstallationContext ctx) {\n        final TaskResource tr = this.getResource();\n        ctx.log(\"Installing new subsystem from {}\", tr);\n\n        try {\n            final Subsystem sub = this.rootSubsystem.install(tr.getURL(), tr.getInputStream());\n            ctx.addTaskToCurrentCycle(new StartSubsystemTask(this.getResourceGroup(), sub));\n            ctx.log(\"Installed new subsystem {}\", sub);\n        } catch (final IOException e) {\n            ctx.log(\"Unable to install subsystem {} : {}\", tr, e);\n            ctx.addTaskToCurrentCycle(new ChangeStateTask(this.getResourceGroup(), ResourceState.IGNORED));\n        }\n    }","commit_id":"9459f7ee3d141618c47e2155cfe10bc0f04ddebc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.installer.api.tasks.InstallTaskFactory#createTask(org.apache.sling.installer.api.tasks.TaskResourceGroup)\n     */\n    public InstallTask createTask(final TaskResourceGroup toActivate) {\n        final InstallTask result;\n\n        final TaskResource rsrc = toActivate.getActiveResource();\n        if ( rsrc.getType().equals(TYPE_SUBSYSTEM) ) {\n\n            // check if the required info is available\n            final SubsystemInfo info = checkResource(toActivate);\n            if ( info == null ) {\n                // ignore as info is missing\n                result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n            } else {\n                // search a subsystem with the symbolic name\n                final ServiceReference<Subsystem> ref = this.getSubsystemReference(info.symbolicName);\n\n                final Version newVersion = new Version(info.version);\n                final Version oldVersion = (ref == null ? null : (Version)ref.getProperty(\"subsystem.version\"));\n\n                // Install\n                if ( rsrc.getState() == ResourceState.INSTALL ) {\n                    if ( oldVersion != null ) {\n\n                        final int compare = oldVersion.compareTo(newVersion);\n                        if (compare < 0) {\n                            // installed version is lower -> update\n                            result = new UpdateSubsystemTask(toActivate, this.bundleContext, ref, this.rootSubsystem);\n                        } else if ( compare == 0 && isSnapshot(newVersion) ) {\n                            // same version but snapshot -> update\n                            result = new UpdateSubsystemTask(toActivate, this.bundleContext, ref, this.rootSubsystem);\n                        } else {\n                            logger.debug(\"{} is not installed, subsystem with same or higher version is already installed: {}\", info, newVersion);\n                            result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n                        }\n                    } else {\n                        result = new InstallSubsystemTask(toActivate, this.rootSubsystem);\n                    }\n\n                // Uninstall\n                } else if ( rsrc.getState() == ResourceState.UNINSTALL ) {\n                    if ( oldVersion == null ) {\n                        logger.error(\"Nothing to uninstall. {} is currently not installed.\", info);\n                        result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n                    } else {\n\n                        final int compare = oldVersion.compareTo(newVersion);\n                        if ( compare == 0 ) {\n                            result = new UninstallSubsystemTask(toActivate, this.bundleContext, ref);\n                        } else {\n                            logger.error(\"Nothing to uninstall. {} is currently not installed, different version is installed {}\", info, oldVersion);\n                            result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n                        }\n                    }\n                } else {\n                    result = null;\n                }\n            }\n        } else {\n            result = null;\n        }\n        return result;\n    }","id":34061,"modified_method":"/**\n     * @see org.apache.sling.installer.api.tasks.InstallTaskFactory#createTask(org.apache.sling.installer.api.tasks.TaskResourceGroup)\n     */\n    public InstallTask createTask(final TaskResourceGroup toActivate) {\n        final InstallTask result;\n\n        final TaskResource rsrc = toActivate.getActiveResource();\n        if ( rsrc.getType().equals(TYPE_SUBSYSTEM) ) {\n\n            // check if the required info is available\n            final SubsystemInfo info = checkResource(toActivate);\n            if ( info == null ) {\n                // ignore as info is missing\n                result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n            } else {\n                // search a subsystem with the symbolic name\n                final ServiceReference<Subsystem> ref = this.getSubsystemReference(info.symbolicName);\n\n                final Subsystem currentSubsystem = (ref != null ? this.bundleContext.getService(ref) : null);\n                try {\n                    final Version newVersion = new Version(info.version);\n                    final Version oldVersion = (ref == null ? null : (Version)ref.getProperty(\"subsystem.version\"));\n\n                    // Install\n                    if ( rsrc.getState() == ResourceState.INSTALL ) {\n                        if ( oldVersion != null ) {\n\n                            final int compare = oldVersion.compareTo(newVersion);\n                            if (compare < 0) {\n                                // installed version is lower -> update\n                                result = new UpdateSubsystemTask(toActivate, this.bundleContext, ref, this.rootSubsystem);\n                            } else if ( compare == 0 && isSnapshot(newVersion) ) {\n                                // same version but snapshot -> update\n                                result = new UpdateSubsystemTask(toActivate, this.bundleContext, ref, this.rootSubsystem);\n                            } else if ( compare == 0 && currentSubsystem != null && currentSubsystem.getState() != State.ACTIVE ) {\n                                // try to start the version\n                                result = new StartSubsystemTask(toActivate, currentSubsystem);\n                            } else {\n                                logger.info(\"{} is not installed, subsystem with same or higher version is already installed: {}\", info, newVersion);\n                                result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n                            }\n                        } else {\n                            result = new InstallSubsystemTask(toActivate, this.rootSubsystem);\n                        }\n\n                    // Uninstall\n                    } else if ( rsrc.getState() == ResourceState.UNINSTALL ) {\n                        if ( oldVersion == null ) {\n                            logger.error(\"Nothing to uninstall. {} is currently not installed.\", info);\n                            result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n                        } else {\n\n                            final int compare = oldVersion.compareTo(newVersion);\n                            if ( compare == 0 ) {\n                                result = new UninstallSubsystemTask(toActivate, this.bundleContext, ref);\n                            } else {\n                                logger.error(\"Nothing to uninstall. {} is currently not installed, different version is installed {}\", info, oldVersion);\n                                result = new ChangeStateTask(toActivate, ResourceState.IGNORED);\n                            }\n                        }\n                    } else {\n                        result = null;\n                    }\n                } finally {\n                    if ( currentSubsystem != null ) {\n                        this.bundleContext.ungetService(ref);\n                    }\n                }\n            }\n        } else {\n            result = null;\n        }\n        return result;\n    }","commit_id":"9459f7ee3d141618c47e2155cfe10bc0f04ddebc","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void execute(final InstallationContext ctx) {\n        final TaskResource tr = this.getResource();\n        ctx.log(\"Uninstalling subsystem from {}\", tr);\n\n        Subsystem subsystem = null;\n        try {\n            subsystem = this.bundleContext.getService(this.subsystemReference);\n            if ( subsystem != null ) {\n                subsystem.uninstall();\n                ctx.addTaskToCurrentCycle(new ChangeStateTask(this.getResourceGroup(), ResourceState.UNINSTALLED));\n            } else {\n                ctx.log(\"Unable to uninstall subsystem {}.\", tr);\n                ctx.addTaskToCurrentCycle(new ChangeStateTask(this.getResourceGroup(), ResourceState.IGNORED));\n            }\n        } finally {\n            if ( subsystem != null ) {\n                this.bundleContext.ungetService(this.subsystemReference);\n            }\n        }\n    }","id":34062,"modified_method":"@Override\n    public void execute(final InstallationContext ctx) {\n        final TaskResource tr = this.getResource();\n        ctx.log(\"Uninstalling subsystem from {}\", tr);\n\n        Subsystem subsystem = null;\n        try {\n            subsystem = this.bundleContext.getService(this.subsystemReference);\n            if ( subsystem != null ) {\n                subsystem.uninstall();\n                ctx.addTaskToCurrentCycle(new ChangeStateTask(this.getResourceGroup(), ResourceState.UNINSTALLED));\n                ctx.log(\"Uninstalled subsystem {}\", subsystem);\n            } else {\n                ctx.log(\"Unable to uninstall subsystem {}.\", tr);\n                ctx.addTaskToCurrentCycle(new ChangeStateTask(this.getResourceGroup(), ResourceState.IGNORED));\n            }\n        } finally {\n            if ( subsystem != null ) {\n                this.bundleContext.ungetService(this.subsystemReference);\n            }\n        }\n    }","commit_id":"9459f7ee3d141618c47e2155cfe10bc0f04ddebc","url":"https://github.com/apache/sling"},{"original_method":"@Override\n\tprotected InstallResultCode doInstallOrUpdate(OsgiControllerTaskContext tctx, Map<String, Object> attributes) throws Exception {\n        int retryCount = 0;\n        if ( attributes.get(\"RETRY_COUNT\") != null ) {\n            retryCount = (Integer)attributes.get(\"RETRY_COUNT\");\n        }\n        retryCount++;\n        attributes.put(\"RETRY_COUNT\", retryCount);\n\n    \t// Check that we have bundle data and manifest\n    \tInputStream is = data.adaptTo(InputStream.class);\n    \tif(is == null) {\n    \t\tthrow new IOException(\"InstallableData does not adapt to an InputStream: \" + uri);\n    \t}\n\n\t\tfinal Manifest m = TaskUtilities.getManifest(data);\n\t\tif(m == null) {\n\t\t\tthrow new IOException(\"Manifest not found for InstallableData \" + uri);\n\t\t}\n\n        // Update if we already have a bundle id, else install\n\t\tBundle b;\n\t\tboolean updated;\n\t\ttry {\n\t\t\tb = null;\n\t\t\tupdated = false;\n\n\t\t\t// check whether we know the bundle and it exists\n\t\t\tfinal Long longId = (Long) attributes.get(Storage.KEY_BUNDLE_ID);\n\t\t\tif (longId != null) {\n\t\t\t    b = bundleContext.getBundle(longId);\n\t\t\t}\n\n\t\t\t// either we don't know the bundle yet or it does not exist,\n\t\t\t// so check whether the bundle can be found by its symbolic name\n\t\t\tif (b == null) {\n\t\t\t    b = TaskUtilities.getMatchingBundle(bundleContext, m);\n\t\t\t}\n\n\t\t\t// If the bundle (or one with the same symbolic name) is\n\t\t\t// already installed, ignore the new one if it's a lower\n\t\t\t// version\n\t\t\tif (b != null && retryCount == 1) {\n\t\t\t\tfinal Version installedVersion = new Version((String)(b.getHeaders().get(Constants.BUNDLE_VERSION)));\n\t\t\t\tfinal Version newBundleVersion = new Version(m.getMainAttributes().getValue(Constants.BUNDLE_VERSION));\n\t\t\t\tif(ignoreNewBundle(b.getSymbolicName(), uri, installedVersion, newBundleVersion)) {\n\t\t            return InstallResultCode.IGNORED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b != null) {\n\t\t\t\t// Existing bundle -> stop, update, restart\n\t\t\t    if ( retryCount == 1 ) {\n\t\t\t    \tif(ocs.getLogService() != null) {\n\t\t\t    \t\tocs.getLogService().log(LogService.LOG_DEBUG, \"Calling Bundle.stop() and updating \" + uri);\n\t\t\t    \t}\n\t\t\t        b.stop();\n\t\t\t        b.update(is);\n\t                b.start();\n\t\t\t    } else {\n\t\t\t    \tif(ocs.getLogService() != null) {\n\t\t\t    \t\tocs.getLogService().log(LogService.LOG_DEBUG, \"Calling Bundle.start \" + uri);\n\t\t\t    \t}\n\t                b.start();\n\t\t\t    }\n\t\t\t    updated = true;\n\t\t\t    tctx.addTaskToCurrentCycle(new SynchronousRefreshPackagesTask());\n\t\t\t} else {\n\t\t\t\t// New bundle -> install\n\t\t\t    final String fullUri = OsgiControllerImpl.getResourceLocation(uri);\n\t\t\t    int level = data.getBundleStartLevel();\n\t\t\t    if(level > 0) {\n\t\t\t    \tthrow new BundleException(\"Non-zero start level is not supported anymore (\" + level + \")\");\n\t\t\t    }\n\t\t\t    b = bundleContext.installBundle(fullUri, is);\n\t\t    \tif(ocs.getLogService() != null) {\n\t\t    \t\tocs.getLogService().log(LogService.LOG_DEBUG, \"No matching Bundle, installed \" + fullUri);\n\t\t    \t}\n\t\t\t}\n\t\t} finally {\n\t\t    // data is never null here\n\t\t    try {\n\t\t\t\tis.close();\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\n        // ensure the bundle id in the attributes, this may be overkill\n        // in simple update situations, but is required for installations\n        // and updates where there are no attributes yet\n        attributes.put(Storage.KEY_BUNDLE_ID, b.getBundleId());\n\n        // start bundle\n        tctx.addTaskToCurrentCycle(new BundleStartTask(b.getBundleId()));\n        \n        // TODO - remove retry\n        // Successful - reset retry count\n        retryCount = 0;\n        attributes.put(\"RETRY_COUNT\", retryCount);\n\n        return updated ? InstallResultCode.UPDATED : InstallResultCode.INSTALLED;\n\t}","id":34063,"modified_method":"@Override\n\tprotected InstallResultCode doInstallOrUpdate(OsgiControllerTaskContext tctx, Map<String, Object> attributes) throws Exception {\n\n    \t// Check that we have bundle data and manifest\n    \tInputStream is = data.adaptTo(InputStream.class);\n    \tif(is == null) {\n    \t\tthrow new IOException(\"InstallableData does not adapt to an InputStream: \" + uri);\n    \t}\n\n\t\tfinal Manifest m = TaskUtilities.getManifest(data);\n\t\tif(m == null) {\n\t\t\tthrow new IOException(\"Manifest not found for InstallableData \" + uri);\n\t\t}\n\n        // Update if we already have a bundle id, else install\n\t\tBundle b;\n\t\tboolean updated;\n\t\ttry {\n\t\t\tb = null;\n\t\t\tupdated = false;\n\n\t\t\t// check whether we know the bundle and it exists\n\t\t\tfinal Long longId = (Long) attributes.get(Storage.KEY_BUNDLE_ID);\n\t\t\tif (longId != null) {\n\t\t\t    b = bundleContext.getBundle(longId);\n\t\t\t}\n\n\t\t\t// either we don't know the bundle yet or it does not exist,\n\t\t\t// so check whether the bundle can be found by its symbolic name\n\t\t\tif (b == null) {\n\t\t\t    b = TaskUtilities.getMatchingBundle(bundleContext, m);\n\t\t\t}\n\n\t\t\t// If the bundle (or one with the same symbolic name) is\n\t\t\t// already installed, ignore the new one if it's a lower\n\t\t\t// version\n\t\t\tif (b != null) {\n\t\t\t\tfinal Version installedVersion = new Version((String)(b.getHeaders().get(Constants.BUNDLE_VERSION)));\n\t\t\t\tfinal Version newBundleVersion = new Version(m.getMainAttributes().getValue(Constants.BUNDLE_VERSION));\n\t\t\t\tif(ignoreNewBundle(b.getSymbolicName(), uri, installedVersion, newBundleVersion)) {\n\t\t            return InstallResultCode.IGNORED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (b != null) {\n\t\t\t\t// Existing bundle -> stop, update, restart\n\t\t    \tif(ocs.getLogService() != null) {\n\t\t    \t\tocs.getLogService().log(LogService.LOG_INFO, \n\t\t    \t\t\t\t\"Bundle \" + b.getBundleId() + \" already present, calling Bundle.stop() and updating \" + uri);\n\t\t    \t}\n\t\t        b.stop();\n\t\t        b.update(is);\n\t\t\t    updated = true;\n\t\t\t    tctx.addTaskToCurrentCycle(new SynchronousRefreshPackagesTask());\n\t\t\t    tctx.addTaskToCurrentCycle(new BundleStartTask(b.getBundleId()));\n\t\t\t} else {\n\t\t\t\t// New bundle -> install\n\t\t\t    final String fullUri = OsgiControllerImpl.getResourceLocation(uri);\n\t\t\t    int level = data.getBundleStartLevel();\n\t\t\t    if(level > 0) {\n\t\t\t    \tthrow new BundleException(\"Non-zero start level is not supported anymore (\" + level + \")\");\n\t\t\t    }\n\t\t\t    b = bundleContext.installBundle(fullUri, is);\n\t\t    \tif(ocs.getLogService() != null) {\n\t\t    \t\tocs.getLogService().log(LogService.LOG_INFO, \"Bundle was not present, installed \" + fullUri);\n\t\t    \t}\n\t\t\t    tctx.addTaskToCurrentCycle(new BundleStartTask(b.getBundleId()));\n\t\t\t}\n\t\t} finally {\n\t\t    // data is never null here\n\t\t    try {\n\t\t\t\tis.close();\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\n        // ensure the bundle id in the attributes, this may be overkill\n        // in simple update situations, but is required for installations\n        // and updates where there are no attributes yet\n        attributes.put(Storage.KEY_BUNDLE_ID, b.getBundleId());\n\n        return updated ? InstallResultCode.UPDATED : InstallResultCode.INSTALLED;\n\t}","commit_id":"f29469688598b20a17ea9d843721427e4c821add","url":"https://github.com/apache/sling"},{"original_method":"public void execute(OsgiControllerTaskContext ctx) throws Exception {\n\t\tfinal Bundle b = ctx.getBundleContext().getBundle(bundleId);\n\t\tfinal LogService log = ctx.getOsgiControllerServices().getLogService();\n\t\t\n\t\tif(b == null) {\n\t\t\tif(log != null) {\n\t\t\t\tlog.log(LogService.LOG_INFO, \"Cannot start bundle, id not found:\" + bundleId);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(b.getState() == Bundle.ACTIVE) {\n\t\t\tif(log != null) {\n\t\t\t\tlog.log(LogService.LOG_DEBUG, \"Bundle already started, no action taken:\" + bundleId + \"/\" + b.getSymbolicName());\n\t\t\t}\n\t\t} else {\n\t\t\tif(log != null) {\n\t\t\t\tlog.log(LogService.LOG_INFO, \"Starting bundle:\" + bundleId + \"/\" + b.getSymbolicName());\n\t\t\t}\n\t\t\tb.start();\n\t\t}\n\t}","id":34064,"modified_method":"public void execute(OsgiControllerTaskContext tctx) throws Exception {\n\t\tfinal Bundle b = tctx.getBundleContext().getBundle(bundleId);\n\t\tfinal LogService log = tctx.getOsgiControllerServices().getLogService();\n\t\t\n\t\tif(b == null) {\n\t\t\tif(log != null) {\n\t\t\t\tlog.log(LogService.LOG_INFO, \"Cannot start bundle, id not found:\" + bundleId);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(b.getState() == Bundle.ACTIVE) {\n\t\t\tif(log != null) {\n\t\t\t\tlog.log(LogService.LOG_DEBUG, \"Bundle already started, no action taken:\" + bundleId + \"/\" + b.getSymbolicName());\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tb.start();\n\t\t\t\tif(log != null) {\n\t\t\t\t\tlog.log(LogService.LOG_INFO, \"Bundle started:\" + bundleId + \"/\" + b.getSymbolicName());\n\t\t\t\t}\n\t\t\t} catch(BundleException e) {\n\t\t\t\tif(log != null) {\n\t\t\t\t\tlog.log(LogService.LOG_INFO, \n\t\t\t\t\t\t\t\"Could not start bundle (\" + e + \"), will retry: \" + bundleId + \"/\" + b.getSymbolicName());\n\t\t\t\t}\n\t\t\t\ttctx.addTaskToNextCycle(this);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","commit_id":"f29469688598b20a17ea9d843721427e4c821add","url":"https://github.com/apache/sling"},{"original_method":"public static ArgWriter windowsStyle(PrintWriter writer) {\n        // TODO:DAZ Should find a way _not_ to escape file names, although Visual Studio seems to handle them escaped\n        return new ArgWriter(writer, true);\n    }","id":34065,"modified_method":"public static ArgWriter windowsStyle(PrintWriter writer) {\n        return new ArgWriter(writer, false);\n    }","commit_id":"89fa36f7cd4fc2476a331cecc594723d92dc3088","url":"https://github.com/gradle/gradle"},{"original_method":"public List<String> transform(AssembleSpec spec) {\n            List<String> args = new ArrayList<String>();\n            args.addAll(spec.getAllArgs());\n            args.add(\"/nologo\");\n            args.add(\"/c\");\n            File outputFile = getOutputFilePath(spec);\n            if(!outputFile.getParentFile().exists()){\n                outputFile.getParentFile().mkdir();\n            }\n            args.add(\"/Fo\"+ outputFile);\n            args.add(inputFile.getAbsolutePath());\n            return args;\n        }","id":34066,"modified_method":"public List<String> transform(AssembleSpec spec) {\n            List<String> args = new ArrayList<String>();\n            args.addAll(escapeUserArgs(spec.getAllArgs()));\n            args.add(\"/nologo\");\n            args.add(\"/c\");\n            File outputFile = getOutputFilePath(spec);\n            if(!outputFile.getParentFile().exists()){\n                outputFile.getParentFile().mkdir();\n            }\n            args.add(\"/Fo\"+ outputFile);\n            args.add(inputFile.getAbsolutePath());\n            return args;\n        }","commit_id":"89fa36f7cd4fc2476a331cecc594723d92dc3088","url":"https://github.com/gradle/gradle"},{"original_method":"public List<String> transform(StaticLibraryArchiverSpec spec) {\n            List<String> args = new ArrayList<String>();\n            args.add(\"/OUT:\" + spec.getOutputFile().getAbsolutePath());\n            args.add(\"/NOLOGO\");\n            args.addAll(spec.getAllArgs());\n            for (File file : spec.getObjectFiles()) {\n                args.add(file.getAbsolutePath());\n            }\n            return args;\n        }","id":34067,"modified_method":"public List<String> transform(StaticLibraryArchiverSpec spec) {\n            List<String> args = new ArrayList<String>();\n            args.add(\"/OUT:\" + spec.getOutputFile().getAbsolutePath());\n            args.add(\"/NOLOGO\");\n            args.addAll(escapeUserArgs(spec.getAllArgs()));\n            for (File file : spec.getObjectFiles()) {\n                args.add(file.getAbsolutePath());\n            }\n            return args;\n        }","commit_id":"89fa36f7cd4fc2476a331cecc594723d92dc3088","url":"https://github.com/gradle/gradle"},{"original_method":"public List<String> transform(LinkerSpec spec) {\n            List<String> args = new ArrayList<String>();\n            args.addAll(spec.getAllArgs());\n            args.add(\"/OUT:\" + spec.getOutputFile().getAbsolutePath());\n            args.add(\"/NOLOGO\");\n            if (spec instanceof SharedLibraryLinkerSpec) {\n                args.add(\"/DLL\");\n            }\n            for (File pathEntry : spec.getLibraryPath()) {\n                args.add(\"/LIBPATH:\" + pathEntry.getAbsolutePath());\n            }\n            for (File file : spec.getObjectFiles()) {\n                args.add(file.getAbsolutePath());\n            }\n            for (File file : spec.getLibraries()) {\n                args.add(file.getAbsolutePath());\n            }\n            return args;\n        }","id":34068,"modified_method":"public List<String> transform(LinkerSpec spec) {\n            List<String> args = new ArrayList<String>();\n            args.addAll(escapeUserArgs(spec.getAllArgs()));\n            args.add(\"/OUT:\" + spec.getOutputFile().getAbsolutePath());\n            args.add(\"/NOLOGO\");\n            if (spec instanceof SharedLibraryLinkerSpec) {\n                args.add(\"/DLL\");\n            }\n            for (File pathEntry : spec.getLibraryPath()) {\n                args.add(\"/LIBPATH:\" + pathEntry.getAbsolutePath());\n            }\n            for (File file : spec.getObjectFiles()) {\n                args.add(file.getAbsolutePath());\n            }\n            for (File file : spec.getLibraries()) {\n                args.add(file.getAbsolutePath());\n            }\n            return args;\n        }","commit_id":"89fa36f7cd4fc2476a331cecc594723d92dc3088","url":"https://github.com/gradle/gradle"},{"original_method":"public List<String> transform(T spec) {\n        List<String> args = new ArrayList<String>();\n        args.add(getLanguageOption());\n        args.add(\"/nologo\");\n\n        for (String macroArg : new MacroArgsConverter().transform(spec.getMacros())) {\n            args.add(\"/D\" + macroArg);\n        }\n        args.addAll(spec.getAllArgs());\n        args.add(\"/c\");\n        for (File file : spec.getIncludeRoots()) {\n            args.add(\"/I\" + file.getAbsolutePath());\n        }\n\n        return args;\n    }","id":34069,"modified_method":"public List<String> transform(T spec) {\n        List<String> args = new ArrayList<String>();\n        args.add(getLanguageOption());\n        args.add(\"/nologo\");\n\n        for (String macroArg : new MacroArgsConverter().transform(spec.getMacros())) {\n            args.add(escapeUserArg(\"/D\" + macroArg));\n        }\n        args.addAll(escapeUserArgs(spec.getAllArgs()));\n\n        args.add(\"/c\");\n        for (File file : spec.getIncludeRoots()) {\n            args.add(\"/I\" + file.getAbsolutePath());\n        }\n\n        return args;\n    }","commit_id":"89fa36f7cd4fc2476a331cecc594723d92dc3088","url":"https://github.com/gradle/gradle"},{"original_method":"protected void configurePluginsSDK(\n\t\tProject project, final WorkspaceExtension workspaceExtension,\n\t\tCopy initBundleTask, AbstractArchiveTask[] distBundleTasks) {\n\n\t\tfinal Project pluginsSDKProject = GradleUtil.getProject(\n\t\t\tproject, workspaceExtension.getPluginsSDKDir());\n\n\t\tif (pluginsSDKProject == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tAntBuilder antBuilder = pluginsSDKProject.getAnt();\n\n\t\tantBuilder.importBuild(\"build.xml\");\n\n\t\tTask buildTask = pluginsSDKProject.task(\n\t\t\tLifecycleBasePlugin.BUILD_TASK_NAME);\n\n\t\tfinal Task warTask = GradleUtil.getTask(\n\t\t\tpluginsSDKProject, WarPlugin.WAR_TASK_NAME);\n\n\t\tbuildTask.dependsOn(warTask);\n\n\t\tFile homeDir = workspaceExtension.getHomeDir();\n\n\t\tif (!homeDir.exists()) {\n\t\t\twarTask.dependsOn(initBundleTask);\n\t\t}\n\n\t\tfor (AbstractArchiveTask abstractArchiveTask : distBundleTasks) {\n\t\t\tabstractArchiveTask.into(\n\t\t\t\t\"deploy\",\n\t\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\t\tConfigurableFileTree configurableFileTree =\n\t\t\t\t\t\t\tpluginsSDKProject.fileTree(\"dist\");\n\n\t\t\t\t\t\tconfigurableFileTree.builtBy(warTask);\n\t\t\t\t\t\tconfigurableFileTree.include(\"*.war\");\n\n\t\t\t\t\t\tcopySpec.from(configurableFileTree);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t}\n\n\t\tTask updateSDKPropertiesTask = GradleUtil.addTask(\n\t\t\tpluginsSDKProject, UPDATE_SDK_PROPERTIES_TASK_NAME, Task.class);\n\n\t\tupdateSDKPropertiesTask.doLast(\n\t\t\tnew Action<Task>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(Task task) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString username = System.getProperty(\"user.name\");\n\n\t\t\t\t\t\tFile buildPropertiesFile = new File(\n\t\t\t\t\t\t\tworkspaceExtension.getPluginsSDKDir(),\n\t\t\t\t\t\t\t\"build.\" + username + \".properties\");\n\n\t\t\t\t\t\tProperties buildProperties = FileUtil.readProperties(\n\t\t\t\t\t\t\tbuildPropertiesFile);\n\n\t\t\t\t\t\tbuildProperties.setProperty(\n\t\t\t\t\t\t\t\"app.server.parent.dir\",\n\t\t\t\t\t\t\tFileUtil.getAbsolutePath(\n\t\t\t\t\t\t\t\tworkspaceExtension.getHomeDir()));\n\n\t\t\t\t\t\tbuildProperties.store(\n\t\t\t\t\t\t\tnew FileOutputStream(buildPropertiesFile), null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tthrow new GradleException(e.getMessage(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tbuildTask.dependsOn(updateSDKPropertiesTask);\n\t}","id":34070,"modified_method":"protected void configurePluginsSDK(\n\t\tProject project, final WorkspaceExtension workspaceExtension,\n\t\tCopy initBundleTask, AbstractArchiveTask[] distBundleTasks) {\n\n\t\tfinal Project pluginsSDKProject = GradleUtil.getProject(\n\t\t\tproject, workspaceExtension.getPluginsSDKDir());\n\n\t\tif (pluginsSDKProject == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tAntBuilder antBuilder = pluginsSDKProject.getAnt();\n\n\t\tantBuilder.importBuild(\"build.xml\");\n\n\t\tfinal Task warTask = GradleUtil.getTask(\n\t\t\tpluginsSDKProject, WarPlugin.WAR_TASK_NAME);\n\n\t\tFile homeDir = workspaceExtension.getHomeDir();\n\n\t\tif (!homeDir.exists()) {\n\t\t\twarTask.dependsOn(initBundleTask);\n\t\t}\n\n\t\tTask updateSDKPropertiesTask = addTaskUpdateSDKProperties(\n\t\t\tpluginsSDKProject, workspaceExtension);\n\n\t\tTask buildTask = pluginsSDKProject.task(\n\t\t\tLifecycleBasePlugin.BUILD_TASK_NAME);\n\n\t\tbuildTask.dependsOn(updateSDKPropertiesTask, warTask);\n\n\t\tfor (AbstractArchiveTask abstractArchiveTask : distBundleTasks) {\n\t\t\tabstractArchiveTask.into(\n\t\t\t\t\"deploy\",\n\t\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\t\tConfigurableFileTree configurableFileTree =\n\t\t\t\t\t\t\tpluginsSDKProject.fileTree(\"dist\");\n\n\t\t\t\t\t\tconfigurableFileTree.builtBy(warTask);\n\t\t\t\t\t\tconfigurableFileTree.include(\"*.war\");\n\n\t\t\t\t\t\tcopySpec.from(configurableFileTree);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t}\n\t}","commit_id":"16501391b80eed846ecf820bb98b9ea5436b172b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n        Sequence result = null;        \n        if (steps.size() == 0) {\n            result = Sequence.EMPTY_SEQUENCE;\n        } else {\n            //we will filter out nodes from the contextSequence\n            result = contextSequence;\n            \n            DocumentSet contextDocs = null;\n            Expression expr = (Expression) steps.get(0);\n            if (expr instanceof VariableReference) {\n                Variable var = ((VariableReference) expr).getVariable();\n                if (var != null) \n                    contextDocs = var.getContextDocs();            \n            }    \n            if (contextDocs != null)\n            \tsetContextDocSet(contextDocs);          \n            else\n            \tsetContextDocSet(null);\n            \n            //To prevent processing nodes after atomic values...\n            //TODO : let the parser do it ? -pb\n            boolean gotAtomicResult = false;            \n            for (Iterator iter = steps.iterator(); iter.hasNext();) {\n                \n                expr = (Expression) iter.next();\n                \n                //TODO : maybe this could be detected by the parser ? -pb    \n                if (gotAtomicResult && !Type.subTypeOf(expr.returnsType(), Type.NODE)\n                        //Ugly workaround to allow preceding *text* nodes.\n                        && !(expr instanceof EnclosedExpr)) {\n                    LOG.debug(\"Path steps:\" + steps);\n                    LOG.debug(\"Current expression:\" + expr);\n                    throw new XPathException(\"XPTY0019: left operand of '/' must be a node. Got '\" + \n                            Type.getTypeName(result.getItemType()) + Cardinality.toString(result.getCardinality()) + \"'\");                    \n                } \n                \n                if (contextDocs != null) \n                    expr.setContextDocSet(contextDocs);\n                else\n                \texpr.setContextDocSet(null);\n                \n                if (Dependency.dependsOn(expr.getDependencies(), Dependency.CONTEXT_POSITION)) {\n                    if (result == null || result.getLength() == 0) {\n                        result = expr.eval(Sequence.EMPTY_SEQUENCE, null);                    \n                    } else {                        \n                        Sequence values = null;\n                        if (result.getLength() > 1)\n                            values = new ValueSequence();   \n\t                    //Restore a position which may have been modified by inner expressions \n\t                    int p = context.getContextPosition();\n\t                    for (SequenceIterator iterInner = result.iterate(); iterInner.hasNext(); p++) {\n\t                        context.setContextPosition(p);\n\t                        Item current = iterInner.nextItem();                            \n\t                        if (values == null)\n\t                            values = expr.eval(result, current);\n\t                        else\n\t                            values.addAll(expr.eval(result, current));                           \n\t                    }\n\t                    result = values;  \n                   }                  \n                } else if (Dependency.dependsOn(expr.getDependencies(), Dependency.CONTEXT_ITEM)) {\n                \tif (result == null || result.getLength() == 0) {\n                \t\tresult = expr.eval(Sequence.EMPTY_SEQUENCE, null);\n                    } else {\n                    \tresult = expr.eval(result);\n                    }\n                } else {\n                \tresult = expr.eval(result);\n                }\n            \n                //TOUNDERSTAND : why did I have to write this test :-) ? -pb\n                //it looks like an empty sequence could be considered as a sub-type of Type.NODE\n                //well, no so stupid I think...                \n                if (!Type.subTypeOf(result.getItemType(), Type.NODE) && result.getLength() > 0)\n                    gotAtomicResult = true;\n\n                if(steps.size() > 1)\n                    // remove duplicate nodes if this is a path \n                    // expression with more than one step\n                    result.removeDuplicates();                \n            }\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result);\n        \n        return result;\n    }","id":34071,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n        Sequence result = null;        \n        if (steps.size() == 0) {\n            result = Sequence.EMPTY_SEQUENCE;\n        } else {\n            //we will filter out nodes from the contextSequence\n            result = contextSequence;\n            \n            DocumentSet contextDocs = null;\n            Expression expr = (Expression) steps.get(0);\n            if (expr instanceof VariableReference) {\n                Variable var = ((VariableReference) expr).getVariable();\n                //TOUNDERSTAND : how null could be possible here ? -pb\n                if (var != null) \n                    contextDocs = var.getContextDocs();            \n            }\n            //contextDocs == null *is* significant\n            setContextDocSet(contextDocs);\n            \n            //To prevent processing nodes after atomic values...\n            //TODO : let the parser do it ? -pb\n            boolean gotAtomicResult = false;  \n            \n            for (Iterator iter = steps.iterator(); iter.hasNext();) {\n                \n                expr = (Expression) iter.next();\n                \n                //TODO : maybe this could be detected by the parser ? -pb    \n                if (gotAtomicResult && !Type.subTypeOf(expr.returnsType(), Type.NODE)\n                        //Ugly workaround to allow preceding *text* nodes.\n                        && !(expr instanceof EnclosedExpr)) {\n                    throw new XPathException(\"XPTY0019: left operand of '/' must be a node. Got '\" + \n                            Type.getTypeName(result.getItemType()) + Cardinality.toString(result.getCardinality()) + \"'\");                    \n                }                 \n                \n                //contextDocs == null *is* significant\n                expr.setContextDocSet(contextDocs);                \n                \n                //DESIGN : calling result.getLength() should be avoided -pb\n                if (Dependency.dependsOn(expr.getDependencies(), Dependency.CONTEXT_POSITION) && \n                \t\tresult.getLength() > 0) {\n                      \n                    Sequence exprResult = Sequence.EMPTY_SEQUENCE;\n                    \n                    //Restore a position which may have been modified by inner expressions \n                    int p = context.getContextPosition();\n                    \n                    for (SequenceIterator iterInner = result.iterate(); iterInner.hasNext(); p++) {\n                        context.setContextPosition(p);\n                        Item current = iterInner.nextItem();   \n                        //DESIGN : calling result.getLength() should be avoided -pb\n                        if (result.getLength() < 2)\n                        \texprResult = expr.eval(result, current);\n                        else {\n                        \texprResult = new ValueSequence();  \n                        \texprResult.addAll(expr.eval(result, current));\n                        }\n                    }\n                    result = exprResult;  \n                                   \n                } else {\n                \tresult = expr.eval(result);\n                }\n            \n                //TOUNDERSTAND : why did I have to write this test :-) ? -pb\n                //it looks like an empty sequence could be considered as a sub-type of Type.NODE\n                //well, no so stupid I think...    \n                //DESIGN : calling result.getLength() should be avoided -pb\n                if (!Type.subTypeOf(result.getItemType(), Type.NODE) && result.getLength() > 0)\n                    gotAtomicResult = true;\n\n                if(steps.size() > 1)\n                    // remove duplicate nodes if this is a path \n                    // expression with more than one step\n                    result.removeDuplicates();                \n            }\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result);\n        \n        return result;\n    }","commit_id":"3dcfc60a905b766cb458172e2b2459099a3290dc","url":"https://github.com/eXist-db/exist"},{"original_method":"public int compare(Object arg0, Object arg1) {\n\t\tMailEnvelope me0 = (MailEnvelope)arg0;\n\t\tMailEnvelope me1 = (MailEnvelope)arg1;\n\t\tLong uid0 = new Long(me0.getMsgUID());\n\t\tLong uid1 = new Long(me1.getMsgUID());\n\n\t\tint comparison = 0;\n\n\t\tif (_asc) {\n\t\t\tcomparison = me0.getRecipient().compareTo(me1.getRecipient());\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me0.getDate(), me1.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid0.compareTo(uid1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcomparison = me1.getRecipient().compareTo(me0.getRecipient());\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me1.getDate(), me0.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid1.compareTo(uid0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn comparison;\n\t}","id":34072,"modified_method":"public int compare(Object arg0, Object arg1) {\n\t\tMailEnvelope me0 = (MailEnvelope)arg0;\n\t\tMailEnvelope me1 = (MailEnvelope)arg1;\n\t\tLong uid0 = new Long(me0.getMsgUID());\n\t\tLong uid1 = new Long(me1.getMsgUID());\n\n\t\tint comparison = 0;\n\n\t\tif (_asc) {\n\t\t\tcomparison = \n\t\t\t\tme0.getRecipient().trim().compareTo(me1.getRecipient().trim());\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me0.getDate(), me1.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid0.compareTo(uid1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcomparison = \n\t\t\t\tme1.getRecipient().trim().compareTo(me0.getRecipient().trim());\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me1.getDate(), me0.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid1.compareTo(uid0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn comparison;\n\t}","commit_id":"bf4474ce917acfacb702d894901ff73b751e9257","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int compare(Object arg0, Object arg1) {\n\t\tMailEnvelope me0 = (MailEnvelope)arg0;\n\t\tMailEnvelope me1 = (MailEnvelope)arg1;\n\t\tLong uid0 = new Long(me0.getMsgUID());\n\t\tLong uid1 = new Long(me1.getMsgUID());\n\n\t\tint comparison = 0;\n\n\t\tif (_asc) {\n\t\t\tcomparison = me0.getSubject().compareTo(me1.getSubject());\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me0.getDate(), me1.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid0.compareTo(uid1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcomparison = me1.getSubject().compareTo(me0.getSubject());\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me1.getDate(), me0.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid1.compareTo(uid0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn comparison;\n\t}","id":34073,"modified_method":"public int compare(Object arg0, Object arg1) {\n\t\tMailEnvelope me0 = (MailEnvelope)arg0;\n\t\tMailEnvelope me1 = (MailEnvelope)arg1;\n\t\tLong uid0 = new Long(me0.getMsgUID());\n\t\tLong uid1 = new Long(me1.getMsgUID());\n\t\tString subj0 = _stripPrefixes(me0.getSubject().trim().toLowerCase());\n\t\tString subj1 = _stripPrefixes(me1.getSubject().trim().toLowerCase());\n\n\t\tint comparison = 0;\n\n\t\tif (_asc) {\n\t\t\tcomparison = subj0.compareTo(subj1);\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me0.getDate(), me1.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid0.compareTo(uid1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcomparison = subj1.compareTo(subj0);\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = DateUtil.compareTo(me1.getDate(), me0.getDate());\n\t\t\t\t\n\t\t\t\tif (comparison == 0) {\n\t\t\t\t\tcomparison = uid1.compareTo(uid0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn comparison;\n\t}","commit_id":"bf4474ce917acfacb702d894901ff73b751e9257","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Constructor called by children classes only. Mainly called by {@link ApplicationClassLoader} from\n   * the MR framework in distributed mode.\n   */\n  protected MapReduceClassLoader() {\n    this(new Parameters());\n  }","id":34074,"modified_method":"/**\n   * Constructor. It creates classloader for MapReduce from information\n   * gathered through {@link MapReduceContextConfig}. This method is called by {@link MRContainerLauncher}.\n   */\n  @SuppressWarnings(\"unused\")\n  public MapReduceClassLoader() {\n    this(new Parameters());\n  }","commit_id":"e04377dc14e4554ad9c309403805f763be2fab4b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    final Job job = createJob();\n    Configuration mapredConf = job.getConfiguration();\n\n    classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader());\n    mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n    ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n    context.setJob(job);\n\n    beforeSubmit(job);\n\n    // Override user-defined job name, since we set it and depend on the name.\n    // https://issues.cask.co/browse/CDAP-2441\n    String jobName = job.getJobName();\n    if (!jobName.isEmpty()) {\n      LOG.warn(\"Job name {} is being overridden.\", jobName);\n    }\n    job.setJobName(getJobName(context));\n\n    // Creates a temporary directory locally for storing all generated files.\n    File tempDir = DirUtils.createTempDir(new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                                   cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile());\n    tempDir.mkdirs();\n    this.cleanupTask = createCleanupTask(tempDir);\n\n    try {\n      // Create a temporary location for storing all generated files through the LocationFactory.\n      Location tempLocation = createTempLocationDirectory();\n      this.cleanupTask = createCleanupTask(tempDir, tempLocation);\n\n      Location pluginArchive = null;\n      // For local mode, everything is in the configuration classloader already, hence no need to create new jar\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        // After calling beforeSubmit, we know what plugins are needed for adapter, hence construct the proper\n        // ClassLoader from here and use it for setting up the job\n        pluginArchive = createPluginArchive(context.getAdapterSpecification(), tempDir, tempLocation);\n        if (pluginArchive != null) {\n          job.addCacheArchive(pluginArchive.toURI());\n        }\n      }\n\n      // Alter the configuration ClassLoader to a MapReduceClassLoader that supports plugin\n      // It is mainly for standalone mode to have the same ClassLoader as in distributed mode\n      // It can only be constructed here because we need to have all adapter plugins information\n      classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader(), context.getAdapterSpecification(),\n                                             context.getPluginInstantiator());\n      mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n      ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n      setOutputClassesIfNeeded(job);\n      setMapOutputClassesIfNeeded(job);\n\n      // Prefer our job jar in the classpath\n      // Set both old and new keys\n      mapredConf.setBoolean(\"mapreduce.user.classpath.first\", true);\n      mapredConf.setBoolean(Job.MAPREDUCE_JOB_USER_CLASSPATH_FIRST, true);\n      mapredConf.setBoolean(Job.MAPREDUCE_JOB_CLASSLOADER, true);\n\n      // Make CDAP classes (which is in the job.jar created below) to have higher precedence\n      // It is needed to override the ApplicationClassLoader to use our implementation\n      String yarnAppClassPath = mapredConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH, Joiner.on(',')\n        .join(YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH));\n      mapredConf.set(YarnConfiguration.YARN_APPLICATION_CLASSPATH, \"job.jar/lib/*,job.jar/classes,\" + yarnAppClassPath);\n\n      // set resources for the job\n      TaskType.MAP.setResources(mapredConf, context.getMapperResources());\n      TaskType.REDUCE.setResources(mapredConf, context.getReducerResources());\n\n      // replace user's Mapper & Reducer's with our wrappers in job config\n      MapperWrapper.wrap(job);\n      ReducerWrapper.wrap(job);\n\n      // packaging job jar which includes cdap classes with dependencies\n      File jobJar = buildJobJar(job, tempDir);\n      job.setJar(jobJar.toURI().toString());\n\n      // Only need to copy and localize the program jar in distributed mode\n      Location programJar = programJarLocation;\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        programJar = copyProgramJar(tempLocation);\n        job.addCacheFile(programJar.toURI());\n      }\n\n      MapReduceContextConfig contextConfig = new MapReduceContextConfig(mapredConf);\n      // We start long-running tx to be used by mapreduce job tasks.\n      Transaction tx = txClient.startLong();\n      try {\n        // We remember tx, so that we can re-use it in mapreduce tasks\n        // Make a copy of the conf and rewrite the template plugin directory to be the plugin archive name\n        CConfiguration cConfCopy = cConf;\n        if (pluginArchive != null) {\n          cConfCopy = CConfiguration.copy(cConf);\n          cConfCopy.set(Constants.AppFabric.APP_TEMPLATE_DIR, pluginArchive.getName());\n        }\n        contextConfig.set(context, cConfCopy, tx, programJar.toURI());\n\n        LOG.info(\"Submitting MapReduce Job: {}\", context);\n        // submits job and returns immediately. Shouldn't need to set context ClassLoader.\n        job.submit();\n\n        this.job = job;\n        this.transaction = tx;\n      } catch (Throwable t) {\n        Transactions.invalidateQuietly(txClient, tx);\n        throw t;\n      }\n    } catch (Throwable t) {\n      LOG.error(\"Exception when submitting MapReduce Job: {}\", context, t);\n      cleanupTask.run();\n      throw t;\n    }\n  }","id":34075,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    final Job job = createJob();\n    Configuration mapredConf = job.getConfiguration();\n\n    classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader());\n    mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n    ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n    context.setJob(job);\n\n    beforeSubmit(job);\n\n    // Override user-defined job name, since we set it and depend on the name.\n    // https://issues.cask.co/browse/CDAP-2441\n    String jobName = job.getJobName();\n    if (!jobName.isEmpty()) {\n      LOG.warn(\"Job name {} is being overridden.\", jobName);\n    }\n    job.setJobName(getJobName(context));\n\n    // Creates a temporary directory locally for storing all generated files.\n    File tempDir = DirUtils.createTempDir(new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                                   cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile());\n    tempDir.mkdirs();\n    this.cleanupTask = createCleanupTask(tempDir);\n\n    try {\n      // Create a temporary location for storing all generated files through the LocationFactory.\n      Location tempLocation = createTempLocationDirectory();\n      this.cleanupTask = createCleanupTask(tempDir, tempLocation);\n\n      Location pluginArchive = null;\n      // For local mode, everything is in the configuration classloader already, hence no need to create new jar\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        // After calling beforeSubmit, we know what plugins are needed for adapter, hence construct the proper\n        // ClassLoader from here and use it for setting up the job\n        pluginArchive = createPluginArchive(context.getAdapterSpecification(), tempDir, tempLocation);\n        if (pluginArchive != null) {\n          job.addCacheArchive(pluginArchive.toURI());\n        }\n      }\n\n      // Alter the configuration ClassLoader to a MapReduceClassLoader that supports plugin\n      // It is mainly for standalone mode to have the same ClassLoader as in distributed mode\n      // It can only be constructed here because we need to have all adapter plugins information\n      classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader(), context.getAdapterSpecification(),\n                                             context.getPluginInstantiator());\n      mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n      ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n      setOutputClassesIfNeeded(job);\n      setMapOutputClassesIfNeeded(job);\n\n      // set resources for the job\n      TaskType.MAP.setResources(mapredConf, context.getMapperResources());\n      TaskType.REDUCE.setResources(mapredConf, context.getReducerResources());\n\n      // replace user's Mapper & Reducer's with our wrappers in job config\n      MapperWrapper.wrap(job);\n      ReducerWrapper.wrap(job);\n\n      // packaging job jar which includes cdap classes with dependencies\n      File jobJar = buildJobJar(job, tempDir);\n      job.setJar(jobJar.toURI().toString());\n\n      Location programJar = programJarLocation;\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        // Copy and localize the program jar in distributed mode\n        programJar = copyProgramJar(tempLocation);\n        job.addCacheFile(programJar.toURI());\n\n        // Generate and localize the launcher jar to control the classloader of MapReduce processes\n        String yarnAppClassPath = \"job.jar/lib/*,job.jar/classes,\" +\n          mapredConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH,\n                         Joiner.on(',').join(YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH));\n        Location launcherJar = createLauncherJar(yarnAppClassPath, tempLocation);\n        job.addCacheFile(launcherJar.toURI());\n\n        // The only thing in the Yarn container classpath is the launcher.jar\n        // The MRContainerLauncher inside the launcher.jar will creates a MapReduceClassLoader and launch\n        // the actual MapReduce AM/Task from that\n        mapredConf.set(YarnConfiguration.YARN_APPLICATION_CLASSPATH, launcherJar.getName());\n      }\n\n      MapReduceContextConfig contextConfig = new MapReduceContextConfig(mapredConf);\n      // We start long-running tx to be used by mapreduce job tasks.\n      Transaction tx = txClient.startLong();\n      try {\n        // We remember tx, so that we can re-use it in mapreduce tasks\n        // Make a copy of the conf and rewrite the template plugin directory to be the plugin archive name\n        CConfiguration cConfCopy = cConf;\n        if (pluginArchive != null) {\n          cConfCopy = CConfiguration.copy(cConf);\n          cConfCopy.set(Constants.AppFabric.APP_TEMPLATE_DIR, pluginArchive.getName());\n        }\n        contextConfig.set(context, cConfCopy, tx, programJar.toURI());\n\n        LOG.info(\"Submitting MapReduce Job: {}\", context);\n        // submits job and returns immediately. Shouldn't need to set context ClassLoader.\n        job.submit();\n\n        this.job = job;\n        this.transaction = tx;\n      } catch (Throwable t) {\n        Transactions.invalidateQuietly(txClient, tx);\n        throw t;\n      }\n    } catch (Throwable t) {\n      LOG.error(\"Exception when submitting MapReduce Job: {}\", context, t);\n      cleanupTask.run();\n      throw t;\n    }\n  }","commit_id":"e04377dc14e4554ad9c309403805f763be2fab4b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Gets plugin files that needs to be localized for the adapter. If the given run is not an adapter, no\n   * modification will be done to the map.\n   */\n  private Map<String, File> addAdapterPluginFiles(ProgramOptions options, Map<String, File> localizeFiles) {\n    Arguments arguments = options.getArguments();\n    if (!arguments.hasOption(ProgramOptionConstants.ADAPTER_SPEC)) {\n      return localizeFiles;\n    }\n\n    // Decode the adapter spec from program system argument\n    AdapterDefinition adapterSpec = GSON.fromJson(arguments.getOption(ProgramOptionConstants.ADAPTER_SPEC),\n                                                     AdapterDefinition.class);\n\n    // Get all unique PluginInfo from the adapter spec\n    Set<PluginInfo> plugins = adapterSpec.getPluginInfos();\n\n    // If there is no plugin used by the adapter, nothing need to be localized\n    if (plugins.isEmpty()) {\n      return localizeFiles;\n    }\n\n    File templateDir = new File(cConf.get(Constants.AppFabric.APP_TEMPLATE_DIR));\n    File templatePluginDir = new File(cConf.get(Constants.AppFabric.APP_TEMPLATE_PLUGIN_DIR),\n                                      adapterSpec.getTemplate());\n\n    String localizePrefix = templateDir.getName() + \"/\" +\n                            templateDir.toURI().relativize(templatePluginDir.toURI()).getPath();\n\n    // Localize all required plugin jars and maintain the template plugin directory structure\n    // The AbstractProgramTwillRunnable will set the APP_TEMPLATE_DIR correspondingly.\n    for (PluginInfo plugin : plugins) {\n      String localizedName = String.format(\"%s/%s\", localizePrefix, plugin.getFileName());\n      localizeFiles.put(localizedName, new File(templatePluginDir, plugin.getFileName()));\n    }\n\n    // Localize all files under template plugin \"lib\" directory\n    for (File libJar : DirUtils.listFiles(new File(templatePluginDir, \"lib\"), \"jar\")) {\n      String localizedName = String.format(\"%s/lib/%s\", localizePrefix, libJar.getName());\n      localizeFiles.put(localizedName, libJar);\n    }\n\n    return localizeFiles;\n  }","id":34076,"modified_method":"/**\n   * Gets plugin files that needs to be localized for the adapter. If the given run is not an adapter, no\n   * modification will be done to the map.\n   */\n  private Map<String, LocalizeResource> addAdapterPluginFiles(ProgramOptions options,\n                                                              Map<String, LocalizeResource> localizeResources) {\n    Arguments arguments = options.getArguments();\n    if (!arguments.hasOption(ProgramOptionConstants.ADAPTER_SPEC)) {\n      return localizeResources;\n    }\n\n    // Decode the adapter spec from program system argument\n    AdapterDefinition adapterSpec = GSON.fromJson(arguments.getOption(ProgramOptionConstants.ADAPTER_SPEC),\n                                                     AdapterDefinition.class);\n\n    // Get all unique PluginInfo from the adapter spec\n    Set<PluginInfo> plugins = adapterSpec.getPluginInfos();\n\n    // If there is no plugin used by the adapter, nothing need to be localized\n    if (plugins.isEmpty()) {\n      return localizeResources;\n    }\n\n    File templateDir = new File(cConf.get(Constants.AppFabric.APP_TEMPLATE_DIR));\n    File templatePluginDir = new File(cConf.get(Constants.AppFabric.APP_TEMPLATE_PLUGIN_DIR),\n                                      adapterSpec.getTemplate());\n\n    String localizePrefix = templateDir.getName() + \"/\" +\n                            templateDir.toURI().relativize(templatePluginDir.toURI()).getPath();\n\n    // Localize all required plugin jars and maintain the template plugin directory structure\n    // The AbstractProgramTwillRunnable will set the APP_TEMPLATE_DIR correspondingly.\n    for (PluginInfo plugin : plugins) {\n      String localizedName = String.format(\"%s/%s\", localizePrefix, plugin.getFileName());\n      localizeResources.put(localizedName, new LocalizeResource(new File(templatePluginDir, plugin.getFileName())));\n    }\n\n    // Localize all files under template plugin \"lib\" directory\n    for (File libJar : DirUtils.listFiles(new File(templatePluginDir, \"lib\"), \"jar\")) {\n      String localizedName = String.format(\"%s/lib/%s\", localizePrefix, libJar.getName());\n      localizeResources.put(localizedName, new LocalizeResource(libJar));\n    }\n\n    return localizeResources;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Sub-class overrides this method to launch the twill application.\n   */\n  protected abstract ProgramController launch(Program program, ProgramOptions options,\n                                              Map<String, File> localizeFiles, ApplicationLauncher launcher);","id":34077,"modified_method":"/**\n   * Sub-class overrides this method to launch the twill application.\n   */\n  protected abstract ProgramController launch(Program program, ProgramOptions options,\n                                              Map<String, LocalizeResource> localizeResources,\n                                              ApplicationLauncher launcher);","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public final ProgramController run(final Program program, final ProgramOptions options) {\n    final String schedulerQueueName = options.getArguments().getOption(Constants.AppFabric.APP_SCHEDULER_QUEUE);\n    final File tempDir = DirUtils.createTempDir(new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                                         cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile());\n    try {\n      if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n        hConf.set(JobContext.QUEUE_NAME, schedulerQueueName);\n        LOG.info(\"Setting scheduler queue to {}\", schedulerQueueName);\n      }\n\n      Map<String, File> localizeFiles = addAdapterPluginFiles(options, new HashMap<String, File>());\n\n      // Copy config files and program jar to local temp, and ask Twill to localize it to container.\n      // What Twill does is to save those files in HDFS and keep using them during the lifetime of application.\n      // Twill will manage the cleanup of those files in HDFS.\n      localizeFiles.put(\"hConf.xml\", saveHConf(hConf, File.createTempFile(\"hConf\", \".xml\", tempDir)));\n      localizeFiles.put(\"cConf.xml\", saveCConf(cConf, File.createTempFile(\"cConf\", \".xml\", tempDir)));\n      File programDir = DirUtils.createTempDir(tempDir);\n      final Program copiedProgram = copyProgramJar(program, tempDir, programDir);\n\n      final URI logbackURI = getLogBackURI(copiedProgram, programDir, tempDir);\n      final String programOptions = GSON.toJson(options);\n\n      // Obtains and add the HBase delegation token as well (if in non-secure mode, it's a no-op)\n      // Twill would also ignore it if it is not running in secure mode.\n      // The HDFS token should already obtained by Twill.\n      return launch(copiedProgram, options, localizeFiles, new ApplicationLauncher() {\n        @Override\n        public TwillController launch(TwillApplication twillApplication, Iterable<String> extraClassPaths) {\n          TwillPreparer twillPreparer = twillRunner.prepare(twillApplication);\n          if (options.isDebug()) {\n            LOG.info(\"Starting {} with debugging enabled, programOptions: {}, and logback: {}\",\n                     program.getId(), programOptions, logbackURI);\n            twillPreparer.enableDebugging();\n          }\n          // Add scheduler queue name if defined\n          if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n            LOG.info(\"Setting scheduler queue for app {} as {}\", program.getId(), schedulerQueueName);\n            twillPreparer.setSchedulerQueue(schedulerQueueName);\n          }\n          if (logbackURI != null) {\n            twillPreparer.withResources(logbackURI);\n          }\n\n          String yarnAppClassPath = hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH,\n                                           Joiner.on(\",\").join(YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH));\n          TwillController twillController = twillPreparer\n            .withDependencies(HBaseTableUtilFactory.getHBaseTableUtilClass())\n            .addLogHandler(new PrinterLogHandler(new PrintWriter(System.out)))\n            .addSecureStore(YarnSecureStore.create(HBaseTokenUtils.obtainToken(hConf, new Credentials())))\n            .withClassPaths(Iterables.concat(extraClassPaths, Splitter.on(',').trimResults()\n                              .split(hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH, \"\"))))\n            .withApplicationClassPaths(Splitter.on(\",\").trimResults().split(yarnAppClassPath))\n            .withBundlerClassAcceptor(new HadoopClassExcluder())\n            .withApplicationArguments(\n              String.format(\"--%s\", RunnableOptions.JAR), copiedProgram.getJarLocation().getName(),\n              String.format(\"--%s\", RunnableOptions.PROGRAM_OPTIONS), programOptions\n            ).start();\n          return addCleanupListener(twillController, program, tempDir);\n        }\n      });\n    } catch (IOException e) {\n      deleteDirectory(tempDir);\n      throw Throwables.propagate(e);\n    }\n  }","id":34078,"modified_method":"@Override\n  public final ProgramController run(final Program program, final ProgramOptions options) {\n    final String schedulerQueueName = options.getArguments().getOption(Constants.AppFabric.APP_SCHEDULER_QUEUE);\n    final File tempDir = DirUtils.createTempDir(new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                                         cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile());\n    try {\n      if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n        hConf.set(JobContext.QUEUE_NAME, schedulerQueueName);\n        LOG.info(\"Setting scheduler queue to {}\", schedulerQueueName);\n      }\n\n      Map<String, LocalizeResource> localizeResources = addAdapterPluginFiles(options,\n                                                                              new HashMap<String, LocalizeResource>());\n\n      // Copy config files and program jar to local temp, and ask Twill to localize it to container.\n      // What Twill does is to save those files in HDFS and keep using them during the lifetime of application.\n      // Twill will manage the cleanup of those files in HDFS.\n      localizeResources.put(\"hConf.xml\",\n                            new LocalizeResource(saveHConf(hConf, File.createTempFile(\"hConf\", \".xml\", tempDir))));\n      localizeResources.put(\"cConf.xml\",\n                            new LocalizeResource(saveCConf(cConf, File.createTempFile(\"cConf\", \".xml\", tempDir))));\n      File programDir = DirUtils.createTempDir(tempDir);\n      final Program copiedProgram = copyProgramJar(program, tempDir, programDir);\n\n      final URI logbackURI = getLogBackURI(copiedProgram, programDir, tempDir);\n      final String programOptions = GSON.toJson(options);\n\n      // Obtains and add the HBase delegation token as well (if in non-secure mode, it's a no-op)\n      // Twill would also ignore it if it is not running in secure mode.\n      // The HDFS token should already obtained by Twill.\n      return launch(copiedProgram, options, localizeResources, new ApplicationLauncher() {\n        @Override\n        public TwillController launch(TwillApplication twillApplication, Iterable<String> extraClassPaths) {\n          TwillPreparer twillPreparer = twillRunner.prepare(twillApplication);\n          if (options.isDebug()) {\n            LOG.info(\"Starting {} with debugging enabled, programOptions: {}, and logback: {}\",\n                     program.getId(), programOptions, logbackURI);\n            twillPreparer.enableDebugging();\n          }\n          // Add scheduler queue name if defined\n          if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n            LOG.info(\"Setting scheduler queue for app {} as {}\", program.getId(), schedulerQueueName);\n            twillPreparer.setSchedulerQueue(schedulerQueueName);\n          }\n          if (logbackURI != null) {\n            twillPreparer.withResources(logbackURI);\n          }\n\n          String yarnAppClassPath = hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH,\n                                           Joiner.on(\",\").join(YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH));\n          TwillController twillController = twillPreparer\n            .withDependencies(HBaseTableUtilFactory.getHBaseTableUtilClass())\n            .addLogHandler(new PrinterLogHandler(new PrintWriter(System.out)))\n            .addSecureStore(YarnSecureStore.create(HBaseTokenUtils.obtainToken(hConf, new Credentials())))\n            .withClassPaths(Iterables.concat(extraClassPaths, Splitter.on(',').trimResults()\n                              .split(hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH, \"\"))))\n            .withApplicationClassPaths(Splitter.on(\",\").trimResults().split(yarnAppClassPath))\n            .withBundlerClassAcceptor(new HadoopClassExcluder())\n            .withApplicationArguments(\n              String.format(\"--%s\", RunnableOptions.JAR), copiedProgram.getJarLocation().getName(),\n              String.format(\"--%s\", RunnableOptions.PROGRAM_OPTIONS), programOptions\n            ).start();\n          return addCleanupListener(twillController, program, tempDir);\n        }\n      });\n    } catch (IOException e) {\n      deleteDirectory(tempDir);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Request localization of the program jar and all other files.\n   */\n  private Builder.RunnableSetter localizeFiles(Builder.LocalFileAdder fileAdder) {\n    Location programLocation = program.getJarLocation();\n\n    Builder.MoreFile moreFile = fileAdder.add(programLocation.getName(), programLocation.toURI());\n    for (Map.Entry<String, File> entry : localizeFiles.entrySet()) {\n      moreFile.add(entry.getKey(), entry.getValue().toURI());\n    }\n    return moreFile.apply();\n  }","id":34079,"modified_method":"/**\n   * Request localization of the program jar and all other files.\n   */\n  private Builder.RunnableSetter localizeFiles(Builder.LocalFileAdder fileAdder) {\n    Location programLocation = program.getJarLocation();\n\n    Builder.MoreFile moreFile = fileAdder.add(programLocation.getName(), programLocation.toURI());\n    for (Map.Entry<String, LocalizeResource> entry : localizeResources.entrySet()) {\n      moreFile.add(entry.getKey(), entry.getValue().getURI(), entry.getValue().isArchive());\n    }\n    return moreFile.apply();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Constructor.\n   *\n   * @param program represents the program to be launched in Twill\n   * @param localizeFiles set of files to be localized to the Twill container\n   * @param eventHandler An {@link EventHandler} for the Twill application which will be set to the\n   *                     Twill application specification\n   */\n  protected AbstractProgramTwillApplication(Program program,\n                                            Map<String, File> localizeFiles, EventHandler eventHandler) {\n    this.program = program;\n    this.localizeFiles = localizeFiles;\n    this.eventHandler = eventHandler;\n  }","id":34080,"modified_method":"/**\n   * Constructor.\n   *\n   * @param program represents the program to be launched in Twill\n   * @param localizeResources set of resources to be localized to the Twill container\n   * @param eventHandler An {@link EventHandler} for the Twill application which will be set to the\n   *                     Twill application specification\n   */\n  protected AbstractProgramTwillApplication(Program program,\n                                            Map<String, LocalizeResource> localizeResources,\n                                            EventHandler eventHandler) {\n    this.program = program;\n    this.localizeResources = ImmutableMap.copyOf(localizeResources);\n    this.eventHandler = eventHandler;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, File> localizeFiles, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.FLOW, \"Only FLOW process type is supported.\");\n\n    try {\n      FlowSpecification flowSpec = appSpec.getFlows().get(program.getName());\n      Preconditions.checkNotNull(flowSpec, \"Missing FlowSpecification for %s\", program.getName());\n\n      LOG.info(\"Configuring flowlets queues\");\n      Multimap<String, QueueName> flowletQueues = FlowUtils.configureQueue(program, flowSpec,\n                                                                           streamAdmin, queueAdmin, txExecutorFactory);\n\n      // Launch flowlet program runners\n      LOG.info(\"Launching distributed flow: \" + program.getName() + \":\" + flowSpec.getName());\n\n      TwillController controller = launcher.launch(new FlowTwillApplication(program, flowSpec,\n                                                                            localizeFiles, eventHandler));\n      DistributedFlowletInstanceUpdater instanceUpdater =\n        new DistributedFlowletInstanceUpdater(program, controller, queueAdmin,\n                                              streamAdmin, flowletQueues, txExecutorFactory);\n      RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n      return new FlowTwillProgramController(program.getName(), controller, instanceUpdater, runId).startListen();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":34081,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, LocalizeResource> localizeResources,\n                                     ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.FLOW, \"Only FLOW process type is supported.\");\n\n    try {\n      FlowSpecification flowSpec = appSpec.getFlows().get(program.getName());\n      Preconditions.checkNotNull(flowSpec, \"Missing FlowSpecification for %s\", program.getName());\n\n      LOG.info(\"Configuring flowlets queues\");\n      Multimap<String, QueueName> flowletQueues = FlowUtils.configureQueue(program, flowSpec,\n                                                                           streamAdmin, queueAdmin, txExecutorFactory);\n\n      // Launch flowlet program runners\n      LOG.info(\"Launching distributed flow: \" + program.getName() + \":\" + flowSpec.getName());\n\n      TwillController controller = launcher.launch(new FlowTwillApplication(program, flowSpec,\n                                                                            localizeResources, eventHandler));\n      DistributedFlowletInstanceUpdater instanceUpdater =\n        new DistributedFlowletInstanceUpdater(program, controller, queueAdmin,\n                                              streamAdmin, flowletQueues, txExecutorFactory);\n      RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n      return new FlowTwillProgramController(program.getName(), controller, instanceUpdater, runId).startListen();\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, File> localizeFiles, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.MAPREDUCE, \"Only MAPREDUCE process type is supported.\");\n\n    MapReduceSpecification spec = appSpec.getMapReduce().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing MapReduceSpecification for %s\", program.getName());\n\n    LOG.info(\"Launching MapReduce program: \" + program.getName() + \":\" + spec.getName());\n    TwillController controller = launcher.launch(new MapReduceTwillApplication(program, spec,\n                                                                               localizeFiles, eventHandler));\n\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new MapReduceTwillProgramController(program.getName(), controller, runId).startListen();\n  }","id":34082,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, LocalizeResource> localizeResources,\n                                     ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.MAPREDUCE, \"Only MAPREDUCE process type is supported.\");\n\n    MapReduceSpecification spec = appSpec.getMapReduce().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing MapReduceSpecification for %s\", program.getName());\n\n    List<String> extraClassPaths = MapReduceContainerHelper.localizeFramework(hConf, localizeResources);\n    LOG.info(\"Launching MapReduce program: \" + program.getName() + \":\" + spec.getName());\n    TwillController controller = launcher.launch(\n      new MapReduceTwillApplication(program, spec, localizeResources, eventHandler),\n      extraClassPaths);\n\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new MapReduceTwillProgramController(program.getName(), controller, runId).startListen();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, File> localizeFiles, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.SERVICE, \"Only SERVICE process type is supported.\");\n\n    final ServiceSpecification serviceSpec = appSpec.getServices().get(program.getName());\n    Preconditions.checkNotNull(serviceSpec, \"Missing ServiceSpecification for %s\", program.getName());\n\n    // Launch service runnables program runners\n    LOG.info(\"Launching distributed service: {}:{}\", program.getName(), serviceSpec.getName());\n\n    TwillController controller = launcher.launch(new ServiceTwillApplication(program, serviceSpec,\n                                                                             localizeFiles, eventHandler));\n\n    DistributedServiceRunnableInstanceUpdater instanceUpdater = new DistributedServiceRunnableInstanceUpdater(\n      program, controller);\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new ServiceTwillProgramController(program.getName(), controller, instanceUpdater, runId).startListen();\n  }","id":34083,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, LocalizeResource> localizeResources,\n                                     ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.SERVICE, \"Only SERVICE process type is supported.\");\n\n    final ServiceSpecification serviceSpec = appSpec.getServices().get(program.getName());\n    Preconditions.checkNotNull(serviceSpec, \"Missing ServiceSpecification for %s\", program.getName());\n\n    // Launch service runnables program runners\n    LOG.info(\"Launching distributed service: {}:{}\", program.getName(), serviceSpec.getName());\n\n    TwillController controller = launcher.launch(new ServiceTwillApplication(program, serviceSpec,\n                                                                             localizeResources, eventHandler));\n\n    DistributedServiceRunnableInstanceUpdater instanceUpdater = new DistributedServiceRunnableInstanceUpdater(\n      program, controller);\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new ServiceTwillProgramController(program.getName(), controller, instanceUpdater, runId).startListen();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, File> localizeFiles, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification for %s\", program.getId());\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type for %s\", program.getId());\n    Preconditions.checkArgument(processorType == ProgramType.SPARK,\n                                \"Only SPARK process type is supported. Program type is %s for %s\",\n                                processorType, program.getId());\n\n    SparkSpecification spec = appSpec.getSpark().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing SparkSpecification for %s\", program.getId());\n\n    // Localize the spark-assembly jar\n    File sparkAssemblyJar = SparkUtils.locateSparkAssemblyJar();\n    localizeFiles.put(sparkAssemblyJar.getName(), sparkAssemblyJar);\n\n    LOG.info(\"Launching Spark program: {}\", program.getId());\n    TwillController controller = launcher.launch(new SparkTwillApplication(program, spec, localizeFiles, eventHandler),\n                                                 sparkAssemblyJar.getName());\n\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new SparkTwillProgramController(program.getName(), controller, runId).startListen();\n  }","id":34084,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, LocalizeResource> localizeResources,\n                                     ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification for %s\", program.getId());\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type for %s\", program.getId());\n    Preconditions.checkArgument(processorType == ProgramType.SPARK,\n                                \"Only SPARK process type is supported. Program type is %s for %s\",\n                                processorType, program.getId());\n\n    SparkSpecification spec = appSpec.getSpark().get(program.getName());\n    Preconditions.checkNotNull(spec, \"Missing SparkSpecification for %s\", program.getId());\n\n    // Localize the spark-assembly jar\n    File sparkAssemblyJar = SparkUtils.locateSparkAssemblyJar();\n    localizeResources.put(sparkAssemblyJar.getName(), new LocalizeResource(sparkAssemblyJar));\n\n    LOG.info(\"Launching Spark program: {}\", program.getId());\n    TwillController controller = launcher.launch(\n      new SparkTwillApplication(program, spec, localizeResources, eventHandler),\n      sparkAssemblyJar.getName());\n\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new SparkTwillProgramController(program.getName(), controller, runId).startListen();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, File> localizeFiles, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.WEBAPP, \"Only WEBAPP process type is supported.\");\n\n    LOG.info(\"Launching distributed webapp: \" + program.getName());\n    TwillController controller = launcher.launch(new WebappTwillApplication(program, localizeFiles, eventHandler));\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new WebappTwillProgramController(program.getName(), controller, runId).startListen();\n  }","id":34085,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, LocalizeResource> localizeResources,\n                                     ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.WEBAPP, \"Only WEBAPP process type is supported.\");\n\n    LOG.info(\"Launching distributed webapp: \" + program.getName());\n    TwillController controller = launcher.launch(new WebappTwillApplication(program, localizeResources, eventHandler));\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new WebappTwillProgramController(program.getName(), controller, runId).startListen();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, File> localizeFiles, ApplicationLauncher launcher) {\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.WORKER, \"Only WORKER process type is supported.\");\n\n    WorkerSpecification workerSpec = appSpec.getWorkers().get(program.getName());\n    Preconditions.checkNotNull(workerSpec, \"Missing WorkerSpecification for %s\", program.getName());\n\n    String instances = options.getArguments().getOption(ProgramOptionConstants.INSTANCES,\n                                                        String.valueOf(workerSpec.getInstances()));\n    String resourceString = options.getArguments().getOption(ProgramOptionConstants.RESOURCES, null);\n    Resources newResources = (resourceString != null) ? GSON.fromJson(resourceString, Resources.class) :\n      workerSpec.getResources();\n\n    WorkerSpecification newWorkerSpec = new WorkerSpecification(workerSpec.getClassName(), workerSpec.getName(),\n                                                                workerSpec.getDescription(), workerSpec.getProperties(),\n                                                                workerSpec.getDatasets(), newResources,\n                                                                Integer.valueOf(instances));\n\n    LOG.info(\"Launching distributed worker {}\", program.getName());\n\n    TwillController controller = launcher.launch(new WorkerTwillApplication(program, newWorkerSpec,\n                                                                            localizeFiles, eventHandler));\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new WorkerTwillProgramController(program.getName(), controller, runId).startListen();\n  }","id":34086,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, LocalizeResource> localizeResources,\n                                     ApplicationLauncher launcher) {\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.WORKER, \"Only WORKER process type is supported.\");\n\n    WorkerSpecification workerSpec = appSpec.getWorkers().get(program.getName());\n    Preconditions.checkNotNull(workerSpec, \"Missing WorkerSpecification for %s\", program.getName());\n\n    String instances = options.getArguments().getOption(ProgramOptionConstants.INSTANCES,\n                                                        String.valueOf(workerSpec.getInstances()));\n    String resourceString = options.getArguments().getOption(ProgramOptionConstants.RESOURCES, null);\n    Resources newResources = (resourceString != null) ? GSON.fromJson(resourceString, Resources.class) :\n      workerSpec.getResources();\n\n    WorkerSpecification newWorkerSpec = new WorkerSpecification(workerSpec.getClassName(), workerSpec.getName(),\n                                                                workerSpec.getDescription(), workerSpec.getProperties(),\n                                                                workerSpec.getDatasets(), newResources,\n                                                                Integer.valueOf(instances));\n\n    LOG.info(\"Launching distributed worker {}\", program.getName());\n\n    TwillController controller = launcher.launch(new WorkerTwillApplication(program, newWorkerSpec,\n                                                                            localizeResources, eventHandler));\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new WorkerTwillProgramController(program.getName(), controller, runId).startListen();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, File> localizeFiles, ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.WORKFLOW, \"Only WORKFLOW process type is supported.\");\n\n    WorkflowSpecification workflowSpec = appSpec.getWorkflows().get(program.getName());\n    Preconditions.checkNotNull(workflowSpec, \"Missing WorkflowSpecification for %s\", program.getName());\n\n    // It the workflow has Spark, localize the spark-assembly jar\n    List<String> extraClassPaths = new ArrayList<>();\n    Resources resources = findSparkDriverResources(program.getApplicationSpecification().getSpark(), workflowSpec);\n    if (resources != null) {\n      // Has Spark\n      File sparkAssemblyJar = SparkUtils.locateSparkAssemblyJar();\n      localizeFiles.put(sparkAssemblyJar.getName(), sparkAssemblyJar);\n      extraClassPaths.add(sparkAssemblyJar.getName());\n    } else {\n      // No Spark\n      resources = new Resources();\n    }\n\n    LOG.info(\"Launching distributed workflow: \" + program.getName() + \":\" + workflowSpec.getName());\n    TwillController controller = launcher.launch(\n      new WorkflowTwillApplication(program, workflowSpec, localizeFiles, eventHandler, resources),\n      extraClassPaths\n    );\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new WorkflowTwillProgramController(program.getName(), controller, runId).startListen();\n  }","id":34087,"modified_method":"@Override\n  protected ProgramController launch(Program program, ProgramOptions options,\n                                     Map<String, LocalizeResource> localizeResources,\n                                     ApplicationLauncher launcher) {\n    // Extract and verify parameters\n    ApplicationSpecification appSpec = program.getApplicationSpecification();\n    Preconditions.checkNotNull(appSpec, \"Missing application specification.\");\n\n    ProgramType processorType = program.getType();\n    Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n    Preconditions.checkArgument(processorType == ProgramType.WORKFLOW, \"Only WORKFLOW process type is supported.\");\n\n    WorkflowSpecification workflowSpec = appSpec.getWorkflows().get(program.getName());\n    Preconditions.checkNotNull(workflowSpec, \"Missing WorkflowSpecification for %s\", program.getName());\n\n    // It the workflow has Spark, localize the spark-assembly jar\n    List<String> extraClassPaths = new ArrayList<>(\n      MapReduceContainerHelper.localizeFramework(hConf, localizeResources));\n\n    // See if the Workflow has Spark in it\n    Resources resources = findSparkDriverResources(program.getApplicationSpecification().getSpark(), workflowSpec);\n    if (resources != null) {\n      // Has Spark\n      File sparkAssemblyJar = SparkUtils.locateSparkAssemblyJar();\n      localizeResources.put(sparkAssemblyJar.getName(), new LocalizeResource(sparkAssemblyJar));\n      extraClassPaths.add(sparkAssemblyJar.getName());\n    } else {\n      // No Spark\n      resources = new Resources();\n    }\n\n    LOG.info(\"Launching distributed workflow: \" + program.getName() + \":\" + workflowSpec.getName());\n    TwillController controller = launcher.launch(\n      new WorkflowTwillApplication(program, workflowSpec, localizeResources, eventHandler, resources),\n      extraClassPaths\n    );\n    RunId runId = RunIds.fromString(options.getArguments().getOption(ProgramOptionConstants.RUN_ID));\n    return new WorkflowTwillProgramController(program.getName(), controller, runId).startListen();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"public FlowTwillApplication(Program program, FlowSpecification spec,\n                              Map<String, File> localizeFiles, EventHandler eventHandler) {\n    super(program, localizeFiles, eventHandler);\n    this.spec = spec;\n  }","id":34088,"modified_method":"public FlowTwillApplication(Program program, FlowSpecification spec,\n                              Map<String, LocalizeResource> localizeResources, EventHandler eventHandler) {\n    super(program, localizeResources, eventHandler);\n    this.spec = spec;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    // Creates a temporary directory locally for storing all generated files.\n    File tempDir = createTempDirectory();\n    this.cleanupTask = createCleanupTask(tempDir);\n\n    try {\n      Job job = createJob(new File(tempDir, \"mapreduce\"));\n      Configuration mapredConf = job.getConfiguration();\n\n      classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader());\n      mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n      ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n      context.setJob(job);\n\n      beforeSubmit(job);\n\n      // Override user-defined job name, since we set it and depend on the name.\n      // https://issues.cask.co/browse/CDAP-2441\n      String jobName = job.getJobName();\n      if (!jobName.isEmpty()) {\n        LOG.warn(\"Job name {} is being overridden.\", jobName);\n      }\n      job.setJobName(getJobName(context));\n\n      // Create a temporary location for storing all generated files through the LocationFactory.\n      Location tempLocation = createTempLocationDirectory();\n      this.cleanupTask = createCleanupTask(tempDir, tempLocation);\n\n      Location pluginArchive = null;\n      // For local mode, everything is in the configuration classloader already, hence no need to create new jar\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        // After calling beforeSubmit, we know what plugins are needed for adapter, hence construct the proper\n        // ClassLoader from here and use it for setting up the job\n        pluginArchive = createPluginArchive(context.getAdapterSpecification(), tempDir, tempLocation);\n        if (pluginArchive != null) {\n          job.addCacheArchive(pluginArchive.toURI());\n        }\n      }\n\n      // Alter the configuration ClassLoader to a MapReduceClassLoader that supports plugin\n      // It is mainly for standalone mode to have the same ClassLoader as in distributed mode\n      // It can only be constructed here because we need to have all adapter plugins information\n      classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader(), context.getAdapterSpecification(),\n                                             context.getPluginInstantiator());\n      mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n      ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n      setOutputClassesIfNeeded(job);\n      setMapOutputClassesIfNeeded(job);\n\n      // set resources for the job\n      TaskType.MAP.setResources(mapredConf, context.getMapperResources());\n      TaskType.REDUCE.setResources(mapredConf, context.getReducerResources());\n\n      // replace user's Mapper & Reducer's with our wrappers in job config\n      MapperWrapper.wrap(job);\n      ReducerWrapper.wrap(job);\n\n      // packaging job jar which includes cdap classes with dependencies\n      File jobJar = buildJobJar(job, tempDir);\n      job.setJar(jobJar.toURI().toString());\n\n      Location programJar = programJarLocation;\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        // Copy and localize the program jar in distributed mode\n        programJar = copyProgramJar(tempLocation);\n        job.addCacheFile(programJar.toURI());\n\n        // Generate and localize the launcher jar to control the classloader of MapReduce processes\n        String yarnAppClassPath = \"job.jar/lib/*,job.jar/classes,\" +\n          mapredConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH,\n                         Joiner.on(',').join(YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH));\n        Location launcherJar = createLauncherJar(yarnAppClassPath, tempLocation);\n        job.addCacheFile(launcherJar.toURI());\n\n        // The only thing in the container classpath is the launcher.jar\n        // The MapReduceContainerLauncher inside the launcher.jar will creates a MapReduceClassLoader and launch\n        // the actual MapReduce AM/Task from that\n        mapredConf.set(YarnConfiguration.YARN_APPLICATION_CLASSPATH, launcherJar.getName());\n      }\n\n      MapReduceContextConfig contextConfig = new MapReduceContextConfig(mapredConf);\n      // We start long-running tx to be used by mapreduce job tasks.\n      Transaction tx = txClient.startLong();\n      try {\n        // We remember tx, so that we can re-use it in mapreduce tasks\n        // Make a copy of the conf and rewrite the template plugin directory to be the plugin archive name\n        CConfiguration cConfCopy = cConf;\n        if (pluginArchive != null) {\n          cConfCopy = CConfiguration.copy(cConf);\n          cConfCopy.set(Constants.AppFabric.APP_TEMPLATE_DIR, pluginArchive.getName());\n        }\n        contextConfig.set(context, cConfCopy, tx, programJar.toURI());\n\n        LOG.info(\"Submitting MapReduce Job: {}\", context);\n        // submits job and returns immediately. Shouldn't need to set context ClassLoader.\n        job.submit();\n\n        this.job = job;\n        this.transaction = tx;\n      } catch (Throwable t) {\n        Transactions.invalidateQuietly(txClient, tx);\n        throw t;\n      }\n    } catch (Throwable t) {\n      LOG.error(\"Exception when submitting MapReduce Job: {}\", context, t);\n      cleanupTask.run();\n      throw t;\n    }\n  }","id":34089,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    // Creates a temporary directory locally for storing all generated files.\n    File tempDir = createTempDirectory();\n    this.cleanupTask = createCleanupTask(tempDir);\n\n    try {\n      Job job = createJob(new File(tempDir, \"mapreduce\"));\n      Configuration mapredConf = job.getConfiguration();\n\n      classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader());\n      mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n      ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n      context.setJob(job);\n\n      beforeSubmit(job);\n\n      // Override user-defined job name, since we set it and depend on the name.\n      // https://issues.cask.co/browse/CDAP-2441\n      String jobName = job.getJobName();\n      if (!jobName.isEmpty()) {\n        LOG.warn(\"Job name {} is being overridden.\", jobName);\n      }\n      job.setJobName(getJobName(context));\n\n      // Create a temporary location for storing all generated files through the LocationFactory.\n      Location tempLocation = createTempLocationDirectory();\n      this.cleanupTask = createCleanupTask(tempDir, tempLocation);\n\n      Location pluginArchive = null;\n      // For local mode, everything is in the configuration classloader already, hence no need to create new jar\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        // After calling beforeSubmit, we know what plugins are needed for adapter, hence construct the proper\n        // ClassLoader from here and use it for setting up the job\n        pluginArchive = createPluginArchive(context.getAdapterSpecification(), tempDir, tempLocation);\n        if (pluginArchive != null) {\n          job.addCacheArchive(pluginArchive.toURI());\n        }\n      }\n\n      // Alter the configuration ClassLoader to a MapReduceClassLoader that supports plugin\n      // It is mainly for standalone mode to have the same ClassLoader as in distributed mode\n      // It can only be constructed here because we need to have all adapter plugins information\n      classLoader = new MapReduceClassLoader(context.getProgram().getClassLoader(), context.getAdapterSpecification(),\n                                             context.getPluginInstantiator());\n      mapredConf.setClassLoader(new WeakReferenceDelegatorClassLoader(classLoader));\n      ClassLoaders.setContextClassLoader(mapredConf.getClassLoader());\n\n      setOutputClassesIfNeeded(job);\n      setMapOutputClassesIfNeeded(job);\n\n      // set resources for the job\n      TaskType.MAP.setResources(mapredConf, context.getMapperResources());\n      TaskType.REDUCE.setResources(mapredConf, context.getReducerResources());\n\n      // replace user's Mapper & Reducer's with our wrappers in job config\n      MapperWrapper.wrap(job);\n      ReducerWrapper.wrap(job);\n\n      // packaging job jar which includes cdap classes with dependencies\n      File jobJar = buildJobJar(job, tempDir);\n      job.setJar(jobJar.toURI().toString());\n\n      Location programJar = programJarLocation;\n      if (!MapReduceContextProvider.isLocal(mapredConf)) {\n        // Copy and localize the program jar in distributed mode\n        programJar = copyProgramJar(tempLocation);\n        job.addCacheFile(programJar.toURI());\n\n        // Generate and localize the launcher jar to control the classloader of MapReduce containers processes\n        List<String> paths = new ArrayList<>();\n        paths.add(\"job.jar/lib/*\");\n        paths.add(\"job.jar/classes\");\n        Location launcherJar = createLauncherJar(\n          Joiner.on(\",\").join(MapReduceContainerHelper.getMapReduceClassPath(mapredConf, paths)), tempLocation);\n        job.addCacheFile(launcherJar.toURI());\n\n        // The only thing in the container classpath is the launcher.jar\n        // The MapReduceContainerLauncher inside the launcher.jar will creates a MapReduceClassLoader and launch\n        // the actual MapReduce AM/Task from that\n        // We explicitly localize the mr-framwork, but not use it with the classpath\n        URI frameworkURI = MapReduceContainerHelper.getFrameworkURI(mapredConf);\n        if (frameworkURI != null) {\n          job.addCacheArchive(frameworkURI);\n        }\n\n        mapredConf.unset(MRJobConfig.MAPREDUCE_APPLICATION_FRAMEWORK_PATH);\n        mapredConf.set(MRJobConfig.MAPREDUCE_APPLICATION_CLASSPATH, launcherJar.getName());\n        mapredConf.set(YarnConfiguration.YARN_APPLICATION_CLASSPATH, launcherJar.getName());\n      }\n\n      MapReduceContextConfig contextConfig = new MapReduceContextConfig(mapredConf);\n      // We start long-running tx to be used by mapreduce job tasks.\n      Transaction tx = txClient.startLong();\n      try {\n        // We remember tx, so that we can re-use it in mapreduce tasks\n        // Make a copy of the conf and rewrite the template plugin directory to be the plugin archive name\n        CConfiguration cConfCopy = cConf;\n        if (pluginArchive != null) {\n          cConfCopy = CConfiguration.copy(cConf);\n          cConfCopy.set(Constants.AppFabric.APP_TEMPLATE_DIR, pluginArchive.getName());\n        }\n        contextConfig.set(context, cConfCopy, tx, programJar.toURI());\n\n        LOG.info(\"Submitting MapReduce Job: {}\", context);\n        // submits job and returns immediately. Shouldn't need to set context ClassLoader.\n        job.submit();\n\n        this.job = job;\n        this.transaction = tx;\n      } catch (Throwable t) {\n        Transactions.invalidateQuietly(txClient, tx);\n        throw t;\n      }\n    } catch (Throwable t) {\n      LOG.error(\"Exception when submitting MapReduce Job: {}\", context, t);\n      cleanupTask.run();\n      throw t;\n    }\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"public MapReduceTwillApplication(Program program, MapReduceSpecification spec,\n                                   Map<String, File> localizeFiles, EventHandler eventHandler) {\n    super(program, localizeFiles, eventHandler);\n    this.name = spec.getName();\n  }","id":34090,"modified_method":"public MapReduceTwillApplication(Program program, MapReduceSpecification spec,\n                                   Map<String, LocalizeResource> localizeResources,\n                                   EventHandler eventHandler) {\n    super(program, localizeResources, eventHandler);\n    this.name = spec.getName();\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"public ServiceTwillApplication(Program program, ServiceSpecification spec,\n                                 Map<String, File> localizeFiles, EventHandler eventHandler) {\n    super(program, localizeFiles, eventHandler);\n    this.spec = spec;\n  }","id":34091,"modified_method":"public ServiceTwillApplication(Program program, ServiceSpecification spec,\n                                 Map<String, LocalizeResource> localizeResources,\n                                 EventHandler eventHandler) {\n    super(program, localizeResources, eventHandler);\n    this.spec = spec;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"public SparkTwillApplication(Program program, SparkSpecification spec,\n                               Map<String, File> localizeFiles, EventHandler eventHandler) {\n    super(program, localizeFiles, eventHandler);\n    this.spec = spec;\n  }","id":34092,"modified_method":"public SparkTwillApplication(Program program, SparkSpecification spec,\n                               Map<String, LocalizeResource> localizeResources,\n                               EventHandler eventHandler) {\n    super(program, localizeResources, eventHandler);\n    this.spec = spec;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"protected WebappTwillApplication(Program program, Map<String, File> localizeFiles, EventHandler eventHandler) {\n    super(program, localizeFiles, eventHandler);\n    this.program = program;\n  }","id":34093,"modified_method":"protected WebappTwillApplication(Program program,\n                                   Map<String, LocalizeResource> localizeResources,\n                                   EventHandler eventHandler) {\n    super(program, localizeResources, eventHandler);\n    this.program = program;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"public WorkerTwillApplication(Program program, WorkerSpecification spec,\n                                Map<String, File> localizeFiles,\n                                EventHandler eventHandler) {\n    super(program, localizeFiles, eventHandler);\n    this.spec = spec;\n  }","id":34094,"modified_method":"public WorkerTwillApplication(Program program, WorkerSpecification spec,\n                                Map<String, LocalizeResource> localizeResources,\n                                EventHandler eventHandler) {\n    super(program, localizeResources, eventHandler);\n    this.spec = spec;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"public WorkflowTwillApplication(Program program, WorkflowSpecification spec,\n                                  Map<String, File> localizeFiles,\n                                  EventHandler eventHandler,\n                                  Resources resources) {\n    super(program, localizeFiles, eventHandler);\n    this.spec = spec;\n    this.resources = resources;\n  }","id":34095,"modified_method":"public WorkflowTwillApplication(Program program, WorkflowSpecification spec,\n                                  Map<String, LocalizeResource> localizeResources,\n                                  EventHandler eventHandler,\n                                  Resources resources) {\n    super(program, localizeResources, eventHandler);\n    this.spec = spec;\n    this.resources = resources;\n  }","commit_id":"1e620b354288c94224240c73f2bfbaa29d1a3214","url":"https://github.com/caskdata/cdap"},{"original_method":"/** Annotates a tree according to options. */\n  @Override\n  public Tree transformTree(Tree t, Tree root) {\n    if (t == null || t.isLeaf()) {\n      return t;\n    }\n\n    List<String> annotations = new ArrayList<String>();\n    CategoryWordTag lab = (CategoryWordTag) t.label();\n    String word = lab.word();\n    String tag = lab.tag();\n    String cat = lab.value();\n    Tree parent = t.parent(root);\n\n    if (t.isPhrasal()) {\n\n      List<String> childBasicCats = childBasicCats(t);\n\n      // cdm 2008: have form for with and without functional tags since this is a hash\n      if (markZu && cat.startsWith(\"V\") && (childBasicCats.contains(\"PTKZU\") || childBasicCats.contains(\"PTKZU-HD\") || childBasicCats.contains(\"VVIZU\") || childBasicCats.contains(\"VVIZU-HD\"))) {\n        annotations.add(\"%ZU\");\n      }\n      if (markContainsV && containsV(t)) {\n        annotations.add(\"%vp\");\n      }\n\n      if (markKonjParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-KONJ\")) {\n            annotations.add(\"%konjp\");\n            break;\n          }\n        }\n      }\n\n      if (markHDParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-HD\")) {\n            annotations.add(\"%hdp\");\n            break;\n          }\n        }\n      }\n    } else {\n      // t.isPreTerminal() case\n//      if (word.equals(\"%\")) {\n//        annotations.add(\"-%\");\n//      }\n//      if(parent != null) {\n//        String parentVal = parent.label().value();\n//        int cutOffPtD = parentVal.indexOf('-');\n//        int cutOffPtC = parentVal.indexOf('^');\n//        int curMin = parentVal.length();\n//        if(cutOffPtD != -1) {\n//          curMin = cutOffPtD;\n//        }\n//        if(cutOffPtC != -1) {\n//          curMin = Math.min(curMin, cutOffPtC);\n//        }\n//        parentVal = parentVal.substring(0, curMin);\n//        annotations.add(\"^\" + parentVal);\n//      }\n      if (markColons && cat.equals(\"$.\") && (word.equals(\":\") || word.equals(\";\"))) {\n        annotations.add(\"-%colon\");\n      }\n\n      if(leftPhrasal && leftPhrasal(t)) {\n        annotations.add(\"%LP\");\n      };\n\n\n    }\n    // put on all the annotations\n    StringBuilder catSB = new StringBuilder(cat);\n    for (String annotation : annotations) {\n      catSB.append(annotation);\n    }\n\n    t.setLabel(new CategoryWordTag(catSB.toString(), word, tag));\n    return t;\n  }","id":34096,"modified_method":"/** Annotates a tree according to options. */\n  @Override\n  public Tree transformTree(Tree t, Tree root) {\n    if (t == null || t.isLeaf()) {\n      return t;\n    }\n\n    List<String> annotations = new ArrayList<String>();\n    Label lab = t.label();\n    String word = null;\n    if (lab instanceof HasWord) {\n      word = ((HasWord) lab).word();\n    }\n    String tag = null;\n    if (lab instanceof HasTag) {\n      tag = ((HasTag) lab).tag();\n    }\n    String cat = lab.value();\n    // Tree parent = t.parent(root);\n\n    if (t.isPhrasal()) {\n\n      List<String> childBasicCats = childBasicCats(t);\n\n      // cdm 2008: have form for with and without functional tags since this is a hash\n      if (markZu && cat.startsWith(\"V\") && (childBasicCats.contains(\"PTKZU\") || childBasicCats.contains(\"PTKZU-HD\") || childBasicCats.contains(\"VVIZU\") || childBasicCats.contains(\"VVIZU-HD\"))) {\n        annotations.add(\"%ZU\");\n      }\n      if (markContainsV && containsV(t)) {\n        annotations.add(\"%vp\");\n      }\n\n      if (markKonjParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-KONJ\")) {\n            annotations.add(\"%konjp\");\n            break;\n          }\n        }\n      }\n\n      if (markHDParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-HD\")) {\n            annotations.add(\"%hdp\");\n            break;\n          }\n        }\n      }\n    } else {\n      // t.isPreTerminal() case\n//      if (word.equals(\"%\")) {\n//        annotations.add(\"-%\");\n//      }\n//      if(parent != null) {\n//        String parentVal = parent.label().value();\n//        int cutOffPtD = parentVal.indexOf('-');\n//        int cutOffPtC = parentVal.indexOf('^');\n//        int curMin = parentVal.length();\n//        if(cutOffPtD != -1) {\n//          curMin = cutOffPtD;\n//        }\n//        if(cutOffPtC != -1) {\n//          curMin = Math.min(curMin, cutOffPtC);\n//        }\n//        parentVal = parentVal.substring(0, curMin);\n//        annotations.add(\"^\" + parentVal);\n//      }\n      if (markColons && cat.equals(\"$.\") && word != null && (word.equals(\":\") || word.equals(\";\"))) {\n        annotations.add(\"-%colon\");\n      }\n\n      if(leftPhrasal && leftPhrasal(t)) {\n        annotations.add(\"%LP\");\n      }\n\n\n    }\n    // put on all the annotations\n    StringBuilder catSB = new StringBuilder(cat);\n    for (String annotation : annotations) {\n      catSB.append(annotation);\n    }\n\n    t.setLabel(new CategoryWordTag(catSB.toString(), word, tag));\n    return t;\n  }","commit_id":"b8d2d938eb70e2d6c05c367f19eebc43950375bc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Binarizes the tree according to options set up in the constructor.\n   *  Does the whole tree by calling itself recursively.\n   *\n   *  @param t A tree to be binarized. The non-leaf nodes must already have\n   *    CategoryWordTag labels, with heads percolated.\n   *  @return A binary tree.\n   */\n  public Tree transformTree(Tree t) {\n    // handle null\n    if (t == null) {\n      return null;\n    }\n\n    String cat = t.label().value();\n    // handle words\n    if (t.isLeaf()) {\n      Label label = new Word(cat);//new CategoryWordTag(cat,cat,\"\");\n      return tf.newLeaf(label);\n    }\n    // handle tags\n    if (t.isPreTerminal()) {\n      Tree childResult = transformTree(t.getChild(0));\n      String word = childResult.value();  // would be nicer if Word/CWT ??\n      List<Tree> newChildren = new ArrayList<Tree>(1);\n      newChildren.add(childResult);\n      return tf.newTreeNode(new CategoryWordTag(cat, word, cat), newChildren);\n    }\n    // handle categories\n    Tree headChild = hf.determineHead(t);\n    /*\n    System.out.println(\"### finding head for:\");\n    t.pennPrint();\n    System.out.println(\"### its head is:\");\n    headChild.pennPrint();\n    */\n    if (headChild == null && ! t.label().value().startsWith(tlp.startSymbol())) {\n      System.err.println(\"### No head found for:\");\n      t.pennPrint();\n    }\n    int headNum = -1;\n    Tree[] kids = t.children();\n    List<Tree> newChildren = new ArrayList<Tree>(kids.length);\n    for (int childNum = 0; childNum < kids.length; childNum++) {\n      Tree child = kids[childNum];\n      Tree childResult = transformTree(child);   // recursive call\n      if (child == headChild) {\n        headNum = childNum;\n      }\n      newChildren.add(childResult);\n    }\n    Tree result;\n    // XXXXX UPTO HERE!!!  ALMOST DONE!!!\n    if (t.label().value().startsWith(tlp.startSymbol())) {\n      // handle the ROOT tree properly\n      CategoryWordTag label = (CategoryWordTag) t.label();\n      /*\n      // binarize without the last kid and then add it back to the top tree\n      Tree lastKid = (Tree)newChildren.remove(newChildren.size()-1);\n      Tree tempTree = tf.newTreeNode(label, newChildren);\n      tempTree = binarizeLocalTree(tempTree, headNum, result.head);\n      newChildren = tempTree.getChildrenAsList();\n      newChildren.add(lastKid); // add it back\n      */\n      result = tf.newTreeNode(label, newChildren); // label shouldn't have changed\n    } else {\n//      CategoryWordTag headLabel = (CategoryWordTag) headChild.label();\n      String word = ((HasWord) headChild.label()).word();\n      String tag = ((HasTag) headChild.label()).tag();\n      Label label = new CategoryWordTag(cat, word, tag);\n      result = tf.newTreeNode(label, newChildren);\n      // cdm Mar 2005: invent a head so I don't have to rewrite all this\n      // code, but with the removal of TreeHeadPair, some of the rest of\n      // this should probably be rewritten too to not use this head variable\n      TaggedWord head = new TaggedWord(word, tag);\n      result = binarizeLocalTree(result, headNum, head);\n    }\n    return result;\n  }","id":34097,"modified_method":"/** Binarizes the tree according to options set up in the constructor.\n   *  Does the whole tree by calling itself recursively.\n   *\n   *  @param t A tree to be binarized. The non-leaf nodes must already have\n   *    CategoryWordTag labels, with heads percolated.\n   *  @return A binary tree.\n   */\n  public Tree transformTree(Tree t) {\n    // handle null\n    if (t == null) {\n      return null;\n    }\n\n    String cat = t.label().value();\n    // handle words\n    if (t.isLeaf()) {\n      Label label = new Word(cat);//new CategoryWordTag(cat,cat,\"\");\n      return tf.newLeaf(label);\n    }\n    // handle tags\n    if (t.isPreTerminal()) {\n      Tree childResult = transformTree(t.getChild(0));\n      String word = childResult.value();  // would be nicer if Word/CWT ??\n      List<Tree> newChildren = new ArrayList<Tree>(1);\n      newChildren.add(childResult);\n      return tf.newTreeNode(new CategoryWordTag(cat, word, cat), newChildren);\n    }\n    // handle categories\n    Tree headChild = hf.determineHead(t);\n    /*\n    System.out.println(\"### finding head for:\");\n    t.pennPrint();\n    System.out.println(\"### its head is:\");\n    headChild.pennPrint();\n    */\n    if (headChild == null && ! t.label().value().startsWith(tlp.startSymbol())) {\n      System.err.println(\"### No head found for:\");\n      t.pennPrint();\n    }\n    int headNum = -1;\n    Tree[] kids = t.children();\n    List<Tree> newChildren = new ArrayList<Tree>(kids.length);\n    for (int childNum = 0; childNum < kids.length; childNum++) {\n      Tree child = kids[childNum];\n      Tree childResult = transformTree(child);   // recursive call\n      if (child == headChild) {\n        headNum = childNum;\n      }\n      newChildren.add(childResult);\n    }\n    Tree result;\n    // XXXXX UPTO HERE!!!  ALMOST DONE!!!\n    if (t.label().value().startsWith(tlp.startSymbol())) {\n      // handle the ROOT tree properly\n      /*\n      //CategoryWordTag label = (CategoryWordTag) t.label();\n      // binarize without the last kid and then add it back to the top tree\n      Tree lastKid = (Tree)newChildren.remove(newChildren.size()-1);\n      Tree tempTree = tf.newTreeNode(label, newChildren);\n      tempTree = binarizeLocalTree(tempTree, headNum, result.head);\n      newChildren = tempTree.getChildrenAsList();\n      newChildren.add(lastKid); // add it back\n      */\n      result = tf.newTreeNode(t.label(), newChildren); // label shouldn't have changed\n    } else {\n//      CategoryWordTag headLabel = (CategoryWordTag) headChild.label();\n      String word = ((HasWord) headChild.label()).word();\n      String tag = ((HasTag) headChild.label()).tag();\n      Label label = new CategoryWordTag(cat, word, tag);\n      result = tf.newTreeNode(label, newChildren);\n      // cdm Mar 2005: invent a head so I don't have to rewrite all this\n      // code, but with the removal of TreeHeadPair, some of the rest of\n      // this should probably be rewritten too to not use this head variable\n      TaggedWord head = new TaggedWord(word, tag);\n      result = binarizeLocalTree(result, headNum, head);\n    }\n    return result;\n  }","commit_id":"315198de706f0bf499b95d08ccc9a98ab6f95881","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Binarizes the tree according to options set up in the constructor.\n   *  Does the whole tree by calling itself recursively.\n   *\n   *  @param t A tree to be binarized. The non-leaf nodes must already have\n   *    CategoryWordTag labels, with heads percolated.\n   *  @return A binary tree.\n   */\n  public Tree transformTree(Tree t) {\n    // handle null\n    if (t == null) {\n      return null;\n    }\n\n    String cat = t.label().value();\n    // handle words\n    if (t.isLeaf()) {\n      Label label = new Word(cat);//new CategoryWordTag(cat,cat,\"\");\n      return tf.newLeaf(label);\n    }\n    // handle tags\n    if (t.isPreTerminal()) {\n      Tree childResult = transformTree(t.getChild(0));\n      String word = childResult.value();  // would be nicer if Word/CWT ??\n      List<Tree> newChildren = new ArrayList<Tree>(1);\n      newChildren.add(childResult);\n      return tf.newTreeNode(new CategoryWordTag(cat, word, cat), newChildren);\n    }\n    // handle categories\n    Tree headChild = hf.determineHead(t);\n    /*\n    System.out.println(\"### finding head for:\");\n    t.pennPrint();\n    System.out.println(\"### its head is:\");\n    headChild.pennPrint();\n    */\n    if (headChild == null && ! t.label().value().startsWith(tlp.startSymbol())) {\n      System.err.println(\"### No head found for:\");\n      t.pennPrint();\n    }\n    int headNum = -1;\n    Tree[] kids = t.children();\n    List<Tree> newChildren = new ArrayList<Tree>(kids.length);\n    for (int childNum = 0; childNum < kids.length; childNum++) {\n      Tree child = kids[childNum];\n      Tree childResult = transformTree(child);   // recursive call\n      if (child == headChild) {\n        headNum = childNum;\n      }\n      newChildren.add(childResult);\n    }\n    Tree result;\n    // XXXXX UPTO HERE!!!  ALMOST DONE!!!\n    if (t.label().value().startsWith(tlp.startSymbol())) {\n      // handle the ROOT tree properly\n      CategoryWordTag label = (CategoryWordTag) t.label();\n      /*\n      // binarize without the last kid and then add it back to the top tree\n      Tree lastKid = (Tree)newChildren.remove(newChildren.size()-1);\n      Tree tempTree = tf.newTreeNode(label, newChildren);\n      tempTree = binarizeLocalTree(tempTree, headNum, result.head);\n      newChildren = tempTree.getChildrenAsList();\n      newChildren.add(lastKid); // add it back\n      */\n      result = tf.newTreeNode(label, newChildren); // label shouldn't have changed\n    } else {\n//      CategoryWordTag headLabel = (CategoryWordTag) headChild.label();\n      String word = ((HasWord) headChild.label()).word();\n      String tag = ((HasTag) headChild.label()).tag();\n      Label label = new CategoryWordTag(cat, word, tag);\n      result = tf.newTreeNode(label, newChildren);\n      // cdm Mar 2005: invent a head so I don't have to rewrite all this\n      // code, but with the removal of TreeHeadPair, some of the rest of\n      // this should probably be rewritten too to not use this head variable\n      TaggedWord head = new TaggedWord(word, tag);\n      result = binarizeLocalTree(result, headNum, head);\n    }\n    return result;\n  }","id":34098,"modified_method":"/** Binarizes the tree according to options set up in the constructor.\n   *  Does the whole tree by calling itself recursively.\n   *\n   *  @param t A tree to be binarized. The non-leaf nodes must already have\n   *    CategoryWordTag labels, with heads percolated.\n   *  @return A binary tree.\n   */\n  public Tree transformTree(Tree t) {\n    // handle null\n    if (t == null) {\n      return null;\n    }\n\n    String cat = t.label().value();\n    // handle words\n    if (t.isLeaf()) {\n      Label label = new Word(cat);//new CategoryWordTag(cat,cat,\"\");\n      return tf.newLeaf(label);\n    }\n    // handle tags\n    if (t.isPreTerminal()) {\n      Tree childResult = transformTree(t.getChild(0));\n      String word = childResult.value();  // would be nicer if Word/CWT ??\n      List<Tree> newChildren = new ArrayList<Tree>(1);\n      newChildren.add(childResult);\n      return tf.newTreeNode(new CategoryWordTag(cat, word, cat), newChildren);\n    }\n    // handle categories\n    Tree headChild = hf.determineHead(t);\n    /*\n    System.out.println(\"### finding head for:\");\n    t.pennPrint();\n    System.out.println(\"### its head is:\");\n    headChild.pennPrint();\n    */\n    if (headChild == null && ! t.label().value().startsWith(tlp.startSymbol())) {\n      System.err.println(\"### No head found for:\");\n      t.pennPrint();\n    }\n    int headNum = -1;\n    Tree[] kids = t.children();\n    List<Tree> newChildren = new ArrayList<Tree>(kids.length);\n    for (int childNum = 0; childNum < kids.length; childNum++) {\n      Tree child = kids[childNum];\n      Tree childResult = transformTree(child);   // recursive call\n      if (child == headChild) {\n        headNum = childNum;\n      }\n      newChildren.add(childResult);\n    }\n    Tree result;\n    // XXXXX UPTO HERE!!!  ALMOST DONE!!!\n    if (t.label().value().startsWith(tlp.startSymbol())) {\n      // handle the ROOT tree properly\n      /*\n      //CategoryWordTag label = (CategoryWordTag) t.label();\n      // binarize without the last kid and then add it back to the top tree\n      Tree lastKid = (Tree)newChildren.remove(newChildren.size()-1);\n      Tree tempTree = tf.newTreeNode(label, newChildren);\n      tempTree = binarizeLocalTree(tempTree, headNum, result.head);\n      newChildren = tempTree.getChildrenAsList();\n      newChildren.add(lastKid); // add it back\n      */\n      result = tf.newTreeNode(t.label(), newChildren); // label shouldn't have changed\n    } else {\n//      CategoryWordTag headLabel = (CategoryWordTag) headChild.label();\n      String word = ((HasWord) headChild.label()).word();\n      String tag = ((HasTag) headChild.label()).tag();\n      Label label = new CategoryWordTag(cat, word, tag);\n      result = tf.newTreeNode(label, newChildren);\n      // cdm Mar 2005: invent a head so I don't have to rewrite all this\n      // code, but with the removal of TreeHeadPair, some of the rest of\n      // this should probably be rewritten too to not use this head variable\n      TaggedWord head = new TaggedWord(word, tag);\n      result = binarizeLocalTree(result, headNum, head);\n    }\n    return result;\n  }","commit_id":"d0b64f2ac11f038cc7d32f46b6ac22fc651283db","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Annotates a tree according to options. */\n  @Override\n  public Tree transformTree(Tree t, Tree root) {\n    if (t == null || t.isLeaf()) {\n      return t;\n    }\n\n    List<String> annotations = new ArrayList<String>();\n    CategoryWordTag lab = (CategoryWordTag) t.label();\n    String word = lab.word();\n    String tag = lab.tag();\n    String cat = lab.value();\n    Tree parent = t.parent(root);\n\n    if (t.isPhrasal()) {\n\n      List<String> childBasicCats = childBasicCats(t);\n\n      // cdm 2008: have form for with and without functional tags since this is a hash\n      if (markZu && cat.startsWith(\"V\") && (childBasicCats.contains(\"PTKZU\") || childBasicCats.contains(\"PTKZU-HD\") || childBasicCats.contains(\"VVIZU\") || childBasicCats.contains(\"VVIZU-HD\"))) {\n        annotations.add(\"%ZU\");\n      }\n      if (markContainsV && containsV(t)) {\n        annotations.add(\"%vp\");\n      }\n\n      if (markKonjParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-KONJ\")) {\n            annotations.add(\"%konjp\");\n            break;\n          }\n        }\n      }\n\n      if (markHDParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-HD\")) {\n            annotations.add(\"%hdp\");\n            break;\n          }\n        }\n      }\n    } else {\n      // t.isPreTerminal() case\n//      if (word.equals(\"%\")) {\n//        annotations.add(\"-%\");\n//      }\n//      if(parent != null) {\n//        String parentVal = parent.label().value();\n//        int cutOffPtD = parentVal.indexOf('-');\n//        int cutOffPtC = parentVal.indexOf('^');\n//        int curMin = parentVal.length();\n//        if(cutOffPtD != -1) {\n//          curMin = cutOffPtD;\n//        }\n//        if(cutOffPtC != -1) {\n//          curMin = Math.min(curMin, cutOffPtC);\n//        }\n//        parentVal = parentVal.substring(0, curMin);\n//        annotations.add(\"^\" + parentVal);\n//      }\n      if (markColons && cat.equals(\"$.\") && (word.equals(\":\") || word.equals(\";\"))) {\n        annotations.add(\"-%colon\");\n      }\n\n      if(leftPhrasal && leftPhrasal(t)) {\n        annotations.add(\"%LP\");\n      };\n\n\n    }\n    // put on all the annotations\n    StringBuilder catSB = new StringBuilder(cat);\n    for (String annotation : annotations) {\n      catSB.append(annotation);\n    }\n\n    t.setLabel(new CategoryWordTag(catSB.toString(), word, tag));\n    return t;\n  }","id":34099,"modified_method":"/** Annotates a tree according to options. */\n  @Override\n  public Tree transformTree(Tree t, Tree root) {\n    if (t == null || t.isLeaf()) {\n      return t;\n    }\n\n    List<String> annotations = new ArrayList<String>();\n    Label lab = t.label();\n    String word = null;\n    if (lab instanceof HasWord) {\n      word = ((HasWord) lab).word();\n    }\n    String tag = null;\n    if (lab instanceof HasTag) {\n      tag = ((HasTag) lab).tag();\n    }\n    String cat = lab.value();\n    // Tree parent = t.parent(root);\n\n    if (t.isPhrasal()) {\n\n      List<String> childBasicCats = childBasicCats(t);\n\n      // cdm 2008: have form for with and without functional tags since this is a hash\n      if (markZu && cat.startsWith(\"V\") && (childBasicCats.contains(\"PTKZU\") || childBasicCats.contains(\"PTKZU-HD\") || childBasicCats.contains(\"VVIZU\") || childBasicCats.contains(\"VVIZU-HD\"))) {\n        annotations.add(\"%ZU\");\n      }\n      if (markContainsV && containsV(t)) {\n        annotations.add(\"%vp\");\n      }\n\n      if (markKonjParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-KONJ\")) {\n            annotations.add(\"%konjp\");\n            break;\n          }\n        }\n      }\n\n      if (markHDParent) {\n        // this depends on functional tags being present\n        for (String cCat : childBasicCats) {\n          if (cCat.contains(\"-HD\")) {\n            annotations.add(\"%hdp\");\n            break;\n          }\n        }\n      }\n    } else {\n      // t.isPreTerminal() case\n//      if (word.equals(\"%\")) {\n//        annotations.add(\"-%\");\n//      }\n//      if(parent != null) {\n//        String parentVal = parent.label().value();\n//        int cutOffPtD = parentVal.indexOf('-');\n//        int cutOffPtC = parentVal.indexOf('^');\n//        int curMin = parentVal.length();\n//        if(cutOffPtD != -1) {\n//          curMin = cutOffPtD;\n//        }\n//        if(cutOffPtC != -1) {\n//          curMin = Math.min(curMin, cutOffPtC);\n//        }\n//        parentVal = parentVal.substring(0, curMin);\n//        annotations.add(\"^\" + parentVal);\n//      }\n      if (markColons && cat.equals(\"$.\") && word != null && (word.equals(\":\") || word.equals(\";\"))) {\n        annotations.add(\"-%colon\");\n      }\n\n      if(leftPhrasal && leftPhrasal(t)) {\n        annotations.add(\"%LP\");\n      }\n\n\n    }\n    // put on all the annotations\n    StringBuilder catSB = new StringBuilder(cat);\n    for (String annotation : annotations) {\n      catSB.append(annotation);\n    }\n\n    t.setLabel(new CategoryWordTag(catSB.toString(), word, tag));\n    return t;\n  }","commit_id":"649f30f02d9b87d7756a445192527e4d9eb95766","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Binarizes the tree according to options set up in the constructor.\n   *  Does the whole tree by calling itself recursively.\n   *\n   *  @param t A tree to be binarized. The non-leaf nodes must already have\n   *    CategoryWordTag labels, with heads percolated.\n   *  @return A binary tree.\n   */\n  public Tree transformTree(Tree t) {\n    // handle null\n    if (t == null) {\n      return null;\n    }\n\n    String cat = t.label().value();\n    // handle words\n    if (t.isLeaf()) {\n      Label label = new Word(cat);//new CategoryWordTag(cat,cat,\"\");\n      return tf.newLeaf(label);\n    }\n    // handle tags\n    if (t.isPreTerminal()) {\n      Tree childResult = transformTree(t.getChild(0));\n      String word = childResult.value();  // would be nicer if Word/CWT ??\n      List<Tree> newChildren = new ArrayList<Tree>(1);\n      newChildren.add(childResult);\n      return tf.newTreeNode(new CategoryWordTag(cat, word, cat), newChildren);\n    }\n    // handle categories\n    Tree headChild = hf.determineHead(t);\n    /*\n    System.out.println(\"### finding head for:\");\n    t.pennPrint();\n    System.out.println(\"### its head is:\");\n    headChild.pennPrint();\n    */\n    if (headChild == null && ! t.label().value().startsWith(tlp.startSymbol())) {\n      System.err.println(\"### No head found for:\");\n      t.pennPrint();\n    }\n    int headNum = -1;\n    Tree[] kids = t.children();\n    List<Tree> newChildren = new ArrayList<Tree>(kids.length);\n    for (int childNum = 0; childNum < kids.length; childNum++) {\n      Tree child = kids[childNum];\n      Tree childResult = transformTree(child);   // recursive call\n      if (child == headChild) {\n        headNum = childNum;\n      }\n      newChildren.add(childResult);\n    }\n    Tree result;\n    // XXXXX UPTO HERE!!!  ALMOST DONE!!!\n    if (t.label().value().startsWith(tlp.startSymbol())) {\n      // handle the ROOT tree properly\n      CategoryWordTag label = (CategoryWordTag) t.label();\n      /*\n      // binarize without the last kid and then add it back to the top tree\n      Tree lastKid = (Tree)newChildren.remove(newChildren.size()-1);\n      Tree tempTree = tf.newTreeNode(label, newChildren);\n      tempTree = binarizeLocalTree(tempTree, headNum, result.head);\n      newChildren = tempTree.getChildrenAsList();\n      newChildren.add(lastKid); // add it back\n      */\n      result = tf.newTreeNode(label, newChildren); // label shouldn't have changed\n    } else {\n//      CategoryWordTag headLabel = (CategoryWordTag) headChild.label();\n      String word = ((HasWord) headChild.label()).word();\n      String tag = ((HasTag) headChild.label()).tag();\n      Label label = new CategoryWordTag(cat, word, tag);\n      result = tf.newTreeNode(label, newChildren);\n      // cdm Mar 2005: invent a head so I don't have to rewrite all this\n      // code, but with the removal of TreeHeadPair, some of the rest of\n      // this should probably be rewritten too to not use this head variable\n      TaggedWord head = new TaggedWord(word, tag);\n      result = binarizeLocalTree(result, headNum, head);\n    }\n    return result;\n  }","id":34100,"modified_method":"/** Binarizes the tree according to options set up in the constructor.\n   *  Does the whole tree by calling itself recursively.\n   *\n   *  @param t A tree to be binarized. The non-leaf nodes must already have\n   *    CategoryWordTag labels, with heads percolated.\n   *  @return A binary tree.\n   */\n  public Tree transformTree(Tree t) {\n    // handle null\n    if (t == null) {\n      return null;\n    }\n\n    String cat = t.label().value();\n    // handle words\n    if (t.isLeaf()) {\n      Label label = new Word(cat);//new CategoryWordTag(cat,cat,\"\");\n      return tf.newLeaf(label);\n    }\n    // handle tags\n    if (t.isPreTerminal()) {\n      Tree childResult = transformTree(t.getChild(0));\n      String word = childResult.value();  // would be nicer if Word/CWT ??\n      List<Tree> newChildren = new ArrayList<Tree>(1);\n      newChildren.add(childResult);\n      return tf.newTreeNode(new CategoryWordTag(cat, word, cat), newChildren);\n    }\n    // handle categories\n    Tree headChild = hf.determineHead(t);\n    /*\n    System.out.println(\"### finding head for:\");\n    t.pennPrint();\n    System.out.println(\"### its head is:\");\n    headChild.pennPrint();\n    */\n    if (headChild == null && ! t.label().value().startsWith(tlp.startSymbol())) {\n      System.err.println(\"### No head found for:\");\n      t.pennPrint();\n    }\n    int headNum = -1;\n    Tree[] kids = t.children();\n    List<Tree> newChildren = new ArrayList<Tree>(kids.length);\n    for (int childNum = 0; childNum < kids.length; childNum++) {\n      Tree child = kids[childNum];\n      Tree childResult = transformTree(child);   // recursive call\n      if (child == headChild) {\n        headNum = childNum;\n      }\n      newChildren.add(childResult);\n    }\n    Tree result;\n    // XXXXX UPTO HERE!!!  ALMOST DONE!!!\n    if (t.label().value().startsWith(tlp.startSymbol())) {\n      // handle the ROOT tree properly\n      /*\n      //CategoryWordTag label = (CategoryWordTag) t.label();\n      // binarize without the last kid and then add it back to the top tree\n      Tree lastKid = (Tree)newChildren.remove(newChildren.size()-1);\n      Tree tempTree = tf.newTreeNode(label, newChildren);\n      tempTree = binarizeLocalTree(tempTree, headNum, result.head);\n      newChildren = tempTree.getChildrenAsList();\n      newChildren.add(lastKid); // add it back\n      */\n      result = tf.newTreeNode(t.label(), newChildren); // label shouldn't have changed\n    } else {\n//      CategoryWordTag headLabel = (CategoryWordTag) headChild.label();\n      String word = ((HasWord) headChild.label()).word();\n      String tag = ((HasTag) headChild.label()).tag();\n      Label label = new CategoryWordTag(cat, word, tag);\n      result = tf.newTreeNode(label, newChildren);\n      // cdm Mar 2005: invent a head so I don't have to rewrite all this\n      // code, but with the removal of TreeHeadPair, some of the rest of\n      // this should probably be rewritten too to not use this head variable\n      TaggedWord head = new TaggedWord(word, tag);\n      result = binarizeLocalTree(result, headNum, head);\n    }\n    return result;\n  }","commit_id":"13e59e5cb61c8f6b1a3ffa9dde6e5133dc03103d","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n\n        final String name = operation.require(NAME).asString();\n        final PathAddress address = PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(DEPLOYMENT, name));\n\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        boolean exists = root.hasChild(PathElement.pathElement(DEPLOYMENT, name));\n        if (! exists) {\n            throw createFailureException(\"No deployment with name %s found\", name);\n        }\n\n        final ModelNode replaceNode = context.readModelForUpdate(address);\n        final String replacedRuntimeName = replaceNode.require(RUNTIME_NAME).asString();\n        final String runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replaceNode.require(RUNTIME_NAME).asString();\n\n        final byte[] hash;\n        // clone it, so we can modify it to our own content\n        final ModelNode content = operation.require(CONTENT).clone();\n        // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n        final DeploymentHandlerUtil.ContentItem contentItem;\n        final ModelNode contentItemNode = content.require(0);\n        if (contentItemNode.hasDefined(HASH)) {\n            managedContentValidator.validate(contentItemNode);\n            hash = contentItemNode.require(HASH).asBytes();\n            if (!contentRepository.hasContent(hash))\n                throw createFailureException(\"No deployment content with hash %s is available in the deployment content repository.\", HashUtil.bytesToHexString(hash));\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else if (hasValidContentAdditionParameterDefined(contentItemNode)) {\n            InputStream in = getInputStream(context, contentItemNode);\n            try {\n                try {\n                    hash = contentRepository.addContent(in);\n                } catch (IOException e) {\n                    throw createFailureException(e.toString());\n                }\n\n            } finally {\n                StreamUtils.safeClose(in);\n            }\n            contentItemNode.clear(); // AS7-1029\n            contentItemNode.get(HASH).set(hash);\n            // TODO: remove the content addition stuff?\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else {\n            unmanagedContentValidator.validate(contentItemNode);\n            final String path = contentItemNode.require(PATH).asString();\n            final String relativeTo = asString(contentItemNode, RELATIVE_TO);\n            final boolean archive = contentItemNode.require(ARCHIVE).asBoolean();\n            contentItem = new DeploymentHandlerUtil.ContentItem(path, relativeTo, archive);\n        }\n\n        boolean start = replaceNode.get(ENABLED).asBoolean();\n\n        final ModelNode deployNode = context.readModelForUpdate(address);\n        deployNode.get(NAME).set(name);\n        deployNode.get(RUNTIME_NAME).set(runtimeName);\n        deployNode.get(CONTENT).set(content);\n        deployNode.get(ENABLED).set(start);\n\n        // the content repo will already have these, note that content should not be empty\n        removeContentAdditions(deployNode.require(CONTENT));\n\n        if (start) {\n            DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedRuntimeName, contentItem);\n        }\n        context.completeStep();\n    }","id":34101,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n\n        final String name = operation.require(NAME).asString();\n        final PathAddress address = PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(DEPLOYMENT, name));\n\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        boolean exists = root.hasChild(PathElement.pathElement(DEPLOYMENT, name));\n        if (! exists) {\n            throw createFailureException(\"No deployment with name %s found\", name);\n        }\n\n        final ModelNode replaceNode = context.readResourceForUpdate(address).getModel();\n        final String replacedRuntimeName = replaceNode.require(RUNTIME_NAME).asString();\n        final String runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replacedRuntimeName;\n\n        final byte[] hash;\n        // clone it, so we can modify it to our own content\n        final ModelNode content = operation.require(CONTENT).clone();\n        // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n        final DeploymentHandlerUtil.ContentItem contentItem;\n        final ModelNode contentItemNode = content.require(0);\n        if (contentItemNode.hasDefined(HASH)) {\n            managedContentValidator.validate(contentItemNode);\n            hash = contentItemNode.require(HASH).asBytes();\n            if (!contentRepository.hasContent(hash))\n                throw createFailureException(\"No deployment content with hash %s is available in the deployment content repository.\", HashUtil.bytesToHexString(hash));\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else if (hasValidContentAdditionParameterDefined(contentItemNode)) {\n            InputStream in = getInputStream(context, contentItemNode);\n            try {\n                try {\n                    hash = contentRepository.addContent(in);\n                } catch (IOException e) {\n                    throw createFailureException(e.toString());\n                }\n\n            } finally {\n                StreamUtils.safeClose(in);\n            }\n            contentItemNode.clear(); // AS7-1029\n            contentItemNode.get(HASH).set(hash);\n            // TODO: remove the content addition stuff?\n            contentItem = new DeploymentHandlerUtil.ContentItem(hash);\n        } else {\n            unmanagedContentValidator.validate(contentItemNode);\n            final String path = contentItemNode.require(PATH).asString();\n            final String relativeTo = asString(contentItemNode, RELATIVE_TO);\n            final boolean archive = contentItemNode.require(ARCHIVE).asBoolean();\n            contentItem = new DeploymentHandlerUtil.ContentItem(path, relativeTo, archive);\n        }\n\n        boolean start = replaceNode.get(ENABLED).asBoolean();\n\n        final ModelNode deployNode = context.readResourceForUpdate(address).getModel();\n        deployNode.get(NAME).set(name);\n        deployNode.get(RUNTIME_NAME).set(runtimeName);\n        deployNode.get(CONTENT).set(content);\n        deployNode.get(ENABLED).set(start);\n\n        // the content repo will already have these, note that content should not be empty\n        removeContentAdditions(deployNode.require(CONTENT));\n\n        if (start) {\n            DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedRuntimeName, contentItem);\n        }\n        context.completeStep();\n    }","commit_id":"c517abff2a8b5adeb2545233ba5780d1b55bd0f4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        validator.validate(operation);\n\n        // ModelNode deployments = context.readModelForUpdate(PathAddress.EMPTY_ADDRESS).get(DEPLOYMENT);\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        String name = operation.require(NAME).asString();\n        String toReplace = operation.require(TO_REPLACE).asString();\n\n        if (name.equals(toReplace)) {\n            throw operationFailed(String.format(\"Cannot use %s with the same value for parameters %s and %s. \" +\n                    \"Use %s to redeploy the same content or %s to replace content with a new version with the same name.\",\n                    OPERATION_NAME, NAME, TO_REPLACE, DeploymentRedeployHandler.OPERATION_NAME,\n                    DeploymentFullReplaceHandler.OPERATION_NAME));\n        }\n\n        final PathElement deployPath = PathElement.pathElement(DEPLOYMENT, name);\n        final PathElement replacePath = PathElement.pathElement(DEPLOYMENT, toReplace);\n\n        if (! root.hasChild(replacePath)) {\n            throw operationFailed(String.format(\"No deployment with name %s found\", toReplace));\n        }\n        final Resource resource = context.readResource(PathAddress.pathAddress(replacePath));\n        final ModelNode replaceNode = resource.getModel();\n        final String replacedName = replaceNode.require(RUNTIME_NAME).asString();\n\n        Resource deployResource = root.getChild(deployPath);\n        if (deployResource == null) {\n            if (!operation.hasDefined(CONTENT)) {\n                throw operationFailed(String.format(\"No deployment with name %s found\", name));\n            }\n            // else -- the HostController handles a server group replace-deployment like an add, so we do too\n\n            // clone it, so we can modify it to our own content\n            final ModelNode content = operation.require(CONTENT).clone();\n            // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n            final ModelNode contentItemNode = content.require(0);\n            if (contentItemNode.hasDefined(HASH)) {\n                managedContentValidator.validate(contentItemNode);\n                byte[] hash = contentItemNode.require(HASH).asBytes();\n                if (!contentRepository.hasContent(hash))\n                    throw createFailureException(\"No deployment content with hash %s is available in the deployment content repository.\", HashUtil.bytesToHexString(hash));\n            } else {\n                unmanagedContentValidator.validate(contentItemNode);\n            }\n            final String runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replacedName;\n\n            // Create the resource\n            deployResource = context.createResource(PathAddress.pathAddress(deployPath));\n            final ModelNode deployNode = deployResource.getModel();\n            deployNode.get(RUNTIME_NAME).set(runtimeName);\n            deployNode.get(CONTENT).set(content);\n\n            final DeploymentHandlerUtil.ContentItem[] contents = getContents(deployNode.require(CONTENT));\n            DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedName, contents);\n\n        } else if (deployResource.getModel().get(ENABLED).asBoolean()) {\n            throw operationFailed(String.format(\"Deployment %s is already started\", toReplace));\n        }\n\n        replaceNode.get(ENABLED).set(false);\n        context.completeStep();\n    }","id":34102,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        validator.validate(operation);\n\n        String name = operation.require(NAME).asString();\n        String toReplace = operation.require(TO_REPLACE).asString();\n\n        if (name.equals(toReplace)) {\n            throw operationFailed(String.format(\"Cannot use %s with the same value for parameters %s and %s. \" +\n                    \"Use %s to redeploy the same content or %s to replace content with a new version with the same name.\",\n                    OPERATION_NAME, NAME, TO_REPLACE, DeploymentRedeployHandler.OPERATION_NAME,\n                    DeploymentFullReplaceHandler.OPERATION_NAME));\n        }\n\n        final PathElement deployPath = PathElement.pathElement(DEPLOYMENT, name);\n        final PathElement replacePath = PathElement.pathElement(DEPLOYMENT, toReplace);\n\n        final Resource root = context.readResource(PathAddress.EMPTY_ADDRESS);\n        if (! root.hasChild(replacePath)) {\n            throw operationFailed(String.format(\"No deployment with name %s found\", toReplace));\n        }\n\n        final ModelNode replaceNode = context.readResourceForUpdate(PathAddress.pathAddress(replacePath)).getModel();\n        final String replacedName = replaceNode.require(RUNTIME_NAME).asString();\n\n        ModelNode deployNode;\n        String runtimeName;\n        if (!root.hasChild(deployPath)) {\n            if (!operation.hasDefined(CONTENT)) {\n                throw operationFailed(String.format(\"No deployment with name %s found\", name));\n            }\n            // else -- the HostController handles a server group replace-deployment like an add, so we do too\n\n            // clone it, so we can modify it to our own content\n            final ModelNode content = operation.require(CONTENT).clone();\n            // TODO: JBAS-9020: for the moment overlays are not supported, so there is a single content item\n            final ModelNode contentItemNode = content.require(0);\n            if (contentItemNode.hasDefined(HASH)) {\n                managedContentValidator.validate(contentItemNode);\n                byte[] hash = contentItemNode.require(HASH).asBytes();\n                if (!contentRepository.hasContent(hash))\n                    throw createFailureException(\"No deployment content with hash %s is available in the deployment content repository.\", HashUtil.bytesToHexString(hash));\n            } else {\n                unmanagedContentValidator.validate(contentItemNode);\n            }\n            runtimeName = operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : replacedName;\n\n            // Create the resource\n            final Resource deployResource = context.createResource(PathAddress.pathAddress(deployPath));\n            deployNode = deployResource.getModel();\n            deployNode.get(RUNTIME_NAME).set(runtimeName);\n            deployNode.get(CONTENT).set(content);\n\n        } else {\n            deployNode = context.readResourceForUpdate(PathAddress.pathAddress(deployPath)).getModel();\n            if (deployNode.get(ENABLED).asBoolean()) {\n                throw operationFailed(String.format(\"Deployment %s is already started\", toReplace));\n            }\n            runtimeName = deployNode.require(RUNTIME_NAME).asString();\n        }\n\n        deployNode.get(ENABLED).set(true);\n        replaceNode.get(ENABLED).set(false);\n\n        final DeploymentHandlerUtil.ContentItem[] contents = getContents(deployNode.require(CONTENT));\n        DeploymentHandlerUtil.replace(context, replaceNode, runtimeName, name, replacedName, contents);\n\n        context.completeStep();\n    }","commit_id":"c517abff2a8b5adeb2545233ba5780d1b55bd0f4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathElement element = address.getLastElement();\n\n        context.addStep(new OperationStepHandler() {\n                    @Override\n                    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                        final ModelNode result = context.getResult();\n                        final ServiceController<?> controller = context.getServiceRegistry(false).getService(Services.deploymentUnitName(element.getValue()));\n                        if(controller != null) {\n                            if (controller.getSubstate() == ServiceController.Substate.WONT_START &&\n                                      controller.getState() == ServiceController.State.DOWN) {\n                                result.set(AbstractDeploymentUnitService.DeploymentStatus.STOPPED.toString());\n                            } else {\n                                result.set(((AbstractDeploymentUnitService)controller.getService()).getStatus().toString());\n                            }\n                        } else {\n                            result.set(NO_METRICS);\n                        }\n                        context.completeStep();\n                    }\n                }, OperationContext.Stage.RUNTIME);\n        context.completeStep();\n    }","id":34103,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathElement element = address.getLastElement();\n        final ModelNode deployment = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final boolean isEnabled = deployment.get(ENABLED).asBoolean();\n        context.addStep(new OperationStepHandler() {\n                    @Override\n                    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                        final ModelNode result = context.getResult();\n                        if (!isEnabled) {\n                            result.set(AbstractDeploymentUnitService.DeploymentStatus.STOPPED.toString());\n                        } else {\n                            final ServiceController<?> controller = context.getServiceRegistry(false).getService(Services.deploymentUnitName(element.getValue()));\n                            if (controller != null) {\n                                if (controller.getSubstate() == ServiceController.Substate.WONT_START &&\n                                        controller.getState() == ServiceController.State.DOWN) {\n                                    result.set(AbstractDeploymentUnitService.DeploymentStatus.STOPPED.toString());\n                                } else {\n                                    result.set(((AbstractDeploymentUnitService) controller.getService()).getStatus().toString());\n                                }\n                            } else {\n                                result.set(NO_METRICS);\n                            }\n                        }\n                        context.completeStep();\n                    }\n                }, OperationContext.Stage.RUNTIME);\n        context.completeStep();\n    }","commit_id":"d040a7c52286cce7145751a9a3e47dc27c057bca","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) {\n        ModelNode model = context.readModelForUpdate(PathAddress.EMPTY_ADDRESS);\n        final String deploymentUnitName = model.require(RUNTIME_NAME).asString();\n        model.get(ENABLED).set(false);\n\n        DeploymentHandlerUtil.undeploy(context, deploymentUnitName);\n\n        context.completeStep();\n    }","id":34104,"modified_method":"public void execute(OperationContext context, ModelNode operation) {\n        ModelNode model = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel();\n        final String deploymentUnitName = model.require(RUNTIME_NAME).asString();\n        model.get(ENABLED).set(false);\n\n        DeploymentHandlerUtil.undeploy(context, deploymentUnitName);\n\n        context.completeStep();\n    }","commit_id":"d040a7c52286cce7145751a9a3e47dc27c057bca","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n\n        performRemove(context, operation, model);\n\n        if (requiresRuntime(context)) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    performRuntime(context, operation, model\n                    );\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        recoverServices(context, operation, model);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","id":34105,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final ModelNode model = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n\n        performRemove(context, operation, model);\n\n        if (requiresRuntime(context)) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    performRuntime(context, operation, model);\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        recoverServices(context, operation, model);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(EJB3SubsystemProviders.SUBSYSTEM);\n        subsystem.registerXMLElementWriter(ejb3Subsystem11Parser);\n\n        // register the operations\n        // EJB3 subsystem ADD operation\n        subsystemRegistration.registerOperationHandler(ADD, EJB3SubsystemAdd.INSTANCE, EJB3SubsystemAdd.INSTANCE, false);\n        // describe operation for the subsystem\n        subsystemRegistration.registerOperationHandler(DESCRIBE, SubsystemDescribeHandler.INSTANCE, SubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        // default slsb pool\n        subsystemRegistration.registerReadWriteAttribute(DEFAULT_SLSB_INSTANCE_POOL, null, SetDefaultSLSBPool.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        // default MDB pool\n        subsystemRegistration.registerReadWriteAttribute(DEFAULT_MDB_INSTANCE_POOL, null, SetDefaultMDBPool.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        // default resource adapter name\n        subsystemRegistration.registerReadWriteAttribute(DEFAULT_RESOURCE_ADAPTER_NAME, null, SetDefaultResourceAdapterName.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n\n        // subsystem=ejb3/strict-max-bean-instance-pool=*\n        final ManagementResourceRegistration strictMaxPoolRegistration = subsystemRegistration.registerSubModel(\n                PathElement.pathElement(EJB3SubsystemModel.STRICT_MAX_BEAN_INSTANCE_POOL), EJB3SubsystemProviders.STRICT_MAX_BEAN_INSTANCE_POOL);\n        // register ADD and REMOVE operations for strict-max-pool\n        strictMaxPoolRegistration.registerOperationHandler(ADD, StrictMaxPoolAdd.INSTANCE, StrictMaxPoolAdd.INSTANCE, false);\n        strictMaxPoolRegistration.registerOperationHandler(REMOVE, StrictMaxPoolRemove.INSTANCE, StrictMaxPoolRemove.INSTANCE, false);\n\n\n        final ManagementResourceRegistration timerService = subsystemRegistration.registerSubModel(\n                EJB3SubsystemModel.TIMER_SERVICE_PATH, EJB3SubsystemProviders.TIMER_SERVICE);\n\n        // register ADD and REMOVE operations for timer-service\n        timerService.registerOperationHandler(ADD, TimerServiceAdd.INSTANCE, TimerServiceAdd.INSTANCE, false);\n        timerService.registerOperationHandler(REMOVE, TimerServiceRemove.INSTANCE, TimerServiceRemove.INSTANCE, false);\n\n        timerService.registerReadWriteAttribute(EJB3SubsystemModel.PATH, null,  WriteAttributeHandlers.WriteAttributeOperationHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        timerService.registerReadWriteAttribute(EJB3SubsystemModel.RELATIVE_TO, null,  WriteAttributeHandlers.WriteAttributeOperationHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        timerService.registerReadWriteAttribute(EJB3SubsystemModel.CORE_THREADS, null,  WriteAttributeHandlers.WriteAttributeOperationHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        timerService.registerReadWriteAttribute(EJB3SubsystemModel.MAX_THREADS, null,  WriteAttributeHandlers.WriteAttributeOperationHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n\n    }","id":34106,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n\n        subsystem.registerXMLElementWriter(ejb3Subsystem11Parser);\n\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(EJB3SubsystemRootResourceDefinition.INSTANCE);\n\n        // describe operation for the subsystem\n        subsystemRegistration.registerOperationHandler(DESCRIBE, SubsystemDescribeHandler.INSTANCE, SubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        // subsystem=ejb3/strict-max-bean-instance-pool=*\n        subsystemRegistration.registerSubModel(StrictMaxPoolResourceDefinition.INSTANCE);\n\n        // subsystem=ejb3/timer-service=*\n        subsystemRegistration.registerSubModel(TimerServiceResourceDefinition.INSTANCE);\n\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ModelNode parseMDB(final XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n        ModelNode mdbModelNode = new ModelNode();\n        // no attributes expected\n        requireNoAttributes(reader);\n\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemXMLElement.forName(reader.getLocalName())) {\n                case BEAN_INSTANCE_POOL_REF: {\n                    final String poolName = readStringAttributeElement(reader, EJB3SubsystemXMLAttribute.POOL_NAME.getLocalName());\n                    final ModelNode setDefaultMDBPoolOperation = this.createSetDefaultMDBPoolOperation(poolName);\n                    operations.add(setDefaultMDBPoolOperation);\n                    break;\n                }\n                case RESOURCE_ADAPTER_REF: {\n                    final String resourceAdapterName = readStringAttributeElement(reader, EJB3SubsystemXMLAttribute.RESOURCE_ADAPTER_NAME.getLocalName());\n                    final ModelNode setDefaultRANameOperation = this.createSetDefaultRAOperation(resourceAdapterName);\n                    operations.add(setDefaultRANameOperation);\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        return mdbModelNode;\n\n    }","id":34107,"modified_method":"private ModelNode parseMDB(final XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n        ModelNode mdbModelNode = new ModelNode();\n        // no attributes expected\n        requireNoAttributes(reader);\n\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemXMLElement.forName(reader.getLocalName())) {\n                case BEAN_INSTANCE_POOL_REF: {\n                    final String poolName = readStringAttributeElement(reader, EJB3SubsystemXMLAttribute.POOL_NAME.getLocalName());\n                    final ModelNode setDefaultMDBPoolOperation =\n                            this.createSetDefaultWriteAttributeOperation(EJB3SubsystemRootResourceDefinition.DEFAULT_MDB_INSTANCE_POOL,\n                                    poolName, reader.getLocation());\n                    operations.add(setDefaultMDBPoolOperation);\n                    break;\n                }\n                case RESOURCE_ADAPTER_REF: {\n                    final String resourceAdapterName = readStringAttributeElement(reader, EJB3SubsystemXMLAttribute.RESOURCE_ADAPTER_NAME.getLocalName());\n                    final ModelNode setDefaultRANameOperation =\n                            this.createSetDefaultWriteAttributeOperation(EJB3SubsystemRootResourceDefinition.DEFAULT_RESOURCE_ADAPTER_NAME,\n                                    resourceAdapterName, reader.getLocation());\n                    operations.add(setDefaultRANameOperation);\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        return mdbModelNode;\n\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseStrictMaxPool(final XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n        final int count = reader.getAttributeCount();\n        String poolName = null;\n        Integer maxPoolSize = null;\n        Long timeout = null;\n        String unit = null;\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final EJB3SubsystemXMLAttribute attribute = EJB3SubsystemXMLAttribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    poolName = value;\n                    break;\n                case MAX_POOL_SIZE:\n                    if (!isPositiveInt(value.trim())) {\n                        throw new XMLStreamException(\"Illegal value: \" + value + \" for \" + EJB3SubsystemXMLAttribute.MAX_POOL_SIZE.getLocalName(), reader.getLocation());\n                    }\n                    maxPoolSize = new Integer(value.trim());\n                    break;\n                case INSTANCE_AQUISITION_TIMEOUT:\n                    if (!isPositiveInt(value.trim())) {\n                        throw new XMLStreamException(\"Illegal value: \" + value + \" for \" + EJB3SubsystemXMLAttribute.INSTANCE_AQUISITION_TIMEOUT.getLocalName(), reader.getLocation());\n                    }\n                    timeout = new Long(value.trim());\n                    break;\n                case INSTANCE_AQUISITION_TIMEOUT_UNIT:\n                    if (!isValidTimeoutUnit(value.trim())) {\n                        throw new XMLStreamException(\"Illegal value: \" + value + \" for \" + EJB3SubsystemXMLAttribute.INSTANCE_AQUISITION_TIMEOUT_UNIT.getLocalName(), reader.getLocation());\n                    }\n                    unit = value.trim().toUpperCase(Locale.ENGLISH);\n                    break;\n\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n        if (poolName == null) {\n            throw missingRequired(reader, Collections.singleton(EJB3SubsystemXMLAttribute.NAME.getLocalName()));\n        }\n        // create and add the operation\n        operations.add(this.createAddStrictMaxBeanInstancePoolOperation(poolName, maxPoolSize, timeout, unit));\n    }","id":34108,"modified_method":"private void parseStrictMaxPool(final XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n        final int count = reader.getAttributeCount();\n        String poolName = null;\n        Integer maxPoolSize = null;\n        Long timeout = null;\n        String unit = null;\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final EJB3SubsystemXMLAttribute attribute = EJB3SubsystemXMLAttribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    poolName = value;\n                    break;\n                case MAX_POOL_SIZE:\n                     maxPoolSize = StrictMaxPoolResourceDefinition.MAX_POOL_SIZE.parse(value, reader.getLocation()).asInt();\n                    break;\n                case INSTANCE_AQUISITION_TIMEOUT:\n                    timeout = StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT.parse(value, reader.getLocation()).asLong();\n                    break;\n                case INSTANCE_AQUISITION_TIMEOUT_UNIT:\n                    unit = StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT_UNIT.parse(value, reader.getLocation()).asString();\n                    break;\n\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n        if (poolName == null) {\n            throw missingRequired(reader, Collections.singleton(EJB3SubsystemXMLAttribute.NAME.getLocalName()));\n        }\n        // create and add the operation\n        operations.add(this.createAddStrictMaxBeanInstancePoolOperation(poolName, maxPoolSize, timeout, unit));\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> operations) throws XMLStreamException {\n\n\n        final ModelNode ejb3SubsystemAddOperation = new ModelNode();\n        ejb3SubsystemAddOperation.get(OP).set(ADD);\n        ejb3SubsystemAddOperation.get(OP_ADDR).add(SUBSYSTEM, EJB3Extension.SUBSYSTEM_NAME);\n        final String liteValue = reader.getAttributeValue(null, EJB3SubsystemModel.LITE);\n        if (liteValue != null) {\n            ejb3SubsystemAddOperation.get(EJB3SubsystemModel.LITE).set(Boolean.parseBoolean(liteValue));\n        }\n        operations.add(ejb3SubsystemAddOperation);\n\n        // elements\n        final EnumSet<EJB3SubsystemXMLElement> encountered = EnumSet.noneOf(EJB3SubsystemXMLElement.class);\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemNamespace.forUri(reader.getNamespaceURI())) {\n                case EJB3_1_1: {\n                    final EJB3SubsystemXMLElement element = EJB3SubsystemXMLElement.forName(reader.getLocalName());\n                    if (!encountered.add(element)) {\n                        throw unexpectedElement(reader);\n                    }\n                    switch (element) {\n                        case MDB: {\n                            // read <mdb>\n                            this.parseMDB(reader, operations);\n                            break;\n                        }\n                        case POOLS: {\n                            // read <pools>\n                            this.parsePools(reader, operations);\n                            break;\n                        }\n                        case SESSION_BEAN: {\n                            // read <session-bean>\n                            this.parseSessionBean(reader, operations);\n                            break;\n                        }\n                        case TIMER_SERVICE: {\n                            parseTimerService(reader, operations);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","id":34109,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> operations) throws XMLStreamException {\n\n\n        final ModelNode ejb3SubsystemAddOperation = new ModelNode();\n        ejb3SubsystemAddOperation.get(OP).set(ADD);\n        ejb3SubsystemAddOperation.get(OP_ADDR).add(SUBSYSTEM, EJB3Extension.SUBSYSTEM_NAME);\n        final String liteValue = reader.getAttributeValue(null, EJB3SubsystemModel.LITE);\n        EJB3SubsystemRootResourceDefinition.LITE.parseAndSetParameter(liteValue, ejb3SubsystemAddOperation, reader.getLocation());\n\n        operations.add(ejb3SubsystemAddOperation);\n\n        // elements\n        final EnumSet<EJB3SubsystemXMLElement> encountered = EnumSet.noneOf(EJB3SubsystemXMLElement.class);\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemNamespace.forUri(reader.getNamespaceURI())) {\n                case EJB3_1_1: {\n                    final EJB3SubsystemXMLElement element = EJB3SubsystemXMLElement.forName(reader.getLocalName());\n                    if (!encountered.add(element)) {\n                        throw unexpectedElement(reader);\n                    }\n                    switch (element) {\n                        case MDB: {\n                            // read <mdb>\n                            this.parseMDB(reader, operations);\n                            break;\n                        }\n                        case POOLS: {\n                            // read <pools>\n                            this.parsePools(reader, operations);\n                            break;\n                        }\n                        case SESSION_BEAN: {\n                            // read <session-bean>\n                            this.parseSessionBean(reader, operations);\n                            break;\n                        }\n                        case TIMER_SERVICE: {\n                            parseTimerService(reader, operations);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeTimerService(final XMLExtendedStreamWriter writer, final ModelNode timerServiceModel) throws XMLStreamException {\n\n        // <thread-pool>\n        writer.writeStartElement(EJB3SubsystemXMLElement.THREAD_POOL.getLocalName());\n\n        final ModelNode coreThreads = timerServiceModel.get(CORE_THREADS);\n        if (coreThreads.isDefined()) {\n            // write the core-threads attribute\n            writer.writeAttribute(EJB3SubsystemXMLAttribute.CORE_THREADS.getLocalName(), \"\" + coreThreads.asInt());\n        }\n        final ModelNode maxThreads = timerServiceModel.get(MAX_THREADS);\n        if (maxThreads.isDefined()) {\n            // write the core-threads attribute\n            writer.writeAttribute(EJB3SubsystemXMLAttribute.MAX_THREADS.getLocalName(), \"\" + maxThreads.asInt());\n        }\n        // <\/thread-pool>\n        writer.writeEndElement();\n\n        // <data-store>\n        writer.writeStartElement(EJB3SubsystemXMLElement.DATA_STORE.getLocalName());\n        final ModelNode path = timerServiceModel.get(PATH);\n        if (path.isDefined()) {\n            // write the path attribute\n            writer.writeAttribute(EJB3SubsystemXMLAttribute.PATH.getLocalName(), path.asString());\n        }\n        final ModelNode relativeTo = timerServiceModel.get(RELATIVE_TO);\n        if (relativeTo.isDefined()) {\n            // write the relative-to attribute\n            writer.writeAttribute(EJB3SubsystemXMLAttribute.RELATIVE_TO.getLocalName(), relativeTo.asString());\n        }\n        // <\/data-store>\n        writer.writeEndElement();\n\n    }","id":34110,"modified_method":"private void writeTimerService(final XMLExtendedStreamWriter writer, final ModelNode timerServiceModel) throws XMLStreamException {\n\n        // <thread-pool>\n        if (TimerServiceResourceDefinition.CORE_THREADS.isMarshallable(timerServiceModel)\n                || TimerServiceResourceDefinition.MAX_THREADS.isMarshallable(timerServiceModel)) {\n\n            writer.writeEmptyElement(EJB3SubsystemXMLElement.THREAD_POOL.getLocalName());\n            TimerServiceResourceDefinition.CORE_THREADS.marshallAsAttribute(timerServiceModel, writer);\n            TimerServiceResourceDefinition.MAX_THREADS.marshallAsAttribute(timerServiceModel, writer);\n        }\n\n        // <data-store>\n        if (TimerServiceResourceDefinition.PATH.isMarshallable(timerServiceModel)\n                        || TimerServiceResourceDefinition.RELATIVE_TO.isMarshallable(timerServiceModel)) {\n\n            writer.writeEmptyElement(EJB3SubsystemXMLElement.DATA_STORE.getLocalName());\n            TimerServiceResourceDefinition.PATH.marshallAsAttribute(timerServiceModel, writer);\n            TimerServiceResourceDefinition.RELATIVE_TO.marshallAsAttribute(timerServiceModel, writer);\n        }\n\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseStatelessBean(final XMLExtendedStreamReader reader, final List<ModelNode> operations) throws XMLStreamException {\n        // no attributes expected\n        requireNoAttributes(reader);\n\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemXMLElement.forName(reader.getLocalName())) {\n                case BEAN_INSTANCE_POOL_REF: {\n                    final String poolName = readStringAttributeElement(reader, EJB3SubsystemXMLAttribute.POOL_NAME.getLocalName());\n                    final ModelNode setDefaultSLSBPoolOperation = this.createSetDefaultSLSBPoolOperation(poolName);\n                    operations.add(setDefaultSLSBPoolOperation);\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","id":34111,"modified_method":"private void parseStatelessBean(final XMLExtendedStreamReader reader, final List<ModelNode> operations) throws XMLStreamException {\n        // no attributes expected\n        requireNoAttributes(reader);\n\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemXMLElement.forName(reader.getLocalName())) {\n                case BEAN_INSTANCE_POOL_REF: {\n                    final String poolName = readStringAttributeElement(reader, EJB3SubsystemXMLAttribute.POOL_NAME.getLocalName());\n                    final ModelNode setDefaultSLSBPoolOperation =\n                            this.createSetDefaultWriteAttributeOperation(EJB3SubsystemRootResourceDefinition.DEFAULT_SLSB_INSTANCE_POOL,\n                                    poolName, reader.getLocation());\n                    operations.add(setDefaultSLSBPoolOperation);\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseTimerService(final XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n\n        requireNoAttributes(reader);\n\n        final ModelNode address = new ModelNode();\n        address.add(SUBSYSTEM, EJB3Extension.SUBSYSTEM_NAME);\n        address.add(SERVICE, TIMER_SERVICE);\n        final ModelNode timerServiceAdd = new ModelNode();\n        timerServiceAdd.get(OP).set(ADD);\n        timerServiceAdd.get(OP_ADDR).set(address);\n\n        Integer coreThreads = null;\n        Integer maxThreads = null;\n        String dataStorePath = null;\n        String dataStorePathRelativeTo = null;\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemXMLElement.forName(reader.getLocalName())) {\n                case THREAD_POOL: {\n                    final int count = reader.getAttributeCount();\n                    for (int i = 0; i < count; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final String value = reader.getAttributeValue(i);\n                        final EJB3SubsystemXMLAttribute attribute = EJB3SubsystemXMLAttribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                            case CORE_THREADS:\n                                if (coreThreads != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                coreThreads = Integer.valueOf(value);\n                                break;\n                            case MAX_THREADS:\n                                if (maxThreads != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                maxThreads = Integer.valueOf(value);\n                                break;\n                            default:\n                                throw unexpectedAttribute(reader, i);\n                        }\n                    }\n                    if (coreThreads != null) {\n                        timerServiceAdd.get(CORE_THREADS).set(coreThreads.intValue());\n                    }\n                    if (maxThreads != null) {\n                        timerServiceAdd.get(MAX_THREADS).set(maxThreads.intValue());\n                    }\n                    requireNoContent(reader);\n                    break;\n                }\n                case DATA_STORE: {\n                    final int count = reader.getAttributeCount();\n                    for (int i = 0; i < count; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final String value = reader.getAttributeValue(i);\n                        final EJB3SubsystemXMLAttribute attribute = EJB3SubsystemXMLAttribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                            case PATH:\n                                if (dataStorePath != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                dataStorePath = value;\n                                break;\n                            case RELATIVE_TO:\n                                if (dataStorePathRelativeTo != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                dataStorePathRelativeTo = value;\n                                break;\n                            default:\n                                throw unexpectedAttribute(reader, i);\n                        }\n                    }\n                    if (dataStorePath == null) {\n                        throw missingRequired(reader, Collections.singleton(EJB3SubsystemXMLAttribute.PATH));\n                    }\n                    timerServiceAdd.get(PATH).set(dataStorePath);\n                    if (dataStorePathRelativeTo != null) {\n                        timerServiceAdd.get(RELATIVE_TO).set(dataStorePathRelativeTo);\n                    }\n                    requireNoContent(reader);\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        operations.add(timerServiceAdd);\n    }","id":34112,"modified_method":"private void parseTimerService(final XMLExtendedStreamReader reader, List<ModelNode> operations) throws XMLStreamException {\n\n        requireNoAttributes(reader);\n\n        final ModelNode address = new ModelNode();\n        address.add(SUBSYSTEM, EJB3Extension.SUBSYSTEM_NAME);\n        address.add(SERVICE, TIMER_SERVICE);\n        final ModelNode timerServiceAdd = new ModelNode();\n        timerServiceAdd.get(OP).set(ADD);\n        timerServiceAdd.get(OP_ADDR).set(address);\n\n        Integer coreThreads = null;\n        Integer maxThreads = null;\n        String dataStorePath = null;\n        String dataStorePathRelativeTo = null;\n        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {\n            switch (EJB3SubsystemXMLElement.forName(reader.getLocalName())) {\n                case THREAD_POOL: {\n                    final int count = reader.getAttributeCount();\n                    for (int i = 0; i < count; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final Location location = reader.getLocation();\n                        final String value = reader.getAttributeValue(i);\n                        final EJB3SubsystemXMLAttribute attribute = EJB3SubsystemXMLAttribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                            case CORE_THREADS:\n                                if (coreThreads != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                TimerServiceResourceDefinition.CORE_THREADS.parseAndSetParameter(value, timerServiceAdd, location);\n                                break;\n                            case MAX_THREADS:\n                                if (maxThreads != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                TimerServiceResourceDefinition.MAX_THREADS.parseAndSetParameter(value, timerServiceAdd, location);\n                                break;\n                            default:\n                                throw unexpectedAttribute(reader, i);\n                        }\n                    }\n                    requireNoContent(reader);\n                    break;\n                }\n                case DATA_STORE: {\n                    final int count = reader.getAttributeCount();\n                    for (int i = 0; i < count; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final Location location = reader.getLocation();\n                        final String value = reader.getAttributeValue(i);\n                        final EJB3SubsystemXMLAttribute attribute = EJB3SubsystemXMLAttribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                            case PATH:\n                                if (dataStorePath != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                dataStorePath = TimerServiceResourceDefinition.PATH.parse(value, location).asString();\n                                break;\n                            case RELATIVE_TO:\n                                if (dataStorePathRelativeTo != null) {\n                                    throw unexpectedAttribute(reader, i);\n                                }\n                                dataStorePathRelativeTo = TimerServiceResourceDefinition.RELATIVE_TO.parse(value, location).asString();\n                                break;\n                            default:\n                                throw unexpectedAttribute(reader, i);\n                        }\n                    }\n                    if (dataStorePath == null) {\n                        throw missingRequired(reader, Collections.singleton(EJB3SubsystemXMLAttribute.PATH));\n                    }\n                    timerServiceAdd.get(PATH).set(dataStorePath);\n                    if (dataStorePathRelativeTo != null) {\n                        timerServiceAdd.get(RELATIVE_TO).set(dataStorePathRelativeTo);\n                    }\n                    requireNoContent(reader);\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        operations.add(timerServiceAdd);\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeStrictMaxPoolConfig(final XMLExtendedStreamWriter writer, final ModelNode strictMaxPoolModelNode) throws XMLStreamException {\n        // write the \"name\" attribute of the pool\n        final String poolName = strictMaxPoolModelNode.get(EJB3SubsystemModel.NAME).asString();\n        writer.writeAttribute(EJB3SubsystemXMLAttribute.NAME.getLocalName(), poolName);\n\n        if (strictMaxPoolModelNode.hasDefined(EJB3SubsystemModel.MAX_POOL_SIZE)) {\n            // value of max-pool-size attribute\n            final ModelNode maxPoolSize = strictMaxPoolModelNode.get(EJB3SubsystemModel.MAX_POOL_SIZE);\n            writer.writeAttribute(EJB3SubsystemXMLAttribute.MAX_POOL_SIZE.getLocalName(), maxPoolSize.asString());\n        }\n        if (strictMaxPoolModelNode.hasDefined(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT)) {\n            // value of instance-acquisition-timeout attribute\n            final ModelNode timeout = strictMaxPoolModelNode.get(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT);\n            writer.writeAttribute(EJB3SubsystemXMLAttribute.INSTANCE_AQUISITION_TIMEOUT.getLocalName(), timeout.asString());\n        }\n        if (strictMaxPoolModelNode.hasDefined(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT_UNIT)) {\n            // value of instance-acquisition-timeout-unit attribute\n            final ModelNode unit = strictMaxPoolModelNode.get(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT_UNIT);\n            writer.writeAttribute(EJB3SubsystemXMLAttribute.INSTANCE_AQUISITION_TIMEOUT_UNIT.getLocalName(), unit.asString());\n        }\n    }","id":34113,"modified_method":"private void writeStrictMaxPoolConfig(final XMLExtendedStreamWriter writer, final ModelNode strictMaxPoolModelNode) throws XMLStreamException {\n        // write the \"name\" attribute of the pool\n        final String poolName = strictMaxPoolModelNode.get(EJB3SubsystemModel.NAME).asString();\n        writer.writeAttribute(EJB3SubsystemXMLAttribute.NAME.getLocalName(), poolName);\n\n        StrictMaxPoolResourceDefinition.MAX_POOL_SIZE.marshallAsAttribute(strictMaxPoolModelNode, writer);\n        StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT.marshallAsAttribute(strictMaxPoolModelNode, writer);\n        StrictMaxPoolResourceDefinition.INSTANCE_ACQUISITION_TIMEOUT_UNIT.marshallAsAttribute(strictMaxPoolModelNode, writer);\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ModelNode createSetDefaultRAOperation(final String resourceAdapterName) {\n        // create /subsystem=ejb3:write-attribute(name=default-resource-adapter-name,value=poolName) operation\n        final ModelNode setDefaultRAName = new ModelNode();\n        setDefaultRAName.get(OP).set(WRITE_ATTRIBUTE_OPERATION);\n        // set the address for this operation\n        setDefaultRAName.get(OP_ADDR).set(this.getEJB3SubsystemAddress().toModelNode());\n        // set the params for the operation\n        setDefaultRAName.get(NAME).set(DEFAULT_RESOURCE_ADAPTER_NAME);\n        setDefaultRAName.get(VALUE).set(resourceAdapterName);\n\n        return setDefaultRAName;\n    }","id":34114,"modified_method":"private ModelNode createSetDefaultWriteAttributeOperation(final SimpleAttributeDefinition attributeDefinition,\n                                                        final String rawValue, final Location location) throws XMLStreamException {\n\n        final ModelNode parsed = attributeDefinition.parse(rawValue, location);\n        // create /subsystem=ejb3:write-attribute(name=default-mdb-instance-pool,value=poolName) operation\n        final ModelNode setDefaultSLSBPoolOperation = new ModelNode();\n        setDefaultSLSBPoolOperation.get(OP).set(WRITE_ATTRIBUTE_OPERATION);\n        // set the address for this operation\n        setDefaultSLSBPoolOperation.get(OP_ADDR).set(this.getEJB3SubsystemAddress().toModelNode());\n        // set the params for the operation\n        setDefaultSLSBPoolOperation.get(NAME).set(attributeDefinition.getName());\n        setDefaultSLSBPoolOperation.get(VALUE).set(parsed);\n\n        return setDefaultSLSBPoolOperation;\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    protected OperationContext mockOperationContext(SubsystemState stateService, final List<OperationStepHandler> addedSteps, ResultAction stepResult) {\n        ServiceRegistry serviceRegistry = Mockito.mock(ServiceRegistry.class);\n        ServiceController serviceController = Mockito.mock(ServiceController.class);\n        Mockito.when(serviceController.getValue()).thenReturn(stateService);\n        Mockito.when(serviceRegistry.getService(SubsystemState.SERVICE_NAME)).thenReturn(serviceController);\n        ModelNode result = new ModelNode();\n        OperationContext context = Mockito.mock(OperationContext.class);\n        Resource resource = Mockito.mock(Resource.class);\n        Mockito.when(resource.getModel()).thenReturn(result);\n        Mockito.when(context.getServiceRegistry(true)).thenReturn(serviceRegistry);\n        Mockito.when(context.completeStep()).thenReturn(stepResult);\n        Mockito.when(context.createResource(PathAddress.EMPTY_ADDRESS)).thenReturn(resource);\n        Mockito.when(context.getType()).thenReturn(OperationContext.Type.SERVER);\n        Mockito.doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                addedSteps.add((OperationStepHandler) invocation.getArguments()[0]);\n                return null;\n            }\n        }).when(context).addStep((OperationStepHandler) Mockito.anyObject(), Mockito.eq(OperationContext.Stage.RUNTIME));\n        return context;\n    }","id":34115,"modified_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    protected OperationContext mockOperationContext(SubsystemState stateService, final List<OperationStepHandler> addedSteps, ResultAction stepResult) {\n        ServiceRegistry serviceRegistry = Mockito.mock(ServiceRegistry.class);\n        ServiceController serviceController = Mockito.mock(ServiceController.class);\n        Mockito.when(serviceController.getValue()).thenReturn(stateService);\n        Mockito.when(serviceRegistry.getService(SubsystemState.SERVICE_NAME)).thenReturn(serviceController);\n        ModelNode result = new ModelNode();\n        OperationContext context = Mockito.mock(OperationContext.class);\n        Resource resource = Mockito.mock(Resource.class);\n        Mockito.when(resource.getModel()).thenReturn(result);\n        Mockito.when(context.getServiceRegistry(true)).thenReturn(serviceRegistry);\n        Mockito.when(context.completeStep()).thenReturn(stepResult);\n        Mockito.when(context.createResource(PathAddress.EMPTY_ADDRESS)).thenReturn(resource);\n        Mockito.when(context.readResource(PathAddress.EMPTY_ADDRESS)).thenReturn(resource);\n        Mockito.when(context.getType()).thenReturn(OperationContext.Type.SERVER);\n        Mockito.doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                addedSteps.add((OperationStepHandler) invocation.getArguments()[0]);\n                return null;\n            }\n        }).when(context).addStep((OperationStepHandler) Mockito.anyObject(), Mockito.eq(OperationContext.Stage.RUNTIME));\n        return context;\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode strictMaxPoolModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final String poolName = strictMaxPoolModel.require(EJB3SubsystemModel.NAME).asString();\n        final int maxPoolSize = strictMaxPoolModel.get(EJB3SubsystemModel.MAX_POOL_SIZE).asInt(StrictMaxPoolConfig.DEFAULT_MAX_POOL_SIZE);\n        final long timeout = strictMaxPoolModel.get(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT).asLong(StrictMaxPoolConfig.DEFAULT_TIMEOUT);\n        final String unit = strictMaxPoolModel.hasDefined(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT_UNIT)\n                ? strictMaxPoolModel.get(EJB3SubsystemModel.INSTANCE_ACQUISITION_TIMEOUT_UNIT).asString()\n                : StrictMaxPoolConfig.DEFAULT_TIMEOUT_UNIT.name();\n        // create the pool config\n        final PoolConfig strictMaxPoolConfig = new StrictMaxPoolConfig(poolName, maxPoolSize, timeout, TimeUnit.valueOf(unit));\n        // create and install the service\n        final PoolConfigService poolConfigService = new PoolConfigService(strictMaxPoolConfig);\n        final ServiceName serviceName = PoolConfigService.EJB_POOL_CONFIG_BASE_SERVICE_NAME.append(poolName);\n        final ServiceController serviceController = context.getServiceTarget().addService(serviceName, poolConfigService).install();\n        // add this to the service controllers\n        serviceControllers.add(serviceController);\n\n    }","id":34116,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode strictMaxPoolModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final ServiceController serviceController = installRuntimeService(context, strictMaxPoolModel, verificationHandler);\n        // add this to the service controllers\n        serviceControllers.add(serviceController);\n\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Populate the <code>strictMaxPoolModel<\/code> from the <code>operation<\/code>\n     *\n     * @param operation          the operation\n     * @param strictMaxPoolModel strict-max-pool ModelNode\n     * @throws OperationFailedException\n     */\n    @Override\n    protected void populateModel(ModelNode operation, ModelNode strictMaxPoolModel) throws OperationFailedException {\n        final String poolName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.ADDRESS)).getLastElement().getValue();\n        strictMaxPoolModel.get(EJB3SubsystemModel.NAME).set(poolName);\n        // max-pool-size\n\n        if (operation.hasDefined(EJB3SubsystemModel.MAX_POOL_SIZE)) {\n            int maxPoolSize = operation.get(EJB3SubsystemModel.MAX_POOL_SIZE).asInt();\n            if (maxPoolSize <= 0) {\n                throw new IllegalArgumentException(\"Invalid value: \" + maxPoolSize + \" for \" + EJB3SubsystemModel.MAX_POOL_SIZE);\n            }\n            strictMaxPoolModel.get(EJB3SubsystemModel.MAX_POOL_SIZE).set(maxPoolSize);\n        }\n\n        // instance-acquisition-timeout\n        if (operation.hasDefined(INSTANCE_ACQUISITION_TIMEOUT)) {\n            long instanceAcquisitionTimeout = operation.get(INSTANCE_ACQUISITION_TIMEOUT).asLong();\n            if (instanceAcquisitionTimeout <= 0) {\n                throw new IllegalArgumentException(\"Invalid value: \" + instanceAcquisitionTimeout + \" for \" + INSTANCE_ACQUISITION_TIMEOUT);\n            }\n            strictMaxPoolModel.get(INSTANCE_ACQUISITION_TIMEOUT).set(instanceAcquisitionTimeout);\n        }\n\n        // instance-acquisition-timeout-unit\n        if (operation.hasDefined(INSTANCE_ACQUISITION_TIMEOUT_UNIT)) {\n            String instanceAcquisitionTimeoutUnit = operation.get(INSTANCE_ACQUISITION_TIMEOUT_UNIT).asString();\n            if (!this.isValidTimeoutUnit(instanceAcquisitionTimeoutUnit)) {\n                throw new IllegalArgumentException(\"Invalid value: \" + instanceAcquisitionTimeoutUnit + \" for \" + INSTANCE_ACQUISITION_TIMEOUT_UNIT);\n            }\n            strictMaxPoolModel.get(INSTANCE_ACQUISITION_TIMEOUT_UNIT).set(instanceAcquisitionTimeoutUnit.trim().toUpperCase(Locale.ENGLISH));\n        }\n\n    }","id":34117,"modified_method":"/**\n     * Populate the <code>strictMaxPoolModel<\/code> from the <code>operation<\/code>\n     *\n     * @param operation          the operation\n     * @param strictMaxPoolModel strict-max-pool ModelNode\n     * @throws OperationFailedException\n     */\n    @Override\n    protected void populateModel(ModelNode operation, ModelNode strictMaxPoolModel) throws OperationFailedException {\n\n        final String poolName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.ADDRESS)).getLastElement().getValue();\n        strictMaxPoolModel.get(EJB3SubsystemModel.NAME).set(poolName);\n\n        for (AttributeDefinition attr : StrictMaxPoolResourceDefinition.ATTRIBUTES.values()) {\n            attr.validateAndSet(operation, strictMaxPoolModel);\n        }\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n    }","id":34118,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        if (context.isResourceServiceRestartAllowed()) {\n            removeRuntimeService(context, operation);\n        } else {\n            context.reloadRequired();\n        }\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) {\n\n        // Only take runtime action if EJB3 Lite isn't configured\n        final ModelNode rootResource = context.getRootResource().getChild(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, EJB3Extension.SUBSYSTEM_NAME)).getModel();\n        final boolean lite = rootResource.hasDefined(EJB3SubsystemModel.LITE) && rootResource.get(EJB3SubsystemModel.LITE).asBoolean();\n        if (!lite) {\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n                    logger.debug(\"Configuring timers\");\n\n                    ModelNode timerServiceModel = model;\n\n                    final ModelNode pathNode = timerServiceModel.get(PATH);\n                    final String path = pathNode.isDefined() ? pathNode.asString() : null;\n                    final ModelNode relativeToNode = timerServiceModel.get(RELATIVE_TO);\n                    final String relativeTo = relativeToNode.isDefined() ? relativeToNode.asString() : null;\n\n                    //install the ejb timer service data store path service\n                    if (path != null) {\n                        if (relativeTo != null) {\n                            RelativePathService.addService(TimerServiceFactoryService.PATH_SERVICE_NAME, path, relativeTo, context.getServiceTarget());\n                        } else {\n                            AbsolutePathService.addService(TimerServiceFactoryService.PATH_SERVICE_NAME, path, context.getServiceTarget());\n                        }\n                    }\n\n                    int coreThreadCount = timerServiceModel.get(CORE_THREADS).asInt(0);\n                    int maxThreadCount = timerServiceModel.get(MAX_THREADS).asInt(Runtime.getRuntime().availableProcessors());\n\n                    //we only add the timer service DUP's when the timer service in enabled in XML\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TIMEOUT_ANNOTATION, new TimerServiceAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_AROUNDTIMEOUT_ANNOTATION, new AroundTimeoutAnnotationParsingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TIMER_METADATA_MERGE, new TimerMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TIMER_SERVICE, new TimerServiceDeploymentProcessor(coreThreadCount, maxThreadCount, true));\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","id":34119,"modified_method":"protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model,\n                                   final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        // Only take runtime action if EJB3 Lite isn't configured\n        final ModelNode rootResource = context.getRootResource().getChild(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, EJB3Extension.SUBSYSTEM_NAME)).getModel();\n        final boolean lite = rootResource.hasDefined(EJB3SubsystemModel.LITE) && rootResource.get(EJB3SubsystemModel.LITE).asBoolean();\n        if (!lite) {\n\n            final ModelNode pathNode = TimerServiceResourceDefinition.PATH.validateResolvedOperation(model);\n            final String path = pathNode.isDefined() ? pathNode.asString() : null;\n            final ModelNode relativeToNode = TimerServiceResourceDefinition.RELATIVE_TO.validateResolvedOperation(model);\n            final String relativeTo = relativeToNode.isDefined() ? relativeToNode.asString() : null;\n\n            final int coreThreadCount = TimerServiceResourceDefinition.CORE_THREADS.validateResolvedOperation(model).asInt();\n            final int maxThreadCount = TimerServiceResourceDefinition.CORE_THREADS.validateResolvedOperation(model).asInt(Runtime.getRuntime().availableProcessors());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n                    logger.debug(\"Configuring timers\");\n\n                    ModelNode timerServiceModel = model;\n\n                    //install the ejb timer service data store path service\n                    if (path != null) {\n                        if (relativeTo != null) {\n                            RelativePathService.addService(TimerServiceFactoryService.PATH_SERVICE_NAME, path, relativeTo, context.getServiceTarget());\n                        } else {\n                            AbsolutePathService.addService(TimerServiceFactoryService.PATH_SERVICE_NAME, path, context.getServiceTarget());\n                        }\n                    }\n\n                    //we only add the timer service DUP's when the timer service in enabled in XML\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TIMEOUT_ANNOTATION, new TimerServiceAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_AROUNDTIMEOUT_ANNOTATION, new AroundTimeoutAnnotationParsingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TIMER_METADATA_MERGE, new TimerMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TIMER_SERVICE, new TimerServiceDeploymentProcessor(coreThreadCount, maxThreadCount, true));\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Populate the <code>timerService<\/code> from the <code>operation<\/code>\n     *\n     * @param operation         the operation\n     * @param timerServiceModel strict-max-pool ModelNode\n     * @throws org.jboss.as.controller.OperationFailedException\n     *\n     */\n\n    protected void populateModel(ModelNode operation, ModelNode timerServiceModel) throws OperationFailedException {\n\n        // max-pool-size\n        if (operation.hasDefined(EJB3SubsystemModel.MAX_THREADS)) {\n            int maxThreads = operation.get(EJB3SubsystemModel.MAX_THREADS).asInt();\n            if (maxThreads <= 0) {\n                throw new IllegalArgumentException(\"Invalid value: \" + maxThreads + \" for \" + EJB3SubsystemModel.MAX_THREADS);\n            }\n            timerServiceModel.get(MAX_THREADS).set(maxThreads);\n        }\n        if (operation.hasDefined(EJB3SubsystemModel.CORE_THREADS)) {\n            int coreThreads = operation.get(EJB3SubsystemModel.CORE_THREADS).asInt();\n            if (coreThreads <= 0) {\n                throw new IllegalArgumentException(\"Invalid value: \" + coreThreads + \" for \" + EJB3SubsystemModel.CORE_THREADS);\n            }\n            timerServiceModel.get(CORE_THREADS).set(coreThreads);\n        }\n\n        if (operation.hasDefined(EJB3SubsystemModel.RELATIVE_TO)) {\n            String relativeTo = operation.get(EJB3SubsystemModel.RELATIVE_TO).asString();\n            timerServiceModel.get(RELATIVE_TO).set(relativeTo);\n        }\n\n        if (operation.hasDefined(EJB3SubsystemModel.PATH)) {\n            String dataDir = operation.get(EJB3SubsystemModel.PATH).asString();\n            timerServiceModel.get(PATH).set(dataDir);\n        }\n    }","id":34120,"modified_method":"/**\n     * Populate the <code>timerService<\/code> from the <code>operation<\/code>\n     *\n     * @param operation         the operation\n     * @param timerServiceModel strict-max-pool ModelNode\n     * @throws org.jboss.as.controller.OperationFailedException\n     *\n     */\n\n    protected void populateModel(ModelNode operation, ModelNode timerServiceModel) throws OperationFailedException {\n\n        for (AttributeDefinition attr : TimerServiceResourceDefinition.ATTRIBUTES.values()) {\n            attr.validateAndSet(operation, timerServiceModel);\n        }\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n    }","id":34121,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        context.reloadRequired();\n    }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n            nameValidator.validate(operation);\n            final String name = operation.require(NAME).asString();\n            // Don't require VALUE. Let validateValue decide if it's bothered\n            // by an undefined value\n            final ModelNode value = operation.get(VALUE);\n\n            validateValue(name, value);\n\n            final ModelNode submodel = context.readModelForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ModelNode currentValue = submodel.get(name).clone();\n\n            submodel.get(name).set(value);\n\n            modelChanged(context, operation, name, value, currentValue);\n        }","id":34122,"modified_method":"@Override\n        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n            nameValidator.validate(operation);\n            final String name = operation.require(NAME).asString();\n            // Don't require VALUE. Let validateValue decide if it's bothered\n            // by an undefined value\n            final ModelNode value = operation.get(VALUE);\n\n            validateValue(name, value);\n\n            final ModelNode submodel = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel();\n            final ModelNode currentValue = submodel.get(name).clone();\n\n            submodel.get(name).set(value);\n\n            modelChanged(context, operation, name, value, currentValue);\n        }","commit_id":"668b4b8a791062d2054b23b51cdae038b7d7d6ba","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static <T> T awaitService(final BundleContext bundleContext, Class<T> type, String fspec, long timeout, TimeUnit unit) {\n\n        if (fspec != null) {\n            if (fspec.startsWith(\"(\")) {\n                fspec = \"(&(\" + Constants.OBJECTCLASS + \"=\" + type.getName() + \")\" + fspec + \")\";\n            } else {\n                fspec = \"(&(\" + Constants.OBJECTCLASS + \"=\" + type.getName() + \")(\" + fspec + \"))\";\n            }\n        } else {\n            fspec = \"(\" + Constants.OBJECTCLASS + \"=\" + type.getName() + \")\";\n        }\n\n        Filter filter;\n        try {\n            filter = FrameworkUtil.createFilter(fspec);\n        } catch (InvalidSyntaxException ex) {\n            throw new IllegalArgumentException(\"Invalid filter\", ex);\n        }\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        final AtomicReference<T> serviceRef = new AtomicReference<T>();\n        ServiceTracker<T, T> tracker = new ServiceTracker<T, T>(bundleContext, filter, null) {\n            @Override\n            public T addingService(ServiceReference<T> sref) {\n                T service = super.addingService(sref);\n                serviceRef.set(bundleContext.getService(sref));\n                latch.countDown();\n                return service;\n            }\n        };\n        tracker.open();\n        try {\n            if (!latch.await(timeout, unit)) {\n                throw new RuntimeException(\"Cannot obtain service: \" + filter);\n            }\n            return serviceRef.get();\n        } catch (InterruptedException ex) {\n            throw new IllegalStateException();\n        } finally {\n            tracker.close();\n        }\n\t}","id":34123,"modified_method":"public static <T> T awaitService(final BundleContext bundleContext, Class<T> type, String filterspec, long timeout, TimeUnit unit) {\n\n        final Filter srvfilter;\n        try {\n            srvfilter = filterspec != null ? FrameworkUtil.createFilter(filterspec) : null;\n        } catch (InvalidSyntaxException ex) {\n            throw new IllegalArgumentException(\"Invalid filter\", ex);\n        }\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        final AtomicReference<T> serviceRef = new AtomicReference<T>();\n        ServiceTracker<T, T> tracker = new ServiceTracker<T, T>(bundleContext, type, null) {\n            @Override\n            public T addingService(ServiceReference<T> sref) {\n                T service = super.addingService(sref);\n                if (srvfilter == null || srvfilter.match(sref)) {\n                    serviceRef.set(bundleContext.getService(sref));\n                    latch.countDown();\n                }\n                return service;\n            }\n        };\n        tracker.open();\n        try {\n            if (!latch.await(timeout, unit)) {\n                throw new RuntimeException(\"Cannot obtain service: \" + srvfilter);\n            }\n            return serviceRef.get();\n        } catch (InterruptedException ex) {\n            throw new IllegalStateException();\n        } finally {\n            tracker.close();\n        }\n\t}","commit_id":"2b93d335e28b8756b6a88c17b0b6ca4ce6fa6734","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void stopBundles() throws BundleException {\n        BundleUtils bundleUtils = new BundleUtils(syscontext);\n        bundleUtils.findAndStopBundle(\"io.fabric8.fabric-agent\");\n    }","id":34124,"modified_method":"private void stopBundles() throws BundleException {\n        BundleUtils bundleUtils = new BundleUtils(bundleContext);\n        bundleUtils.findAndStopBundle(\"io.fabric8.fabric-agent\");\n    }","commit_id":"2b93d335e28b8756b6a88c17b0b6ca4ce6fa6734","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void create(CreateEnsembleOptions options) {\n        assertValid();\n        try {\n            stopBundles();\n\n            DataStoreRegistrationHandler regHandler = registrationHandler.get();\n            BootstrapConfiguration bootConfig = bootstrapConfiguration.get();\n            if (options.isClean()) {\n                bootConfig = cleanInternal(bootConfig, regHandler);\n            }\n\n            BootstrapCreateHandler createHandler = new BootstrapCreateHandler(bootConfig, regHandler);\n            createHandler.bootstrapFabric(name, home, options);\n\n            startBundles(options);\n\n            createHandler.waitForContainerAlive(name, syscontext, 30000L);\n\n            if (options.isWaitForProvision() && options.isAgentEnabled()) {\n                createHandler.waitForSuccessfulDeploymentOf(name, syscontext, options.getProvisionTimeout());\n            }\n        } catch (RuntimeException rte) {\n            throw rte;\n        } catch (Exception ex) {\n            throw new FabricException(\"Unable to create zookeeper server configuration\", ex);\n        }\n    }","id":34125,"modified_method":"@Override\n    public void create(CreateEnsembleOptions options) {\n        assertValid();\n        try {\n            // Wait for bootstrap to be complete\n            ServiceLocator.awaitService(bundleContext, BootstrapComplete.class);\n\n            stopBundles();\n\n            DataStoreRegistrationHandler regHandler = registrationHandler.get();\n            BootstrapConfiguration bootConfig = bootstrapConfiguration.get();\n            BundleContext syscontext = bundleContext.getBundle(0).getBundleContext();\n            if (options.isClean()) {\n                bootConfig = cleanInternal(syscontext, bootConfig, regHandler);\n            }\n\n            BootstrapCreateHandler createHandler = new BootstrapCreateHandler(bootConfig, regHandler);\n            createHandler.bootstrapFabric(name, home, options);\n\n            startBundles(options);\n\n            createHandler.waitForContainerAlive(name, syscontext, 30000L);\n\n            if (options.isWaitForProvision() && options.isAgentEnabled()) {\n                createHandler.waitForSuccessfulDeploymentOf(name, syscontext, options.getProvisionTimeout());\n            }\n        } catch (RuntimeException rte) {\n            throw rte;\n        } catch (Exception ex) {\n            throw new FabricException(\"Unable to create zookeeper server configuration\", ex);\n        }\n    }","commit_id":"2b93d335e28b8756b6a88c17b0b6ca4ce6fa6734","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void startBundles(CreateEnsembleOptions options) throws BundleException {\n        BundleUtils bundleUtils = new BundleUtils(syscontext);\n        Bundle agentBundle = bundleUtils.findBundle(\"io.fabric8.fabric-agent\");\n        if (agentBundle != null && options.isAgentEnabled()) {\n            agentBundle.start();\n        }\n    }","id":34126,"modified_method":"private void startBundles(CreateEnsembleOptions options) throws BundleException {\n        BundleUtils bundleUtils = new BundleUtils(bundleContext);\n        Bundle agentBundle = bundleUtils.findBundle(\"io.fabric8.fabric-agent\");\n        if (agentBundle != null && options.isAgentEnabled()) {\n            agentBundle.start();\n        }\n    }","commit_id":"2b93d335e28b8756b6a88c17b0b6ca4ce6fa6734","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Activate\n    void activate(BundleContext bundleContext, Map<String, ?> configuration) throws Exception {\n        syscontext = bundleContext.getBundle(0).getBundleContext();\n        configurer.configure(configuration, this);\n        BootstrapConfiguration bootConfig = bootstrapConfiguration.get();\n        CreateEnsembleOptions options = bootConfig.getBootstrapOptions();\n        if (options.isEnsembleStart()) {\n            startBundles(options);\n        }\n        activateComponent();\n    }","id":34127,"modified_method":"@Activate\n    void activate(BundleContext bundleContext, Map<String, ?> configuration) throws Exception {\n        this.bundleContext = bundleContext;\n        this.configurer.configure(configuration, this);\n        BootstrapConfiguration bootConfig = bootstrapConfiguration.get();\n        CreateEnsembleOptions options = bootConfig.getBootstrapOptions();\n        if (options.isEnsembleStart()) {\n            startBundles(options);\n        }\n        activateComponent();\n    }","commit_id":"2b93d335e28b8756b6a88c17b0b6ca4ce6fa6734","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private BootstrapConfiguration cleanInternal(BootstrapConfiguration bootConfig, DataStoreRegistrationHandler registrationHandler) throws TimeoutException {\n        try {\n            Configuration[] configs = configAdmin.get().listConfigurations(\"(|(service.factoryPid=io.fabric8.zookeeper.server)(service.pid=io.fabric8.zookeeper))\");\n            File karafData = new File(data);\n\n            // Setup the listener for unregistration of {@link BootstrapConfiguration}\n            final CountDownLatch unregisterLatch = new CountDownLatch(1);\n            ServiceListener listener = new ServiceListener() {\n                @Override\n                public void serviceChanged(ServiceEvent event) {\n                    if (event.getType() == ServiceEvent.UNREGISTERING) {\n                        syscontext.removeServiceListener(this);\n                        unregisterLatch.countDown();\n                    }\n                }\n            };\n            syscontext.addServiceListener(listener, \"(objectClass=\" + BootstrapConfiguration.class.getName() + \")\");\n\n            // Disable the BootstrapConfiguration component\n            ComponentContext componentContext = bootConfig.getComponentContext();\n            componentContext.disableComponent(BootstrapConfiguration.COMPONENT_NAME);\n\n            if (!unregisterLatch.await(30, TimeUnit.SECONDS))\n                throw new TimeoutException(\"Timeout for unregistering BootstrapConfiguration service\");\n\n            // Do the cleanup\n            registrationHandler.removeRegistrationCallback();\n            cleanConfigurations(configs);\n            cleanZookeeperDirectory(karafData);\n            cleanGitDirectory(karafData);\n\n            // Setup the registration listener for the new {@link BootstrapConfiguration}\n            final CountDownLatch registerLatch = new CountDownLatch(1);\n            final AtomicReference<ServiceReference<?>> sref = new AtomicReference<ServiceReference<?>>();\n            listener = new ServiceListener() {\n                @Override\n                public void serviceChanged(ServiceEvent event) {\n                    if (event.getType() == ServiceEvent.REGISTERED) {\n                        syscontext.removeServiceListener(this);\n                        sref.set(event.getServiceReference());\n                        registerLatch.countDown();\n                    }\n                }\n            };\n            syscontext.addServiceListener(listener, \"(objectClass=\" + BootstrapConfiguration.class.getName() + \")\");\n\n            // Enable the {@link BootstrapConfiguration} component and await the registration of the respective service\n            componentContext.enableComponent(BootstrapConfiguration.COMPONENT_NAME);\n            if (!registerLatch.await(30, TimeUnit.SECONDS))\n                throw new TimeoutException(\"Timeout for registering BootstrapConfiguration service\");\n\n            return (BootstrapConfiguration) syscontext.getService(sref.get());\n\n        } catch (RuntimeException rte) {\n            throw rte;\n        } catch (TimeoutException toe) {\n            throw toe;\n        } catch (Exception ex) {\n            throw new FabricException(\"Unable to delete zookeeper configuration\", ex);\n        }\n    }","id":34128,"modified_method":"private BootstrapConfiguration cleanInternal(final BundleContext syscontext, BootstrapConfiguration bootConfig, DataStoreRegistrationHandler registrationHandler) throws TimeoutException {\n        try {\n            Configuration[] configs = configAdmin.get().listConfigurations(\"(|(service.factoryPid=io.fabric8.zookeeper.server)(service.pid=io.fabric8.zookeeper))\");\n            File karafData = new File(data);\n\n            // Setup the listener for unregistration of {@link BootstrapConfiguration}\n            final CountDownLatch unregisterLatch = new CountDownLatch(1);\n            ServiceListener listener = new ServiceListener() {\n                @Override\n                public void serviceChanged(ServiceEvent event) {\n                    if (event.getType() == ServiceEvent.UNREGISTERING) {\n                        syscontext.removeServiceListener(this);\n                        unregisterLatch.countDown();\n                    }\n                }\n            };\n            syscontext.addServiceListener(listener, \"(objectClass=\" + BootstrapConfiguration.class.getName() + \")\");\n\n            // Disable the BootstrapConfiguration component\n            ComponentContext componentContext = bootConfig.getComponentContext();\n            componentContext.disableComponent(BootstrapConfiguration.COMPONENT_NAME);\n\n            if (!unregisterLatch.await(30, TimeUnit.SECONDS))\n                throw new TimeoutException(\"Timeout for unregistering BootstrapConfiguration service\");\n\n            // Do the cleanup\n            registrationHandler.removeRegistrationCallback();\n            cleanConfigurations(configs);\n            cleanZookeeperDirectory(karafData);\n            cleanGitDirectory(karafData);\n\n            // Setup the registration listener for the new {@link BootstrapConfiguration}\n            final CountDownLatch registerLatch = new CountDownLatch(1);\n            final AtomicReference<ServiceReference<?>> sref = new AtomicReference<ServiceReference<?>>();\n            listener = new ServiceListener() {\n                @Override\n                public void serviceChanged(ServiceEvent event) {\n                    if (event.getType() == ServiceEvent.REGISTERED) {\n                        syscontext.removeServiceListener(this);\n                        sref.set(event.getServiceReference());\n                        registerLatch.countDown();\n                    }\n                }\n            };\n            syscontext.addServiceListener(listener, \"(objectClass=\" + BootstrapConfiguration.class.getName() + \")\");\n\n            // Enable the {@link BootstrapConfiguration} component and await the registration of the respective service\n            componentContext.enableComponent(BootstrapConfiguration.COMPONENT_NAME);\n            if (!registerLatch.await(30, TimeUnit.SECONDS))\n                throw new TimeoutException(\"Timeout for registering BootstrapConfiguration service\");\n\n            return (BootstrapConfiguration) syscontext.getService(sref.get());\n\n        } catch (RuntimeException rte) {\n            throw rte;\n        } catch (TimeoutException toe) {\n            throw toe;\n        } catch (Exception ex) {\n            throw new FabricException(\"Unable to delete zookeeper configuration\", ex);\n        }\n    }","commit_id":"2b93d335e28b8756b6a88c17b0b6ca4ce6fa6734","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public ServiceReference getServiceReference(final String clazz) {\n        ServiceReference[] serviceRefs = getServiceReferences(clazz, null);\n        if (serviceRefs != null && serviceRefs.length > 0) {\n            return serviceRefs[0];\n        } else {\n            return null;\n        }\n    }","id":34129,"modified_method":"@Override\n    public ServiceReference getServiceReference(final String clazz) {\n        try {\n            ServiceReference[] serviceRefs = getServiceReferences(clazz, null);\n            if (serviceRefs != null && serviceRefs.length > 0) {\n                return serviceRefs[0];\n            }\n        }\n        catch (InvalidSyntaxException ex) {\n            // should not happen\n        }\n        return null;\n    }","commit_id":"c178d20fd34f0111a160d6028927dab2d68a0b87","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Filter createFilter(final String s) {\n        String filter = simplifyFilter(s);\n        \n        Matcher matcher = SIMPLE_OBJECT_CLASS_FILTER.matcher(filter);\n        \n        // try to extract a single objectClass, should cover most cases\n        if ( matcher.matches() ) {\n            return new ClassNameFilter(matcher.group(1));\n        } \n        \n        // fallback to a filter that denies all\n        return new MockFilter();\n        \n    }","id":34130,"modified_method":"@Override\n    public Filter createFilter(final String s) throws InvalidSyntaxException {\n        return new FilterImpl(s);\n    }","commit_id":"c178d20fd34f0111a160d6028927dab2d68a0b87","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void addServiceListener(final ServiceListener serviceListener, final String filter) {\n        serviceListeners.put(serviceListener, filter != null ? createFilter(filter) : null );\n    }","id":34131,"modified_method":"@Override\n    public void addServiceListener(final ServiceListener serviceListener, final String filter) throws InvalidSyntaxException {\n        serviceListeners.put(serviceListener, createFilter(filter));\n    }","commit_id":"c178d20fd34f0111a160d6028927dab2d68a0b87","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void addServiceListener(final ServiceListener serviceListener) {\n        addServiceListener(serviceListener, null);\n    }","id":34132,"modified_method":"@Override\n    public void addServiceListener(final ServiceListener serviceListener) {\n        serviceListeners.put(serviceListener, null);\n    }","commit_id":"c178d20fd34f0111a160d6028927dab2d68a0b87","url":"https://github.com/apache/sling"},{"original_method":"boolean matches(final String clazz, final String filter) {\n        // ignore filter for now\n        return this.clazzes.contains(clazz);\n    }","id":34133,"modified_method":"boolean matches(final String clazz, final String filter) throws InvalidSyntaxException {\n        // ignore filter for now\n        return this.clazzes.contains(clazz)\n                && (filter == null || new FilterImpl(filter).match(properties));\n    }","commit_id":"c178d20fd34f0111a160d6028927dab2d68a0b87","url":"https://github.com/apache/sling"},{"original_method":"public FilterConsumer(TwitterEndpoint te) {\n        super(te);\n        TwitterStream twitterStream = new TwitterStreamFactory(te.getProperties().getConfiguration()).getInstance();\n        twitterStream.addListener(this);\n        FilterQuery filterQuery = createFilter(te);\n        twitterStream.filter(filterQuery);\n    }","id":34134,"modified_method":"public FilterConsumer(TwitterEndpoint te) {\n        super(te);\n        twitterStream.filter(createFilter(te));\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"public SampleConsumer(TwitterEndpoint te) {\n        super(te);\n\n        TwitterStream twitterStream = new TwitterStreamFactory(te.getProperties().getConfiguration()).getInstance();\n        twitterStream.addListener(this);\n        twitterStream.sample();\n    }","id":34135,"modified_method":"public SampleConsumer(TwitterEndpoint te) {\n        super(te);\n        twitterStream.sample();\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"public StreamingConsumer(TwitterEndpoint te) {\n        this.te = te;\n    }","id":34136,"modified_method":"public StreamingConsumer(TwitterEndpoint te) {\n        this.te = te;\n        twitterStream = te.getProperties().getTwitterStreamInstance();\n        twitterStream.addListener(this);\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void onStatus(Status status) {\n        if (clear) {\n            receivedStatuses.clear();\n            clear = false;\n        }\n        receivedStatuses.add(status);\n    }","id":34137,"modified_method":"@Override\n    public void onStatus(Status status) {\n        if (tweeterStatusListener != null) {\n            tweeterStatusListener.onStatus(status);\n        } else {\n            if (clear) {\n                receivedStatuses.clear();\n                clear = false;\n            }\n            receivedStatuses.add(status);\n        }\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"public static DefaultProducer getProducer(TwitterEndpoint te, String uri) throws IllegalArgumentException {\n        String[] uriSplit = splitUri(uri);\n\n        if (uriSplit.length > 0) {\n            switch (ConsumerType.fromUri(uriSplit[0])) {\n            case DIRECTMESSAGE:\n                if (te.getProperties().getUser() == null || te.getProperties().getUser().trim().isEmpty()) {\n                    throw new IllegalArgumentException(\"Producer type set to DIRECT MESSAGE but no recipientuser was set.\");\n                } else {\n                    return new DirectMessageProducer(te);\n                }\n            case TIMELINE:\n                if (uriSplit.length > 1) {\n                    switch (TimelineType.fromUri(uriSplit[1])) {\n                    case USER:\n                        return new UserProducer(te);\n                    default:\n                        break;\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n            \n        }\n\n        LOG.warn(\"A producer type was not provided (or an incorrect pairing was used). Defaulting to a MOCK!\");\n        throw new IllegalArgumentException(\"Cannot create any producer with uri \" + uri \n                                           + \"A producer type was not provided (or an incorrect pairing was used).\");\n    }","id":34138,"modified_method":"public static DefaultProducer getProducer(TwitterEndpoint te, String uri) throws IllegalArgumentException {\n        String[] uriSplit = splitUri(uri);\n\n        if (uriSplit.length > 0) {\n            switch (ConsumerType.fromUri(uriSplit[0])) {\n            case DIRECTMESSAGE:\n                if (te.getProperties().getUser() == null || te.getProperties().getUser().trim().isEmpty()) {\n                    throw new IllegalArgumentException(\"Producer type set to DIRECT MESSAGE but no recipient user was set.\");\n                } else {\n                    return new DirectMessageProducer(te);\n                }\n            case TIMELINE:\n                if (uriSplit.length > 1) {\n                    switch (TimelineType.fromUri(uriSplit[1])) {\n                    case USER:\n                        return new UserProducer(te);\n                    default:\n                        break;\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n            \n        }\n\n        LOG.warn(\"A producer type was not provided (or an incorrect pairing was used). Defaulting to a MOCK!\");\n        throw new IllegalArgumentException(\"Cannot create any producer with uri \" + uri \n                                           + \"A producer type was not provided (or an incorrect pairing was used).\");\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters)\n        throws Exception {\n        TwitterConfiguration properties = new TwitterConfiguration();\n        setProperties(properties, parameters);\n\n        TwitterEndpoint endpoint;\n        switch (EndpointType.fromUri(properties.getType())) {\n        case POLLING:\n            endpoint = new TwitterEndpointPolling(uri, this, properties);\n            break;\n        default:\n            endpoint = new TwitterEndpointDirect(uri, this, properties);\n            break;\n        }\n\n        return endpoint;\n    }","id":34139,"modified_method":"protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters)\n        throws Exception {\n        TwitterConfiguration properties = new TwitterConfiguration();\n        setProperties(properties, parameters);\n\n        TwitterEndpoint endpoint;\n        switch (EndpointType.fromUri(properties.getType())) {\n        case POLLING:\n            endpoint = new TwitterEndpointPolling(uri, this, properties);\n            break;\n        case EVENT:\n            endpoint = new TwitterEndpointEvent(uri, this, properties);\n            break;\n        default:\n            endpoint = new TwitterEndpointDirect(uri, this, properties);\n            break;\n        }\n        return endpoint;\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"public void checkComplete() {\n        if (consumerKey.isEmpty() || consumerSecret.isEmpty() || accessToken.isEmpty()\n            || accessTokenSecret.isEmpty()) {\n            throw new IllegalArgumentException(\"consumerKey, consumerSecret, accessToken, and accessTokenSecret must be set!\");\n        }\n    }","id":34140,"modified_method":"public void checkComplete() {\n        if (twitter == null && twitterStream == null\n                && (consumerKey.isEmpty() || consumerSecret.isEmpty() || accessToken.isEmpty() || accessTokenSecret.isEmpty())) {\n            throw new IllegalArgumentException(\"twitter or twitterStream or all of consumerKey, consumerSecret, accessToken, and accessTokenSecret must be set!\");\n        }\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() {\n        properties.checkComplete();\n        twitter = new TwitterFactory(properties.getConfiguration()).getInstance();\n    }","id":34141,"modified_method":"@Override\n    protected void doStart() {\n        twitter = properties.getTwitterInstance();\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() {\n        properties.checkComplete();\n        twitter = new TwitterFactory(properties.getConfiguration()).getInstance();\n    }","id":34142,"modified_method":"@Override\n    protected void doStart() {\n        twitter = properties.getTwitterInstance();\n    }","commit_id":"545994abd718724e5f016c810da43abc72b4c9e1","url":"https://github.com/apache/camel"},{"original_method":"private void process(File f) {\n            if (f.isFile()) {\n                f.setExecutable(true, false); // XXX JDK 6-specific\n            } else {\n                File[] kids = f.listFiles();\n                if (kids != null) {\n                    for (File kid : kids) {\n                        process(kid);\n                    }\n                }\n            }\n        }","id":34143,"modified_method":"@IgnoreJRERequirement\n        private void process(File f) {\n            if (f.isFile()) {\n                if(Functions.isMustangOrAbove())\n                    f.setExecutable(true, false);\n                else\n                    GNUCLibrary.LIBC.chmod(f.getAbsolutePath(),0755);\n            } else {\n                File[] kids = f.listFiles();\n                if (kids != null) {\n                    for (File kid : kids) {\n                        process(kid);\n                    }\n                }\n            }\n        }","commit_id":"7da580e86ea89308603754d517ce0e2b95ee96ca","url":"https://github.com/kohsuke/hudson"},{"original_method":"public Void invoke(File d, VirtualChannel channel) throws IOException {\n            process(d);\n            return null;\n        }","id":34144,"modified_method":"public Void invoke(File d, VirtualChannel channel) throws IOException {\n            if(!Hudson.isWindows())\n                process(d);\n            return null;\n        }","commit_id":"7da580e86ea89308603754d517ce0e2b95ee96ca","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public void preOnline(Computer c, Channel channel,FilePath root,  TaskListener listener) throws IOException, InterruptedException {\n        PrintStream logger = listener.getLogger();\n        copyJar(logger, root, Main.class, \"maven-agent\");\n        copyJar(logger, root, PluginManagerInterceptor.class, \"maven-interceptor\");\n        copyJar(logger, root, Maven21Interceptor.class, \"maven2.1-interceptor.jar\");\n    }","id":34145,"modified_method":"@Override\n    public void preOnline(Computer c, Channel channel,FilePath root,  TaskListener listener) throws IOException, InterruptedException {\n        PrintStream logger = listener.getLogger();\n        copyJar(logger, root, Main.class, \"maven-agent\");\n        copyJar(logger, root, PluginManagerInterceptor.class, \"maven-interceptor\");\n        copyJar(logger, root, Maven21Interceptor.class, \"maven2.1-interceptor\");\n    }","commit_id":"84d466ff5dbb37dcfbdf3b22a4dfc5fe1a1670d2","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Creates a fresh {@link MavenEmbedder} instance.\n     *\n     * @param listener\n     *      This is where the log messages from Maven will be recorded.\n     * @param mavenHome\n     *      Directory of the Maven installation. We read {@code conf/settings.xml}\n     *      from here. Can be null.\n     * @param profiles\n     *      Profiles to activate/deactivate. Can be null.\n     * @param systemProperties\n     *      The system properties that the embedded Maven sees. See {@link MavenEmbedder#setSystemProperties(Properties)}.\n     */\n    public static MavenEmbedder createEmbedder(TaskListener listener, File mavenHome, String profiles, Properties systemProperties) throws MavenEmbedderException, IOException {\n        MavenEmbedder maven = new MavenEmbedder(mavenHome);\n\n        ClassLoader cl = MavenUtil.class.getClassLoader();\n        maven.setClassLoader(new MaskingClassLoader(cl));\n        EmbedderLoggerImpl logger = new EmbedderLoggerImpl(listener);\n        if(debugMavenEmbedder)  logger.setThreshold(MavenEmbedderLogger.LEVEL_DEBUG);\n        maven.setLogger(logger);\n\n        // make sure ~/.m2 exists to avoid http://www.nabble.com/BUG-Report-tf3401736.html\n        File m2Home = new File(MavenEmbedder.userHome, \".m2\");\n        m2Home.mkdirs();\n        if(!m2Home.exists())\n            throw new AbortException(\"Failed to create \"+m2Home+\n                \"\\nSee https://hudson.dev.java.net/cannot-create-.m2.html\");\n\n        maven.setProfiles(profiles);\n        maven.setSystemProperties(systemProperties);\n        maven.start();\n\n        return maven;\n    }","id":34146,"modified_method":"/**\n     * Creates a fresh {@link MavenEmbedder} instance.\n     *\n     * @param listener\n     *      This is where the log messages from Maven will be recorded.\n     * @param mavenHome\n     *      Directory of the Maven installation. We read {@code conf/settings.xml}\n     *      from here. Can be null.\n     * @param profiles\n     *      Profiles to activate/deactivate. Can be null.\n     * @param systemProperties\n     *      The system properties that the embedded Maven sees. See {@link MavenEmbedder#setSystemProperties(Properties)}.\n     */\n    public static MavenEmbedder createEmbedder(TaskListener listener, File mavenHome, String profiles, Properties systemProperties) throws MavenEmbedderException, IOException {\n        MavenEmbedder maven = new MavenEmbedder(mavenHome);\n\n        ClassLoader cl = MavenUtil.class.getClassLoader();\n        maven.setClassLoader(new MaskingClassLoader(cl));\n        EmbedderLoggerImpl logger = new EmbedderLoggerImpl(listener);\n        if(debugMavenEmbedder)  logger.setThreshold(MavenEmbedderLogger.LEVEL_DEBUG);\n        maven.setLogger(logger);\n\n        {\n            Enumeration<URL> e = cl.getResources(\"META-INF/plexus/components.xml\");\n            while (e.hasMoreElements()) {\n                URL url = e.nextElement();\n                LOGGER.fine(\"components.xml from \"+url);\n            }\n        }\n        // make sure ~/.m2 exists to avoid http://www.nabble.com/BUG-Report-tf3401736.html\n        File m2Home = new File(MavenEmbedder.userHome, \".m2\");\n        m2Home.mkdirs();\n        if(!m2Home.exists())\n            throw new AbortException(\"Failed to create \"+m2Home+\n                \"\\nSee https://hudson.dev.java.net/cannot-create-.m2.html\");\n\n        maven.setProfiles(profiles);\n        maven.setSystemProperties(systemProperties);\n        maven.start();\n\n        return maven;\n    }","commit_id":"84d466ff5dbb37dcfbdf3b22a4dfc5fe1a1670d2","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * @deprecated\n     *      Use {@link MavenInstallation#createEmbedder(BuildListener, String, Properties)} \n     *      or other overloaded versions that infers maven home.\n     */\n    public static MavenEmbedder createEmbedder(TaskListener listener, String profiles) throws MavenEmbedderException, IOException {\n        return createEmbedder(listener,(File)null,profiles);\n    }","id":34147,"modified_method":"/**\n     * @deprecated\n     *      Use {@link #createEmbedder(TaskListener, File, String, Properties)}  \n     *      or other overloaded versions that infers maven home.\n     */\n    public static MavenEmbedder createEmbedder(TaskListener listener, String profiles) throws MavenEmbedderException, IOException {\n        return createEmbedder(listener,(File)null,profiles);\n    }","commit_id":"84d466ff5dbb37dcfbdf3b22a4dfc5fe1a1670d2","url":"https://github.com/kohsuke/hudson"},{"original_method":"public Enumeration<URL> getResources(String name) throws IOException {\n            final Enumeration<URL> e = super.getResources(name);\n            return new Enumeration<URL>() {\n                URL next;\n\n                public boolean hasMoreElements() {\n                    fetch();\n                    return next!=null;\n                }\n\n                public URL nextElement() {\n                    fetch();\n                    URL r = next;\n                    next = null;\n                    return r;\n                }\n\n                private void fetch() {\n                    while(next==null && e.hasMoreElements()) {\n                        next = e.nextElement();\n                        if(next.toExternalForm().contains(\"maven-plugin-tools-api\"))\n                            next = null;\n                    }\n                }\n            };\n        }","id":34148,"modified_method":"public Enumeration<URL> getResources(String name) throws IOException {\n            final Enumeration<URL> e = super.getResources(name);\n            return new Enumeration<URL>() {\n                URL next;\n\n                public boolean hasMoreElements() {\n                    fetch();\n                    return next!=null;\n                }\n\n                public URL nextElement() {\n                    fetch();\n                    URL r = next;\n                    next = null;\n                    return r;\n                }\n\n                private void fetch() {\n                    while(next==null && e.hasMoreElements()) {\n                        next = e.nextElement();\n                        if(shouldBeIgnored(next))\n                            next = null;\n                    }\n                }\n\n                private boolean shouldBeIgnored(URL url) {\n                    String s = url.toExternalForm();\n                    if(s.contains(\"maven-plugin-tools-api\"))\n                        return true;\n                    if(s.endsWith(\"plexus/components.xml\")) {\n                        try {\n                            // is this designated for interception purpose? If so, don't load them in the MavenEmbedder\n                            IOUtils.closeQuietly(new URL(s + \".interception\").openStream());\n                            return true;\n                        } catch (IOException _) {\n                            // no such resource exists\n                        }\n                    }\n                    return false;\n                }\n            };\n        }","commit_id":"84d466ff5dbb37dcfbdf3b22a4dfc5fe1a1670d2","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void process(File f) {\n            if (f.isFile()) {\n                f.setExecutable(true, false); // XXX JDK 6-specific, use FilePath.chmod instead\n            } else {\n                File[] kids = f.listFiles();\n                if (kids != null) {\n                    for (File kid : kids) {\n                        process(kid);\n                    }\n                }\n            }\n        }","id":34149,"modified_method":"@IgnoreJRERequirement\n        private void process(File f) {\n            if (f.isFile()) {\n                if(Functions.isMustangOrAbove())\n                    f.setExecutable(true, false);\n                else\n                    GNUCLibrary.LIBC.chmod(f.getAbsolutePath(),0755);\n            } else {\n                File[] kids = f.listFiles();\n                if (kids != null) {\n                    for (File kid : kids) {\n                        process(kid);\n                    }\n                }\n            }\n        }","commit_id":"84d466ff5dbb37dcfbdf3b22a4dfc5fe1a1670d2","url":"https://github.com/kohsuke/hudson"},{"original_method":"public Void invoke(File d, VirtualChannel channel) throws IOException {\n            process(d);\n            return null;\n        }","id":34150,"modified_method":"public Void invoke(File d, VirtualChannel channel) throws IOException {\n            if(!Hudson.isWindows())\n                process(d);\n            return null;\n        }","commit_id":"84d466ff5dbb37dcfbdf3b22a4dfc5fe1a1670d2","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n   * Tests the {@link FileUtils#getLocalFileMode(String)}} method.\n   */\n  @Test\n  public void getLocalFileModeTest() throws IOException {\n    File tmpDir = mTestFolder.newFolder(\"dir\");\n    File tmpFile777 = mTestFolder.newFile(\"dir/0777\");\n    tmpFile777.setReadable(true, false /* owner only */);\n    tmpFile777.setWritable(true, false /* owner only */);\n    tmpFile777.setExecutable(true, false /* owner only */);\n\n    File tmpFile755 = mTestFolder.newFile(\"dir/0755\");\n    tmpFile755.setReadable(true, false /* owner only */);\n    tmpFile755.setWritable(true, true /* owner only */);\n    tmpFile755.setExecutable(true, false /* owner only */);\n\n    File tmpFile444 = mTestFolder.newFile(\"dir/0444\");\n    tmpFile444.setReadOnly();\n\n    Assert.assertEquals((short) 0777, FileUtils.getLocalFileMode(tmpFile777.getPath()));\n    Assert.assertEquals((short) 0755, FileUtils.getLocalFileMode(tmpFile755.getPath()));\n    Assert.assertEquals((short) 0444, FileUtils.getLocalFileMode(tmpFile444.getPath()));\n\n    // Delete all of these.\n    FileUtils.deletePathRecursively(tmpDir.getAbsolutePath());\n  }","id":34151,"modified_method":"/**\n   * Tests the {@link FileUtils#getLocalFileMode(String)}} method.\n   */\n  @Test\n  public void getLocalFileModeTest() throws IOException {\n    File tmpDir = mTestFolder.newFolder(\"dir\");\n    File tmpFile777 = mTestFolder.newFile(\"dir/0777\");\n    tmpFile777.setReadable(true, false /* owner only */);\n    tmpFile777.setWritable(true, false /* owner only */);\n    tmpFile777.setExecutable(true, false /* owner only */);\n\n    File tmpFile755 = mTestFolder.newFile(\"dir/0755\");\n    tmpFile755.setReadable(true, false /* owner only */);\n    tmpFile755.setWritable(false, false /* owner only */);\n    tmpFile755.setExecutable(true, false /* owner only */);\n    tmpFile755.setWritable(true, true /* owner only */);\n\n    File tmpFile444 = mTestFolder.newFile(\"dir/0444\");\n    tmpFile444.setReadOnly();\n\n    Assert.assertEquals((short) 0777, FileUtils.getLocalFileMode(tmpFile777.getPath()));\n    Assert.assertEquals((short) 0755, FileUtils.getLocalFileMode(tmpFile755.getPath()));\n    Assert.assertEquals((short) 0444, FileUtils.getLocalFileMode(tmpFile444.getPath()));\n\n    // Delete all of these.\n    FileUtils.deletePathRecursively(tmpDir.getAbsolutePath());\n  }","commit_id":"408b45db7a30455ec5a773ba20140a086d3d9ed3","url":"https://github.com/amplab/tachyon"},{"original_method":"GpgSigner newSigner( MavenProject project )\n        throws MojoExecutionException, MojoFailureException\n    {\n        GpgSigner signer = new GpgSigner();\n\n        signer.setInteractive( interactive );\n        signer.setKeyName( keyname );\n        signer.setUseAgent( useAgent );\n        signer.setHomeDirectory( homedir );\n\n        signer.setPassPhrase( passphrase );\n        if ( null == passphrase && !useAgent )\n        {\n            if ( !interactive )\n            {\n                throw new MojoFailureException( \"Cannot obtain passphrase in batch mode\" );\n            }\n            try\n            {\n                signer.setPassPhrase( signer.getPassphrase( project ) );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Exception reading passphrase\", e );\n            }\n        }\n\n        return signer;\n    }","id":34152,"modified_method":"GpgSigner newSigner( MavenProject project )\n        throws MojoExecutionException, MojoFailureException\n    {\n        GpgSigner signer = new GpgSigner();\n\n        signer.setExecutable( executable );\n        signer.setInteractive( interactive );\n        signer.setKeyName( keyname );\n        signer.setUseAgent( useAgent );\n        signer.setHomeDirectory( homedir );\n\n        signer.setPassPhrase( passphrase );\n        if ( null == passphrase && !useAgent )\n        {\n            if ( !interactive )\n            {\n                throw new MojoFailureException( \"Cannot obtain passphrase in batch mode\" );\n            }\n            try\n            {\n                signer.setPassPhrase( signer.getPassphrase( project ) );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Exception reading passphrase\", e );\n            }\n        }\n\n        return signer;\n    }","commit_id":"e390094587c1607b1c960480505c6456e90c28f7","url":"https://github.com/apache/maven-plugins"},{"original_method":"public File generateSignatureForArtifact( File file )\n        throws MojoExecutionException\n    {\n        File signature = new File( file + SIGNATURE_EXTENSION );\n\n        boolean isInBuildDir = false;\n        if ( buildDir != null )\n        {\n            File parent = signature.getParentFile();\n            if ( buildDir.equals( parent ) )\n            {\n                isInBuildDir = true;\n            }\n        }\n        if ( !isInBuildDir && outputDir != null )\n        {\n            String fileDirectory = \"\";\n            File signatureDirectory = signature;\n\n            while ( ( signatureDirectory = signatureDirectory.getParentFile() ) != null )\n            {\n                if ( !signatureDirectory.equals( baseDir ) )\n                {\n                    fileDirectory = signatureDirectory.getName() + File.separatorChar + fileDirectory;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            signatureDirectory = new File( outputDir, fileDirectory );\n            if ( !signatureDirectory.exists() )\n            {\n                signatureDirectory.mkdirs();\n            }\n            signature = new File( signatureDirectory, file.getName() + SIGNATURE_EXTENSION );\n        }\n\n        if ( signature.exists() )\n        {\n            signature.delete();\n        }\n\n        Commandline cmd = new Commandline();\n\n        cmd.setExecutable( \"gpg\" + ( Os.isFamily( Os.FAMILY_WINDOWS ) ? \".exe\" : \"\" ) );\n\n        if ( homeDir != null )\n        {\n            cmd.createArg().setValue( \"--homedir\" );\n            cmd.createArg().setFile( homeDir );\n        }\n\n        if ( useAgent )\n        {\n            cmd.createArg().setValue( \"--use-agent\" );\n        }\n        else\n        {\n            cmd.createArg().setValue( \"--no-use-agent\" );\n        }\n\n        InputStream in = null;\n        if ( null != passphrase )\n        {\n            // make --passphrase-fd effective in gpg2\n            cmd.createArg().setValue( \"--batch\" );\n\n            cmd.createArg().setValue( \"--passphrase-fd\" );\n\n            cmd.createArg().setValue( \"0\" );\n\n            // Prepare the input stream which will be used to pass the passphrase to the executable\n            in = new ByteArrayInputStream( passphrase.getBytes() );\n        }\n\n        if ( null != keyname )\n        {\n            cmd.createArg().setValue( \"--local-user\" );\n\n            cmd.createArg().setValue( keyname );\n        }\n\n        cmd.createArg().setValue( \"--armor\" );\n\n        cmd.createArg().setValue( \"--detach-sign\" );\n\n        if ( !isInteractive )\n        {\n            cmd.createArg().setValue( \"--no-tty\" );\n        }\n\n        cmd.createArg().setValue( \"--output\" );\n        cmd.createArg().setFile( signature );\n\n        cmd.createArg().setFile( file );\n\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, in, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MojoExecutionException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Unable to execute gpg command\", e );\n        }\n\n        return signature;\n    }","id":34153,"modified_method":"public File generateSignatureForArtifact( File file )\n        throws MojoExecutionException\n    {\n        File signature = new File( file + SIGNATURE_EXTENSION );\n\n        boolean isInBuildDir = false;\n        if ( buildDir != null )\n        {\n            File parent = signature.getParentFile();\n            if ( buildDir.equals( parent ) )\n            {\n                isInBuildDir = true;\n            }\n        }\n        if ( !isInBuildDir && outputDir != null )\n        {\n            String fileDirectory = \"\";\n            File signatureDirectory = signature;\n\n            while ( ( signatureDirectory = signatureDirectory.getParentFile() ) != null )\n            {\n                if ( !signatureDirectory.equals( baseDir ) )\n                {\n                    fileDirectory = signatureDirectory.getName() + File.separatorChar + fileDirectory;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            signatureDirectory = new File( outputDir, fileDirectory );\n            if ( !signatureDirectory.exists() )\n            {\n                signatureDirectory.mkdirs();\n            }\n            signature = new File( signatureDirectory, file.getName() + SIGNATURE_EXTENSION );\n        }\n\n        if ( signature.exists() )\n        {\n            signature.delete();\n        }\n\n        Commandline cmd = new Commandline();\n\n        if ( StringUtils.isNotEmpty( executable ) )\n        {\n            cmd.setExecutable( executable );\n        }\n        else\n        {\n            cmd.setExecutable( \"gpg\" + ( Os.isFamily( Os.FAMILY_WINDOWS ) ? \".exe\" : \"\" ) );\n        }\n\n        if ( homeDir != null )\n        {\n            cmd.createArg().setValue( \"--homedir\" );\n            cmd.createArg().setFile( homeDir );\n        }\n\n        if ( useAgent )\n        {\n            cmd.createArg().setValue( \"--use-agent\" );\n        }\n        else\n        {\n            cmd.createArg().setValue( \"--no-use-agent\" );\n        }\n\n        InputStream in = null;\n        if ( null != passphrase )\n        {\n            // make --passphrase-fd effective in gpg2\n            cmd.createArg().setValue( \"--batch\" );\n\n            cmd.createArg().setValue( \"--passphrase-fd\" );\n\n            cmd.createArg().setValue( \"0\" );\n\n            // Prepare the input stream which will be used to pass the passphrase to the executable\n            in = new ByteArrayInputStream( passphrase.getBytes() );\n        }\n\n        if ( null != keyname )\n        {\n            cmd.createArg().setValue( \"--local-user\" );\n\n            cmd.createArg().setValue( keyname );\n        }\n\n        cmd.createArg().setValue( \"--armor\" );\n\n        cmd.createArg().setValue( \"--detach-sign\" );\n\n        if ( !isInteractive )\n        {\n            cmd.createArg().setValue( \"--no-tty\" );\n        }\n\n        cmd.createArg().setValue( \"--output\" );\n        cmd.createArg().setFile( signature );\n\n        cmd.createArg().setFile( file );\n\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, in, new DefaultConsumer(), new DefaultConsumer() );\n\n            if ( exitCode != 0 )\n            {\n                throw new MojoExecutionException( \"Exit code: \" + exitCode );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Unable to execute gpg command\", e );\n        }\n\n        return signature;\n    }","commit_id":"e390094587c1607b1c960480505c6456e90c28f7","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param locale\n     * @throws MavenReportException\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet\", e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( quotedArgument( this.locale ) );\n            options.append( \" \" );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n\n        // Set the proxy host and port\n        if ( StringUtils.isNotEmpty( proxyHost ) && proxyPort > 0 )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyHost=\" + proxyHost );\n            cmd.createArgument().setValue( \"-J-DproxyPort=\" + proxyPort );\n        }\n\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        cmd.setExecutable( getJavadocPath() );\n\n        // General javadoc arguments\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n\n        if ( old && SystemUtils.isJavaVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        addArgIfNotEmpty( arguments, \"-overview\", quotedPathArgument( overview ) );\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( getBottomText( project.getInceptionYear() ) ) );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n            if ( groups!= null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", quotedArgument( groupTitle ) + \" \"\n                            + quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n                addLinkofflineArguments( arguments );\n                addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            }\n            else\n            {\n                addLinkofflineArguments( arguments );\n            }\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", packagesheader, SINCE_JAVADOC_1_4_2 );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\", quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglets[i].getTagletClass() ), SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( ( tags[i] == null ) || ( StringUtils.isEmpty( tags[i].getName() ) )\n                        || ( StringUtils.isEmpty( tags[i].getPlacement() ) ) )\n                    {\n                        getLog().info( \"A tag option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName() + \":\" + tags[i].getPlacement();\n                        if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                        {\n                            value += \":\" + quotedArgument( tags[i].getHead() );\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command\", e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","id":34154,"modified_method":"/**\n     * @param locale\n     * @throws MavenReportException\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( quotedArgument( this.locale ) );\n            options.append( \" \" );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n\n        // Set the proxy host and port\n        if ( StringUtils.isNotEmpty( proxyHost ) && proxyPort > 0 )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyHost=\" + proxyHost );\n            cmd.createArgument().setValue( \"-J-DproxyPort=\" + proxyPort );\n        }\n\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        try\n        {\n            cmd.setExecutable( getJavadocPath() );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc command: \" + e.getMessage(), e );\n        }\n\n        // General javadoc arguments\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n\n        if ( old && SystemUtils.isJavaVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        addArgIfNotEmpty( arguments, \"-overview\", quotedPathArgument( overview ) );\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( getBottomText( project.getInceptionYear() ) ) );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n            if ( groups != null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", quotedArgument( groupTitle ) + \" \"\n                            + quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n                addLinkofflineArguments( arguments );\n                addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            }\n            else\n            {\n                addLinkofflineArguments( arguments );\n            }\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", packagesheader, SINCE_JAVADOC_1_4_2 );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                              quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglets[i].getTagletClass() ),\n                                          SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( ( tags[i] == null ) || ( StringUtils.isEmpty( tags[i].getName() ) )\n                        || ( StringUtils.isEmpty( tags[i].getPlacement() ) ) )\n                    {\n                        getLog().info( \"A tag option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName() + \":\" + tags[i].getPlacement();\n                        if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                        {\n                            value += \":\" + quotedArgument( tags[i].getHead() );\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + Commandline.toString( cmd.getCommandline() ) );\n                throw new MavenReportException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Get the path of Javadoc tool depending the OS.\n     *\n     * @return the path of the Javadoc tool\n     */\n    private String getJavadocPath()\n    {\n        String javadocCommand = \"javadoc\" + ( SystemUtils.IS_OS_WINDOWS ? \".exe\" : \"\" );\n\n        File javadocExe;\n\n        // For IBM's JDK 1.2\n        if ( SystemUtils.IS_OS_AIX )\n        {\n            javadocExe = new File( SystemUtils.getJavaHome() + \"/../sh\", javadocCommand );\n        }\n        else if ( SystemUtils.IS_OS_MAC_OSX )\n        {\n            javadocExe = new File( SystemUtils.getJavaHome() + \"/bin\", javadocCommand );\n        }\n        else\n        {\n            javadocExe = new File( SystemUtils.getJavaHome() + \"/../bin\", javadocCommand );\n        }\n\n        getLog().debug( \"Javadoc executable=[\" + javadocExe.getAbsolutePath() + \"]\" );\n\n        return javadocExe.getAbsolutePath();\n    }","id":34155,"modified_method":"/**\n     * Get the path of Javadoc tool depending the OS, the <code>java.home<\/code> system property and the\n     * <code>JAVA_HOME<\/code> environment variable\n     *\n     * @return the path of the Javadoc tool\n     * @throws IOException if not found\n     */\n    private String getJavadocPath()\n        throws IOException\n    {\n        String javadocCommand = \"javadoc\" + ( SystemUtils.IS_OS_WINDOWS ? \".exe\" : \"\" );\n\n        File javadocExe;\n\n        // ----------------------------------------------------------------------\n        // Try to find javadocExe from System.getProperty( \"java.home\" )\n        // By default, System.getProperty( \"java.home\" ) = JRE_HOME and JRE_HOME\n        // should be in the JDK_HOME\n        // ----------------------------------------------------------------------\n\n        // For IBM's JDK 1.2\n        if ( SystemUtils.IS_OS_AIX )\n        {\n            javadocExe = new File( SystemUtils.getJavaHome() + File.separator + \"..\" + File.separator + \"sh\",\n                                   javadocCommand );\n        }\n        else if ( SystemUtils.IS_OS_MAC_OSX )\n        {\n            javadocExe = new File( SystemUtils.getJavaHome() + File.separator + \"bin\", javadocCommand );\n        }\n        else\n        {\n            javadocExe = new File( SystemUtils.getJavaHome() + File.separator + \"..\" + File.separator + \"bin\",\n                                   javadocCommand );\n        }\n\n        // ----------------------------------------------------------------------\n        // Try to find javadocExe from JAVA_HOME environment variable\n        // ----------------------------------------------------------------------\n\n        if ( !javadocExe.exists() || !javadocExe.isFile() )\n        {\n            Properties env = CommandLineUtils.getSystemEnvVars();\n            String javaHome = env.getProperty( \"JAVA_HOME\" );\n            if ( StringUtils.isEmpty( javaHome ) )\n            {\n                throw new IOException( \"The environment variable JAVA_HOME is not correctly set.\" );\n            }\n            if ( ( !new File( javaHome ).exists() ) || ( !new File( javaHome ).isDirectory() ) )\n            {\n                throw new IOException( \"The environment variable JAVA_HOME=\" + javaHome + \" doesn't exist or is \"\n                    + \"not a valid directory.\" );\n            }\n\n            javadocExe = new File( env.getProperty( \"JAVA_HOME\" ) + File.separator + \"bin\", javadocCommand );\n        }\n\n        if ( !javadocExe.exists() || !javadocExe.isFile() )\n        {\n            throw new IOException( \"The javadoc executable '\" + javadocExe + \"' doesn't exist or is not a file. \"\n                + \"Verify the JAVA_HOME environment variable.\" );\n        }\n\n        return javadocExe.getAbsolutePath();\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method to get the source paths. If no source path is specified in the parameter, the compile source roots\n     * of the project will be used.\n     *\n     * @return a List of the project source paths\n     */\n    protected List getSourcePaths()\n    {\n        List sourcePaths;\n        if ( StringUtils.isEmpty( sourcepath ) )\n        {\n            sourcePaths = new ArrayList( project.getCompileSourceRoots() );\n\n            if ( project.getExecutionProject() != null )\n            {\n                sourcePaths.addAll( project.getExecutionProject().getCompileSourceRoots() );\n            }\n\n            if ( javadocDirectory != null )\n            {\n                File javadocDir = new File( javadocDirectory );\n                if ( !javadocDir.exists() || !javadocDir.isDirectory() )\n                {\n                    getLog().warn( \"The file '\" + javadocDirectory + \"' doesn't exists or it is not a directory.\" );\n                }\n                else\n                {\n                    sourcePaths.add( javadocDirectory );\n                }\n            }\n\n            if ( aggregate && project.isExecutionRoot() )\n            {\n                for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) i.next();\n\n                    List sourceRoots = project.getCompileSourceRoots();\n                    ArtifactHandler artifactHandler = project.getArtifact().getArtifactHandler();\n                    if ( \"java\".equals( artifactHandler.getLanguage() ) )\n                    {\n                        sourcePaths.addAll( sourceRoots );\n                    }\n                }\n            }\n\n            sourcePaths = pruneSourceDirs( sourcePaths );\n        }\n        else\n        {\n            sourcePaths = Arrays.asList( sourcepath.split( \"[;]\" ) );\n        }\n        return sourcePaths;\n    }","id":34156,"modified_method":"/**\n     * Method to get the source paths. If no source path is specified in the parameter, the compile source roots\n     * of the project will be used.\n     *\n     * @return a List of the project source paths\n     */\n    protected List getSourcePaths()\n    {\n        List sourcePaths;\n        if ( StringUtils.isEmpty( sourcepath ) )\n        {\n            sourcePaths = new ArrayList( project.getCompileSourceRoots() );\n\n            if ( project.getExecutionProject() != null )\n            {\n                sourcePaths.addAll( project.getExecutionProject().getCompileSourceRoots() );\n            }\n\n            if ( javadocDirectory != null )\n            {\n                File javadocDir = new File( javadocDirectory );\n                if ( javadocDir.exists() && javadocDir.isDirectory() )\n                {\n                    sourcePaths.add( javadocDirectory );\n                }\n            }\n\n            if ( aggregate && project.isExecutionRoot() )\n            {\n                for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) i.next();\n\n                    List sourceRoots = project.getCompileSourceRoots();\n                    ArtifactHandler artifactHandler = project.getArtifact().getArtifactHandler();\n                    if ( \"java\".equals( artifactHandler.getLanguage() ) )\n                    {\n                        sourcePaths.addAll( sourceRoots );\n                    }\n                }\n            }\n\n            sourcePaths = pruneSourceDirs( sourcePaths );\n        }\n        else\n        {\n            sourcePaths = Arrays.asList( sourcepath.split( \"[;]\" ) );\n        }\n        return sourcePaths;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setBuild( Build build )\n    {\n        this.build = build;\n    }","id":34157,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#setBuild(org.apache.maven.model.Build)\n     */\n    public void setBuild( Build build )\n    {\n        this.build = build;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public AggregateProject1TestMavenProjectStub()\n    {\n        /*\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model = null;\n\n        try\n        {\n            model = pomReader.read( new FileReader( new File( getBasedir() +\n                \"/src/test/resources/unit/aggregate-test/aggregate-test-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n\n        }\n\n*/\n        setGroupId( \"aggregate.test\" );\n        setArtifactId( \"aggregate-test-project1\" );\n        setVersion( \"1.0-SNAPSHOT\" );\n        setPackaging( \"jar\" );\n        setExecutionRoot( true );\n\n        Artifact artifact =\n            new JavadocPluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging() );\n        artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n        setArtifact( artifact );\n\n        Scm scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n        setScm( scm );\n\n        Build build = new Build();\n        build.setFinalName( \"aggregate-test-project1\" );\n        build.setDirectory( getBasedir() + \"/target/test/unit/aggregate-test/target\" );\n        setBuild( build );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/aggregate-test/project1/aggregate/test/project1\" );\n        setCompileSourceRoots( compileSourceRoots );\n\n    }","id":34158,"modified_method":"public AggregateProject1TestMavenProjectStub()\n    {\n        setGroupId( \"aggregate.test\" );\n        setArtifactId( \"aggregate-test-project1\" );\n        setVersion( \"1.0-SNAPSHOT\" );\n        setPackaging( \"jar\" );\n        setExecutionRoot( true );\n\n        Artifact artifact =\n            new JavadocPluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging() );\n        artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n        setArtifact( artifact );\n\n        scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n\n        build = new Build();\n        build.setFinalName( \"aggregate-test-project1\" );\n        build.setDirectory( getBasedir() + \"/target/test/unit/aggregate-test/target\" );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/aggregate-test/project1/aggregate/test/project1\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setScm( Scm scm )\n    {\n        this.scm = scm;\n    }","id":34159,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#setScm(org.apache.maven.model.Scm)\n     */\n    public void setScm( Scm scm )\n    {\n        this.scm = scm;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Build getBuild()\n    {\n        return build;\n    }","id":34160,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#getBuild()\n     */\n    public Build getBuild()\n    {\n        return build;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Scm getScm()\n    {\n        return scm;\n    }","id":34161,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#getScm()\n     */\n    public Scm getScm()\n    {\n        return scm;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Build getBuild()\n    {\n        return build;\n    }","id":34162,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#getBuild()\n     */\n    public Build getBuild()\n    {\n        return build;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public AggregateProject2TestMavenProjectStub()\n    {\n        setGroupId( \"aggregate.test\" );\n        setArtifactId( \"aggregate-test-project2\" );\n        setVersion( \"1.0-SNAPSHOT\" );\n        setPackaging( \"jar\" );\n        setExecutionRoot( true );\n\n        Artifact artifact =\n            new JavadocPluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging() );\n        artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n        setArtifact( artifact );\n\n        Scm scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n        setScm( scm );\n\n        Build build = new Build();\n        build.setFinalName( \"aggregate-test-project2\" );\n        build.setDirectory( getBasedir() + \"/target/test/unit/aggregate-test/target\" );\n        setBuild( build );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/aggregate-test/project2/aggregate/test/project2\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }","id":34163,"modified_method":"public AggregateProject2TestMavenProjectStub()\n    {\n        setGroupId( \"aggregate.test\" );\n        setArtifactId( \"aggregate-test-project2\" );\n        setVersion( \"1.0-SNAPSHOT\" );\n        setPackaging( \"jar\" );\n        setExecutionRoot( true );\n\n        Artifact artifact =\n            new JavadocPluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging() );\n        artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n        setArtifact( artifact );\n\n        scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n\n        build = new Build();\n        build.setFinalName( \"aggregate-test-project2\" );\n        build.setDirectory( getBasedir() + \"/target/test/unit/aggregate-test/target\" );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/aggregate-test/project2/aggregate/test/project2\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Scm getScm()\n    {\n        return scm;\n    }","id":34164,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#getScm()\n     */\n    public Scm getScm()\n    {\n        return scm;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setScm( Scm scm )\n    {\n        this.scm = scm;\n    }","id":34165,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#setScm(org.apache.maven.model.Scm)\n     */\n    public void setScm( Scm scm )\n    {\n        this.scm = scm;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setBuild( Build build )\n    {\n        this.build = build;\n    }","id":34166,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#setBuild(org.apache.maven.model.Build)\n     */\n    public void setBuild( Build build )\n    {\n        this.build = build;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Build getBuild()\n    {\n        return build;\n    }","id":34167,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#getBuild()\n     */\n    public Build getBuild()\n    {\n        return build;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Scm getScm()\n    {\n        return scm;\n    }","id":34168,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#getScm()\n     */\n    public Scm getScm()\n    {\n        return scm;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public AggregateTestMavenProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model = null;\n\n        try\n        {\n            model = pomReader.read( new FileReader( new File(\n                getBasedir() + \"/src/test/resources/unit/aggregate-test/aggregate-test-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n        setExecutionRoot( true );\n\n        Scm scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n        setScm( scm );\n\n        Build build = new Build();\n        build.setFinalName( model.getArtifactId() );\n        build.setDirectory( getBasedir() + \"/target/test/unit/aggregate-test/target\" );\n        setBuild( build );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/aggregate-test/aggregate/test\" );\n        setCompileSourceRoots( compileSourceRoots );\n\n    }","id":34169,"modified_method":"public AggregateTestMavenProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model = null;\n\n        try\n        {\n            model = pomReader.read( new FileReader( new File(\n                getBasedir() + \"/src/test/resources/unit/aggregate-test/aggregate-test-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n        setExecutionRoot( true );\n\n        scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n\n        build = new Build();\n        build.setFinalName( model.getArtifactId() );\n        build.setDirectory( getBasedir() + \"/target/test/unit/aggregate-test/target\" );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/aggregate-test/aggregate/test\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setScm( Scm scm )\n    {\n        this.scm = scm;\n    }","id":34170,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#setScm(org.apache.maven.model.Scm)\n     */\n    public void setScm( Scm scm )\n    {\n        this.scm = scm;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setBuild( Build build )\n    {\n        this.build = build;\n    }","id":34171,"modified_method":"/**\n     * @see org.apache.maven.project.MavenProject#setBuild(org.apache.maven.model.Build)\n     */\n    public void setBuild( Build build )\n    {\n        this.build = build;\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        File destDir = this.destDir;\n\n        if ( destDir == null )\n        {\n            destDir = outputDirectory;\n        }\n\n        // The JAR does not operate in aggregation mode - individual Javadoc JARs are always distributed.\n        aggregate = false;\n\n        ArtifactHandler artifactHandler = project.getArtifact().getArtifactHandler();\n        if ( !\"java\".equals( artifactHandler.getLanguage() ) )\n        {\n            getLog().info( \"Not executing Javadoc as the project is not a Java classpath-capable package\" );\n        }\n        else\n        {\n            try\n            {\n                executeReport( Locale.getDefault() );\n\n                if ( destDir.exists() )\n                {\n                    File outputFile = generateArchive( destDir, finalName + \"-javadoc.jar\" );\n\n                    if ( !attach )\n                    {\n                        getLog().info( \"NOT adding javadoc to attached artifacts list.\" );\n\n                    }\n                    else\n                    {\n                        // TODO: these introduced dependencies on the project are going to become problematic - can we export it\n                        //  through metadata instead?\n                        projectHelper.attachArtifact( project, \"javadoc\", \"javadoc\", outputFile );\n                    }\n                }\n            }\n            catch ( ArchiverException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive.\", e );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive.\", e );\n            }\n            catch ( MavenReportException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive.\", e );\n            }\n        }\n    }","id":34172,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        File destDir = this.destDir;\n\n        if ( destDir == null )\n        {\n            destDir = outputDirectory;\n        }\n\n        // The JAR does not operate in aggregation mode - individual Javadoc JARs are always distributed.\n        aggregate = false;\n\n        ArtifactHandler artifactHandler = project.getArtifact().getArtifactHandler();\n        if ( !\"java\".equals( artifactHandler.getLanguage() ) )\n        {\n            getLog().info( \"Not executing Javadoc as the project is not a Java classpath-capable package\" );\n        }\n        else\n        {\n            try\n            {\n                executeReport( Locale.getDefault() );\n\n                if ( destDir.exists() )\n                {\n                    File outputFile = generateArchive( destDir, finalName + \"-javadoc.jar\" );\n\n                    if ( !attach )\n                    {\n                        getLog().info( \"NOT adding javadoc to attached artifacts list.\" );\n\n                    }\n                    else\n                    {\n                        // TODO: these introduced dependencies on the project are going to become problematic - can we export it\n                        //  through metadata instead?\n                        projectHelper.attachArtifact( project, \"javadoc\", \"javadoc\", outputFile );\n                    }\n                }\n            }\n            catch ( ArchiverException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive:\" + e.getMessage(), e );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive:\" + e.getMessage(), e );\n            }\n            catch ( MavenReportException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive:\" + e.getMessage(), e );\n            }\n        }\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        try\n        {\n            SiteRendererSink sink = siteRenderer.createSink( getReportOutputDirectory(), getOutputName() + \".html\" );\n\n            generate( sink, Locale.getDefault() );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"An error has occurred in \" + getName( Locale.ENGLISH )\n                + \" report generation.\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"An error has occurred in \" + getName( Locale.ENGLISH )\n                + \" report generation.\", e );\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"An error has occurred in \" + getName( Locale.ENGLISH )\n                + \" report generation.\", e );\n        }\n    }","id":34173,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        try\n        {\n            SiteRendererSink sink = siteRenderer.createSink( getReportOutputDirectory(), getOutputName() + \".html\" );\n\n            generate( sink, Locale.getDefault() );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"An error has occurred in \" + getName( Locale.ENGLISH )\n                + \" report generation:\" + e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"An error has occurred in \" + getName( Locale.ENGLISH )\n                + \" report generation:\" + e.getMessage(), e );\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"An error has occurred in \" + getName( Locale.ENGLISH )\n                + \" report generation:\" + e.getMessage(), e );\n        }\n    }","commit_id":"f961de8a900cdbf5c1d10b898fe581e4d8263a5a","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Test\n  public void testAMRestartWithExistingContainers() throws Exception {\n    YarnConfiguration conf = new YarnConfiguration();\n    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS, 2);\n\n    MockRM rm1 = new MockRM(conf);\n    rm1.start();\n    RMApp app1 =\n        rm1.submitApp(200, \"name\", \"user\",\n          new HashMap<ApplicationAccessType, String>(), false, \"default\", -1,\n          null, \"MAPREDUCE\", false, true);\n    MockNM nm1 =\n        new MockNM(\"127.0.0.1:1234\", 10240, rm1.getResourceTrackerService());\n    nm1.registerNode();\n    MockNM nm2 =\n        new MockNM(\"127.0.0.1:2351\", 4089, rm1.getResourceTrackerService());\n    nm2.registerNode();\n\n    MockAM am1 = MockRM.launchAndRegisterAM(app1, rm1, nm1);\n    int NUM_CONTAINERS = 3;\n    // allocate NUM_CONTAINERS containers\n    am1.allocate(\"127.0.0.1\", 1024, NUM_CONTAINERS,\n      new ArrayList<ContainerId>());\n    nm1.nodeHeartbeat(true);\n\n    // wait for containers to be allocated.\n    List<Container> containers =\n        am1.allocate(new ArrayList<ResourceRequest>(),\n          new ArrayList<ContainerId>()).getAllocatedContainers();\n    while (containers.size() != NUM_CONTAINERS) {\n      nm1.nodeHeartbeat(true);\n      containers.addAll(am1.allocate(new ArrayList<ResourceRequest>(),\n        new ArrayList<ContainerId>()).getAllocatedContainers());\n      Thread.sleep(200);\n    }\n\n    // launch the 2nd container, for testing running container transferred.\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 2, ContainerState.RUNNING);\n    ContainerId containerId2 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 2);\n    rm1.waitForState(nm1, containerId2, RMContainerState.RUNNING);\n\n    // launch the 3rd container, for testing container allocated by previous\n    // attempt is completed by the next new attempt/\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 3, ContainerState.RUNNING);\n    ContainerId containerId3 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 3);\n    rm1.waitForState(nm1, containerId3, RMContainerState.RUNNING);\n\n    // 4th container still in AQUIRED state. for testing Acquired container is\n    // always killed.\n    ContainerId containerId4 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 4);\n    rm1.waitForState(nm1, containerId4, RMContainerState.ACQUIRED);\n\n    // 5th container is in Allocated state. for testing allocated container is\n    // always killed.\n    am1.allocate(\"127.0.0.1\", 1024, 1, new ArrayList<ContainerId>());\n    nm1.nodeHeartbeat(true);\n    ContainerId containerId5 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 5);\n    rm1.waitForContainerAllocated(nm1, containerId5);\n    rm1.waitForState(nm1, containerId5, RMContainerState.ALLOCATED);\n\n    // 6th container is in Reserved state.\n    am1.allocate(\"127.0.0.1\", 6000, 1, new ArrayList<ContainerId>());\n    ContainerId containerId6 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 6);\n    nm1.nodeHeartbeat(true);\n    SchedulerApplicationAttempt schedulerAttempt =\n        ((CapacityScheduler) rm1.getResourceScheduler())\n          .getCurrentAttemptForContainer(containerId6);\n    while (schedulerAttempt.getReservedContainers().size() == 0) {\n      System.out.println(\"Waiting for container \" + containerId6\n          + \" to be reserved.\");\n      nm1.nodeHeartbeat(true);\n      Thread.sleep(200);\n    }\n    // assert containerId6 is reserved.\n    Assert.assertEquals(containerId6, schedulerAttempt.getReservedContainers()\n      .get(0).getContainerId());\n\n    // fail the AM by sending CONTAINER_FINISHED event without registering.\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 1, ContainerState.COMPLETE);\n    am1.waitForState(RMAppAttemptState.FAILED);\n\n    // wait for some time. previous AM's running containers should still remain\n    // in scheduler even though am failed\n    Thread.sleep(3000);\n    rm1.waitForState(nm1, containerId2, RMContainerState.RUNNING);\n    // acquired/allocated containers are cleaned up.\n    Assert.assertNull(rm1.getResourceScheduler().getRMContainer(containerId4));\n    Assert.assertNull(rm1.getResourceScheduler().getRMContainer(containerId5));\n\n    // wait for app to start a new attempt.\n    rm1.waitForState(app1.getApplicationId(), RMAppState.ACCEPTED);\n    // assert this is a new AM.\n    ApplicationAttemptId newAttemptId =\n        app1.getCurrentAppAttempt().getAppAttemptId();\n    Assert.assertFalse(newAttemptId.equals(am1.getApplicationAttemptId()));\n\n    // launch the new AM\n    RMAppAttempt attempt2 = app1.getCurrentAppAttempt();\n    nm1.nodeHeartbeat(true);\n    MockAM am2 = rm1.sendAMLaunched(attempt2.getAppAttemptId());\n    RegisterApplicationMasterResponse registerResponse =\n        am2.registerAppAttempt();\n\n    // Assert two containers are running: container2 and container3;\n    Assert.assertEquals(2, registerResponse.getContainersFromPreviousAttempts()\n      .size());\n    boolean containerId2Exists = false, containerId3Exists = false;\n    for (Container container : registerResponse\n      .getContainersFromPreviousAttempts()) {\n      if (container.getId().equals(containerId2)) {\n        containerId2Exists = true;\n      }\n      if (container.getId().equals(containerId3)) {\n        containerId3Exists = true;\n      }\n    }\n    Assert.assertTrue(containerId2Exists && containerId3Exists);\n    rm1.waitForState(app1.getApplicationId(), RMAppState.RUNNING);\n\n    // complete container by sending the container complete event which has earlier\n    // attempt's attemptId\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 3, ContainerState.COMPLETE);\n    rm1.waitForState(nm1, containerId3, RMContainerState.COMPLETED);\n\n    // Even though the completed container containerId3 event was sent to the\n    // earlier failed attempt, new RMAppAttempt can also capture this container\n    // info.\n    // completed containerId4 is also transferred to the new attempt.\n    RMAppAttempt newAttempt =\n        app1.getRMAppAttempt(am2.getApplicationAttemptId());\n    // 4 containers finished, acquired/allocated/reserved/completed.\n    Assert.assertEquals(4, newAttempt.getJustFinishedContainers().size());\n    boolean container3Exists = false, container4Exists = false, container5Exists =\n        false, container6Exists = false;\n    for(ContainerStatus status :  newAttempt.getJustFinishedContainers()) {\n      if(status.getContainerId().equals(containerId3)) {\n        // containerId3 is the container ran by previous attempt but finished by the\n        // new attempt.\n        container3Exists = true;\n      }\n      if (status.getContainerId().equals(containerId4)) {\n        // containerId4 is the Acquired Container killed by the previous attempt,\n        // it's now inside new attempt's finished container list.\n        container4Exists = true;\n      }\n      if (status.getContainerId().equals(containerId5)) {\n        // containerId5 is the Allocated container killed by previous failed attempt.\n        container5Exists = true;\n      }\n      if (status.getContainerId().equals(containerId6)) {\n        // containerId6 is the reserved container killed by previous failed attempt.\n        container6Exists = true;\n      }\n    }\n    Assert.assertTrue(container3Exists && container4Exists && container5Exists\n        && container6Exists);\n\n    // New SchedulerApplicationAttempt also has the containers info.\n    rm1.waitForState(nm1, containerId2, RMContainerState.RUNNING);\n\n    // record the scheduler attempt for testing.\n    SchedulerApplicationAttempt schedulerNewAttempt =\n        ((CapacityScheduler) rm1.getResourceScheduler())\n          .getCurrentAttemptForContainer(containerId2);\n    // finish this application\n    MockRM.finishAMAndVerifyAppState(app1, rm1, nm1, am2);\n\n    // the 2nd attempt released the 1st attempt's running container, when the\n    // 2nd attempt finishes.\n    Assert.assertFalse(schedulerNewAttempt.getLiveContainers().contains(\n      containerId2));\n    // all 4 normal containers finished.\n    Assert.assertEquals(5, newAttempt.getJustFinishedContainers().size());\n\n    rm1.stop();\n  }","id":34174,"modified_method":"@Test\n  public void testAMRestartWithExistingContainers() throws Exception {\n    YarnConfiguration conf = new YarnConfiguration();\n    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS, 2);\n\n    MockRM rm1 = new MockRM(conf);\n    rm1.start();\n    RMApp app1 =\n        rm1.submitApp(200, \"name\", \"user\",\n          new HashMap<ApplicationAccessType, String>(), false, \"default\", -1,\n          null, \"MAPREDUCE\", false, true);\n    MockNM nm1 =\n        new MockNM(\"127.0.0.1:1234\", 10240, rm1.getResourceTrackerService());\n    nm1.registerNode();\n    MockNM nm2 =\n        new MockNM(\"127.0.0.1:2351\", 4089, rm1.getResourceTrackerService());\n    nm2.registerNode();\n\n    MockAM am1 = MockRM.launchAndRegisterAM(app1, rm1, nm1);\n    int NUM_CONTAINERS = 3;\n    // allocate NUM_CONTAINERS containers\n    am1.allocate(\"127.0.0.1\", 1024, NUM_CONTAINERS,\n      new ArrayList<ContainerId>());\n    nm1.nodeHeartbeat(true);\n\n    // wait for containers to be allocated.\n    List<Container> containers =\n        am1.allocate(new ArrayList<ResourceRequest>(),\n          new ArrayList<ContainerId>()).getAllocatedContainers();\n    while (containers.size() != NUM_CONTAINERS) {\n      nm1.nodeHeartbeat(true);\n      containers.addAll(am1.allocate(new ArrayList<ResourceRequest>(),\n        new ArrayList<ContainerId>()).getAllocatedContainers());\n      Thread.sleep(200);\n    }\n\n    // launch the 2nd container, for testing running container transferred.\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 2, ContainerState.RUNNING);\n    ContainerId containerId2 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 2);\n    rm1.waitForState(nm1, containerId2, RMContainerState.RUNNING);\n\n    // launch the 3rd container, for testing container allocated by previous\n    // attempt is completed by the next new attempt/\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 3, ContainerState.RUNNING);\n    ContainerId containerId3 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 3);\n    rm1.waitForState(nm1, containerId3, RMContainerState.RUNNING);\n\n    // 4th container still in AQUIRED state. for testing Acquired container is\n    // always killed.\n    ContainerId containerId4 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 4);\n    rm1.waitForState(nm1, containerId4, RMContainerState.ACQUIRED);\n\n    // 5th container is in Allocated state. for testing allocated container is\n    // always killed.\n    am1.allocate(\"127.0.0.1\", 1024, 1, new ArrayList<ContainerId>());\n    nm1.nodeHeartbeat(true);\n    ContainerId containerId5 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 5);\n    rm1.waitForContainerAllocated(nm1, containerId5);\n    rm1.waitForState(nm1, containerId5, RMContainerState.ALLOCATED);\n\n    // 6th container is in Reserved state.\n    am1.allocate(\"127.0.0.1\", 6000, 1, new ArrayList<ContainerId>());\n    ContainerId containerId6 =\n        ContainerId.newInstance(am1.getApplicationAttemptId(), 6);\n    nm1.nodeHeartbeat(true);\n    SchedulerApplicationAttempt schedulerAttempt =\n        ((CapacityScheduler) rm1.getResourceScheduler())\n          .getCurrentAttemptForContainer(containerId6);\n    while (schedulerAttempt.getReservedContainers().size() == 0) {\n      System.out.println(\"Waiting for container \" + containerId6\n          + \" to be reserved.\");\n      nm1.nodeHeartbeat(true);\n      Thread.sleep(200);\n    }\n    // assert containerId6 is reserved.\n    Assert.assertEquals(containerId6, schedulerAttempt.getReservedContainers()\n      .get(0).getContainerId());\n\n    // fail the AM by sending CONTAINER_FINISHED event without registering.\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 1, ContainerState.COMPLETE);\n    am1.waitForState(RMAppAttemptState.FAILED);\n\n    // wait for some time. previous AM's running containers should still remain\n    // in scheduler even though am failed\n    Thread.sleep(3000);\n    rm1.waitForState(nm1, containerId2, RMContainerState.RUNNING);\n    // acquired/allocated containers are cleaned up.\n    Assert.assertNull(rm1.getResourceScheduler().getRMContainer(containerId4));\n    Assert.assertNull(rm1.getResourceScheduler().getRMContainer(containerId5));\n\n    // wait for app to start a new attempt.\n    rm1.waitForState(app1.getApplicationId(), RMAppState.ACCEPTED);\n    // assert this is a new AM.\n    ApplicationAttemptId newAttemptId =\n        app1.getCurrentAppAttempt().getAppAttemptId();\n    Assert.assertFalse(newAttemptId.equals(am1.getApplicationAttemptId()));\n\n    // launch the new AM\n    RMAppAttempt attempt2 = app1.getCurrentAppAttempt();\n    nm1.nodeHeartbeat(true);\n    MockAM am2 = rm1.sendAMLaunched(attempt2.getAppAttemptId());\n    RegisterApplicationMasterResponse registerResponse =\n        am2.registerAppAttempt();\n\n    // Assert two containers are running: container2 and container3;\n    Assert.assertEquals(2, registerResponse.getContainersFromPreviousAttempts()\n      .size());\n    boolean containerId2Exists = false, containerId3Exists = false;\n    for (Container container : registerResponse\n      .getContainersFromPreviousAttempts()) {\n      if (container.getId().equals(containerId2)) {\n        containerId2Exists = true;\n      }\n      if (container.getId().equals(containerId3)) {\n        containerId3Exists = true;\n      }\n    }\n    Assert.assertTrue(containerId2Exists && containerId3Exists);\n    rm1.waitForState(app1.getApplicationId(), RMAppState.RUNNING);\n\n    // complete container by sending the container complete event which has earlier\n    // attempt's attemptId\n    nm1.nodeHeartbeat(am1.getApplicationAttemptId(), 3, ContainerState.COMPLETE);\n\n    // Even though the completed container containerId3 event was sent to the\n    // earlier failed attempt, new RMAppAttempt can also capture this container\n    // info.\n    // completed containerId4 is also transferred to the new attempt.\n    RMAppAttempt newAttempt =\n        app1.getRMAppAttempt(am2.getApplicationAttemptId());\n    // 4 containers finished, acquired/allocated/reserved/completed.\n    waitForContainersToFinish(4, newAttempt);\n    boolean container3Exists = false, container4Exists = false, container5Exists =\n        false, container6Exists = false;\n    for(ContainerStatus status :  newAttempt.getJustFinishedContainers()) {\n      if(status.getContainerId().equals(containerId3)) {\n        // containerId3 is the container ran by previous attempt but finished by the\n        // new attempt.\n        container3Exists = true;\n      }\n      if (status.getContainerId().equals(containerId4)) {\n        // containerId4 is the Acquired Container killed by the previous attempt,\n        // it's now inside new attempt's finished container list.\n        container4Exists = true;\n      }\n      if (status.getContainerId().equals(containerId5)) {\n        // containerId5 is the Allocated container killed by previous failed attempt.\n        container5Exists = true;\n      }\n      if (status.getContainerId().equals(containerId6)) {\n        // containerId6 is the reserved container killed by previous failed attempt.\n        container6Exists = true;\n      }\n    }\n    Assert.assertTrue(container3Exists && container4Exists && container5Exists\n        && container6Exists);\n\n    // New SchedulerApplicationAttempt also has the containers info.\n    rm1.waitForState(nm1, containerId2, RMContainerState.RUNNING);\n\n    // record the scheduler attempt for testing.\n    SchedulerApplicationAttempt schedulerNewAttempt =\n        ((CapacityScheduler) rm1.getResourceScheduler())\n          .getCurrentAttemptForContainer(containerId2);\n    // finish this application\n    MockRM.finishAMAndVerifyAppState(app1, rm1, nm1, am2);\n\n    // the 2nd attempt released the 1st attempt's running container, when the\n    // 2nd attempt finishes.\n    Assert.assertFalse(schedulerNewAttempt.getLiveContainers().contains(\n      containerId2));\n    // all 4 normal containers finished.\n    System.out.println(\"New attempt's just finished containers: \"\n        + newAttempt.getJustFinishedContainers());\n    waitForContainersToFinish(5, newAttempt);\n    rm1.stop();\n  }","commit_id":"c6b70f4760bc9d4028616de779ccf86219f38ec8","url":"https://github.com/apache/hadoop"},{"original_method":"private void writeNodeHealthScriptFile(String scriptStr, boolean setExecutable)\n      throws IOException {\n    PrintWriter pw = new PrintWriter(new FileOutputStream(nodeHealthscriptFile));\n    pw.println(scriptStr);\n    pw.flush();\n    pw.close();\n    FileUtil.setExecutable(nodeHealthscriptFile, setExecutable);\n  }","id":34175,"modified_method":"private void writeNodeHealthScriptFile(String scriptStr, boolean setExecutable)\n          throws IOException {\n    PrintWriter pw = null;\n    try {\n      FileUtil.setWritable(nodeHealthscriptFile, true);\n      FileUtil.setReadable(nodeHealthscriptFile, true);\n      pw = new PrintWriter(new FileOutputStream(nodeHealthscriptFile));\n      pw.println(scriptStr);\n      pw.flush();\n    } finally {\n      pw.close();\n    }\n    FileUtil.setExecutable(nodeHealthscriptFile, setExecutable);\n  }","commit_id":"c6b70f4760bc9d4028616de779ccf86219f38ec8","url":"https://github.com/apache/hadoop"},{"original_method":"T runWithRetries() throws Exception {\n      int retry = 0;\n      while (true) {\n        try {\n          return runWithCheck();\n        } catch (KeeperException.NoAuthException nae) {\n          if (HAUtil.isHAEnabled(getConfig())) {\n            // NoAuthException possibly means that this store is fenced due to\n            // another RM becoming active. Even if not,\n            // it is safer to assume we have been fenced\n            throw new StoreFencedException();\n          }\n        } catch (KeeperException ke) {\n          if (shouldRetry(ke.code()) && ++retry < numRetries) {\n            LOG.info(\"Waiting for zookeeper to be connected, retry no. + \"\n                + retry);\n            Thread.sleep(zkRetryInterval);\n            continue;\n          }\n          LOG.error(\"Error while doing ZK operation.\", ke);\n          throw ke;\n        }\n      }\n    }","id":34176,"modified_method":"T runWithRetries() throws Exception {\n      int retry = 0;\n      while (true) {\n        try {\n          return runWithCheck();\n        } catch (KeeperException.NoAuthException nae) {\n          if (HAUtil.isHAEnabled(getConfig())) {\n            // NoAuthException possibly means that this store is fenced due to\n            // another RM becoming active. Even if not,\n            // it is safer to assume we have been fenced\n            throw new StoreFencedException();\n          }\n        } catch (KeeperException ke) {\n          if (shouldRetry(ke.code()) && ++retry < numRetries) {\n            LOG.info(\"Waiting for zookeeper to be connected, retry no. + \"\n                + retry);\n            Thread.sleep(zkRetryInterval);\n            continue;\n          }\n          LOG.debug(\"Error while doing ZK operation.\", ke);\n          throw ke;\n        }\n      }\n    }","commit_id":"c6b70f4760bc9d4028616de779ccf86219f38ec8","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * get the alternate genotype\n     */\n    public DiploidGenotype getAltGenotype() {\n        lazyEval();\n        return mCompareTo;\n    }","id":34177,"modified_method":"/**\n     * get the alternate genotype\n     */\n    private DiploidGenotype getRefGenotype() {\n        lazyEval();\n        return mRefGenotype;\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String toString() {\n        lazyEval();\n        return String.format(\"%s best=%s cmp=%s ref=%s depth=%d negLog10PError = %.2f, likelihoods=%s\",\n                getLocation(), mGenotype, mCompareTo, mRefBase, mPileup.getReads().size(),\n                getNegLog10PError(), Arrays.toString(mGenotypeLikelihoods.getLikelihoods()));\n    }","id":34178,"modified_method":"public String toString() {\n        lazyEval();\n        return String.format(\"%s best=%s cmp=%s ref=%s depth=%d negLog10PError = %.2f, likelihoods=%s\",\n                getLocation(), mGenotype, mRefGenotype, mRefBase, mPileup.getReads().size(),\n                getNegLog10PError(), Arrays.toString(mGenotypeLikelihoods.getLikelihoods()));\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Generate a single sample genotype object, containing everything we need to represent calls out of a genotyper object\n     *\n     * @param discovery are we representing the best vrs next or best vrs ref\n     * @param location   the location we're working with\n     * @param refBase    the ref base\n     * @param gtlh       the genotype likelihoods object\n     * @param pileup     the pile-up of reads at the specified locus\n     */\n    SSGenotypeCall(boolean discovery, GenomeLoc location, char refBase, GenotypeLikelihoods gtlh, ReadBackedPileup pileup, DiploidGenotype genotype) {\n        mBestVrsRef = discovery;\n        mRefBase = String.valueOf(refBase).toUpperCase().charAt(0); // a round about way to make sure the ref base is up-case\n        mGenotypeLikelihoods = gtlh;\n        mLocation = location;\n        mGenotype = genotype;\n        mPileup = pileup;\n    }","id":34179,"modified_method":"/**\n     * Generate a single sample genotype object, containing everything we need to represent calls out of a genotyper object\n     *\n     * @param location  the location we're working with\n     * @param refBase   the ref base\n     * @param gtlh      the genotype likelihoods object\n     * @param pileup    the pile-up of reads at the specified locus\n     */\n    SSGenotypeCall(GenomeLoc location, char refBase, GenotypeLikelihoods gtlh, ReadBackedPileup pileup, DiploidGenotype genotype) {\n        mRefBase = String.valueOf(refBase).toUpperCase().charAt(0); // a round about way to make sure the ref base is up-case\n        mGenotypeLikelihoods = gtlh;\n        mLocation = location;\n        mGenotype = genotype;\n        mPileup = pileup;\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * return this genotype as a variant\n     *\n     * @return\n     */\n    public Variant toVariation() {\n        return null;  // the next step is to implement the variant system\n    }","id":34180,"modified_method":"/**\n     * return this genotype as a variant\n     *\n     * @return\n     */\n    public Variation toVariation() {\n        double bestRef = Math.abs(mGenotypeLikelihoods.getPosterior(getBestGenotype()) - mGenotypeLikelihoods.getPosterior(getRefGenotype()));\n        return new BasicVariation(this.getBases(), this.getReference(), 0, this.mLocation, bestRef);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * get the confidence we have\n     *\n     * @return get the one minus error value\n     */\n    @Override\n    public double getNegLog10PError() {\n        getBestGenotype();\n        getAltGenotype();        \n        return Math.abs(mGenotypeLikelihoods.getPosterior(mGenotype) - mGenotypeLikelihoods.getPosterior(mCompareTo));\n    }","id":34181,"modified_method":"/**\n     * get the confidence we have\n     *\n     * @return get the one minus error value\n     */\n    @Override\n    public double getNegLog10PError() {\n        return Math.abs(mGenotypeLikelihoods.getPosterior(getBestGenotype()) - mGenotypeLikelihoods.getPosterior(getNextBest()));\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void lazyEval() {\n        // us\n        if (mGenotype == null) {\n            Integer sorted[] = Utils.SortPermutation(mGenotypeLikelihoods.getPosteriors());\n            mGenotype = DiploidGenotype.values()[sorted[DiploidGenotype.values().length - 1]];\n        }\n\n        // our comparison\n        if (mCompareTo == null) {\n            if (this.mBestVrsRef) {\n                mCompareTo = DiploidGenotype.valueOf(Utils.dupString(this.getReference(),2));\n            } else {\n                Integer sorted[] = Utils.SortPermutation(mGenotypeLikelihoods.getPosteriors());\n                mCompareTo = DiploidGenotype.values()[sorted[DiploidGenotype.values().length - 2]];\n            }\n        }\n    }","id":34182,"modified_method":"private void lazyEval() {\n        // us\n        if (mGenotype == null) {\n            Integer sorted[] = Utils.SortPermutation(mGenotypeLikelihoods.getPosteriors());\n            mGenotype = DiploidGenotype.values()[sorted[DiploidGenotype.values().length - 1]];\n        }\n\n        // our comparison\n        if (mRefGenotype == null) {\n            mRefGenotype = DiploidGenotype.valueOf(Utils.dupString(this.getReference(), 2));\n        }\n        if (mNextGenotype == null) {\n            Integer sorted[] = Utils.SortPermutation(mGenotypeLikelihoods.getPosteriors());\n            mNextGenotype = DiploidGenotype.values()[sorted[DiploidGenotype.values().length - 2]];\n        }\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Generate a single sample genotype object, containing everything we need to represent calls out of a genotyper object\n     *\n     * @param discovery are we representing the best vrs next or best vrs ref\n     * @param location   the location we're working with\n     * @param refBase    the ref base\n     * @param gtlh       the genotype likelihoods object\n     * @param pileup     the pile-up of reads at the specified locus\n     */\n    public SSGenotypeCall(boolean discovery, GenomeLoc location, char refBase, GenotypeLikelihoods gtlh, ReadBackedPileup pileup) {\n        mBestVrsRef = discovery;\n        mRefBase = String.valueOf(refBase).toUpperCase().charAt(0); // a round about way to make sure the ref base is up-case\n        mGenotypeLikelihoods = gtlh;\n        mLocation = location;\n        mPileup = pileup;\n    }","id":34183,"modified_method":"/**\n     * Generate a single sample genotype object, containing everything we need to represent calls out of a genotyper object\n     *\n     * @param location  the location we're working with\n     * @param refBase   the ref base\n     * @param gtlh      the genotype likelihoods object\n     * @param pileup    the pile-up of reads at the specified locus\n     */\n    public SSGenotypeCall(GenomeLoc location, char refBase, GenotypeLikelihoods gtlh, ReadBackedPileup pileup) {\n        mRefBase = String.valueOf(refBase).toUpperCase().charAt(0); // a round about way to make sure the ref base is up-case\n        mGenotypeLikelihoods = gtlh;\n        mLocation = location;\n        mPileup = pileup;\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * get the likelihoods\n     *\n     * @return an array in lexigraphical order of the likelihoods\n     */\n    public Genotype getGenotype(DiploidGenotype x) {\n        return new SSGenotypeCall(mBestVrsRef,mLocation,mRefBase,mGenotypeLikelihoods,mPileup,x);\n    }","id":34184,"modified_method":"/**\n     * get the likelihoods\n     *\n     * @return an array in lexigraphical order of the likelihoods\n     */\n    public Genotype getGenotype(DiploidGenotype x) {\n        return new SSGenotypeCall(mLocation, mRefBase, mGenotypeLikelihoods, mPileup, x);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * get the best genotype\n     */\n    public DiploidGenotype getBestGenotype() {\n        lazyEval();\n        return mGenotype;\n    }","id":34185,"modified_method":"/**\n     * get the best genotype\n     */\n    private DiploidGenotype getBestGenotype() {\n        lazyEval();\n        return mGenotype;\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testBestVrsRef2() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call2 = new SSGenotypeCall(true, myPair.second, 'T', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(9, call2.getNegLog10PError(), 0.0000001);\n    }","id":34186,"modified_method":"@Test\n    public void testBestVrsRef2() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call2 = new SSGenotypeCall(myPair.second, 'T', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(9, call2.toVariation().getNegLog10PError(), 0.0000001);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testBestVrsNext3() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call3 = new SSGenotypeCall(false, myPair.second, 'C', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(1, call3.getNegLog10PError(), 0.0000001);\n    }","id":34187,"modified_method":"@Test\n    public void testBestVrsNext3() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call3 = new SSGenotypeCall(myPair.second, 'C', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(1, call3.getNegLog10PError(), 0.0000001);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testBestVrsNext2() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call2 = new SSGenotypeCall(false, myPair.second, 'A', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(1, call2.getNegLog10PError(), 0.0000001);\n    }","id":34188,"modified_method":"@Test\n    public void testBestVrsNext2() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call2 = new SSGenotypeCall(myPair.second, 'A', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(1, call2.getNegLog10PError(), 0.0000001);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testBestVrsRefSame() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call = new SSGenotypeCall(true, myPair.second, 'A', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(0, call.getNegLog10PError(), 0.0000001);\n    }","id":34189,"modified_method":"@Test\n    public void testBestVrsRefSame() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call = new SSGenotypeCall(myPair.second, 'A', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(0, call.toVariation().getNegLog10PError(), 0.0000001);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testBestVrsRef3() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call3 = new SSGenotypeCall(true, myPair.second, 'C', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(4, call3.getNegLog10PError(), 0.0000001);\n    }","id":34190,"modified_method":"@Test\n    public void testBestVrsRef3() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call3 = new SSGenotypeCall(myPair.second, 'C', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(4, call3.toVariation().getNegLog10PError(), 0.0000001);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testBestVrsNextSame() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call = new SSGenotypeCall(false, myPair.second, 'A', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(1, call.getNegLog10PError(), 0.0000001);\n    }","id":34191,"modified_method":"@Test\n    public void testBestVrsNextSame() {\n        Pair<ReadBackedPileup, GenomeLoc> myPair = makePileup();\n        SSGenotypeCall call = new SSGenotypeCall(myPair.second, 'A', new GenotypeLikelihoodsImpl(), myPair.first);\n        Assert.assertEquals(1, call.getNegLog10PError(), 0.0000001);\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute at a given locus.\n     *\n     * @param tracker the meta data tracker\n     * @param refContext the reference base\n     * @param context contextual information around the locus\n     */\n    public SSGenotypeCall map(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext context) {\n        char ref = refContext.getBase();\n        if ( BaseUtils.isRegularBase(ref) ) {\n            DiploidGenotypePriors priors = new DiploidGenotypePriors(ref, heterozygosity, DiploidGenotypePriors.PROB_OF_TRISTATE_GENOTYPE);\n\n            // setup GenotypeLike object\n            GenotypeLikelihoods gl = GenotypeLikelihoodsFactory.makeGenotypeLikelihoods(baseModel, priors, defaultPlatform);\n\n            gl.setVerbose(VERBOSE);\n            gl.setEnableCacheFlag(! disableCache);\n            ReadBackedPileup pileup = new ReadBackedPileup(ref, context);\n            gl.add(pileup, true);\n            gl.validate();\n\n            return new SSGenotypeCall(!GENOTYPE, context.getLocation(), ref,gl, pileup);\n        } else {\n            return null;\n        }\n    }","id":34192,"modified_method":"/**\n     * Compute at a given locus.\n     *\n     * @param tracker the meta data tracker\n     * @param refContext the reference base\n     * @param context contextual information around the locus\n     */\n    public SSGenotypeCall map(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext context) {\n        char ref = refContext.getBase();\n        if ( BaseUtils.isRegularBase(ref) ) {\n            DiploidGenotypePriors priors = new DiploidGenotypePriors(ref, heterozygosity, DiploidGenotypePriors.PROB_OF_TRISTATE_GENOTYPE);\n\n            // setup GenotypeLike object\n            GenotypeLikelihoods gl = GenotypeLikelihoodsFactory.makeGenotypeLikelihoods(baseModel, priors, defaultPlatform);\n\n            gl.setVerbose(VERBOSE);\n            gl.setEnableCacheFlag(! disableCache);\n            ReadBackedPileup pileup = new ReadBackedPileup(ref, context);\n            gl.add(pileup, true);\n            gl.validate();\n\n            return new SSGenotypeCall(context.getLocation(), ref,gl, pileup);\n        } else {\n            return null;\n        }\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * If we've found a LOD >= 5 variant, output it to disk.\n     *\n     * @param call an GenotypeCall object for the variant.\n     * @param sum  accumulator for the reduce.\n     *\n     * @return an empty string\n     */\n    public CallResult reduce(SSGenotypeCall call, CallResult sum) {\n        sum.nCalledBases++;\n\n        // todo -- aaron, fixme -- this should be using variation() in discovery mode and genotype if not\n        if (call != null && (GENOTYPE || call.isVariant(call.getReference()))) {\n            if (call.getNegLog10PError() >= LOD_THRESHOLD) {\n                sum.nConfidentCalls++;\n                //System.out.printf(\"Call %s%n\", call);\n                sum.writer.addGenotypeCall(call);\n            } else {\n                sum.nNonConfidentCalls++;\n            }\n        }\n        return sum;\n    }","id":34193,"modified_method":"/**\n     * If we've found a LOD variant or callable genotype, output it to disk.\n     *\n     * @param call an GenotypeCall object for the variant.\n     * @param sum  accumulator for the reduce.\n     *\n     * @return an empty string\n     */\n    public CallResult reduce(SSGenotypeCall call, CallResult sum) {\n        sum.nCalledBases++;\n\n        if (call != null && (GENOTYPE || call.isVariant(call.getReference()))) {\n            double confidence = (GENOTYPE) ? call.getNegLog10PError() : call.toVariation().getNegLog10PError();\n            if (confidence >= LOD_THRESHOLD) {\n                sum.nConfidentCalls++;\n                //System.out.printf(\"Call %s%n\", call);\n                sum.writer.addGenotypeCall(call);\n            } else\n                sum.nNonConfidentCalls++;\n        }\n        return sum;\n    }","commit_id":"5a64a80ab5115d86d58b600f4edbf0a703eb7b04","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker rodData, ReferenceContext ref, AlignmentContext context) {\n        if ( rodData == null ) // RodWalkers can make funky map calls\n            return 0;\n\n        // get all of the vcf rods at this locus\n        ArrayList<RodVCF> vcfRods = new ArrayList<RodVCF>();        \n        Iterator<ReferenceOrderedDatum> rods = rodData.getAllRods().iterator();\n        while (rods.hasNext()) {\n            ReferenceOrderedDatum rod = rods.next();\n            if ( rod instanceof RodVCF )\n                vcfRods.add((RodVCF)rod);\n        }\n\n        if ( vcfRods.size() == 0 )\n            return 0;\n\n        // create a merged record from all input VCFs\n        VCFRecord record = VCFUtils.mergeRecords(vcfRods, rodNamesToSampleNames);\n\n        // pull out all of the individual calls from the rods and insert into a map based on the\n        // mapping from rod/sample to uniquified name\n        HashMap<String, VCFGenotypeCall> samplesToRecords = new HashMap<String, VCFGenotypeCall>();\n        for ( RodVCF rod : vcfRods ) {\n            List<Genotype> records = rod.getGenotypes();\n            for ( Genotype g : records ) {\n                if ( !(g instanceof VCFGenotypeCall) )\n                    throw new StingException(\"Expected VCF rod Genotypes to be of type VCFGenotypeCall\");\n\n                VCFGenotypeCall vcfCall = (VCFGenotypeCall)g;\n                String uniquifiedSample = rodNamesToSampleNames.get(new Pair<String, String>(rod.getName(), vcfCall.getSampleName()));\n                if ( uniquifiedSample == null )\n                    throw new StingException(\"Unexpected sample encountered: \" + vcfCall.getSampleName() + \" in rod \" + rod.getName());\n\n                samplesToRecords.put(uniquifiedSample, vcfCall);\n            }\n        }\n\n        // add in the info fields to the new record based on the results of each of the relevant concordance tests\n        for ( ConcordanceType type : requestedTypes ) {\n            String result = type.computeConcordance(samplesToRecords, ref);\n            if ( result != null ) {\n                record.addInfoField(type.getInfoName(), result);\n            }\n        }\n\n        // emit the new record\n        vcfWriter.addRecord(record);\n\n        return 1;\n    }","id":34194,"modified_method":"public Integer map(RefMetaDataTracker rodData, ReferenceContext ref, AlignmentContext context) {\n        if ( rodData == null ) // RodWalkers can make funky map calls\n            return 0;\n\n        // get all of the vcf rods at this locus\n        ArrayList<RodVCF> vcfRods = new ArrayList<RodVCF>();        \n        Iterator<ReferenceOrderedDatum> rods = rodData.getAllRods().iterator();\n        while (rods.hasNext()) {\n            ReferenceOrderedDatum rod = rods.next();\n            if ( rod instanceof RodVCF )\n                vcfRods.add((RodVCF)rod);\n        }\n\n        if ( vcfRods.size() == 0 )\n            return 0;\n\n        // pull out all of the individual calls from the rods and insert into a map based on the\n        // mapping from rod/sample to uniquified name\n        HashMap<String, VCFGenotypeCall> samplesToRecords = new HashMap<String, VCFGenotypeCall>();\n        for ( RodVCF rod : vcfRods ) {\n            List<Genotype> records = rod.getGenotypes();\n            for ( Genotype g : records ) {\n                if ( !(g instanceof VCFGenotypeCall) )\n                    throw new StingException(\"Expected VCF rod Genotypes to be of type VCFGenotypeCall\");\n\n                VCFGenotypeCall vcfCall = (VCFGenotypeCall)g;\n                String uniquifiedSample = rodNamesToSampleNames.get(new Pair<String, String>(rod.getName(), vcfCall.getSampleName()));\n                if ( uniquifiedSample == null )\n                    throw new StingException(\"Unexpected sample encountered: \" + vcfCall.getSampleName() + \" in rod \" + rod.getName());\n\n                samplesToRecords.put(uniquifiedSample, vcfCall);\n            }\n        }\n\n        // create a merged record from all input VCFs\n        VCFRecord record = VCFUtils.mergeRecords(vcfRods, rodNamesToSampleNames);\n\n        // add in the info fields to the new record based on the results of each of the relevant concordance tests\n        for ( ConcordanceType type : requestedTypes ) {\n            String result = type.computeConcordance(samplesToRecords, ref);\n            if ( result != null ) {\n                record.addInfoField(type.getInfoName(), result);\n            }\n        }\n\n        // emit the new record\n        vcfWriter.addRecord(record);\n\n        return 1;\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * get the genotype\n     *\n     * @return a map in lexigraphical order of the genotypes\n     */\n    @Override\n    public Genotype getCalledGenotype() {\n        double refQual = (this.getNegLog10PError());\n\n        if (this.mCurrentRecord != null && this.mCurrentRecord.hasGenotypeData()) {\n            List<VCFGenotypeRecord> lst = this.mCurrentRecord.getVCFGenotypeRecords();\n            if (lst.size() != 1) {\n                throw new IllegalStateException(\"VCF object does not have one and only one genotype record\");\n            }\n            double qual = 0;\n            if (lst.get(0).getAlleles().equals(this.getReference()))\n                qual = refQual;\n            else if (lst.get(0).getFields().containsKey(\"GQ\"))\n                qual = Double.valueOf(lst.get(0).getFields().get(\"GQ\")) / 10.0;\n            return new VCFGenotypeCall(this.getReference().charAt(0), this.getLocation(), Utils.join(\"\", lst.get(0).getAlleles()), qual, lst.get(0).getSampleName());\n        }\n        return null;\n    }","id":34195,"modified_method":"/**\n     * get the genotype\n     *\n     * @return a map in lexigraphical order of the genotypes\n     */\n    @Override\n    public Genotype getCalledGenotype() {\n        double refQual = (this.getNegLog10PError());\n\n        if (this.mCurrentRecord != null && this.mCurrentRecord.hasGenotypeData()) {\n            List<VCFGenotypeRecord> lst = this.mCurrentRecord.getVCFGenotypeRecords();\n            if (lst.size() != 1) {\n                throw new IllegalStateException(\"VCF object does not have one and only one genotype record\");\n            }\n            double qual = 0;\n            if (lst.get(0).getAlleles().equals(this.getReference()))\n                qual = refQual;\n            else if (lst.get(0).getFields().containsKey(\"GQ\"))\n                qual = Double.valueOf(lst.get(0).getFields().get(\"GQ\")) / 10.0;\n            int coverage = (lst.get(0).getFields().containsKey(\"RD\") ? Integer.valueOf(lst.get(0).getFields().get(\"RD\")) : 0);\n            return new VCFGenotypeCall(this.getReference().charAt(0), this.getLocation(), Utils.join(\"\", lst.get(0).getAlleles()), qual, coverage, lst.get(0).getSampleName());\n        }\n        return null;\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * get the genotypes\n     *\n     * @return a list of the genotypes\n     */\n    @Override\n    public List<Genotype> getGenotypes() {\n        List<Genotype> genotypes = new ArrayList<Genotype>();\n        if (!this.mCurrentRecord.hasGenotypeData()) {\n            return genotypes;\n        }\n        double refQual = (this.getNegLog10PError());\n        // add the reference\n        for (VCFGenotypeRecord rec : mCurrentRecord.getVCFGenotypeRecords()) {\n            double qual = 0;\n            if (rec.getAlleles().equals(this.getReference()))\n                qual = refQual;\n            else if (rec.getFields().containsKey(\"GQ\"))\n                qual = Double.valueOf(rec.getFields().get(\"GQ\")) / 10.0;\n            genotypes.add(new VCFGenotypeCall(this.getReference().charAt(0), this.getLocation(), Utils.join(\"\", rec.getAlleles()), qual, rec.getSampleName()));\n        }\n        return genotypes;\n    }","id":34196,"modified_method":"/**\n     * get the genotypes\n     *\n     * @return a list of the genotypes\n     */\n    @Override\n    public List<Genotype> getGenotypes() {\n        List<Genotype> genotypes = new ArrayList<Genotype>();\n        if (!this.mCurrentRecord.hasGenotypeData()) {\n            return genotypes;\n        }\n        double refQual = (this.getNegLog10PError());\n        // add the reference\n        for (VCFGenotypeRecord rec : mCurrentRecord.getVCFGenotypeRecords()) {\n            double qual = 0;\n            if (rec.getAlleles().equals(this.getReference()))\n                qual = refQual;\n            else if (rec.getFields().containsKey(\"GQ\"))\n                qual = Double.valueOf(rec.getFields().get(\"GQ\")) / 10.0;\n            int coverage = (rec.getFields().containsKey(\"RD\") ? Integer.valueOf(rec.getFields().get(\"RD\")) : 0);\n            genotypes.add(new VCFGenotypeCall(this.getReference().charAt(0), this.getLocation(), Utils.join(\"\", rec.getAlleles()), qual, coverage, rec.getSampleName()));\n        }\n        return genotypes;\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * a private helper method\n     *\n     * @return an array in lexigraphical order of the likelihoods\n     */\n    private Genotype getGenotype(DiploidGenotype x) {\n        if (x.toString().equals(getReference()))\n            return new BasicGenotype(this.getLocation(), getReference(), this.getReference().charAt(0), 0);\n        for (VCFGenotypeRecord record : mCurrentRecord.getVCFGenotypeRecords()) {\n            if (Utils.join(\"\", record.getAlleles()).equals(x.toString())) {\n                double qual = 0.0;\n                if (record.getAlleles().equals(this.getReference()))\n                    qual = this.getNegLog10PError();\n                else if (record.getFields().containsKey(\"GQ\"))\n                    qual = Double.valueOf(record.getFields().get(\"GQ\")) / 10.0;\n                return new VCFGenotypeCall(this.getReference().charAt(0), this.getLocation(), Utils.join(\"\", record.getAlleles()), qual, record.getSampleName());\n            }\n        }\n        return null;\n    }","id":34197,"modified_method":"/**\n     * a private helper method\n     *\n     * @return an array in lexigraphical order of the likelihoods\n     */\n    private Genotype getGenotype(DiploidGenotype x) {\n        if (x.toString().equals(getReference()))\n            return new BasicGenotype(this.getLocation(), getReference(), this.getReference().charAt(0), 0);\n        for (VCFGenotypeRecord record : mCurrentRecord.getVCFGenotypeRecords()) {\n            if (Utils.join(\"\", record.getAlleles()).equals(x.toString())) {\n                double qual = 0.0;\n                if (record.getAlleles().equals(this.getReference()))\n                    qual = this.getNegLog10PError();\n                else if (record.getFields().containsKey(\"GQ\"))\n                    qual = Double.valueOf(record.getFields().get(\"GQ\")) / 10.0;\n                int coverage = (record.getFields().containsKey(\"RD\") ? Integer.valueOf(record.getFields().get(\"RD\")) : 0);\n                return new VCFGenotypeCall(this.getReference().charAt(0), this.getLocation(), Utils.join(\"\", record.getAlleles()), qual, coverage, record.getSampleName());\n            }\n        }\n        return null;\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize(Map<String, String> args, Set<String> samples) {\n        if ( samples.size() != 2 )\n            throw new StingException(\"SNPGenotype concordance test cannot handle anything other than 2 VCF records\");\n\n        if ( args.get(\"lod\") != null )\n            LOD = Double.valueOf(args.get(\"lod\"));\n\n        Iterator<String> iter = samples.iterator();\n        sample1 = iter.next();\n        sample2 = iter.next();\n    }","id":34198,"modified_method":"public void initialize(Map<String, String> args, Set<String> samples) {\n        if ( samples.size() != 2 )\n            throw new StingException(\"SNPGenotype concordance test cannot handle anything other than 2 VCF records\");\n\n        if ( args.get(\"qscore\") != null )\n            Qscore = Double.valueOf(args.get(\"qscore\"));\n\n        Iterator<String> iter = samples.iterator();\n        sample1 = iter.next();\n        sample2 = iter.next();\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String computeConcordance(Map<String, VCFGenotypeCall> samplesToRecords, ReferenceContext ref) {\n\n        VCFGenotypeCall vcfCall1 = samplesToRecords.get(sample1);\n        VCFGenotypeCall vcfCall2 = samplesToRecords.get(sample2);\n        Variation call1 = (vcfCall1 == null ? null : vcfCall1.toVariation());\n        Variation call2 = (vcfCall2 == null ? null : vcfCall2.toVariation());\n\n        // the only reason they would be null is a lack of coverage\n        if ( call1 == null || call2 == null ) {\n            if ( call1 != null && call1.isSNP() && call1.getNegLog10PError() >= LOD )\n                return \"set1ConfidentVariantSet2NoCoverage\";\n            else if ( call2 != null && call2.isSNP() && call2.getNegLog10PError() >= LOD )\n                return \"set1NoCoverageSet2ConfidentVariant\";\n            return null;\n        }\n        if (!(call1 instanceof VariantBackedByGenotype) || !(call2 instanceof VariantBackedByGenotype))\n                    throw new StingException(\"Both ROD tracks must be backed by genotype data. Ensure that your rod(s) contain genotyping information\");\n\n        double bestVsRef1 = call1.getNegLog10PError();\n        double bestVsRef2 = call2.getNegLog10PError();\n        String genotype1 = ((VariantBackedByGenotype)call1).getCalledGenotype().getBases();\n        String genotype2 = ((VariantBackedByGenotype)call2).getCalledGenotype().getBases();\n\n        // are they both variant SNPs?\n        if ( call1.isSNP() && call2.isSNP() ) {\n\n            // are they both confident calls?\n            if ( bestVsRef1 >= LOD && bestVsRef2 >= LOD ) {\n                // same genotype\n                if ( genotype1.equals(genotype2) )\n                    return \"sameConfidentVariant\";\n\n                // same allele, different genotype\n                else if ( sameVariantAllele(genotype1, genotype2, ref.getBase()) )\n                    return \"sameVariantAlleleDifferentGenotype\";\n\n                // different variant allele\n                else\n                    return \"differentVariantAllele\";\n            }\n\n            // confident only when combined\n            else if ( bestVsRef1 < LOD && bestVsRef2 < LOD && bestVsRef1 + bestVsRef2 >= LOD ) {\n                return \"confidentVariantWhenCombined\";\n            }\n\n            // only one is confident variant\n            else if ( (bestVsRef1 < LOD && bestVsRef2 >= LOD) || (bestVsRef1 >= LOD && bestVsRef2 < LOD) ) {\n                return \"bothVariantOnlyOneIsConfident\";\n            }\n        }\n\n        // one is variant and the other is ref\n        else if ( call1.isSNP() && call2.isReference() && bestVsRef1 >= LOD )\n             return \"set1VariantSet2Ref\";\n        else if ( call2.isSNP() && call1.isReference() && bestVsRef2 >= LOD )\n            return \"set1RefSet2Variant\";\n\n        return null;\n    }","id":34199,"modified_method":"public String computeConcordance(Map<String, VCFGenotypeCall> samplesToRecords, ReferenceContext ref) {\n\n        VCFGenotypeCall call1 = samplesToRecords.get(sample1);\n        VCFGenotypeCall call2 = samplesToRecords.get(sample2);\n\n        // the only reason they would be null is a lack of coverage\n        if ( call1 == null || call2 == null ) {\n            if ( call1 != null && call1.isPointGenotype() && (10.0 * call1.getNegLog10PError()) >= Qscore )\n                return \"set1ConfidentVariantSet2NoCoverage\";\n            else if ( call2 != null && call2.isPointGenotype() && (10.0 * call2.getNegLog10PError()) >= Qscore )\n                return \"set1NoCoverageSet2ConfidentVariant\";\n            return null;\n        }\n\n        double confidence1 = 10.0 * call1.getNegLog10PError();\n        double confidence2 = 10.0 * call2.getNegLog10PError();\n        String genotype1 = call1.getBases();\n        String genotype2 = call2.getBases();\n\n        // are they both variant SNPs?\n        if ( call1.isPointGenotype() && call2.isPointGenotype() ) {\n\n            // are they both confident calls?\n            if ( confidence1 >= Qscore && confidence2 >= Qscore ) {\n                // same genotype\n                if ( genotype1.equals(genotype2) )\n                    return \"sameConfidentVariant\";\n\n                // same allele, different genotype\n                else if ( sameVariantAllele(genotype1, genotype2, ref.getBase()) )\n                    return \"sameVariantAlleleDifferentGenotype\";\n\n                // different variant allele\n                else\n                    return \"differentVariantAllele\";\n            }\n\n            // confident only when combined\n            else if ( confidence1 < Qscore && confidence2 < Qscore && confidence1 + confidence2 >= Qscore ) {\n                return \"confidentVariantWhenCombined\";\n            }\n\n            // only one is confident variant\n            else if ( (confidence1 < Qscore && confidence2 >= Qscore) || (confidence1 >= Qscore && confidence2 < Qscore) ) {\n                return \"bothVariantOnlyOneIsConfident\";\n            }\n        }\n\n        // one is variant and the other is ref\n        else if ( call1.isPointGenotype() && call2.isVariant() && confidence1 >= Qscore )\n             return \"set1VariantSet2Ref\";\n        else if ( call2.isPointGenotype() && call1.isVariant() && confidence2 >= Qscore )\n            return \"set1RefSet2Variant\";\n\n        return null;\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * get the count of reads\n     *\n     * @return the number of reads we're backed by\n     */\n    public int getReadCount() {\n        return mReads.size();\n    }","id":34200,"modified_method":"/**\n     * get the count of reads\n     *\n     * @return the number of reads we're backed by\n     */\n    public int getReadCount() {\n       return (mCoverage > 0 ? mCoverage : mReads.size());\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"public VCFGenotypeCall(char ref, GenomeLoc loc, String genotype, double negLog10PError, String sample) {\n        mRefBase = ref;\n        mLocation = loc;\n        mBestGenotype = DiploidGenotype.unorderedValueOf(genotype);\n        mRefGenotype = DiploidGenotype.createHomGenotype(ref);\n        mSampleName = sample;\n\n        // set general posteriors to min double value\n        mPosteriors = new double[10];\n        Arrays.fill(mPosteriors, Double.MIN_VALUE);\n\n        // set the ref to PError\n        mPosteriors[mRefGenotype.ordinal()] = -1.0 * negLog10PError;\n\n        // set the best genotype to zero (need to do this after ref in case ref=best)\n        mPosteriors[mBestGenotype.ordinal()] = 0.0;\n\n        // choose a smart next best genotype and set it to PError\n        if ( mBestGenotype == mRefGenotype )\n            mNextGenotype = DiploidGenotype.valueOf(BaseUtils.simpleComplement(genotype));\n        else\n            mNextGenotype = mRefGenotype;\n        mPosteriors[mNextGenotype.ordinal()] = -1.0 * negLog10PError;\n\n        mReads = new ArrayList<SAMRecord>();\n    }","id":34201,"modified_method":"public VCFGenotypeCall(char ref, GenomeLoc loc, String genotype, double negLog10PError, int coverage, String sample) {\n        mRefBase = ref;\n        mLocation = loc;\n        mBestGenotype = DiploidGenotype.unorderedValueOf(genotype);\n        mRefGenotype = DiploidGenotype.createHomGenotype(ref);\n        mSampleName = sample;\n        mCoverage = coverage;\n\n        // set general posteriors to min double value\n        mPosteriors = new double[10];\n        Arrays.fill(mPosteriors, Double.MIN_VALUE);\n\n        // set the ref to PError\n        mPosteriors[mRefGenotype.ordinal()] = -1.0 * negLog10PError;\n\n        // set the best genotype to zero (need to do this after ref in case ref=best)\n        mPosteriors[mBestGenotype.ordinal()] = 0.0;\n\n        // choose a smart next best genotype and set it to PError\n        if ( mBestGenotype == mRefGenotype )\n            mNextGenotype = DiploidGenotype.valueOf(BaseUtils.simpleComplement(genotype));\n        else\n            mNextGenotype = mRefGenotype;\n        mPosteriors[mNextGenotype.ordinal()] = -1.0 * negLog10PError;\n\n        mReads = new ArrayList<SAMRecord>();\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Generate a single sample genotype object\n     *\n     */\n    public VCFGenotypeCall(char ref, GenomeLoc loc) {\n        mRefBase = ref;\n        mLocation = loc;\n\n        // fill in empty data\n        mPosteriors = new double[10];\n        Arrays.fill(mPosteriors, Double.MIN_VALUE);\n        mSampleName = \"\";\n        mReads = new ArrayList<SAMRecord>();\n    }","id":34202,"modified_method":"public VCFGenotypeCall(char ref, GenomeLoc loc) {\n        mRefBase = ref;\n        mLocation = loc;\n\n        // fill in empty data\n        mPosteriors = new double[10];\n        Arrays.fill(mPosteriors, Double.MIN_VALUE);\n        mSampleName = \"\";\n        mReads = new ArrayList<SAMRecord>();\n    }","commit_id":"74751a8ed37c95b4fc700f6b1a5c5ba162d91f76","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean hasNegLog10PError() {\n        return getNegLog10PError() == NO_NEG_LOG_10PERROR;\n    }","id":34203,"modified_method":"public boolean hasNegLog10PError() {\n        return getNegLog10PError() != NO_NEG_LOG_10PERROR;\n    }","commit_id":"9a6b384adb80fc61f35a702ed385ebe7a52ec8db","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String update1(VariantContext vc, RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( vc.isBiallelic() && vc.hasGenotypes() ) { // todo -- currently limited to biallelic loci\n            nVariants++;\n\n            Genotype momG   = vc.getGenotype(trio.mom);\n            Genotype dadG   = vc.getGenotype(trio.dad);\n            Genotype childG = vc.getGenotype(trio.child);\n\n            if ( momG == null || dadG == null || childG == null )\n                throw new IllegalArgumentException(String.format(\"VariantContext didn't contain genotypes for expected trio members: mom=%s dad=%s child=%s\", trio.mom, trio.dad, trio.child));\n\n            if ( includeGenotype(momG) && includeGenotype(dadG) && includeGenotype(childG) ) {\n                // all genotypes are good, so let's see if child is a violation\n\n                if ( isViolation(vc, momG, dadG, childG) ) {\n                    nViolations++;\n\n                    String label = null;\n                    if ( childG.isHomRef() && (momG.isHomVar() || dadG.isHomVar() )) {\n                        label = \"KidHomRef_ParentHomVar\";\n                        KidHomRef_ParentHomVar++;\n                    } else if (childG.isHet() && (momG.isHomRef() && dadG.isHomRef()) ) {\n                        label = \"KidHet_ParentsHomRef\";\n                        KidHet_ParentsHomRef++;\n                    } else if (childG.isHet() && (momG.isHomVar() && dadG.isHomVar()) ) {\n                        label = \"KidHet_ParentsHomVar\";\n                        KidHet_ParentsHomVar++;\n                    } else if (childG.isHomVar() && (momG.isHomRef() || dadG.isHomRef())) {\n                        label = \"KidHomVar_ParentHomRef\";\n                        KidHomVar_ParentHomRef++;\n                    } else {\n                        throw new StingException(\"BUG: unexpected child genotype class \" + childG);\n                    }\n\n                    return label;\n                }\n            }\n        }\n\n        return null; // we don't capture any intersting sites\n    }","id":34204,"modified_method":"public String update1(VariantContext vc, RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        if ( vc.isBiallelic() && vc.hasGenotypes() ) { // todo -- currently limited to biallelic loci\n            Genotype momG   = vc.getGenotype(trio.mom);\n            Genotype dadG   = vc.getGenotype(trio.dad);\n            Genotype childG = vc.getGenotype(trio.child);\n\n            if ( includeGenotype(momG) && includeGenotype(dadG) && includeGenotype(childG) ) {\n                nVariants++;\n\n                if ( momG == null || dadG == null || childG == null )\n                    throw new IllegalArgumentException(String.format(\"VariantContext didn't contain genotypes for expected trio members: mom=%s dad=%s child=%s\", trio.mom, trio.dad, trio.child));\n\n                // all genotypes are good, so let's see if child is a violation\n\n                if ( isViolation(vc, momG, dadG, childG) ) {\n                    nViolations++;\n\n                    String label = null;\n                    if ( childG.isHomRef() && (momG.isHomVar() || dadG.isHomVar() )) {\n                        label = \"KidHomRef_ParentHomVar\";\n                        KidHomRef_ParentHomVar++;\n                    } else if (childG.isHet() && (momG.isHomRef() && dadG.isHomRef()) ) {\n                        label = \"KidHet_ParentsHomRef\";\n                        KidHet_ParentsHomRef++;\n                    } else if (childG.isHet() && (momG.isHomVar() && dadG.isHomVar()) ) {\n                        label = \"KidHet_ParentsHomVar\";\n                        KidHet_ParentsHomVar++;\n                    } else if (childG.isHomVar() && (momG.isHomRef() || dadG.isHomRef())) {\n                        label = \"KidHomVar_ParentHomRef\";\n                        KidHomVar_ParentHomRef++;\n                    } else {\n                        throw new StingException(\"BUG: unexpected child genotype class \" + childG);\n                    }\n\n                    return label;\n                }\n            }\n        }\n\n        return null; // we don't capture any intersting sites\n    }","commit_id":"9a6b384adb80fc61f35a702ed385ebe7a52ec8db","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static VariantContext vcfToVariantContext(String name, VCFRecord vcf) {\n        if ( vcf.isSNP() || vcf.isIndel() ) {\n            // add the reference allele\n            if ( ! Allele.acceptableAlleleBases(vcf.getReference()) ) {\n                System.out.printf(\"Excluding vcf record %s%n\", vcf);\n                return null;\n            }\n\n            Set<String> filters = vcf.isFiltered() ? new HashSet<String>(Arrays.asList(vcf.getFilteringCodes())) : null;\n            Map<String, String> attributes = vcf.getInfoValues();\n            attributes.put(\"ID\", vcf.getID());\n\n            // add all of the alt alleles\n            List<Allele> alleles = new ArrayList<Allele>();\n            Allele refAllele = new Allele(vcf.getReference(), true);\n            alleles.add(refAllele);\n            for ( String alt : vcf.getAlternateAlleleList() ) {\n                if ( ! Allele.acceptableAlleleBases(alt) ) {\n                    // todo -- cleanup\n                    System.out.printf(\"Excluding vcf record %s%n\", vcf);\n                    return null;\n                }\n                alleles.add(new Allele(alt, false));\n            }\n\n            Map<String, Genotype> genotypes = new HashMap<String, Genotype>();\n            for ( VCFGenotypeRecord vcfG : vcf.getVCFGenotypeRecords() ) {\n                List<Allele> genotypeAlleles = new ArrayList<Allele>();\n                for ( VCFGenotypeEncoding s : vcfG.getAlleles() ) {\n                    Allele a = Allele.getMatchingAllele(alleles, s.getBases());\n                    if ( a == null )\n                        throw new StingException(\"Invalid VCF genotype allele \" + s + \" in VCF \" + vcf);\n\n                    genotypeAlleles.add(a);\n                }\n\n                double pError = vcfG.getNegLog10PError() == VCFGenotypeRecord.MISSING_GENOTYPE_QUALITY ? Genotype.NO_NEG_LOG_10PERROR : vcfG.getNegLog10PError();\n\n                Map<String, String> fields = new HashMap<String, String>();\n                for ( Map.Entry<String, String> e : vcfG.getFields().entrySet() ) {\n                    // todo -- fixme if we put GQ and GF into key itself\n                    if ( ! e.getKey().equals(VCFGenotypeRecord.GENOTYPE_QUALITY_KEY) && ! e.getKey().equals(VCFGenotypeRecord.GENOTYPE_FILTER_KEY) )\n                        fields.put(e.getKey(), e.getValue());\n                }\n\n                Set<String> genotypeFilters = new HashSet<String>();\n                if ( vcfG.isFiltered() ) // setup the FL genotype filter fields\n                    genotypeFilters.addAll(Arrays.asList(vcfG.getFields().get(VCFGenotypeRecord.GENOTYPE_FILTER_KEY).split(\";\")));\n\n                Genotype g = new Genotype(vcfG.getSampleName(), genotypeAlleles, pError, genotypeFilters, fields, vcfG.getPhaseType() == VCFGenotypeRecord.PHASE.PHASED);\n                genotypes.put(g.getSampleName(), g);\n            }\n\n            VariantContext vc = new VariantContext(name, vcf.getLocation(), alleles, genotypes, vcf.getNegLog10PError(), filters, attributes);\n            vc.validate();\n            return vc;\n        } else\n            return null; // can't handle anything else\n    }","id":34205,"modified_method":"private static VariantContext vcfToVariantContext(String name, VCFRecord vcf) {\n        if ( vcf.isSNP() || vcf.isIndel() ) {\n            // add the reference allele\n            if ( ! Allele.acceptableAlleleBases(vcf.getReference()) ) {\n                System.out.printf(\"Excluding vcf record %s%n\", vcf);\n                return null;\n            }\n\n            Set<String> filters = vcf.isFiltered() ? new HashSet<String>(Arrays.asList(vcf.getFilteringCodes())) : null;\n            Map<String, String> attributes = vcf.getInfoValues();\n            attributes.put(\"ID\", vcf.getID());\n\n            // add all of the alt alleles\n            List<Allele> alleles = new ArrayList<Allele>();\n            Allele refAllele = new Allele(vcf.getReference(), true);\n            alleles.add(refAllele);\n            for ( String alt : vcf.getAlternateAlleleList() ) {\n                if ( ! Allele.acceptableAlleleBases(alt) ) {\n                    // todo -- cleanup\n                    System.out.printf(\"Excluding vcf record %s%n\", vcf);\n                    return null;\n                }\n                alleles.add(new Allele(alt, false));\n            }\n\n            Map<String, Genotype> genotypes = new HashMap<String, Genotype>();\n            for ( VCFGenotypeRecord vcfG : vcf.getVCFGenotypeRecords() ) {\n                List<Allele> genotypeAlleles = new ArrayList<Allele>();\n                for ( VCFGenotypeEncoding s : vcfG.getAlleles() ) {\n                    Allele a = Allele.getMatchingAllele(alleles, s.getBases());\n                    if ( a == null )\n                        throw new StingException(\"Invalid VCF genotype allele \" + s + \" in VCF \" + vcf);\n\n                    genotypeAlleles.add(a);\n                }\n\n                double pError = vcfG.getNegLog10PError() == VCFGenotypeRecord.MISSING_GENOTYPE_QUALITY ? Genotype.NO_NEG_LOG_10PERROR : vcfG.getNegLog10PError();\n\n                Map<String, String> fields = new HashMap<String, String>();\n                for ( Map.Entry<String, String> e : vcfG.getFields().entrySet() ) {\n                    // todo -- fixme if we put GQ and GF into key itself\n                    if ( ! e.getKey().equals(VCFGenotypeRecord.GENOTYPE_QUALITY_KEY) && ! e.getKey().equals(VCFGenotypeRecord.GENOTYPE_FILTER_KEY) )\n                        fields.put(e.getKey(), e.getValue());\n                }\n\n                Set<String> genotypeFilters = new HashSet<String>();\n                if ( vcfG.isFiltered() ) // setup the FL genotype filter fields\n                    genotypeFilters.addAll(Arrays.asList(vcfG.getFields().get(VCFGenotypeRecord.GENOTYPE_FILTER_KEY).split(\";\")));\n\n                Genotype g = new Genotype(vcfG.getSampleName(), genotypeAlleles, pError, genotypeFilters, fields, vcfG.getPhaseType() == VCFGenotypeRecord.PHASE.PHASED);\n                genotypes.put(g.getSampleName(), g);\n            }\n\n            double qual = vcf.getQual() == -1 ? VariantContext.NO_NEG_LOG_10PERROR : vcf.getNegLog10PError();\n            VariantContext vc = new VariantContext(name, vcf.getLocation(), alleles, genotypes, qual, filters, attributes);\n            vc.validate();\n            return vc;\n        } else\n            return null; // can't handle anything else\n    }","commit_id":"9a6b384adb80fc61f35a702ed385ebe7a52ec8db","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static VCFRecord toVCF(VariantContext vc) {\n        // deal with the reference\n        char referenceBase = 'N'; // by default we'll use N\n        if ( vc.getReference().length() == 1 ) {\n            referenceBase = (char)vc.getReference().getBases()[0];\n        }\n\n        if ( ! vc.isSNP() )\n            // todo -- update the code so it works correctly with indels\n            throw new StingException(\"VariantContext -> VCF converter currently doesn't support indels; complain to the GATK team\");\n\n        String contig = vc.getLocation().getContig();\n        long position = vc.getLocation().getStart();\n        String ID = vc.hasAttribute(\"ID\") ? vc.getAttributeAsString(\"ID\") : \".\";\n        double qual = vc.getPhredScaledQual();\n        String filters = vc.isFiltered() ? Utils.join(\";\", Utils.sorted(vc.getFilters())) : VCFRecord.PASSES_FILTERS;\n\n        Map<Allele, VCFGenotypeEncoding> alleleMap = new HashMap<Allele, VCFGenotypeEncoding>();\n        alleleMap.put(Allele.NO_CALL, new VCFGenotypeEncoding(VCFGenotypeRecord.EMPTY_ALLELE)); // convenience for lookup\n        List<VCFGenotypeEncoding> vcfAltAlleles = new ArrayList<VCFGenotypeEncoding>();\n        for ( Allele a : vc.getAlleles() ) {\n            VCFGenotypeEncoding encoding = new VCFGenotypeEncoding(new String(a.getBases()));\n            if ( a.isNonReference() ) {\n                vcfAltAlleles.add(encoding);\n            }\n            alleleMap.put(a, encoding);\n        }\n\n        List<String> vcfGenotypeAttributeKeys = new ArrayList<String>(Arrays.asList(VCFGenotypeRecord.GENOTYPE_KEY));\n        List<String> vcGenotypeKeys = calcVCFGenotypeKeys(vc);\n        if ( vc.hasGenotypes() ) vcfGenotypeAttributeKeys.addAll(vcGenotypeKeys);\n        String genotypeFormatString = Utils.join(VCFRecord.GENOTYPE_FIELD_SEPERATOR, vcfGenotypeAttributeKeys);\n\n        List<VCFGenotypeRecord> genotypeObjects = new ArrayList<VCFGenotypeRecord>(vc.getGenotypes().size());\n        for ( Genotype g : vc.getGenotypesSortedByName() ) {\n            List<VCFGenotypeEncoding> encodings = new ArrayList<VCFGenotypeEncoding>(g.getPloidy());\n            for ( Allele a : g.getAlleles() ) {\n                encodings.add(alleleMap.get(a));\n            }\n\n            VCFGenotypeRecord.PHASE phasing = g.genotypesArePhased() ? VCFGenotypeRecord.PHASE.PHASED : VCFGenotypeRecord.PHASE.UNPHASED;\n            VCFGenotypeRecord vcfG = new VCFGenotypeRecord(g.getSampleName(), encodings, phasing);\n\n            if ( ! g.isNoCall() ) {\n                for ( String key : vcGenotypeKeys ) {\n                    String val = key.equals(VCFGenotypeRecord.GENOTYPE_QUALITY_KEY) ? String.format(\"%.2f\", g.getPhredScaledQual()) : g.getAttribute(key).toString();\n                    vcfG.setField(key, val);\n                }\n            }\n\n            genotypeObjects.add(vcfG);\n        }\n\n        // info fields\n        Map<String, String> infoFields = new HashMap<String, String>();\n        for ( Map.Entry<String, Object> elt : vc.getAttributes().entrySet() ) {\n            String key = elt.getKey();\n            String val = elt.getValue().toString();\n            if ( ! key.equals(\"ID\") ) {\n                infoFields.put(key, val);\n            }\n        }\n\n        return new VCFRecord(referenceBase, contig, position, ID, vcfAltAlleles, qual, filters, infoFields, genotypeFormatString, genotypeObjects);\n    }","id":34206,"modified_method":"public static VCFRecord toVCF(VariantContext vc) {\n        // deal with the reference\n        char referenceBase = 'N'; // by default we'll use N\n        if ( vc.getReference().length() == 1 ) {\n            referenceBase = (char)vc.getReference().getBases()[0];\n        }\n\n        if ( ! vc.isSNP() )\n            // todo -- update the code so it works correctly with indels\n            throw new StingException(\"VariantContext -> VCF converter currently doesn't support indels; complain to the GATK team\");\n\n        String contig = vc.getLocation().getContig();\n        long position = vc.getLocation().getStart();\n        String ID = vc.hasAttribute(\"ID\") ? vc.getAttributeAsString(\"ID\") : \".\";\n        double qual = vc.hasNegLog10PError() ? vc.getPhredScaledQual() : -1;\n        \n        String filters = vc.isFiltered() ? Utils.join(\";\", Utils.sorted(vc.getFilters())) : VCFRecord.PASSES_FILTERS;\n\n        Map<Allele, VCFGenotypeEncoding> alleleMap = new HashMap<Allele, VCFGenotypeEncoding>();\n        alleleMap.put(Allele.NO_CALL, new VCFGenotypeEncoding(VCFGenotypeRecord.EMPTY_ALLELE)); // convenience for lookup\n        List<VCFGenotypeEncoding> vcfAltAlleles = new ArrayList<VCFGenotypeEncoding>();\n        for ( Allele a : vc.getAlleles() ) {\n            VCFGenotypeEncoding encoding = new VCFGenotypeEncoding(new String(a.getBases()));\n            if ( a.isNonReference() ) {\n                vcfAltAlleles.add(encoding);\n            }\n            alleleMap.put(a, encoding);\n        }\n\n        List<String> vcfGenotypeAttributeKeys = new ArrayList<String>(Arrays.asList(VCFGenotypeRecord.GENOTYPE_KEY));\n        List<String> vcGenotypeKeys = calcVCFGenotypeKeys(vc);\n        if ( vc.hasGenotypes() ) vcfGenotypeAttributeKeys.addAll(vcGenotypeKeys);\n        String genotypeFormatString = Utils.join(VCFRecord.GENOTYPE_FIELD_SEPERATOR, vcfGenotypeAttributeKeys);\n\n        List<VCFGenotypeRecord> genotypeObjects = new ArrayList<VCFGenotypeRecord>(vc.getGenotypes().size());\n        for ( Genotype g : vc.getGenotypesSortedByName() ) {\n            List<VCFGenotypeEncoding> encodings = new ArrayList<VCFGenotypeEncoding>(g.getPloidy());\n            for ( Allele a : g.getAlleles() ) {\n                encodings.add(alleleMap.get(a));\n            }\n\n            VCFGenotypeRecord.PHASE phasing = g.genotypesArePhased() ? VCFGenotypeRecord.PHASE.PHASED : VCFGenotypeRecord.PHASE.UNPHASED;\n            VCFGenotypeRecord vcfG = new VCFGenotypeRecord(g.getSampleName(), encodings, phasing);\n\n            if ( ! g.isNoCall() ) {\n                for ( String key : vcGenotypeKeys ) {\n                    String val = key.equals(VCFGenotypeRecord.GENOTYPE_QUALITY_KEY) ? String.format(\"%.2f\", g.getPhredScaledQual()) : g.getAttribute(key).toString();\n                    vcfG.setField(key, val);\n                }\n            }\n\n            genotypeObjects.add(vcfG);\n        }\n\n        // info fields\n        Map<String, String> infoFields = new HashMap<String, String>();\n        for ( Map.Entry<String, Object> elt : vc.getAttributes().entrySet() ) {\n            String key = elt.getKey();\n            String val = elt.getValue().toString();\n            if ( ! key.equals(\"ID\") ) {\n                infoFields.put(key, val);\n            }\n        }\n\n        return new VCFRecord(referenceBase, contig, position, ID, vcfAltAlleles, qual, filters, infoFields, genotypeFormatString, genotypeObjects);\n    }","commit_id":"9a6b384adb80fc61f35a702ed385ebe7a52ec8db","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testVE2Complex() {\n        HashMap<String, String> expectations = new HashMap<String, String>();\n        String extraArgs1 = \"-L \" + validationDataLocation + \"chr1_b36_pilot3.interval_list -family NA19238+NA19239=NA19240 -MVQ 30\" +\n                \" -B dbsnp_130,dbSNP,\" + GATKDataLocation + \"dbsnp_130_b36.rod\" +\n                \" -B comp_hapmap,VCF,\" + validationDataLocation + \"CEU_hapmap_nogt_23.vcf\";\n\n        String eqMD5s = \"380e082222111c7bf962095d9afca8da\"; // next two examples should be the same!\n        expectations.put(\"\", eqMD5s);\n        expectations.put(\" -known comp_hapmap -known dbsnp\", eqMD5s);\n        expectations.put(\" -known comp_hapmap\", \"90d7d4d0ff370e9457978b2869782aa0\");\n\n        for ( Map.Entry<String, String> entry : expectations.entrySet() ) {\n            String extraArgs2 = entry.getKey();\n            String md5 = entry.getValue();\n\n            WalkerTestSpec spec = new WalkerTestSpec( root + \" \" + extraArgs1 + extraArgs2 + \" -o %s\",\n                    1, // just one output file\n                    Arrays.asList(md5));\n            executeTest(\"testVE2Complex\", spec);\n        }\n    }","id":34207,"modified_method":"@Test\n    public void testVE2Complex() {\n        HashMap<String, String> expectations = new HashMap<String, String>();\n        String extraArgs1 = \"-L \" + validationDataLocation + \"chr1_b36_pilot3.interval_list -family NA19238+NA19239=NA19240 -MVQ 30\" +\n                \" -B dbsnp_130,dbSNP,\" + GATKDataLocation + \"dbsnp_130_b36.rod\" +\n                \" -B comp_hapmap,VCF,\" + validationDataLocation + \"CEU_hapmap_nogt_23.vcf\";\n\n        String eqMD5s = \"1606e285d9bd586dc6662b1ace0a3a0e\"; // next two examples should be the same!\n        expectations.put(\"\", eqMD5s);\n        expectations.put(\" -known comp_hapmap -known dbsnp\", eqMD5s);\n        expectations.put(\" -known comp_hapmap\", \"44773a96d1c5904a57e0e983836768e4\");\n\n        for ( Map.Entry<String, String> entry : expectations.entrySet() ) {\n            String extraArgs2 = entry.getKey();\n            String md5 = entry.getValue();\n\n            WalkerTestSpec spec = new WalkerTestSpec( root + \" \" + extraArgs1 + extraArgs2 + \" -o %s\",\n                    1, // just one output file\n                    Arrays.asList(md5));\n            executeTest(\"testVE2Complex\", spec);\n        }\n    }","commit_id":"9a6b384adb80fc61f35a702ed385ebe7a52ec8db","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testVE2Simple() {\n        HashMap<String, String> expectations = new HashMap<String, String>();\n        expectations.put(\"-L 1:1-10,000,000\", \"d58a2a22e5fb3a3d8d90ba02de37f62b\");\n        expectations.put(\"-L 1:1-10,000,000 -family NA19238+NA19239=NA19240 -MVQ 0\", \"8a928c8ad99428445e53b0b83f8ccdfa\");\n\n        for ( Map.Entry<String, String> entry : expectations.entrySet() ) {\n            String extraArgs = entry.getKey();\n            String md5 = entry.getValue();\n\n            WalkerTestSpec spec = new WalkerTestSpec( root + \" \" + extraArgs + \" -o %s\",\n                    1, // just one output file\n                    Arrays.asList(md5));\n            executeTest(\"testVE2Simple\", spec);\n        }\n    }","id":34208,"modified_method":"@Test\n    public void testVE2Simple() {\n        HashMap<String, String> expectations = new HashMap<String, String>();\n        expectations.put(\"-L 1:1-10,000,000\", \"d58a2a22e5fb3a3d8d90ba02de37f62b\");\n        expectations.put(\"-L 1:1-10,000,000 -family NA19238+NA19239=NA19240 -MVQ 0\", \"03cddae2afbe0d1a8f5e3490aebc7c9c\");\n\n        for ( Map.Entry<String, String> entry : expectations.entrySet() ) {\n            String extraArgs = entry.getKey();\n            String md5 = entry.getValue();\n\n            WalkerTestSpec spec = new WalkerTestSpec( root + \" \" + extraArgs + \" -o %s\",\n                    1, // just one output file\n                    Arrays.asList(md5));\n            executeTest(\"testVE2Simple\", spec);\n        }\n    }","commit_id":"9a6b384adb80fc61f35a702ed385ebe7a52ec8db","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testVE2WriteVCF() {\n        String extraArgs = \"-L 1:1-10,000,000 -family NA19238+NA19239=NA19240 -MVQ 30\";\n        WalkerTestSpec spec = new WalkerTestSpec( root + \" \" + extraArgs + \" -o %s -outputVCF %s\",\n                2,\n                Arrays.asList(\"b7d52d13e6eb3d593395a644583e449a\", \"9ec81f7389c0971e44e4b8d2d4af3008\"));\n        executeTest(\"testVE2WriteVCF\", spec);\n    }","id":34209,"modified_method":"@Test\n    public void testVE2WriteVCF() {\n        String extraArgs = \"-L 1:1-10,000,000 -family NA19238+NA19239=NA19240 -MVQ 30\";\n        WalkerTestSpec spec = new WalkerTestSpec( root + \" \" + extraArgs + \" -o %s -outputVCF %s\",\n                2,\n                Arrays.asList(\"1f2e04f8af061b7190758679a7840f12\", \"9ec81f7389c0971e44e4b8d2d4af3008\"));\n        executeTest(\"testVE2WriteVCF\", spec);\n    }","commit_id":"9a6b384adb80fc61f35a702ed385ebe7a52ec8db","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n\t * Gets the value of a commandline option \n\t * @param arg The command line argument\n\t * @return The value of the commandline option specified.\n\t */\n\tpublic String extractAndSetArgument(String arg)\n\t{\n\t\tString optionStart[] = new String[] { \"-\", \"/\" };\n\t\tString optionDelim[] = new String[] { \"=\", \":\" };\n\n\t\tfor (int s = 0; s < optionStart.length; s++)\n\t\t{\n\t\t\tint osLength = optionStart[s].length();\n\t\t\tfor (int d = 0; d < optionDelim.length; d++)\n\t\t\t{\n\t\t\t\tint optLength = optionDelim[d].length();\n\t\t\t\tif (arg != null && arg.length()>osLength && arg.toUpperCase().substring(osLength).startsWith(option.toUpperCase()))\n\t\t\t\t{\n\t\t\t\t\t// OK, this is it.\n\t\t\t\t\t// Do we expect anything after this? \n\t\t\t\t\t// after the start, the option and the delimiter?\n\t\t\t\t\t//\n\t\t\t\t\tString value =null;\n\t\t\t\t\tint valueStart = osLength+option.length()+optLength;\n\n\t\t\t\t\t// System.out.println(\"Arg: [\"+arg+\"], option: [\"+option+\"], valueStart: \"+valueStart);\n\t\t\t\t\t//\n\t\t\t\t\tif (arg.length()>=valueStart)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue = arg.substring(valueStart);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// If it's a Y/N kind of deal: set it to Y if nothing was specified\n\t\t\t\t\tif ((value==null || value.length()==0) && yesNo)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue=\"Y\";\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Add it to the StringBuffer\n\t\t\t\t\targument.append(value);\n\t\t\t\t\t\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":34210,"modified_method":"/**\n\t * Gets the value of a commandline option \n\t * @param arg The command line argument\n\t * @return The value of the commandline option specified.\n\t */\n\tpublic String extractAndSetArgument(String arg)\n\t{\n\t\tString optionStart[] = new String[] { \"-\", \"/\" };\n\t\tString optionDelim[] = new String[] { \"=\", \":\" };\n\n\t\tfor (int s = 0; s < optionStart.length; s++)\n\t\t{\n\t\t\tint osLength = optionStart[s].length();\n\t\t\tfor (int d = 0; d < optionDelim.length; d++)\n\t\t\t{\n\t\t\t\tint optLength = optionDelim[d].length();\n\t\t\t\tif (arg != null && arg.length()>osLength && arg.toUpperCase().substring(osLength).equals(option.toUpperCase()))\n\t\t\t\t{\n\t\t\t\t\t// OK, this is it.\n\t\t\t\t\t// Do we expect anything after this? \n\t\t\t\t\t// after the start, the option and the delimiter?\n\t\t\t\t\t//\n\t\t\t\t\tString value =null;\n\t\t\t\t\tint valueStart = osLength+option.length()+optLength;\n\n\t\t\t\t\t// System.out.println(\"Arg: [\"+arg+\"], option: [\"+option+\"], valueStart: \"+valueStart);\n\t\t\t\t\t//\n\t\t\t\t\tif (arg.length()>=valueStart)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue = arg.substring(valueStart);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// If it's a Y/N kind of deal: set it to Y if nothing was specified\n\t\t\t\t\tif ((value==null || value.length()==0) && yesNo)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue=\"Y\";\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Add it to the StringBuffer\n\t\t\t\t\targument.append(value);\n\t\t\t\t\t\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"0088be4e22c307736121a65b9ceb4624a8f134b8","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Parse and set the command line arguments using the defined options\n\t * @param args The list of arguments to parse\n\t * @param options The command line options to use\n\t */\n\tpublic static void parseArguments(List<String> args, CommandLineOption[] options)\n\t{\n\t\tfor (int i=0;i<options.length;i++)\n\t\t{\n\t\t\tboolean found=false;\n\t\t\tfor (int j=0;j<args.size() && !found;j++)\n\t\t\t{\n\t\t\t\tString argument = options[i].extractAndSetArgument((String)args.get(j));\n\t\t\t\tif (argument!=null) \n\t\t\t\t{\n\t\t\t\t\tfound=true;\n\t\t\t\t\targs.remove(j); // We covered it: remove from the list\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }","id":34211,"modified_method":"/**\n\t * Parse and set the command line arguments using the defined options\n\t * @param args The list of arguments to parse\n\t * @param options The command line options to use\n\t */\n\tpublic static boolean parseArguments(List<String> args, CommandLineOption[] options, LogWriter log)\n\t{\n\t\t\n\t\tMap<String,CommandLineOption> optionMap = new HashMap<String,CommandLineOption>();\n\n\t\tfor (int i=0;i<options.length;i++)\n\t\t{\n\t\t\toptionMap.put(options[i].option, options[i]);\n\t\t}\n\t\twhile( args.size() > 0 )\n\t\t{\n\t\t\t// this should be an option name\n\t\t\tString arg = args.get(0).trim();\n\t\t\tif( arg != null && arg.length() > 0 && arg.charAt(0) == '-') \n\t\t\t{\n\t\t\t\t// remove the leading '-'\n\t\t\t\tString optionName = arg.substring(1);\n\t\t\t\t// see if this matches an option\n\t\t\t\tCommandLineOption option = optionMap.get(optionName);\n\t\t\t\tif( option != null ) {\n\t\t\t\t\targs.remove(0);\n\t\t\t\t\tif( !option.yesNo )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( args.size() > 0 ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString value = args.get(0);\n\t\t\t\t\t\t\toption.argument.append(value);\n\t\t\t\t\t\t\targs.remove(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// we did not get a valid value\n\t\t\t\t\t\t\tif( log != null ) {\n\t\t\t\t\t\t\t\tlog.logError( \"Command Line Options\", \"Option \"+optionName+\" expects an argument\", new Object[] {optionName});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\toption.argument.append(\"Y\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this is not a valid option\n\t\t\t\t\tif( log != null ) {\n\t\t\t\t\t\tlog.logError( \"Command Line Options\", optionName+\" is not a recognized option\", new Object[] {optionName});\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} \n\t\t\telse if( \"\".equals( arg ) )\n\t\t\t{\n\t\t\t\t// just an empty string\n\t\t\t\targs.remove(0);\n\t\t\t} else {\n\t\t\t\t// we don't understand this option\n\t\t\t\tif( log != null ) {\n\t\t\t\t\tlog.logError( \"Command Line Options\", \"Expected a recognized option but encountered \"+arg, new Object[] {arg});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t\t/*\n\t\tfor (int i=0;i<options.length;i++)\n\t\t{\n\t\t\tboolean found=false;\n\t\t\tfor (int j=0;j<args.size() && !found;j++)\n\t\t\t{\n\t\t\t\tString argument = options[i].extractAndSetArgument((String)args.get(j));\n\t\t\t\tif (argument!=null) \n\t\t\t\t{\n\t\t\t\t\tfound=true;\n\t\t\t\t\targs.remove(j); // We covered it: remove from the list\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n    }","commit_id":"0088be4e22c307736121a65b9ceb4624a8f134b8","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n\t\t\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++) \n\t    {\n\t        if (a[i].length()>0) \n            {\n                args.add(a[i]);\n            }\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tTrans          trans    = null;\n\n\t\t// The options: \n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionTransname, optionDirname, optionFilename, optionLoglevel;\n\t\tStringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListtrans, optionListrep, optionExprep, optionNorep, optionSafemode, optionVersion, optionJarFilename;\n        \n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", \"Repository name\", optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", \"Repository username\", optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", \"Repository password\", optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"trans\", \"The name of the transformation to launch\", optionTransname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", \"The directory (don't forget the leading /)\", optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", \"The filename (Transformation in XML) to launch\", optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", \"The logging level (Basic, Detailed, Debug, Rowlevel, Error, Nothing)\", optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", \"The logging file to write to\", optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", \"The logging file to write to (deprecated)\", optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", \"List the directories in the repository\", optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listtrans\", \"List the transformations in the specified directory\", optionListtrans=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", \"List the available repositories\", optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"exprep\", \"Export all repository objects to one XML file\", optionExprep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", \"Do not log into the repository\", optionNorep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"safemode\", \"Run in safe mode: with extra checking enabled\", optionSafemode=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", \"show the version, revision and build date\", optionVersion=new StringBuffer(), true, false),\n                new CommandLineOption(\"jarfile\", \"specifies the jar filename\", optionJarFilename=new StringBuffer(), true, true),\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t\tCommandLineOption.printUsage(options);\n            System.exit(9);\n\t\t}\n\n\t\t// Parse the options...\n\t\tCommandLineOption.parseArguments(args, options);\n\t\t\n\t\tString kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (kettleRepname !=null && kettleRepname .length()>0) optionRepname  = new StringBuffer(kettleRepname);\n        if (kettleUsername!=null && kettleUsername.length()>0) optionUsername = new StringBuffer(kettleUsername);\n        if (kettlePassword!=null && kettlePassword.length()>0) optionPassword = new StringBuffer(kettlePassword);\n        \n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n        }\n        else\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(\"Pan\", \"Logging is at level : \"+log.getLogLevelDesc());\n        }\n        \n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Pan\", \"Kettle version \"+Const.VERSION+\", build \"+buildVersion.getVersion()+\", build date : \"+buildVersion.getBuildDate());\n            if (a.length==1) System.exit(6);\n        }\n        \n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n        // This is where the action starts.\n        // Print the options before we start processing when running in Debug or Rowlevel\n        // \n        if (log.isDebug())\n        {\n\t\t    System.out.println(\"Arguments:\");\n\t\t    for (int i=0;i<options.length;i++) \n\t\t    {\n\t\t    \t/*if (!options[i].isHiddenOption())*/\n                System.out.println(Const.rightPad(options[i].getOption(),12)+\" : \"+options[i].getArgument());\n\t\t    }\n\t\t    System.out.println(\"\");\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n        log.logMinimal(\"Pan\", \"Start of run.\");\n\t\t\n\t\t/* Load the plugins etc.*/\n\t\tStepLoader steploader = StepLoader.getInstance();\n\t\tif (!steploader.read())\n\t\t{\n\t\t\tlog.logError(\"Pan\", \"Error loading steps... halting Pan!\");\n            System.exit(8);\n\t\t}\n\t\t\n        /* Load the plugins etc.*/\n        JobEntryLoader jeloader = JobEntryLoader.getInstance();\n        if (!jeloader.read())\n        {\n            log.logError(\"Pan\", \"Error loading job entries & plugins... halting Pan!\");\n            System.exit(8);\n        }\n        \n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\n\t\tlog.logDebug(\"Pan\", \"Allocate new transformation.\");\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\tlog.logDebug(\"Pan\", \"Starting to look at options...\");\n\t\t\t// Read kettle transformation specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename) || !Const.isEmpty(optionJarFilename))\n\t\t\t{\t\t\t\n\t\t\t\tlog.logDebug(\"Pan\", \"Parsing command line options.\");\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tlog.logDebug(\"Pan\", \"Loading available repositories.\");\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Finding repository [\"+optionRepname+\"]\");\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Allocate & connect to repository.\");\n\t\t\t\t\t\t\tRepository rep = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (rep.connect(\"Pan commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = rep.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = rep.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Check supplied username and password.\");\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(rep, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Load a transformation\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionTransname))\n\t\t\t\t\t\t\t\t\t\t{\n                                            throw new KettleException(\"3.0 TODO: re-enable repository support.\");\n                                            /*\n                                            \n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Load the transformation info...\");\n\t\t\t\t\t\t\t\t\t\t\ttransMeta = new TransMeta(rep, optionTransname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Allocate transformation...\");\n\t\t\t\t\t\t\t\t\t\t\ttrans = new Trans(log, transMeta);\n                                            \n                                            */\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the transformations in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListtrans.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t    log.logDebug(\"Pan\", \"Getting list of transformations in directory: \"+directory);\n\t\t\t\t\t\t\t\t\t\t\tString transnames[] = rep.getTransformationNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<transnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(transnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = rep.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n                                        else\n                                        // Export the repository\n                                        if (!Const.isEmpty(optionExprep))\n                                        {\n                                            System.out.println(\"Exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                            rep.exportAllObjects(null, optionExprep.toString());\n                                            System.out.println(\"Finished exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                        }\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No transformation name supplied: which one should be run?\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't verify username and password.\");\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't find the specified directory [\"+optionDirname+\"]\");\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trep.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't connect to the repository.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No repository provided, can't load transformation.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR: No repositories defined on this system.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to load the transformation from file, even if it failed to load from the repository\n                // You could implement some failover mechanism this way.\n                //\n\t\t\t\tif (trans==null && !Const.isEmpty(optionFilename))\n\t\t\t\t{\n                    log.logDetailed(\"Pan\", \"Loading transformation from XML file [\"+optionFilename+\"]\");\n\t\t\t\t\ttransMeta = new TransMeta(optionFilename.toString());\n\t\t\t\t\ttrans = new Trans(transMeta);\n\t\t\t\t}\n                \n                // Try to load the transformation from a jar file\n                // \n                if (trans==null && !Const.isEmpty(optionJarFilename))\n                {\n                    try\n                    {\n                        log.logDetailed(\"Pan\", \"Loading transformation from jar file [\"+optionJarFilename+\"]\");\n                        InputStream inputStream = Pan.class.getResourceAsStream(optionJarFilename.toString());\n                        StringBuffer xml = new StringBuffer();\n                        int c;\n                        while ((c=inputStream.read()) != -1) xml.append((char)c);\n                        inputStream.close();\n                        Document document = XMLHandler.loadXMLString(xml.toString());\n                        transMeta = new TransMeta(XMLHandler.getSubNode(document, \"transformation\"));\n                        trans = new Trans(transMeta);\n                    }\n                    catch(Exception e)\n                    {\n                        System.out.println(\"Error reading jarfile: \"+e.toString());\n                        System.out.println(Const.getStackTracker(e));\n                        throw e;\n                    }\n                }\n\t\t\t}\n\t\t\t\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tlog.logDebug(\"Pan\", \"Getting the list of repositories...\");\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"List of repositories:\");\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR: Unable to read/parse the repositories XML file.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\tSystem.out.println(\"Processing has stopped because of an error: \"+e.getMessage());\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListtrans.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListrep.toString()) &&\n                Const.isEmpty(optionExprep)\n               )\n            {\n                System.out.println(\"ERROR: Pan can't continue because the transformation couldn't be loaded.\");\n                System.exit(7);\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\n\t\t\t\n\t\t\t// See if we want to run in safe mode:\n\t\t\tif (\"Y\".equalsIgnoreCase(optionSafemode.toString()))\n\t\t\t{\n\t\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t}\n\t\t\t\n\t\t    // allocate & run the required sub-threads\n\t\t\tboolean ok = trans.execute((String[])args.toArray(new String[args.size()])); \n            if (!ok)\n            {\n                System.out.println(\"Unable to prepare and initialize this transformation\");\n                System.exit(3);\n            }\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(\"end\");\n\n\t\t\tlog.logMinimal(\"Pan\", \"Finished!\");\n\t\t\t\n\t\t\tcal=Calendar.getInstance();\n\t\t\tstop=cal.getTime();\n\t\t\tString begin=df.format(start).toString();\n\t\t\tString end  =df.format(stop).toString();\n\n\t\t\tlog.logMinimal(\"Pan\", \"Start=\"+begin+\", Stop=\"+end);\n\t\t\tlong millis=stop.getTime()-start.getTime();\n\t\t\tlog.logMinimal(\"Pan\", \"Processing ended after \"+(millis/1000)+\" seconds.\");\n\t\t\tif (trans.getResult().getNrErrors()==0) \n\t\t\t{\n\t\t\t\ttrans.printStats((int)millis/1000);\n                System.exit(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                System.exit(1);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tSystem.out.println(\"ERROR occurred: \"+ke.getMessage());\n            log.logError(\"Pan\", \"Unexpected error occurred: \"+ke.getMessage());\n            System.exit(2);\n\t\t}\n\n\t}","id":34212,"modified_method":"public static void main(String[] a) throws KettleException\n\t{\n\t\tEnvUtil.environmentInit();\n\t\t\n\t    List<String> args = new ArrayList<String>();\n\t    for (int i=0;i<a.length;i++) \n\t    {\n\t        if (a[i].length()>0) \n            {\n                args.add(a[i]);\n            }\n\t    }\n\n\t\tRepositoryMeta repinfo  = null;\n\t\tUserInfo       userinfo = null;\n\t\tTrans          trans    = null;\n\n\t\t// The options: \n\t\tStringBuffer optionRepname, optionUsername, optionPassword, optionTransname, optionDirname, optionFilename, optionLoglevel;\n\t\tStringBuffer optionLogfile, optionLogfileOld, optionListdir, optionListtrans, optionListrep, optionExprep, optionNorep, optionSafemode, optionVersion, optionJarFilename;\n        \n\t\tCommandLineOption options[] = new CommandLineOption[] \n            {\n\t\t\t    new CommandLineOption(\"rep\", \"Repository name\", optionRepname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"user\", \"Repository username\", optionUsername=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"pass\", \"Repository password\", optionPassword=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"trans\", \"The name of the transformation to launch\", optionTransname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"dir\", \"The directory (don't forget the leading /)\", optionDirname=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"file\", \"The filename (Transformation in XML) to launch\", optionFilename=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"level\", \"The logging level (Basic, Detailed, Debug, Rowlevel, Error, Nothing)\", optionLoglevel=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"logfile\", \"The logging file to write to\", optionLogfile=new StringBuffer()),\n\t\t\t    new CommandLineOption(\"log\", \"The logging file to write to (deprecated)\", optionLogfileOld=new StringBuffer(), false, true),\n\t\t\t    new CommandLineOption(\"listdir\", \"List the directories in the repository\", optionListdir=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listtrans\", \"List the transformations in the specified directory\", optionListtrans=new StringBuffer(), true, false),\n\t\t\t    new CommandLineOption(\"listrep\", \"List the available repositories\", optionListrep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"exprep\", \"Export all repository objects to one XML file\", optionExprep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"norep\", \"Do not log into the repository\", optionNorep=new StringBuffer(), true, false),\n\t\t        new CommandLineOption(\"safemode\", \"Run in safe mode: with extra checking enabled\", optionSafemode=new StringBuffer(), true, false),\n                new CommandLineOption(\"version\", \"show the version, revision and build date\", optionVersion=new StringBuffer(), true, false),\n                new CommandLineOption(\"jarfile\", \"specifies the jar filename\", optionJarFilename=new StringBuffer(), false, true),\n            };\n\n\t\tif (args.size()==0 ) \n\t\t{\n\t\t\tCommandLineOption.printUsage(options);\n            System.exit(9);\n\t\t}\n\n        LogWriter log;\n        LogWriter.setConsoleAppenderDebug();\n        // start with the default logger until we find out otherwise\n        log=LogWriter.getInstance( LogWriter.LOG_LEVEL_BASIC );\n\n\t\t// Parse the options...\n\t\tif( !CommandLineOption.parseArguments(args, options, log) ) {\n            log.logError(\"Pan\", \"Command line option not understood\");\n            System.exit(8);\n\t\t}\n\t\t\n\t\tString kettleRepname  = Const.getEnvironmentVariable(\"KETTLE_REPOSITORY\", null);\n        String kettleUsername = Const.getEnvironmentVariable(\"KETTLE_USER\", null);\n        String kettlePassword = Const.getEnvironmentVariable(\"KETTLE_PASSWORD\", null);\n        \n        if (kettleRepname !=null && kettleRepname .length()>0) optionRepname  = new StringBuffer(kettleRepname);\n        if (kettleUsername!=null && kettleUsername.length()>0) optionUsername = new StringBuffer(kettleUsername);\n        if (kettlePassword!=null && kettlePassword.length()>0) optionPassword = new StringBuffer(kettlePassword);\n        \n        \n        if (Const.isEmpty(optionLogfile) && !Const.isEmpty(optionLogfileOld))\n        {\n           // if the old style of logging name is filled in, and the new one is not\n           // overwrite the new by the old\n           optionLogfile = optionLogfileOld;\n        }\n        \n        if (!Const.isEmpty(optionLogfile))\n        {\n            log=LogWriter.getInstance( optionLogfile.toString(), true, LogWriter.LOG_LEVEL_BASIC );\n        }\n        \n        if (!Const.isEmpty(optionLoglevel)) \n        {\n            log.setLogLevel(optionLoglevel.toString());\n            log.logMinimal(\"Pan\", \"Logging is at level : \"+log.getLogLevelDesc());\n        }\n        \n        if (!Const.isEmpty(optionVersion))\n        {\n            BuildVersion buildVersion = BuildVersion.getInstance();\n            log.logBasic(\"Pan\", \"Kettle version \"+Const.VERSION+\", build \"+buildVersion.getVersion()+\", build date : \"+buildVersion.getBuildDate());\n            if (a.length==1) System.exit(6);\n        }\n        \n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n        // This is where the action starts.\n        // Print the options before we start processing when running in Debug or Rowlevel\n        // \n        if (log.isDebug())\n        {\n\t\t    System.out.println(\"Arguments:\");\n\t\t    for (int i=0;i<options.length;i++) \n\t\t    {\n\t\t    \t/*if (!options[i].isHiddenOption())*/\n                System.out.println(Const.rightPad(options[i].getOption(),12)+\" : \"+options[i].getArgument());\n\t\t    }\n\t\t    System.out.println(\"\");\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n        log.logMinimal(\"Pan\", \"Start of run.\");\n\t\t\n\t\t/* Load the plugins etc.*/\n\t\tStepLoader steploader = StepLoader.getInstance();\n\t\tif (!steploader.read())\n\t\t{\n\t\t\tlog.logError(\"Pan\", \"Error loading steps... halting Pan!\");\n            System.exit(8);\n\t\t}\n\t\t\n        /* Load the plugins etc.*/\n        JobEntryLoader jeloader = JobEntryLoader.getInstance();\n        if (!jeloader.read())\n        {\n            log.logError(\"Pan\", \"Error loading job entries & plugins... halting Pan!\");\n            System.exit(8);\n        }\n        \n\t\tDate start, stop;\n\t\tCalendar cal;\n\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n\t\tcal=Calendar.getInstance();\n\t\tstart=cal.getTime();\n\n\t\tlog.logDebug(\"Pan\", \"Allocate new transformation.\");\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\tlog.logDebug(\"Pan\", \"Starting to look at options...\");\n\t\t\t// Read kettle transformation specified on command-line?\n\t\t\tif (!Const.isEmpty(optionRepname) || !Const.isEmpty(optionFilename) || !Const.isEmpty(optionJarFilename))\n\t\t\t{\t\t\t\n\t\t\t\tlog.logDebug(\"Pan\", \"Parsing command line options.\");\n\t\t\t\tif (!Const.isEmpty(optionRepname) && !\"Y\".equalsIgnoreCase(optionNorep.toString()))\n\t\t\t\t{\n\t\t\t\t\tlog.logDebug(\"Pan\", \"Loading available repositories.\");\n\t\t\t\t\tRepositoriesMeta repsinfo = new RepositoriesMeta(log);\n\t\t\t\t\tif (repsinfo.readData())\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Finding repository [\"+optionRepname+\"]\");\n\t\t\t\t\t\trepinfo = repsinfo.findRepository(optionRepname.toString());\n\t\t\t\t\t\tif (repinfo!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Define and connect to the repository...\n\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Allocate & connect to repository.\");\n\t\t\t\t\t\t\tRepository rep = new Repository(log, repinfo, userinfo);\n\t\t\t\t\t\t\tif (rep.connect(\"Pan commandline\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRepositoryDirectory directory = rep.getDirectoryTree(); // Default = root\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Find the directory name if one is specified...\n\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionDirname))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdirectory = rep.getDirectoryTree().findDirectory(optionDirname.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (directory!=null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Check username, password\n\t\t\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Check supplied username and password.\");\n\t\t\t\t\t\t\t\t\tuserinfo = new UserInfo(rep, optionUsername.toString(), optionPassword.toString());\n\t\t\t\t\t\t\t\t\tif (userinfo.getID()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Load a transformation\n\t\t\t\t\t\t\t\t\t\tif (!Const.isEmpty(optionTransname))\n\t\t\t\t\t\t\t\t\t\t{\n                                            throw new KettleException(\"3.0 TODO: re-enable repository support.\");\n                                            /*\n                                            \n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Load the transformation info...\");\n\t\t\t\t\t\t\t\t\t\t\ttransMeta = new TransMeta(rep, optionTransname.toString(), directory);\n\t\t\t\t\t\t\t\t\t\t\tlog.logDebug(\"Pan\", \"Allocate transformation...\");\n\t\t\t\t\t\t\t\t\t\t\ttrans = new Trans(log, transMeta);\n                                            \n                                            */\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the transformations in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListtrans.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t    log.logDebug(\"Pan\", \"Getting list of transformations in directory: \"+directory);\n\t\t\t\t\t\t\t\t\t\t\tString transnames[] = rep.getTransformationNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<transnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(transnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t// List the directories in the repository\n\t\t\t\t\t\t\t\t\t\tif (\"Y\".equalsIgnoreCase(optionListdir.toString()))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tString dirnames[] = rep.getDirectoryNames(directory.getID());\n\t\t\t\t\t\t\t\t\t\t\tfor (int i=0;i<dirnames.length;i++)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(dirnames[i]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n                                        else\n                                        // Export the repository\n                                        if (!Const.isEmpty(optionExprep))\n                                        {\n                                            System.out.println(\"Exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                            rep.exportAllObjects(null, optionExprep.toString());\n                                            System.out.println(\"Finished exporting all objects in the repository to file [\"+optionExprep+\"]\");\n                                        }\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No transformation name supplied: which one should be run?\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't verify username and password.\");\n\t\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't find the specified directory [\"+optionDirname+\"]\");\n\t\t\t\t\t\t\t\t\tuserinfo=null;\n\t\t\t\t\t\t\t\t\trepinfo=null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trep.disconnect();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSystem.out.println(\"ERROR: Can't connect to the repository.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR: No repository provided, can't load transformation.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR: No repositories defined on this system.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to load the transformation from file, even if it failed to load from the repository\n                // You could implement some failover mechanism this way.\n                //\n\t\t\t\tif (trans==null && !Const.isEmpty(optionFilename))\n\t\t\t\t{\n                    log.logDetailed(\"Pan\", \"Loading transformation from XML file [\"+optionFilename+\"]\");\n\t\t\t\t\ttransMeta = new TransMeta(optionFilename.toString());\n\t\t\t\t\ttrans = new Trans(transMeta);\n\t\t\t\t}\n                \n                // Try to load the transformation from a jar file\n                // \n                if (trans==null && !Const.isEmpty(optionJarFilename))\n                {\n                    try\n                    {\n                        log.logDetailed(\"Pan\", \"Loading transformation from jar file [\"+optionJarFilename+\"]\");\n                        InputStream inputStream = Pan.class.getResourceAsStream(optionJarFilename.toString());\n                        StringBuffer xml = new StringBuffer();\n                        int c;\n                        while ((c=inputStream.read()) != -1) xml.append((char)c);\n                        inputStream.close();\n                        Document document = XMLHandler.loadXMLString(xml.toString());\n                        transMeta = new TransMeta(XMLHandler.getSubNode(document, \"transformation\"));\n                        trans = new Trans(transMeta);\n                    }\n                    catch(Exception e)\n                    {\n                        System.out.println(\"Error reading jarfile: \"+e.toString());\n                        System.out.println(Const.getStackTracker(e));\n                        throw e;\n                    }\n                }\n\t\t\t}\n\t\t\t\n\t\t\tif (\"Y\".equalsIgnoreCase(optionListrep.toString()))\n\t\t\t{\n\t\t\t\tlog.logDebug(\"Pan\", \"Getting the list of repositories...\");\n\t\t\t\tRepositoriesMeta ri = new RepositoriesMeta(log);\n\t\t\t\tif (ri.readData())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"List of repositories:\");\n\t\t\t\t\tfor (int i=0;i<ri.nrRepositories();i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRepositoryMeta rinfo = ri.getRepository(i);\n\t\t\t\t\t\tSystem.out.println(\"#\"+(i+1)+\" : \"+rinfo.getName()+\" [\"+rinfo.getDescription()+\"] \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR: Unable to read/parse the repositories XML file.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\tSystem.out.println(\"Processing has stopped because of an error: \"+e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\tif (!\"Y\".equalsIgnoreCase(optionListtrans.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListdir.toString()) && \n                !\"Y\".equalsIgnoreCase(optionListrep.toString()) &&\n                Const.isEmpty(optionExprep)\n               )\n            {\n                System.out.println(\"ERROR: Pan can't continue because the transformation couldn't be loaded.\");\n                System.exit(7);\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\n\t\t\t\n\t\t\t// See if we want to run in safe mode:\n\t\t\tif (\"Y\".equalsIgnoreCase(optionSafemode.toString()))\n\t\t\t{\n\t\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t}\n\t\t\t\n\t\t    // allocate & run the required sub-threads\n\t\t\tboolean ok = trans.execute((String[])args.toArray(new String[args.size()])); \n            if (!ok)\n            {\n                System.out.println(\"Unable to prepare and initialize this transformation\");\n                System.exit(3);\n            }\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(\"end\");\n\n\t\t\tlog.logMinimal(\"Pan\", \"Finished!\");\n\t\t\t\n\t\t\tcal=Calendar.getInstance();\n\t\t\tstop=cal.getTime();\n\t\t\tString begin=df.format(start).toString();\n\t\t\tString end  =df.format(stop).toString();\n\n\t\t\tlog.logMinimal(\"Pan\", \"Start=\"+begin+\", Stop=\"+end);\n\t\t\tlong millis=stop.getTime()-start.getTime();\n\t\t\tlog.logMinimal(\"Pan\", \"Processing ended after \"+(millis/1000)+\" seconds.\");\n\t\t\tif (trans.getResult().getNrErrors()==0) \n\t\t\t{\n\t\t\t\ttrans.printStats((int)millis/1000);\n                System.exit(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                System.exit(1);\n\t\t\t}\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\tSystem.out.println(\"ERROR occurred: \"+ke.getMessage());\n            log.logError(\"Pan\", \"Unexpected error occurred: \"+ke.getMessage());\n            System.exit(2);\n\t\t}\n\n\t}","commit_id":"0088be4e22c307736121a65b9ceb4624a8f134b8","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public DefaultResolvedModuleVersionResult getFrom() {\n        return from;\n    }","id":34213,"modified_method":"public ResolvedModuleVersionResult getFrom() {\n        return from;\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultResolvedModuleVersionResult getSelected() {\n        return selected;\n    }","id":34214,"modified_method":"public ResolvedModuleVersionResult getSelected() {\n        return selected;\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultResolvedDependencyResult(ModuleVersionSelector requested, DefaultResolvedModuleVersionResult selected, DefaultResolvedModuleVersionResult from) {\n        assert requested != null;\n        assert selected != null;\n        assert from != null;\n\n        this.from = from;\n        this.requested = requested;\n        this.selected = selected;\n    }","id":34215,"modified_method":"public DefaultResolvedDependencyResult(ModuleVersionSelector requested, ResolvedModuleVersionResult selected, ResolvedModuleVersionResult from) {\n        assert requested != null;\n        assert selected != null;\n        assert from != null;\n\n        this.from = from;\n        this.requested = requested;\n        this.selected = selected;\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<DefaultResolvedDependencyResult> getDependents() {\n        return dependents;\n    }","id":34216,"modified_method":"public Set<ResolvedDependencyResult> getDependents() {\n        return dependents;\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultResolvedModuleVersionResult addDependent(DefaultResolvedDependencyResult dependent) {\n        this.dependents.add(dependent);\n        return this;\n    }","id":34217,"modified_method":"public DefaultResolvedModuleVersionResult addDependent(ResolvedDependencyResult dependent) {\n        this.dependents.add(dependent);\n        return this;\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultUnresolvedDependencyResult(ModuleVersionSelector requested, Exception failure, DefaultResolvedModuleVersionResult from) {\n        assert requested != null;\n        assert failure != null;\n        assert from != null;\n\n        this.from = from;\n        this.failure = failure;\n        this.requested = requested;\n    }","id":34218,"modified_method":"public DefaultUnresolvedDependencyResult(ModuleVersionSelector requested, Exception failure, ResolvedModuleVersionResult from) {\n        assert requested != null;\n        assert failure != null;\n        assert from != null;\n\n        this.from = from;\n        this.failure = failure;\n        this.requested = requested;\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultResolvedModuleVersionResult getFrom() {\n        return from;\n    }","id":34219,"modified_method":"public ResolvedModuleVersionResult getFrom() {\n        return from;\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolvedConfiguration(ModuleVersionIdentifier id, Collection<? extends InternalDependencyResult> dependencies) {\n        DefaultResolvedModuleVersionResult from = getModule(id, VersionSelectionReasons.REQUESTED);\n\n        for (InternalDependencyResult d : dependencies) {\n            if (d.getFailure() != null) {\n                from.addDependency(new DefaultUnresolvedDependencyResult(d.getRequested(), d.getFailure(), from));\n            } else {\n                DefaultResolvedModuleVersionResult selected = getModule(d.getSelected().getSelectedId(), d.getSelected().getSelectionReason());\n                DefaultResolvedDependencyResult dependency = new DefaultResolvedDependencyResult(d.getRequested(), selected, from);\n                from.addDependency(dependency);\n                selected.addDependent(dependency);\n            }\n        }\n    }","id":34220,"modified_method":"public void resolvedConfiguration(ModuleVersionIdentifier id, Collection<? extends InternalDependencyResult> dependencies) {\n        DefaultResolvedModuleVersionResult from = getModule(id, VersionSelectionReasons.REQUESTED);\n\n        for (InternalDependencyResult d : dependencies) {\n            if (d.getFailure() != null) {\n                from.addDependency(dependencyResultFactory.createUnresolvedDependency(d.getRequested(), from, d.getFailure()));\n            } else {\n                DefaultResolvedModuleVersionResult selected = getModule(d.getSelected().getSelectedId(), d.getSelected().getSelectionReason());\n                DependencyResult dependency = dependencyResultFactory.createResolvedDependency(d.getRequested(), from, selected);\n                from.addDependency(dependency);\n                selected.addDependent((ResolvedDependencyResult) dependency);\n            }\n        }\n    }","commit_id":"62d636b157ddbfff0ce06fffcd6aaa5003f033e5","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentIdentifier getId() {\n        return module.getId();\n    }","id":34221,"modified_method":"public ModuleComponentIdentifier getId() {\n        return (ModuleComponentIdentifier)module.getId();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public String getName() {\n        return module.getId().getGroup() + \":\" + module.getId().getName() + \":\" + module.getId().getVersion();\n    }","id":34222,"modified_method":"public String getName() {\n        ModuleComponentIdentifier id = (ModuleComponentIdentifier)module.getId();\n        return id.getGroup() + \":\" + id.getName() + \":\" + id.getVersion();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public int compare(DependencyEdge left, DependencyEdge right) {\n            ModuleComponentSelector leftRequested = left.getRequested();\n            ModuleComponentSelector rightRequested = right.getRequested();\n            int byGroup = leftRequested.getGroup().compareTo(rightRequested.getGroup());\n            if (byGroup != 0) {\n                return byGroup;\n            }\n\n            int byModule = leftRequested.getName().compareTo(rightRequested.getName());\n            if (byModule != 0) {\n                return byModule;\n            }\n\n            //if selected matches requested version comparison is overridden\n            boolean leftMatches = leftRequested.matchesStrictly(left.getActual());\n            boolean rightMatches = rightRequested.matchesStrictly(right.getActual());\n            if (leftMatches && !rightMatches) {\n                return -1;\n            } else if (!leftMatches && rightMatches) {\n                return 1;\n            }\n\n            //order dynamic selectors after static selectors\n            boolean leftDynamic = matcher.isDynamic(leftRequested.getVersion());\n            boolean rightDynamic = matcher.isDynamic(rightRequested.getVersion());\n            if (leftDynamic && !rightDynamic) {\n                return 1;\n            } else if (!leftDynamic && rightDynamic) {\n                return -1;\n            }\n\n            int byVersion;\n            if (leftDynamic && rightDynamic) {\n                // order dynamic selectors lexicographically\n                byVersion = leftRequested.getVersion().compareTo(rightRequested.getVersion());\n            } else {\n                // order static selectors semantically\n                byVersion = matcher.compare(leftRequested.getVersion(), rightRequested.getVersion());\n            }\n            if (byVersion != 0) {\n                return byVersion;\n            }\n\n            ModuleComponentIdentifier leftFrom = left.getFrom();\n            ModuleComponentIdentifier rightFrom = right.getFrom();\n            byGroup = leftFrom.getGroup().compareTo(rightFrom.getGroup());\n            if (byGroup != 0) {\n                return byGroup;\n            }\n\n            byModule = leftFrom.getName().compareTo(rightFrom.getName());\n            if (byModule != 0) {\n                return byModule;\n            }\n\n            return matcher.compare(leftFrom.getVersion(), rightFrom.getVersion());\n        }","id":34223,"modified_method":"public int compare(DependencyEdge left, DependencyEdge right) {\n            ModuleComponentSelector leftRequested = (ModuleComponentSelector)left.getRequested();\n            ModuleComponentSelector rightRequested = (ModuleComponentSelector)right.getRequested();\n            int byGroup = leftRequested.getGroup().compareTo(rightRequested.getGroup());\n            if (byGroup != 0) {\n                return byGroup;\n            }\n\n            int byModule = leftRequested.getName().compareTo(rightRequested.getName());\n            if (byModule != 0) {\n                return byModule;\n            }\n\n            //if selected matches requested version comparison is overridden\n            boolean leftMatches = leftRequested.matchesStrictly(left.getActual());\n            boolean rightMatches = rightRequested.matchesStrictly(right.getActual());\n            if (leftMatches && !rightMatches) {\n                return -1;\n            } else if (!leftMatches && rightMatches) {\n                return 1;\n            }\n\n            //order dynamic selectors after static selectors\n            boolean leftDynamic = matcher.isDynamic(leftRequested.getVersion());\n            boolean rightDynamic = matcher.isDynamic(rightRequested.getVersion());\n            if (leftDynamic && !rightDynamic) {\n                return 1;\n            } else if (!leftDynamic && rightDynamic) {\n                return -1;\n            }\n\n            int byVersion;\n            if (leftDynamic && rightDynamic) {\n                // order dynamic selectors lexicographically\n                byVersion = leftRequested.getVersion().compareTo(rightRequested.getVersion());\n            } else {\n                // order static selectors semantically\n                byVersion = matcher.compare(leftRequested.getVersion(), rightRequested.getVersion());\n            }\n            if (byVersion != 0) {\n                return byVersion;\n            }\n\n            ModuleComponentIdentifier leftFrom = (ModuleComponentIdentifier)left.getFrom();\n            ModuleComponentIdentifier rightFrom = (ModuleComponentIdentifier)right.getFrom();\n            byGroup = leftFrom.getGroup().compareTo(rightFrom.getGroup());\n            if (byGroup != 0) {\n                return byGroup;\n            }\n\n            byModule = leftFrom.getName().compareTo(rightFrom.getName());\n            if (byModule != 0) {\n                return byModule;\n            }\n\n            return matcher.compare(leftFrom.getVersion(), rightFrom.getVersion());\n        }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean matchesSelected(ResolvedDependencyResult candidate) {\n        ModuleComponentIdentifier selected = candidate.getSelected().getId();\n        String selectedCandidate = selected.getGroup() + \":\" + selected.getName() + \":\" + selected.getVersion();\n        return selectedCandidate.contains(stringNotation);\n    }","id":34224,"modified_method":"private boolean matchesSelected(ResolvedDependencyResult candidate) {\n        ModuleComponentIdentifier selected = (ModuleComponentIdentifier)candidate.getSelected().getId();\n        String selectedCandidate = selected.getGroup() + \":\" + selected.getName() + \":\" + selected.getVersion();\n        return selectedCandidate.contains(stringNotation);\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean matchesRequested(DependencyResult candidate) {\n        String requestedCandidate = candidate.getRequested().getGroup() + \":\" + candidate.getRequested().getName() + \":\" + candidate.getRequested().getVersion();\n        return requestedCandidate.contains(stringNotation);\n    }","id":34225,"modified_method":"private boolean matchesRequested(DependencyResult candidate) {\n        ModuleComponentSelector requested = (ModuleComponentSelector)candidate.getRequested();\n        String requestedCandidate = requested.getGroup() + \":\" + requested.getName() + \":\" + requested.getVersion();\n        return requestedCandidate.contains(stringNotation);\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleComponentIdentifier getActual() {\n        return dependency.getSelected().getId();\n    }","id":34226,"modified_method":"@Override\n    protected ModuleComponentIdentifier getActual() {\n        return (ModuleComponentIdentifier)dependency.getSelected().getId();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleComponentSelector getRequested() {\n        return dependency.getRequested();\n    }","id":34227,"modified_method":"@Override\n    protected ModuleComponentSelector getRequested() {\n        return (ModuleComponentSelector)dependency.getRequested();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public RenderableUnresolvedDependencyResult(UnresolvedDependencyResult dependency) {\n        this.dependency = dependency;\n        ModuleComponentSelector attempted = dependency.getAttempted();\n        this.actual = DefaultModuleComponentIdentifier.newId(attempted.getGroup(), attempted.getName(), attempted.getVersion());\n    }","id":34228,"modified_method":"public RenderableUnresolvedDependencyResult(UnresolvedDependencyResult dependency) {\n        this.dependency = dependency;\n        ModuleComponentSelector attempted = (ModuleComponentSelector)dependency.getAttempted();\n        this.actual = DefaultModuleComponentIdentifier.newId(attempted.getGroup(), attempted.getName(), attempted.getVersion());\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleComponentSelector getRequested() {\n        return dependency.getRequested();\n    }","id":34229,"modified_method":"@Override\n    protected ModuleComponentSelector getRequested() {\n        return (ModuleComponentSelector)dependency.getRequested();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentSelector getRequested() {\n        return dependency.getRequested();\n    }","id":34230,"modified_method":"public ModuleComponentSelector getRequested() {\n        return (ModuleComponentSelector)dependency.getRequested();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentIdentifier getActual() {\n        return dependency.getSelected().getId();\n    }","id":34231,"modified_method":"public ModuleComponentIdentifier getActual() {\n        return (ModuleComponentIdentifier)dependency.getSelected().getId();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentIdentifier getFrom() {\n        return dependency.getFrom().getId();\n    }","id":34232,"modified_method":"public ModuleComponentIdentifier getFrom() {\n        return (ModuleComponentIdentifier)dependency.getFrom().getId();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean matchesSelected(ResolvedDependencyResult candidate) {\n        ModuleComponentIdentifier selected = candidate.getSelected().getId();\n        return selected.getGroup().equals(moduleIdentifier.getGroup())\n               && selected.getName().equals(moduleIdentifier.getName());\n    }","id":34233,"modified_method":"private boolean matchesSelected(ResolvedDependencyResult candidate) {\n        ModuleComponentIdentifier selected = (ModuleComponentIdentifier)candidate.getSelected().getId();\n        return selected.getGroup().equals(moduleIdentifier.getGroup())\n               && selected.getName().equals(moduleIdentifier.getName());\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean matchesRequested(DependencyResult candidate) {\n        return candidate.getRequested().getGroup().equals(moduleIdentifier.getGroup())\n               && candidate.getRequested().getName().equals(moduleIdentifier.getName());\n    }","id":34234,"modified_method":"private boolean matchesRequested(DependencyResult candidate) {\n        ModuleComponentSelector requested = (ModuleComponentSelector)candidate.getRequested();\n        return requested.getGroup().equals(moduleIdentifier.getGroup())\n               && requested.getName().equals(moduleIdentifier.getName());\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentSelector getRequested() {\n        return dependency.getRequested();\n    }","id":34235,"modified_method":"public ModuleComponentSelector getRequested() {\n        return (ModuleComponentSelector)dependency.getRequested();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public UnresolvedDependencyEdge(UnresolvedDependencyResult dependency) {\n        this.dependency = dependency;\n        ModuleComponentSelector attempted = dependency.getAttempted();\n        actual = DefaultModuleComponentIdentifier.newId(attempted.getGroup(), attempted.getName(), attempted.getVersion());\n    }","id":34236,"modified_method":"public UnresolvedDependencyEdge(UnresolvedDependencyResult dependency) {\n        this.dependency = dependency;\n        ModuleComponentSelector attempted = (ModuleComponentSelector)dependency.getAttempted();\n        actual = DefaultModuleComponentIdentifier.newId(attempted.getGroup(), attempted.getName(), attempted.getVersion());\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleComponentIdentifier getFrom() {\n        return dependency.getFrom().getId();\n    }","id":34237,"modified_method":"public ModuleComponentIdentifier getFrom() {\n        return (ModuleComponentIdentifier)dependency.getFrom().getId();\n    }","commit_id":"259b40d04ed2684b6ad68ccc5c99f9d526bd253a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  @NotNull\n  protected Collection<String> getValues(@Nullable VcsLogBranchFilter filter) {\n    return filter == null ? Collections.<String>emptySet() : filter.getBranchNames();\n  }","id":34238,"modified_method":"@Override\n  @NotNull\n  protected Collection<String> getTextValues(@Nullable VcsLogBranchFilter filter) {\n    if (filter == null) return Collections.emptySet();\n    return ContainerUtil.newArrayList(ContainerUtil.concat(filter.getBranchNames(), addMinusPrefix(filter.getExcludedBranchNames())));\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected String getText(@NotNull VcsLogBranchFilter filter) {\n    return displayableText(filter.getBranchNames());\n  }","id":34239,"modified_method":"@NotNull\n  @Override\n  protected String getText(@NotNull VcsLogBranchFilter filter) {\n    boolean positiveMatch = !filter.getBranchNames().isEmpty();\n    Collection<String> names = positiveMatch ? filter.getBranchNames() : addMinusPrefix(filter.getExcludedBranchNames());\n    return displayableText(names);\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected VcsLogBranchFilter createFilter(@NotNull Collection<String> values) {\n    return new VcsLogBranchFilterImpl(values);\n  }","id":34240,"modified_method":"@NotNull\n  @Override\n  protected VcsLogBranchFilter createFilter(@NotNull Collection<String> values) {\n    Collection<String> acceptedBranches = ContainerUtil.newArrayList();\n    Collection<String> excludedBranches = ContainerUtil.newArrayList();\n    for (String value : values) {\n      if (value.startsWith(\"-\")) {\n        excludedBranches.add(value.substring(1));\n      }\n      else {\n        acceptedBranches.add(value);\n      }\n    }\n    return new VcsLogBranchFilterImpl(acceptedBranches, excludedBranches);\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected String getToolTip(@NotNull VcsLogBranchFilter filter) {\n    return tooltip(filter.getBranchNames());\n  }","id":34241,"modified_method":"@Nullable\n  @Override\n  protected String getToolTip(@NotNull VcsLogBranchFilter filter) {\n    boolean positiveMatch = !filter.getBranchNames().isEmpty();\n    Collection<String> names = positiveMatch ? filter.getBranchNames() : filter.getExcludedBranchNames();\n    String tooltip = tooltip(names);\n    return positiveMatch ? tooltip : \"not in \" + tooltip;\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setSelected(AnActionEvent e, boolean selected) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    final VcsLogUi ui = e.getData(VcsLogDataKeys.VCS_LOG_UI);\n    final VcsLogDataProvider dataProvider = e.getData(VcsLogDataKeys.VCS_LOG_DATA_PROVIDER);\n    if (project == null || ui == null || dataProvider == null) {\n      return;\n    }\n    final DeepComparator dc = DeepComparator.getInstance(project, ui);\n    if (selected) {\n      VcsLogBranchFilter branchFilter = ui.getFilterUi().getFilters().getBranchFilter();\n      if (branchFilter == null || branchFilter.getBranchNames().size() != 1) {\n        selectBranchAndPerformAction(ui.getDataPack(), e, new Consumer<String>() {\n          @Override\n          public void consume(String selectedBranch) {\n            ui.getFilterUi().setFilter(new VcsLogBranchFilterImpl(Collections.singleton(selectedBranch)));\n            dc.highlightInBackground(selectedBranch, dataProvider);\n          }\n        }, getAllVisibleRoots(ui));\n        return;\n      }\n      String branchToCompare = branchFilter.getBranchNames().iterator().next();\n      dc.highlightInBackground(branchToCompare, dataProvider);\n    }\n    else {\n      dc.stopAndUnhighlight();\n    }\n  }","id":34242,"modified_method":"@Override\n  public void setSelected(AnActionEvent e, boolean selected) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    final VcsLogUi ui = e.getData(VcsLogDataKeys.VCS_LOG_UI);\n    final VcsLogDataProvider dataProvider = e.getData(VcsLogDataKeys.VCS_LOG_DATA_PROVIDER);\n    if (project == null || ui == null || dataProvider == null) {\n      return;\n    }\n    final DeepComparator dc = DeepComparator.getInstance(project, ui);\n    if (selected) {\n      VcsLogBranchFilter branchFilter = ui.getFilterUi().getFilters().getBranchFilter();\n      if (branchFilter == null || branchFilter.getBranchNames().size() != 1) {\n        selectBranchAndPerformAction(ui.getDataPack(), e, new Consumer<String>() {\n          @Override\n          public void consume(String selectedBranch) {\n            ui.getFilterUi().setFilter(new VcsLogBranchFilterImpl(Collections.singleton(selectedBranch), Collections.<String>emptySet()));\n            dc.highlightInBackground(selectedBranch, dataProvider);\n          }\n        }, getAllVisibleRoots(ui));\n        return;\n      }\n      String branchToCompare = branchFilter.getBranchNames().iterator().next();\n      dc.highlightInBackground(branchToCompare, dataProvider);\n    }\n    else {\n      dc.stopAndUnhighlight();\n    }\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void actionPerformed(@NotNull AnActionEvent e) {\n      Project project = e.getProject();\n      if (project == null) {\n        return;\n      }\n\n      Filter filter = myFilterModel.getFilter();\n      final MultilinePopupBuilder popupBuilder = new MultilinePopupBuilder(project, myVariants, getPopupText(getValues(filter)));\n      JBPopup popup = popupBuilder.createPopup();\n      popup.addListener(new JBPopupAdapter() {\n        @Override\n        public void onClosed(LightweightWindowEvent event) {\n          if (event.isOk()) {\n            Collection<String> selectedValues = popupBuilder.getSelectedValues();\n            if (selectedValues.isEmpty()) {\n              myFilterModel.setFilter(null);\n            }\n            else {\n              myFilterModel.setFilter(createFilter(selectedValues));\n              rememberValuesInSettings(selectedValues);\n            }\n          }\n        }\n      });\n      popup.showUnderneathOf(MultipleValueFilterPopupComponent.this);\n    }","id":34243,"modified_method":"@Override\n    public void actionPerformed(@NotNull AnActionEvent e) {\n      Project project = e.getProject();\n      if (project == null) {\n        return;\n      }\n\n      Filter filter = myFilterModel.getFilter();\n      final MultilinePopupBuilder popupBuilder = new MultilinePopupBuilder(project, myVariants, getPopupText(getTextValues(filter)));\n      JBPopup popup = popupBuilder.createPopup();\n      popup.addListener(new JBPopupAdapter() {\n        @Override\n        public void onClosed(LightweightWindowEvent event) {\n          if (event.isOk()) {\n            Collection<String> selectedValues = popupBuilder.getSelectedValues();\n            if (selectedValues.isEmpty()) {\n              myFilterModel.setFilter(null);\n            }\n            else {\n              myFilterModel.setFilter(createFilter(selectedValues));\n              rememberValuesInSettings(selectedValues);\n            }\n          }\n        }\n      });\n      popup.showUnderneathOf(MultipleValueFilterPopupComponent.this);\n    }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected abstract Collection<String> getValues(@Nullable Filter filter);","id":34244,"modified_method":"@NotNull\n  protected abstract Collection<String> getTextValues(@Nullable Filter filter);","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected String getText(@NotNull VcsLogUserFilter filter) {\n    return displayableText(getValues(filter));\n  }","id":34245,"modified_method":"@NotNull\n  @Override\n  protected String getText(@NotNull VcsLogUserFilter filter) {\n    return displayableText(getTextValues(filter));\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected String getToolTip(@NotNull VcsLogUserFilter filter) {\n    return tooltip(getValues(filter));\n  }","id":34246,"modified_method":"@Nullable\n  @Override\n  protected String getToolTip(@NotNull VcsLogUserFilter filter) {\n    return tooltip(getTextValues(filter));\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected Collection<String> getValues(@Nullable VcsLogUserFilter filter) {\n    if (filter == null) {\n      return Collections.emptySet();\n    }\n    return ContainerUtil.newHashSet(((VcsLogUserFilterImpl)filter).getUserNamesForPresentation());\n  }","id":34247,"modified_method":"@NotNull\n  @Override\n  protected Collection<String> getTextValues(@Nullable VcsLogUserFilter filter) {\n    if (filter == null) {\n      return Collections.emptySet();\n    }\n    return ContainerUtil.newHashSet(((VcsLogUserFilterImpl)filter).getUserNamesForPresentation());\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    return \"on: \" + myBranchNames;\n  }","id":34248,"modified_method":"@Override\n  public String toString() {\n    return !myBranchNames.isEmpty()\n           ? \"on: \" + StringUtil.join(myBranchNames, \", \")\n           : \"not on: \" + StringUtil.join(myExcludedBranchNames, \", \");\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VcsLogBranchFilterImpl(@NotNull final Collection<String> branchNames) {\n    myBranchNames = branchNames;\n  }","id":34249,"modified_method":"public VcsLogBranchFilterImpl(@NotNull final Collection<String> branchNames, @NotNull Collection<String> excludedBranchNames) {\n    myBranchNames = branchNames;\n    myExcludedBranchNames = excludedBranchNames;\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Set<Integer> getMatchingHeads(@NotNull VcsLogRefs refs, @NotNull VcsLogBranchFilter filter) {\n    final Collection<String> branchNames = new HashSet<String>(filter.getBranchNames());\n    return new HashSet<Integer>(ContainerUtil.mapNotNull(refs.getBranches(), new Function<VcsRef, Integer>() {\n      @Override\n      public Integer fun(VcsRef ref) {\n        if (branchNames.contains(ref.getName())) {\n          return myHashMap.getCommitIndex(ref.getCommitHash());\n        }\n        return null;\n      }\n    }));\n  }","id":34250,"modified_method":"private Set<Integer> getMatchingHeads(@NotNull VcsLogRefs refs, @NotNull VcsLogBranchFilter filter) {\n    final Collection<String> branchNames = new HashSet<String>(filter.getBranchNames());\n    final Collection<String> excludedBranches = new HashSet<String>(filter.getExcludedBranchNames());\n    final boolean filterByAcceptance = !filter.getBranchNames().isEmpty();\n    return new HashSet<Integer>(ContainerUtil.mapNotNull(refs.getBranches(), new Function<VcsRef, Integer>() {\n      @Override\n      public Integer fun(@NotNull VcsRef ref) {\n        boolean acceptRef = filterByAcceptance ? branchNames.contains(ref.getName()) : !excludedBranches.contains(ref.getName());\n        return acceptRef ? myHashMap.getCommitIndex(ref.getCommitHash()) : null;\n      }\n    }));\n  }","commit_id":"ee08ee5c46eb04421e9cebb56933d998a50f3529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (from == null && to == null && rid == null && query == null && compiledFilter == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n\r\n    if (rid != null) {\r\n      // REMOVE PUNCTUAL RID\r\n      final OrientEdge e = graph.getEdge(rid);\r\n      if (e != null) {\r\n        e.remove();\r\n        removed = 1;\r\n      }\r\n    } else {\r\n      // MULTIPLE EDGES\r\n      final Set<OrientEdge> edges = new HashSet<OrientEdge>();\r\n\r\n      if (query == null) {\r\n        // SELECTIVE TARGET\r\n        if (from != null && to != null) {\r\n          // REMOVE ALL THE EDGES BETWEEN VERTICES\r\n          for (Edge e : graph.getVertex(from).getEdges(Direction.OUT))\r\n            if (to.equals(((OrientEdge) e).getInVertex()))\r\n              edges.add((OrientEdge) e);\r\n        } else if (from != null)\r\n          // REMOVE ALL THE EDGES THAT START FROM A VERTEXES\r\n          edges.add((OrientEdge) graph.getVertex(from).getEdges(Direction.OUT));\r\n        else if (to != null)\r\n          // REMOVE ALL THE EDGES THAT ARRIVE TO A VERTEXES\r\n          edges.add((OrientEdge) graph.getVertex(to).getEdges(Direction.IN));\r\n        else\r\n          throw new OCommandExecutionException(\"Invalid target\");\r\n\r\n        if (compiledFilter != null) {\r\n          // ADDITIONAL FILTERING\r\n          for (Iterator<OrientEdge> it = edges.iterator(); it.hasNext();) {\r\n            final OrientEdge edge = it.next();\r\n            if (!(Boolean) compiledFilter.evaluate((ODocument) edge.getRecord(), null, context))\r\n              it.remove();\r\n          }\r\n        }\r\n\r\n        // DELETE THE FOUND EDGES\r\n        removed = edges.size();\r\n        for (OrientEdge edge : edges)\r\n          edge.remove();\r\n      } else if (query != null)\r\n        // TARGET IS A CLASS + OPTIONAL CONDITION\r\n        query.execute(iArgs);\r\n      else\r\n        throw new OCommandExecutionException(\"Invalid target\");\r\n    }\r\n\r\n    return removed;\r\n  }","id":34251,"modified_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (fromExpr == null && toExpr == null && rid == null && query == null && compiledFilter == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n\r\n    if (rid != null) {\r\n      // REMOVE PUNCTUAL RID\r\n      final OrientEdge e = graph.getEdge(rid);\r\n      if (e != null) {\r\n        e.remove();\r\n        removed = 1;\r\n      }\r\n    } else {\r\n      // MULTIPLE EDGES\r\n      final Set<OrientEdge> edges = new HashSet<OrientEdge>();\r\n\r\n      if (query == null) {\r\n        // SELECTIVE TARGET\r\n\r\n        Set<ORID> fromIds = null;\r\n        if (fromExpr != null)\r\n          fromIds = parseTarget(graph.getRawGraph(), fromExpr);\r\n        Set<ORID> toIds = null;\r\n        if (toExpr != null)\r\n          toIds = parseTarget(graph.getRawGraph(), toExpr);\r\n\r\n        if (fromIds != null && toIds != null) {\r\n          // REMOVE ALL THE EDGES BETWEEN VERTICES\r\n          for (ORID fromId : fromIds)\r\n            for (Edge e : graph.getVertex(fromId).getEdges(Direction.OUT))\r\n              if (toIds.contains(((OrientEdge) e).getInVertex().getIdentity()))\r\n                edges.add((OrientEdge) e);\r\n        } else if (fromIds != null)\r\n          // REMOVE ALL THE EDGES THAT START FROM A VERTEXES\r\n          for (ORID fromId : fromIds)\r\n            edges.add((OrientEdge) graph.getVertex(fromId).getEdges(Direction.OUT));\r\n        else if (toIds != null)\r\n          // REMOVE ALL THE EDGES THAT ARRIVE TO A VERTEXES\r\n          for (ORID toId : toIds)\r\n            edges.add((OrientEdge) graph.getVertex(toId).getEdges(Direction.IN));\r\n        else\r\n          throw new OCommandExecutionException(\"Invalid target\");\r\n\r\n        if (compiledFilter != null) {\r\n          // ADDITIONAL FILTERING\r\n          for (Iterator<OrientEdge> it = edges.iterator(); it.hasNext();) {\r\n            final OrientEdge edge = it.next();\r\n            if (!(Boolean) compiledFilter.evaluate((ODocument) edge.getRecord(), null, context))\r\n              it.remove();\r\n          }\r\n        }\r\n\r\n        // DELETE THE FOUND EDGES\r\n        removed = edges.size();\r\n        for (OrientEdge edge : edges)\r\n          edge.remove();\r\n      } else\r\n        // TARGET IS A CLASS + OPTIONAL CONDITION\r\n        query.execute(iArgs);\r\n    }\r\n\r\n    return removed;\r\n  }","commit_id":"96e16cff49ad46a07ec0496bbb373a644fe84420","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLDeleteEdge parse(final OCommandRequest iRequest) {\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n    graph.getRawGraph().checkSecurity(ODatabaseSecurityResources.COMMAND, ORole.PERMISSION_READ);\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    parserRequiredKeyword(\"DELETE\");\r\n    parserRequiredKeyword(\"EDGE\");\r\n\r\n    OClass clazz = null;\r\n\r\n    String temp = parseOptionalWord(true);\r\n    while (temp != null) {\r\n\r\n      if (temp.equals(\"FROM\")) {\r\n        from = new ORecordId(parserRequiredWord(false));\r\n        if (rid != null)\r\n          throwSyntaxErrorException(\"FROM '\" + from + \"' is not allowed when specify a RID (\" + rid + \")\");\r\n\r\n      } else if (temp.equals(\"TO\")) {\r\n        to = new ORecordId(parserRequiredWord(false));\r\n        if (rid != null)\r\n          throwSyntaxErrorException(\"TO '\" + to + \"' is not allowed when specify a RID (\" + rid + \")\");\r\n\r\n      } else if (temp.startsWith(\"#\")) {\r\n        rid = new ORecordId(temp);\r\n        if (from != null || to != null)\r\n          throwSyntaxErrorException(\"Specifying the RID \" + rid + \" is not allowed with FROM/TO\");\r\n\r\n      } else if (temp.equals(KEYWORD_WHERE)) {\r\n        if (clazz == null)\r\n          // ASSIGN DEFAULT CLASS\r\n          clazz = graph.getEdgeType(OGraphDatabase.EDGE_CLASS_NAME);\r\n\r\n        final String condition = parserGetCurrentPosition() > -1 ? \" \" + parserText.substring(parserGetCurrentPosition()) : \"\";\r\n\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(condition, getContext(), KEYWORD_WHERE);\r\n        break;\r\n\r\n      } else if (temp.length() > 0) {\r\n        // GET/CHECK CLASS NAME\r\n        clazz = graph.getEdgeType(temp);\r\n        if (clazz == null)\r\n          throw new OCommandSQLParsingException(\"Class '\" + temp + \" was not found\");\r\n      }\r\n\r\n      temp = parseOptionalWord(true);\r\n      if (parserIsEnded())\r\n        break;\r\n    }\r\n\r\n    if (from == null && to == null && rid == null)\r\n      if (clazz == null)\r\n        // DELETE ALL THE EDGES\r\n        query = graph.getRawGraph().command(new OSQLAsynchQuery<ODocument>(\"select from E\", this));\r\n      else\r\n        // DELETE EDGES OF CLASS X\r\n        query = graph.getRawGraph().command(new OSQLAsynchQuery<ODocument>(\"select from \" + clazz.getName(), this));\r\n\r\n    return this;\r\n  }","id":34252,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLDeleteEdge parse(final OCommandRequest iRequest) {\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n    graph.getRawGraph().checkSecurity(ODatabaseSecurityResources.COMMAND, ORole.PERMISSION_READ);\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    parserRequiredKeyword(\"DELETE\");\r\n    parserRequiredKeyword(\"EDGE\");\r\n\r\n    OClass clazz = null;\r\n\r\n    String temp = parseOptionalWord(true);\r\n    while (temp != null) {\r\n\r\n      if (temp.equals(\"FROM\")) {\r\n        fromExpr = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\r\n        if (rid != null)\r\n          throwSyntaxErrorException(\"FROM '\" + fromExpr + \"' is not allowed when specify a RID (\" + rid + \")\");\r\n\r\n      } else if (temp.equals(\"TO\")) {\r\n        toExpr = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\r\n        if (rid != null)\r\n          throwSyntaxErrorException(\"TO '\" + toExpr + \"' is not allowed when specify a RID (\" + rid + \")\");\r\n\r\n      } else if (temp.startsWith(\"#\")) {\r\n        rid = new ORecordId(temp);\r\n        if (fromExpr != null || toExpr != null)\r\n          throwSyntaxErrorException(\"Specifying the RID \" + rid + \" is not allowed with FROM/TO\");\r\n\r\n      } else if (temp.equals(KEYWORD_WHERE)) {\r\n        if (clazz == null)\r\n          // ASSIGN DEFAULT CLASS\r\n          clazz = graph.getEdgeType(OGraphDatabase.EDGE_CLASS_NAME);\r\n\r\n        final String condition = parserGetCurrentPosition() > -1 ? \" \" + parserText.substring(parserGetCurrentPosition()) : \"\";\r\n\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(condition, getContext(), KEYWORD_WHERE);\r\n        break;\r\n\r\n      } else if (temp.length() > 0) {\r\n        // GET/CHECK CLASS NAME\r\n        clazz = graph.getEdgeType(temp);\r\n        if (clazz == null)\r\n          throw new OCommandSQLParsingException(\"Class '\" + temp + \" was not found\");\r\n      }\r\n\r\n      temp = parseOptionalWord(true);\r\n      if (parserIsEnded())\r\n        break;\r\n    }\r\n\r\n    if (fromExpr == null && toExpr == null && rid == null)\r\n      if (clazz == null)\r\n        // DELETE ALL THE EDGES\r\n        query = graph.getRawGraph().command(new OSQLAsynchQuery<ODocument>(\"select from E\", this));\r\n      else\r\n        // DELETE EDGES OF CLASS X\r\n        query = graph.getRawGraph().command(new OSQLAsynchQuery<ODocument>(\"select from \" + clazz.getName(), this));\r\n\r\n    return this;\r\n  }","commit_id":"96e16cff49ad46a07ec0496bbb373a644fe84420","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n\r\n    final ORecordId[] fromIds = parseTarget(graph.getRawGraph(), from);\r\n    final ORecordId[] toIds = parseTarget(graph.getRawGraph(), to);\r\n\r\n    // CREATE EDGES\r\n    final List<Object> edges = new ArrayList<Object>();\r\n    for (ORecordId from : fromIds) {\r\n      final OrientVertex fromVertex = (OrientVertex) graph.getVertex(from);\r\n      if (fromVertex == null)\r\n        throw new OCommandExecutionException(\"Source vertex '\" + from + \"' not exists\");\r\n\r\n      for (ORecordId to : toIds) {\r\n        final OrientVertex toVertex = (OrientVertex) graph.getVertex(to);\r\n\r\n        final String clsName = clazz.getName();\r\n\r\n        if (fields != null)\r\n          // EVALUATE FIELDS\r\n          for (Entry<String, Object> f : fields.entrySet()) {\r\n            if (f.getValue() instanceof OSQLFunctionRuntime)\r\n              fields.put(f.getKey(), ((OSQLFunctionRuntime) f.getValue()).getValue(to, context));\r\n          }\r\n\r\n        final OrientEdge edge = fromVertex.addEdge(null, toVertex, clsName, clusterName, fields);\r\n\r\n        if (content != null) {\r\n          if (!edge.getRecord().getIdentity().isValid())\r\n            // LIGHTWEIGHT EDGE, TRANSFORM IT BEFORE\r\n            edge.convertToDocument();\r\n          edge.getRecord().merge(content, true, false);\r\n        }\r\n\r\n        edge.save(clusterName);\r\n\r\n        edges.add(edge);\r\n      }\r\n    }\r\n\r\n    return edges;\r\n  }","id":34253,"modified_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n\r\n    final ORecordId[] fromIds = parseTarget(graph.getRawGraph(), from);\r\n    final ORecordId[] toIds = parseTarget(graph.getRawGraph(), to);\r\n\r\n    // CREATE EDGES\r\n    final List<Object> edges = new ArrayList<Object>();\r\n    for (ORecordId from : fromIds) {\r\n      final OrientVertex fromVertex = graph.getVertex(from);\r\n      if (fromVertex == null)\r\n        throw new OCommandExecutionException(\"Source vertex '\" + from + \"' not exists\");\r\n\r\n      for (ORecordId to : toIds) {\r\n        final OrientVertex toVertex;\r\n        if (from.equals(to)) {\r\n          toVertex = fromVertex;\r\n        } else {\r\n          toVertex = graph.getVertex(to);\r\n        }\r\n\r\n        final String clsName = clazz.getName();\r\n\r\n        if (fields != null)\r\n          // EVALUATE FIELDS\r\n          for (Entry<String, Object> f : fields.entrySet()) {\r\n            if (f.getValue() instanceof OSQLFunctionRuntime)\r\n              fields.put(f.getKey(), ((OSQLFunctionRuntime) f.getValue()).getValue(to, context));\r\n          }\r\n\r\n        final OrientEdge edge = fromVertex.addEdge(null, toVertex, clsName, clusterName, fields);\r\n\r\n        if (content != null) {\r\n          if (!edge.getRecord().getIdentity().isValid())\r\n            // LIGHTWEIGHT EDGE, TRANSFORM IT BEFORE\r\n            edge.convertToDocument();\r\n          edge.getRecord().merge(content, true, false);\r\n        }\r\n\r\n        edge.save(clusterName);\r\n\r\n        edges.add(edge);\r\n      }\r\n    }\r\n\r\n    return edges;\r\n  }","commit_id":"a1abfab56456c9a910615782c573369224c704bf","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void setValue(int n) {\n    super.setValue(n);\n    AppIcon icon = AppIcon.getInstance();\n    if (n < getMaximum()) {\n      icon.setProgress(null, TESTS, AppIconScheme.Progress.TESTS, (double)n / (double)getMaximum(), myProblemsCounter == 0);\n    } else {\n      icon.hideProgress(null, TESTS);\n      if (myProblemsCounter > 0) {\n        icon.setBadge(String.valueOf(myProblemsCounter));\n        icon.requestAttention(false);\n      }\n    }\n  }","id":34254,"modified_method":"@Override\n  public void setValue(int n) {\n    super.setValue(n);\n    AppIcon icon = AppIcon.getInstance();\n    if (n < getMaximum()) {\n      if (icon.setProgress(null, TESTS, AppIconScheme.Progress.TESTS, (double)n / (double)getMaximum(), myProblemsCounter == 0)) {\n        if (myProblemsCounter > 0) {\n          icon.setBadge(String.valueOf(myProblemsCounter));\n        }\n      }\n    } else {\n      if (icon.hideProgress(null, TESTS)) {\n        if (myProblemsCounter > 0) {\n          icon.setBadge(String.valueOf(myProblemsCounter));\n          icon.requestAttention(true);\n        }\n      }\n    }\n  }","commit_id":"e3cd6a55af697c8f7ced11a7ade116565dbfeb50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public edu.ucsb.eucalyptus.msgs.Snapshot morph( final edu.ucsb.eucalyptus.msgs.Snapshot snap ) {\n    snap.setSnapshotId( this.getDisplayName( ) );\n    snap.setStatus( this.mapState( ) );\n    snap.setStartTime( this.getCreationTimestamp( ) );\n    snap.setVolumeId( this.getParentVolume( ) );\n    snap.setVolumeSize( Integer.toString( this.getVolumeSize( ) ) );\n    snap.setProgress( this.getState( ).equals( State.EXTANT )\n      ? \"100%\"\n      : this.getProgress( ) );\n    return snap;\n  }","id":34255,"modified_method":"public edu.ucsb.eucalyptus.msgs.Snapshot morph( final edu.ucsb.eucalyptus.msgs.Snapshot snap ) {\n    snap.setSnapshotId( this.getDisplayName( ) );\n    snap.setStatus( this.mapState( ) );\n    snap.setStartTime( this.getCreationTimestamp( ) );\n    snap.setVolumeId( this.getParentVolume( ) );\n    snap.setVolumeSize( Integer.toString( this.getVolumeSize( ) ) );\n    if ( this.getProgress( ) != null ) {\n      snap.setProgress( this.getProgress( ) );\n    } else {\n      snap.setProgress( State.EXTANT.equals( this.getState( ) ) ? \"100%\" : \"0%\" );//GRZE: sigh @ this crap.\n    }\n    return snap;\n  }","commit_id":"f5bd6f700847c18095294fae753b3e96892c735b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void updateSnapshot( String snapshotId, final StorageSnapshot storageSnapshot ) {\n      try {\n        final Function<String, Snapshot> updateSnapshot = new Function<String, Snapshot>( ) {\n          public Snapshot apply( final String input ) {\n            try {\n              Snapshot entity = Entities.uniqueResult( Snapshot.named( null, input ) );\n              StringBuilder buf = new StringBuilder( );\n              buf.append( \"SnapshotStateUpdate: \" )\n                   .append( entity.getPartition( ) ).append( \" \" )\n                   .append( input ).append( \" \" )\n                   .append( entity.getParentVolume( ) ).append( \" \" )\n                   .append( entity.getState( ) ).append( \" \" )\n                   .append( entity.getProgress( ) ).append( \" \" );\n              if ( storageSnapshot != null && !State.EXTANT.equals( entity.getState( ) ) ) {\n                entity.setMappedState( storageSnapshot.getStatus( ) );\n                if ( storageSnapshot.getProgress( ) != null ) {\n                  entity.setProgress( storageSnapshot.getProgress( ) );\n                }\n                buf.append( \" storage-snapshot \" )\n                .append( storageSnapshot.getStatus( ) ).append( \"=>\" ).append( entity.getState( ) ).append( \" \" )\n                .append( storageSnapshot.getProgress( ) ).append( \" \" );\n              } else if ( State.GENERATING.equals( entity.getState( ) ) && entity.lastUpdateMillis( ) > SNAPSHOT_STATE_TIMEOUT ) {\n                Entities.delete( entity );\n              }\n              LOG.debug( buf.toString( ) );\n              return entity;\n            } catch ( TransactionException ex ) {\n              throw Exceptions.toUndeclared( ex );\n            }\n          }\n        };\n        try {\n          Entities.asTransaction( Snapshot.class, updateSnapshot ).apply( snapshotId );\n        } catch ( Exception ex ) {\n          LOG.error( ex );\n          Logs.extreme( ).error( ex, ex );\n        }\n      } catch ( Exception ex ) {\n        LOG.error( ex );\n        Logs.extreme( ).error( ex, ex );\n      }\n    }","id":34256,"modified_method":"public void updateSnapshot( String snapshotId, final StorageSnapshot storageSnapshot ) {\n      try {\n        final Function<String, Snapshot> updateSnapshot = new Function<String, Snapshot>( ) {\n          public Snapshot apply( final String input ) {\n            try {\n              Snapshot entity = Entities.uniqueResult( Snapshot.named( null, input ) );\n              StringBuilder buf = new StringBuilder( );\n              buf.append( \"SnapshotStateUpdate: \" )\n                   .append( entity.getPartition( ) ).append( \" \" )\n                   .append( input ).append( \" \" )\n                   .append( entity.getParentVolume( ) ).append( \" \" )\n                   .append( entity.getState( ) ).append( \" \" )\n                   .append( entity.getProgress( ) ).append( \" \" );\n              if ( storageSnapshot != null ) {\n                if ( storageSnapshot.getStatus( ) != null ) {\n                  entity.setMappedState( storageSnapshot.getStatus( ) );\n                }\n                if ( !State.EXTANT.equals( entity.getState( ) ) && storageSnapshot.getProgress( ) != null ) {\n                  entity.setProgress( storageSnapshot.getProgress( ) );\n                } else if ( State.EXTANT.equals( entity.getState( ) ) ) {\n                  if ( entity.getProgress( ) == null ) {\n                    entity.setProgress( \"100%\" );\n                  }\n                } else if ( State.GENERATING.equals( entity.getState( ) ) ) {\n                  if ( entity.getProgress( ) == null ) {\n                    entity.setProgress( \"0%\" );\n                  }\n                }\n                buf.append( \" storage-snapshot \" )\n                   .append( storageSnapshot.getStatus( ) ).append( \"=>\" ).append( entity.getState( ) ).append( \" \" )\n                   .append( storageSnapshot.getProgress( ) ).append( \" \" );\n              } else if ( State.GENERATING.equals( entity.getState( ) ) && entity.lastUpdateMillis( ) > SNAPSHOT_STATE_TIMEOUT ) {\n                Entities.delete( entity );\n              } else {\n                if ( State.EXTANT.equals( entity.getState( ) ) ) {\n                  if ( entity.getProgress( ) == null ) {\n                    entity.setProgress( \"100%\" );\n                  }\n                } else if ( State.GENERATING.equals( entity.getState( ) ) ) {\n                  if ( entity.getProgress( ) == null ) {\n                    entity.setProgress( \"0%\" );\n                  }\n                }\n              }\n              LOG.debug( buf.toString( ) );\n              return entity;\n            } catch ( TransactionException ex ) {\n              throw Exceptions.toUndeclared( ex );\n            }\n          }\n        };\n        try {\n          Entities.asTransaction( Snapshot.class, updateSnapshot ).apply( snapshotId );\n        } catch ( Exception ex ) {\n          LOG.error( ex );\n          Logs.extreme( ).error( ex, ex );\n        }\n      } catch ( Exception ex ) {\n        LOG.error( ex );\n        Logs.extreme( ).error( ex, ex );\n      }\n    }","commit_id":"f5bd6f700847c18095294fae753b3e96892c735b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void backup(Collection current, BackupWriter output, BackupDialog dialog)\n\t\tthrows XMLDBException, IOException, SAXException {\n\t\tif (current == null)\n\t\t\treturn;\n\t\t\n\t\tcurrent.setProperty(OutputKeys.ENCODING, defaultOutputProperties.getProperty(OutputKeys.ENCODING));\n\t\tcurrent.setProperty(OutputKeys.INDENT, defaultOutputProperties.getProperty(OutputKeys.INDENT));\n\t\tcurrent.setProperty(EXistOutputKeys.EXPAND_XINCLUDES,  defaultOutputProperties.getProperty(EXistOutputKeys.EXPAND_XINCLUDES));\n\t\tcurrent.setProperty(EXistOutputKeys.PROCESS_XSL_PI,  defaultOutputProperties.getProperty(EXistOutputKeys.PROCESS_XSL_PI));\n\t\t\n\t\t// get resources and permissions\n\t\tString[] resources = current.listResources();\n\t\tArrays.sort(resources);\n\t\t\n\t\tUserManagementService mgtService =\n\t\t\t(UserManagementService) current.getService(\"UserManagementService\", \"1.0\");\n\t\tPermission perms[] = mgtService.listResourcePermissions();\n\t\tPermission currentPerms = mgtService.getPermissions(current);\n\n\t\tif (dialog != null) {\n\t\t\tdialog.setCollection(current.getName());\n\t\t\tdialog.setResourceCount(resources.length);\n\t\t}\n        Writer contents = output.newContents();\n\t\t// serializer writes to __contents__.xml\n\t\tSAXSerializer serializer = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n\t\tserializer.setOutput(contents, contentsOutputProps);\n\t\t\n\t\tserializer.startDocument();\n\t\tserializer.startPrefixMapping(\"\", Namespaces.EXIST_NS);\n\t\t// write <collection> element\n\t\tCollectionImpl cur = (CollectionImpl)current;\n\t\tAttributesImpl attr = new AttributesImpl();\n\t\t//The name should have come from an XmldbURI.toString() call\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", current.getName());\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"owner\", \"owner\", \"CDATA\", currentPerms.getOwner());\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"group\", \"group\", \"CDATA\", currentPerms.getOwnerGroup());\n\t\tattr.addAttribute(\n\t\t\t\tNamespaces.EXIST_NS,\n\t\t\t\"mode\",\n\t\t\t\"mode\",\n\t\t\t\"CDATA\",\n\t\t\tInteger.toOctalString(currentPerms.getPermissions()));\n\t\tattr.addAttribute(\n\t\t\t\tNamespaces.EXIST_NS,\n\t\t\t\t\"created\",\n\t\t\t\t\"created\",\n\t\t\t\t\"CDATA\",\n\t\t\t\t\"\"+new DateTimeValue(cur.getCreationTime()));\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"version\", \"version\", \"CDATA\", String.valueOf(currVersion));\n\t\tserializer.startElement(Namespaces.EXIST_NS, \"collection\", \"collection\", attr);\n\n\t\t// scan through resources\n\t\tResource resource;\n\t\tOutputStream os;\n\t\tBufferedWriter writer;\n\t\tSAXSerializer contentSerializer;\n\t\tfor (int i = 0; i < resources.length; i++) {\n            try {\n                if (resources[i].equals(\"__contents__.xml\")) {\n                    //Skipping resources[i]\n                    continue;\n                }\n                resource = current.getResource(resources[i]);\n\n                dialog.setResource(resources[i]);\n                dialog.setProgress(i);\n\n                os = output.newEntry(encode(URIUtils.urlDecodeUtf8(resources[i])));\n                if(resource.getResourceType().equals(\"BinaryResource\")) {\n                    byte[] bdata = (byte[])resource.getContent();\n                    os.write(bdata);\n                } else {\n                    try {\n                        writer =\n                            new BufferedWriter(\n                                    new OutputStreamWriter(os, \"UTF-8\"));\n                        // write resource to contentSerializer\n                        contentSerializer = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n                        contentSerializer.setOutput(writer, defaultOutputProperties);\n                        ((EXistResource)resource).setLexicalHandler(contentSerializer);\n                        ((XMLResource)resource).getContentAsSAX(contentSerializer);\n                        SerializerPool.getInstance().returnObject(contentSerializer);\n                        writer.flush();\n                    } catch(Exception e) {\n                        System.err.println(\"An exception occurred while writing the resource: \" + e.getMessage());\n                        e.printStackTrace();\n                        continue;\n                    }\n                }\n                output.closeEntry();\n                EXistResource ris = (EXistResource)resource;\n                \n                //store permissions\n                attr.clear();\n                attr.addAttribute(Namespaces.EXIST_NS, \"type\", \"type\", \"CDATA\", resource.getResourceType());\n                attr.addAttribute(Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", resources[i]);\n                attr.addAttribute(Namespaces.EXIST_NS, \"owner\", \"owner\", \"CDATA\", perms[i].getOwner());\n                attr.addAttribute(Namespaces.EXIST_NS, \"group\", \"group\", \"CDATA\", perms[i].getOwnerGroup());\n                attr.addAttribute(\n                \t\tNamespaces.EXIST_NS,\n                        \"mode\",\n                        \"mode\",\n                        \"CDATA\",\n                        Integer.toOctalString(perms[i].getPermissions()));\n                Date date = ris.getCreationTime();\n                if (date != null)\n                    attr.addAttribute(\n                    \t\tNamespaces.EXIST_NS,\n                            \"created\",\n                            \"created\",\n                            \"CDATA\",\n                            \"\"+new DateTimeValue(date));\n                date = ris.getLastModificationTime();\n                if (date != null)\n                    attr.addAttribute(\n                    \t\tNamespaces.EXIST_NS,\n                            \"modified\",\n                            \"modified\",\n                            \"CDATA\",\n                            \"\"+new DateTimeValue(date));\n                \n                attr.addAttribute(\n                \t\tNamespaces.EXIST_NS,\n                        \"filename\",\n                        \"filename\",\n                        \"CDATA\",\n                        encode( URIUtils.urlDecodeUtf8(resources[i]) )\n                );\n                attr.addAttribute(\n                \t\tNamespaces.EXIST_NS,\n                        \"mimetype\",\n                        \"mimetype\",\n                        \"CDATA\",\n                        encode( ((EXistResource)resource).getMimeType())\n                );\n                \n                if (!resource.getResourceType().equals(\"BinaryResource\")) {\n\t\t\t\t\tif (ris.getDocType() != null) {\n\t\t\t\t\t\tif (ris.getDocType().getName() != null) {\n\t\t\t\t\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"namedoctype\", \"namedoctype\",\n\t\t\t\t\t\t\t\t\t\"CDATA\", ris.getDocType().getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ris.getDocType().getPublicId() != null) {\n\t\t\t\t\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"publicid\", \"publicid\",\n\t\t\t\t\t\t\t\t\t\"CDATA\", ris.getDocType().getPublicId());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ris.getDocType().getSystemId() != null) {\n\t\t\t\t\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"systemid\", \"systemid\",\n\t\t\t\t\t\t\t\t\t\"CDATA\", ris.getDocType().getSystemId());\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n                serializer.startElement(Namespaces.EXIST_NS, \"resource\", \"resource\", attr);\n                serializer.endElement(Namespaces.EXIST_NS, \"resource\", \"resource\");\n            } catch(XMLDBException e) {\n                System.err.println(\"Failed to backup resource \" + resources[i] + \" from collection \" + current.getName());\n            }\n      }\n\t\t// write subcollections\n\t\tString[] collections = current.listChildCollections();\n\t\tfor (int i = 0; i < collections.length; i++) {\n\t\t\tif (current.getName().equals(NativeBroker.SYSTEM_COLLECTION) && collections[i].equals(\"temp\"))\n\t\t\t\tcontinue;\n\t\t\tattr.clear();\n\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", collections[i]);\n\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"filename\", \"filename\", \"CDATA\", encode(URIUtils.urlDecodeUtf8(collections[i])));\n\t\t\tserializer.startElement(Namespaces.EXIST_NS, \"subcollection\", \"subcollection\", attr);\n\t\t\tserializer.endElement(Namespaces.EXIST_NS, \"subcollection\", \"subcollection\");\n\t\t}\n\t\t// close <collection>\n\t\tserializer.endElement(Namespaces.EXIST_NS, \"collection\", \"collection\");\n\t\tserializer.endPrefixMapping(\"\");\n\t\tserializer.endDocument();\n\t\toutput.closeContents();\n\n        SerializerPool.getInstance().returnObject(serializer);\n\t\t// descend into subcollections\n\t\tCollection child;\n\t\tfor (int i = 0; i < collections.length; i++) {\n\t\t\tchild = current.getChildCollection(collections[i]);\n\t\t\tif (child.getName().equals(NativeBroker.TEMP_COLLECTION))\n\t\t\t\tcontinue;\n            output.newCollection(encode(URIUtils.urlDecodeUtf8(collections[i])));\n            backup(child, output, dialog);\n            output.closeCollection();\n        }\n\t}","id":34257,"modified_method":"private void backup(Collection current, BackupWriter output, BackupDialog dialog)\n\t\tthrows XMLDBException, IOException, SAXException {\n\t\tif (current == null)\n\t\t\treturn;\n\t\t\n\t\tcurrent.setProperty(OutputKeys.ENCODING, defaultOutputProperties.getProperty(OutputKeys.ENCODING));\n\t\tcurrent.setProperty(OutputKeys.INDENT, defaultOutputProperties.getProperty(OutputKeys.INDENT));\n\t\tcurrent.setProperty(EXistOutputKeys.EXPAND_XINCLUDES,  defaultOutputProperties.getProperty(EXistOutputKeys.EXPAND_XINCLUDES));\n\t\tcurrent.setProperty(EXistOutputKeys.PROCESS_XSL_PI,  defaultOutputProperties.getProperty(EXistOutputKeys.PROCESS_XSL_PI));\n\t\t\n\t\t// get resources and permissions\n\t\tString[] resources = current.listResources();\n\t\tArrays.sort(resources);\n\t\t\n\t\tUserManagementService mgtService =\n\t\t\t(UserManagementService) current.getService(\"UserManagementService\", \"1.0\");\n\t\tPermission perms[] = mgtService.listResourcePermissions();\n\t\tPermission currentPerms = mgtService.getPermissions(current);\n\n\t\tif (dialog != null) {\n\t\t\tdialog.setCollection(current.getName());\n\t\t\tdialog.setResourceCount(resources.length);\n\t\t}\n        Writer contents = output.newContents();\n\t\t// serializer writes to __contents__.xml\n\t\tSAXSerializer serializer = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n\t\tserializer.setOutput(contents, contentsOutputProps);\n\t\t\n\t\tserializer.startDocument();\n\t\tserializer.startPrefixMapping(\"\", Namespaces.EXIST_NS);\n\t\t// write <collection> element\n\t\tCollectionImpl cur = (CollectionImpl)current;\n\t\tAttributesImpl attr = new AttributesImpl();\n\t\t//The name should have come from an XmldbURI.toString() call\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", current.getName());\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"owner\", \"owner\", \"CDATA\", currentPerms.getOwner());\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"group\", \"group\", \"CDATA\", currentPerms.getOwnerGroup());\n\t\tattr.addAttribute(\n\t\t\t\tNamespaces.EXIST_NS,\n\t\t\t\"mode\",\n\t\t\t\"mode\",\n\t\t\t\"CDATA\",\n\t\t\tInteger.toOctalString(currentPerms.getPermissions()));\n\t\tattr.addAttribute(\n\t\t\t\tNamespaces.EXIST_NS,\n\t\t\t\t\"created\",\n\t\t\t\t\"created\",\n\t\t\t\t\"CDATA\",\n\t\t\t\t\"\"+new DateTimeValue(cur.getCreationTime()));\n\t\tattr.addAttribute(Namespaces.EXIST_NS, \"version\", \"version\", \"CDATA\", String.valueOf(currVersion));\n\t\tserializer.startElement(Namespaces.EXIST_NS, \"collection\", \"collection\", attr);\n\n\t\t// scan through resources\n\t\tResource resource;\n\t\tOutputStream os;\n\t\tBufferedWriter writer;\n\t\tSAXSerializer contentSerializer;\n\t\tfor (int i = 0; i < resources.length; i++) {\n            try {\n                if (resources[i].equals(\"__contents__.xml\")) {\n                    //Skipping resources[i]\n                    continue;\n                }\n                resource = current.getResource(resources[i]);\n\n                if (dialog != null) {\n                    dialog.setResource(resources[i]);\n                    dialog.setProgress(i);\n                }\n\n                os = output.newEntry(encode(URIUtils.urlDecodeUtf8(resources[i])));\n                if(resource.getResourceType().equals(\"BinaryResource\")) {\n                    byte[] bdata = (byte[])resource.getContent();\n                    os.write(bdata);\n                } else {\n                    try {\n                        writer =\n                            new BufferedWriter(\n                                    new OutputStreamWriter(os, \"UTF-8\"));\n                        // write resource to contentSerializer\n                        contentSerializer = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n                        contentSerializer.setOutput(writer, defaultOutputProperties);\n                        ((EXistResource)resource).setLexicalHandler(contentSerializer);\n                        ((XMLResource)resource).getContentAsSAX(contentSerializer);\n                        SerializerPool.getInstance().returnObject(contentSerializer);\n                        writer.flush();\n                    } catch(Exception e) {\n                        System.err.println(\"An exception occurred while writing the resource: \" + e.getMessage());\n                        e.printStackTrace();\n                        continue;\n                    }\n                }\n                output.closeEntry();\n                EXistResource ris = (EXistResource)resource;\n                \n                //store permissions\n                attr.clear();\n                attr.addAttribute(Namespaces.EXIST_NS, \"type\", \"type\", \"CDATA\", resource.getResourceType());\n                attr.addAttribute(Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", resources[i]);\n                attr.addAttribute(Namespaces.EXIST_NS, \"owner\", \"owner\", \"CDATA\", perms[i].getOwner());\n                attr.addAttribute(Namespaces.EXIST_NS, \"group\", \"group\", \"CDATA\", perms[i].getOwnerGroup());\n                attr.addAttribute(\n                \t\tNamespaces.EXIST_NS,\n                        \"mode\",\n                        \"mode\",\n                        \"CDATA\",\n                        Integer.toOctalString(perms[i].getPermissions()));\n                Date date = ris.getCreationTime();\n                if (date != null)\n                    attr.addAttribute(\n                    \t\tNamespaces.EXIST_NS,\n                            \"created\",\n                            \"created\",\n                            \"CDATA\",\n                            \"\"+new DateTimeValue(date));\n                date = ris.getLastModificationTime();\n                if (date != null)\n                    attr.addAttribute(\n                    \t\tNamespaces.EXIST_NS,\n                            \"modified\",\n                            \"modified\",\n                            \"CDATA\",\n                            \"\"+new DateTimeValue(date));\n                \n                attr.addAttribute(\n                \t\tNamespaces.EXIST_NS,\n                        \"filename\",\n                        \"filename\",\n                        \"CDATA\",\n                        encode( URIUtils.urlDecodeUtf8(resources[i]) )\n                );\n                attr.addAttribute(\n                \t\tNamespaces.EXIST_NS,\n                        \"mimetype\",\n                        \"mimetype\",\n                        \"CDATA\",\n                        encode( ((EXistResource)resource).getMimeType())\n                );\n                \n                if (!resource.getResourceType().equals(\"BinaryResource\")) {\n\t\t\t\t\tif (ris.getDocType() != null) {\n\t\t\t\t\t\tif (ris.getDocType().getName() != null) {\n\t\t\t\t\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"namedoctype\", \"namedoctype\",\n\t\t\t\t\t\t\t\t\t\"CDATA\", ris.getDocType().getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ris.getDocType().getPublicId() != null) {\n\t\t\t\t\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"publicid\", \"publicid\",\n\t\t\t\t\t\t\t\t\t\"CDATA\", ris.getDocType().getPublicId());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ris.getDocType().getSystemId() != null) {\n\t\t\t\t\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"systemid\", \"systemid\",\n\t\t\t\t\t\t\t\t\t\"CDATA\", ris.getDocType().getSystemId());\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n                serializer.startElement(Namespaces.EXIST_NS, \"resource\", \"resource\", attr);\n                serializer.endElement(Namespaces.EXIST_NS, \"resource\", \"resource\");\n            } catch(XMLDBException e) {\n                System.err.println(\"Failed to backup resource \" + resources[i] + \" from collection \" + current.getName());\n            }\n      }\n\t\t// write subcollections\n\t\tString[] collections = current.listChildCollections();\n\t\tfor (int i = 0; i < collections.length; i++) {\n\t\t\tif (current.getName().equals(NativeBroker.SYSTEM_COLLECTION) && collections[i].equals(\"temp\"))\n\t\t\t\tcontinue;\n\t\t\tattr.clear();\n\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"name\", \"name\", \"CDATA\", collections[i]);\n\t\t\tattr.addAttribute(Namespaces.EXIST_NS, \"filename\", \"filename\", \"CDATA\", encode(URIUtils.urlDecodeUtf8(collections[i])));\n\t\t\tserializer.startElement(Namespaces.EXIST_NS, \"subcollection\", \"subcollection\", attr);\n\t\t\tserializer.endElement(Namespaces.EXIST_NS, \"subcollection\", \"subcollection\");\n\t\t}\n\t\t// close <collection>\n\t\tserializer.endElement(Namespaces.EXIST_NS, \"collection\", \"collection\");\n\t\tserializer.endPrefixMapping(\"\");\n\t\tserializer.endDocument();\n\t\toutput.closeContents();\n\n        SerializerPool.getInstance().returnObject(serializer);\n\t\t// descend into subcollections\n\t\tCollection child;\n\t\tfor (int i = 0; i < collections.length; i++) {\n\t\t\tchild = current.getChildCollection(collections[i]);\n\t\t\tif (child.getName().equals(NativeBroker.TEMP_COLLECTION))\n\t\t\t\tcontinue;\n            output.newCollection(encode(URIUtils.urlDecodeUtf8(collections[i])));\n            backup(child, output, dialog);\n            output.closeCollection();\n        }\n\t}","commit_id":"5b0a73e5fcafbd0097011fb0ea19b140aaddab2e","url":"https://github.com/eXist-db/exist"},{"original_method":"public static MultiThreadedHttpConnectionManager getDefaultHttpManager( )\n  {\n    MultiThreadedHttpConnectionManager httpConnMgr = new MultiThreadedHttpConnectionManager();\n    HttpConnectionManagerParams params = httpConnMgr.getParams();\n    params.setDefaultMaxConnectionsPerHost( 128 );\n    params.setMaxTotalConnections( 128 );\n    params.setTcpNoDelay( true );\n    params.setConnectionTimeout( 120*1000 );\n    params.setReceiveBufferSize( 8388608 );\n    params.setSendBufferSize( 8388608 );\n    params.setStaleCheckingEnabled( true );\n    params.setSoTimeout( 120*1000 );\n    params.setLinger( -1 );\n    return httpConnMgr;\n  }","id":34258,"modified_method":"public static MultiThreadedHttpConnectionManager getDefaultHttpManager( )\n  {\n    MultiThreadedHttpConnectionManager httpConnMgr = new MultiThreadedHttpConnectionManager();\n    HttpConnectionManagerParams params = httpConnMgr.getParams();\n    params.setDefaultMaxConnectionsPerHost( 16 );\n    params.setMaxTotalConnections( 16 );\n    params.setTcpNoDelay( true );\n    params.setConnectionTimeout( 120*1000 );\n//    params.setReceiveBufferSize( 8388608 );\n//    params.setSendBufferSize( 8388608 );\n    params.setStaleCheckingEnabled( true );\n    params.setSoTimeout( 120*1000 );\n//    params.setLinger( -1 );\n    return httpConnMgr;\n  }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setMappedState( final String state ) {\n    if( StorageProperties.Status.creating.toString().equals( state ) ) this.setState( State.GENERATING );\n    else if( StorageProperties.Status.completed.equals( state )) this.setState( State.EXTANT );\n    else this.setState( State.FAIL );\n  }","id":34259,"modified_method":"public void setMappedState( final String state ) {\n    if( StorageProperties.Status.creating.toString().equals( state ) ) this.setState( State.GENERATING );\n    else if( StorageProperties.Status.pending.equals( state )) this.setState( State.EXTANT );\n    else if( StorageProperties.Status.completed.equals( state )) this.setState( State.EXTANT );\n    else if( StorageProperties.Status.available.equals( state )) this.setState( State.EXTANT );\n    else if( StorageProperties.Status.failed.equals( state )) this.setState( State.FAIL );\n  }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public edu.ucsb.eucalyptus.msgs.Snapshot morph( final edu.ucsb.eucalyptus.msgs.Snapshot snap ) {\n    snap.setSnapshotId( this.getDisplayName() );\n    snap.setStatus( this.mapState() );\n    snap.setStartTime( this.getBirthday() );\n    snap.setVolumeId( this.getParentVolume() );\n    return snap;\n  }","id":34260,"modified_method":"public edu.ucsb.eucalyptus.msgs.Snapshot morph( final edu.ucsb.eucalyptus.msgs.Snapshot snap ) {\n    snap.setSnapshotId( this.getDisplayName() );\n    snap.setStatus( this.mapState() );\n    snap.setStartTime( this.getBirthday() );\n    snap.setVolumeId( this.getParentVolume() );\n    snap.setProgress( this.getState().equals( State.EXTANT ) ? \"100%\" : \"\" );\n    return snap;\n  }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeSnapshotsResponseType DescribeSnapshots( DescribeSnapshotsType request ) throws EucalyptusCloudException {\n    DescribeSnapshotsResponseType reply = ( DescribeSnapshotsResponseType ) request.getReply();\n    EntityWrapper<Snapshot> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    List<Snapshot> snapshots = db.query( Snapshot.ownedBy( userName ) );\n    for ( Snapshot v : snapshots ) {\n      if ( request.getSnapshotSet().isEmpty() || request.getSnapshotSet().contains( v.getDisplayName() ) ) {\n        DescribeStorageSnapshotsResponseType snapshotInfo = null;\n        try {\n          snapshotInfo = ( DescribeStorageSnapshotsResponseType ) Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageSnapshotsType( Lists.newArrayList( v.getDisplayName() ) ) );\n          LOG.debug( snapshotInfo );\n        } catch ( EucalyptusCloudException e ) {\n          LOG.debug( e, e );\n          throw e;\n        }\n        if( !snapshotInfo.getSnapshotSet().isEmpty() ) {\n          StorageSnapshot storageSnapshot = snapshotInfo.getSnapshotSet().get( 0 );\n          v.setMappedState( storageSnapshot.getStatus() );\n          edu.ucsb.eucalyptus.msgs.Snapshot snapReply = v.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n          snapReply.setProgress( storageSnapshot.getProgress() );\n          reply.getSnapshotSet().add( snapReply );\n        } else {\n          //:: TODO: handle the now-removed snapshot entry case here :://\n        }\n      }\n    }\n    db.commit();\n    return reply;\n  }","id":34261,"modified_method":"public DescribeSnapshotsResponseType DescribeSnapshots( DescribeSnapshotsType request ) throws EucalyptusCloudException {\n    DescribeSnapshotsResponseType reply = ( DescribeSnapshotsResponseType ) request.getReply();\n    EntityWrapper<Snapshot> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    List<Snapshot> snapshots = db.query( Snapshot.ownedBy( userName ) );\n    for ( Snapshot v : snapshots ) {\n      if ( request.getSnapshotSet().isEmpty() || request.getSnapshotSet().contains( v.getDisplayName() ) ) {\n        DescribeStorageSnapshotsResponseType snapshotInfo = null;\n        try {\n          snapshotInfo = ( DescribeStorageSnapshotsResponseType ) Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageSnapshotsType( Lists.newArrayList( v.getDisplayName() ) ) );\n          for( StorageSnapshot storageSnapshot : snapshotInfo.getSnapshotSet() ) {\n            v.setMappedState( storageSnapshot.getStatus() );\n            edu.ucsb.eucalyptus.msgs.Snapshot snapReply = v.morph( new edu.ucsb.eucalyptus.msgs.Snapshot() );\n            if( storageSnapshot.getProgress() != null )\n              snapReply.setProgress( storageSnapshot.getProgress() );\n            snapReply.setVolumeId( storageSnapshot.getVolumeId() );\n            reply.getSnapshotSet().add( snapReply );\n          }\n        } catch ( EucalyptusCloudException e ) {\n          LOG.debug( e, e );\n          throw e;\n        }\n      }\n    }\n    db.commit();\n    LOG.warn( \"RESPONSE ============\\n\" + reply );\n    return reply;\n  }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void cleanFailedVolume(String volumeId) {\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo(volumeId);\n        List<VolumeInfo> volumeInfos = db.query(volumeInfo);\n        if(volumeInfos.size() > 0) {\n            VolumeInfo volInfo = volumeInfos.get(0);\n            LOG.info(\"Cleaning failed volume \" + volumeId);\n            blockManager.cleanVolume(volumeId);\n            try {\n                volumeStorageManager.deleteObject(\"\", volumeId);\n            } catch(Exception ex) {\n                LOG.warn(ex);\n            }\n            db.delete(volInfo);\n        }\n        db.commit();\n    }","id":34262,"modified_method":"private static void cleanFailedVolume(String volumeId) {\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo(volumeId);\n        List<VolumeInfo> volumeInfos = db.query(volumeInfo);\n        if(volumeInfos.size() > 0) {\n            VolumeInfo volInfo = volumeInfos.get(0);\n            LOG.warn(\"Cleaning failed volume \" + volumeId);\n            blockManager.cleanVolume(volumeId);\n            try {\n                volumeStorageManager.deleteObject(\"\", volumeId);\n            } catch(Exception ex) {\n                LOG.warn(ex);\n            }\n            db.delete(volInfo);\n        }\n        db.commit();\n    }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeStorageVolumesResponseType DescribeStorageVolumes(DescribeStorageVolumesType request) throws EucalyptusCloudException {\n        DescribeStorageVolumesResponseType reply = (DescribeStorageVolumesResponseType) request.getReply();\n\n        List<String> volumeSet = request.getVolumeSet();\n        ArrayList<VolumeInfo> volumeInfos = new ArrayList<VolumeInfo>();\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n\n        if((volumeSet != null) && !volumeSet.isEmpty()) {\n            for(String volumeSetEntry: volumeSet) {\n                VolumeInfo volumeInfo = new VolumeInfo(volumeSetEntry);\n                List<VolumeInfo> foundVolumeInfos = db.query(volumeInfo);\n                if(foundVolumeInfos.size() > 0) {\n                    volumeInfos.add(foundVolumeInfos.get(0));\n                }\n            }\n        } else {\n            VolumeInfo volumeInfo = new VolumeInfo();\n            List<VolumeInfo> foundVolumeInfos = db.query(volumeInfo);\n            for(VolumeInfo volInfo : foundVolumeInfos) {\n                volumeInfos.add(volInfo);\n            }\n        }\n\n        ArrayList<StorageVolume> volumes = reply.getVolumeSet();\n        for(VolumeInfo volumeInfo: volumeInfos) {\n            volumes.add(convertVolumeInfo(volumeInfo));\n            if(volumeInfo.getStatus().equals(StorageProperties.Status.failed.toString()))\n                cleanFailedVolume(volumeInfo.getVolumeId());\n        }\n        db.commit();\n        return reply;\n    }","id":34263,"modified_method":"public DescribeStorageVolumesResponseType DescribeStorageVolumes(DescribeStorageVolumesType request) throws EucalyptusCloudException {\n        DescribeStorageVolumesResponseType reply = (DescribeStorageVolumesResponseType) request.getReply();\n\n        List<String> volumeSet = request.getVolumeSet();\n        ArrayList<VolumeInfo> volumeInfos = new ArrayList<VolumeInfo>();\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n\n        if((volumeSet != null) && !volumeSet.isEmpty()) {\n            for(String volumeSetEntry: volumeSet) {\n                VolumeInfo volumeInfo = new VolumeInfo(volumeSetEntry);\n                List<VolumeInfo> foundVolumeInfos = db.query(volumeInfo);\n                if(foundVolumeInfos.size() > 0) {\n                    volumeInfos.add(foundVolumeInfos.get(0));\n                }\n            }\n        } else {\n            VolumeInfo volumeInfo = new VolumeInfo();\n            List<VolumeInfo> foundVolumeInfos = db.query(volumeInfo);\n            for(VolumeInfo volInfo : foundVolumeInfos) {\n                volumeInfos.add(volInfo);\n            }\n        }\n\n        ArrayList<StorageVolume> volumes = reply.getVolumeSet();\n        for(VolumeInfo volumeInfo: volumeInfos) {\n            volumes.add(convertVolumeInfo(volumeInfo));\n            if(volumeInfo.getStatus().equals(StorageProperties.Status.failed.toString())) {\n                LOG.warn( \"Volume looks like it has failed removing it: \" + volumeInfo.getVolumeId() );\n                cleanFailedVolume(volumeInfo.getVolumeId());\n            }\n        }\n        db.commit();\n        return reply;\n    }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void cleanFailedVolumes() {\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo();\n        volumeInfo.setStatus(StorageProperties.Status.failed.toString());\n        List<VolumeInfo> volumeInfos = db.query(volumeInfo);\n        for(VolumeInfo volInfo : volumeInfos) {\n            String volumeId = volInfo.getVolumeId();\n            LOG.info(\"Cleaning failed volume \" + volumeId);\n            blockManager.cleanVolume(volumeId);\n            try {\n                volumeStorageManager.deleteObject(\"\", volumeId);\n            } catch(Exception ex) {\n                LOG.warn(ex);\n            }\n            db.delete(volInfo);\n        }\n        db.commit();\n    }","id":34264,"modified_method":"private static void cleanFailedVolumes() {\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo();\n        volumeInfo.setStatus(StorageProperties.Status.failed.toString());\n        List<VolumeInfo> volumeInfos = db.query(volumeInfo);\n        for(VolumeInfo volInfo : volumeInfos) {\n            String volumeId = volInfo.getVolumeId();\n            LOG.warn(\"Cleaning failed volume \" + volumeId);\n            blockManager.cleanVolume(volumeId);\n            try {\n                volumeStorageManager.deleteObject(\"\", volumeId);\n            } catch(Exception ex) {\n                LOG.warn(ex);\n            }\n            db.delete(volInfo);\n        }\n        db.commit();\n    }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void cleanVolumes() {\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo();\n        volumeInfo.setStatus(StorageProperties.Status.creating.toString());\n        List<VolumeInfo> volumeInfos = db.query(volumeInfo);\n        for(VolumeInfo volInfo : volumeInfos) {\n            String volumeId = volInfo.getVolumeId();\n            LOG.info(\"Cleaning failed volume \" + volumeId);\n            blockManager.cleanVolume(volumeId);\n            try {\n                volumeStorageManager.deleteObject(\"\", volumeId);\n            } catch(Exception ex) {\n                LOG.warn(ex);\n            }\n            db.delete(volInfo);\n        }\n        db.commit();\n        cleanFailedVolumes();\n    }","id":34265,"modified_method":"private static void cleanVolumes() {\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo();\n        volumeInfo.setStatus(StorageProperties.Status.creating.toString());\n        List<VolumeInfo> volumeInfos = db.query(volumeInfo);\n        for(VolumeInfo volInfo : volumeInfos) {\n            String volumeId = volInfo.getVolumeId();\n            LOG.warn(\"Cleaning failed volume \" + volumeId);\n            blockManager.cleanVolume(volumeId);\n            try {\n                volumeStorageManager.deleteObject(\"\", volumeId);\n            } catch(Exception ex) {\n                LOG.warn(ex);\n            }\n            db.delete(volInfo);\n        }\n        db.commit();\n        cleanFailedVolumes();\n    }","commit_id":"e86da5e91bdde3ffd586a779a15a420a7558397b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected DownloadingOptionsDialog(Component parent, LibraryCompositionSettings settings) {\n    super(parent, true);\n    setTitle(\"Downloading Options\");\n    mySettings = settings;\n\n    myFilesList.setModel(new CollectionListModel(ContainerUtil.map2Array(settings.getLibraryInfos(), new Function<LibraryInfo, Object>() {\n      @Override\n      public Object fun(LibraryInfo libraryInfo) {\n        return new JCheckBox(libraryInfo.getPresentableName(), libraryInfo.isSelected());\n      }\n    })));\n    myFilesToDownloadLabel.setLabelFor(myFilesList);\n\n    myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                             ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                             FileChooserDescriptorFactory.createSingleFolderDescriptor());\n\n    myCopyDownloadedFilesToLabel.setLabelFor(myDirectoryField);\n    myDirectoryField.setText(settings.getDirectoryForDownloadedLibrariesPath());\n\n    myDownloadSourcesCheckBox.setSelected(settings.isDownloadSources());\n    myDownloadJavadocsCheckBox.setSelected(settings.isDownloadJavadocs());\n\n    myNameAndLevelPanel = new LibraryNameAndLevelPanel();\n    myNameWrappingPanel.add(myNameAndLevelPanel.getPanel());\n    myNameAndLevelPanel.reset(settings);\n    init();\n  }","id":34266,"modified_method":"protected DownloadingOptionsDialog(Component parent, LibraryCompositionSettings settings) {\n    super(parent, true);\n    setTitle(\"Downloading Options\");\n    mySettings = settings;\n\n    myFilesList.setModel(new CollectionListModel(ContainerUtil.map2Array(settings.getLibraryInfos(), new Function<LibraryInfo, Object>() {\n      @Override\n      public Object fun(LibraryInfo libraryInfo) {\n        return new JCheckBox(libraryInfo.getName(), libraryInfo.isSelected());\n      }\n    })));\n    myFilesToDownloadLabel.setLabelFor(myFilesList);\n\n    myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                             ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                             FileChooserDescriptorFactory.createSingleFolderDescriptor());\n\n    myCopyDownloadedFilesToLabel.setLabelFor(myDirectoryField);\n    myDirectoryField.setText(settings.getDirectoryForDownloadedLibrariesPath());\n\n    myDownloadSourcesCheckBox.setSelected(settings.isDownloadSources());\n    myDownloadJavadocsCheckBox.setSelected(settings.isDownloadJavadocs());\n\n    myNameAndLevelPanel = new LibraryNameAndLevelPanel();\n    myNameWrappingPanel.add(myNameAndLevelPanel.getPanel());\n    myNameAndLevelPanel.reset(settings);\n    init();\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LibraryInfo(final @NonNls String presentableName, final @Nullable LibraryDownloadInfo downloadInfo, String... requiredClasses) {\n    myPresentableName = presentableName;\n    myRequiredClasses = requiredClasses;\n    myDownloadInfo = downloadInfo;\n  }","id":34267,"modified_method":"public LibraryInfo(final @NonNls String name, final @Nullable LibraryDownloadInfo downloadInfo, String... requiredClasses) {\n    myName = name;\n    myRequiredClasses = requiredClasses;\n    myDownloadInfo = downloadInfo;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n    int result;\n    result = (myDownloadInfo != null ? myDownloadInfo.hashCode() : 0);\n    result = 31 * result + myPresentableName.hashCode();\n    result = 31 * result + Arrays.hashCode(myRequiredClasses);\n    return result;\n  }","id":34268,"modified_method":"public int hashCode() {\n    int result;\n    result = (myDownloadInfo != null ? myDownloadInfo.hashCode() : 0);\n    result = 31 * result + myName.hashCode();\n    result = 31 * result + Arrays.hashCode(myRequiredClasses);\n    return result;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LibraryInfo(final @NonNls String presentableName, final @Nullable @NonNls String version,\n                         final @Nullable @NonNls String downloadingUrl,\n                     final @Nullable String presentableUrl, final @NonNls String... requiredClasses) {\n    myPresentableName = presentableName;\n    myRequiredClasses = requiredClasses;\n    if (downloadingUrl != null) {\n      int dot = presentableName.lastIndexOf('.');\n      String prefix = presentableName.substring(0, dot);\n      String suffix = presentableName.substring(dot);\n      myDownloadInfo = new LibraryDownloadInfo(downloadingUrl, presentableUrl, prefix, suffix);\n    }\n    else {\n      myDownloadInfo = null;\n    }\n  }","id":34269,"modified_method":"public LibraryInfo(final @NonNls String name,\n                     final @Nullable @NonNls String downloadingUrl,\n                     final @Nullable String presentableUrl, final @NonNls String... requiredClasses) {\n    myName = name;\n    myRequiredClasses = requiredClasses;\n    if (downloadingUrl != null) {\n      int dot = name.lastIndexOf('.');\n      String prefix = name.substring(0, dot);\n      String suffix = name.substring(dot);\n      myDownloadInfo = new LibraryDownloadInfo(downloadingUrl, presentableUrl, prefix, suffix);\n    }\n    else {\n      myDownloadInfo = null;\n    }\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    return getPresentableName();\n  }","id":34270,"modified_method":"@Override\n  public String toString() {\n    return getName();\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    final LibraryInfo that = (LibraryInfo)o;\n\n    if (myDownloadInfo != null ? !myDownloadInfo.equals(that.myDownloadInfo) : that.myDownloadInfo != null) return false;\n    if (!myPresentableName.equals(that.myPresentableName)) return false;\n    if (!Arrays.equals(myRequiredClasses, that.myRequiredClasses)) return false;\n\n    return true;\n  }","id":34271,"modified_method":"public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    final LibraryInfo that = (LibraryInfo)o;\n\n    if (myDownloadInfo != null ? !myDownloadInfo.equals(that.myDownloadInfo) : that.myDownloadInfo != null) return false;\n    if (!myName.equals(that.myName)) return false;\n    if (!Arrays.equals(myRequiredClasses, that.myRequiredClasses)) return false;\n\n    return true;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getLibrariesPresentableText(final LibraryInfo[] libraryInfos) {\n    StringBuilder missedJarsText = new StringBuilder();\n    for (int i = 0; i < libraryInfos.length; i++) {\n      if (i > 0) {\n        missedJarsText.append(\", \");\n      }\n\n      missedJarsText.append(libraryInfos[i].getPresentableName());\n    }\n    return missedJarsText.toString();\n  }","id":34272,"modified_method":"public static String getLibrariesPresentableText(final LibraryInfo[] libraryInfos) {\n    StringBuilder missedJarsText = new StringBuilder();\n    for (int i = 0; i < libraryInfos.length; i++) {\n      if (i > 0) {\n        missedJarsText.append(\", \");\n      }\n\n      missedJarsText.append(libraryInfos[i].getName());\n    }\n    return missedJarsText.toString();\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateCurrentVersion(JComboBox comboBox) {\n    final LibraryVersionInfo versionInfo = getSelectedVersion(comboBox);\n\n    if (versionInfo != null) {\n      myCurrentVersion = versionInfo;\n      myValidator.setDescription(getFacetLibrariesValidatorDescription(versionInfo));\n      myValidator.setRequiredLibraries(getRequiredLibraries(versionInfo));\n    }\n  }","id":34273,"modified_method":"private void updateCurrentVersion(JComboBox comboBox) {\n    final Version versionInfo = getSelectedVersion(comboBox);\n\n    if (versionInfo != null) {\n      myCurrentVersion = versionInfo;\n      myValidator.setDescription(getFacetLibrariesValidatorDescription(versionInfo));\n      myValidator.setRequiredLibraries(getRequiredLibraries(versionInfo));\n    }\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComboBox createComboBox(String ri) {\n    final JComboBox comboBox = new JComboBox();\n\n    List<LibraryVersionInfo> versions = getSupportedVersions(ri);\n    comboBox.setModel(new CollectionComboBoxModel(versions, null));\n\n    comboBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateCurrentVersion(comboBox);\n      }\n    });\n\n    return comboBox;\n  }","id":34274,"modified_method":"private JComboBox createComboBox(String ri) {\n    final JComboBox comboBox = new JComboBox();\n\n    List<Version> versions = getSupportedVersions(ri);\n    comboBox.setModel(new CollectionComboBoxModel(versions, null));\n\n    comboBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateCurrentVersion(comboBox);\n      }\n    });\n\n    return comboBox;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addSingletonReferenceImplementationUI(@NotNull final String ri) {\n    JComboBox comboBox = createComboBox(ri);\n    addToPanel(new JLabel(ri), comboBox);\n    LibraryVersionInfo version = getCurrentVersion(ri);\n    if (version != null) {\n      comboBox.setSelectedItem(version);\n    }\n  }","id":34275,"modified_method":"private void addSingletonReferenceImplementationUI(@NotNull final String ri) {\n    JComboBox comboBox = createComboBox(ri);\n    addToPanel(new JLabel(ri), comboBox);\n    Version version = getCurrentVersion(ri);\n    if (version != null) {\n      comboBox.setSelectedItem(version);\n    }\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Set<String> getRIs() {\n    Set<String> ris = new HashSet<String>();\n    for (LibraryVersionInfo info : getLibraries().keySet()) {\n      String ri = info.getRI();\n      if (!StringUtil.isEmptyOrSpaces(ri)) {\n        ris.add(ri);\n      }\n      else {\n        ris.add(UNKNOWN_RI_NAME);\n      }\n    }\n    return ris;\n  }","id":34276,"modified_method":"public Set<String> getRIs() {\n    Set<String> ris = new HashSet<String>();\n    for (Version version : getLibraries()) {\n      String ri = version.getRI();\n      if (!StringUtil.isEmptyOrSpaces(ri)) {\n        ris.add(ri);\n      }\n      else {\n        ris.add(UNKNOWN_RI_NAME);\n      }\n    }\n    return ris;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public LibraryVersionInfo getCurrentLibraryVersionInfo() {\n    return myCurrentVersion;\n  }","id":34277,"modified_method":"@Nullable\n  public Version getCurrentVersion() {\n    return myCurrentVersion;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected FacetLibrariesValidatorDescription getFacetLibrariesValidatorDescription(LibraryVersionInfo versionInfo) {\n    return new FacetLibrariesValidatorDescription(versionInfo.getVersion()) {\n      @NonNls\n      public String getDefaultLibraryName() {\n        if (myCurrentVersion != null) {\n          String ri = myCurrentVersion.getRI();\n          String version = myCurrentVersion.getVersion();\n\n          return StringUtil.isEmptyOrSpaces(ri) ? version : ri + \".\" + version;\n        }\n\n        return super.getDefaultLibraryName();\n      }\n    };\n  }","id":34278,"modified_method":"protected FacetLibrariesValidatorDescription getFacetLibrariesValidatorDescription(Version version) {\n    return new FacetLibrariesValidatorDescription(version.getId()) {\n      @NonNls\n      public String getDefaultLibraryName() {\n        if (myCurrentVersion != null) {\n          String ri = myCurrentVersion.getRI();\n          String version = myCurrentVersion.getId();\n\n          return StringUtil.isEmptyOrSpaces(ri) ? version : ri + \".\" + version;\n        }\n\n        return super.getDefaultLibraryName();\n      }\n    };\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JRadioButton createRadioButton(final String ri) {\n    final JRadioButton radioButton = new JRadioButton(ri);\n    radioButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent actionEvent) {\n        for (Pair<JRadioButton, JComboBox> pair : myButtons.values()) {\n          if (pair.getFirst().equals(radioButton)) {\n            JComboBox comboBox = pair.second;\n            comboBox.setEnabled(true);\n\n            LibraryVersionInfo currentVersion = getCurrentVersion(ri);\n            if (currentVersion != null) {\n              comboBox.setSelectedItem(currentVersion);\n            }\n            else {\n              if (comboBox.getSelectedIndex() < 0) {\n                comboBox.setSelectedItem(getAppropriateVersion(getSupportedVersions(ri)));\n              }\n              else {\n                updateCurrentVersion(comboBox); // activate already selected\n              }\n            }\n          }\n          else {\n            pair.second.setEnabled(false);\n          }\n        }\n      }\n    });\n    return radioButton;\n  }","id":34279,"modified_method":"private JRadioButton createRadioButton(final String ri) {\n    final JRadioButton radioButton = new JRadioButton(ri);\n    radioButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent actionEvent) {\n        for (Pair<JRadioButton, JComboBox> pair : myButtons.values()) {\n          if (pair.getFirst().equals(radioButton)) {\n            JComboBox comboBox = pair.second;\n            comboBox.setEnabled(true);\n\n            Version currentVersion = getCurrentVersion(ri);\n            if (currentVersion != null) {\n              comboBox.setSelectedItem(currentVersion);\n            }\n            else {\n              if (comboBox.getSelectedIndex() < 0) {\n                comboBox.setSelectedItem(getAppropriateVersion(getSupportedVersions(ri)));\n              }\n              else {\n                updateCurrentVersion(comboBox); // activate already selected\n              }\n            }\n          }\n          else {\n            pair.second.setEnabled(false);\n          }\n        }\n      }\n    });\n    return radioButton;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private LibraryVersionInfo getCurrentVersion(@NotNull String currentRI) {\n    String detectionClass = getFacetDetectionClass(currentRI);\n    if (detectionClass != null) {\n      final String version = JarVersionDetectionUtil.detectJarVersion(detectionClass, myModule);\n      if (version != null) {\n        LibraryVersionInfo approximatedVersion = null;\n        for (LibraryVersionInfo info : getLibraries().keySet()) {\n          if (version.equals(info.getVersion())) {\n            return info;\n          }\n          if (version.contains(info.getVersion())) {\n            approximatedVersion = info;\n          }\n        }\n        return approximatedVersion;\n      }\n    }\n\n    return null;\n  }","id":34280,"modified_method":"@Nullable\n  private Version getCurrentVersion(@NotNull String currentRI) {\n    String detectionClass = getFacetDetectionClass(currentRI);\n    if (detectionClass != null) {\n      final String version = JarVersionDetectionUtil.detectJarVersion(detectionClass, myModule);\n      if (version != null) {\n        Version approximatedVersion = null;\n        for (Version info : getLibraries()) {\n          if (version.equals(info.getId())) {\n            return info;\n          }\n          if (version.contains(info.getId())) {\n            approximatedVersion = info;\n          }\n        }\n        return approximatedVersion;\n      }\n    }\n\n    return null;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static LibraryVersionInfo getAppropriateVersion(List<LibraryVersionInfo> versions) {\n    return versions.size() > 0 ? versions.get(0) : null;\n  }","id":34281,"modified_method":"private static LibraryInfo[] getRequiredLibraries(Version version) {\n    final LibraryInfo[] infos = LibrariesDownloadAssistant.getLibraryInfos(version);\n\n    return infos == null ? LibraryInfo.EMPTY_ARRAY : infos;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static LibraryVersionInfo getSelectedVersion(@NotNull JComboBox comboBox) {\n    final Object version = comboBox.getModel().getSelectedItem();\n    return version instanceof LibraryVersionInfo ? (LibraryVersionInfo)version : null;\n  }","id":34282,"modified_method":"@Nullable\n  private static Version getSelectedVersion(@NotNull JComboBox comboBox) {\n    final Object version = comboBox.getModel().getSelectedItem();\n    return version instanceof Version ? (Version)version : null;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<LibraryVersionInfo> getSupportedVersions(@NotNull String ri) {\n    List<LibraryVersionInfo> versions = new ArrayList<LibraryVersionInfo>();\n    for (Map.Entry<LibraryVersionInfo, List<LibraryInfo>> entry : getLibraries().entrySet()) {\n      if (ri.equals(entry.getKey().getRI())) {\n        versions.add(entry.getKey());\n      }\n    }\n\n    return versions;\n  }","id":34283,"modified_method":"private List<Version> getSupportedVersions(@NotNull String ri) {\n    List<Version> versions = new ArrayList<Version>();\n    for (Version version : getLibraries()) {\n      if (ri.equals(version.getRI())) {\n        versions.add(version);\n      }\n    }\n\n    return versions;\n  }","commit_id":"0deb21ba60eda1263d9186a16633e6c1d7a8fff2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected DownloadingOptionsDialog(Component parent, LibraryCompositionSettings settings) {\n    super(parent, true);\n    setTitle(\"Downloading Options\");\n    mySettings = settings;\n\n    myFilesList.setModel(new CollectionListModel(ContainerUtil.map2Array(settings.getLibraryInfos(), new Function<LibraryInfo, Object>() {\n      @Override\n      public Object fun(LibraryInfo libraryInfo) {\n        return new JCheckBox(libraryInfo.getPresentableName(), libraryInfo.isSelected());\n      }\n    })));\n    myFilesToDownloadLabel.setLabelFor(myFilesList);\n\n    myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                             ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                             FileChooserDescriptorFactory.createSingleFolderDescriptor());\n\n    myCopyDownloadedFilesToLabel.setLabelFor(myDirectoryField);\n    myDirectoryField.setText(settings.getDirectoryForDownloadedLibrariesPath());\n\n    myDownloadSourcesCheckBox.setSelected(settings.isDownloadSources());\n    myDownloadJavadocsCheckBox.setSelected(settings.isDownloadJavadocs());\n\n    myNameAndLevelPanel = new LibraryNameAndLevelPanel();\n    myNameWrappingPanel.add(myNameAndLevelPanel.getPanel());\n    myNameAndLevelPanel.reset(settings);\n    init();\n  }","id":34284,"modified_method":"protected DownloadingOptionsDialog(Component parent, LibraryCompositionSettings settings) {\n    super(parent, true);\n    setTitle(\"Downloading Options\");\n    mySettings = settings;\n\n    myFilesList.setModel(new CollectionListModel(ContainerUtil.map2Array(settings.getLibraryInfos(), new Function<LibraryInfo, Object>() {\n      @Override\n      public Object fun(LibraryInfo libraryInfo) {\n        return new JCheckBox(libraryInfo.getName(), libraryInfo.isSelected());\n      }\n    })));\n    myFilesToDownloadLabel.setLabelFor(myFilesList);\n\n    myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                             ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                             FileChooserDescriptorFactory.createSingleFolderDescriptor());\n\n    myCopyDownloadedFilesToLabel.setLabelFor(myDirectoryField);\n    myDirectoryField.setText(settings.getDirectoryForDownloadedLibrariesPath());\n\n    myDownloadSourcesCheckBox.setSelected(settings.isDownloadSources());\n    myDownloadJavadocsCheckBox.setSelected(settings.isDownloadJavadocs());\n\n    myNameAndLevelPanel = new LibraryNameAndLevelPanel();\n    myNameWrappingPanel.add(myNameAndLevelPanel.getPanel());\n    myNameAndLevelPanel.reset(settings);\n    init();\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    return getPresentableName();\n  }","id":34285,"modified_method":"@Override\n  public String toString() {\n    return getName();\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LibraryInfo(final @NonNls String presentableName, final @Nullable @NonNls String version,\n                         final @Nullable @NonNls String downloadingUrl,\n                     final @Nullable String presentableUrl, final @NonNls String... requiredClasses) {\n    myPresentableName = presentableName;\n    myRequiredClasses = requiredClasses;\n    if (downloadingUrl != null) {\n      int dot = presentableName.lastIndexOf('.');\n      String prefix = presentableName.substring(0, dot);\n      String suffix = presentableName.substring(dot);\n      myDownloadInfo = new LibraryDownloadInfo(downloadingUrl, presentableUrl, prefix, suffix);\n    }\n    else {\n      myDownloadInfo = null;\n    }\n  }","id":34286,"modified_method":"public LibraryInfo(final @NonNls String name,\n                     final @Nullable @NonNls String downloadingUrl,\n                     final @Nullable String presentableUrl, final @NonNls String... requiredClasses) {\n    myName = name;\n    myRequiredClasses = requiredClasses;\n    if (downloadingUrl != null) {\n      int dot = name.lastIndexOf('.');\n      String prefix = name.substring(0, dot);\n      String suffix = name.substring(dot);\n      myDownloadInfo = new LibraryDownloadInfo(downloadingUrl, presentableUrl, prefix, suffix);\n    }\n    else {\n      myDownloadInfo = null;\n    }\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n    int result;\n    result = (myDownloadInfo != null ? myDownloadInfo.hashCode() : 0);\n    result = 31 * result + myPresentableName.hashCode();\n    result = 31 * result + Arrays.hashCode(myRequiredClasses);\n    return result;\n  }","id":34287,"modified_method":"public int hashCode() {\n    int result;\n    result = (myDownloadInfo != null ? myDownloadInfo.hashCode() : 0);\n    result = 31 * result + myName.hashCode();\n    result = 31 * result + Arrays.hashCode(myRequiredClasses);\n    return result;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    final LibraryInfo that = (LibraryInfo)o;\n\n    if (myDownloadInfo != null ? !myDownloadInfo.equals(that.myDownloadInfo) : that.myDownloadInfo != null) return false;\n    if (!myPresentableName.equals(that.myPresentableName)) return false;\n    if (!Arrays.equals(myRequiredClasses, that.myRequiredClasses)) return false;\n\n    return true;\n  }","id":34288,"modified_method":"public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    final LibraryInfo that = (LibraryInfo)o;\n\n    if (myDownloadInfo != null ? !myDownloadInfo.equals(that.myDownloadInfo) : that.myDownloadInfo != null) return false;\n    if (!myName.equals(that.myName)) return false;\n    if (!Arrays.equals(myRequiredClasses, that.myRequiredClasses)) return false;\n\n    return true;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LibraryInfo(final @NonNls String presentableName, final @Nullable LibraryDownloadInfo downloadInfo, String... requiredClasses) {\n    myPresentableName = presentableName;\n    myRequiredClasses = requiredClasses;\n    myDownloadInfo = downloadInfo;\n  }","id":34289,"modified_method":"public LibraryInfo(final @NonNls String name, final @Nullable LibraryDownloadInfo downloadInfo, String... requiredClasses) {\n    myName = name;\n    myRequiredClasses = requiredClasses;\n    myDownloadInfo = downloadInfo;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getLibrariesPresentableText(final LibraryInfo[] libraryInfos) {\n    StringBuilder missedJarsText = new StringBuilder();\n    for (int i = 0; i < libraryInfos.length; i++) {\n      if (i > 0) {\n        missedJarsText.append(\", \");\n      }\n\n      missedJarsText.append(libraryInfos[i].getPresentableName());\n    }\n    return missedJarsText.toString();\n  }","id":34290,"modified_method":"public static String getLibrariesPresentableText(final LibraryInfo[] libraryInfos) {\n    StringBuilder missedJarsText = new StringBuilder();\n    for (int i = 0; i < libraryInfos.length; i++) {\n      if (i > 0) {\n        missedJarsText.append(\", \");\n      }\n\n      missedJarsText.append(libraryInfos[i].getName());\n    }\n    return missedJarsText.toString();\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<LibraryVersionInfo> getSupportedVersions(@NotNull String ri) {\n    List<LibraryVersionInfo> versions = new ArrayList<LibraryVersionInfo>();\n    for (Map.Entry<LibraryVersionInfo, List<LibraryInfo>> entry : getLibraries().entrySet()) {\n      if (ri.equals(entry.getKey().getRI())) {\n        versions.add(entry.getKey());\n      }\n    }\n\n    return versions;\n  }","id":34291,"modified_method":"private List<Version> getSupportedVersions(@NotNull String ri) {\n    List<Version> versions = new ArrayList<Version>();\n    for (Version version : getLibraries()) {\n      if (ri.equals(version.getRI())) {\n        versions.add(version);\n      }\n    }\n\n    return versions;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addSingletonReferenceImplementationUI(@NotNull final String ri) {\n    JComboBox comboBox = createComboBox(ri);\n    addToPanel(new JLabel(ri), comboBox);\n    LibraryVersionInfo version = getCurrentVersion(ri);\n    if (version != null) {\n      comboBox.setSelectedItem(version);\n    }\n  }","id":34292,"modified_method":"private void addSingletonReferenceImplementationUI(@NotNull final String ri) {\n    JComboBox comboBox = createComboBox(ri);\n    addToPanel(new JLabel(ri), comboBox);\n    Version version = getCurrentVersion(ri);\n    if (version != null) {\n      comboBox.setSelectedItem(version);\n    }\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static LibraryVersionInfo getAppropriateVersion(List<LibraryVersionInfo> versions) {\n    return versions.size() > 0 ? versions.get(0) : null;\n  }","id":34293,"modified_method":"private static LibraryInfo[] getRequiredLibraries(Version version) {\n    final LibraryInfo[] infos = LibrariesDownloadAssistant.getLibraryInfos(version);\n\n    return infos == null ? LibraryInfo.EMPTY_ARRAY : infos;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateCurrentVersion(JComboBox comboBox) {\n    final LibraryVersionInfo versionInfo = getSelectedVersion(comboBox);\n\n    if (versionInfo != null) {\n      myCurrentVersion = versionInfo;\n      myValidator.setDescription(getFacetLibrariesValidatorDescription(versionInfo));\n      myValidator.setRequiredLibraries(getRequiredLibraries(versionInfo));\n    }\n  }","id":34294,"modified_method":"private void updateCurrentVersion(JComboBox comboBox) {\n    final Version versionInfo = getSelectedVersion(comboBox);\n\n    if (versionInfo != null) {\n      myCurrentVersion = versionInfo;\n      myValidator.setDescription(getFacetLibrariesValidatorDescription(versionInfo));\n      myValidator.setRequiredLibraries(getRequiredLibraries(versionInfo));\n    }\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Set<String> getRIs() {\n    Set<String> ris = new HashSet<String>();\n    for (LibraryVersionInfo info : getLibraries().keySet()) {\n      String ri = info.getRI();\n      if (!StringUtil.isEmptyOrSpaces(ri)) {\n        ris.add(ri);\n      }\n      else {\n        ris.add(UNKNOWN_RI_NAME);\n      }\n    }\n    return ris;\n  }","id":34295,"modified_method":"public Set<String> getRIs() {\n    Set<String> ris = new HashSet<String>();\n    for (Version version : getLibraries()) {\n      String ri = version.getRI();\n      if (!StringUtil.isEmptyOrSpaces(ri)) {\n        ris.add(ri);\n      }\n      else {\n        ris.add(UNKNOWN_RI_NAME);\n      }\n    }\n    return ris;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected FacetLibrariesValidatorDescription getFacetLibrariesValidatorDescription(LibraryVersionInfo versionInfo) {\n    return new FacetLibrariesValidatorDescription(versionInfo.getVersion()) {\n      @NonNls\n      public String getDefaultLibraryName() {\n        if (myCurrentVersion != null) {\n          String ri = myCurrentVersion.getRI();\n          String version = myCurrentVersion.getVersion();\n\n          return StringUtil.isEmptyOrSpaces(ri) ? version : ri + \".\" + version;\n        }\n\n        return super.getDefaultLibraryName();\n      }\n    };\n  }","id":34296,"modified_method":"protected FacetLibrariesValidatorDescription getFacetLibrariesValidatorDescription(Version version) {\n    return new FacetLibrariesValidatorDescription(version.getId()) {\n      @NonNls\n      public String getDefaultLibraryName() {\n        if (myCurrentVersion != null) {\n          String ri = myCurrentVersion.getRI();\n          String version = myCurrentVersion.getId();\n\n          return StringUtil.isEmptyOrSpaces(ri) ? version : ri + \".\" + version;\n        }\n\n        return super.getDefaultLibraryName();\n      }\n    };\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComboBox createComboBox(String ri) {\n    final JComboBox comboBox = new JComboBox();\n\n    List<LibraryVersionInfo> versions = getSupportedVersions(ri);\n    comboBox.setModel(new CollectionComboBoxModel(versions, null));\n\n    comboBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateCurrentVersion(comboBox);\n      }\n    });\n\n    return comboBox;\n  }","id":34297,"modified_method":"private JComboBox createComboBox(String ri) {\n    final JComboBox comboBox = new JComboBox();\n\n    List<Version> versions = getSupportedVersions(ri);\n    comboBox.setModel(new CollectionComboBoxModel(versions, null));\n\n    comboBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateCurrentVersion(comboBox);\n      }\n    });\n\n    return comboBox;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JRadioButton createRadioButton(final String ri) {\n    final JRadioButton radioButton = new JRadioButton(ri);\n    radioButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent actionEvent) {\n        for (Pair<JRadioButton, JComboBox> pair : myButtons.values()) {\n          if (pair.getFirst().equals(radioButton)) {\n            JComboBox comboBox = pair.second;\n            comboBox.setEnabled(true);\n\n            LibraryVersionInfo currentVersion = getCurrentVersion(ri);\n            if (currentVersion != null) {\n              comboBox.setSelectedItem(currentVersion);\n            }\n            else {\n              if (comboBox.getSelectedIndex() < 0) {\n                comboBox.setSelectedItem(getAppropriateVersion(getSupportedVersions(ri)));\n              }\n              else {\n                updateCurrentVersion(comboBox); // activate already selected\n              }\n            }\n          }\n          else {\n            pair.second.setEnabled(false);\n          }\n        }\n      }\n    });\n    return radioButton;\n  }","id":34298,"modified_method":"private JRadioButton createRadioButton(final String ri) {\n    final JRadioButton radioButton = new JRadioButton(ri);\n    radioButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent actionEvent) {\n        for (Pair<JRadioButton, JComboBox> pair : myButtons.values()) {\n          if (pair.getFirst().equals(radioButton)) {\n            JComboBox comboBox = pair.second;\n            comboBox.setEnabled(true);\n\n            Version currentVersion = getCurrentVersion(ri);\n            if (currentVersion != null) {\n              comboBox.setSelectedItem(currentVersion);\n            }\n            else {\n              if (comboBox.getSelectedIndex() < 0) {\n                comboBox.setSelectedItem(getAppropriateVersion(getSupportedVersions(ri)));\n              }\n              else {\n                updateCurrentVersion(comboBox); // activate already selected\n              }\n            }\n          }\n          else {\n            pair.second.setEnabled(false);\n          }\n        }\n      }\n    });\n    return radioButton;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private LibraryVersionInfo getCurrentVersion(@NotNull String currentRI) {\n    String detectionClass = getFacetDetectionClass(currentRI);\n    if (detectionClass != null) {\n      final String version = JarVersionDetectionUtil.detectJarVersion(detectionClass, myModule);\n      if (version != null) {\n        LibraryVersionInfo approximatedVersion = null;\n        for (LibraryVersionInfo info : getLibraries().keySet()) {\n          if (version.equals(info.getVersion())) {\n            return info;\n          }\n          if (version.contains(info.getVersion())) {\n            approximatedVersion = info;\n          }\n        }\n        return approximatedVersion;\n      }\n    }\n\n    return null;\n  }","id":34299,"modified_method":"@Nullable\n  private Version getCurrentVersion(@NotNull String currentRI) {\n    String detectionClass = getFacetDetectionClass(currentRI);\n    if (detectionClass != null) {\n      final String version = JarVersionDetectionUtil.detectJarVersion(detectionClass, myModule);\n      if (version != null) {\n        Version approximatedVersion = null;\n        for (Version info : getLibraries()) {\n          if (version.equals(info.getId())) {\n            return info;\n          }\n          if (version.contains(info.getId())) {\n            approximatedVersion = info;\n          }\n        }\n        return approximatedVersion;\n      }\n    }\n\n    return null;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public LibraryVersionInfo getCurrentLibraryVersionInfo() {\n    return myCurrentVersion;\n  }","id":34300,"modified_method":"@Nullable\n  public Version getCurrentVersion() {\n    return myCurrentVersion;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static LibraryVersionInfo getSelectedVersion(@NotNull JComboBox comboBox) {\n    final Object version = comboBox.getModel().getSelectedItem();\n    return version instanceof LibraryVersionInfo ? (LibraryVersionInfo)version : null;\n  }","id":34301,"modified_method":"@Nullable\n  private static Version getSelectedVersion(@NotNull JComboBox comboBox) {\n    final Object version = comboBox.getModel().getSelectedItem();\n    return version instanceof Version ? (Version)version : null;\n  }","commit_id":"82b5f8971fba42d88bec4e9c2fdcddbd33458f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void restoreExceptionOnExchange(Exchange exchange) {\n        exchange.setException(exchange.getProperty(FAILURE_HANDLED_PROPERTY, Throwable.class));\n    }","id":34302,"modified_method":"protected static void restoreExceptionOnExchange(Exchange exchange, Predicate handledPredicate) {\n        if (handledPredicate == null || !handledPredicate.matches(exchange)) {\n            // exception not handled, put exception back in the exchange\n            exchange.setException(exchange.getProperty(FAILURE_HANDLED_PROPERTY, Throwable.class));\n        } else {\n            exchange.setProperty(Exchange.EXCEPTION_HANDLED_PROPERTY, Boolean.TRUE);\n        }\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) {\n\n        while (true) {\n            // we can't keep retrying if the route is being shutdown.\n            if (!isRunAllowed()) {\n                if (exchange.getException() == null) {\n                    exchange.setException(new RejectedExecutionException());\n                }\n                callback.done(data.sync);\n                return data.sync;\n            }\n\n            // if the exchange is transacted then let the underlying system handle the redelivery etc.\n            // this DeadLetterChannel is only for non transacted exchanges\n            if (exchange.isTransacted() && exchange.getException() != null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"This is a transacted exchange, bypassing this DeadLetterChannel: \" + this + \" for exchange: \" + exchange);\n                }\n                return data.sync;\n            }\n\n            // did previous processing caused an exception?\n            if (exchange.getException() != null) {\n                Throwable e = exchange.getException();\n                // set the original caused exception\n                exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, e);\n\n                logger.log(\"Failed delivery for exchangeId: \" + exchange.getExchangeId() + \". On delivery attempt: \" + data.redeliveryCounter + \" caught: \" + e, e);\n                data.redeliveryCounter = incrementRedeliveryCounter(exchange, e);\n\n                // find the error handler to use (if any)\n                ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e);\n                if (exceptionPolicy != null) {\n                    data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy);\n                    Processor processor = exceptionPolicy.getErrorHandler();\n                    if (processor != null) {\n                        data.failureProcessor = processor;\n                    }\n                }\n            }\n\n            // should we redeliver or not?\n            if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) {\n                // we did not success with the redelivery so now we let the failure processor handle it\n                setFailureHandled(exchange, true);\n                // must decrement the redelivery counter as we didn't process the redelivery but is\n                // handling by the failure handler. So we must -1 to not let the counter be out-of-sync\n                decrementRedeliveryCounter(exchange);\n\n                AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor);\n                boolean sync = afp.process(exchange, new AsyncCallback() {\n                    public void done(boolean sync) {\n                        restoreExceptionOnExchange(exchange);\n                        callback.done(data.sync);\n                    }\n                });\n\n                restoreExceptionOnExchange(exchange);\n                logger.log(\"Failed delivery for exchangeId: \" + exchange.getExchangeId() + \". Handled by the failure processor: \" + data.failureProcessor);\n                return sync;\n            }\n\n            // should we redeliver\n            if (data.redeliveryCounter > 0) {\n                // okay we will give it another go so clear the exception so we can try again\n                if (exchange.getException() != null) {\n                    exchange.setException(null);\n                }\n\n                // wait until we should redeliver\n                data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay);\n            }\n\n\n            // process the exchange\n            boolean sync = outputAsync.process(exchange, new AsyncCallback() {\n                public void done(boolean sync) {\n                    // Only handle the async case...\n                    if (sync) {\n                        return;\n                    }\n                    data.sync = false;\n                    if (exchange.getException() != null) {\n                        process(exchange, callback, data);\n                    } else {\n                        callback.done(sync);\n                    }\n                }\n            });\n            if (!sync) {\n                // It is going to be processed async..\n                return false;\n            }\n            if (exchange.getException() == null || isFailureHandled(exchange)) {\n                // If everything went well.. then we exit here..\n                callback.done(true);\n                return true;\n            }\n            // error occurred so loop back around.....\n        }\n\n    }","id":34303,"modified_method":"public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) {\n\n        while (true) {\n            // we can't keep retrying if the route is being shutdown.\n            if (!isRunAllowed()) {\n                if (exchange.getException() == null) {\n                    exchange.setException(new RejectedExecutionException());\n                }\n                callback.done(data.sync);\n                return data.sync;\n            }\n\n            // if the exchange is transacted then let the underlying system handle the redelivery etc.\n            // this DeadLetterChannel is only for non transacted exchanges\n            if (exchange.isTransacted() && exchange.getException() != null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"This is a transacted exchange, bypassing this DeadLetterChannel: \" + this + \" for exchange: \" + exchange);\n                }\n                return data.sync;\n            }\n\n            // did previous processing caused an exception?\n            if (exchange.getException() != null) {\n                Throwable e = exchange.getException();\n                // set the original caused exception\n                exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, e);\n\n                logger.log(\"Failed delivery for exchangeId: \" + exchange.getExchangeId() + \". On delivery attempt: \" + data.redeliveryCounter + \" caught: \" + e, e);\n                data.redeliveryCounter = incrementRedeliveryCounter(exchange, e);\n\n                // find the error handler to use (if any)\n                ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e);\n                if (exceptionPolicy != null) {\n                    data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy);\n                    data.handledPredicate = exceptionPolicy.getHandledPolicy();\n                    Processor processor = exceptionPolicy.getErrorHandler();\n                    if (processor != null) {\n                        data.failureProcessor = processor;\n                    }\n                }\n            }\n\n            // should we redeliver or not?\n            if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) {\n                // we did not success with the redelivery so now we let the failure processor handle it\n                setFailureHandled(exchange);\n                // must decrement the redelivery counter as we didn't process the redelivery but is\n                // handling by the failure handler. So we must -1 to not let the counter be out-of-sync\n                decrementRedeliveryCounter(exchange);\n\n                AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor);\n                boolean sync = afp.process(exchange, new AsyncCallback() {\n                    public void done(boolean sync) {\n                        restoreExceptionOnExchange(exchange, data.handledPredicate);\n                        callback.done(data.sync);\n                    }\n                });\n\n                // The line below shouldn't be needed, it is invoked by the AsyncCallback above\n                //restoreExceptionOnExchange(exchange, data.handledPredicate);\n                logger.log(\"Failed delivery for exchangeId: \" + exchange.getExchangeId() + \". Handled by the failure processor: \" + data.failureProcessor);\n                return sync;\n            }\n\n            // should we redeliver\n            if (data.redeliveryCounter > 0) {\n                // okay we will give it another go so clear the exception so we can try again\n                if (exchange.getException() != null) {\n                    exchange.setException(null);\n                }\n\n                // wait until we should redeliver\n                data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay);\n            }\n\n            // process the exchange\n            boolean sync = outputAsync.process(exchange, new AsyncCallback() {\n                public void done(boolean sync) {\n                    // Only handle the async case...\n                    if (sync) {\n                        return;\n                    }\n                    data.sync = false;\n                    if (exchange.getException() != null) {\n                        process(exchange, callback, data);\n                    } else {\n                        callback.done(sync);\n                    }\n                }\n            });\n            if (!sync) {\n                // It is going to be processed async..\n                return false;\n            }\n            if (exchange.getException() == null || isFailureHandled(exchange)) {\n                // If everything went well.. then we exit here..\n                callback.done(true);\n                return true;\n            }\n            // error occurred so loop back around.....\n        }\n\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public static void setFailureHandled(Exchange exchange, boolean isHandled) {\n        if (isHandled) {\n            exchange.setProperty(FAILURE_HANDLED_PROPERTY, exchange.getException());\n            exchange.setException(null);\n        } else {\n            exchange.setException(exchange.getProperty(FAILURE_HANDLED_PROPERTY, Throwable.class));\n            exchange.removeProperty(FAILURE_HANDLED_PROPERTY);\n        }\n\n    }","id":34304,"modified_method":"public static void setFailureHandled(Exchange exchange) {\n        exchange.setProperty(FAILURE_HANDLED_PROPERTY, exchange.getException());\n        exchange.setException(null);\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public void testMyBusinessException() throws Exception {\n        MockEndpoint mock = getMockEndpoint(BUSINESS_ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm my business is not going to well\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello business\");\n            fail(\"Should have thrown a MyBusinessException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof MyBusinessException);\n            // expected\n        }\n\n        mock.assertIsSatisfied();\n    }","id":34305,"modified_method":"public void testMyBusinessException() throws Exception {\n        MockEndpoint result = getMockEndpoint(RESULT_QUEUE);\n        result.expectedMessageCount(0);\n        MockEndpoint mock = getMockEndpoint(BUSINESS_ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm my business is not going to well\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello business\");\n            fail(\"Should have thrown a MyBusinessException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof MyBusinessException);\n            // expected\n        }\n\n        MockEndpoint.assertIsSatisfied(result, mock);\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public void testNPE() throws Exception {\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm a NPE\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello NPE\");\n            fail(\"Should have thrown a NullPointerException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof NullPointerException);\n            // expected\n        }\n\n        mock.assertIsSatisfied();\n    }","id":34306,"modified_method":"public void testNPE() throws Exception {\n        MockEndpoint result = getMockEndpoint(RESULT_QUEUE);\n        result.expectedMessageCount(0);\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm a NPE\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello NPE\");\n            fail(\"Should have thrown a NullPointerException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof NullPointerException);\n            // expected\n        }\n\n        MockEndpoint.assertIsSatisfied(result, mock);\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public void testSecurityConfiguredWithTwoExceptions() throws Exception {\n        // test that we also handles a configuration with 2 or more exceptions\n        MockEndpoint mock = getMockEndpoint(SECURITY_ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm some security error\");\n\n        try {\n            template.sendBody(\"direct:a\", \"I am not allowed to do this\");\n            fail(\"Should have thrown a GeneralSecurityException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof GeneralSecurityException);\n            // expected\n        }\n\n        mock.assertIsSatisfied();\n    }","id":34307,"modified_method":"public void testSecurityConfiguredWithTwoExceptions() throws Exception {\n        // test that we also handles a configuration with 2 or more exceptions\n        MockEndpoint result = getMockEndpoint(RESULT_QUEUE);\n        result.expectedMessageCount(0);\n        MockEndpoint mock = getMockEndpoint(SECURITY_ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm some security error\");\n\n        try {\n            template.sendBody(\"direct:a\", \"I am not allowed to do this\");\n            fail(\"Should have thrown a GeneralSecurityException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof GeneralSecurityException);\n            // expected\n        }\n\n        MockEndpoint.assertIsSatisfied(result, mock);\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public void testIOException() throws Exception {\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm somekind of IO exception\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello IO\");\n            fail(\"Should have thrown a IOException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof IOException);\n            // expected\n        }\n\n        mock.assertIsSatisfied();\n    }","id":34308,"modified_method":"public void testIOException() throws Exception {\n        MockEndpoint result = getMockEndpoint(RESULT_QUEUE);\n        result.expectedMessageCount(0);\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm somekind of IO exception\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello IO\");\n            fail(\"Should have thrown a IOException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof IOException);\n            // expected\n        }\n\n        MockEndpoint.assertIsSatisfied(result, mock);\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public void testSecurityConfiguredWithExceptionList() throws Exception {\n        // test that we also handles a configuration with a list of exceptions\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm some access error\");\n\n        try {\n            template.sendBody(\"direct:a\", \"I am not allowed to access this\");\n            fail(\"Should have thrown a GeneralSecurityException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof IllegalAccessException);\n            // expected\n        }\n\n        mock.assertIsSatisfied();\n    }","id":34309,"modified_method":"public void testSecurityConfiguredWithExceptionList() throws Exception {\n        // test that we also handles a configuration with a list of exceptions\n        MockEndpoint result = getMockEndpoint(RESULT_QUEUE);\n        result.expectedMessageCount(0);\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm some access error\");\n\n        try {\n            template.sendBody(\"direct:a\", \"I am not allowed to access this\");\n            fail(\"Should have thrown a GeneralSecurityException\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof IllegalAccessException);\n            // expected\n        }\n\n        MockEndpoint.assertIsSatisfied(result, mock);\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public void testException() throws Exception {\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm just exception\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello Exception\");\n            fail(\"Should have thrown a Exception\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof Exception);\n            // expected\n        }\n\n        mock.assertIsSatisfied();\n    }","id":34310,"modified_method":"public void testException() throws Exception {\n        MockEndpoint result = getMockEndpoint(RESULT_QUEUE);\n        result.expectedMessageCount(0);\n        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);\n        mock.expectedMessageCount(1);\n        mock.expectedHeaderReceived(MESSAGE_INFO, \"Damm just exception\");\n\n        try {\n            template.sendBody(\"direct:a\", \"Hello Exception\");\n            fail(\"Should have thrown a Exception\");\n        } catch (RuntimeCamelException e) {\n            assertTrue(e.getCause() instanceof Exception);\n            // expected\n        }\n\n        MockEndpoint.assertIsSatisfied(result, mock);\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"public boolean process(Exchange original, AsyncCallback callback) {\n        Iterator<Processor> processors = getProcessors().iterator();\n        Exchange nextExchange = original;\n        boolean first = true;\n        while (true) {\n            if (nextExchange.isFailed()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Message exchange has failed so breaking out of pipeline: \" + nextExchange\n                              + \" exception: \" + nextExchange.getException() + \" fault: \"\n                              + nextExchange.getFault(false));\n                }\n                break;\n            }\n            if (!processors.hasNext()) {\n                break;\n            }\n\n            AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());\n\n            if (first) {\n                first = false;\n            } else {\n                nextExchange = createNextExchange(processor, nextExchange);\n            }\n\n            boolean sync = process(original, nextExchange, callback, processors, processor);\n            // Continue processing the pipeline synchronously ...\n            if (!sync) {\n                // The pipeline will be completed async...\n                return false;\n            }\n        }\n\n        // If we get here then the pipeline was processed entirely\n        // synchronously.\n        ExchangeHelper.copyResults(original, nextExchange);\n        callback.done(true);\n        return true;\n    }","id":34311,"modified_method":"public boolean process(Exchange original, AsyncCallback callback) {\n        Iterator<Processor> processors = getProcessors().iterator();\n        Exchange nextExchange = original;\n        boolean first = true;\n        while (true) {\n            boolean handledException = Boolean.TRUE.equals(\n                    nextExchange.getProperty(Exchange.EXCEPTION_HANDLED_PROPERTY));\n            if (nextExchange.isFailed() || handledException) {\n                // The Exchange.EXCEPTION_HANDLED_PROPERTY property is only set if satisfactory handling was done \n                //  by the error handler.  It's still an exception, the exchange still failed.\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Message exchange has failed so breaking out of pipeline: \" + nextExchange\n                              + \" exception: \" + nextExchange.getException() + \" fault: \"\n                              + nextExchange.getFault(false)\n                              + (handledException ? \" handled by the error handler\" : \"\"));\n                }\n                break;\n            }\n            if (!processors.hasNext()) {\n                break;\n            }\n\n            AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());\n\n            if (first) {\n                first = false;\n            } else {\n                nextExchange = createNextExchange(processor, nextExchange);\n            }\n\n            boolean sync = process(original, nextExchange, callback, processors, processor);\n            // Continue processing the pipeline synchronously ...\n            if (!sync) {\n                // The pipeline will be completed async...\n                return false;\n            }\n        }\n\n        // If we get here then the pipeline was processed entirely\n        // synchronously.\n        ExchangeHelper.copyResults(original, nextExchange);\n        callback.done(true);\n        return true;\n    }","commit_id":"d8a5034741ca1e996c35d0ed4575ed685b787a26","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testGetWrongCustomer() throws Exception {\n        URL url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/456\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/256\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n    }","id":34312,"modified_method":"@Test\n    public void testGetWrongCustomer() throws Exception {\n        URL url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/456\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/234\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (FileNotFoundException exception) {\n            // do nothing here\n        }\n        \n        url = new URL(\"http://localhost:\" + CXT + \"/rest/customerservice/customers/256\");\n        try {\n            url.openStream();\n            fail(\"Expect to get exception here\");\n        } catch (IOException exception) {\n            // expect the Internal error exception\n        }\n        \n    }","commit_id":"0ccf7689046ab3f5e335582d7756f728e7bdf7d2","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                errorHandler(new NoErrorHandlerBuilder());\n                from(CXF_RS_ENDPOINT_URI).process(new Processor() {\n\n                    public void process(Exchange exchange) throws Exception {\n                        Message inMessage = exchange.getIn();                        \n                        // Get the operation name from in message\n                        String operationName = inMessage.getHeader(CxfConstants.OPERATION_NAME, String.class);\n                        if (\"getCustomer\".equals(operationName)) {\n                            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n                            assertEquals(\"Get a wrong http method\", \"GET\", httpMethod);\n                            String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n                            // The parameter of the invocation is stored in the body of in message\n                            String id = inMessage.getBody(String.class);\n                            if (\"/customerservice/customers/126\".equals(path)) {                            \n                                Customer customer = new Customer();\n                                customer.setId(Long.parseLong(id));\n                                customer.setName(\"Willem\");\n                                // We just put the response Object into the out message body\n                                exchange.getOut().setBody(customer);\n                            } else {\n                                if (\"/customerservice/customers/400\".equals(path)) {\n                                    // We return the remote client IP address this time\n                                    org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);\n                                    ServletRequest request = (ServletRequest) cxfMessage.get(\"HTTP.REQUEST\");\n                                    String remoteAddress = request.getRemoteAddr();\n                                    Response r = Response.status(200).entity(\"The remoteAddress is \" + remoteAddress).build();\n                                    exchange.getOut().setBody(r);\n                                    return;\n                                }\n                                if (\"/customerservice/customers/123\".equals(path)) {\n                                    // send a customer response back\n                                    Response r = Response.status(200).entity(\"customer response back!\").build();\n                                    exchange.getOut().setBody(r);\n                                    return;\n                                }\n                                if (\"/customerservice/customers/456\".equals(path)) {\n                                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path).build();\n                                    throw new WebApplicationException(r);\n                                } else {\n                                    throw new RuntimeCamelException(\"Can't found the customer with uri \" + path);\n                                }\n                            }\n                        }\n                        if (\"updateCustomer\".equals(operationName)) {\n                            assertEquals(\"Get a wrong customer message header\", \"header1;header2\", inMessage.getHeader(\"test\"));\n                            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n                            assertEquals(\"Get a wrong http method\", \"PUT\", httpMethod);\n                            Customer customer = inMessage.getBody(Customer.class);\n                            assertNotNull(\"The customer should not be null.\", customer);\n                            // Now you can do what you want on the customer object\n                            assertEquals(\"Get a wrong customer name.\", \"Mary\", customer.getName());\n                            // set the response back\n                            exchange.getOut().setBody(Response.ok().build());\n                        }\n                        \n                    }\n                    \n                });\n            }\n        };\n    }","id":34313,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                errorHandler(new NoErrorHandlerBuilder());\n                from(CXF_RS_ENDPOINT_URI).process(new Processor() {\n\n                    public void process(Exchange exchange) throws Exception {\n                        Message inMessage = exchange.getIn();                        \n                        // Get the operation name from in message\n                        String operationName = inMessage.getHeader(CxfConstants.OPERATION_NAME, String.class);\n                        if (\"getCustomer\".equals(operationName)) {\n                            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n                            assertEquals(\"Get a wrong http method\", \"GET\", httpMethod);\n                            String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n                            // The parameter of the invocation is stored in the body of in message\n                            String id = inMessage.getBody(String.class);\n                            if (\"/customerservice/customers/126\".equals(path)) {                            \n                                Customer customer = new Customer();\n                                customer.setId(Long.parseLong(id));\n                                customer.setName(\"Willem\");\n                                // We just put the response Object into the out message body\n                                exchange.getOut().setBody(customer);\n                            } else {\n                                if (\"/customerservice/customers/400\".equals(path)) {\n                                    // We return the remote client IP address this time\n                                    org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);\n                                    ServletRequest request = (ServletRequest) cxfMessage.get(\"HTTP.REQUEST\");\n                                    String remoteAddress = request.getRemoteAddr();\n                                    Response r = Response.status(200).entity(\"The remoteAddress is \" + remoteAddress).build();\n                                    exchange.getOut().setBody(r);\n                                    return;\n                                }\n                                if (\"/customerservice/customers/123\".equals(path)) {\n                                    // send a customer response back\n                                    Response r = Response.status(200).entity(\"customer response back!\").build();\n                                    exchange.getOut().setBody(r);\n                                    return;\n                                }\n                                if (\"/customerservice/customers/456\".equals(path)) {\n                                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path).build();\n                                    throw new WebApplicationException(r);\n                                } else if (\"/customerservice/customers/234\".equals(path)) {\n                                    Response r = Response.status(404).entity(\"Can't found the customer with uri \" + path).build();\n                                    exchange.getOut().setBody(r);\n                                    exchange.getOut().setFault(true);\n                                } else {\n                                    throw new RuntimeCamelException(\"Can't found the customer with uri \" + path);\n                                }\n                            }\n                        }\n                        if (\"updateCustomer\".equals(operationName)) {\n                            assertEquals(\"Get a wrong customer message header\", \"header1;header2\", inMessage.getHeader(\"test\"));\n                            String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n                            assertEquals(\"Get a wrong http method\", \"PUT\", httpMethod);\n                            Customer customer = inMessage.getBody(Customer.class);\n                            assertNotNull(\"The customer should not be null.\", customer);\n                            // Now you can do what you want on the customer object\n                            assertEquals(\"Get a wrong customer name.\", \"Mary\", customer.getName());\n                            // set the response back\n                            exchange.getOut().setBody(Response.ok().build());\n                        }\n                        \n                    }\n                    \n                });\n            }\n        };\n    }","commit_id":"0ccf7689046ab3f5e335582d7756f728e7bdf7d2","url":"https://github.com/apache/camel"},{"original_method":"public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        if (camelExchange.isFailed()) {\n            throw camelExchange.getException();\n        }\n\n        org.apache.camel.Message response;\n        if (camelExchange.getPattern().isOutCapable()) {\n            if (camelExchange.hasOut()) {\n                response = camelExchange.getOut();\n                LOG.trace(\"Get the response from the out message\");\n            } else {\n                response = camelExchange.getIn();\n                LOG.trace(\"Get the response from the in message as a fallback\");\n            }\n        } else {\n            response = camelExchange.getIn();\n            LOG.trace(\"Get the response from the in message\");\n        }\n\n        return response.getBody();\n    }","id":34314,"modified_method":"public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        // Need to check if the exchange has the exception\n        if (camelExchange.isFailed() && camelExchange.getException() != null) {\n            throw camelExchange.getException();\n        }\n\n        org.apache.camel.Message response;\n        if (camelExchange.getPattern().isOutCapable()) {\n            if (camelExchange.hasOut()) {\n                response = camelExchange.getOut();\n                LOG.trace(\"Get the response from the out message\");\n            } else {\n                response = camelExchange.getIn();\n                LOG.trace(\"Get the response from the in message as a fallback\");\n            }\n        } else {\n            response = camelExchange.getIn();\n            LOG.trace(\"Get the response from the in message\");\n        }\n\n        return response.getBody();\n    }","commit_id":"0ccf7689046ab3f5e335582d7756f728e7bdf7d2","url":"https://github.com/apache/camel"},{"original_method":"public void onMessage(final Message message) {\n        LOG.trace(\"onMessage START\");\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(endpoint + \" consumer receiving JMS message: \" + message);\n        }\n\n        RuntimeCamelException rce = null;\n        try {\n            Object replyDestination = getReplyToDestination(message);\n            final Exchange exchange = createExchange(message, replyDestination);\n            if (eagerLoadingOfProperties) {\n                exchange.getIn().getHeaders();\n            }\n\n            // process the exchange\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"onMessage.process START\");\n            }\n            processor.process(exchange);\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"onMessage.process END\");\n            }\n\n            // get the correct jms message to send as reply\n            JmsMessage body = null;\n            Exception cause = null;\n            boolean sendReply = false;\n            if (exchange.isFailed()) {\n                if (exchange.getException() != null) {\n                    // an exception occurred while processing\n                    if (endpoint.isTransferException()) {\n                        // send the exception as reply\n                        body = null;\n                        cause = exchange.getException();\n                        sendReply = true;\n                    } else {\n                        // only throw exception if endpoint is not configured to transfer exceptions back to caller\n                        // do not send a reply but wrap and rethrow the exception\n                        rce = wrapRuntimeCamelException(exchange.getException());\n                    }\n                } else if (exchange.getOut().getBody() != null) {\n                    // a fault occurred while processing\n                    body = (JmsMessage) exchange.getOut();\n                    sendReply = true;\n                }\n            } else if (exchange.hasOut()) {\n                // process OK so get the reply\n                body = (JmsMessage) exchange.getOut();\n                sendReply = true;\n            }\n\n            // send the reply if we got a response and the exchange is out capable\n            if (rce == null && sendReply && !disableReplyTo && exchange.getPattern().isOutCapable()) {\n                LOG.trace(\"onMessage.sendReply START\");\n                if (replyDestination instanceof Destination) {\n                    sendReply((Destination)replyDestination, message, exchange, body, cause);\n                } else {\n                    sendReply((String)replyDestination, message, exchange, body, cause);\n                }\n                LOG.trace(\"onMessage.sendReply END\");\n            }\n\n        } catch (Exception e) {\n            rce = wrapRuntimeCamelException(e);\n        }\n\n        if (rce != null) {\n            handleException(rce);\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"onMessage END throwing exception: \" + rce.getMessage());\n            }\n            throw rce;\n        }\n\n        LOG.trace(\"onMessage END\");\n    }","id":34315,"modified_method":"public void onMessage(final Message message) {\n        LOG.trace(\"onMessage START\");\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(endpoint + \" consumer receiving JMS message: \" + message);\n        }\n\n        RuntimeCamelException rce = null;\n        try {\n            Object replyDestination = getReplyToDestination(message);\n            final Exchange exchange = createExchange(message, replyDestination);\n            if (eagerLoadingOfProperties) {\n                exchange.getIn().getHeaders();\n            }\n\n            // process the exchange\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"onMessage.process START\");\n            }\n            processor.process(exchange);\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"onMessage.process END\");\n            }\n\n            // get the correct jms message to send as reply\n            JmsMessage body = null;\n            Exception cause = null;\n            boolean sendReply = false;\n            if (exchange.isFailed() || exchange.isRollbackOnly()) {\n                if (exchange.getException() != null) {\n                    // an exception occurred while processing\n                    if (endpoint.isTransferException()) {\n                        // send the exception as reply\n                        body = null;\n                        cause = exchange.getException();\n                        sendReply = true;\n                    } else {\n                        // only throw exception if endpoint is not configured to transfer exceptions back to caller\n                        // do not send a reply but wrap and rethrow the exception\n                        rce = wrapRuntimeCamelException(exchange.getException());\n                    }\n                } else if (exchange.isRollbackOnly()) {\n                    // rollback only so wrap an exception so we can rethrow the exception to cause rollback\n                    rce = wrapRuntimeCamelException(new RollbackExchangeException(exchange));\n                } else if (exchange.getOut().getBody() != null) {\n                    // a fault occurred while processing\n                    body = (JmsMessage) exchange.getOut();\n                    sendReply = true;\n                }\n            } else if (exchange.hasOut()) {\n                // process OK so get the reply\n                body = (JmsMessage) exchange.getOut();\n                sendReply = true;\n            }\n\n            // send the reply if we got a response and the exchange is out capable\n            if (rce == null && sendReply && !disableReplyTo && exchange.getPattern().isOutCapable()) {\n                LOG.trace(\"onMessage.sendReply START\");\n                if (replyDestination instanceof Destination) {\n                    sendReply((Destination)replyDestination, message, exchange, body, cause);\n                } else {\n                    sendReply((String)replyDestination, message, exchange, body, cause);\n                }\n                LOG.trace(\"onMessage.sendReply END\");\n            }\n\n        } catch (Exception e) {\n            rce = wrapRuntimeCamelException(e);\n        }\n\n        if (rce != null) {\n            handleException(rce);\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"onMessage END throwing exception: \" + rce.getMessage());\n            }\n            throw rce;\n        }\n\n        LOG.trace(\"onMessage END\");\n    }","commit_id":"6f95bc93bf8c7f8f2934e809c5f1aafea34c76ad","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    @Ignore(\"markRollbackOnly causes Spring TX to not let JMS redeliver!\")\n    public void testJmsToJmsTestRollbackDueToMarkRollbackOnly() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"activemq:queue:foo\")\n                        .transacted()\n                        .to(\"mock:start\")\n                        .to(\"activemq:queue:bar\")\n                        .markRollbackOnly();\n\n                from(\"activemq:queue:bar\").to(\"log:bar\").to(\"mock:bar\");\n            }\n        });\n        context.start();\n\n        MockEndpoint bar = getMockEndpoint(\"mock:bar\");\n        bar.expectedMessageCount(0);\n\n        // TODO: mark rollback only causes Spring TX to not rollback on JMS queue\n        MockEndpoint start = getMockEndpoint(\"mock:start\");\n        start.expectedMessageCount(6);\n\n        template.sendBody(\"activemq:queue:foo\", \"Hello World\");\n\n        assertMockEndpointsSatisfied();\n    }","id":34316,"modified_method":"@Test\n    public void testJmsToJmsTestRollbackDueToMarkRollbackOnly() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"activemq:queue:foo\")\n                        .transacted()\n                        .to(\"mock:start\")\n                        .to(\"activemq:queue:bar\")\n                        .markRollbackOnly();\n\n                from(\"activemq:queue:bar\").to(\"log:bar\").to(\"mock:bar\");\n            }\n        });\n        context.start();\n\n        MockEndpoint bar = getMockEndpoint(\"mock:bar\");\n        bar.expectedMessageCount(0);\n\n        MockEndpoint start = getMockEndpoint(\"mock:start\");\n        start.expectedMessageCount(6);\n\n        template.sendBody(\"activemq:queue:foo\", \"Hello World\");\n\n        assertMockEndpointsSatisfied();\n    }","commit_id":"6f95bc93bf8c7f8f2934e809c5f1aafea34c76ad","url":"https://github.com/apache/camel"},{"original_method":"protected void doInTransactionTemplate(final Exchange exchange) {\n\n        // spring transaction template is working best with rollback if you throw it a runtime exception\n        // otherwise it may not rollback messages send to JMS queues etc.\n\n        transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n            protected void doInTransactionWithoutResult(TransactionStatus status) {\n                // wrapper exception to throw if the exchange failed\n                // IMPORTANT: Must be a runtime exception to let Spring regard it as to do \"rollback\"\n                RuntimeCamelException rce = null;\n\n                exchange.setProperty(Exchange.TRANSACTED, Boolean.TRUE);\n\n                // and now let process the exchange\n                // we have to wait if the async routing engine took over, because transactions have to be done in\n                // the same thread (Spring TransactionManager) so by waiting until the async routing is done\n                // will let us be able to continue routing thereafter in the same thread context\n                final CountDownLatch latch = new CountDownLatch(1);\n                boolean sync = TransactionErrorHandler.super.process(exchange, new AsyncCallback() {\n                    public void done(boolean doneSync) {\n                        if (!doneSync) {\n                            if (log.isTraceEnabled()) {\n                                log.trace(\"Asynchronous callback received for exchangeId: \" + exchange.getExchangeId());\n                            }\n                            latch.countDown();\n                        }\n                    }\n\n                    @Override\n                    public String toString() {\n                        return \"Done TransactionErrorHandler\";\n                    }\n                });\n                if (!sync) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Waiting for asynchronous callback before continuing for exchangeId: \" + exchange.getExchangeId() + \" -> \" + exchange);\n                    }\n                    try {\n                        latch.await();\n                    } catch (InterruptedException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Interrupted while waiting for asynchronous callback for exchangeId: \" + exchange.getExchangeId(), e);\n                        }\n                        // we may be shutting down etc., so set exception\n                        if (exchange.getException() == null) {\n                            exchange.setException(e);\n                        }\n                    }\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Asynchronous callback received, will continue routing exchangeId: \" + exchange.getExchangeId() + \" -> \" + exchange);\n                    }\n                }\n\n                // after handling and still an exception or marked as rollback only then rollback\n                if (exchange.getException() != null || exchange.isRollbackOnly()) {\n\n                    // if it was a local rollback only then remove its marker so outer transaction\n                    // wont rollback as well (Note: isRollbackOnly() also returns true for ROLLBACK_ONLY_LAST)\n                    exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);\n\n                    // wrap exception in transacted exception\n                    if (exchange.getException() != null) {\n                        rce = ObjectHelper.wrapRuntimeCamelException(exchange.getException());\n                    }\n\n                    if (!status.isRollbackOnly()) {\n                        status.setRollbackOnly();\n                    }\n\n                    // rethrow if an exception occurred\n                    if (rce != null) {\n                        throw rce;\n                    } else {\n                        // create dummy exception to force spring transaction manager to rollback\n                        throw new TransactionRollbackException();\n                    }\n                }\n            }\n        });\n    }","id":34317,"modified_method":"protected void doInTransactionTemplate(final Exchange exchange) {\n\n        // spring transaction template is working best with rollback if you throw it a runtime exception\n        // otherwise it may not rollback messages send to JMS queues etc.\n\n        transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n            protected void doInTransactionWithoutResult(TransactionStatus status) {\n                // wrapper exception to throw if the exchange failed\n                // IMPORTANT: Must be a runtime exception to let Spring regard it as to do \"rollback\"\n                RuntimeException rce = null;\n\n                exchange.setProperty(Exchange.TRANSACTED, Boolean.TRUE);\n\n                // and now let process the exchange\n                // we have to wait if the async routing engine took over, because transactions have to be done in\n                // the same thread (Spring TransactionManager) so by waiting until the async routing is done\n                // will let us be able to continue routing thereafter in the same thread context\n                final CountDownLatch latch = new CountDownLatch(1);\n                boolean sync = TransactionErrorHandler.super.process(exchange, new AsyncCallback() {\n                    public void done(boolean doneSync) {\n                        if (!doneSync) {\n                            if (log.isTraceEnabled()) {\n                                log.trace(\"Asynchronous callback received for exchangeId: \" + exchange.getExchangeId());\n                            }\n                            latch.countDown();\n                        }\n                    }\n\n                    @Override\n                    public String toString() {\n                        return \"Done TransactionErrorHandler\";\n                    }\n                });\n                if (!sync) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Waiting for asynchronous callback before continuing for exchangeId: \" + exchange.getExchangeId() + \" -> \" + exchange);\n                    }\n                    try {\n                        latch.await();\n                    } catch (InterruptedException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Interrupted while waiting for asynchronous callback for exchangeId: \" + exchange.getExchangeId(), e);\n                        }\n                        // we may be shutting down etc., so set exception\n                        if (exchange.getException() == null) {\n                            exchange.setException(e);\n                        }\n                    }\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Asynchronous callback received, will continue routing exchangeId: \" + exchange.getExchangeId() + \" -> \" + exchange);\n                    }\n                }\n\n                // after handling and still an exception or marked as rollback only then rollback\n                if (exchange.getException() != null || exchange.isRollbackOnly()) {\n\n                    // if it was a local rollback only then remove its marker so outer transaction\n                    // wont rollback as well (Note: isRollbackOnly() also returns true for ROLLBACK_ONLY_LAST)\n                    exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);\n\n                    // wrap exception in transacted exception\n                    if (exchange.getException() != null) {\n                        rce = ObjectHelper.wrapRuntimeCamelException(exchange.getException());\n                    } else if (exchange.isRollbackOnly()) {\n                        // create dummy exception to force spring transaction manager to rollback\n                        rce = new TransactionRollbackException();\n                    }\n\n                    if (!status.isRollbackOnly()) {\n                        status.setRollbackOnly();\n                    }\n\n                    // rethrow if an exception occurred\n                    if (rce != null) {\n                        throw rce;\n                    }\n                }\n            }\n        });\n    }","commit_id":"6f95bc93bf8c7f8f2934e809c5f1aafea34c76ad","url":"https://github.com/apache/camel"},{"original_method":"@Feature(summary = \"The maintainer can override the available languages \" +\n            \"for a project version\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void changeVersionLanguages() throws Exception {\n        assertThat(new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .loggedInAs())\n                .isEqualTo(\"admin\")\n                .as(\"Admin user has logged in\");\n\n        VersionLanguagesTab versionLanguagesTab = new ProjectWorkFlow()\n                .createNewSimpleProject(\"langoverride\", \"langoverride\")\n                .clickCreateVersionLink()\n                .inputVersionId(\"overridelangtest\")\n                .saveVersion()\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .clickInheritCheckbox()\n                .waitForLocaleListVisible();\n\n        List<String> enabledLocaleList = versionLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"French[fr]\", \"Hindi[hi]\", \"Polish[pl]\")\n                .as(\"The enabled list contains three languages\");\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"English (United States)[en-US]\")\n                .as(\"The enabled list does not contain \" +\n                        \"'English (United States)[en-US]'\");\n\n        versionLanguagesTab = versionLanguagesTab.removeLocale(\"pl\");\n        versionLanguagesTab.waitForLanguagesNotContains(\n                \"English (United States)[en-US]\");\n        versionLanguagesTab.waitForLanguagesNotContains(\"Polish[pl]\");\n        enabledLocaleList = versionLanguagesTab.getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"English (United States)[en-US]\")\n                .doesNotContain(\"Polish[pl]\")\n                .as(\"The enabled list does not contain 'US English' or Polish\");\n\n        versionLanguagesTab = versionLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .enterSearchLanguage(\"en-US\")\n                .addLocale(\"English (United States)[en-US]\");\n\n        versionLanguagesTab.waitForLanguagesContains(\n                \"English (United States)[en-US]\");\n        enabledLocaleList = versionLanguagesTab.getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"English (United States)[en-US]\",\n                        \"French[fr]\",\n                        \"Hindi[hi]\")\n                .as(\"Three languages are available to translate\");\n    }","id":34318,"modified_method":"@Feature(summary = \"The maintainer can override the available languages \" +\n            \"for a project version\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Ignore(\"Behaviour changed - needs review\")\n    public void changeVersionLanguages() throws Exception {\n        assertThat(new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .loggedInAs())\n                .isEqualTo(\"admin\")\n                .as(\"Admin user has logged in\");\n\n        VersionLanguagesTab versionLanguagesTab = new ProjectWorkFlow()\n                .goToProjectByName(\"langoverride\")\n                .gotoVersion(\"overridelangtest\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .clickInheritCheckbox()\n                .waitForLocaleListVisible();\n\n        List<String> enabledLocaleList = versionLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"French[fr]\", \"Hindi[hi]\", \"Polish[pl]\")\n                .as(\"The enabled list contains three languages\");\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"English (United States)[en-US]\")\n                .as(\"The enabled list does not contain \" +\n                        \"'English (United States)[en-US]'\");\n\n        versionLanguagesTab = versionLanguagesTab.removeLocale(\"pl\");\n        versionLanguagesTab.waitForLanguagesNotContains(\n                \"English (United States)[en-US]\");\n        versionLanguagesTab.waitForLanguagesNotContains(\"Polish[pl]\");\n        enabledLocaleList = versionLanguagesTab.getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(\"English (United States)[en-US]\")\n                .doesNotContain(\"Polish[pl]\")\n                .as(\"The enabled list does not contain 'US English' or Polish\");\n\n        versionLanguagesTab = versionLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .enterSearchLanguage(\"en-US\")\n                .addLocale(\"English (United States)[en-US]\");\n\n        versionLanguagesTab.waitForLanguagesContains(\n                \"English (United States)[en-US]\");\n        enabledLocaleList = versionLanguagesTab.getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(\"English (United States)[en-US]\",\n                        \"French[fr]\",\n                        \"Hindi[hi]\")\n                .as(\"Three languages are available to translate\");\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"private Boolean openConfigurationPanel() {\n        waitForTenSec().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getDriver()\n                        .findElement(By.className(\"icon-cog\"))\n                        .isEnabled();\n            }\n        });\n        new Actions(getDriver()).click(\n                getDriver().findElement(By.className(\"icon-cog\"))).perform();\n        return waitForTenSec().until(new Function<WebDriver, Boolean>() {\n            @Override\n            public Boolean apply(WebDriver input) {\n                return input.findElement(\n                        By.className(\"gwt-TabLayoutPanelContentContainer\"))\n                        .isDisplayed();\n            }\n        });\n\n    }","id":34319,"modified_method":"private Boolean openConfigurationPanel() {\n        waitForTenSec().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getDriver()\n                        .findElement(By.className(\"i--settings\"))\n                        .isEnabled();\n            }\n        });\n        new Actions(getDriver()).click(\n                getDriver().findElement(By.className(\"i--settings\"))).perform();\n        return waitForTenSec().until(new Function<WebDriver, Boolean>() {\n            @Override\n            public Boolean apply(WebDriver input) {\n                return input.findElement(\n                        By.className(\"gwt-TabLayoutPanelContentContainer\"))\n                        .isDisplayed();\n            }\n        });\n\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Opens the validation options sidebar\n     *\n     * @return new EditorPage\n     */\n    public EditorPage openValidationOptions() {\n        getDriver().findElement(By.className(\"icon-check\")).click();\n        waitForTenSec().until(new Function<WebDriver, Boolean>() {\n            @Override\n            public Boolean apply(WebDriver driver) {\n                return getDriver().findElement(By.id(\"validationOptionsView\"))\n                        .isDisplayed();\n            }\n        });\n        return new EditorPage(getDriver());\n    }","id":34320,"modified_method":"/**\n     * Opens the validation options sidebar\n     *\n     * @return new EditorPage\n     */\n    public EditorPage openValidationOptions() {\n        getDriver().findElement(By.className(\"i--checkmark\")).click();\n        waitForTenSec().until(new Function<WebDriver, Boolean>() {\n            @Override\n            public Boolean apply(WebDriver driver) {\n                return getDriver().findElement(By.id(\"validationOptionsView\"))\n                        .isDisplayed();\n            }\n        });\n        return new EditorPage(getDriver());\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Create a new project version.\n     *\n     * @param projectName name of the project\n     * @param versionID ID of the version\n     * @param versionType type of the version\n     * @return new Version page, on the default Languages tab\n     */\n    public VersionLanguagesPage createNewProjectVersion(String projectName,\n            String versionID, String versionType) {\n        ProjectVersionsPage projectVersionsPage = goToProjectByName(projectName);\n        if (projectVersionsPage.getVersions().contains(versionID)) {\n            log.warn(\"{} has already been created. \" +\n                    \"Presumably you are running this test manually and more\" +\n                    \" than once.\", versionID);\n            return projectVersionsPage.gotoVersion(versionID);\n        }\n        return projectVersionsPage\n                .clickCreateVersionLink()\n                .clickCopyFromVersion()\n                .inputVersionId(versionID)\n                .selectProjectType(versionType)\n                .saveVersion();\n    }","id":34321,"modified_method":"/**\n     * Create a new project version.\n     *\n     * @param projectName name of the project\n     * @param versionID ID of the version\n     * @param versionType type of the version\n     * @return new Version page, on the default Languages tab\n     */\n    public VersionLanguagesPage createNewProjectVersion(String projectName,\n            String versionID, String versionType) {\n        ProjectVersionsPage projectVersionsPage =\n                goToProjectByName(projectName);\n        if (projectVersionsPage.getVersions().contains(versionID)) {\n            log.warn(\"{} has already been created. \" +\n                    \"Presumably you are running this test manually and more\" +\n                    \" than once.\", versionID);\n            return projectVersionsPage.gotoVersion(versionID);\n        }\n        CreateVersionPage createVersionPage = projectVersionsPage\n                .clickCreateVersionLink();\n        // First version has no copy options\n        if (driver.findElements(By.id(\"create-version-form:copy-from-version\"))\n                .size() > 0) {\n            createVersionPage = createVersionPage\n                    .clickCopyFromVersion()\n                    .selectProjectType(versionType);\n        }\n        return createVersionPage.inputVersionId(versionID).saveVersion();\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n    public void before() {\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","id":34322,"modified_method":"@Before\n    public void before() {\n        zanataRestCaller = new ZanataRestCaller();\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The user can translate HyperText Markup Language files\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Theory\n    public void translateBasicHTMLFile(String extension) {\n        File testfile = testFileGenerator.generateTestFileWithContent(\n                \"basichtml\", \".\" + extension,\n                \"<html><body>Line One<p>Line Two<p>Line Three<\/body><\/html>\");\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoVersion(\"master\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage\n                .translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n\n    }","id":34323,"modified_method":"@Feature(summary = \"The user can translate HyperText Markup Language files\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Theory\n    public void translateBasicHTMLFile(String extension) {\n        File testfile = testFileGenerator.generateTestFileWithContent(\n                \"basichtml\", \".\" + extension,\n                \"<html><body>Line One<p>Line Two<p>Line Three<\/body><\/html>\");\n        zanataRestCaller.createProjectAndVersion(extension+\"-translate\",\n                extension, \"file\");\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(extension+\"-translate\")\n                .gotoVersion(extension)\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage\n                .translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The user can translate an InDesign file\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void translateBasicIdmlFile() {\n        File testfile = testFileGenerator.openTestFile(\"test-idml.idml\");\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoVersion(\"master\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage.translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","id":34324,"modified_method":"@Feature(summary = \"The user can translate an InDesign file\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void translateBasicIdmlFile() {\n        zanataRestCaller.createProjectAndVersion(\"idml-translate\", \"idml\", \"file\");\n        File testfile = testFileGenerator.openTestFile(\"test-idml.idml\");\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"idml-translate\")\n                .gotoVersion(\"idml\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage.translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n    public void before() {\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","id":34325,"modified_method":"@Before\n    public void before() {\n        zanataRestCaller = new ZanataRestCaller();\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n    public void before() {\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","id":34326,"modified_method":"@Before\n    public void before() {\n        zanataRestCaller = new ZanataRestCaller();\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The user can translate an OpenOffice spreadsheet file\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void translateBasicOdsFile() {\n        File testfile = testFileGenerator.openTestFile(\"test-ods.ods\");\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoVersion(\"master\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"TestODS\")\n                .as(\"Item 1 shows TestODS (the sheet name)\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"First\")\n                .as(\"Item 2 shows First (the page name)\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 3 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(3))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 4 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(4))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 5 shows Line Three\");\n\n        editorPage = editorPage\n                .translateTargetAtRowIndex(0, \"TestODS\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Début\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Une Ligne\")\n                .approveTranslationAtRow(2)\n                .translateTargetAtRowIndex(3, \"Deux Ligne\")\n                .approveTranslationAtRow(3)\n                .translateTargetAtRowIndex(4, \"Ligne Trois\")\n                .approveTranslationAtRow(4);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save, switches to CodeMirror\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","id":34327,"modified_method":"@Feature(summary = \"The user can translate an OpenOffice spreadsheet file\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void translateBasicOdsFile() {\n        File testfile = testFileGenerator.openTestFile(\"test-ods.ods\");\n        zanataRestCaller.createProjectAndVersion(\"ods-translate\", \"ods\", \"file\");\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"ods-translate\")\n                .gotoVersion(\"ods\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"TestODS\")\n                .as(\"Item 1 shows TestODS (the sheet name)\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"First\")\n                .as(\"Item 2 shows First (the page name)\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 3 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(3))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 4 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(4))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 5 shows Line Three\");\n\n        editorPage = editorPage\n                .translateTargetAtRowIndex(0, \"TestODS\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Début\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Une Ligne\")\n                .approveTranslationAtRow(2)\n                .translateTargetAtRowIndex(3, \"Deux Ligne\")\n                .approveTranslationAtRow(3)\n                .translateTargetAtRowIndex(4, \"Ligne Trois\")\n                .approveTranslationAtRow(4);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save, switches to CodeMirror\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n    public void before() {\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","id":34328,"modified_method":"@Before\n    public void before() {\n        zanataRestCaller = new ZanataRestCaller();\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The user can translate OpenOffice files\",\n        tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Theory\n    public void translateBasicOpenOfficeFile(String extension) {\n        File testfile = testFileGenerator\n                .openTestFile(\"test-\" + extension + \".\" + extension);\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoVersion(\"master\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage\n                .translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save, switches to CodeMirror\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","id":34329,"modified_method":"@Feature(summary = \"The user can translate OpenOffice files\",\n        tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Theory\n    public void translateBasicOpenOfficeFile(String extension) {\n        File testfile = testFileGenerator\n                .openTestFile(\"test-\" + extension + \".\" + extension);\n        zanataRestCaller.createProjectAndVersion(extension+\"-translate\",\n                extension, \"file\");\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(extension+\"-translate\")\n                .gotoVersion(extension)\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage\n                .translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save, switches to CodeMirror\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n    public void before() {\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","id":34330,"modified_method":"@Before\n    public void before() {\n        zanataRestCaller = new ZanataRestCaller();\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        assumeFalse(\n                \"\",\n                new File(CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator)).exists());\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The user can translate a plain text file\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void translateBasicTextFile() {\n        File testfile = testFileGenerator.generateTestFileWithContent(\n                \"basictext\",\".txt\",\n                \"Line One\\nLine Two\\nLine Three\");\n\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoVersion(\"master\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage.translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save, switches to CodeMirror\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","id":34331,"modified_method":"@Feature(summary = \"The user can translate a plain text file\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void translateBasicTextFile() {\n        File testfile = testFileGenerator.generateTestFileWithContent(\n                \"basictext\",\".txt\",\n                \"Line One\\nLine Two\\nLine Three\");\n        zanataRestCaller.createProjectAndVersion(\"txt-translate\", \"txt\", \"file\");\n        EditorPage editorPage = new ProjectWorkFlow()\n                .goToProjectByName(\"txt-translate\")\n                .gotoVersion(\"txt\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(testfile.getAbsolutePath())\n                .submitUpload()\n                .clickUploadDone()\n                .gotoLanguageTab()\n                .translate(\"fr\", testfile.getName());\n\n        assertThat(editorPage.getMessageSourceAtRowIndex(0))\n                .isEqualTo(\"Line One\")\n                .as(\"Item 1 shows Line One\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(1))\n                .isEqualTo(\"Line Two\")\n                .as(\"Item 2 shows Line Two\");\n        assertThat(editorPage.getMessageSourceAtRowIndex(2))\n                .isEqualTo(\"Line Three\")\n                .as(\"Item 3 shows Line Three\");\n\n        editorPage = editorPage.translateTargetAtRowIndex(0, \"Une Ligne\")\n                .approveTranslationAtRow(0)\n                .translateTargetAtRowIndex(1, \"Deux Ligne\")\n                .approveTranslationAtRow(1)\n                .translateTargetAtRowIndex(2, \"Ligne Trois\")\n                .approveTranslationAtRow(2);\n\n        assertTranslations(editorPage);\n\n        // Close and reopen the editor to test save, switches to CodeMirror\n        editorPage.reload();\n\n        assertTranslations(editorPage);\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void rejectUnsupportedValidFiletype() {\n        File unsupportedFile = testFileGenerator\n                .generateTestFileWithContent(\"testfodt\", \".fodt\", \"<xml><\/xml>\");\n\n        VersionDocumentsTab versionDocumentsTab = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoVersion(\"txt-upload\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(unsupportedFile.getAbsolutePath())\n                .submitUpload();\n\n        assertThat(versionDocumentsTab.getUploadError())\n                .contains(\"is not valid for a source file on this server\")\n                .as(\"Unrecognized file extension error is shown\");\n    }","id":34332,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void rejectUnsupportedValidFiletype() {\n        File unsupportedFile = testFileGenerator\n                .generateTestFileWithContent(\"testfodt\", \".fodt\", \"<xml><\/xml>\");\n\n        VersionDocumentsTab versionDocumentsTab = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoVersion(\"txt-upload\")\n                .gotoSettingsTab()\n                .gotoSettingsDocumentsTab()\n                .pressUploadFileButton()\n                .enterFilePath(unsupportedFile.getAbsolutePath())\n                .submitUpload();\n\n        assertThat(versionDocumentsTab.getUploadError())\n                .contains(VersionDocumentsTab.UNSUPPORTED_FILETYPE)\n                .as(\"Unsupported file type error is shown\");\n    }","commit_id":"712e7c46ee7cca8ae8cffe204208230409268dea","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The administrator can create a project version\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 136517)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Category(BasicAcceptanceTest.class)\n    public void createASimpleProjectVersion() throws Exception {\n        VersionLanguagesPage versionLanguagesPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .clickCreateVersionLink()\n                .inputVersionId(\"my-aboutfedora-version\")\n                .saveVersion();\n\n        assertThat(versionLanguagesPage.getProjectVersionName())\n                .isEqualTo(\"my-aboutfedora-version\")\n                .as(\"The version is created with correct ID\");\n    }","id":34333,"modified_method":"@Feature(summary = \"The administrator can create a project version\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 136517)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Category(BasicAcceptanceTest.class)\n    public void createASimpleProjectVersion() throws Exception {\n        VersionLanguagesPage versionLanguagesPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .clickCreateVersionLink()\n                .clickCopyFromVersion()\n                .inputVersionId(\"my-aboutfedora-version\")\n                .saveVersion();\n\n        assertThat(versionLanguagesPage.getProjectVersionName())\n                .isEqualTo(\"my-aboutfedora-version\")\n                .as(\"The version is created with correct ID\");\n    }","commit_id":"a2cc569dcfaae025346949979177d535d072b059","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Create a new project version.\n     *\n     * @param projectName name of the project\n     * @param versionID ID of the version\n     * @param versionType type of the version\n     * @return new Version page, on the default Languages tab\n     */\n    public VersionLanguagesPage createNewProjectVersion(String projectName,\n            String versionID, String versionType) {\n        ProjectVersionsPage projectVersionsPage = goToProjectByName(projectName);\n        if (projectVersionsPage.getVersions().contains(versionID)) {\n            log.warn(\"{} has already been created. \" +\n                    \"Presumably you are running this test manually and more\" +\n                    \" than once.\", versionID);\n            return projectVersionsPage.gotoVersion(versionID);\n        }\n        return projectVersionsPage\n                .clickCreateVersionLink()\n                .inputVersionId(versionID)\n                .selectProjectType(versionType)\n                .saveVersion();\n    }","id":34334,"modified_method":"/**\n     * Create a new project version.\n     *\n     * @param projectName name of the project\n     * @param versionID ID of the version\n     * @param versionType type of the version\n     * @return new Version page, on the default Languages tab\n     */\n    public VersionLanguagesPage createNewProjectVersion(String projectName,\n            String versionID, String versionType) {\n        ProjectVersionsPage projectVersionsPage = goToProjectByName(projectName);\n        if (projectVersionsPage.getVersions().contains(versionID)) {\n            log.warn(\"{} has already been created. \" +\n                    \"Presumably you are running this test manually and more\" +\n                    \" than once.\", versionID);\n            return projectVersionsPage.gotoVersion(versionID);\n        }\n        return projectVersionsPage\n                .clickCreateVersionLink()\n                .clickCopyFromVersion()\n                .inputVersionId(versionID)\n                .selectProjectType(versionType)\n                .saveVersion();\n    }","commit_id":"a2cc569dcfaae025346949979177d535d072b059","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setCopyFromVersion(boolean copyFromVersion) {\n        this.copyFromVersion = copyFromVersion;\n        List<VersionItem> otherVersions = getOtherVersions();\n        if (!otherVersions.isEmpty()) {\n            this.copyFromVersionSlug =\n                    otherVersions.get(0).getVersion().getSlug();\n        } else {\n            this.copyFromVersionSlug = \"\";\n        }\n    }","id":34335,"modified_method":"private void setDefaultCopyFromVersion() {\n        List<VersionItem> otherVersions = getOtherVersions();\n        if (!otherVersions.isEmpty()\n                && StringUtils.isEmpty(copyFromVersionSlug)) {\n            this.copyFromVersionSlug =\n                    otherVersions.get(0).getVersion().getSlug();\n        }\n    }","commit_id":"a2cc569dcfaae025346949979177d535d072b059","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void init(boolean isNewInstance) {\n        this.isNewInstance = isNewInstance;\n        if (isNewInstance) {\n            // set copy from version option to true\n            if (StringUtils.isNotEmpty(copyFromVersionSlug)) {\n                copyFromVersion = true;\n            } else {\n                ProjectType projectType = getProject().getDefaultProjectType();\n                if (projectType != null) {\n                    selectedProjectType = projectType.name();\n                }\n            }\n\n        } else {\n            ProjectType versionProjectType = getInstance().getProjectType();\n            if (versionProjectType != null) {\n                selectedProjectType = versionProjectType.name();\n            }\n        }\n    }","id":34336,"modified_method":"public void init(boolean isNewInstance) {\n        this.isNewInstance = isNewInstance;\n        if (isNewInstance) {\n            ProjectType projectType = getProject().getDefaultProjectType();\n            if (projectType != null) {\n                selectedProjectType = projectType.name();\n            }\n            setDefaultCopyFromVersion();\n        } else {\n            ProjectType versionProjectType = getInstance().getProjectType();\n            if (versionProjectType != null) {\n                selectedProjectType = versionProjectType.name();\n            }\n            copyFromVersion = false;\n            copyFromVersionSlug = \"\";\n        }\n    }","commit_id":"a2cc569dcfaae025346949979177d535d072b059","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n\t// return variable that accumulates replacements\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n\tserverObjects prop = new serverObjects();\r\n        \r\n\tif ((post == null) || (env == null)) return prop;\r\n\r\n\tint proxyPrefetchDepth = Integer.parseInt(env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n\tint crawlingDepth = Integer.parseInt(env.getConfig(\"crawlingDepth\", \"0\"));\r\n\r\n\t// request values\r\n\tString iam        = (String) post.get(\"iam\", \"\");      // seed hash of requester\r\n        String youare     = (String) post.get(\"youare\", \"\");    // seed hash of the target peer, needed for network stability\r\n\tString process    = (String) post.get(\"process\", \"\");  // process type\r\n\tString key        = (String) post.get(\"key\", \"\");      // transmission key\r\n\tString urlhash    = (String) post.get(\"urlhash\", \"\");  // the url hash that has been crawled\r\n        String result     = (String) post.get(\"result\", \"\");   // the result; either \"ok\" or \"fail\"\r\n        String reason     = (String) post.get(\"reason\", \"\");   // the reason for that result\r\n        String words      = (String) post.get(\"wordh\", \"\");    // priority word hashes\r\n        String propStr    = crypt.simpleDecode((String) post.get(\"lurlEntry\", \"\"), key);\r\n        \r\n        /*\r\n         the result can have one of the following values:\r\n         negative cases, no retry\r\n           unavailable - the resource is not available (a broken link); not found or interrupted\r\n           exception   - an exception occurred\r\n           robot       - a robot-file has denied to crawl that resource\r\n\r\n         negative cases, retry possible\r\n           rejected    - the peer has rejected to load the resource\r\n           dequeue     - peer too busy - rejected to crawl\r\n         \r\n         positive cases with crawling\r\n           fill        - the resource was loaded and processed\r\n           update      - the resource was already in database but re-loaded and processed\r\n\t \r\n         positive cases without crawling\t \r\n           known       - the resource is already in database, believed to be fresh and not reloaded\r\n           stale       - the resource was reloaded but not processed because source had no changes\r\n\r\n        */\r\n        \r\n        if ((yacyCore.seedDB.mySeed == null) || (!(yacyCore.seedDB.mySeed.hash.equals(youare)))) {\r\n            // no yacy connection / unknown peers\r\n            prop.put(\"delay\", \"3600\");\r\n        } else if (propStr == null) {\r\n            // error with url / wrong key\r\n            prop.put(\"delay\", \"3600\");\r\n        } else if (result.equals(\"fill\")) {\r\n            // put new data into database\r\n            switchboard.urlPool.loadedURL.addEntry(switchboard.urlPool.loadedURL.newEntry(propStr, true), youare, iam, 1);\r\n            switchboard.urlPool.noticeURL.remove(urlhash);\r\n            \r\n            // write log\r\n            plasmaCrawlLURL.Entry entry = switchboard.urlPool.loadedURL.getEntry(urlhash);\r\n            if (entry == null) {\r\n                switchboard.getLog().logSevere(\"RECEIVED wrong RECEIPT for hash \" + urlhash + \" from peer \" + iam);\r\n            } else {\r\n                switchboard.getLog().logInfo(\"RECEIVED RECEIPT for URL \" + urlhash + \":\" + entry.url());\r\n            }\r\n            \r\n            // ready for more\r\n            prop.put(\"delay\", \"10\");\r\n        } else {\r\n            plasmaCrawlNURL.Entry en = switchboard.urlPool.noticeURL.getEntry(urlhash);\r\n            if (en != null) {\r\n                switchboard.urlPool.errorURL.newEntry(en.url(), en.referrerHash(), en.initiator(), iam, en.name(), result + \":\" + reason, new bitfield(plasmaURL.urlFlagLength), false);\r\n                switchboard.urlPool.noticeURL.remove(urlhash);\r\n            }\r\n            prop.put(\"delay\", \"100\"); // what shall we do with that???\r\n        }\r\n\t\r\n\t// return rewrite properties\r\n\treturn prop;\r\n    }","id":34337,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        serverLog log = switchboard.getLog();\r\n        \r\n\tif ((post == null) || (env == null)) return prop;\r\n\r\n\tint proxyPrefetchDepth = Integer.parseInt(env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n\tint crawlingDepth = Integer.parseInt(env.getConfig(\"crawlingDepth\", \"0\"));\r\n\r\n\t// request values\r\n\tString iam        = (String) post.get(\"iam\", \"\");      // seed hash of requester\r\n        String youare     = (String) post.get(\"youare\", \"\");    // seed hash of the target peer, needed for network stability\r\n\tString process    = (String) post.get(\"process\", \"\");  // process type\r\n\tString key        = (String) post.get(\"key\", \"\");      // transmission key\r\n\tString receivedUrlhash    = (String) post.get(\"urlhash\", \"\");  // the url hash that has been crawled\r\n        String result     = (String) post.get(\"result\", \"\");   // the result; either \"ok\" or \"fail\"\r\n        String reason     = (String) post.get(\"reason\", \"\");   // the reason for that result\r\n        String words      = (String) post.get(\"wordh\", \"\");    // priority word hashes\r\n        String propStr    = crypt.simpleDecode((String) post.get(\"lurlEntry\", \"\"), key);\r\n        \r\n        /*\r\n         the result can have one of the following values:\r\n         negative cases, no retry\r\n           unavailable - the resource is not available (a broken link); not found or interrupted\r\n           exception   - an exception occurred\r\n           robot       - a robot-file has denied to crawl that resource\r\n\r\n         negative cases, retry possible\r\n           rejected    - the peer has rejected to load the resource\r\n           dequeue     - peer too busy - rejected to crawl\r\n         \r\n         positive cases with crawling\r\n           fill        - the resource was loaded and processed\r\n           update      - the resource was already in database but re-loaded and processed\r\n\t \r\n         positive cases without crawling\t \r\n           known       - the resource is already in database, believed to be fresh and not reloaded\r\n           stale       - the resource was reloaded but not processed because source had no changes\r\n\r\n        */\r\n        \r\n        if ((yacyCore.seedDB.mySeed == null) || (!(yacyCore.seedDB.mySeed.hash.equals(youare)))) {\r\n            // no yacy connection / unknown peers\r\n            prop.put(\"delay\", \"3600\");\r\n        } else if (propStr == null) {\r\n            // error with url / wrong key\r\n            prop.put(\"delay\", \"3600\");\r\n        } else if (result.equals(\"fill\")) {\r\n            // generating a new loaded URL entry\r\n            plasmaCrawlLURL.Entry entry = switchboard.urlPool.loadedURL.newEntry(propStr, true);\r\n            if ((entry == null)||(entry.url()==null)) {\r\n                log.logWarning(\"crawlReceipt: RECEIVED wrong RECEIPT for hash \" + receivedUrlhash + \" from peer \" + iam +\r\n                              \"\\n\\tURL properties: \"+ propStr);\r\n            } else {\r\n                // put new entry into database\r\n                switchboard.urlPool.loadedURL.addEntry(entry, youare, iam, 1);\r\n                \r\n                // generating url hash\r\n                String newUrlHash = plasmaURL.urlHash(entry.url());\r\n                String oldUrlHash = plasmaURL.oldurlHash(entry.url());\r\n                \r\n                // removing URL from notice URL                \r\n                switchboard.urlPool.noticeURL.remove(newUrlHash);\r\n                switchboard.urlPool.noticeURL.remove(oldUrlHash); \r\n                \r\n                log.logInfo(\"crawlReceipt: RECEIVED RECEIPT for URL \" + receivedUrlhash + \":\" + entry.url());\r\n            }\r\n            \r\n            // ready for more\r\n            prop.put(\"delay\", \"10\");\r\n        } else {\r\n            plasmaCrawlNURL.Entry en = switchboard.urlPool.noticeURL.getEntry(receivedUrlhash);\r\n            if (en != null) {\r\n                switchboard.urlPool.errorURL.newEntry(en.url(), en.referrerHash(), en.initiator(), iam, en.name(), result + \":\" + reason, new bitfield(plasmaURL.urlFlagLength), false);\r\n                switchboard.urlPool.noticeURL.remove(receivedUrlhash);\r\n            }\r\n            prop.put(\"delay\", \"100\"); // what shall we do with that???\r\n        }\r\n\t\r\n\t// return rewrite properties\r\n\treturn prop;\r\n    }","commit_id":"0610ff4fe983480d96f8c23d597a4595c3fc8575","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws IOException {\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if (post == null) {\r\n            post = new serverObjects();\r\n            post.put(\"page\", \"start\");\r\n        }\r\n\r\n        String access = switchboard.getConfig(\"WikiAccess\", \"admin\");\r\n        String pagename = post.get(\"page\", \"start\");\r\n        String ip = post.get(\"CLIENTIP\", \"127.0.0.1\");\r\n        String author = post.get(\"author\", \"anonymous\");\r\n        if (author.equals(\"anonymous\")) {\r\n            author = wikiBoard.guessAuthor(ip);\r\n            if (author == null) {\r\n                if (de.anomic.yacy.yacyCore.seedDB.mySeed == null) author = \"anonymous\";\r\n                else author = de.anomic.yacy.yacyCore.seedDB.mySeed.get(\"Name\", \"anonymous\");\r\n            }\r\n        }\r\n        \r\n        if (post.containsKey(\"access\")) {\r\n            // only the administrator may change the access right\r\n            if (!switchboard.verifyAuthentication(header, true)) {\r\n                // check access right for admin\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            \r\n            access = post.get(\"access\", \"admin\");\r\n            switchboard.setConfig(\"WikiAccess\", access);\r\n        }\r\n        if (access.equals(\"admin\")) prop.put(\"mode_access\", 0);\r\n        if (access.equals(\"all\"))   prop.put(\"mode_access\", 1);\r\n        \r\n        if (post.containsKey(\"submit\")) {\r\n            \r\n            if ((access.equals(\"admin\") && (!switchboard.verifyAuthentication(header, true)))) {\r\n                // check access right for admin\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            \r\n            // store a new page\r\n            byte[] content;\r\n            try {\r\n                content = post.get(\"content\", \"\").getBytes(\"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                content = post.get(\"content\", \"\").getBytes();\r\n            }\r\n            switchboard.wikiDB.write(switchboard.wikiDB.newEntry(pagename, author, ip, post.get(\"reason\", \"edit\"), content));\r\n            // create a news message\r\n            HashMap map = new HashMap();\r\n            map.put(\"page\", pagename);\r\n            map.put(\"author\", author.replace(',', ' '));\r\n            yacyCore.newsPool.publishMyNews(new yacyNewsRecord(\"wiki_upd\", map));\r\n            prop.put(\"LOCATION\", \"/Wiki.html?page=\" + pagename);\r\n        }\r\n\r\n        wikiBoard.entry page = switchboard.wikiDB.read(pagename);\r\n\r\n        if (post.containsKey(\"edit\")) {\r\n            if ((access.equals(\"admin\") && (!switchboard.verifyAuthentication(header, true)))) {\r\n                // check access right for admin\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            \r\n            // edit the page\r\n            try {\r\n                prop.put(\"mode\", 1); //edit\r\n                prop.put(\"mode_author\", author);\r\n                prop.put(\"mode_page-code\", new String(page.page(), \"UTF-8\"));\r\n                prop.put(\"mode_pagename\", pagename);\r\n            } catch (UnsupportedEncodingException e) {}\r\n        }\r\n\r\n        //contributed by [MN]\r\n        else if (post.containsKey(\"preview\")) {\r\n            // preview the page\r\n            prop.put(\"mode\", 2);//preview\r\n            prop.put(\"mode_pagename\", pagename);\r\n            prop.put(\"mode_author\", author);\r\n            prop.put(\"mode_date\", dateString(new Date()));\r\n            prop.putWiki(\"mode_page\", post.get(\"content\", \"\"));\r\n            prop.put(\"mode_page-code\", post.get(\"content\", \"\"));\r\n        }\r\n        //end contrib of [MN]\r\n\r\n        else if (post.containsKey(\"index\")) {\r\n            // view an index\r\n            prop.put(\"mode\", 3); //Index\r\n            String subject;\r\n            try {\r\n                Iterator i = switchboard.wikiDB.keys(true);\r\n                wikiBoard.entry entry;\r\n                int count=0;\r\n                while (i.hasNext()) {\r\n                    subject = (String) i.next();\r\n                    entry = switchboard.wikiDB.read(subject);\r\n                    prop.put(\"mode_pages_\"+count+\"_name\",wikiBoard.webalize(subject));\r\n                    prop.put(\"mode_pages_\"+count+\"_subject\", subject);\r\n                    prop.put(\"mode_pages_\"+count+\"_date\", dateString(entry.date()));\r\n                    prop.put(\"mode_pages_\"+count+\"_author\", entry.author());\r\n                    count++;\r\n                }\r\n                prop.put(\"mode_pages\", count);\r\n            } catch (IOException e) {\r\n                prop.put(\"mode_error\", 1); //IO Error reading Wiki\r\n                prop.put(\"mode_error_message\", e.getMessage());\r\n            }\r\n            prop.put(\"mode_pagename\", pagename);\r\n        }\r\n        \r\n        else if (post.containsKey(\"diff\")) {\r\n            // Diff\r\n            prop.put(\"mode\", 4);\r\n            prop.put(\"mode_page\", pagename);\r\n            prop.put(\"mode_error_page\", pagename);\r\n            \r\n            try {\r\n                Iterator it = switchboard.wikiDB.keysBkp(true);\r\n                wikiBoard.entry entry;\r\n                wikiBoard.entry oentry = null;\r\n                wikiBoard.entry nentry = null;\r\n                int count = 0;\r\n                boolean oldselected = false, newselected = false;\r\n                while (it.hasNext()) {\r\n                    entry = switchboard.wikiDB.readBkp((String)it.next());\r\n                    prop.put(\"mode_error_versions_\" + count + \"_date\", wikiBoard.dateString(entry.date()));\r\n                    prop.put(\"mode_error_versions_\" + count + \"_fdate\", dateString(entry.date()));\r\n                    if (wikiBoard.dateString(entry.date()).equals(post.get(\"old\", null))) {\r\n                        prop.put(\"mode_error_versions_\" + count + \"_oldselected\", 1);\r\n                        oentry = entry;\r\n                        oldselected = true;\r\n                    } else if (wikiBoard.dateString(entry.date()).equals(post.get(\"new\", null))) {\r\n                        prop.put(\"mode_error_versions_\" + count + \"_newselected\", 1);\r\n                        nentry = entry;\r\n                        newselected = true;\r\n                    }\r\n                    count++;\r\n                }\r\n                count--;    // don't show current version\r\n                \r\n                if (!oldselected)   // select latest old entry\r\n                    prop.put(\"mode_error_versions_\" + (count - 1) + \"_oldselected\", 1);\r\n                if (!newselected)   // select latest new entry (== current)\r\n                    prop.put(\"mode_error_curselected\", 1);\r\n                \r\n                if (count == 0) {\r\n                    prop.put(\"mode_error\", 2); // no entries found\r\n                } else {\r\n                    prop.put(\"mode_error_versions\", count);\r\n                }\r\n                \r\n                entry = switchboard.wikiDB.read(pagename);\r\n                if (entry != null) {\r\n                    prop.put(\"mode_error_curdate\", wikiBoard.dateString(entry.date()));\r\n                    prop.put(\"mode_error_curfdate\", dateString(entry.date()));\r\n                }\r\n                \r\n                if (nentry == null) nentry = entry;\r\n                if (post.containsKey(\"compare\") && oentry != null && nentry != null) {\r\n                    // TODO: split into paragraphs and compare them with the same diff-algo\r\n                    Diff diff = new Diff(\r\n                            new String(oentry.page(), \"UTF-8\"),\r\n                            new String(nentry.page(), \"UTF-8\"), 3);\r\n                    prop.putASIS(\"mode_versioning_diff\", Diff.toHTML(new Diff[] { diff }));\r\n                    prop.put(\"mode_versioning\", 1);\r\n                } else if (post.containsKey(\"viewold\") && oentry != null) {\r\n                    prop.put(\"mode_versioning\", 2);\r\n                    prop.put(\"mode_versioning_pagename\", pagename);\r\n                    prop.put(\"mode_versioning_author\", oentry.author());\r\n                    prop.put(\"mode_versioning_date\", dateString(oentry.date()));\r\n                    prop.putWiki(\"mode_versioning_page\", oentry.page());\r\n                    prop.put(\"mode_versioning_page-code\", new String(oentry.page(), \"UTF-8\"));\r\n                }\r\n            } catch (IOException e) {\r\n                prop.put(\"mode_error\", 1); //IO Error reading Wiki\r\n                prop.put(\"mode_error_message\", e.getMessage());\r\n            }\r\n        }\r\n\r\n        else {\r\n            // show page\r\n            prop.put(\"mode\", 0); //viewing\r\n            prop.put(\"mode_pagename\", pagename);\r\n            prop.put(\"mode_author\", page.author());\r\n            prop.put(\"mode_date\", dateString(page.date()));\r\n            prop.putWiki(\"mode_page\", page.page());\r\n\r\n            prop.put(\"controls\", 0);\r\n            prop.put(\"controls_pagename\", pagename);\r\n        }\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":34338,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) throws IOException {\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if (post == null) {\r\n            post = new serverObjects();\r\n            post.put(\"page\", \"start\");\r\n        }\r\n\r\n        String access = switchboard.getConfig(\"WikiAccess\", \"admin\");\r\n        String pagename = post.get(\"page\", \"start\");\r\n        String ip = post.get(\"CLIENTIP\", \"127.0.0.1\");\r\n        String author = post.get(\"author\", \"anonymous\");\r\n        if (author.equals(\"anonymous\")) {\r\n            author = wikiBoard.guessAuthor(ip);\r\n            if (author == null) {\r\n                if (de.anomic.yacy.yacyCore.seedDB.mySeed == null) author = \"anonymous\";\r\n                else author = de.anomic.yacy.yacyCore.seedDB.mySeed.get(\"Name\", \"anonymous\");\r\n            }\r\n        }\r\n        \r\n        if (post.containsKey(\"access\")) {\r\n            // only the administrator may change the access right\r\n            if (!switchboard.verifyAuthentication(header, true)) {\r\n                // check access right for admin\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            \r\n            access = post.get(\"access\", \"admin\");\r\n            switchboard.setConfig(\"WikiAccess\", access);\r\n        }\r\n        if (access.equals(\"admin\")) prop.put(\"mode_access\", 0);\r\n        if (access.equals(\"all\"))   prop.put(\"mode_access\", 1);\r\n\r\n        wikiBoard.entry page = switchboard.wikiDB.read(pagename);\r\n        \r\n        if (post.containsKey(\"submit\")) {\r\n            \r\n            if ((access.equals(\"admin\") && (!switchboard.verifyAuthentication(header, true)))) {\r\n                // check access right for admin\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            \r\n            // store a new page\r\n            byte[] content;\r\n            try {\r\n                content = post.get(\"content\", \"\").getBytes(\"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                content = post.get(\"content\", \"\").getBytes();\r\n            }\r\n            wikiBoard.entry newEntry = switchboard.wikiDB.newEntry(pagename, author, ip, post.get(\"reason\", \"edit\"), content);\r\n            switchboard.wikiDB.write(newEntry);\r\n            // create a news message\r\n            HashMap map = new HashMap();\r\n            map.put(\"page\", pagename);\r\n            map.put(\"author\", author.replace(',', ' '));\r\n            if (!page.page().equals(content))\r\n                yacyCore.newsPool.publishMyNews(new yacyNewsRecord(\"wiki_upd\", map));\r\n            page = newEntry;\r\n            prop.put(\"LOCATION\", \"/Wiki.html?page=\" + pagename);\r\n        }\r\n\r\n        if (post.containsKey(\"edit\")) {\r\n            if ((access.equals(\"admin\") && (!switchboard.verifyAuthentication(header, true)))) {\r\n                // check access right for admin\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            \r\n            // edit the page\r\n            try {\r\n                prop.put(\"mode\", 1); //edit\r\n                prop.put(\"mode_author\", author);\r\n                prop.put(\"mode_page-code\", new String(page.page(), \"UTF-8\"));\r\n                prop.put(\"mode_pagename\", pagename);\r\n            } catch (UnsupportedEncodingException e) {}\r\n        }\r\n\r\n        //contributed by [MN]\r\n        else if (post.containsKey(\"preview\")) {\r\n            // preview the page\r\n            prop.put(\"mode\", 2);//preview\r\n            prop.put(\"mode_pagename\", pagename);\r\n            prop.put(\"mode_author\", author);\r\n            prop.put(\"mode_date\", dateString(new Date()));\r\n            prop.putWiki(\"mode_page\", post.get(\"content\", \"\"));\r\n            prop.put(\"mode_page-code\", post.get(\"content\", \"\"));\r\n        }\r\n        //end contrib of [MN]\r\n\r\n        else if (post.containsKey(\"index\")) {\r\n            // view an index\r\n            prop.put(\"mode\", 3); //Index\r\n            String subject;\r\n            try {\r\n                Iterator i = switchboard.wikiDB.keys(true);\r\n                wikiBoard.entry entry;\r\n                int count=0;\r\n                while (i.hasNext()) {\r\n                    subject = (String) i.next();\r\n                    entry = switchboard.wikiDB.read(subject);\r\n                    prop.put(\"mode_pages_\"+count+\"_name\",wikiBoard.webalize(subject));\r\n                    prop.put(\"mode_pages_\"+count+\"_subject\", subject);\r\n                    prop.put(\"mode_pages_\"+count+\"_date\", dateString(entry.date()));\r\n                    prop.put(\"mode_pages_\"+count+\"_author\", entry.author());\r\n                    count++;\r\n                }\r\n                prop.put(\"mode_pages\", count);\r\n            } catch (IOException e) {\r\n                prop.put(\"mode_error\", 1); //IO Error reading Wiki\r\n                prop.put(\"mode_error_message\", e.getMessage());\r\n            }\r\n            prop.put(\"mode_pagename\", pagename);\r\n        }\r\n        \r\n        else if (post.containsKey(\"diff\")) {\r\n            // Diff\r\n            prop.put(\"mode\", 4);\r\n            prop.put(\"mode_page\", pagename);\r\n            prop.put(\"mode_error_page\", pagename);\r\n            \r\n            try {\r\n                Iterator it = switchboard.wikiDB.keysBkp(true);\r\n                wikiBoard.entry entry;\r\n                wikiBoard.entry oentry = null;\r\n                wikiBoard.entry nentry = null;\r\n                int count = 0;\r\n                boolean oldselected = false, newselected = false;\r\n                while (it.hasNext()) {\r\n                    entry = switchboard.wikiDB.readBkp((String)it.next());\r\n                    prop.put(\"mode_error_versions_\" + count + \"_date\", wikiBoard.dateString(entry.date()));\r\n                    prop.put(\"mode_error_versions_\" + count + \"_fdate\", dateString(entry.date()));\r\n                    if (wikiBoard.dateString(entry.date()).equals(post.get(\"old\", null))) {\r\n                        prop.put(\"mode_error_versions_\" + count + \"_oldselected\", 1);\r\n                        oentry = entry;\r\n                        oldselected = true;\r\n                    } else if (wikiBoard.dateString(entry.date()).equals(post.get(\"new\", null))) {\r\n                        prop.put(\"mode_error_versions_\" + count + \"_newselected\", 1);\r\n                        nentry = entry;\r\n                        newselected = true;\r\n                    }\r\n                    count++;\r\n                }\r\n                count--;    // don't show current version\r\n                \r\n                if (!oldselected)   // select latest old entry\r\n                    prop.put(\"mode_error_versions_\" + (count - 1) + \"_oldselected\", 1);\r\n                if (!newselected)   // select latest new entry (== current)\r\n                    prop.put(\"mode_error_curselected\", 1);\r\n                \r\n                if (count == 0) {\r\n                    prop.put(\"mode_error\", 2); // no entries found\r\n                } else {\r\n                    prop.put(\"mode_error_versions\", count);\r\n                }\r\n                \r\n                entry = switchboard.wikiDB.read(pagename);\r\n                if (entry != null) {\r\n                    prop.put(\"mode_error_curdate\", wikiBoard.dateString(entry.date()));\r\n                    prop.put(\"mode_error_curfdate\", dateString(entry.date()));\r\n                }\r\n                \r\n                if (nentry == null) nentry = entry;\r\n                if (post.containsKey(\"compare\") && oentry != null && nentry != null) {\r\n                    // TODO: split into paragraphs and compare them with the same diff-algo\r\n                    Diff diff = new Diff(\r\n                            new String(oentry.page(), \"UTF-8\"),\r\n                            new String(nentry.page(), \"UTF-8\"), 3);\r\n                    prop.putASIS(\"mode_versioning_diff\", Diff.toHTML(new Diff[] { diff }));\r\n                    prop.put(\"mode_versioning\", 1);\r\n                } else if (post.containsKey(\"viewold\") && oentry != null) {\r\n                    prop.put(\"mode_versioning\", 2);\r\n                    prop.put(\"mode_versioning_pagename\", pagename);\r\n                    prop.put(\"mode_versioning_author\", oentry.author());\r\n                    prop.put(\"mode_versioning_date\", dateString(oentry.date()));\r\n                    prop.putWiki(\"mode_versioning_page\", oentry.page());\r\n                    prop.put(\"mode_versioning_page-code\", new String(oentry.page(), \"UTF-8\"));\r\n                }\r\n            } catch (IOException e) {\r\n                prop.put(\"mode_error\", 1); //IO Error reading Wiki\r\n                prop.put(\"mode_error_message\", e.getMessage());\r\n            }\r\n        }\r\n\r\n        else {\r\n            // show page\r\n            prop.put(\"mode\", 0); //viewing\r\n            prop.put(\"mode_pagename\", pagename);\r\n            prop.put(\"mode_author\", page.author());\r\n            prop.put(\"mode_date\", dateString(page.date()));\r\n            prop.putWiki(\"mode_page\", page.page());\r\n\r\n            prop.put(\"controls\", 0);\r\n            prop.put(\"controls_pagename\", pagename);\r\n        }\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"de1b4a1731974ba98f9431f27d96ba1177e7a491","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        //listManager.switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        Properties profile = new Properties();\r\n        FileInputStream fileIn = null;\r\n        try{\r\n            fileIn = new FileInputStream(new File(\"DATA/SETTINGS/profile.txt\"));\r\n            profile.load(fileIn);            \r\n        } catch(IOException e){            \r\n        } finally {\r\n            if (fileIn != null) try { fileIn.close(); } catch (Exception e) {}\r\n        }\r\n       \r\n        if(post != null && post.containsKey(\"set\")){\r\n            profile.setProperty(\"name\", (String)post.get(\"name\"));\r\n            profile.setProperty(\"nickname\", (String)post.get(\"nickname\"));\r\n            profile.setProperty(\"homepage\", (String)post.get(\"homepage\"));\r\n            profile.setProperty(\"email\", (String)post.get(\"email\"));\r\n            \r\n            profile.setProperty(\"icq\", (String)post.get(\"icq\"));\r\n            profile.setProperty(\"jabber\", (String)post.get(\"jabber\"));\r\n            profile.setProperty(\"yahoo\", (String)post.get(\"yahoo\"));\r\n            profile.setProperty(\"msn\", (String)post.get(\"msn\"));\r\n            \r\n            profile.setProperty(\"comment\", (String)post.get(\"comment\"));\r\n            \r\n            // write new values\r\n            FileOutputStream fileOut = null;\r\n            try{\r\n                fileOut = new FileOutputStream(new File(\"DATA/SETTINGS/profile.txt\"));\r\n                profile.store(fileOut , null );\r\n                \r\n                // generate a news message\r\n                //HashMap map = new HashMap();\r\n                yacyCore.newsPool.publishMyNews(new yacyNewsRecord(\"updprfle\", profile));\r\n            }catch(IOException e){\r\n            } finally {\r\n                if (fileOut != null) try { fileOut.close(); } catch (Exception e) {}\r\n            }\r\n        }\r\n        \r\n        prop.put(\"name\", profile.getProperty(\"name\", \"\"));\r\n        prop.put(\"nickname\", profile.getProperty(\"nickname\", \"\"));\r\n        prop.put(\"homepage\", profile.getProperty(\"homepage\", \"\"));\r\n        prop.put(\"email\", profile.getProperty(\"email\", \"\"));\r\n        \r\n        prop.put(\"icq\", profile.getProperty(\"icq\", \"\"));\r\n        prop.put(\"jabber\", profile.getProperty(\"jabber\", \"\"));\r\n        prop.put(\"yahoo\", profile.getProperty(\"yahoo\", \"\"));\r\n        prop.put(\"msn\", profile.getProperty(\"msn\", \"\"));\r\n        \r\n        prop.put(\"comment\", profile.getProperty(\"comment\", \"\"));\r\n         \r\n        return prop;\r\n    }","id":34339,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        //listManager.switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        Properties profile = new Properties();\r\n        FileInputStream fileIn = null;\r\n        try{\r\n            fileIn = new FileInputStream(new File(\"DATA/SETTINGS/profile.txt\"));\r\n            profile.load(fileIn);            \r\n        } catch(IOException e){            \r\n        } finally {\r\n            if (fileIn != null) try { fileIn.close(); } catch (Exception e) {}\r\n        }\r\n       \r\n        if(post != null && post.containsKey(\"set\")){\r\n            profile.setProperty(\"name\", (String)post.get(\"name\"));\r\n            profile.setProperty(\"nickname\", (String)post.get(\"nickname\"));\r\n            profile.setProperty(\"homepage\", (String)post.get(\"homepage\"));\r\n            profile.setProperty(\"email\", (String)post.get(\"email\"));\r\n            \r\n            profile.setProperty(\"icq\", (String)post.get(\"icq\"));\r\n            profile.setProperty(\"jabber\", (String)post.get(\"jabber\"));\r\n            profile.setProperty(\"yahoo\", (String)post.get(\"yahoo\"));\r\n            profile.setProperty(\"msn\", (String)post.get(\"msn\"));\r\n            \r\n            profile.setProperty(\"comment\", (String)post.get(\"comment\"));\r\n            \r\n            // write new values\r\n            FileOutputStream fileOut = null;\r\n            try{\r\n                fileOut = new FileOutputStream(new File(\"DATA/SETTINGS/profile.txt\"));\r\n                profile.store(fileOut , null );\r\n                \r\n                // generate a news message\r\n                //HashMap map = new HashMap();\r\n                yacyCore.newsPool.publishMyNews(new yacyNewsRecord(\"prfleupd\", profile));\r\n            }catch(IOException e){\r\n            } finally {\r\n                if (fileOut != null) try { fileOut.close(); } catch (Exception e) {}\r\n            }\r\n        }\r\n        \r\n        prop.put(\"name\", profile.getProperty(\"name\", \"\"));\r\n        prop.put(\"nickname\", profile.getProperty(\"nickname\", \"\"));\r\n        prop.put(\"homepage\", profile.getProperty(\"homepage\", \"\"));\r\n        prop.put(\"email\", profile.getProperty(\"email\", \"\"));\r\n        \r\n        prop.put(\"icq\", profile.getProperty(\"icq\", \"\"));\r\n        prop.put(\"jabber\", profile.getProperty(\"jabber\", \"\"));\r\n        prop.put(\"yahoo\", profile.getProperty(\"yahoo\", \"\"));\r\n        prop.put(\"msn\", profile.getProperty(\"msn\", \"\"));\r\n        \r\n        prop.put(\"comment\", profile.getProperty(\"comment\", \"\"));\r\n         \r\n        return prop;\r\n    }","commit_id":"13abd8b6e7db1fb438d58e54b40db39d20c712f8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        prop.put(\"error\", 0);\r\n        prop.put(\"info\", 0);\r\n        prop.put(\"refreshbutton\", 0);\r\n                            \r\n        switchboard.cleanProfiles();\r\n        \r\n        int i;\r\n        \r\n        if (post != null) {\r\n            if (post.containsKey(\"crawlingstart\")) {\r\n                // init crawl\r\n                if (yacyCore.seedDB == null) {\r\n                    prop.put(\"error\", 3);\r\n                } else {\r\n                    // set new properties\r\n                    String newcrawlingfilter = post.get(\"crawlingFilter\", \".*\");\r\n                    env.setConfig(\"crawlingFilter\", newcrawlingfilter);\r\n                    int newcrawlingdepth = Integer.parseInt((String) post.get(\"crawlingDepth\", \"0\"));\r\n                    env.setConfig(\"crawlingDepth\", (\"\" + newcrawlingdepth));\r\n                    boolean crawlingQ = ((String) post.get(\"crawlingQ\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"crawlingQ\", (crawlingQ) ? \"true\" : \"false\");\r\n                    boolean storeHTCache = ((String) post.get(\"storeHTCache\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"storeHTCache\", (storeHTCache) ? \"true\" : \"false\");\r\n                    boolean localIndexing = ((String) post.get(\"localIndexing\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"localIndexing\", (localIndexing) ? \"true\" : \"false\");\r\n                    boolean crawlOrder = ((String) post.get(\"crawlOrder\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"crawlOrder\", (crawlOrder) ? \"true\" : \"false\");\r\n                    boolean xsstopw = ((String) post.get(\"xsstopw\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"xsstopw\", (xsstopw) ? \"true\" : \"false\");\r\n                    boolean xdstopw = ((String) post.get(\"xdstopw\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"xdstopw\", (xdstopw) ? \"true\" : \"false\");\r\n                    boolean xpstopw = ((String) post.get(\"xpstopw\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"xpstopw\", (xpstopw) ? \"true\" : \"false\");\r\n                    \r\n                    String crawlingMode = post.get(\"crawlingMode\",\"url\");\r\n                    if (crawlingMode.equals(\"url\")) {\r\n                        String crawlingStart = (String) post.get(\"crawlingURL\");\r\n                        if (!(crawlingStart.startsWith(\"http\"))) crawlingStart = \"http://\" + crawlingStart;\r\n                        \r\n                        // check if url is proper\r\n                        URL crawlingStartURL = null;\r\n                        try {\r\n                            crawlingStartURL = new URL(crawlingStart);\r\n                        } catch (MalformedURLException e) {\r\n                            crawlingStartURL = null;\r\n                        }\r\n                        \r\n                        // check if pattern matches\r\n                        if ((crawlingStartURL == null) /* || (!(crawlingStart.matches(newcrawlingfilter))) */) {\r\n                            // print error message\r\n                            prop.put(\"error\", 4); //crawlfilter does not match url\r\n                            prop.put(\"error_newcrawlingfilter\", newcrawlingfilter);\r\n                            prop.put(\"error_crawlingStart\", crawlingStart);\r\n                        } else try {\r\n                            // stack request\r\n                            // first delete old entry, if exists\r\n                            String urlhash = plasmaURL.urlHash(crawlingStart);\r\n                            switchboard.urlPool.loadedURL.remove(urlhash);\r\n                            switchboard.urlPool.noticeURL.remove(urlhash);\r\n                            \r\n                            // stack url\r\n                            String reasonString = switchboard.stackCrawl(crawlingStart, null, yacyCore.seedDB.mySeed.hash, \"CRAWLING-ROOT\", new Date(), 0,\r\n                            switchboard.profiles.newEntry(crawlingStartURL.getHost(), crawlingStart, newcrawlingfilter, newcrawlingfilter, newcrawlingdepth, newcrawlingdepth, crawlingQ, storeHTCache, true, localIndexing, crawlOrder, xsstopw, xdstopw, xpstopw));\r\n                            \r\n                            if (reasonString == null) {\r\n                                // liftoff!\r\n                                prop.put(\"info\", 2);//start msg\r\n                                prop.put(\"info_crawlingURL\", ((String) post.get(\"crawlingURL\")));\r\n                            } else {\r\n                                prop.put(\"error\", 5); //Crawling failed\r\n                                prop.put(\"error_crawlingURL\", ((String) post.get(\"crawlingURL\")));\r\n                                prop.put(\"error_reasonString\", reasonString);\r\n                            }\r\n                        } catch (Exception e) {\r\n                            // mist\r\n                            prop.put(\"error\", 6);//Error with url\r\n                            prop.put(\"error_crawlingStart\", crawlingStart);\r\n                            prop.put(\"error_error\", e.getMessage());\r\n                            e.printStackTrace();\r\n                        }                        \r\n                        \r\n                    } else if (crawlingMode.equals(\"file\")) {                        \r\n                        if (post.containsKey(\"crawlingFile\")) {\r\n                            // getting the name of the uploaded file\r\n                            String fileName = (String) post.get(\"crawlingFile\");  \r\n                            try {                         \r\n                                File file = new File(fileName);\r\n                                \r\n                                // getting the content of the bookmark file\r\n                                byte[] fileContent = (byte[]) post.get(\"crawlingFile$file\");\r\n                                \r\n                                // parsing the bookmark file and fetching the headline and contained links\r\n                                htmlFilterContentScraper scraper = new htmlFilterContentScraper(file.toURL());\r\n                                OutputStream os = new htmlFilterOutputStream(null, scraper, null, false);\r\n                                serverFileUtils.write(fileContent,os);\r\n                                os.close();\r\n                                \r\n                                String headline = scraper.getHeadline();\r\n                                HashMap hyperlinks = (HashMap) scraper.getAnchors();\r\n                                \r\n                                // creating a crawler profile\r\n                                plasmaCrawlProfile.entry profile = switchboard.profiles.newEntry(fileName, file.toURL().toString(), newcrawlingfilter, newcrawlingfilter, newcrawlingdepth, newcrawlingdepth, crawlingQ, storeHTCache, true, localIndexing, crawlOrder, xsstopw, xdstopw, xpstopw);                                \r\n                                \r\n                                // loop through the contained links\r\n                                Iterator interator = hyperlinks.entrySet().iterator();\r\n                                int c = 0;\r\n                                while (interator.hasNext()) {\r\n                                    Map.Entry e = (Map.Entry) interator.next();\r\n                                    String nexturlstring = (String) e.getKey();\r\n                                    \r\n                                    // generating an url object\r\n                                    URL nexturlURL = null;\r\n                                    try {\r\n                                        nexturlURL = new URL(nexturlstring);\r\n                                    } catch (MalformedURLException ex) {\r\n                                        nexturlURL = null;\r\n                                        c++;\r\n                                        continue;\r\n                                    }                                    \r\n                                    \r\n                                    // enqueuing the url for crawling\r\n                                    String rejectReason = switchboard.stackCrawl(nexturlstring, null, yacyCore.seedDB.mySeed.hash, (String)e.getValue(), new Date(), 1, profile);                                    \r\n                                    \r\n                                    // if something failed add the url into the errorURL list\r\n                                    if (rejectReason == null) {\r\n                                        c++;\r\n                                    } else {\r\n                                        switchboard.urlPool.errorURL.newEntry(nexturlURL, null, yacyCore.seedDB.mySeed.hash, yacyCore.seedDB.mySeed.hash,\r\n                                       (String) e.getValue(), rejectReason, new bitfield(plasmaURL.urlFlagLength), false);\r\n                                    }\r\n                                }                             \r\n                                \r\n                            } catch (Exception e) {\r\n                                // mist\r\n                                prop.put(\"error\", 7);//Error with file\r\n                                prop.put(\"error_crawlingStart\", fileName);\r\n                                prop.put(\"error_error\", e.getMessage());\r\n                                e.printStackTrace();                                \r\n                            }\r\n                        }                        \r\n                    }\r\n                }\r\n            }\r\n\r\n            \r\n            \r\n            if (post.containsKey(\"distributedcrawling\")) {\r\n                long newBusySleep = Integer.parseInt(env.getConfig(\"62_remotetriggeredcrawl_busysleep\", \"100\"));\r\n                if (((String) post.get(\"dcr\", \"\")).equals(\"acceptCrawlMax\")) {\r\n                    env.setConfig(\"crawlResponse\", \"true\");\r\n                    newBusySleep = 100;\r\n                } else if (((String) post.get(\"dcr\", \"\")).equals(\"acceptCrawlLimited\")) {\r\n                    env.setConfig(\"crawlResponse\", \"true\");\r\n                    int newppm = Integer.parseInt(post.get(\"acceptCrawlLimit\", \"1\"));\r\n                    if (newppm < 1) newppm = 1;\r\n                    newBusySleep = 60000 / newppm;\r\n                    if (newBusySleep < 100) newBusySleep = 100;\r\n                } else if (((String) post.get(\"dcr\", \"\")).equals(\"acceptCrawlDenied\")) {\r\n                    env.setConfig(\"crawlResponse\", \"false\");\r\n                }\r\n                serverThread rct = switchboard.getThread(\"62_remotetriggeredcrawl\");\r\n                rct.setBusySleep(newBusySleep);\r\n                env.setConfig(\"62_remotetriggeredcrawl_busysleep\", \"\" + newBusySleep);\r\n                //boolean crawlResponse = ((String) post.get(\"acceptCrawlMax\", \"\")).equals(\"on\");\r\n                //env.setConfig(\"crawlResponse\", (crawlResponse) ? \"true\" : \"false\");\r\n            }\r\n\r\n            \r\n            if (post.containsKey(\"pausecrawlqueue\")) {\r\n                switchboard.pauseCrawling();\r\n                prop.put(\"info\", 4);//crawling paused\r\n            }           \r\n            \r\n            if (post.containsKey(\"continuecrawlqueue\")) {\r\n                switchboard.continueCrawling();\r\n                prop.put(\"info\", 5);//crawling continued\r\n            }                        \r\n        }\r\n        \r\n        // define visible variables\r\n        prop.put(\"proxyPrefetchDepth\", env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n        prop.put(\"crawlingDepth\", env.getConfig(\"crawlingDepth\", \"0\"));\r\n        prop.put(\"crawlingFilter\", env.getConfig(\"crawlingFilter\", \"0\"));\r\n        prop.put(\"crawlingQChecked\", env.getConfig(\"crawlingQ\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"storeHTCacheChecked\", env.getConfig(\"storeHTCache\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"localIndexingChecked\", env.getConfig(\"localIndexing\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"crawlOrderChecked\", env.getConfig(\"crawlOrder\", \"\").equals(\"true\") ? 1 : 0);\r\n        long busySleep = Integer.parseInt(env.getConfig(\"62_remotetriggeredcrawl_busysleep\", \"100\"));\r\n        if (busySleep < 100) {\r\n            busySleep = 100;\r\n            env.setConfig(\"62_remotetriggeredcrawl_busysleep\", \"\" + busySleep);\r\n        }\r\n        if (env.getConfig(\"crawlResponse\", \"\").equals(\"true\")) {\r\n            if (busySleep <= 100) {\r\n                prop.put(\"acceptCrawlMaxChecked\", 1);\r\n                prop.put(\"acceptCrawlLimitedChecked\", 0);\r\n                prop.put(\"acceptCrawlDeniedChecked\", 0);\r\n            } else {\r\n                prop.put(\"acceptCrawlMaxChecked\", 0);\r\n                prop.put(\"acceptCrawlLimitedChecked\", 1);\r\n                prop.put(\"acceptCrawlDeniedChecked\", 0);\r\n            }\r\n        } else {\r\n            prop.put(\"acceptCrawlMaxChecked\", 0);\r\n            prop.put(\"acceptCrawlLimitedChecked\", 0);\r\n            prop.put(\"acceptCrawlDeniedChecked\", 1);\r\n        }\r\n        int ppm = (int) ((long) 60000 / busySleep);\r\n        if (ppm > 60) ppm = 60;\r\n        prop.put(\"PPM\", ppm);\r\n        prop.put(\"xsstopwChecked\", env.getConfig(\"xsstopw\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"xdstopwChecked\", env.getConfig(\"xdstopw\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"xpstopwChecked\", env.getConfig(\"xpstopw\", \"\").equals(\"true\") ? 1 : 0);\r\n        \r\n        int queueStackSize = switchboard.sbQueue.size();\r\n        int loaderThreadsSize = switchboard.cacheLoader.size();\r\n        int crawlerListSize = switchboard.urlPool.noticeURL.stackSize();\r\n        int completequeue = queueStackSize + loaderThreadsSize + crawlerListSize;\r\n        \r\n        if ((completequeue > 0) || ((post != null) && (post.containsKey(\"refreshpage\")))) {\r\n            prop.put(\"refreshbutton\", 1);\r\n        }\r\n        \r\n        // create prefetch table\r\n        boolean dark;\r\n        \r\n        //  sed crawl profiles\r\n        int count = 0;\r\n        //try{\r\n        Iterator it = switchboard.profiles.profiles(true);\r\n        plasmaCrawlProfile.entry profile;\r\n        dark = true;\r\n        while (it.hasNext()) {\r\n            profile = (plasmaCrawlProfile.entry) it.next();\r\n            //table += profile.map().toString() + \"<br>\";\r\n            prop.put(\"crawlProfiles_\"+count+\"_dark\", ((dark) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_name\", profile.name());\r\n            prop.put(\"crawlProfiles_\"+count+\"_startURL\", profile.startURL());\r\n            prop.put(\"crawlProfiles_\"+count+\"_depth\", profile.generalDepth());\r\n            prop.put(\"crawlProfiles_\"+count+\"_filter\", profile.generalFilter());\r\n            prop.put(\"crawlProfiles_\"+count+\"_withQuery\", ((profile.crawlingQ()) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_storeCache\", ((profile.storeHTCache()) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_localIndexing\", ((profile.localIndexing()) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_remoteIndexing\", ((profile.remoteIndexing()) ? 1 : 0));\r\n            \r\n            dark = !dark;\r\n            count++;\r\n        }\r\n        //}catch(IOException e){};\r\n        prop.put(\"crawlProfiles\", count);\r\n        \r\n        // remote crawl peers\r\n        if (yacyCore.seedDB == null) {\r\n            //table += \"Sorry, cannot show any crawl output now because the system is not completely initialised. Please re-try.\";\r\n            prop.put(\"error\", 3);\r\n        } else {\r\n            Enumeration crawlavail = yacyCore.dhtAgent.getAcceptRemoteCrawlSeeds(plasmaURL.dummyHash, true);\r\n            Enumeration crawlpendi = yacyCore.dhtAgent.getAcceptRemoteCrawlSeeds(plasmaURL.dummyHash, false);\r\n            if ((!(crawlavail.hasMoreElements())) && (!(crawlpendi.hasMoreElements()))) {\r\n                prop.put(\"remoteCrawlPeers\", 0); //no peers availible\r\n            } else {\r\n                prop.put(\"remoteCrawlPeers\", 1);\r\n                int maxcount = 100;\r\n                int availcount = 0;\r\n                yacySeed seed;\r\n                while ((availcount < maxcount) && (crawlavail.hasMoreElements())) {\r\n                    seed = (yacySeed) crawlavail.nextElement();\r\n                    prop.put(\"remoteCrawlPeers_available_\" + availcount + \"_name\", seed.getName());\r\n                    prop.put(\"remoteCrawlPeers_available_\" + availcount + \"_due\", (yacyCore.yacyTime() - seed.available));\r\n                    availcount++;\r\n                }\r\n                prop.put(\"remoteCrawlPeers_available\", availcount);\r\n                int pendicount = 0;\r\n                while ((pendicount < maxcount) && (crawlpendi.hasMoreElements())) {\r\n                    seed = (yacySeed) crawlpendi.nextElement();\r\n                    prop.put(\"remoteCrawlPeers_busy_\" + pendicount + \"_name\", seed.getName());\r\n                    prop.put(\"remoteCrawlPeers_busy_\" + pendicount + \"_due\", (yacyCore.yacyTime() - seed.available));\r\n                    pendicount++;\r\n                }\r\n                prop.put(\"remoteCrawlPeers_busy\", pendicount);\r\n                prop.put(\"remoteCrawlPeers_num\", (availcount + pendicount));\r\n            }\r\n\r\n        }\r\n        \r\n        \r\n        prop.put(\"crawler-paused\",(switchboard.crawlingIsPaused())?0:1);\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":34340,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        \r\n        prop.put(\"error\", 0);\r\n        prop.put(\"info\", 0);\r\n        prop.put(\"refreshbutton\", 0);\r\n                            \r\n        switchboard.cleanProfiles();\r\n        \r\n        int i;\r\n        \r\n        if (post != null) {\r\n            if (post.containsKey(\"crawlingstart\")) {\r\n                // init crawl\r\n                if (yacyCore.seedDB == null) {\r\n                    prop.put(\"error\", 3);\r\n                } else {\r\n                    // set new properties\r\n                    String newcrawlingfilter = post.get(\"crawlingFilter\", \".*\");\r\n                    env.setConfig(\"crawlingFilter\", newcrawlingfilter);\r\n                    int newcrawlingdepth = Integer.parseInt((String) post.get(\"crawlingDepth\", \"0\"));\r\n                    env.setConfig(\"crawlingDepth\", (\"\" + newcrawlingdepth));\r\n                    boolean crawlingQ = ((String) post.get(\"crawlingQ\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"crawlingQ\", (crawlingQ) ? \"true\" : \"false\");\r\n                    boolean storeHTCache = ((String) post.get(\"storeHTCache\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"storeHTCache\", (storeHTCache) ? \"true\" : \"false\");\r\n                    boolean localIndexing = ((String) post.get(\"localIndexing\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"localIndexing\", (localIndexing) ? \"true\" : \"false\");\r\n                    boolean crawlOrder = ((String) post.get(\"crawlOrder\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"crawlOrder\", (crawlOrder) ? \"true\" : \"false\");\r\n                    boolean xsstopw = ((String) post.get(\"xsstopw\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"xsstopw\", (xsstopw) ? \"true\" : \"false\");\r\n                    boolean xdstopw = ((String) post.get(\"xdstopw\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"xdstopw\", (xdstopw) ? \"true\" : \"false\");\r\n                    boolean xpstopw = ((String) post.get(\"xpstopw\", \"\")).equals(\"on\");\r\n                    env.setConfig(\"xpstopw\", (xpstopw) ? \"true\" : \"false\");\r\n                    \r\n                    String crawlingMode = post.get(\"crawlingMode\",\"url\");\r\n                    if (crawlingMode.equals(\"url\")) {\r\n                        String crawlingStart = (String) post.get(\"crawlingURL\");\r\n                        if (!(crawlingStart.startsWith(\"http\"))) crawlingStart = \"http://\" + crawlingStart;\r\n                        \r\n                        // check if url is proper\r\n                        URL crawlingStartURL = null;\r\n                        try {\r\n                            crawlingStartURL = new URL(crawlingStart);\r\n                        } catch (MalformedURLException e) {\r\n                            crawlingStartURL = null;\r\n                        }\r\n                        \r\n                        // check if pattern matches\r\n                        if ((crawlingStartURL == null) /* || (!(crawlingStart.matches(newcrawlingfilter))) */) {\r\n                            // print error message\r\n                            prop.put(\"error\", 4); //crawlfilter does not match url\r\n                            prop.put(\"error_newcrawlingfilter\", newcrawlingfilter);\r\n                            prop.put(\"error_crawlingStart\", crawlingStart);\r\n                        } else try {\r\n                            // stack request\r\n                            // first delete old entry, if exists\r\n                            String urlhash = plasmaURL.urlHash(crawlingStart);\r\n                            switchboard.urlPool.loadedURL.remove(urlhash);\r\n                            switchboard.urlPool.noticeURL.remove(urlhash);\r\n                            \r\n                            // stack url\r\n                            plasmaCrawlProfile.entry pe = switchboard.profiles.newEntry(crawlingStartURL.getHost(), crawlingStart, newcrawlingfilter, newcrawlingfilter, newcrawlingdepth, newcrawlingdepth, crawlingQ, storeHTCache, true, localIndexing, crawlOrder, xsstopw, xdstopw, xpstopw);\r\n                            String reasonString = switchboard.stackCrawl(crawlingStart, null, yacyCore.seedDB.mySeed.hash, \"CRAWLING-ROOT\", new Date(), 0, pe);\r\n                            \r\n                            if (reasonString == null) {\r\n                                // liftoff!\r\n                                prop.put(\"info\", 2);//start msg\r\n                                prop.put(\"info_crawlingURL\", ((String) post.get(\"crawlingURL\")));\r\n                                \r\n                                // generate a YaCyNews if the global flag was set\r\n                                if (crawlOrder) {\r\n                                    yacyCore.newsPool.publishMyNews(new yacyNewsRecord(\"crwlstrt\", pe.map()));\r\n                                }\r\n                                \r\n                            } else {\r\n                                prop.put(\"error\", 5); //Crawling failed\r\n                                prop.put(\"error_crawlingURL\", ((String) post.get(\"crawlingURL\")));\r\n                                prop.put(\"error_reasonString\", reasonString);\r\n                            }\r\n                        } catch (Exception e) {\r\n                            // mist\r\n                            prop.put(\"error\", 6);//Error with url\r\n                            prop.put(\"error_crawlingStart\", crawlingStart);\r\n                            prop.put(\"error_error\", e.getMessage());\r\n                            e.printStackTrace();\r\n                        }                        \r\n                        \r\n                    } else if (crawlingMode.equals(\"file\")) {                        \r\n                        if (post.containsKey(\"crawlingFile\")) {\r\n                            // getting the name of the uploaded file\r\n                            String fileName = (String) post.get(\"crawlingFile\");  \r\n                            try {                         \r\n                                File file = new File(fileName);\r\n                                \r\n                                // getting the content of the bookmark file\r\n                                byte[] fileContent = (byte[]) post.get(\"crawlingFile$file\");\r\n                                \r\n                                // parsing the bookmark file and fetching the headline and contained links\r\n                                htmlFilterContentScraper scraper = new htmlFilterContentScraper(file.toURL());\r\n                                OutputStream os = new htmlFilterOutputStream(null, scraper, null, false);\r\n                                serverFileUtils.write(fileContent,os);\r\n                                os.close();\r\n                                \r\n                                String headline = scraper.getHeadline();\r\n                                HashMap hyperlinks = (HashMap) scraper.getAnchors();\r\n                                \r\n                                // creating a crawler profile\r\n                                plasmaCrawlProfile.entry profile = switchboard.profiles.newEntry(fileName, file.toURL().toString(), newcrawlingfilter, newcrawlingfilter, newcrawlingdepth, newcrawlingdepth, crawlingQ, storeHTCache, true, localIndexing, crawlOrder, xsstopw, xdstopw, xpstopw);                                \r\n                                \r\n                                // loop through the contained links\r\n                                Iterator interator = hyperlinks.entrySet().iterator();\r\n                                int c = 0;\r\n                                while (interator.hasNext()) {\r\n                                    Map.Entry e = (Map.Entry) interator.next();\r\n                                    String nexturlstring = (String) e.getKey();\r\n                                    \r\n                                    // generating an url object\r\n                                    URL nexturlURL = null;\r\n                                    try {\r\n                                        nexturlURL = new URL(nexturlstring);\r\n                                    } catch (MalformedURLException ex) {\r\n                                        nexturlURL = null;\r\n                                        c++;\r\n                                        continue;\r\n                                    }                                    \r\n                                    \r\n                                    // enqueuing the url for crawling\r\n                                    String rejectReason = switchboard.stackCrawl(nexturlstring, null, yacyCore.seedDB.mySeed.hash, (String)e.getValue(), new Date(), 1, profile);                                    \r\n                                    \r\n                                    // if something failed add the url into the errorURL list\r\n                                    if (rejectReason == null) {\r\n                                        c++;\r\n                                    } else {\r\n                                        switchboard.urlPool.errorURL.newEntry(nexturlURL, null, yacyCore.seedDB.mySeed.hash, yacyCore.seedDB.mySeed.hash,\r\n                                       (String) e.getValue(), rejectReason, new bitfield(plasmaURL.urlFlagLength), false);\r\n                                    }\r\n                                }                             \r\n                                \r\n                            } catch (Exception e) {\r\n                                // mist\r\n                                prop.put(\"error\", 7);//Error with file\r\n                                prop.put(\"error_crawlingStart\", fileName);\r\n                                prop.put(\"error_error\", e.getMessage());\r\n                                e.printStackTrace();                                \r\n                            }\r\n                        }                        \r\n                    }\r\n                }\r\n            }\r\n\r\n            \r\n            \r\n            if (post.containsKey(\"distributedcrawling\")) {\r\n                long newBusySleep = Integer.parseInt(env.getConfig(\"62_remotetriggeredcrawl_busysleep\", \"100\"));\r\n                if (((String) post.get(\"dcr\", \"\")).equals(\"acceptCrawlMax\")) {\r\n                    env.setConfig(\"crawlResponse\", \"true\");\r\n                    newBusySleep = 100;\r\n                } else if (((String) post.get(\"dcr\", \"\")).equals(\"acceptCrawlLimited\")) {\r\n                    env.setConfig(\"crawlResponse\", \"true\");\r\n                    int newppm = Integer.parseInt(post.get(\"acceptCrawlLimit\", \"1\"));\r\n                    if (newppm < 1) newppm = 1;\r\n                    newBusySleep = 60000 / newppm;\r\n                    if (newBusySleep < 100) newBusySleep = 100;\r\n                } else if (((String) post.get(\"dcr\", \"\")).equals(\"acceptCrawlDenied\")) {\r\n                    env.setConfig(\"crawlResponse\", \"false\");\r\n                }\r\n                serverThread rct = switchboard.getThread(\"62_remotetriggeredcrawl\");\r\n                rct.setBusySleep(newBusySleep);\r\n                env.setConfig(\"62_remotetriggeredcrawl_busysleep\", \"\" + newBusySleep);\r\n                //boolean crawlResponse = ((String) post.get(\"acceptCrawlMax\", \"\")).equals(\"on\");\r\n                //env.setConfig(\"crawlResponse\", (crawlResponse) ? \"true\" : \"false\");\r\n            }\r\n\r\n            \r\n            if (post.containsKey(\"pausecrawlqueue\")) {\r\n                switchboard.pauseCrawling();\r\n                prop.put(\"info\", 4);//crawling paused\r\n            }           \r\n            \r\n            if (post.containsKey(\"continuecrawlqueue\")) {\r\n                switchboard.continueCrawling();\r\n                prop.put(\"info\", 5);//crawling continued\r\n            }                        \r\n        }\r\n        \r\n        // define visible variables\r\n        prop.put(\"proxyPrefetchDepth\", env.getConfig(\"proxyPrefetchDepth\", \"0\"));\r\n        prop.put(\"crawlingDepth\", env.getConfig(\"crawlingDepth\", \"0\"));\r\n        prop.put(\"crawlingFilter\", env.getConfig(\"crawlingFilter\", \"0\"));\r\n        prop.put(\"crawlingQChecked\", env.getConfig(\"crawlingQ\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"storeHTCacheChecked\", env.getConfig(\"storeHTCache\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"localIndexingChecked\", env.getConfig(\"localIndexing\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"crawlOrderChecked\", env.getConfig(\"crawlOrder\", \"\").equals(\"true\") ? 1 : 0);\r\n        long busySleep = Integer.parseInt(env.getConfig(\"62_remotetriggeredcrawl_busysleep\", \"100\"));\r\n        if (busySleep < 100) {\r\n            busySleep = 100;\r\n            env.setConfig(\"62_remotetriggeredcrawl_busysleep\", \"\" + busySleep);\r\n        }\r\n        if (env.getConfig(\"crawlResponse\", \"\").equals(\"true\")) {\r\n            if (busySleep <= 100) {\r\n                prop.put(\"acceptCrawlMaxChecked\", 1);\r\n                prop.put(\"acceptCrawlLimitedChecked\", 0);\r\n                prop.put(\"acceptCrawlDeniedChecked\", 0);\r\n            } else {\r\n                prop.put(\"acceptCrawlMaxChecked\", 0);\r\n                prop.put(\"acceptCrawlLimitedChecked\", 1);\r\n                prop.put(\"acceptCrawlDeniedChecked\", 0);\r\n            }\r\n        } else {\r\n            prop.put(\"acceptCrawlMaxChecked\", 0);\r\n            prop.put(\"acceptCrawlLimitedChecked\", 0);\r\n            prop.put(\"acceptCrawlDeniedChecked\", 1);\r\n        }\r\n        int ppm = (int) ((long) 60000 / busySleep);\r\n        if (ppm > 60) ppm = 60;\r\n        prop.put(\"PPM\", ppm);\r\n        prop.put(\"xsstopwChecked\", env.getConfig(\"xsstopw\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"xdstopwChecked\", env.getConfig(\"xdstopw\", \"\").equals(\"true\") ? 1 : 0);\r\n        prop.put(\"xpstopwChecked\", env.getConfig(\"xpstopw\", \"\").equals(\"true\") ? 1 : 0);\r\n        \r\n        int queueStackSize = switchboard.sbQueue.size();\r\n        int loaderThreadsSize = switchboard.cacheLoader.size();\r\n        int crawlerListSize = switchboard.urlPool.noticeURL.stackSize();\r\n        int completequeue = queueStackSize + loaderThreadsSize + crawlerListSize;\r\n        \r\n        if ((completequeue > 0) || ((post != null) && (post.containsKey(\"refreshpage\")))) {\r\n            prop.put(\"refreshbutton\", 1);\r\n        }\r\n        \r\n        // create prefetch table\r\n        boolean dark;\r\n        \r\n        //  sed crawl profiles\r\n        int count = 0;\r\n        //try{\r\n        Iterator it = switchboard.profiles.profiles(true);\r\n        plasmaCrawlProfile.entry profile;\r\n        dark = true;\r\n        while (it.hasNext()) {\r\n            profile = (plasmaCrawlProfile.entry) it.next();\r\n            //table += profile.map().toString() + \"<br>\";\r\n            prop.put(\"crawlProfiles_\"+count+\"_dark\", ((dark) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_name\", profile.name());\r\n            prop.put(\"crawlProfiles_\"+count+\"_startURL\", profile.startURL());\r\n            prop.put(\"crawlProfiles_\"+count+\"_depth\", profile.generalDepth());\r\n            prop.put(\"crawlProfiles_\"+count+\"_filter\", profile.generalFilter());\r\n            prop.put(\"crawlProfiles_\"+count+\"_withQuery\", ((profile.crawlingQ()) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_storeCache\", ((profile.storeHTCache()) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_localIndexing\", ((profile.localIndexing()) ? 1 : 0));\r\n            prop.put(\"crawlProfiles_\"+count+\"_remoteIndexing\", ((profile.remoteIndexing()) ? 1 : 0));\r\n            \r\n            dark = !dark;\r\n            count++;\r\n        }\r\n        //}catch(IOException e){};\r\n        prop.put(\"crawlProfiles\", count);\r\n        \r\n        // remote crawl peers\r\n        if (yacyCore.seedDB == null) {\r\n            //table += \"Sorry, cannot show any crawl output now because the system is not completely initialised. Please re-try.\";\r\n            prop.put(\"error\", 3);\r\n        } else {\r\n            Enumeration crawlavail = yacyCore.dhtAgent.getAcceptRemoteCrawlSeeds(plasmaURL.dummyHash, true);\r\n            Enumeration crawlpendi = yacyCore.dhtAgent.getAcceptRemoteCrawlSeeds(plasmaURL.dummyHash, false);\r\n            if ((!(crawlavail.hasMoreElements())) && (!(crawlpendi.hasMoreElements()))) {\r\n                prop.put(\"remoteCrawlPeers\", 0); //no peers availible\r\n            } else {\r\n                prop.put(\"remoteCrawlPeers\", 1);\r\n                int maxcount = 100;\r\n                int availcount = 0;\r\n                yacySeed seed;\r\n                while ((availcount < maxcount) && (crawlavail.hasMoreElements())) {\r\n                    seed = (yacySeed) crawlavail.nextElement();\r\n                    prop.put(\"remoteCrawlPeers_available_\" + availcount + \"_name\", seed.getName());\r\n                    prop.put(\"remoteCrawlPeers_available_\" + availcount + \"_due\", (yacyCore.yacyTime() - seed.available));\r\n                    availcount++;\r\n                }\r\n                prop.put(\"remoteCrawlPeers_available\", availcount);\r\n                int pendicount = 0;\r\n                while ((pendicount < maxcount) && (crawlpendi.hasMoreElements())) {\r\n                    seed = (yacySeed) crawlpendi.nextElement();\r\n                    prop.put(\"remoteCrawlPeers_busy_\" + pendicount + \"_name\", seed.getName());\r\n                    prop.put(\"remoteCrawlPeers_busy_\" + pendicount + \"_due\", (yacyCore.yacyTime() - seed.available));\r\n                    pendicount++;\r\n                }\r\n                prop.put(\"remoteCrawlPeers_busy\", pendicount);\r\n                prop.put(\"remoteCrawlPeers_num\", (availcount + pendicount));\r\n            }\r\n\r\n        }\r\n        \r\n        \r\n        prop.put(\"crawler-paused\",(switchboard.crawlingIsPaused())?0:1);\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"13abd8b6e7db1fb438d58e54b40db39d20c712f8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void initProfiles() throws IOException {\r\n        if ((profiles.size() == 0) ||\r\n            (getConfig(\"defaultProxyProfile\", \"\").length() == 0) ||\r\n            (profiles.getEntry(getConfig(\"defaultProxyProfile\", \"\")) == null)) {\r\n            // generate new default entry for proxy crawling\r\n            defaultProxyProfile = profiles.newEntry(\"proxy\", \"\", \".*\", \".*\", Integer.parseInt(getConfig(\"proxyPrefetchDepth\", \"0\")), Integer.parseInt(getConfig(\"proxyPrefetchDepth\", \"0\")), false, true, true, true, false, true, true, true);\r\n            setConfig(\"defaultProxyProfile\", defaultProxyProfile.handle());\r\n        } else {\r\n            defaultProxyProfile = profiles.getEntry(getConfig(\"defaultProxyProfile\", \"\"));\r\n        }\r\n        if ((profiles.size() == 1) ||\r\n            (getConfig(\"defaultRemoteProfile\", \"\").length() == 0) ||\r\n            (profiles.getEntry(getConfig(\"defaultRemoteProfile\", \"\")) == null)) {\r\n            // generate new default entry for proxy crawling\r\n            defaultRemoteProfile = profiles.newEntry(\"remote\", \"\", \".*\", \".*\", 0, 0, false, false, true, true, false, true, true, false);\r\n            setConfig(\"defaultRemoteProfile\", defaultRemoteProfile.handle());\r\n        } else {\r\n            defaultRemoteProfile = profiles.getEntry(getConfig(\"defaultRemoteProfile\", \"\"));\r\n        }\r\n    }","id":34341,"modified_method":"private void initProfiles() throws IOException {\r\n        if ((profiles.size() == 0) ||\r\n            (getConfig(\"defaultProxyProfile\", \"\").length() == 0) ||\r\n            (profiles.getEntry(getConfig(\"defaultProxyProfile\", \"\")) == null)) {\r\n            // generate new default entry for proxy crawling\r\n            defaultProxyProfile = profiles.newEntry(\"proxy\", \"\", \".*\", \".*\", Integer.parseInt(getConfig(\"proxyPrefetchDepth\", \"0\")), Integer.parseInt(getConfig(\"proxyPrefetchDepth\", \"0\")), false, true, true, true, false, true, true, true);\r\n            setConfig(\"defaultProxyProfile\", defaultProxyProfile.handle());\r\n        } else {\r\n            defaultProxyProfile = profiles.getEntry(getConfig(\"defaultProxyProfile\", \"\"));\r\n        }\r\n        if ((profiles.size() == 1) ||\r\n            (getConfig(\"defaultRemoteProfile\", \"\").length() == 0) ||\r\n            (profiles.getEntry(getConfig(\"defaultRemoteProfile\", \"\")) == null)) {\r\n            // generate new default entry for remote crawling\r\n            defaultRemoteProfile = profiles.newEntry(\"remote\", \"\", \".*\", \".*\", 0, 0, true, false, true, true, false, true, true, false);\r\n            setConfig(\"defaultRemoteProfile\", defaultRemoteProfile.handle());\r\n        } else {\r\n            defaultRemoteProfile = profiles.getEntry(getConfig(\"defaultRemoteProfile\", \"\"));\r\n        }\r\n    }","commit_id":"13abd8b6e7db1fb438d58e54b40db39d20c712f8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n\t * Adds a Collection and its child collections and resources recursively to\r\n\t * a archive\r\n\t * \r\n\t * @param os\r\n\t *            The Output Stream to add the document to\r\n\t * @param col\r\n\t *            The Collection to add to the archive\r\n\t * @param useHierarchy\r\n\t *            Whether to use a folder hierarchy in the archive file that\r\n\t *            reflects the collection hierarchy\r\n\t */\r\n\tprivate void compressCollection(OutputStream os, Collection col, boolean useHierarchy, String stripOffset) throws IOException, SAXException, LockException {\r\n\t\t// iterate over child documents\r\n\t\tMutableDocumentSet childDocs = new DefaultDocumentSet();\r\n\t\tcol.getDocuments(context.getBroker(), childDocs, true);\r\n\t\tfor (Iterator itChildDocs = childDocs.getDocumentIterator(); itChildDocs\r\n\t\t\t\t.hasNext();) {\r\n\t\t\tDocumentImpl childDoc = (DocumentImpl) itChildDocs.next();\r\n\t\t\tchildDoc.getUpdateLock().acquire(Lock.READ_LOCK);\r\n\t\t\ttry {\r\n\t\t\t\tcompressResource(os, childDoc, useHierarchy, stripOffset);\r\n\t\t\t} finally {\r\n\t\t\t\tchildDoc.getUpdateLock().release(Lock.READ_LOCK);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// iterate over child collections\r\n\t\tfor (Iterator itChildCols = col.collectionIterator(); itChildCols.hasNext();) {\r\n\t\t\t// get the child collection\r\n\t\t\tXmldbURI childColURI = (XmldbURI) itChildCols.next();\r\n\t\t\tCollection childCol = context.getBroker().getCollection(col.getURI().append(childColURI));\r\n\t\t\t// recurse\r\n\t\t\tcompressCollection(os, childCol, useHierarchy, stripOffset);\r\n\t\t}\r\n\t}","id":34342,"modified_method":"/**\r\n\t * Adds a Collection and its child collections and resources recursively to\r\n\t * a archive\r\n\t * \r\n\t * @param os\r\n\t *            The Output Stream to add the document to\r\n\t * @param col\r\n\t *            The Collection to add to the archive\r\n\t * @param useHierarchy\r\n\t *            Whether to use a folder hierarchy in the archive file that\r\n\t *            reflects the collection hierarchy\r\n\t */\r\n\tprivate void compressCollection(OutputStream os, Collection col, boolean useHierarchy, String stripOffset) throws IOException, SAXException, LockException {\r\n\t\t// iterate over child documents\r\n\t\tMutableDocumentSet childDocs = new DefaultDocumentSet();\r\n\t\tcol.getDocuments(context.getBroker(), childDocs, true);\r\n\t\tfor (Iterator itChildDocs = childDocs.getDocumentIterator(); itChildDocs\r\n\t\t\t\t.hasNext();) {\r\n\t\t\tDocumentImpl childDoc = (DocumentImpl) itChildDocs.next();\r\n\t\t\tchildDoc.getUpdateLock().acquire(Lock.READ_LOCK);\r\n\t\t\ttry {\r\n\t\t\t\tcompressResource(os, childDoc, useHierarchy, stripOffset, null);\r\n\t\t\t} finally {\r\n\t\t\t\tchildDoc.getUpdateLock().release(Lock.READ_LOCK);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// iterate over child collections\r\n\t\tfor (Iterator itChildCols = col.collectionIterator(); itChildCols.hasNext();) {\r\n\t\t\t// get the child collection\r\n\t\t\tXmldbURI childColURI = (XmldbURI) itChildCols.next();\r\n\t\t\tCollection childCol = context.getBroker().getCollection(col.getURI().append(childColURI));\r\n\t\t\t// recurse\r\n\t\t\tcompressCollection(os, childCol, useHierarchy, stripOffset);\r\n\t\t}\r\n\t}","commit_id":"6e79313fc508f7e22b31db7fc07ef395d60aaf93","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\r\n\t * Adds a element to a archive\r\n\t * \r\n\t * @param os\r\n\t *            The Output Stream to add the element to\r\n\t * @param nodeValue\r\n\t *            The element to add to the archive\r\n\t * @param useHierarchy\r\n\t *            Whether to use a folder hierarchy in the archive file that\r\n\t *            reflects the collection hierarchy\r\n\t */\r\n\tprivate void compressElement(OutputStream os, Element element, boolean useHierarchy, String stripOffset) throws XPathException, IOException, SAXException {\r\n\t\t if (element.getNodeName().equals(\"entry\") && element.getNamespaceURI().equals(\"\")){\r\n\t\t\tString name = element.getAttribute(\"name\");\r\n\t\t\tString type = element.getAttribute(\"type\");\r\n\t\t\tif (name!=null){\r\n\t\t\t\tif (useHierarchy){\r\n\t\t\t\t\tname = removeLeadingOffset(name, stripOffset);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tStringTokenizer tok = new StringTokenizer(name, \"/\");\r\n\t\t\t        while (tok.hasMoreTokens()) {\r\n\t\t\t            name = tok.nextToken();\r\n\t\t\t        }\r\n\t\t\t\t}\r\n\t\t\t\tif (\"collection\".equals(type)){\r\n\t\t\t\t\tname += \"/\"; \r\n\t\t\t\t}\r\n\t\t\t\tObject entry = newEntry(name);\r\n\t\t\t\tputEntry(os, entry);\r\n\t\t\t\tif (element.getChildNodes().getLength()>1){\r\n\t\t\t\t\tthrow new XPathException(this, \"Entry content is not valid XML fragment.\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!name.endsWith(\"/\")){\r\n\t\t\t\t\t\tbyte[] value;\r\n\t\t\t\t\t\tNode content = element.getFirstChild();\r\n\t\t\t\t\t\tif (content==null){\r\n\t\t\t\t\t\t\tvalue=new byte[0];\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (content.getNodeType() == Node.TEXT_NODE){\r\n\t\t\t\t\t\t\t\tString text = content.getNodeValue();\r\n\t\t\t\t\t\t\t\tBase64Decoder dec = new Base64Decoder();\r\n\t\t\t\t\t\t\t\tif (\"binary\".equals(type)){\r\n\t\t\t\t\t\t\t\t\tdec.translate(text);\r\n\t\t\t\t\t\t\t\t\tvalue = dec.getByteArray();\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tvalue = text.getBytes();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tSerializer serializer = context.getBroker().getSerializer();\r\n\t\t\t\t\t\t\t\tserializer.setUser(context.getUser());\r\n\t\t\t\t\t\t\t\tserializer.setProperty(\"omit-xml-declaration\", \"no\");\r\n\t\t\t\t\t\t\t\tvalue = serializer.serialize((NodeValue) content).getBytes();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tos.write(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcloseEntry(os);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new XPathException(this, \"Entry must have name attribute.\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthrow new XPathException(this, \"Item must be type of xs:anyURI or element enry.\");\r\n\t\t}\r\n\t}","id":34343,"modified_method":"/**\r\n\t * Adds a element to a archive\r\n\t * \r\n\t * @param os\r\n\t *            The Output Stream to add the element to\r\n\t * @param nodeValue\r\n\t *            The element to add to the archive\r\n\t * @param useHierarchy\r\n\t *            Whether to use a folder hierarchy in the archive file that\r\n\t *            reflects the collection hierarchy\r\n\t */\r\n\tprivate void compressElement(OutputStream os, Element element, boolean useHierarchy, String stripOffset) throws XPathException\r\n        {\r\n\r\n            if(!(element.getNodeName().equals(\"entry\") || element.getNamespaceURI().length() > 0))\r\n                throw new XPathException(this, \"Item must be type of xs:anyURI or element enry.\");\r\n\r\n            if(element.getChildNodes().getLength() > 1)\r\n                throw new XPathException(this, \"Entry content is not valid XML fragment.\");\r\n\r\n            String name = element.getAttribute(\"name\");\r\n            if(name == null)\r\n                throw new XPathException(this, \"Entry must have name attribute.\");\r\n\r\n            String type = element.getAttribute(\"type\");\r\n\r\n            if(\"uri\".equals(type))\r\n            {\r\n                compressFromUri(os, XmldbURI.create(element.getFirstChild().getNodeValue()), useHierarchy, stripOffset, name);\r\n                return;\r\n            }\r\n\r\n            if(useHierarchy)\r\n            {\r\n                name = removeLeadingOffset(name, stripOffset);\r\n            }\r\n            else\r\n            {\r\n                name = name.substring(name.lastIndexOf(\"/\") + 1);\r\n            }\r\n\r\n            if(\"collection\".equals(type))\r\n                name += \"/\";\r\n            \r\n            Object entry = null;\r\n\r\n            try\r\n            {\r\n                entry = newEntry(name);\r\n                putEntry(os, entry);\r\n\r\n                if(!\"collection\".equals(type))\r\n                {\r\n                    byte[] value;\r\n                    Node content = element.getFirstChild();\r\n\r\n\r\n                    if(content == null)\r\n                    {\r\n                        value = new byte[0];\r\n                    }\r\n                    else\r\n                    {\r\n                        if(content.getNodeType() == Node.TEXT_NODE)\r\n                        {\r\n                            String text = content.getNodeValue();\r\n                            Base64Decoder dec = new Base64Decoder();\r\n                            if(\"binary\".equals(type))\r\n                            {\r\n                                //base64 binary\r\n                                dec.translate(text);\r\n                                value = dec.getByteArray();\r\n                            }\r\n                            else\r\n                            {\r\n                                //text\r\n                                value = text.getBytes();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            //xml\r\n                            Serializer serializer = context.getBroker().getSerializer();\r\n                            serializer.setUser(context.getUser());\r\n                            serializer.setProperty(\"omit-xml-declaration\", \"no\");\r\n                            value = serializer.serialize((NodeValue) content).getBytes();\r\n                        }\r\n                    }\r\n\r\n                    os.write(value);\r\n                }\r\n            }\r\n            catch(IOException ioe)\r\n            {\r\n                throw new XPathException(this, ioe.getMessage(), ioe);\r\n            }\r\n            catch(SAXException saxe)\r\n            {\r\n                throw new XPathException(this, saxe.getMessage(), saxe);\r\n            }\r\n            finally\r\n            {\r\n                if(entry != null)\r\n                    try\r\n                    {\r\n                        closeEntry(os);\r\n                    }\r\n                    catch(IOException ioe)\r\n                    {\r\n                        throw new XPathException(this, ioe.getMessage(), ioe);\r\n                    }\r\n            }\r\n\t}","commit_id":"6e79313fc508f7e22b31db7fc07ef395d60aaf93","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\r\n\t\t\tthrows XPathException {\r\n\t\t// are there some uri's to tar?\r\n\t\tif (args[0].isEmpty()) {\r\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\r\n\t\t}\r\n\r\n\t\t// use a hierarchy in the tar file?\r\n\t\tboolean useHierarchy = args[1].effectiveBooleanValue();\r\n\r\n\t\t// Get offset\r\n\t\tString stripOffset = \"\";\r\n\t\tif (args.length == 3) {\r\n\t\t\tstripOffset = args[2].getStringValue();\r\n\t\t}\r\n\r\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\t\tOutputStream os = stream(baos);\r\n\r\n\t\t// iterate through the argument sequence\r\n\t\tfor (SequenceIterator i = args[0].iterate(); i.hasNext();) {\r\n\t\t\tItem item = i.nextItem();\r\n\t\t\tDocumentImpl doc = null;\r\n\t\t\ttry {\r\n\t\t\t\tif (item instanceof Element){\r\n\t\t\t\t\tElement element = (Element) item; \r\n\t\t\t\t\tcompressElement(os, element, useHierarchy, stripOffset);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tAnyURIValue uri = (AnyURIValue) item;\r\n\t\t\t\t\t// try for a doc\r\n\t\t\t\t\tdoc = context.getBroker().getXMLResource(uri.toXmldbURI(),\r\n\t\t\t\t\t\t\tLock.READ_LOCK);\r\n\t\t\t\t\tif (doc == null) {\r\n\t\t\t\t\t\t// no doc, try for a collection\r\n\t\t\t\t\t\tCollection col = context.getBroker().getCollection(\r\n\t\t\t\t\t\t\t\turi.toXmldbURI());\r\n\t\t\t\t\t\tif (col != null) {\r\n\t\t\t\t\t\t\t// got a collection\r\n\t\t\t\t\t\t\tcompressCollection(os, col, useHierarchy, stripOffset);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// no doc or collection\r\n\t\t\t\t\t\t\tthrow new XPathException(this, \"Invalid URI: \" + uri.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// got a doc\r\n\t\t\t\t\t\tcompressResource(os, doc, useHierarchy, stripOffset);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (PermissionDeniedException pde) {\r\n\t\t\t\tthrow new XPathException(this, pde.getMessage());\r\n\t\t\t} catch (IOException ioe) {\r\n\t\t\t\tthrow new XPathException(this, ioe.getMessage());\r\n\t\t\t} catch (SAXException se) {\r\n\t\t\t\tthrow new XPathException(this, se.getMessage());\r\n\t\t\t} catch (LockException le) {\r\n\t\t\t\tthrow new XPathException(this, le.getMessage());\r\n\t\t\t} finally {\r\n\t\t\t\tif (doc != null) {\r\n\t\t\t\t\tdoc.getUpdateLock().release(Lock.READ_LOCK);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tos.close();\r\n\t\t} catch (IOException ioe) {\r\n\t\t\tthrow new XPathException(this, ioe.getMessage());\r\n\t\t}\r\n\t\treturn new Base64Binary(baos.toByteArray());\r\n\t}","id":34344,"modified_method":"@Override\r\n    public Sequence eval(Sequence[] args, Sequence contextSequence)\r\n\t\t\tthrows XPathException {\r\n\t\t// are there some uri's to tar?\r\n\t\tif (args[0].isEmpty()) {\r\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\r\n\t\t}\r\n\r\n\t\t// use a hierarchy in the tar file?\r\n\t\tboolean useHierarchy = args[1].effectiveBooleanValue();\r\n\r\n\t\t// Get offset\r\n\t\tString stripOffset = \"\";\r\n\t\tif (args.length == 3) {\r\n\t\t\tstripOffset = args[2].getStringValue();\r\n\t\t}\r\n\r\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\t\tOutputStream os = stream(baos);\r\n\r\n\t\t// iterate through the argument sequence\r\n\t\tfor (SequenceIterator i = args[0].iterate(); i.hasNext();) {\r\n\t\t\tItem item = i.nextItem();\r\n\t\t\t\r\n                        if(item instanceof Element)\r\n                        {\r\n                            Element element = (Element) item;\r\n                            compressElement(os, element, useHierarchy, stripOffset);\r\n                        }\r\n                        else\r\n                        {\r\n                            compressFromUri(os, ((AnyURIValue)item).toXmldbURI(), useHierarchy, stripOffset, null);\r\n                        }\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tos.close();\r\n\t\t} catch (IOException ioe) {\r\n\t\t\tthrow new XPathException(this, ioe.getMessage());\r\n\t\t}\r\n\t\treturn new Base64Binary(baos.toByteArray());\r\n\t}","commit_id":"6e79313fc508f7e22b31db7fc07ef395d60aaf93","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\r\n\t * Adds a document to a archive\r\n\t * \r\n\t * @param os\r\n\t *            The Output Stream to add the document to\r\n\t * @param doc\r\n\t *            The document to add to the archive\r\n\t * @param useHierarchy\r\n\t *            Whether to use a folder hierarchy in the archive file that\r\n\t *            reflects the collection hierarchy\r\n\t */\r\n\tprivate void compressResource(OutputStream os, DocumentImpl doc, boolean useHierarchy, String stripOffset) throws IOException, SAXException {\r\n\t\t// create an entry in the Tar for the document\r\n\t\tObject entry = null;\r\n\t\tif (useHierarchy) {\r\n\t\t\tString docCollection = doc.getCollection().getURI().toString();\r\n\t\t\tXmldbURI collection = XmldbURI.create(removeLeadingOffset(docCollection, stripOffset));\r\n\t\t\tentry = newEntry(collection.append(doc.getFileURI()).toString());\r\n\t\t} else {\r\n\t\t\tentry = newEntry(doc.getFileURI().toString());\r\n\t\t}\r\n\t\tputEntry(os, entry);\r\n\t\tif (doc.getResourceType() == DocumentImpl.XML_FILE) {\r\n\t\t\t// xml file\r\n\t\t\tSerializer serializer = context.getBroker().getSerializer();\r\n\t\t\tserializer.setUser(context.getUser());\r\n\t\t\tserializer.setProperty(\"omit-xml-declaration\", \"no\");\r\n\t\t\tString strDoc = serializer.serialize(doc);\r\n\t\t\tos.write(strDoc.getBytes());\r\n\t\t} else if (doc.getResourceType() == DocumentImpl.BINARY_FILE) {\r\n\t\t\t// binary file\r\n            InputStream is = context.getBroker().getBinaryResource((BinaryDocument)doc);\r\n\t\t\tbyte[] data = new byte[16384];\r\n            int len = 0;\r\n            while ((len=is.read(data,0,data.length))>0) {\r\n            \tos.write(data,0,len);\r\n            }\r\n            is.close();\r\n\t\t}\r\n\t\t// close the entry\r\n\t\tcloseEntry(os);\r\n\t}","id":34345,"modified_method":"/**\r\n\t * Adds a document to a archive\r\n\t * \r\n\t * @param os\r\n\t *            The Output Stream to add the document to\r\n\t * @param doc\r\n\t *            The document to add to the archive\r\n\t * @param useHierarchy\r\n\t *            Whether to use a folder hierarchy in the archive file that\r\n\t *            reflects the collection hierarchy\r\n\t */\r\n\tprivate void compressResource(OutputStream os, DocumentImpl doc, boolean useHierarchy, String stripOffset, String name) throws IOException, SAXException {\r\n\t\t// create an entry in the Tar for the document\r\n\t\tObject entry = null;\r\n                if(name != null)\r\n                {\r\n                    entry = newEntry(name);\r\n                }\r\n                else if (useHierarchy) {\r\n\t\t\tString docCollection = doc.getCollection().getURI().toString();\r\n\t\t\tXmldbURI collection = XmldbURI.create(removeLeadingOffset(docCollection, stripOffset));\r\n\t\t\tentry = newEntry(collection.append(doc.getFileURI()).toString());\r\n\t\t} else {\r\n\t\t\tentry = newEntry(doc.getFileURI().toString());\r\n\t\t}\r\n\t\tputEntry(os, entry);\r\n\t\tif (doc.getResourceType() == DocumentImpl.XML_FILE) {\r\n\t\t\t// xml file\r\n\t\t\tSerializer serializer = context.getBroker().getSerializer();\r\n\t\t\tserializer.setUser(context.getUser());\r\n\t\t\tserializer.setProperty(\"omit-xml-declaration\", \"no\");\r\n\t\t\tString strDoc = serializer.serialize(doc);\r\n\t\t\tos.write(strDoc.getBytes());\r\n\t\t} else if (doc.getResourceType() == DocumentImpl.BINARY_FILE) {\r\n\t\t\t// binary file\r\n            InputStream is = context.getBroker().getBinaryResource((BinaryDocument)doc);\r\n\t\t\tbyte[] data = new byte[16384];\r\n            int len = 0;\r\n            while ((len=is.read(data,0,data.length))>0) {\r\n            \tos.write(data,0,len);\r\n            }\r\n            is.close();\r\n\t\t}\r\n\t\t// close the entry\r\n\t\tcloseEntry(os);\r\n\t}","commit_id":"6e79313fc508f7e22b31db7fc07ef395d60aaf93","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean hasChild() {\r\n            final String c = record.get(\"child\");\r\n            if (c == null) return false;\r\n            final byte[] subject = Base64Order.enhancedCoder.decode(c);\r\n            return (subject != null);\r\n        }","id":34346,"modified_method":"public boolean hasChild() {\r\n            final String c = record.get(\"child\");\r\n            return (c != null && Base64Order.enhancedCoder.decode(c) != null) ? true : false;\r\n        }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"entry read(String key, final MapHeap base) {\r\n        try {\r\n            key = normalize(key);\r\n            if (key.length() > keyLength) key = key.substring(0, keyLength);\r\n            final Map<String, String> record = base.get(key.getBytes());\r\n            if (record == null) return newEntry(key, \"anonymous\", \"127.0.0.1\", \"New Page\", \"\".getBytes());\r\n            return new entry(key, record);\r\n        } catch (final IOException e) {\r\n            Log.logException(e);\r\n            return null;\r\n        } catch (RowSpaceExceededException e) {\r\n            Log.logException(e);\r\n            return null;\r\n        }\r\n    }","id":34347,"modified_method":"entry read(String key, final MapHeap base) {\r\n        entry ret = null;\r\n        try {\r\n            key = normalize(key);\r\n            if (key.length() > keyLength) {\r\n                key = key.substring(0, keyLength);\r\n            }\r\n            final Map<String, String> record = base.get(key.getBytes());\r\n            ret = (record == null) ? newEntry(key, ANONYMOUS, \"127.0.0.1\", \"New Page\", \"\".getBytes()) : new entry(key, record);\r\n        } catch (final IOException e) {\r\n            Log.logException(e);\r\n        } catch (RowSpaceExceededException e) {\r\n            Log.logException(e);\r\n        }\r\n        return ret;\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public entry getAncestor() {\r\n            final Date ancDate = getAncestorDate();\r\n            if (ancDate == null) return null;\r\n            return read(key + dateString(ancDate), bkpbase);\r\n        }","id":34348,"modified_method":"public entry getAncestor() {\r\n            final Date ancDate = getAncestorDate();\r\n            return (ancDate == null) ? null : read(key + dateString(ancDate), bkpbase);\r\n        }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public entry(final String subject, String author, String ip, String reason, final byte[] page) throws IOException {\r\n            record = new HashMap<String, String>();\r\n            key = subject;\r\n            if (key.length() > keyLength) key = key.substring(0, keyLength);\r\n            record.put(\"date\", dateString());\r\n            if ((author == null) || (author.length() == 0)) author = \"anonymous\";\r\n            record.put(\"author\", Base64Order.enhancedCoder.encode(author.getBytes(\"UTF-8\")));\r\n            if ((ip == null) || (ip.length() == 0)) ip = \"\";\r\n            record.put(\"ip\", ip);\r\n            if ((reason == null) || (reason.length() == 0)) reason = \"\";\r\n            record.put(\"reason\", Base64Order.enhancedCoder.encode(reason.getBytes(\"UTF-8\")));\r\n            if (page == null)\r\n                record.put(\"page\", \"\");\r\n            else\r\n                record.put(\"page\", Base64Order.enhancedCoder.encode(page));\r\n            authors.put(ip, author);\r\n            //System.out.println(\"DEBUG: setting author \" + author + \" for ip = \" + ip + \", authors = \" + authors.toString());\r\n        }","id":34349,"modified_method":"public entry(final String subject, String author, String ip, String reason, final byte[] page) throws IOException {\r\n            record = new HashMap<String, String>();\r\n            key = subject;\r\n            if (key.length() > keyLength) {\r\n                key = key.substring(0, keyLength);\r\n            }\r\n            record.put(\"date\", dateString());\r\n            if ((author == null) || (author.length() == 0)) {\r\n                author = ANONYMOUS;\r\n            }\r\n            record.put(\"author\", Base64Order.enhancedCoder.encode(author.getBytes(\"UTF-8\")));\r\n            if ((ip == null) || (ip.length() == 0)) {\r\n                ip = \"\";\r\n            }\r\n            record.put(\"ip\", ip);\r\n            if ((reason == null) || (reason.length() == 0)) {\r\n                reason = \"\";\r\n            }\r\n            record.put(\"reason\", Base64Order.enhancedCoder.encode(reason.getBytes(\"UTF-8\")));\r\n            if (page == null) {\r\n                record.put(\"page\", \"\");\r\n            } else {\r\n                record.put(\"page\", Base64Order.enhancedCoder.encode(page));\r\n            }\r\n            authors.put(ip, author);\r\n            //System.out.println(\"DEBUG: setting author \" + author + \" for ip = \" + ip + \", authors = \" + authors.toString());\r\n        }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public wikiBoard( final File actpath, final File bkppath) throws IOException {\r\n        new File(actpath.getParent()).mkdirs();\r\n        if (datbase == null) {\r\n            //datbase = new MapView(BLOBTree.toHeap(actpath, true, true, keyLength, recordSize, '_', NaturalOrder.naturalOrder, actpathNew), 500, '_');\r\n            datbase = new MapHeap(actpath, keyLength, NaturalOrder.naturalOrder, 1024 * 64, 500, '_');\r\n        }\r\n        new File(bkppath.getParent()).mkdirs();\r\n        if (bkpbase == null) {\r\n            //bkpbase = new MapView(BLOBTree.toHeap(bkppath, true, true, keyLength + dateFormat.length(), recordSize, '_', NaturalOrder.naturalOrder, bkppathNew), 500, '_');\r\n            bkpbase = new MapHeap(bkppath, keyLength + dateFormat.length(), NaturalOrder.naturalOrder, 1024 * 64, 500, '_');\r\n        }\r\n    }","id":34350,"modified_method":"public wikiBoard( final File actpath, final File bkppath) throws IOException {\r\n        new File(actpath.getParent()).mkdirs();\r\n        if (datbase == null) {\r\n            //datbase = new MapView(BLOBTree.toHeap(actpath, true, true, keyLength, recordSize, '_', NaturalOrder.naturalOrder, actpathNew), 500, '_');\r\n            datbase = new MapHeap(actpath, keyLength, NaturalOrder.naturalOrder, 1024 * 64, 500, '_');\r\n        }\r\n        new File(bkppath.getParent()).mkdirs();\r\n        if (bkpbase == null) {\r\n            //bkpbase = new MapView(BLOBTree.toHeap(bkppath, true, true, keyLength + dateFormat.length(), recordSize, '_', NaturalOrder.naturalOrder, bkppathNew), 500, '_');\r\n            bkpbase = new MapHeap(bkppath, keyLength + DATE_FORMAT.length(), NaturalOrder.naturalOrder, 1024 * 64, 500, '_');\r\n        }\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private String getChildName() {\r\n            final String c = record.get(\"child\");\r\n            if (c == null) return null;\r\n            final byte[] subject = Base64Order.enhancedCoder.decode(c);\r\n            if (subject == null) return null;\r\n            return new String(subject);\r\n        }","id":34351,"modified_method":"private String getChildName() {\r\n            final String c = record.get(\"child\");\r\n            final byte[] subject;\r\n            return (c != null && (subject = Base64Order.enhancedCoder.decode(c)) != null) ? new String(subject) : null;\r\n        }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static String normalize(final String key) {\r\n        if (key == null) return \"null\";\r\n        return key.trim().toLowerCase();\r\n    }","id":34352,"modified_method":"private static String normalize(final String key) {\r\n        return (key != null) ? key.trim().toLowerCase() : \"null\";\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public String author() {\r\n            final String a = record.get(\"author\");\r\n            if (a == null) return \"anonymous\";\r\n            final byte[] b = Base64Order.enhancedCoder.decode(a);\r\n            if (b == null) return \"anonymous\";\r\n            return new String(b);\r\n        }","id":34353,"modified_method":"public String author() {\r\n            final String a = record.get(\"author\");\r\n            final byte[] b;\r\n            return (a != null && (b = Base64Order.enhancedCoder.decode(a)) != null) ? new String(b) : ANONYMOUS;\r\n        }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public String write(final entry page) {\r\n        // writes a new page and returns key\r\n        try {\r\n            // first load the old page\r\n            final entry oldEntry = read(page.key);\r\n            // set the bkp date of the new page to the date of the old page\r\n            final Date oldDate = oldEntry.date();\r\n            page.setAncestorDate(oldDate);\r\n            oldEntry.setChild(page.subject());\r\n            // write the backup\r\n            //System.out.println(\"key = \" + page.key);\r\n            //System.out.println(\"oldDate = \" + oldDate);\r\n            //System.out.println(\"record = \" + oldEntry.record.toString());\r\n            bkpbase.insert((page.key + dateString(oldDate)).getBytes(), oldEntry.record);\r\n            // write the new page\r\n            datbase.insert(page.key.getBytes(), page.record);\r\n            return page.key;\r\n        } catch (final Exception e) {\r\n            Log.logException(e);\r\n            return null;\r\n        }\r\n    }","id":34354,"modified_method":"public String write(final entry page) {\r\n        // writes a new page and returns key\r\n        String ret = null;\r\n        try {\r\n            // first load the old page\r\n            final entry oldEntry = read(page.key);\r\n            // set the bkp date of the new page to the date of the old page\r\n            final Date oldDate = oldEntry.date();\r\n            page.setAncestorDate(oldDate);\r\n            oldEntry.setChild(page.subject());\r\n            // write the backup\r\n            //System.out.println(\"key = \" + page.key);\r\n            //System.out.println(\"oldDate = \" + oldDate);\r\n            //System.out.println(\"record = \" + oldEntry.record.toString());\r\n            bkpbase.insert((page.key + dateString(oldDate)).getBytes(), oldEntry.record);\r\n            // write the new page\r\n            datbase.insert(page.key.getBytes(), page.record);\r\n            ret = page.key;\r\n        } catch (final Exception e) {\r\n            Log.logException(e);\r\n        }\r\n        return ret;\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public entry getChild() {\r\n            final String childName = getChildName();\r\n            if (childName == null) return null;\r\n            return read(childName, datbase);\r\n        }","id":34355,"modified_method":"public entry getChild() {\r\n            final String childName = getChildName();\r\n            return (childName == null) ? null : read(childName, datbase);\r\n        }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static String webalize(String key) {\r\n        if (key == null) return \"null\";\r\n        key = key.trim().toLowerCase();\r\n        int p;\r\n        while ((p = key.indexOf(\" \")) >= 0)\r\n            key = key.substring(0, p) + \"%20\" + key.substring(p +1);\r\n        return key;\r\n    }","id":34356,"modified_method":"public static String webalize(final String key) {\r\n        return (key != null) ? normalize(key).replaceAll(\" \", \"%20\") : \"null\";\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public byte[] page() {\r\n            final String m = record.get(\"page\");\r\n            if (m == null) return new byte[0];\r\n            final byte[] b = Base64Order.enhancedCoder.decode(m);\r\n            if (b == null) return \"\".getBytes();\r\n            return b;\r\n        }","id":34357,"modified_method":"public byte[] page() {\r\n            final String m = record.get(\"page\");\r\n            final byte[] b;\r\n            return (m != null && (b = Base64Order.enhancedCoder.decode(m)) != null) ? b : new byte[0];\r\n        }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Processes tags which are connected to definition lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processDefinitionList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n\r\n            if (line.startsWith(defListLevel + \";\")) { //more semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                final int positionOfOpeningTag;\r\n                final int positionOfClosingTag = line.length();\r\n                final String copyOfLine = line.substring(defListLevel.length() + 1, positionOfClosingTag);\r\n                if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                    definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                    definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                    line = OPEN_DEFINITION_LIST +\r\n                            OPEN_DEFINITION_ITEM +\r\n                            definitionItem +\r\n                            CLOSE_DEFINITION_ITEM +\r\n                            OPEN_DEFINITION_DESCRIPTION +\r\n                            definitionDescription;\r\n                    processingDefList = true;\r\n                }\r\n                defListLevel += \";\";\r\n            } else if (defListLevel.length() > 0 && line.startsWith(defListLevel)) { //equal number of semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                final int positionOfOpeningTag;\r\n                final int positionOfClosingTag = line.length();\r\n                final String copyOfLine = line.substring(defListLevel.length(), positionOfClosingTag);\r\n                if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                    definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                    definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                    line = OPEN_DEFINITION_ITEM +\r\n                            definitionItem +\r\n                            CLOSE_DEFINITION_ITEM +\r\n                            OPEN_DEFINITION_DESCRIPTION +\r\n                            definitionDescription;\r\n                    processingDefList = true;\r\n                }\r\n            } else if (defListLevel.length() > 0) { //less semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                int i = defListLevel.length();\r\n                String tmp = EMPTY;\r\n                while (!line.startsWith(defListLevel.substring(0, i))) {\r\n                    tmp = CLOSE_DEFINITION_DESCRIPTION + CLOSE_DEFINITION_LIST;\r\n                    i--;\r\n                }\r\n                defListLevel = defListLevel.substring(0, i);\r\n                int positionOfOpeningTag = defListLevel.length();\r\n                final int positionOfClosingTag = line.length();\r\n                if (defListLevel.length() > 0) {\r\n                    final String copyOfLine = line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                    if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                        definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                        definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                        line = tmp + OPEN_DEFINITION_ITEM + definitionItem + CLOSE_DEFINITION_ITEM + OPEN_DEFINITION_DESCRIPTION + definitionDescription;\r\n                        processingDefList = true;\r\n                    }\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n        }\r\n        return line;\r\n    }","id":34358,"modified_method":"/**\r\n     * Processes tags which are connected to definition lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processDefinitionList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n\r\n            if (line.startsWith(defListLevel + \";\")) { //more semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                final int positionOfOpeningTag;\r\n                final int positionOfClosingTag = line.length();\r\n                final String copyOfLine = line.substring(defListLevel.length() + 1, positionOfClosingTag);\r\n                if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                    definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                    definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                    line = HTML_OPEN_DEFINITION_LIST +\r\n                            HTML_OPEN_DEFINITION_ITEM +\r\n                            definitionItem +\r\n                            HTML_CLOSE_DEFINITION_ITEM +\r\n                            HTML_OPEN_DEFINITION_DESCRIPTION +\r\n                            definitionDescription;\r\n                    processingDefList = true;\r\n                }\r\n                defListLevel += \";\";\r\n            } else if (defListLevel.length() > 0 && line.startsWith(defListLevel)) { //equal number of semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                final int positionOfOpeningTag;\r\n                final int positionOfClosingTag = line.length();\r\n                final String copyOfLine = line.substring(defListLevel.length(), positionOfClosingTag);\r\n                if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                    definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                    definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                    line = HTML_OPEN_DEFINITION_ITEM +\r\n                            definitionItem +\r\n                            HTML_CLOSE_DEFINITION_ITEM +\r\n                            HTML_OPEN_DEFINITION_DESCRIPTION +\r\n                            definitionDescription;\r\n                    processingDefList = true;\r\n                }\r\n            } else if (defListLevel.length() > 0) { //less semicolons\r\n                String definitionItem = EMPTY;\r\n                String definitionDescription = EMPTY;\r\n                int i = defListLevel.length();\r\n                String tmp = EMPTY;\r\n                while (!line.startsWith(defListLevel.substring(0, i))) {\r\n                    tmp = HTML_CLOSE_DEFINITION_DESCRIPTION + HTML_CLOSE_DEFINITION_LIST;\r\n                    i--;\r\n                }\r\n                defListLevel = defListLevel.substring(0, i);\r\n                int positionOfOpeningTag = defListLevel.length();\r\n                final int positionOfClosingTag = line.length();\r\n                if (defListLevel.length() > 0) {\r\n                    final String copyOfLine = line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                    if ((positionOfOpeningTag = copyOfLine.indexOf(\":\")) > 0) {\r\n                        definitionItem = copyOfLine.substring(0, positionOfOpeningTag);\r\n                        definitionDescription = copyOfLine.substring(positionOfOpeningTag + 1);\r\n                        line = tmp + HTML_OPEN_DEFINITION_ITEM + definitionItem + HTML_CLOSE_DEFINITION_ITEM + HTML_OPEN_DEFINITION_DESCRIPTION + definitionDescription;\r\n                        processingDefList = true;\r\n                    }\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n        }\r\n        return line;\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** Replaces wiki tags with HTML tags in one line of text.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    public String processLineOfWikiCode(String line) {\r\n        //If HTML has not bee replaced yet (can happen if method gets called in recursion), replace now!\r\n        if (!replacedHtmlAlready || preformattedSpanning) {\r\n            line = CharacterCoding.unicode2html(line, true);\r\n            replacedHtmlAlready = true;\r\n        }\r\n\r\n        //check if line contains preformatted symbols or if we are in a preformatted sequence already.\r\n        if ((line.indexOf(WIKI_OPEN_PRE_ESCAPED) >= 0) || (line.indexOf(WIKI_CLOSE_PRE_ESCAPED) >= 0) || (preformattedSpanning)) {\r\n            line = processPreformattedText(line);\r\n        } else {\r\n\r\n            //tables first -> wiki-tags in cells can be treated after that\r\n            line = processTable(line);\r\n\r\n            // format lines\r\n            if (line.length() > 0 && line.charAt(0) == WIKI_FORMATTED) {\r\n                line = \"<tt>\" + line.substring(1) + \"<\/tt>\";\r\n            }\r\n            if (line.startsWith(WIKI_HR_LINE)) {\r\n                line = \"<hr />\" + line.substring(LEN_WIKI_HR_LINE);\r\n            }\r\n\r\n            // citings contributed by [MN]\r\n            if (line.length() > 0 && line.charAt(0) == WIKI_INDENTION) {\r\n                final StringBuilder head = new StringBuilder();\r\n                final StringBuilder tail = new StringBuilder();\r\n                while (line.length() > 0 && line.charAt(0) == WIKI_INDENTION) {\r\n                    head.append(OPEN_BLOCKQUOTE);\r\n                    tail.append(CLOSE_BLOCKQUOTE);\r\n                    line = line.substring(1);\r\n                }\r\n                line = head + line + tail;\r\n            }\r\n            // end contrib [MN]\t\r\n\r\n            // format headers\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_3, \"<h4>\", \"<\/h4>\");\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_2, \"<h3>\", \"<\/h3>\");\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_1, \"<h2>\", \"<\/h2>\");\r\n\r\n            line = pairReplace(line, WIKI_EMPHASIZE_3, \"<b><i>\", \"<\/i><\/b>\");\r\n            line = pairReplace(line, WIKI_EMPHASIZE_2, \"<b>\", \"<\/b>\");\r\n            line = pairReplace(line, WIKI_EMPHASIZE_1, \"<i>\", \"<\/i>\");\r\n\r\n            line = processUnorderedList(line);\r\n            line = processOrderedList(line);\r\n            line = processDefinitionList(line);\r\n\r\n            line = processLinksAndImages(line);\r\n\r\n        }\r\n\r\n        if (!processingPreformattedText) {\r\n            replacedHtmlAlready = false;\r\n        }\r\n        if (!(line.endsWith(CLOSE_LIST_ELEMENT) || processingDefList || escape || processingPreformattedText || processingTable || processingCell)) {\r\n            line += \"<br />\";\r\n        }\r\n        return line;\r\n    }","id":34359,"modified_method":"/** Replaces wiki tags with HTML tags in one line of text.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    public String processLineOfWikiCode(String line) {\r\n        //If HTML has not bee replaced yet (can happen if method gets called in recursion), replace now!\r\n        if (!replacedHtmlAlready || preformattedSpanning) {\r\n            line = CharacterCoding.unicode2html(line, true);\r\n            replacedHtmlAlready = true;\r\n        }\r\n\r\n        //check if line contains preformatted symbols or if we are in a preformatted sequence already.\r\n        if ((line.indexOf(WIKI_OPEN_PRE_ESCAPED) >= 0) || (line.indexOf(WIKI_CLOSE_PRE_ESCAPED) >= 0) || (preformattedSpanning)) {\r\n            line = processPreformattedText(line);\r\n        } else {\r\n\r\n            //tables first -> wiki-tags in cells can be treated after that\r\n            line = processTable(line);\r\n\r\n            // format lines\r\n            if (line.length() > 0 && line.charAt(0) == WIKI_FORMATTED) {\r\n                line = \"<tt>\" + line.substring(1) + \"<\/tt>\";\r\n            }\r\n            if (line.startsWith(WIKI_HR_LINE)) {\r\n                line = \"<hr />\" + line.substring(LEN_WIKI_HR_LINE);\r\n            }\r\n\r\n            // citings contributed by [MN]\r\n            if (line.length() > 0 && line.charAt(0) == WIKI_INDENTION) {\r\n                final StringBuilder head = new StringBuilder();\r\n                final StringBuilder tail = new StringBuilder();\r\n                while (line.length() > 0 && line.charAt(0) == WIKI_INDENTION) {\r\n                    head.append(HTML_OPEN_BLOCKQUOTE);\r\n                    tail.append(HTML_CLOSE_BLOCKQUOTE);\r\n                    line = line.substring(1);\r\n                }\r\n                line = head + line + tail;\r\n            }\r\n            // end contrib [MN]\t\r\n\r\n            // format headers\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_3, \"<h4>\", \"<\/h4>\");\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_2, \"<h3>\", \"<\/h3>\");\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_1, \"<h2>\", \"<\/h2>\");\r\n\r\n            line = pairReplace(line, WIKI_EMPHASIZE_3, \"<b><i>\", \"<\/i><\/b>\");\r\n            line = pairReplace(line, WIKI_EMPHASIZE_2, \"<b>\", \"<\/b>\");\r\n            line = pairReplace(line, WIKI_EMPHASIZE_1, \"<i>\", \"<\/i>\");\r\n\r\n            line = pairReplace(line, WIKI_OPEN_STRIKE, WIKI_CLOSE_STRIKE, \"<s>\", \"<\/s>\");\r\n\r\n            line = processUnorderedList(line);\r\n            line = processOrderedList(line);\r\n            line = processDefinitionList(line);\r\n\r\n            line = processLinksAndImages(line);\r\n\r\n        }\r\n\r\n        if (!processingPreformattedText) {\r\n            replacedHtmlAlready = false;\r\n        }\r\n        if (!(line.endsWith(HTML_CLOSE_LIST_ELEMENT) || processingDefList || escape || processingPreformattedText || processingTable || processingCell)) {\r\n            line += \"<br />\";\r\n        }\r\n        return line;\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Processes tags which are connected preformatted text (&lt;pre&gt; &lt;/pre&gt;).\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processPreformattedText(String line) {\r\n        final int positionOfOpeningTag = line.indexOf(WIKI_OPEN_PRE_ESCAPED);\r\n        final int positionOfClosingTag = line.indexOf(WIKI_CLOSE_PRE_ESCAPED);\r\n        //both <pre> and <\/pre> in the same line\r\n        if ((positionOfOpeningTag >= 0) && (positionOfClosingTag > 0) && !escaped) {\r\n            if (positionOfOpeningTag < positionOfClosingTag) {\r\n                String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_PRE_ESCAPED, positionOfClosingTag) + \"<\/pre>\";\r\n                preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n                line = processLineOfWikiCode(line.substring(0, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\" + line.substring(positionOfClosingTag + LEN_WIKI_CLOSE_PRE_ESCAPED).replaceAll(\"!pre!\", \"!pre!!\"));\r\n                line = line.replaceAll(\"!pre!txt!\", preformattedText);\r\n                line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            } //handles cases like <pre><pre> <\/pre><\/pre> <pre> <\/pre> that would cause an exception otherwise\r\n            else {\r\n                processingPreformattedText = true;\r\n                final String temp1 = processLineOfWikiCode(line.substring(0, positionOfOpeningTag - 1).replaceAll(\"!tmp!\", \"!tmp!!\") + \"!tmp!txt!\");\r\n                noList = true;\r\n                final String temp2 = processLineOfWikiCode(line.substring(positionOfOpeningTag));\r\n                noList = false;\r\n                line = temp1.replaceAll(\"!tmp!txt!\", temp2);\r\n                line = line.replaceAll(\"!tmp!!\", \"!tmp!\");\r\n                processingPreformattedText = false;\r\n            }\r\n        } //start <pre>\r\n        else if ((positionOfOpeningTag >= 0) && !preformattedSpanning && !escaped) {\r\n            processingPreformattedText = true;    //prevent surplus line breaks\r\n            final StringBuilder openBlockQuoteTags = new StringBuilder();  //gets filled with <blockquote>s as needed\r\n            String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_PRE_ESCAPED);\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (line.substring(preindented, positionOfOpeningTag).charAt(0) == WIKI_INDENTION) {\r\n                preindented++;\r\n                openBlockQuoteTags.append(OPEN_BLOCKQUOTE);\r\n            }\r\n            line = processLineOfWikiCode(line.substring(preindented, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\");\r\n            line = openBlockQuoteTags + line.replaceAll(\"!pre!txt!\", preformattedText);\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            preformattedSpanning = true;\r\n        } //end <\/pre>\r\n        else if ((positionOfOpeningTag >= 0) && preformattedSpanning && !escaped) {\r\n            preformattedSpanning = false;\r\n            final StringBuilder endBlockQuoteTags = new StringBuilder(); //gets filled with <\/blockquote>s as needed\r\n            String preformattedText = line.substring(0, positionOfOpeningTag) + \"<\/pre>\";\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (preindented > 0) {\r\n                endBlockQuoteTags.append(CLOSE_BLOCKQUOTE);\r\n                preindented--;\r\n            }\r\n            line = processLineOfWikiCode(\"!pre!txt!\" + line.substring(positionOfOpeningTag + LEN_WIKI_CLOSE_PRE_ESCAPED).replaceAll(\"!pre!\", \"!pre!!\"));\r\n            line = line.replaceAll(\"!pre!txt!\", preformattedText) + endBlockQuoteTags;\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            processingPreformattedText = false;\r\n        } //Getting rid of surplus <\/pre>\r\n        else if ((positionOfOpeningTag >= 0) && !preformattedSpanning && !escaped) {\r\n            int posTag;\r\n            while ((posTag = line.indexOf(WIKI_CLOSE_PRE_ESCAPED)) >= 0) {\r\n                line = line.substring(0, posTag) + line.substring(posTag + LEN_WIKI_CLOSE_PRE_ESCAPED);\r\n            }\r\n            line = processLineOfWikiCode(line);\r\n        }\r\n        return line;\r\n    }","id":34360,"modified_method":"/**\r\n     * Processes tags which are connected preformatted text (&lt;pre&gt; &lt;/pre&gt;).\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processPreformattedText(String line) {\r\n        final int positionOfOpeningTag = line.indexOf(WIKI_OPEN_PRE_ESCAPED);\r\n        final int positionOfClosingTag = line.indexOf(WIKI_CLOSE_PRE_ESCAPED);\r\n        //both <pre> and <\/pre> in the same line\r\n        if ((positionOfOpeningTag >= 0) && (positionOfClosingTag > 0) && !escaped) {\r\n            if (positionOfOpeningTag < positionOfClosingTag) {\r\n                String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_PRE_ESCAPED, positionOfClosingTag) + \"<\/pre>\";\r\n                preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n                line = processLineOfWikiCode(line.substring(0, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\" + line.substring(positionOfClosingTag + LEN_WIKI_CLOSE_PRE_ESCAPED).replaceAll(\"!pre!\", \"!pre!!\"));\r\n                line = line.replaceAll(\"!pre!txt!\", preformattedText);\r\n                line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            } //handles cases like <pre><pre> <\/pre><\/pre> <pre> <\/pre> that would cause an exception otherwise\r\n            else {\r\n                processingPreformattedText = true;\r\n                final String temp1 = processLineOfWikiCode(line.substring(0, positionOfOpeningTag - 1).replaceAll(\"!tmp!\", \"!tmp!!\") + \"!tmp!txt!\");\r\n                noList = true;\r\n                final String temp2 = processLineOfWikiCode(line.substring(positionOfOpeningTag));\r\n                noList = false;\r\n                line = temp1.replaceAll(\"!tmp!txt!\", temp2);\r\n                line = line.replaceAll(\"!tmp!!\", \"!tmp!\");\r\n                processingPreformattedText = false;\r\n            }\r\n        } //start <pre>\r\n        else if ((positionOfOpeningTag >= 0) && !preformattedSpanning && !escaped) {\r\n            processingPreformattedText = true;    //prevent surplus line breaks\r\n            final StringBuilder openBlockQuoteTags = new StringBuilder();  //gets filled with <blockquote>s as needed\r\n            String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_PRE_ESCAPED);\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (line.substring(preindented, positionOfOpeningTag).charAt(0) == WIKI_INDENTION) {\r\n                preindented++;\r\n                openBlockQuoteTags.append(HTML_OPEN_BLOCKQUOTE);\r\n            }\r\n            line = processLineOfWikiCode(line.substring(preindented, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\");\r\n            line = openBlockQuoteTags + line.replaceAll(\"!pre!txt!\", preformattedText);\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            preformattedSpanning = true;\r\n        } //end <\/pre>\r\n        else if ((positionOfOpeningTag >= 0) && preformattedSpanning && !escaped) {\r\n            preformattedSpanning = false;\r\n            final StringBuilder endBlockQuoteTags = new StringBuilder(); //gets filled with <\/blockquote>s as needed\r\n            String preformattedText = line.substring(0, positionOfOpeningTag) + \"<\/pre>\";\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (preindented > 0) {\r\n                endBlockQuoteTags.append(HTML_CLOSE_BLOCKQUOTE);\r\n                preindented--;\r\n            }\r\n            line = processLineOfWikiCode(\"!pre!txt!\" + line.substring(positionOfOpeningTag + LEN_WIKI_CLOSE_PRE_ESCAPED).replaceAll(\"!pre!\", \"!pre!!\"));\r\n            line = line.replaceAll(\"!pre!txt!\", preformattedText) + endBlockQuoteTags;\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            processingPreformattedText = false;\r\n        } //Getting rid of surplus <\/pre>\r\n        else if ((positionOfOpeningTag >= 0) && !preformattedSpanning && !escaped) {\r\n            int posTag;\r\n            while ((posTag = line.indexOf(WIKI_CLOSE_PRE_ESCAPED)) >= 0) {\r\n                line = line.substring(0, posTag) + line.substring(posTag + LEN_WIKI_CLOSE_PRE_ESCAPED);\r\n            }\r\n            line = processLineOfWikiCode(line);\r\n        }\r\n        return line;\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** Replaces two occurences of a substring in a string by a pair of strings if \r\n     * that substring occurs twice in the string. This method is not greedy! You'll\r\n     * have to run it in a loop if you want to replace all occurences of the substring.\r\n     * This method provides special treatment for headlines.\r\n     * @param input the string that something is to be replaced in\r\n     * @param pat substring to be replaced\r\n     * @param repl1 string substring gets replaced by on uneven occurences\r\n     * @param repl2 string substring gets replaced by on even occurences\r\n     */\r\n    //[MN]\r\n    private String pairReplace(String input, final String pat, final String repl1, final String repl2) {\r\n        String direlem = null;    //string to keep headlines until they get added to List dirElements\r\n        int firstPosition;\r\n        final int secondPosition;\r\n        final int strLen = pat.length();\r\n        //replace pattern if a pair of the pattern can be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && ((secondPosition = input.indexOf(pat, firstPosition + strLen)) >= 0)) {\r\n            //extra treatment for headlines\r\n            if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                //add anchor and create headline\r\n                direlem = input.substring(firstPosition + strLen, secondPosition);\r\n                if (direlem != null) {\r\n                    //counting double headlines\r\n                    int doubles = 0;\r\n                    for (int i = 0; i < tableOfContentElements.size(); i++) {\r\n                        // no element with null value should ever be in directory\r\n                        assert (tableOfContentElements.get(i) != null);\r\n\r\n                        if (tableOfContentElements.size() > i && tableOfContentElements.get(i).substring(1).equals(direlem)) {\r\n                            doubles++;\r\n                        }\r\n                    }\r\n                    String anchor = direlem.replaceAll(\" \", \"_\").replaceAll(REGEX_NOT_CHAR_NUM_OR_UNDERSCORE, EMPTY); //replace blanks with underscores and delete everything thats not a regular character, a number or _\r\n                    //if there are doubles, add underscore and number of doubles plus one\r\n                    if (doubles > 0) {\r\n                        anchor = anchor + \"_\" + (doubles + 1);\r\n                    }\r\n                    input = input.substring(0, firstPosition) + \"<a name=\\\"\" + anchor + \"\\\"><\/a>\" + repl1\r\n                            + direlem + repl2 + input.substring(secondPosition + strLen);\r\n                    //add headlines to list of headlines (so TOC can be created)\r\n                    if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                        tableOfContentElements.add((pat.length() - 1) + direlem);\r\n                    }\r\n                }\r\n            } else {\r\n                input = input.substring(0, firstPosition) + repl1\r\n                        + (input.substring(firstPosition + strLen, secondPosition)) + repl2\r\n                        + input.substring(secondPosition + strLen);\r\n            }\r\n        }\r\n        //recursion if another pair of the pattern can still be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && (input.indexOf(pat, firstPosition + strLen) >= 0)) {\r\n            input = pairReplace(input, pat, repl1, repl2);\r\n        }\r\n        return input;\r\n    }","id":34361,"modified_method":"/** Replaces two occurences of a substring in a string by a pair of strings if \r\n     * that substring occurs twice in the string. This method is not greedy! You'll\r\n     * have to run it in a loop if you want to replace all occurences of the substring.\r\n     * This method provides special treatment for headlines.\r\n     * @param input the string that something is to be replaced in\r\n     * @param pat substring to be replaced\r\n     * @param repl1 string substring gets replaced by on uneven occurences\r\n     * @param repl2 string substring gets replaced by on even occurences\r\n     */\r\n    //[MN]\r\n    private String pairReplace(String input, final String pat, final String repl1, final String repl2) {\r\n        return pairReplace(input, pat, pat, repl1, repl2);\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Processes tags which are connected to ordered lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processOrderedList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n\r\n            //# sorted Lists contributed by [AS]\r\n            //## Sublist\r\n            if (line.startsWith(numberedListLevel + \"#\")) { //more #\r\n                line = OPEN_ORDERED_LIST + serverCore.CRLF_STRING\r\n                        + OPEN_LIST_ELEMENT\r\n                        + line.substring(numberedListLevel.length() + 1, line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n                numberedListLevel += \"#\";\r\n            } else if (numberedListLevel.length() > 0 && line.startsWith(numberedListLevel)) { //equal number of #\r\n                line = OPEN_LIST_ELEMENT\r\n                        + line.substring(numberedListLevel.length(), line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n            } else if (numberedListLevel.length() > 0) { //less #\r\n                int i = numberedListLevel.length();\r\n                String tmp = EMPTY;\r\n\r\n                while (!line.startsWith(numberedListLevel.substring(0, i))) {\r\n                    tmp += CLOSE_ORDERED_LIST;\r\n                    i--;\r\n                }\r\n                numberedListLevel = numberedListLevel.substring(0, i);\r\n                final int positionOfOpeningTag = numberedListLevel.length();\r\n                final int positionOfClosingTag = line.length();\r\n\r\n                if (numberedListLevel.length() > 0) {\r\n                    line = tmp\r\n                            + OPEN_LIST_ELEMENT\r\n                            + line.substring(positionOfOpeningTag, positionOfClosingTag)\r\n                            + CLOSE_LIST_ELEMENT;\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n            // end contrib [AS]\r\n        }\r\n        return line;\r\n    }","id":34362,"modified_method":"/**\r\n     * Processes tags which are connected to ordered lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processOrderedList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n\r\n            //# sorted Lists contributed by [AS]\r\n            //## Sublist\r\n            if (line.startsWith(numberedListLevel + \"#\")) { //more #\r\n                line = HTML_OPEN_ORDERED_LIST + serverCore.CRLF_STRING\r\n                        + HTML_OPEN_LIST_ELEMENT\r\n                        + line.substring(numberedListLevel.length() + 1, line.length())\r\n                        + HTML_CLOSE_LIST_ELEMENT;\r\n                numberedListLevel += \"#\";\r\n            } else if (numberedListLevel.length() > 0 && line.startsWith(numberedListLevel)) { //equal number of #\r\n                line = HTML_OPEN_LIST_ELEMENT\r\n                        + line.substring(numberedListLevel.length(), line.length())\r\n                        + HTML_CLOSE_LIST_ELEMENT;\r\n            } else if (numberedListLevel.length() > 0) { //less #\r\n                int i = numberedListLevel.length();\r\n                String tmp = EMPTY;\r\n\r\n                while (!line.startsWith(numberedListLevel.substring(0, i))) {\r\n                    tmp += HTML_CLOSE_ORDERED_LIST;\r\n                    i--;\r\n                }\r\n                numberedListLevel = numberedListLevel.substring(0, i);\r\n                final int positionOfOpeningTag = numberedListLevel.length();\r\n                final int positionOfClosingTag = line.length();\r\n\r\n                if (numberedListLevel.length() > 0) {\r\n                    line = tmp\r\n                            + HTML_OPEN_LIST_ELEMENT\r\n                            + line.substring(positionOfOpeningTag, positionOfClosingTag)\r\n                            + HTML_CLOSE_LIST_ELEMENT;\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n            // end contrib [AS]\r\n        }\r\n        return line;\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Processes tags which are connected to unordered lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processUnorderedList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n            //contributed by [AS]\r\n            if (line.startsWith(unorderedListLevel + ASTERISK)) { //more stars\r\n                line = OPEN_UNORDERED_LIST + serverCore.CRLF_STRING\r\n                        + OPEN_LIST_ELEMENT\r\n                        + line.substring(unorderedListLevel.length() + 1, line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n                unorderedListLevel += ASTERISK;\r\n            } else if (unorderedListLevel.length() > 0 && line.startsWith(unorderedListLevel)) { //equal number of stars\r\n                line = OPEN_LIST_ELEMENT\r\n                        + line.substring(unorderedListLevel.length(), line.length())\r\n                        + CLOSE_LIST_ELEMENT;\r\n            } else if (unorderedListLevel.length() > 0) { //less stars\r\n                int i = unorderedListLevel.length();\r\n                String tmp = EMPTY;\r\n\r\n                while (unorderedListLevel.length() >= i && !line.startsWith(unorderedListLevel.substring(0, i))) {\r\n                    tmp += CLOSE_UNORDERED_LIST;\r\n                    i--;\r\n                }\r\n                int positionOfOpeningTag = unorderedListLevel.length();\r\n                if (i < positionOfOpeningTag) {\r\n                    unorderedListLevel = unorderedListLevel.substring(0, i);\r\n                    positionOfOpeningTag = unorderedListLevel.length();\r\n                }\r\n                final int positionOfClosingTag = line.length();\r\n\r\n                if (unorderedListLevel.length() > 0) {\r\n                    line = tmp\r\n                            + OPEN_LIST_ELEMENT\r\n                            + line.substring(positionOfOpeningTag, positionOfClosingTag)\r\n                            + CLOSE_LIST_ELEMENT;\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n            //end contrib [AS]\r\n        }\r\n        return line;\r\n    }","id":34363,"modified_method":"/**\r\n     * Processes tags which are connected to unordered lists.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processUnorderedList(String line) {\r\n        if (!noList) {    //lists only get processed if not forbidden (see code for [= and <pre>). [MN]\r\n            //contributed by [AS]\r\n            if (line.startsWith(unorderedListLevel + ASTERISK)) { //more stars\r\n                line = HTML_OPEN_UNORDERED_LIST + serverCore.CRLF_STRING\r\n                        + HTML_OPEN_LIST_ELEMENT\r\n                        + line.substring(unorderedListLevel.length() + 1, line.length())\r\n                        + HTML_CLOSE_LIST_ELEMENT;\r\n                unorderedListLevel += ASTERISK;\r\n            } else if (unorderedListLevel.length() > 0 && line.startsWith(unorderedListLevel)) { //equal number of stars\r\n                line = HTML_OPEN_LIST_ELEMENT\r\n                        + line.substring(unorderedListLevel.length(), line.length())\r\n                        + HTML_CLOSE_LIST_ELEMENT;\r\n            } else if (unorderedListLevel.length() > 0) { //less stars\r\n                int i = unorderedListLevel.length();\r\n                String tmp = EMPTY;\r\n\r\n                while (unorderedListLevel.length() >= i && !line.startsWith(unorderedListLevel.substring(0, i))) {\r\n                    tmp += HTML_CLOSE_UNORDERED_LIST;\r\n                    i--;\r\n                }\r\n                int positionOfOpeningTag = unorderedListLevel.length();\r\n                if (i < positionOfOpeningTag) {\r\n                    unorderedListLevel = unorderedListLevel.substring(0, i);\r\n                    positionOfOpeningTag = unorderedListLevel.length();\r\n                }\r\n                final int positionOfClosingTag = line.length();\r\n\r\n                if (unorderedListLevel.length() > 0) {\r\n                    line = tmp\r\n                            + HTML_OPEN_LIST_ELEMENT\r\n                            + line.substring(positionOfOpeningTag, positionOfClosingTag)\r\n                            + HTML_CLOSE_LIST_ELEMENT;\r\n                } else {\r\n                    line = tmp + line.substring(positionOfOpeningTag, positionOfClosingTag);\r\n                }\r\n            }\r\n            //end contrib [AS]\r\n        }\r\n        return line;\r\n    }","commit_id":"afa708d55237f3919523fe010c122b35492d2c6e","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void transform(XtendField source, JvmGenericType container) {\n\t\tif (source.isExtension() || source.getName() != null) {\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tfield.setSimpleName(computeFieldName(source, container));\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(source, field);\n\t\t\tfield.setVisibility(source.getVisibility());\n\t\t\tfield.setStatic(source.isStatic());\n\t\t\tfield.setFinal(source.isFinal());\n\t\t\tif (source.getType() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.cloneWithProxies(source.getType()));\n\t\t\t} else if (source.getInitialValue() != null) {\n\t\t\t\tfield.setType(getTypeProxy(source.getInitialValue()));\n\t\t\t}\n\t\t\tjvmTypesBuilder.translateAnnotationsTo(source.getAnnotationInfo().getAnnotations(), field);\n\t\t\tjvmTypesBuilder.setDocumentation(field, jvmTypesBuilder.getDocumentation(source));\n\t\t\tjvmTypesBuilder.setInitializer(field, source.getInitialValue());\n\t\t\t\n\t\t\tif (containsAnnotation(source.getAnnotations(), Property.class)) {\n\t\t\t\tfield.setSimpleName(\"_\"+field.getSimpleName());\n\t\t\t\tfinal JvmOperation getter = jvmTypesBuilder.toGetter(source, source.getName(), field.getSimpleName(), field.getType());\n\t\t\t\tjvmTypesBuilder.setDocumentation(getter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\tif (getter != null && !hasMethod((XtendClass)source.eContainer(), getter.getSimpleName(), getter.getParameters()))\n\t\t\t\t\t\tcontainer.getMembers().add( getter);\n\t\t\t\tif (!source.isFinal()) {\n\t\t\t\t\tfinal JvmOperation setter = jvmTypesBuilder.toSetter(source, source.getName(), field.getSimpleName(), field.getType());\n\t\t\t\t\tjvmTypesBuilder.setDocumentation(setter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\t\tif (setter != null && !hasMethod((XtendClass)source.eContainer(), setter.getSimpleName(), setter.getParameters()))\n\t\t\t\t\t\tcontainer.getMembers().add( setter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":34364,"modified_method":"protected void transform(XtendField source, JvmGenericType container) {\n\t\tif (source.isExtension() || source.getName() != null) {\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tfinal String computeFieldName = computeFieldName(source, container);\n\t\t\tfield.setSimpleName(computeFieldName);\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(source, field);\n\t\t\tfield.setVisibility(source.getVisibility());\n\t\t\tfield.setStatic(source.isStatic());\n\t\t\tfield.setFinal(source.isFinal());\n\t\t\tif (source.getType() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.cloneWithProxies(source.getType()));\n\t\t\t} else if (source.getInitialValue() != null) {\n\t\t\t\tfield.setType(getTypeProxy(source.getInitialValue()));\n\t\t\t}\n\t\t\t\n\t\t\tfor (XAnnotation anno : source.getAnnotations()) {\n\t\t\t\tif (anno == null || anno.getAnnotationType() == null || anno.getAnnotationType().getIdentifier() == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (Property.class.getName().equals(anno.getAnnotationType().getIdentifier())) {\n\t\t\t\t\tfield.setSimpleName(\"_\"+computeFieldName);\n\t\t\t\t\tfinal JvmOperation getter = jvmTypesBuilder.toGetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\t\tjvmTypesBuilder.setDocumentation(getter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\t\tif (getter != null && !hasMethod(container, getter.getSimpleName(), getter.getParameters()))\n\t\t\t\t\t\tcontainer.getMembers().add( getter);\n\t\t\t\t\tif (!source.isFinal()) {\n\t\t\t\t\t\tfinal JvmOperation setter = jvmTypesBuilder.toSetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\t\t\tjvmTypesBuilder.setDocumentation(setter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\t\t\tif (setter != null && !hasMethod(container, setter.getSimpleName(), setter.getParameters()))\n\t\t\t\t\t\t\tcontainer.getMembers().add( setter);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tJvmAnnotationReference annotationReference = jvmTypesBuilder.getJvmAnnotationReference(anno);\n\t\t\t\t\tif(annotationReference != null)\n\t\t\t\t\t\tfield.getAnnotations().add(annotationReference);\n\t\t\t\t}\n\t\t\t}\n\t\t\tjvmTypesBuilder.setDocumentation(field, jvmTypesBuilder.getDocumentation(source));\n\t\t\tjvmTypesBuilder.setInitializer(field, source.getInitialValue());\n\t\t\t\n\t\t}\n\t}","commit_id":"34481e04e525fcf4d40a72e404219b1023444417","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean hasMethod(XtendClass xtendClass, String simpleName, EList<JvmFormalParameter> parameters) {\n\t\tfor (XtendMember member : xtendClass.getMembers()) {\n\t\t\tif (member instanceof XtendFunction) {\n\t\t\t\tXtendFunction function = (XtendFunction) member;\n\t\t\t\tif (function.getName().equals(simpleName)) {\n\t\t\t\t\tboolean allMatched = true;\n\t\t\t\t\tif (function.getParameters().size() == parameters.size()) {\n\t\t\t\t\t\tfor (int i = 0; i < parameters.size() ; i++) {\n\t\t\t\t\t\t\tXtendParameter p1 = function.getParameters().get(i);\n\t\t\t\t\t\t\tJvmFormalParameter p2 = parameters.get(i);\n\t\t\t\t\t\t\tallMatched = allMatched && p1.getParameterType().getType() == p2.getParameterType().getType(); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (allMatched)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":34365,"modified_method":"protected boolean hasMethod(JvmGenericType clazz, String simpleName, EList<JvmFormalParameter> parameters) {\n\t\tfor (JvmOperation member : clazz.getDeclaredOperations()) {\n\t\t\tif (member.getSimpleName().equals(simpleName)) {\n\t\t\t\t// since we cannot resolve inferred type proxies here, we just check the number of arguments.\n\t\t\t\treturn member.getParameters().size() == parameters.size();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"34481e04e525fcf4d40a72e404219b1023444417","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * Return the user part of the user name (i.e. the string before the @\n     * sign).\n     *\n     * @param userName the username.\n     * @return the user part of the jabber user name.\n     */\n    public static String getUserFromUserName(String userName)\n    {\n        int delimIndex = userName.indexOf(\"@\");\n        if (delimIndex != -1)\n        {\n            return userName.substring(0, delimIndex);\n        }\n\n        return userName;\n    }","id":34366,"modified_method":"/**\n     * Return the user part of the user name (i.e. the string before the @\n     * sign).\n     *\n     * @param userName the username.\n     * @return the user part of the jabber user name.\n     */\n    public static String getUserFromUserName(String userName)\n    {\n        int delimIndex = userName.indexOf(\"@\");\n        return\n            (delimIndex == -1) ? userName : userName.substring(0, delimIndex);\n    }","commit_id":"28bbf296f790b1980738b1193776d8301b703175","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Installs the account defined in this wizard.\n     * @return the created <tt>ProtocolProviderService<\/tt> corresponding to the\n     * new account\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    @Override\n    public ProtocolProviderService signin()\n        throws OperationFailedException\n    {\n        firstWizardPage.commitPage();\n        if (firstWizardPage.isCommitted())\n        {\n            return signin(  registration.getUserID(),\n                            registration.getPassword());\n        }\n\n        return null;\n    }","id":34367,"modified_method":"/**\n     * Installs the account defined in this wizard.\n     * @return the created <tt>ProtocolProviderService<\/tt> corresponding to the\n     * new account\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    @Override\n    public ProtocolProviderService signin()\n        throws OperationFailedException\n    {\n        firstWizardPage.commitPage();\n\n        return\n            firstWizardPage.isCommitted()\n                ? signin(registration.getUserID(), registration.getPassword())\n                : null;\n    }","commit_id":"28bbf296f790b1980738b1193776d8301b703175","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Installs the account defined in this wizard.\n     *\n     * @param userName the user name to sign in with\n     * @param password the password to sign in with\n     * @return the created <tt>ProtocolProviderService<\/tt> corresponding to the\n     * new account\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    @Override\n    public ProtocolProviderService signin(String userName, String password)\n        throws OperationFailedException\n    {\n        // if firstWizardPage is null we are requested sign-in from\n        // initial account registration form we must init\n        // firstWizardPage in order to init default values\n        // Pawel: firstWizardPage is never null, and commitPage fails\n        // with no user ID provided for simple account wizard.\n        // Now userName and password are reentered here\n        AccountPanel accPanel =\n                    (AccountPanel)firstWizardPage.getSimpleForm();\n        accPanel.setUsername(userName);\n        accPanel.setPassword(password);\n        accPanel.setRememberPassword(password != null);\n\n        if(!firstWizardPage.isCommitted())\n            firstWizardPage.commitPage();\n\n        if(!firstWizardPage.isCommitted())\n            throw new OperationFailedException(\"Could not confirm data.\",\n                OperationFailedException.GENERAL_ERROR);\n\n        ProtocolProviderFactory factory\n            = JabberAccRegWizzActivator.getJabberProtocolProviderFactory();\n\n        return this.installAccount(\n            factory,\n            registration.getUserID(),  // The user id may get changed.Server\n                                       // part can be added in the data\n                                       // commit.\n            password);\n    }","id":34368,"modified_method":"/**\n     * Installs the account defined in this wizard.\n     *\n     * @param userName the user name to sign in with\n     * @param password the password to sign in with\n     * @return the created <tt>ProtocolProviderService<\/tt> corresponding to the\n     * new account\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    public ProtocolProviderService signin(\n            final String userName,\n            final String password)\n        throws OperationFailedException\n    {\n        /*\n         * If firstWizardPage is null we are requested sign-in from initial\n         * account registration form we must init firstWizardPage in order to\n         * init default values\n         * Pawel: firstWizardPage is never null, and commitPage fails with no\n         * user ID provided for simple account wizard. Now userName and password\n         * are reentered here.\n         */\n        final AccountPanel accPanel\n            = (AccountPanel) firstWizardPage.getSimpleForm();\n        /*\n         * XXX Swing is not thread safe! We've experienced deadlocks on OS X\n         * upon invoking accPanel's setters. In order to address them, (1)\n         * invoke accPanel's setters on the AWT event dispatching thread and (2)\n         * do it only if absolutely necessary.\n         */\n        String accPanelUsername = accPanel.getUsername();\n        boolean equals = false;\n        final boolean rememberPassword = (password != null);\n\n        if (StringUtils.isEquals(accPanelUsername, userName))\n        {\n            char[] accPanelPasswordChars = accPanel.getPassword();\n            char[] passwordChars\n                = (password == null) ? null : password.toCharArray();\n\n            if (accPanelPasswordChars == null)\n                equals = ((passwordChars == null) || passwordChars.length == 0);\n            else if (passwordChars == null)\n                equals = (accPanelPasswordChars.length == 0);\n            else\n                equals = Arrays.equals(accPanelPasswordChars, passwordChars);\n            if (equals)\n            {\n                boolean accPanelRememberPassword\n                    = accPanel.isRememberPassword();\n\n                equals = (accPanelRememberPassword == rememberPassword);\n            }\n        }\n        if (!equals)\n        {\n            try\n            {\n                SwingUtilities.invokeAndWait(\n                        new Runnable()\n                        {\n                            public void run()\n                            {\n                                accPanel.setUsername(userName);\n                                accPanel.setPassword(password);\n                                accPanel.setRememberPassword(rememberPassword);\n                            }\n                        });\n            }\n            catch (Exception e)\n            {\n                if (e instanceof OperationFailedException)\n                {\n                    throw (OperationFailedException) e;\n                }\n                else\n                {\n                    throw new OperationFailedException(\n                            \"Failed to set username and password on \"\n                                + accPanel.getClass().getName(),\n                            OperationFailedException.INTERNAL_ERROR,\n                            e);\n                }\n            }\n        }\n\n        if(!firstWizardPage.isCommitted())\n            firstWizardPage.commitPage();\n        if(!firstWizardPage.isCommitted())\n        {\n            throw new OperationFailedException(\n                    \"Could not confirm data.\",\n                    OperationFailedException.GENERAL_ERROR);\n        }\n\n        ProtocolProviderFactory factory\n            = JabberAccRegWizzActivator.getJabberProtocolProviderFactory();\n\n        return\n            installAccount(\n                    factory,\n                    registration.getUserID(), // The user id may get changed.\n                                              // Server part can be added in the\n                                              // data commit.\n                    password);\n    }","commit_id":"28bbf296f790b1980738b1193776d8301b703175","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    protected void doHead(SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws ServletException,\n            IOException {\n\n        // don't do nothing if the request has already been committed\n        // or this servlet is called for a servlet include\n        if (response.isCommitted()\n            || request.getAttribute(SlingConstants.ATTR_REQUEST_SERVLET) != null) {\n            return;\n        }\n\n        request = new HeadServletRequest(request);\n        response = new HeadServletResponse(response);\n\n        RequestDispatcher dispatcher = request.getRequestDispatcher(request.getResource());\n        if (dispatcher != null) {\n            dispatcher.forward(request, response);\n        }\n    }","id":34369,"modified_method":"@Override\n    protected void doHead(SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws ServletException,\n            IOException {\n\n        // don't do nothing if the request has already been committed\n        // or this servlet is called for a servlet include\n        if (response.isCommitted()) {\n            // committed response cannot be redirected\n            log.warn(\"DefaultHeadServlet: Ignoring request because response is committed\");\n            request.getRequestProgressTracker().log(\n                \"DefaultHeadServlet: Ignoring request because response is committed\");\n            return;\n        } else if (request.getAttribute(SlingConstants.ATTR_REQUEST_SERVLET) != null) {\n            // included request will not redirect\n            log.warn(\"DefaultHeadServlet: Ignoring request because request is included\");\n            request.getRequestProgressTracker().log(\n                \"DefaultHeadServlet: Ignoring request because request is included\");\n            return;\n        }\n\n        request = new HeadServletRequest(request);\n        response = new HeadServletResponse(response);\n\n        RequestDispatcher dispatcher = request.getRequestDispatcher(request.getResource());\n        if (dispatcher != null) {\n            dispatcher.forward(request, response);\n        }\n    }","commit_id":"9b5bc13ee53d4a01b80482b562799fa45384d7b3","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void doGet(SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws ServletException,\n            IOException {\n\n        // handle json export of the redirect node\n        if (JsonRendererServlet.EXT_JSON.equals(request.getRequestPathInfo().getExtension())) {\n            getJsonRendererServlet().service(request, response);\n            return;\n        }\n\n        // check for redirectability\n        if (response.isCommitted()) {\n            // committed response cannot be redirected\n            log.warn(\"doGet: Response is already committed, not redirecting\");\n            return;\n        } else if (request.getAttribute(SlingConstants.ATTR_REQUEST_SERVLET) != null) {\n            // included request will not redirect\n            log.warn(\"doGet: Servlet is included, not redirecting\");\n            return;\n        }\n\n        String targetPath = null;\n\n        // convert resource to a value map\n        final Resource rsrc = request.getResource();\n        final ValueMap valueMap = rsrc.adaptTo(ValueMap.class);\n        if (valueMap != null) {\n            targetPath = valueMap.get(TARGET_PROP, String.class);\n        }\n        if (targetPath == null) {\n            // old behaviour\n            final Resource targetResource = request.getResourceResolver().getResource(\n                rsrc, TARGET_PROP);\n            if (targetResource == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                    \"Missing target for redirection\");\n                return;\n            }\n\n            // if the target resource is a path (string), redirect there\n            targetPath = targetResource.adaptTo(String.class);\n\n        }\n\n        // if we got a target path, make it external and redirect to it\n        if (targetPath != null) {\n            if (!isUrl(targetPath)) {\n                // make path relative and append selectors, extension etc.\n                targetPath = toRedirectPath(targetPath, request);\n            }\n\n            // and redirect there ...\n            response.sendRedirect(targetPath);\n\n            return;\n        }\n\n        // no way of finding the target, just fail\n        response.sendError(HttpServletResponse.SC_NOT_FOUND,\n            \"Cannot redirect to target resource \" + targetPath);\n    }","id":34370,"modified_method":"@Override\n    protected void doGet(SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws ServletException,\n            IOException {\n\n        // handle json export of the redirect node\n        if (JsonRendererServlet.EXT_JSON.equals(request.getRequestPathInfo().getExtension())) {\n            getJsonRendererServlet().service(request, response);\n            return;\n        }\n\n        // check for redirectability\n        if (response.isCommitted()) {\n            // committed response cannot be redirected\n            log.warn(\"RedirectServlet: Response is already committed, not redirecting\");\n            request.getRequestProgressTracker().log(\n                \"RedirectServlet: Response is already committed, not redirecting\");\n            return;\n        } else if (request.getAttribute(SlingConstants.ATTR_REQUEST_SERVLET) != null) {\n            // included request will not redirect\n            log.warn(\"RedirectServlet: Servlet is included, not redirecting\");\n            request.getRequestProgressTracker().log(\n                \"RedirectServlet: Servlet is included, not redirecting\");\n            return;\n        }\n\n        String targetPath = null;\n\n        // convert resource to a value map\n        final Resource rsrc = request.getResource();\n        final ValueMap valueMap = rsrc.adaptTo(ValueMap.class);\n        if (valueMap != null) {\n            targetPath = valueMap.get(TARGET_PROP, String.class);\n        }\n        if (targetPath == null) {\n            // old behaviour\n            final Resource targetResource = request.getResourceResolver().getResource(\n                rsrc, TARGET_PROP);\n            if (targetResource == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                    \"Missing target for redirection\");\n                return;\n            }\n\n            // if the target resource is a path (string), redirect there\n            targetPath = targetResource.adaptTo(String.class);\n\n        }\n\n        // if we got a target path, make it external and redirect to it\n        if (targetPath != null) {\n            if (!isUrl(targetPath)) {\n                // make path relative and append selectors, extension etc.\n                targetPath = toRedirectPath(targetPath, request);\n            }\n\n            // and redirect there ...\n            response.sendRedirect(targetPath);\n\n            return;\n        }\n\n        // no way of finding the target, just fail\n        response.sendError(HttpServletResponse.SC_NOT_FOUND,\n            \"Cannot redirect to target resource \" + targetPath);\n    }","commit_id":"9b5bc13ee53d4a01b80482b562799fa45384d7b3","url":"https://github.com/apache/sling"},{"original_method":"Node.Children readChildren(String path, Revision rev, int limit) {\n        String from = PathUtils.concat(path, \"a\");\n        from = Utils.getIdFromPath(from);\n        from = from.substring(0, from.length() - 1);\n        String to = PathUtils.concat(path, \"z\");\n        to = Utils.getIdFromPath(to);\n        to = to.substring(0, to.length() - 2) + \"0\";\n        List<Map<String, Object>> list = store.query(DocumentStore.Collection.NODES, from, to, limit);\n        Children c = new Children(path, rev);\n        for (Map<String, Object> e : list) {\n            // filter out deleted children\n            if (getLiveRevision(e, rev) == null) {\n                continue;\n            }\n            // TODO put the whole node in the cache\n            String id = e.get(UpdateOp.ID).toString();\n            String p = Utils.getPathFromId(id);\n            c.children.add(p);\n        }\n        return c;\n    }","id":34371,"modified_method":"Node.Children readChildren(String path, Revision rev, int limit) {\n        String from = PathUtils.concat(path, \"a\");\n        from = Utils.getIdFromPath(from);\n        from = from.substring(0, from.length() - 1);\n        String to = PathUtils.concat(path, \"z\");\n        to = Utils.getIdFromPath(to);\n        to = to.substring(0, to.length() - 2) + \"0\";\n        List<Map<String, Object>> list = store.query(DocumentStore.Collection.NODES, from, to, limit);\n        Children c = new Children(path, rev);\n        Set<Revision> validRevisions = new HashSet<Revision>();\n        for (Map<String, Object> e : list) {\n            // filter out deleted children\n            if (getLiveRevision(e, rev, validRevisions) == null) {\n                continue;\n            }\n            // TODO put the whole node in the cache\n            String id = e.get(UpdateOp.ID).toString();\n            String p = Utils.getPathFromId(id);\n            c.children.add(p);\n        }\n        return c;\n    }","commit_id":"e848a38ab99da7c8b4ed5ce2163136babd8f7231","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the revision of the latest change made to this node.\n     * \n     * @param nodeMap the document\n     * @param before the returned value is guaranteed to be older than this revision\n     * @param onlyCommitted whether only committed changes should be considered\n     * @return the revision, or null if deleted\n     */\n    @Nullable Revision getNewestRevision(Map<String, Object> nodeMap, Revision before, boolean onlyCommitted) {\n        if (nodeMap == null) {\n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) nodeMap\n                .get(UpdateOp.DELETED);\n        if (valueMap == null) {\n            return null;\n        }\n        Revision newestRev = null;\n        String newestValue = null;\n        for (String r : valueMap.keySet()) {\n            Revision propRev = Revision.fromString(r);\n            if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\n                if (isRevisionNewer(before, propRev)) {\n                    if (!onlyCommitted || isValidRevision(propRev, before, nodeMap)) {\n                        newestRev = propRev;\n                        newestValue = valueMap.get(r);\n                    }\n                }\n            }\n        }\n        if (\"true\".equals(newestValue)) {\n            // deleted in the newest revision\n            return null;\n        }\n        return newestRev;\n    }","id":34372,"modified_method":"/**\n     * Get the revision of the latest change made to this node.\n     * \n     * @param nodeMap the document\n     * @param before the returned value is guaranteed to be older than this revision\n     * @param onlyCommitted whether only committed changes should be considered\n     * @return the revision, or null if deleted\n     */\n    @Nullable Revision getNewestRevision(Map<String, Object> nodeMap,\n                                         Revision before, boolean onlyCommitted) {\n        if (nodeMap == null) {\n            return null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) nodeMap\n                .get(UpdateOp.DELETED);\n        if (valueMap == null) {\n            return null;\n        }\n        Revision newestRev = null;\n        String newestValue = null;\n        for (String r : valueMap.keySet()) {\n            Revision propRev = Revision.fromString(r);\n            if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\n                if (isRevisionNewer(before, propRev)) {\n                    if (!onlyCommitted\n                            || isValidRevision(propRev, before,\n                                nodeMap, new HashSet<Revision>())) {\n                        newestRev = propRev;\n                        newestValue = valueMap.get(r);\n                    }\n                }\n            }\n        }\n        if (\"true\".equals(newestValue)) {\n            // deleted in the newest revision\n            return null;\n        }\n        return newestRev;\n    }","commit_id":"e848a38ab99da7c8b4ed5ce2163136babd8f7231","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the latest revision where the node was alive at or before the\n     * provided revision.\n     * \n     * @param nodeMap the node map\n     * @param maxRev the maximum revision to return\n     * @return the earliest revision, or null if the node is deleted at the\n     *         given revision\n     */\n    private Revision getLiveRevision(Map<String, Object> nodeMap,\n            Revision maxRev) {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> valueMap = (Map<String, String>) nodeMap\n                .get(UpdateOp.DELETED);\n        Revision firstRev = null;\n        String value = null;\n        if (valueMap == null) {\n            return null;\n        }\n        for (String r : valueMap.keySet()) {\n            Revision propRev = Revision.fromString(r);\n            if (isRevisionNewer(propRev, maxRev)\n                    || !isValidRevision(propRev, maxRev, nodeMap)) {\n                continue;\n            }\n            if (firstRev == null || isRevisionNewer(propRev, firstRev)) {\n                firstRev = propRev;\n                value = valueMap.get(r);\n            }\n        }\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return firstRev;\n    }","id":34373,"modified_method":"/**\n     * Get the latest revision where the node was alive at or before the\n     * provided revision.\n     *\n     * @param nodeMap the node map\n     * @param maxRev the maximum revision to return\n     * @return the earliest revision, or null if the node is deleted at the\n     *         given revision\n     */\n    private Revision getLiveRevision(Map<String, Object> nodeMap,\n                                     Revision maxRev) {\n        return getLiveRevision(nodeMap, maxRev, new HashSet<Revision>());\n    }","commit_id":"e848a38ab99da7c8b4ed5ce2163136babd8f7231","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Checks if the revision is valid for the given node map. A revision is\n     * considered valid if the given node map is the root of the commit, or the\n     * commit root has the revision set. This method may read further nodes to\n     * perform this check.\n     * This method also takes pending branches into consideration.\n     * The <code>readRevision<\/code> identifies the read revision used by the\n     * client, which may be a branch revision logged in {@link #branchCommits}.\n     * The revision <code>rev<\/code> is valid if it is part of the branch\n     * history of <code>readRevision<\/code>.\n     *\n     * @param rev     revision to check.\n     * @param readRevision the read revision of the client.\n     * @param nodeMap the node to check.\n     * @return <code>true<\/code> if the revision is valid; <code>false<\/code>\n     *         otherwise.\n     */\n    boolean isValidRevision(@Nonnull Revision rev,\n                            @Nonnull Revision readRevision,\n                            @Nonnull Map<String, Object> nodeMap) {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> revisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);\n        if (isCommitted(rev, readRevision, revisions)) {\n            return true;\n        }\n        // check commit root\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Integer> commitRoot = (Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT);\n        String commitRootPath = null;\n        if (commitRoot != null) {\n            Integer depth = commitRoot.get(rev.toString());\n            if (depth != null) {\n                String p = Utils.getPathFromId((String) nodeMap.get(UpdateOp.ID));\n                commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n            }\n        }\n        if (commitRootPath == null) {\n            // shouldn't happen, either node is commit root for a revision\n            // or has a reference to the commit root\n            LOG.warn(\"Node {} does not have commit root reference for revision {}\",\n                    nodeMap.get(UpdateOp.ID), rev);\n            LOG.warn(nodeMap.toString());\n            return false;\n        }\n        // get root of commit\n        nodeMap = store.find(DocumentStore.Collection.NODES, Utils.getIdFromPath(commitRootPath));\n        if (nodeMap == null) {\n            return false;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> rootRevisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);\n        return isCommitted(rev, readRevision, rootRevisions);\n    }","id":34374,"modified_method":"/**\n     * Checks if the revision is valid for the given node map. A revision is\n     * considered valid if the given node map is the root of the commit, or the\n     * commit root has the revision set. This method may read further nodes to\n     * perform this check.\n     * This method also takes pending branches into consideration.\n     * The <code>readRevision<\/code> identifies the read revision used by the\n     * client, which may be a branch revision logged in {@link #branchCommits}.\n     * The revision <code>rev<\/code> is valid if it is part of the branch\n     * history of <code>readRevision<\/code>.\n     *\n     * @param rev     revision to check.\n     * @param readRevision the read revision of the client.\n     * @param nodeMap the node to check.\n     * @param validRevisions set of revisions already checked against\n     *                       <code>readRevision<\/code> and considered valid.\n     * @return <code>true<\/code> if the revision is valid; <code>false<\/code>\n     *         otherwise.\n     */\n    boolean isValidRevision(@Nonnull Revision rev,\n                            @Nonnull Revision readRevision,\n                            @Nonnull Map<String, Object> nodeMap,\n                            @Nonnull Set<Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> revisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);\n        if (isCommitted(rev, readRevision, revisions)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        // check commit root\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Integer> commitRoot = (Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT);\n        String commitRootPath = null;\n        if (commitRoot != null) {\n            Integer depth = commitRoot.get(rev.toString());\n            if (depth != null) {\n                String p = Utils.getPathFromId((String) nodeMap.get(UpdateOp.ID));\n                commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n            }\n        }\n        if (commitRootPath == null) {\n            // shouldn't happen, either node is commit root for a revision\n            // or has a reference to the commit root\n            LOG.warn(\"Node {} does not have commit root reference for revision {}\",\n                    nodeMap.get(UpdateOp.ID), rev);\n            LOG.warn(nodeMap.toString());\n            return false;\n        }\n        // get root of commit\n        nodeMap = store.find(DocumentStore.Collection.NODES, Utils.getIdFromPath(commitRootPath));\n        if (nodeMap == null) {\n            return false;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String> rootRevisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);\n        if (isCommitted(rev, readRevision, rootRevisions)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }","commit_id":"e848a38ab99da7c8b4ed5ce2163136babd8f7231","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString wsrpServiceUrl = ParamUtil.getString(req, \"wsrp_service_url\");\n\t\tString markupEndpoint = ParamUtil.getString(req, \"markup_endpoint\");\n\t\tString serviceDescriptionEndpoint = ParamUtil.getString(req,\n\t\t\t\t\"service_description_endpoint\");\n\t\tString registrationEndpoint = ParamUtil.getString(req,\n\t\t\t\t\"registration_endpoint\");\n\t\tString portletManagementEndpoint = ParamUtil.getString(req,\n\t\t\t\t\"portlet_management_endpoint\");\n\t\tString portletHandle = ParamUtil.getString(req, \"portlet_handle\");\n\n\t\tprefs.setValue(\"wsrp-service-url\", wsrpServiceUrl);\n\t\tprefs.setValue(\"markup-endpoint\", markupEndpoint);\n\t\tprefs.setValue(\"service-description-endpoint\",\n\t\t\t\tserviceDescriptionEndpoint);\n\t\tprefs.setValue(\"registration-endpoint\", registrationEndpoint);\n\t\tprefs.setValue(\"portlet-management-endpoint\",\n\t\t\t\t\t\tportletManagementEndpoint);\n\n\t\tString oldPortletHandle = prefs.getValue(\"portlet-handle\", \"\");\n\t\tif (!portletHandle.equals(oldPortletHandle)) {\n\t\t\tprefs.reset(\"parent-handle\");\n\t\t}\n\t\tprefs.setValue(\"portlet-handle\", portletHandle);\n\n\t\t// start a new wsrp session on next render\n\t\tPortletSession ses = req.getPortletSession();\n\t\tses.setAttribute(WebKeys.WSRP_NEW_SESSION, \"true\");\n\t\tses.setAttribute(WebKeys.WSRP_REGISTER_PRODUCER, \"true\");\n\n\t\tprefs.store();\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doEdit\");\n\n\t\tsetForward(req, \"portlet.wsrp.edit\");\n\t}","id":34375,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString wsrpServiceUrl = ParamUtil.getString(req, \"wsrp_service_url\");\n\t\tString markupEndpoint = ParamUtil.getString(req, \"markup_endpoint\");\n\t\tString serviceDescriptionEndpoint = ParamUtil.getString(req,\n\t\t\t\t\"service_description_endpoint\");\n\t\tString registrationEndpoint = ParamUtil.getString(req,\n\t\t\t\t\"registration_endpoint\");\n\t\tString portletManagementEndpoint = ParamUtil.getString(req,\n\t\t\t\t\"portlet_management_endpoint\");\n\t\tString portletHandle = ParamUtil.getString(req, \"portlet_handle\");\n\n\t\tprefs.setValue(\"wsrp-service-url\", wsrpServiceUrl);\n\t\tprefs.setValue(\"markup-endpoint\", markupEndpoint);\n\t\tprefs.setValue(\"service-description-endpoint\",\n\t\t\t\tserviceDescriptionEndpoint);\n\t\tprefs.setValue(\"registration-endpoint\", registrationEndpoint);\n\t\tprefs.setValue(\"portlet-management-endpoint\",\n\t\t\t\t\t\tportletManagementEndpoint);\n\n\t\tString oldPortletHandle = prefs.getValue(\"portlet-handle\", \"\");\n\t\tif (!portletHandle.equals(oldPortletHandle)) {\n\t\t\tprefs.reset(\"parent-handle\");\n\t\t}\n\t\tprefs.setValue(\"portlet-handle\", portletHandle);\n\n\t\t// start a new wsrp session on next render\n\t\tPortletSession ses = req.getPortletSession();\n\t\tses.setAttribute(WebKeys.WSRP_NEW_SESSION, \"true\");\n\n\t\tprefs.store();\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doEdit\");\n\n\t\tsetForward(req, \"portlet.wsrp.edit\");\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Map _getPreferences(PortletRequest request) {\n\n\t\tMap preferences = CollectionFactory.getSyncHashMap();\n\t\tEnumeration keys = request.getPreferences().getNames();\n\n\t\twhile (keys.hasMoreElements()) {\n\t\t\tString key = (String) keys.nextElement();\n\t\t\tString value = request.getPreferences().getValue(key, null);\n\n\t\t\tpreferences.put(key, value);\n\t\t}\n\n\t\treturn preferences;\n\t}","id":34376,"modified_method":"private PortletKey _getPortletKey(PortletPreferences preferences) {\n\t\tPortletKey portletKey = null;\n\n\t\tString portletHandle = preferences.getValue(\n\t\t\t\t\"portlet-handle\", StringPool.BLANK);\n\n\t\tif (portletHandle != null) {\n\t\t\tString producerID = _getProducerID(preferences);\n\t\t\tif (producerID != null) {\n\t\t\t\tportletKey = new PortletKeyImpl(portletHandle, producerID);\n\t\t\t}\n\t\t}\n\n\t\treturn portletKey;\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private PortletDescription _getPortletDescription(WSRPPortlet portlet)\n\t\t\tthrows WSRPException {\n\t\tString producerID = portlet.getPortletKey().getProducerId();\n\t\tProducer producer = _getProducer(producerID);\n\n\t\tPortletDescription portletDesc = producer.getPortletDescription(portlet\n\t\t\t\t.getParent());\n\t\tif (portletDesc == null) {\n\t\t\tWSRPXHelper.throwX(ErrorCodes.PORTLET_DESC_NOT_FOUND);\n\t\t}\n\n\t\treturn portletDesc;\n\t}","id":34377,"modified_method":"private PortletDescription _getPortletDescription(\n\t\t\tWSRPPortlet portlet, PortletPreferences preferences)\n\t\tthrows WSRPException {\n\t\t\n\t\tProducer producer = _getProducer(preferences);\n\n\t\tPortletDescription portletDesc = \n\t\t\tproducer.getPortletDescription(portlet.getParent());\n\t\t\n\t\tif (portletDesc == null) {\n\t\t\tWSRPXHelper.throwX(ErrorCodes.PORTLET_DESC_NOT_FOUND);\n\t\t}\n\n\t\treturn portletDesc;\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void render(RenderRequest request, RenderResponse response)\n\t\t\tthrows PortletException, IOException {\n\n\t\tException producerConfigError = null;\n\t\ttry {\n\t\t\tProducer producer = _createProducer(request.getPreferences());\n\t\t\trequest.setAttribute(WebKeys.WSRP_PRODUCER, producer);\n\t\t}\n\t\tcatch (WSRPException e) {\n\t\t\tproducerConfigError = e;\n\t\t\tSessionMessages.add(request, _portletConfig.getPortletName()\n\t\t\t\t\t+ \".configError\", e);\n\t\t}\n\n\t\tPortletMode mode = request.getPortletMode();\n\t\tif (mode.equals(PortletMode.VIEW)) {\n\t\t\tif (producerConfigError == null) {\n\t\t\t\t_renderRemote(request, response);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuper.render(request, response);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tboolean remoteInvocation = ParamUtil.get(request,\n\t\t\t\t\tREMOTE_INVOCATION, false);\n\n\t\t\tif (remoteInvocation && producerConfigError == null) {\n\t\t\t\t_renderRemote(request, response);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuper.render(request, response);\n\t\t\t}\n\t\t}\n\t}","id":34378,"modified_method":"public void render(RenderRequest request, RenderResponse response)\n\t\t\tthrows PortletException, IOException {\n\n\t\tException producerConfigError = null;\n\t\ttry {\n\t\t\tProducer producer = _getProducer(request.getPreferences());\n\t\t\trequest.setAttribute(WebKeys.WSRP_PRODUCER, producer);\n\t\t}\n\t\tcatch (WSRPException e) {\n\t\t\tproducerConfigError = e;\n\t\t\tSessionMessages.add(request, _portletConfig.getPortletName()\n\t\t\t\t\t+ \".configError\", e);\n\t\t}\n\n\t\tPortletMode mode = request.getPortletMode();\n\t\tif (mode.equals(PortletMode.VIEW)) {\n\t\t\tif (producerConfigError == null) {\n\t\t\t\t_renderRemote(request, response);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuper.render(request, response);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tboolean remoteInvocation = ParamUtil.get(request,\n\t\t\t\t\tREMOTE_INVOCATION, false);\n\n\t\t\tif (remoteInvocation && producerConfigError == null) {\n\t\t\t\t_renderRemote(request, response);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuper.render(request, response);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void _renderRemote(RenderRequest request,\n\t\t\tRenderResponse renderResponse) throws PortletException, IOException {\n\n\t\tString MN = \"render\";\n\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t_logger.entry(Logger.TRACE_HIGH, MN);\n\t\t}\n\n\t\ttry {\n\t\t\t// set content type in response\n\t\t\trenderResponse.setContentType(request.getResponseContentType());\n\n\t\t\t// get the user on which request this call is being done\n\t\t\tUser user = _getUser(request);\n\t\t\tString userID = null;\n\t\t\tif (user != null) {\n\t\t\t\tuserID = user.getUserID();\n\t\t\t}\n\n\t\t\t_registerProducer(request.getPreferences(), request\n\t\t\t\t\t.getPortletSession());\n\n\t\t\t// get all information and objects which are needed to perform the\n\t\t\t// interaction\n\t\t\tMap preferences = _getPreferences(request);\n\n\t\t\tPortletKey portletKey = _getPortletKey(preferences);\n\t\t\tWSRPPortlet portlet = _getPortlet(portletKey, preferences);\n\t\t\tPortletWindowSession windowSession = _getWindowSession(userID,\n\t\t\t\t\tportlet, request);\n\t\t\tPortletDriver portletDriver = _consumerEnv\n\t\t\t\t\t.getPortletDriverRegistry().getPortletDriver(portlet);\n\t\t\tMarkupRequest markupRequest = new WSRPRequestImpl(windowSession,\n\t\t\t\t\trequest);\n\n\t\t\t// feed the url generator with the current response\n\t\t\tsynchronized (_urlGenLock) {\n\t\t\t\t// update url generator\n\t\t\t\tURLGenerator urlGenerator = URLGeneratorImpl.getInstance(\n\t\t\t\t\t\trenderResponse, getPortletConfig());\n\t\t\t\tURLTemplateComposer templateComposer = _consumerEnv\n\t\t\t\t\t\t.getTemplateComposer();\n\t\t\t\tif (templateComposer != null) {\n\t\t\t\t\ttemplateComposer.setURLGenerator(urlGenerator);\n\t\t\t\t}\n\n\t\t\t\t_consumerEnv.getURLRewriter().setURLGenerator(urlGenerator);\n\t\t\t}\n\n\t\t\t// do a getMarkup call and check the response\n\t\t\tMarkupResponse response = null;\n\t\t\ttry {\n\t\t\t\tresponse = portletDriver.getMarkup(markupRequest, userID);\n\t\t\t\t_checker.check(response);\n\n\t\t\t}\n\t\t\tcatch (java.rmi.RemoteException wsrpFault) {\n\t\t\t\tWSRPXHelper.handleWSRPFault(_logger, wsrpFault);\n\t\t\t}\n\n\t\t\t// process the markup response\n\t\t\tif (response != null) {\n\t\t\t\tif (windowSession != null) {\n\t\t\t\t\t_updateSessionContext(response.getSessionContext(),\n\t\t\t\t\t\t\twindowSession.getPortletSession());\n\t\t\t\t}\n\t\t\t\t_processMarkupContext(response.getMarkupContext(), request,\n\t\t\t\t\t\trenderResponse);\n\t\t\t}\n\n\t\t\t// delete any cached markup\n\t\t\tif (windowSession != null) {\n\t\t\t\twindowSession.updateMarkupCache(null);\n\t\t\t}\n\n\t\t}\n\t\tcatch (WSRPException e) {\n\t\t\tthrow new PortletException(\"Error occured while retrieving markup\",\n\t\t\t\t\te);\n\t\t}\n\t\tfinally {\n\t\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t\t_logger.exit(Logger.TRACE_HIGH, MN);\n\t\t\t}\n\t\t}\n\t}","id":34379,"modified_method":"public void _renderRemote(RenderRequest request,\n\t\t\tRenderResponse renderResponse) throws PortletException, IOException {\n\n\t\tString MN = \"render\";\n\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t_logger.entry(Logger.TRACE_HIGH, MN);\n\t\t}\n\n\t\ttry {\n\t\t\t// set content type in response\n\t\t\trenderResponse.setContentType(request.getResponseContentType());\n\n\t\t\t// get the user on which request this call is being done\n\t\t\tUser user = _getUser(request);\n\t\t\tString userID = null;\n\t\t\tif (user != null) {\n\t\t\t\tuserID = user.getUserID();\n\t\t\t}\n\n\t\t\t// get all information and objects which are needed to perform the\n\t\t\t// interaction\n\t\t\tPortletPreferences preferences = request.getPreferences();\n\n\t\t\tPortletKey portletKey = _getPortletKey(preferences);\n\t\t\tWSRPPortlet portlet = _getPortlet(portletKey, preferences);\n\t\t\tPortletWindowSession windowSession = _getWindowSession(userID,\n\t\t\t\t\tportlet, request);\n\t\t\tPortletDriver portletDriver = _consumerEnv\n\t\t\t\t\t.getPortletDriverRegistry().getPortletDriver(portlet);\n\t\t\tMarkupRequest markupRequest = new WSRPRequestImpl(windowSession,\n\t\t\t\t\trequest);\n\n\t\t\t// feed the url generator with the current response\n\t\t\tsynchronized (_urlGenLock) {\n\t\t\t\t// update url generator\n\t\t\t\tURLGenerator urlGenerator = URLGeneratorImpl.getInstance(\n\t\t\t\t\t\trenderResponse, getPortletConfig());\n\t\t\t\tURLTemplateComposer templateComposer = _consumerEnv\n\t\t\t\t\t\t.getTemplateComposer();\n\t\t\t\tif (templateComposer != null) {\n\t\t\t\t\ttemplateComposer.setURLGenerator(urlGenerator);\n\t\t\t\t}\n\n\t\t\t\t_consumerEnv.getURLRewriter().setURLGenerator(urlGenerator);\n\t\t\t}\n\n\t\t\t// do a getMarkup call and check the response\n\t\t\tMarkupResponse response = null;\n\t\t\ttry {\n\t\t\t\tresponse = portletDriver.getMarkup(markupRequest, userID);\n\t\t\t\t_checker.check(response);\n\n\t\t\t}\n\t\t\tcatch (java.rmi.RemoteException wsrpFault) {\n\t\t\t\tWSRPXHelper.handleWSRPFault(_logger, wsrpFault);\n\t\t\t}\n\n\t\t\t// process the markup response\n\t\t\tif (response != null) {\n\t\t\t\tif (windowSession != null) {\n\t\t\t\t\t_updateSessionContext(response.getSessionContext(),\n\t\t\t\t\t\t\twindowSession.getPortletSession());\n\t\t\t\t}\n\t\t\t\t_processMarkupContext(response.getMarkupContext(), request,\n\t\t\t\t\t\trenderResponse);\n\t\t\t}\n\n\t\t\t// delete any cached markup\n\t\t\tif (windowSession != null) {\n\t\t\t\twindowSession.updateMarkupCache(null);\n\t\t\t}\n\n\t\t}\n\t\tcatch (WSRPException e) {\n\t\t\tthrow new PortletException(\"Error occured while retrieving markup\",\n\t\t\t\t\te);\n\t\t}\n\t\tfinally {\n\t\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t\t_logger.exit(Logger.TRACE_HIGH, MN);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private WSRPPortlet _getPortlet(PortletKey portletKey, Map preferences)\n\t\t\tthrows WSRPException {\n\n\t\tWSRPPortlet portlet = null;\n\n\t\tif (portletKey != null) {\n\t\t\tportlet = _consumerEnv.getPortletRegistry().getPortlet(portletKey);\n\t\t\tif (portlet == null) {\n\t\t\t\t// not yet in registry, create new one\n\t\t\t\tString parentHandle = GetterUtil.getString((String) preferences\n\t\t\t\t\t\t.get(\"parent-handle\"), (String) preferences\n\t\t\t\t\t\t.get(\"portlet-handle\"));\n\n\t\t\t\tportlet = _createPortlet(portletKey, parentHandle);\n\t\t\t\t_consumerEnv.getPortletRegistry().addPortlet(portlet);\n\t\t\t}\n\t\t}\n\n\t\treturn portlet;\n\t}","id":34380,"modified_method":"private WSRPPortlet _getPortlet(\n\t\t\tPortletKey portletKey, PortletPreferences preferences) \n\t\tthrows WSRPException {\n\n\t\tWSRPPortlet portlet = null;\n\n\t\tif (portletKey != null) {\n\n\t\t\tportlet = _consumerEnv.getPortletRegistry().getPortlet(portletKey);\n\n\t\t\tif (portlet == null) {\n\n\t\t\t\tString parentHandle = preferences.getValue(\n\t\t\t\t\t\t\"parent-handle\", StringPool.BLANK);\n\n\t\t\t\t// not yet in registry, create new one\n\n\t\t\t\tif (Validator.isNull(parentHandle)) {\n\t\t\t\t\tparentHandle = preferences.getValue(\n\t\t\t\t\t\t\t\"portlet-handle\", StringPool.BLANK);;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tportlet = _createPortlet(portletKey, parentHandle);\n\t\t\t\t\n\t\t\t\t_consumerEnv.getPortletRegistry().addPortlet(portlet);\n\t\t\t}\n\t\t}\n\n\t\treturn portlet;\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void _processActionRemote(ActionRequest request,\n\t\t\tActionResponse actionResponse) throws PortletException {\n\t\tString MN = \"processAction\";\n\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t_logger.entry(Logger.TRACE_HIGH, MN);\n\t\t}\n\n\t\ttry {\n\t\t\t// get the user on which request this call is being done\n\t\t\tUser user = _getUser(request);\n\t\t\tString userID = null;\n\t\t\tif (user != null) {\n\t\t\t\tuserID = user.getUserID();\n\t\t\t}\n\n\t\t\t_registerProducer(request.getPreferences(), request\n\t\t\t\t\t.getPortletSession());\n\n\t\t\t// get all information and objects which are needed to perform the\n\t\t\t// interaction\n\t\t\tMap preferences = _getPreferences(request);\n\n\t\t\tPortletKey portletKey = _getPortletKey(preferences);\n\t\t\tWSRPPortlet portlet = _getPortlet(portletKey, preferences);\n\t\t\tPortletWindowSession windowSession = _getWindowSession(userID,\n\t\t\t\t\tportlet, request);\n\t\t\tPortletDriver portletDriver = _consumerEnv\n\t\t\t\t\t.getPortletDriverRegistry().getPortletDriver(portlet);\n\t\t\tInteractionRequest actionRequest = new WSRPRequestImpl(\n\t\t\t\t\twindowSession, request);\n\n\t\t\t// do the actual call and check the response from the producer\n\t\t\tBlockingInteractionResponse response = null;\n\t\t\ttry {\n\t\t\t\tresponse = portletDriver.performBlockingInteraction(\n\t\t\t\t\t\tactionRequest, userID);\n\t\t\t\t_checker.check(response);\n\n\t\t\t}\n\t\t\tcatch (java.rmi.RemoteException wsrpFault) {\n\t\t\t\tWSRPXHelper.handleWSRPFault(_logger, wsrpFault);\n\t\t\t}\n\n\t\t\t// process the reponse\n\t\t\tif (response != null) {\n\t\t\t\t// the producer can either send a update response or a redirect\n\t\t\t\tUpdateResponse updateResponse = response.getUpdateResponse();\n\t\t\t\tString redirectURL = response.getRedirectURL();\n\n\t\t\t\tif (updateResponse != null) {\n\t\t\t\t\t// process the update response\n\t\t\t\t\tif (windowSession != null) {\n\t\t\t\t\t\t_updateSessionContext(updateResponse\n\t\t\t\t\t\t\t\t.getSessionContext(), windowSession\n\t\t\t\t\t\t\t\t.getPortletSession());\n\t\t\t\t\t\twindowSession.updateMarkupCache(updateResponse\n\t\t\t\t\t\t\t\t.getMarkupContext());\n\t\t\t\t\t}\n\t\t\t\t\t_updatePortletContext(request, updateResponse\n\t\t\t\t\t\t\t.getPortletContext(), portlet);\n\n\t\t\t\t\t// pass navState to next getMarkup by using the render\n\t\t\t\t\t// params\n\t\t\t\t\tString navState = updateResponse.getNavigationalState();\n\t\t\t\t\tif (navState != null) {\n\t\t\t\t\t\tactionResponse.setRenderParameter(NAVIGATIONAL_STATE,\n\t\t\t\t\t\t\t\tnavState);\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the remote portlet requested to change the portlet\n\t\t\t\t\t// mode\n\t\t\t\t\t// we try to solve this request.\n\t\t\t\t\tString newMode = updateResponse.getNewMode();\n\t\t\t\t\tif (newMode != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tactionResponse.setPortletMode(WSRPUtil\n\t\t\t\t\t\t\t\t\t.fromWsrpMode(newMode));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (PortletModeException e) {\n\t\t\t\t\t\t\t// means portlet does not support this mode\n\t\t\t\t\t\t\tif (_logger.isLogging(Logger.INFO)) {\n\t\t\t\t\t\t\t\t_logger.text(Logger.INFO, MN, \"The portlet='\"\n\t\t\t\t\t\t\t\t\t\t+ portlet.getPortletKey()\n\t\t\t\t\t\t\t\t\t\t\t\t.getPortletHandle()\n\t\t\t\t\t\t\t\t\t\t+ \"' does not support the mode=\"\n\t\t\t\t\t\t\t\t\t\t+ e.getMode());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the remote portlet requested to change the window\n\t\t\t\t\t// state\n\t\t\t\t\t// we try to solve this request. If the window state\n\t\t\t\t\tString newWindowState = updateResponse.getNewWindowState();\n\t\t\t\t\tif (newWindowState != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tactionResponse.setWindowState(WSRPUtil\n\t\t\t\t\t\t\t\t\t.fromWsrpWindowState(newWindowState));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (WindowStateException e) {\n\t\t\t\t\t\t\t// means portlet does not support the window state\n\t\t\t\t\t\t\tif (_logger.isLogging(Logger.INFO)) {\n\t\t\t\t\t\t\t\t_logger\n\t\t\t\t\t\t\t\t\t\t.text(\n\t\t\t\t\t\t\t\t\t\t\t\tLogger.INFO,\n\t\t\t\t\t\t\t\t\t\t\t\tMN,\n\t\t\t\t\t\t\t\t\t\t\t\t\"The portlet='\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ portlet\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPortletKey()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPortletHandle()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"' does not support the window state=\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ e.getState());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (redirectURL != null) {\n\t\t\t\t\t// if we got a redirect forward this redirect to the\n\t\t\t\t\t// container\n\t\t\t\t\ttry {\n\t\t\t\t\t\tactionResponse.sendRedirect(redirectURL);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioEx) {\n\t\t\t\t\t\tWSRPXHelper.throwX(_logger, Logger.ERROR,\n\t\t\t\t\t\t\t\t\"processAction\",\n\t\t\t\t\t\t\t\tErrorCodes.COULD_NOT_FOLLOW_REDIRECT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcatch (WSRPException e) {\n\t\t\tthrow new PortletException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t\t_logger.exit(Logger.TRACE_HIGH, MN);\n\t\t\t}\n\t\t}\n\t}","id":34381,"modified_method":"public void _processActionRemote(ActionRequest request,\n\t\t\tActionResponse actionResponse) throws PortletException {\n\t\tString MN = \"processAction\";\n\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t_logger.entry(Logger.TRACE_HIGH, MN);\n\t\t}\n\n\t\ttry {\n\t\t\t// get the user on which request this call is being done\n\t\t\tUser user = _getUser(request);\n\t\t\tString userID = null;\n\t\t\tif (user != null) {\n\t\t\t\tuserID = user.getUserID();\n\t\t\t}\n\n\t\t\t// get all information and objects which are needed to perform the\n\t\t\t// interaction\n\t\t\t\n\t\t\tPortletPreferences preferences = request.getPreferences();\n\t\t\t\n\t\t\tPortletKey portletKey = _getPortletKey(preferences);\n\t\t\tWSRPPortlet portlet = _getPortlet(portletKey, preferences);\n\t\t\tPortletWindowSession windowSession = _getWindowSession(userID,\n\t\t\t\t\tportlet, request);\n\t\t\tPortletDriver portletDriver = _consumerEnv\n\t\t\t\t\t.getPortletDriverRegistry().getPortletDriver(portlet);\n\t\t\tInteractionRequest actionRequest = new WSRPRequestImpl(\n\t\t\t\t\twindowSession, request);\n\n\t\t\t// do the actual call and check the response from the producer\n\t\t\tBlockingInteractionResponse response = null;\n\t\t\ttry {\n\t\t\t\tresponse = portletDriver.performBlockingInteraction(\n\t\t\t\t\t\tactionRequest, userID);\n\t\t\t\t_checker.check(response);\n\n\t\t\t}\n\t\t\tcatch (java.rmi.RemoteException wsrpFault) {\n\t\t\t\tWSRPXHelper.handleWSRPFault(_logger, wsrpFault);\n\t\t\t}\n\n\t\t\t// process the reponse\n\t\t\tif (response != null) {\n\t\t\t\t// the producer can either send a update response or a redirect\n\t\t\t\tUpdateResponse updateResponse = response.getUpdateResponse();\n\t\t\t\tString redirectURL = response.getRedirectURL();\n\n\t\t\t\tif (updateResponse != null) {\n\t\t\t\t\t// process the update response\n\t\t\t\t\tif (windowSession != null) {\n\t\t\t\t\t\t_updateSessionContext(updateResponse\n\t\t\t\t\t\t\t\t.getSessionContext(), windowSession\n\t\t\t\t\t\t\t\t.getPortletSession());\n\t\t\t\t\t\twindowSession.updateMarkupCache(updateResponse\n\t\t\t\t\t\t\t\t.getMarkupContext());\n\t\t\t\t\t}\n\t\t\t\t\t_updatePortletContext(request, updateResponse\n\t\t\t\t\t\t\t.getPortletContext(), portlet);\n\n\t\t\t\t\t// pass navState to next getMarkup by using the render\n\t\t\t\t\t// params\n\t\t\t\t\tString navState = updateResponse.getNavigationalState();\n\t\t\t\t\tif (navState != null) {\n\t\t\t\t\t\tactionResponse.setRenderParameter(NAVIGATIONAL_STATE,\n\t\t\t\t\t\t\t\tnavState);\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the remote portlet requested to change the portlet\n\t\t\t\t\t// mode\n\t\t\t\t\t// we try to solve this request.\n\t\t\t\t\tString newMode = updateResponse.getNewMode();\n\t\t\t\t\tif (newMode != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tactionResponse.setPortletMode(WSRPUtil\n\t\t\t\t\t\t\t\t\t.fromWsrpMode(newMode));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (PortletModeException e) {\n\t\t\t\t\t\t\t// means portlet does not support this mode\n\t\t\t\t\t\t\tif (_logger.isLogging(Logger.INFO)) {\n\t\t\t\t\t\t\t\t_logger.text(Logger.INFO, MN, \"The portlet='\"\n\t\t\t\t\t\t\t\t\t\t+ portlet.getPortletKey()\n\t\t\t\t\t\t\t\t\t\t\t\t.getPortletHandle()\n\t\t\t\t\t\t\t\t\t\t+ \"' does not support the mode=\"\n\t\t\t\t\t\t\t\t\t\t+ e.getMode());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the remote portlet requested to change the window\n\t\t\t\t\t// state\n\t\t\t\t\t// we try to solve this request. If the window state\n\t\t\t\t\tString newWindowState = updateResponse.getNewWindowState();\n\t\t\t\t\tif (newWindowState != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tactionResponse.setWindowState(WSRPUtil\n\t\t\t\t\t\t\t\t\t.fromWsrpWindowState(newWindowState));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (WindowStateException e) {\n\t\t\t\t\t\t\t// means portlet does not support the window state\n\t\t\t\t\t\t\tif (_logger.isLogging(Logger.INFO)) {\n\t\t\t\t\t\t\t\t_logger\n\t\t\t\t\t\t\t\t\t\t.text(\n\t\t\t\t\t\t\t\t\t\t\t\tLogger.INFO,\n\t\t\t\t\t\t\t\t\t\t\t\tMN,\n\t\t\t\t\t\t\t\t\t\t\t\t\"The portlet='\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ portlet\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPortletKey()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPortletHandle()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"' does not support the window state=\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ e.getState());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (redirectURL != null) {\n\t\t\t\t\t// if we got a redirect forward this redirect to the\n\t\t\t\t\t// container\n\t\t\t\t\ttry {\n\t\t\t\t\t\tactionResponse.sendRedirect(redirectURL);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioEx) {\n\t\t\t\t\t\tWSRPXHelper.throwX(_logger, Logger.ERROR,\n\t\t\t\t\t\t\t\t\"processAction\",\n\t\t\t\t\t\t\t\tErrorCodes.COULD_NOT_FOLLOW_REDIRECT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcatch (WSRPException e) {\n\t\t\tthrow new PortletException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t\t_logger.exit(Logger.TRACE_HIGH, MN);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Producer _createProducer(PortletPreferences preferences)\n\t\t\tthrows WSRPException {\n\n\t\tString wsrpServiceUrl = preferences.getValue(\"wsrp-service-url\",\n\t\t\t\tStringPool.BLANK);\n\t\tString markupEndpoint = preferences.getValue(\"markup-endpoint\",\n\t\t\t\tStringPool.BLANK);\n\t\tString serviceDescriptionEndpoint = preferences.getValue(\n\t\t\t\t\"service-description-endpoint\", StringPool.BLANK);\n\t\tString registrationEndpoint = preferences.getValue(\n\t\t\t\t\"registration-endpoint\", StringPool.BLANK);\n\t\tString portletManagementEndpoint = preferences.getValue(\n\t\t\t\t\"portlet-management-endpoint\", StringPool.BLANK);\n\n\t\tmarkupEndpoint = wsrpServiceUrl + \"/\" + markupEndpoint;\n\t\tserviceDescriptionEndpoint = wsrpServiceUrl + \"/\"\n\t\t\t\t+ serviceDescriptionEndpoint;\n\t\tregistrationEndpoint = wsrpServiceUrl + \"/\" + registrationEndpoint;\n\t\tportletManagementEndpoint = wsrpServiceUrl + \"/\"\n\t\t\t\t+ portletManagementEndpoint;\n\n\t\tRegistrationData regData = new RegistrationData();\n\t\tregData.setConsumerName(\"Liferay WSRP Agent\");\n\t\tregData.setConsumerAgent(\"Liferay WSRP Agent\");\n\n\t\tProducer producer = new ProducerImpl(PRODUCER_ID, markupEndpoint,\n\t\t\t\tserviceDescriptionEndpoint, registrationEndpoint,\n\t\t\t\tportletManagementEndpoint, regData);\n\n\t\treturn producer;\n\t}","id":34382,"modified_method":"private Producer _getProducer(PortletPreferences preferences) \n\t\tthrows WSRPException {\n\t\t\n\t\tfinal String MN = \"getProducer\";\n\n\t\tif (_logger.isLogging(Logger.TRACE_HIGH)) {\n\t\t\t_logger.text(Logger.TRACE_HIGH, MN,\n\t\t\t\t\t\"Trying to load producer with ID :\" + \n\t\t\t\t\t_getProducerID(preferences));\n\t\t}\n\n\t\tString producerID = _getProducerID(preferences);\n\n\t\tProducerRegistry producerReg = _consumerEnv.getProducerRegistry();\n\t\tProducer producer = producerReg.getProducer(producerID);\n\n\t\tif (producer == null) {\n\t\t\t\n\t\t\tString wsrpServiceUrl = preferences.getValue(\"wsrp-service-url\",\n\t\t\t\t\tStringPool.BLANK);\n\t\t\tString markupEndpoint = preferences.getValue(\"markup-endpoint\",\n\t\t\t\t\tStringPool.BLANK);\n\t\t\tString serviceDescriptionEndpoint = preferences.getValue(\n\t\t\t\t\t\"service-description-endpoint\", StringPool.BLANK);\n\t\t\tString registrationEndpoint = preferences.getValue(\n\t\t\t\t\t\"registration-endpoint\", StringPool.BLANK);\n\t\t\tString portletManagementEndpoint = preferences.getValue(\n\t\t\t\t\t\"portlet-management-endpoint\", StringPool.BLANK);\n\n\t\t\tmarkupEndpoint = wsrpServiceUrl + \"/\" + markupEndpoint;\n\t\t\tserviceDescriptionEndpoint = wsrpServiceUrl + \"/\"\n\t\t\t\t\t+ serviceDescriptionEndpoint;\n\t\t\tregistrationEndpoint = wsrpServiceUrl + \"/\" + registrationEndpoint;\n\t\t\tportletManagementEndpoint = wsrpServiceUrl + \"/\"\n\t\t\t\t\t+ portletManagementEndpoint;\n\n\t\t\tRegistrationData regData = new RegistrationData();\n\t\t\tregData.setConsumerName(\"Liferay WSRP Agent\");\n\t\t\tregData.setConsumerAgent(\"Liferay WSRP Agent\");\n\n\t\t\tproducer = new ProducerImpl(producerID, \n\t\t\t\t\tmarkupEndpoint, serviceDescriptionEndpoint, \n\t\t\t\t\tregistrationEndpoint, portletManagementEndpoint, regData);\n\n\t\t\tproducerReg.addProducer(producer);\n\t\t}\n\n\t\tif (producer == null) {\n\t\t\tWSRPXHelper.throwX(_logger, Logger.ERROR, MN,\n\t\t\t\t\tErrorCodes.PRODUCER_DOES_NOT_EXIST);\n\t\t}\n\n\t\treturn producer;\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private PortletWindowSession _getWindowSession(String userID,\n\t\t\tWSRPPortlet portlet, PortletRequest request) throws WSRPException {\n\t\tPortletKey portletKey = portlet.getPortletKey();\n\n\t\tjavax.portlet.PortletSession jsrPortletSession = request\n\t\t\t\t.getPortletSession();\n\n\t\t// to ensure that producer is added to the producer registry\n\t\t// throws exception which we pass\n\t\t_getProducer(portletKey.getProducerId());\n\n\t\t// now we can get our sessions\n\t\tUserSession userSession = null;\n\t\tsynchronized (_sessionHdlrLock) {\n\t\t\tSessionHandler sessionHandler = (SessionHandler) _consumerEnv\n\t\t\t\t\t.getSessionHandler();\n\t\t\tsessionHandler.setPortletSession(jsrPortletSession);\n\t\t\t// get the user session\n\t\t\tuserSession = sessionHandler.getUserSession(portletKey\n\t\t\t\t\t.getProducerId(), userID);\n\t\t}\n\n\t\tif (userSession != null) {\n\t\t\t// get the group session\n\t\t\tString groupID = _getPortletDescription(portlet).getGroupID();\n\t\t\tgroupID = groupID == null ? \"default\" : groupID;\n\n\t\t\tGroupSession groupSession = userSession.getGroupSession(groupID);\n\t\t\tif (groupSession != null) {\n\t\t\t\t// get the portlet session\n\t\t\t\tString handle = _portletConfig.getPortletName();\n\n\t\t\t\tPortletSession portletSession = groupSession\n\t\t\t\t\t\t.getPortletSession(handle);\n\n\t\t\t\tint sessionScope = javax.portlet.PortletSession.PORTLET_SCOPE;\n\t\t\t\tboolean clearSessionCtx = GetterUtil.getBoolean(\n\t\t\t\t\t\t(String) jsrPortletSession.getAttribute(\n\t\t\t\t\t\t\t\tWebKeys.WSRP_NEW_SESSION, sessionScope));\n\n\t\t\t\tif (clearSessionCtx) {\n\t\t\t\t\tportletSession.setSessionContext(null);\n\t\t\t\t\tjsrPortletSession.setAttribute(WebKeys.WSRP_NEW_SESSION,\n\t\t\t\t\t\t\t\"false\");\n\t\t\t\t}\n\n\t\t\t\tif (portletSession != null) {\n\t\t\t\t\t// get the window session\n\t\t\t\t\tPortletWindowSession windowSession = portletSession\n\t\t\t\t\t\t\t.getPortletWindowSession(handle);\n\n\t\t\t\t\treturn windowSession;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tWSRPXHelper.throwX(ErrorCodes.PORTLET_SESSION_NOT_FOUND);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWSRPXHelper.throwX(ErrorCodes.GROUP_SESSION_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tWSRPXHelper.throwX(ErrorCodes.USER_SESSION_NOT_FOUND);\n\t\t}\n\t\t// we will never reach this\n\t\treturn null;\n\t}","id":34383,"modified_method":"private PortletWindowSession _getWindowSession(String userID,\n\t\t\tWSRPPortlet portlet, PortletRequest request) throws WSRPException {\n\t\tPortletKey portletKey = portlet.getPortletKey();\n\n\t\tjavax.portlet.PortletSession jsrPortletSession = request\n\t\t\t\t.getPortletSession();\n\n\t\t// to ensure that producer is added to the producer registry\n\t\t// throws exception which we pass\n\t\t_getProducer(request.getPreferences());\n\n\t\t// now we can get our sessions\n\n\t\tUserSession userSession = null;\n\n\t\tsynchronized (_sessionHdlrLock) {\n\t\t\tSessionHandler sessionHandler = (SessionHandler) _consumerEnv\n\t\t\t\t\t.getSessionHandler();\n\t\t\tsessionHandler.setPortletSession(jsrPortletSession);\n\n\t\t\t// get the user session\n\n\t\t\tuserSession = sessionHandler.getUserSession(portletKey\n\t\t\t\t\t.getProducerId(), userID);\n\t\t}\n\n\t\tif (userSession != null) {\n\t\t\t\n\t\t\t// get the group session\n\n\t\t\tPortletDescription portletDescription = \n\t\t\t\t_getPortletDescription(portlet, request.getPreferences());\n\t\t\t\n\t\t\tString groupID = portletDescription.getGroupID();\n\t\t\t\n\t\t\tif (groupID == null) {\n\t\t\t\tgroupID = \"default\";\n\t\t\t}\n\n\t\t\tGroupSession groupSession = userSession.getGroupSession(groupID);\n\n\t\t\tif (groupSession != null) {\n\n\t\t\t\t// get the portlet session\n\t\t\t\tString handle = _portletConfig.getPortletName();\n\n\t\t\t\tPortletSession portletSession = groupSession\n\t\t\t\t\t\t.getPortletSession(handle);\n\n\t\t\t\tint sessionScope = javax.portlet.PortletSession.PORTLET_SCOPE;\n\t\t\t\tboolean clearSessionCtx = GetterUtil.getBoolean(\n\t\t\t\t\t\t(String) jsrPortletSession.getAttribute(\n\t\t\t\t\t\t\t\tWebKeys.WSRP_NEW_SESSION, sessionScope));\n\n\t\t\t\tif (clearSessionCtx) {\n\t\t\t\t\tportletSession.setSessionContext(null);\n\t\t\t\t\tjsrPortletSession.setAttribute(WebKeys.WSRP_NEW_SESSION,\n\t\t\t\t\t\t\t\"false\");\n\t\t\t\t}\n\n\t\t\t\tif (portletSession != null) {\n\t\t\t\t\t\n\t\t\t\t\t// get the window session\n\n\t\t\t\t\tPortletWindowSession windowSession = portletSession\n\t\t\t\t\t\t\t.getPortletWindowSession(handle);\n\n\t\t\t\t\treturn windowSession;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tWSRPXHelper.throwX(ErrorCodes.PORTLET_SESSION_NOT_FOUND);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWSRPXHelper.throwX(ErrorCodes.GROUP_SESSION_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tWSRPXHelper.throwX(ErrorCodes.USER_SESSION_NOT_FOUND);\n\t\t}\n\n\t\t// we will never reach this\n\n\t\treturn null;\n\t}","commit_id":"1d0fcba530fd661da0769c48fde59773bbf9452e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static WikiNode getNode(PortletRequest portletRequest)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\tportletRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong nodeId = ParamUtil.getLong(request, \"nodeId\");\n\t\tString nodeName = ParamUtil.getString(request, \"nodeName\");\n\n\t\tWikiNode node = null;\n\n\t\ttry {\n\t\t\tif (nodeId > 0) {\n\t\t\t\tnode = WikiNodeServiceUtil.getNode(nodeId);\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(nodeName)) {\n\t\t\t\tnode = WikiNodeServiceUtil.getNode(\n\t\t\t\t\tthemeDisplay.getScopeGroupId(), nodeName);\n\t\t\t}\n\n\t\t\tif (node == null) {\n\t\t\t\tthrow new NoSuchNodeException();\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchNodeException e) {\n\t\t\tnode = ActionUtil.getFirstVisibleNode(portletRequest);\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.WIKI_NODE, node);\n\n\t\treturn node;\n\t}","id":34384,"modified_method":"public static WikiNode getNode(PortletRequest portletRequest)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\tportletRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong nodeId = ParamUtil.getLong(request, \"nodeId\");\n\t\tString nodeName = ParamUtil.getString(request, \"nodeName\");\n\n\t\tWikiNode node = null;\n\n\t\ttry {\n\t\t\tif (nodeId > 0) {\n\t\t\t\tnode = WikiNodeServiceUtil.getNode(nodeId);\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(nodeName)) {\n\t\t\t\tnode = WikiNodeServiceUtil.getNode(\n\t\t\t\t\tthemeDisplay.getScopeGroupId(), nodeName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchNodeException();\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchNodeException nsne) {\n\t\t\tnode = ActionUtil.getFirstVisibleNode(portletRequest);\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.WIKI_NODE, node);\n\n\t\treturn node;\n\t}","commit_id":"630ab0ac708fe81356066234d703ad26b2bb050a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<WikiNode> getNodes(PortletRequest portletRequest)\n\t\tthrows PortalException, SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\n\t\tString allNodes = ListUtil.toString(\n\t\t\tWikiNodeLocalServiceUtil.getNodes(groupId), \"name\");\n\n\t\tString[] visibleNodes = StringUtil.split(\n\t\t\tportletRequest.getPreferences().getValue(\n\t\t\t\t\"visible-nodes\", allNodes));\n\t\tString[] hiddenNodes = StringUtil.split(\n\t\t\tportletRequest.getPreferences().getValue(\n\t\t\t\t\"hidden-nodes\", StringPool.BLANK));\n\n\t\treturn getNodes(\n\t\t\tgroupId, visibleNodes, hiddenNodes,\n\t\t\tthemeDisplay.getPermissionChecker());\n\t}","id":34385,"modified_method":"public static List<WikiNode> getNodes(PortletRequest portletRequest)\n\t\tthrows PortalException, SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\n\t\tString allNodes = ListUtil.toString(\n\t\t\tWikiNodeLocalServiceUtil.getNodes(groupId), \"name\");\n\n\t\tPortletPreferences preferences = portletRequest.getPreferences();\n\n\t\tString[] visibleNodes = StringUtil.split(\n\t\t\tpreferences.getValue(\"visible-nodes\", allNodes));\n\t\tString[] hiddenNodes = StringUtil.split(\n\t\t\tpreferences.getValue(\"hidden-nodes\", StringPool.BLANK));\n\n\t\treturn getNodes(\n\t\t\tgroupId, visibleNodes, hiddenNodes,\n\t\t\tthemeDisplay.getPermissionChecker());\n\t}","commit_id":"630ab0ac708fe81356066234d703ad26b2bb050a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _doServeResource(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest ownerLayoutRequest = getOwnerLayoutRequestWrapper(\n\t\t\trequest, portlet);\n\n\t\tLayout ownerLayout = (Layout)ownerLayoutRequest.getAttribute(\n\t\t\tWebKeys.LAYOUT);\n\n\t\tboolean allowAddPortletDefaultResource =\n\t\t\tPortalUtil.isAllowAddPortletDefaultResource(\n\t\t\t\townerLayoutRequest, portlet);\n\n\t\tif (!allowAddPortletDefaultResource) {\n\t\t\tString url = null;\n\n\t\t\tLastPath lastPath = (LastPath)request.getAttribute(\n\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\tif (lastPath != null) {\n\t\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\t\tsb.append(PortalUtil.getPortalURL(request));\n\t\t\t\tsb.append(lastPath.getContextPath());\n\t\t\t\tsb.append(lastPath.getPath());\n\n\t\t\t\turl = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\turl = String.valueOf(request.getRequestURI());\n\t\t\t}\n\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\n\t\t\t_log.error(\n\t\t\t\t\"Reject serveResource for \" + url + \" on \" +\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tWindowState windowState = (WindowState)request.getAttribute(\n\t\t\tWebKeys.WINDOW_STATE);\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portlet.getPortletId());\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\tif (allowAddPortletDefaultResource) {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\t\telse {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getStrictPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tString portletPrimaryKey = PortletPermissionUtil.getPrimaryKey(\n\t\t\tlayout.getPlid(), portlet.getPortletId());\n\n\t\tportletDisplay.setId(portlet.getPortletId());\n\t\tportletDisplay.setRootPortletId(portlet.getRootPortletId());\n\t\tportletDisplay.setInstanceId(portlet.getInstanceId());\n\t\tportletDisplay.setResourcePK(portletPrimaryKey);\n\t\tportletDisplay.setPortletName(portletConfig.getPortletName());\n\t\tportletDisplay.setNamespace(\n\t\t\tPortalUtil.getPortletNamespace(portlet.getPortletId()));\n\n\t\tWebDAVStorage webDAVStorage = portlet.getWebDAVStorageInstance();\n\n\t\tif (webDAVStorage != null) {\n\t\t\tportletDisplay.setWebDAVEnabled(true);\n\t\t}\n\t\telse {\n\t\t\tportletDisplay.setWebDAVEnabled(false);\n\t\t}\n\n\t\tResourceRequestImpl resourceRequestImpl = ResourceRequestFactory.create(\n\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\tResourceResponseImpl resourceResponseImpl =\n\t\t\tResourceResponseFactory.create(\n\t\t\t\tresourceRequestImpl, response, portlet.getPortletId(),\n\t\t\t\tcompanyId);\n\n\t\tresourceRequestImpl.defineObjects(portletConfig, resourceResponseImpl);\n\n\t\ttry {\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tresourceRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, ownerLayout, portlet,\n\t\t\t\tportletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.serveResource(\n\t\t\t\t\tresourceRequestImpl, resourceResponseImpl);\n\n\t\t\t\tresourceResponseImpl.transferHeaders(response);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","id":34386,"modified_method":"private void _doServeResource(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest ownerLayoutRequest = getOwnerLayoutRequestWrapper(\n\t\t\trequest, portlet);\n\n\t\tLayout ownerLayout = (Layout)ownerLayoutRequest.getAttribute(\n\t\t\tWebKeys.LAYOUT);\n\n\t\tboolean allowAddPortletDefaultResource =\n\t\t\tPortalUtil.isAllowAddPortletDefaultResource(\n\t\t\t\townerLayoutRequest, portlet);\n\n\t\tif (!allowAddPortletDefaultResource) {\n\t\t\tString url = null;\n\n\t\t\tLastPath lastPath = (LastPath)request.getAttribute(\n\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\tif (lastPath != null) {\n\t\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\t\tsb.append(PortalUtil.getPortalURL(request));\n\t\t\t\tsb.append(lastPath.getContextPath());\n\t\t\t\tsb.append(lastPath.getPath());\n\n\t\t\t\turl = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\turl = String.valueOf(request.getRequestURI());\n\t\t\t}\n\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\n\t\t\t_log.error(\n\t\t\t\t\"Reject serveResource for \" + url + \" on \" +\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tWindowState windowState = (WindowState)request.getAttribute(\n\t\t\tWebKeys.WINDOW_STATE);\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portlet.getPortletId());\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\tportletPreferencesIds);\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tString portletPrimaryKey = PortletPermissionUtil.getPrimaryKey(\n\t\t\tlayout.getPlid(), portlet.getPortletId());\n\n\t\tportletDisplay.setId(portlet.getPortletId());\n\t\tportletDisplay.setRootPortletId(portlet.getRootPortletId());\n\t\tportletDisplay.setInstanceId(portlet.getInstanceId());\n\t\tportletDisplay.setResourcePK(portletPrimaryKey);\n\t\tportletDisplay.setPortletName(portletConfig.getPortletName());\n\t\tportletDisplay.setNamespace(\n\t\t\tPortalUtil.getPortletNamespace(portlet.getPortletId()));\n\n\t\tWebDAVStorage webDAVStorage = portlet.getWebDAVStorageInstance();\n\n\t\tif (webDAVStorage != null) {\n\t\t\tportletDisplay.setWebDAVEnabled(true);\n\t\t}\n\t\telse {\n\t\t\tportletDisplay.setWebDAVEnabled(false);\n\t\t}\n\n\t\tResourceRequestImpl resourceRequestImpl = ResourceRequestFactory.create(\n\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\tResourceResponseImpl resourceResponseImpl =\n\t\t\tResourceResponseFactory.create(\n\t\t\t\tresourceRequestImpl, response, portlet.getPortletId(),\n\t\t\t\tcompanyId);\n\n\t\tresourceRequestImpl.defineObjects(portletConfig, resourceResponseImpl);\n\n\t\ttry {\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tresourceRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, ownerLayout, portlet,\n\t\t\t\tportletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.serveResource(\n\t\t\t\t\tresourceRequestImpl, resourceResponseImpl);\n\n\t\t\t\tresourceResponseImpl.transferHeaders(response);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","commit_id":"d52412dc22a2b80ab3eb55d78870e3eedb84e08d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private ActionResult _doProcessAction(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest ownerLayoutRequest = getOwnerLayoutRequestWrapper(\n\t\t\trequest, portlet);\n\n\t\tLayout ownerLayout = (Layout)ownerLayoutRequest.getAttribute(\n\t\t\tWebKeys.LAYOUT);\n\n\t\tboolean allowAddPortletDefaultResource =\n\t\t\tPortalUtil.isAllowAddPortletDefaultResource(\n\t\t\t\townerLayoutRequest, portlet);\n\n\t\tif (!allowAddPortletDefaultResource) {\n\t\t\tString url = null;\n\n\t\t\tLastPath lastPath = (LastPath)request.getAttribute(\n\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\tif (lastPath != null) {\n\t\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\t\tsb.append(PortalUtil.getPortalURL(request));\n\t\t\t\tsb.append(lastPath.getContextPath());\n\t\t\t\tsb.append(lastPath.getPath());\n\n\t\t\t\turl = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\turl = String.valueOf(request.getRequestURI());\n\t\t\t}\n\n\t\t\t_log.error(\n\t\t\t\t\"Reject processAction for \" + url + \" on \" +\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\treturn ActionResult.EMPTY_ACTION_RESULT;\n\t\t}\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tWindowState windowState = WindowStateFactory.getWindowState(\n\t\t\tParamUtil.getString(request, \"p_p_state\"));\n\n\t\tif (layout.isTypeControlPanel() &&\n\t\t\t((windowState == null) || windowState.equals(WindowState.NORMAL) ||\n\t\t\t Validator.isNull(windowState.toString()))) {\n\n\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t}\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portlet.getPortletId());\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\tif (allowAddPortletDefaultResource) {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\t\telse {\n\t\t\tportletPreferences =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getStrictPreferences(\n\t\t\t\t\tportletPreferencesIds);\n\t\t}\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tString contentType = request.getHeader(HttpHeaders.CONTENT_TYPE);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Content type \" + contentType);\n\t\t}\n\n\t\tUploadServletRequest uploadServletRequest = null;\n\n\t\ttry {\n\t\t\tif ((contentType != null) &&\n\t\t\t\tcontentType.startsWith(ContentTypes.MULTIPART_FORM_DATA)) {\n\n\t\t\t\tPortletConfigImpl invokerPortletConfigImpl =\n\t\t\t\t\t(PortletConfigImpl)invokerPortlet.getPortletConfig();\n\n\t\t\t\tif (invokerPortlet.isStrutsPortlet() ||\n\t\t\t\t\tinvokerPortletConfigImpl.isCopyRequestParameters() ||\n\t\t\t\t\t!invokerPortletConfigImpl.isWARFile()) {\n\n\t\t\t\t\tuploadServletRequest = new UploadServletRequestImpl(\n\t\t\t\t\t\trequest);\n\n\t\t\t\t\trequest = uploadServletRequest;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PropsValues.AUTH_TOKEN_CHECK_ENABLED &&\n\t\t\t\tinvokerPortlet.isCheckAuthToken()) {\n\n\t\t\t\tAuthTokenUtil.check(request);\n\t\t\t}\n\n\t\t\tActionRequestImpl actionRequestImpl = ActionRequestFactory.create(\n\t\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tActionResponseImpl actionResponseImpl =\n\t\t\t\tActionResponseFactory.create(\n\t\t\t\t\tactionRequestImpl, response, portlet.getPortletId(), user,\n\t\t\t\t\tlayout, windowState, portletMode);\n\n\t\t\tactionRequestImpl.defineObjects(portletConfig, actionResponseImpl);\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tactionRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, ownerLayout, portlet,\n\t\t\t\tportletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.processAction(\n\t\t\t\t\tactionRequestImpl, actionResponseImpl);\n\n\t\t\t\tactionResponseImpl.transferHeaders(response);\n\t\t\t}\n\n\t\t\tRenderParametersPool.put(\n\t\t\t\trequest, layout.getPlid(), portlet.getPortletId(),\n\t\t\t\tactionResponseImpl.getRenderParameterMap());\n\n\t\t\tList<Event> events = actionResponseImpl.getEvents();\n\n\t\t\tString redirectLocation = actionResponseImpl.getRedirectLocation();\n\n\t\t\tif (Validator.isNull(redirectLocation) &&\n\t\t\t\tportlet.isActionURLRedirect()) {\n\n\t\t\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\t\t\tactionRequestImpl, actionRequestImpl.getPortletName(),\n\t\t\t\t\tlayout.getPlid(), PortletRequest.RENDER_PHASE);\n\n\t\t\t\tMap<String, String[]> renderParameters =\n\t\t\t\t\tactionResponseImpl.getRenderParameterMap();\n\n\t\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\t\trenderParameters.entrySet()) {\n\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tString[] value = entry.getValue();\n\n\t\t\t\t\tportletURL.setParameter(key, value);\n\t\t\t\t}\n\n\t\t\t\tredirectLocation = portletURL.toString();\n\t\t\t}\n\n\t\t\treturn new ActionResult(events, redirectLocation);\n\t\t}\n\t\tfinally {\n\t\t\tif (uploadServletRequest != null) {\n\t\t\t\tuploadServletRequest.cleanUp();\n\t\t\t}\n\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","id":34387,"modified_method":"private ActionResult _doProcessAction(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPortlet portlet)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest ownerLayoutRequest = getOwnerLayoutRequestWrapper(\n\t\t\trequest, portlet);\n\n\t\tLayout ownerLayout = (Layout)ownerLayoutRequest.getAttribute(\n\t\t\tWebKeys.LAYOUT);\n\n\t\tboolean allowAddPortletDefaultResource =\n\t\t\tPortalUtil.isAllowAddPortletDefaultResource(\n\t\t\t\townerLayoutRequest, portlet);\n\n\t\tif (!allowAddPortletDefaultResource) {\n\t\t\tString url = null;\n\n\t\t\tLastPath lastPath = (LastPath)request.getAttribute(\n\t\t\t\tWebKeys.LAST_PATH);\n\n\t\t\tif (lastPath != null) {\n\t\t\t\tStringBundler sb = new StringBundler(3);\n\n\t\t\t\tsb.append(PortalUtil.getPortalURL(request));\n\t\t\t\tsb.append(lastPath.getContextPath());\n\t\t\t\tsb.append(lastPath.getPath());\n\n\t\t\t\turl = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\turl = String.valueOf(request.getRequestURI());\n\t\t\t}\n\n\t\t\t_log.error(\n\t\t\t\t\"Reject processAction for \" + url + \" on \" +\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\treturn ActionResult.EMPTY_ACTION_RESULT;\n\t\t}\n\n\t\tLayout layout = (Layout)request.getAttribute(WebKeys.LAYOUT);\n\n\t\tWindowState windowState = WindowStateFactory.getWindowState(\n\t\t\tParamUtil.getString(request, \"p_p_state\"));\n\n\t\tif (layout.isTypeControlPanel() &&\n\t\t\t((windowState == null) || windowState.equals(WindowState.NORMAL) ||\n\t\t\t Validator.isNull(windowState.toString()))) {\n\n\t\t\twindowState = WindowState.MAXIMIZED;\n\t\t}\n\n\t\tPortletMode portletMode = PortletModeFactory.getPortletMode(\n\t\t\tParamUtil.getString(request, \"p_p_mode\"));\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portlet.getPortletId());\n\n\t\tPortletPreferences portletPreferences =\n\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\tportletPreferencesIds);\n\n\t\tServletContext servletContext = (ServletContext)request.getAttribute(\n\t\t\tWebKeys.CTX);\n\n\t\tInvokerPortlet invokerPortlet = PortletInstanceFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\n\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\tportlet, servletContext);\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tString contentType = request.getHeader(HttpHeaders.CONTENT_TYPE);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Content type \" + contentType);\n\t\t}\n\n\t\tUploadServletRequest uploadServletRequest = null;\n\n\t\ttry {\n\t\t\tif ((contentType != null) &&\n\t\t\t\tcontentType.startsWith(ContentTypes.MULTIPART_FORM_DATA)) {\n\n\t\t\t\tPortletConfigImpl invokerPortletConfigImpl =\n\t\t\t\t\t(PortletConfigImpl)invokerPortlet.getPortletConfig();\n\n\t\t\t\tif (invokerPortlet.isStrutsPortlet() ||\n\t\t\t\t\tinvokerPortletConfigImpl.isCopyRequestParameters() ||\n\t\t\t\t\t!invokerPortletConfigImpl.isWARFile()) {\n\n\t\t\t\t\tuploadServletRequest = new UploadServletRequestImpl(\n\t\t\t\t\t\trequest);\n\n\t\t\t\t\trequest = uploadServletRequest;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PropsValues.AUTH_TOKEN_CHECK_ENABLED &&\n\t\t\t\tinvokerPortlet.isCheckAuthToken()) {\n\n\t\t\t\tAuthTokenUtil.check(request);\n\t\t\t}\n\n\t\t\tActionRequestImpl actionRequestImpl = ActionRequestFactory.create(\n\t\t\t\trequest, portlet, invokerPortlet, portletContext, windowState,\n\t\t\t\tportletMode, portletPreferences, layout.getPlid());\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tActionResponseImpl actionResponseImpl =\n\t\t\t\tActionResponseFactory.create(\n\t\t\t\t\tactionRequestImpl, response, portlet.getPortletId(), user,\n\t\t\t\t\tlayout, windowState, portletMode);\n\n\t\t\tactionRequestImpl.defineObjects(portletConfig, actionResponseImpl);\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tactionRequestImpl);\n\n\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\t\tboolean access = PortletPermissionUtil.hasAccessPermission(\n\t\t\t\tpermissionChecker, scopeGroupId, ownerLayout, portlet,\n\t\t\t\tportletMode);\n\n\t\t\tif (access) {\n\t\t\t\tinvokerPortlet.processAction(\n\t\t\t\t\tactionRequestImpl, actionResponseImpl);\n\n\t\t\t\tactionResponseImpl.transferHeaders(response);\n\t\t\t}\n\n\t\t\tRenderParametersPool.put(\n\t\t\t\trequest, layout.getPlid(), portlet.getPortletId(),\n\t\t\t\tactionResponseImpl.getRenderParameterMap());\n\n\t\t\tList<Event> events = actionResponseImpl.getEvents();\n\n\t\t\tString redirectLocation = actionResponseImpl.getRedirectLocation();\n\n\t\t\tif (Validator.isNull(redirectLocation) &&\n\t\t\t\tportlet.isActionURLRedirect()) {\n\n\t\t\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\t\t\tactionRequestImpl, actionRequestImpl.getPortletName(),\n\t\t\t\t\tlayout.getPlid(), PortletRequest.RENDER_PHASE);\n\n\t\t\t\tMap<String, String[]> renderParameters =\n\t\t\t\t\tactionResponseImpl.getRenderParameterMap();\n\n\t\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\t\trenderParameters.entrySet()) {\n\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tString[] value = entry.getValue();\n\n\t\t\t\t\tportletURL.setParameter(key, value);\n\t\t\t\t}\n\n\t\t\t\tredirectLocation = portletURL.toString();\n\t\t\t}\n\n\t\t\treturn new ActionResult(events, redirectLocation);\n\t\t}\n\t\tfinally {\n\t\t\tif (uploadServletRequest != null) {\n\t\t\t\tuploadServletRequest.cleanUp();\n\t\t\t}\n\n\t\t\tServiceContextThreadLocal.popServiceContext();\n\t\t}\n\t}","commit_id":"d52412dc22a2b80ab3eb55d78870e3eedb84e08d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Create a new Patch instance using the specified broker and diff document.\n     *\n     * @param broker the DBBroker to use\n     * @param diff the diff document to apply\n     *\n     * @throws XPathException\n     */\n    public Patch(DBBroker broker, DocumentImpl diff) throws XPathException {\n        this.broker = broker;\n        parseDiff(broker, diff);\n    }","id":34388,"modified_method":"/**\n     * Create a new Patch instance using the specified broker and diff document.\n     *\n     * @param broker the DBBroker to use\n     * @param diff the diff document to apply\n     *\n     * @throws XPathException\n     */\n    public Patch(DBBroker broker, DocumentImpl diff) throws XPathException {\n        this.broker = broker;\n        this.diffDoc = diff;\n        parseDiff(broker, diff);\n    }","commit_id":"105d00e3e06574a1502f72d8d1f599d01d3c969d","url":"https://github.com/eXist-db/exist"},{"original_method":"private void copyNode(ExtendedXMLStreamReader reader, Receiver receiver, int status) throws SAXException, XMLStreamException, IOException {\n        switch (status) {\n            case XMLStreamReader.START_ELEMENT:\n                AttrList attrs = new AttrList();\n                for (int i = 0; i < reader.getAttributeCount(); i++) {\n                    // check if an attribute has to be inserted before the current attribute\n                    NodeId nodeId = reader.getAttributeId(i);\n\n                    // check if an attribute has to be inserted before the current attribute\n                    ElementImpl insertedNode = (ElementImpl) insertedNodes.get(nodeId);\n                    if (insertedNode != null) {\n                        StoredNode child = (StoredNode) insertedNode.getFirstChild();\n                        while (child != null) {\n                            if (XMLDiff.NAMESPACE.equals(child.getNamespaceURI()) && \"attribute\".equals(child.getLocalName())) {\n                                NamedNodeMap map = child.getAttributes();\n                                for (int j = 0; j < map.getLength(); j++) {\n                                    AttrImpl attr = (AttrImpl) map.item(j);\n                                    if (!attr.getName().startsWith(\"xmlns\"))\n                                        attrs.addAttribute(attr.getQName(), attr.getValue(),\n                                                attr.getType(), attr.getNodeId());\n                                }\n                            }\n                            child = (StoredNode) child.getNextSibling();\n                        }\n                    }\n\n                    if (deletedNodes.get(nodeId) == null) {\n                        QName attrQn = new QName(reader.getAttributeLocalName(i), reader.getAttributeNamespace(i),\n                                reader.getAttributePrefix(i));\n                        attrs.addAttribute(\n                                attrQn,\n                                reader.getAttributeValue(i),\n                                getAttributeType(reader.getAttributeType(i))\n                        );\n                    }\n                }\n                receiver.startElement(new QName(reader.getLocalName(), reader.getNamespaceURI(), reader.getPrefix()),\n                        attrs);\n                break;\n            case XMLStreamReader.END_ELEMENT:\n                receiver.endElement(new QName(reader.getLocalName(), reader.getNamespaceURI(), reader.getPrefix()));\n                break;\n            case XMLStreamReader.CHARACTERS:\n                receiver.characters(reader.getText());\n                break;\n            case XMLStreamReader.CDATA:\n                char[] cdata = reader.getTextCharacters();\n                receiver.cdataSection(cdata, 0, cdata.length);\n                break;\n            case XMLStreamReader.PROCESSING_INSTRUCTION:\n                receiver.processingInstruction(reader.getPITarget(), reader.getPIData());\n                break;\n            case XMLStreamReader.COMMENT:\n                char[] ch = reader.getTextCharacters();\n                receiver.comment(ch, 0, ch.length);\n                break;\n        }\n    }","id":34389,"modified_method":"private void copyNode(ExtendedXMLStreamReader reader, Receiver receiver, int status,\n                          boolean onFirstNode, String changeMessage) throws SAXException, XMLStreamException, IOException {\n        AttrList attrs;\n        switch (status) {\n            case XMLStreamReader.START_ELEMENT:\n                attrs = new AttrList();\n                if (annotate) {\n                    if (onFirstNode)\n                        attrs.addAttribute(ATTR_CHANGE, changeMessage);\n                    else {\n                        NodeId nodeId = (NodeId) reader.getProperty(EmbeddedXMLStreamReader.PROPERTY_NODE_ID);\n                        if (changeSet.hasDescendantsInSet(diffDoc, nodeId, false, -1) != null)\n                            attrs.addAttribute(ATTR_CHANGE, \"changed\");\n                    }\n                    if (elementStack.size() == 0)\n                        receiver.startPrefixMapping(XMLDiff.PREFIX, XMLDiff.NAMESPACE);\n                }\n\n                for (int i = 0; i < reader.getAttributeCount(); i++) {\n                    // check if an attribute has to be inserted before the current attribute\n                    NodeId nodeId = reader.getAttributeId(i);\n\n                    // check if an attribute has to be inserted before the current attribute\n                    ElementImpl insertedNode = (ElementImpl) insertedNodes.get(nodeId);\n                    if (insertedNode != null) {\n                        StoredNode child = (StoredNode) insertedNode.getFirstChild();\n                        while (child != null) {\n                            if (XMLDiff.NAMESPACE.equals(child.getNamespaceURI()) && \"attribute\".equals(child.getLocalName())) {\n                                NamedNodeMap map = child.getAttributes();\n                                for (int j = 0; j < map.getLength(); j++) {\n                                    AttrImpl attr = (AttrImpl) map.item(j);\n                                    if (!attr.getName().startsWith(\"xmlns\"))\n                                        attrs.addAttribute(attr.getQName(), attr.getValue(),\n                                                attr.getType(), attr.getNodeId());\n                                }\n                            }\n                            child = (StoredNode) child.getNextSibling();\n                        }\n                    }\n\n                    if (deletedNodes.get(nodeId) == null) {\n                        QName attrQn = new QName(reader.getAttributeLocalName(i), reader.getAttributeNamespace(i),\n                                reader.getAttributePrefix(i));\n                        attrs.addAttribute(\n                                attrQn,\n                                reader.getAttributeValue(i),\n                                getAttributeType(reader.getAttributeType(i))\n                        );\n                    }\n                }\n                QName qn = new QName(reader.getLocalName(), reader.getNamespaceURI(), reader.getPrefix());\n                receiver.startElement(qn, attrs);\n                if (elementStack != null)\n                    elementStack.push(qn);\n                break;\n            case XMLStreamReader.END_ELEMENT:\n                receiver.endElement(new QName(reader.getLocalName(), reader.getNamespaceURI(), reader.getPrefix()));\n                if (elementStack != null) {\n                    if (elementStack.isEmpty())\n                        receiver.endPrefixMapping(XMLDiff.PREFIX);\n                    elementStack.pop();\n                }\n                break;\n            case XMLStreamReader.CHARACTERS:\n                if (onFirstNode && annotate) {\n                    attrs = new AttrList();\n                    attrs.addAttribute(ATTR_CHANGE, changeMessage);\n                    receiver.startElement(ELEMENT_WRAPPER, attrs);\n                }\n                receiver.characters(reader.getText());\n                if (onFirstNode && annotate)\n                    receiver.endElement(ELEMENT_WRAPPER);\n                break;\n            case XMLStreamReader.CDATA:\n                if (onFirstNode && annotate)\n                    receiver.startElement(ELEMENT_WRAPPER, null);\n                char[] cdata = reader.getTextCharacters();\n                receiver.cdataSection(cdata, 0, cdata.length);\n                if (onFirstNode && annotate)\n                    receiver.endElement(ELEMENT_WRAPPER);\n                break;\n            case XMLStreamReader.PROCESSING_INSTRUCTION:\n                receiver.processingInstruction(reader.getPITarget(), reader.getPIData());\n                break;\n            case XMLStreamReader.COMMENT:\n                char[] ch = reader.getTextCharacters();\n                receiver.comment(ch, 0, ch.length);\n                break;\n        }\n    }","commit_id":"105d00e3e06574a1502f72d8d1f599d01d3c969d","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Apply the diff to the given source data stream passed as an XMLStreamReader. Write\n     * output to the specified receiver.\n     *\n     * @throws DiffException\n     */\n    public void patch(ExtendedXMLStreamReader reader, Receiver receiver) throws DiffException {\n        try {\n            NodeId skipSubtree = null;\n            while (reader.hasNext()) {\n                int status = reader.next();\n                NodeId nodeId = (NodeId) reader.getProperty(EmbeddedXMLStreamReader.PROPERTY_NODE_ID);\n                if (status != XMLStreamReader.END_ELEMENT) {\n                    ElementImpl insertedNode = (ElementImpl) insertedNodes.get(nodeId);\n                    if (insertedNode != null) {\n                        insertNode(insertedNode, receiver);\n                    }\n                } else {\n                    ElementImpl appendedNode = (ElementImpl) appendedNodes.get(nodeId);\n                    if (appendedNode != null) {\n                        insertNode(appendedNode, receiver);\n                    }\n                }\n                String opt = (String) deletedNodes.get(nodeId);\n                if (opt == D_SUBTREE) {\n                    if (status == XMLStreamReader.START_ELEMENT)\n                        skipSubtree = nodeId;\n                } else if (opt == D_BOTH) {\n                    //skip\n                } else if (opt == D_END && status == XMLStreamReader.END_ELEMENT) {\n                    // skip\n                } else if (opt == D_START && status == XMLStreamReader.START_ELEMENT) {\n                    // skip\n                } else if (skipSubtree == null)\n                    copyNode(reader, receiver, status);\n                if (status == XMLStreamReader.END_ELEMENT && skipSubtree != null &&\n                        skipSubtree.equals(nodeId))\n                    skipSubtree = null;\n            }\n        } catch (XMLStreamException e) {\n            throw new DiffException(\"Caught exception while reading source document for patch: \" +\n                    e.getMessage(), e);\n        } catch (IOException e) {\n            throw new DiffException(\"Caught exception while patching document: \" + e.getMessage(), e);\n        } catch (SAXException e) {\n            throw new DiffException(\"Caught exception while serializing patch output: \" + e.getMessage(), e);\n        }\n    }","id":34390,"modified_method":"/**\n     * Apply the diff to the given source data stream passed as an XMLStreamReader. Write\n     * output to the specified receiver.\n     *\n     * @throws DiffException\n     */\n    public void patch(ExtendedXMLStreamReader reader, Receiver receiver) throws DiffException {\n        annotate = false;\n        try {\n            NodeId skipSubtree = null;\n            while (reader.hasNext()) {\n                int status = reader.next();\n                NodeId nodeId = (NodeId) reader.getProperty(EmbeddedXMLStreamReader.PROPERTY_NODE_ID);\n                if (status != XMLStreamReader.END_ELEMENT) {\n                    ElementImpl insertedNode = (ElementImpl) insertedNodes.get(nodeId);\n                    if (insertedNode != null) {\n                        insertNode(insertedNode, receiver, null);\n                    }\n                } else {\n                    ElementImpl appendedNode = (ElementImpl) appendedNodes.get(nodeId);\n                    if (appendedNode != null) {\n                        insertNode(appendedNode, receiver, null);\n                    }\n                }\n                String opt = (String) deletedNodes.get(nodeId);\n                if (opt == D_SUBTREE) {\n                    if (status == XMLStreamReader.START_ELEMENT)\n                        skipSubtree = nodeId;\n                } else if (opt == D_BOTH) {\n                    //skip\n                } else if (opt == D_END && status == XMLStreamReader.END_ELEMENT) {\n                    // skip\n                } else if (opt == D_START && status == XMLStreamReader.START_ELEMENT) {\n                    // skip\n                } else if (skipSubtree == null)\n                    copyNode(reader, receiver, status, false, null);\n                if (status == XMLStreamReader.END_ELEMENT && skipSubtree != null &&\n                        skipSubtree.equals(nodeId))\n                    skipSubtree = null;\n            }\n        } catch (XMLStreamException e) {\n            throw new DiffException(\"Caught exception while reading source document for patch: \" +\n                    e.getMessage(), e);\n        } catch (IOException e) {\n            throw new DiffException(\"Caught exception while patching document: \" + e.getMessage(), e);\n        } catch (SAXException e) {\n            throw new DiffException(\"Caught exception while serializing patch output: \" + e.getMessage(), e);\n        }\n    }","commit_id":"105d00e3e06574a1502f72d8d1f599d01d3c969d","url":"https://github.com/eXist-db/exist"},{"original_method":"private void insertNode(StoredNode insertedNode, Receiver receiver) throws XMLStreamException, IOException, SAXException {\n        ExtendedXMLStreamReader reader = broker.newXMLStreamReader(insertedNode, false);\n        reader.next();\n        while (reader.hasNext()) {\n            int status = reader.next();\n            if ((status == XMLStreamReader.START_ELEMENT || status == XMLStreamReader.END_ELEMENT) &&\n                    XMLDiff.NAMESPACE.equals(reader.getNamespaceURI())) {\n                if (status == XMLStreamReader.START_ELEMENT) {\n                    if (\"attribute\".equals(reader.getLocalName())) {\n                        int attrCount = reader.getAttributeCount();\n                        for (int i = 0; i < attrCount; i++) {\n                            QName qname = reader.getAttributeQName(i);\n                            receiver.attribute(qname, reader.getAttributeValue(i));\n                        }\n                    } else if (\"comment\".equals(reader.getLocalName())) {\n                        StringBuffer buf = new StringBuffer();\n                        while (reader.hasNext()) {\n                            status = reader.next();\n                            if (status == XMLStreamReader.END_ELEMENT &&\n                                    reader.getNamespaceURI().equals(XMLDiff.NAMESPACE) &&\n                                    reader.getLocalName().equals(\"comment\"))\n                                break;\n                            if (status == XMLStreamReader.CHARACTERS)\n                                buf.append(reader.getText());\n                        }\n                        char[] ch = buf.toString().toCharArray();\n                        receiver.comment(ch, 0, ch.length);\n                    } else if (\"start\".equals(reader.getLocalName())) {\n                        String namespace = reader.getAttributeValue(\"\", \"namespace\");\n                        String name = reader.getAttributeValue(\"\", \"name\");\n                        receiver.startElement(new QName(QName.extractLocalName(name), namespace, QName.extractPrefix(name)), null);\n                    } else if (\"end\".equals(reader.getLocalName())) {\n                        String namespace = reader.getAttributeValue(\"\", \"namespace\");\n                        String name = reader.getAttributeValue(\"\", \"name\");\n                        receiver.endElement(new QName(QName.extractLocalName(name), namespace, QName.extractPrefix(name)));\n                    }\n                }\n            } else {\n                copyNode(reader, receiver, status);\n            }\n        }\n    }","id":34391,"modified_method":"private void insertNode(StoredNode insertedNode, Receiver receiver, String changeMessage) throws XMLStreamException, IOException, SAXException {\n        ExtendedXMLStreamReader reader = broker.newXMLStreamReader(insertedNode, false);\n        reader.next();\n        int treeLevel = 0;\n        while (reader.hasNext()) {\n            int status = reader.next();\n            if ((status == XMLStreamReader.START_ELEMENT || status == XMLStreamReader.END_ELEMENT) &&\n                    XMLDiff.NAMESPACE.equals(reader.getNamespaceURI())) {\n                if (status == XMLStreamReader.START_ELEMENT) {\n                    if (\"attribute\".equals(reader.getLocalName())) {\n                        int attrCount = reader.getAttributeCount();\n                        for (int i = 0; i < attrCount; i++) {\n                            QName qname = reader.getAttributeQName(i);\n                            receiver.attribute(qname, reader.getAttributeValue(i));\n                        }\n                    } else if (\"comment\".equals(reader.getLocalName())) {\n                        StringBuffer buf = new StringBuffer();\n                        while (reader.hasNext()) {\n                            status = reader.next();\n                            if (status == XMLStreamReader.END_ELEMENT &&\n                                    reader.getNamespaceURI().equals(XMLDiff.NAMESPACE) &&\n                                    reader.getLocalName().equals(\"comment\"))\n                                break;\n                            if (status == XMLStreamReader.CHARACTERS)\n                                buf.append(reader.getText());\n                        }\n                        char[] ch = buf.toString().toCharArray();\n                        receiver.comment(ch, 0, ch.length);\n                    } else if (\"start\".equals(reader.getLocalName())) {\n                        String namespace = reader.getAttributeValue(\"\", \"namespace\");\n                        String name = reader.getAttributeValue(\"\", \"name\");\n                        receiver.startElement(new QName(QName.extractLocalName(name), namespace, QName.extractPrefix(name)), null);\n                    } else if (\"end\".equals(reader.getLocalName())) {\n                        String namespace = reader.getAttributeValue(\"\", \"namespace\");\n                        String name = reader.getAttributeValue(\"\", \"name\");\n                        receiver.endElement(new QName(QName.extractLocalName(name), namespace, QName.extractPrefix(name)));\n                    }\n                }\n            } else {\n                copyNode(reader, receiver, status, treeLevel == 0, changeMessage);\n                if (status == XMLStreamReader.START_ELEMENT)\n                    treeLevel++;\n                else if (status == XMLStreamReader.END_ELEMENT)\n                    treeLevel--;\n            }\n        }\n    }","commit_id":"105d00e3e06574a1502f72d8d1f599d01d3c969d","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        context.pushDocumentContext();\n        try {\n            ExtendedXMLStreamReader reader;\n            NodeValue nv = (NodeValue) args[0].itemAt(0);\n            if (nv.getImplementationType() == NodeValue.IN_MEMORY_NODE) {\n                NodeImpl node = (NodeImpl) nv;\n                reader = new InMemoryXMLStreamReader(node.getDocument(), node.getDocument());\n            } else {\n                NodeProxy proxy = (NodeProxy) nv;\n                reader = context.getBroker().newXMLStreamReader(new NodeProxy(proxy.getDocument(), NodeId.DOCUMENT_NODE, proxy.getDocument().getFirstChildAddress()), false);\n            }\n\n            nv = (NodeValue) args[1].itemAt(0);\n            if (nv.getImplementationType() == NodeValue.IN_MEMORY_NODE)\n                throw new XPathException(\"patch cannot be applied to in-memory documents\");\n            NodeProxy diffProxy = (NodeProxy) nv;\n            DocumentImpl diff = diffProxy.getDocument();\n        \n            MemTreeBuilder builder = context.getDocumentBuilder();\n            DocumentBuilderReceiver receiver = new DocumentBuilderReceiver(builder);\n            Patch patch = new Patch(context.getBroker(), diff);\n            patch.patch(reader, receiver);\n            NodeValue result = (NodeValue) builder.getDocument().getDocumentElement();\n            return result == null ? Sequence.EMPTY_SEQUENCE : result;\n        } catch (IOException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        } catch (XMLStreamException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        } catch (DiffException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        } finally {\n            context.popDocumentContext();\n        }\n    }","id":34392,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        context.pushDocumentContext();\n        try {\n            ExtendedXMLStreamReader reader;\n            NodeValue nv = (NodeValue) args[0].itemAt(0);\n            if (nv.getImplementationType() == NodeValue.IN_MEMORY_NODE) {\n                NodeImpl node = (NodeImpl) nv;\n                reader = new InMemoryXMLStreamReader(node.getDocument(), node.getDocument());\n            } else {\n                NodeProxy proxy = (NodeProxy) nv;\n                reader = context.getBroker().newXMLStreamReader(new NodeProxy(proxy.getDocument(), NodeId.DOCUMENT_NODE, proxy.getDocument().getFirstChildAddress()), false);\n            }\n\n            nv = (NodeValue) args[1].itemAt(0);\n            if (nv.getImplementationType() == NodeValue.IN_MEMORY_NODE)\n                throw new XPathException(\"patch cannot be applied to in-memory documents\");\n            NodeProxy diffProxy = (NodeProxy) nv;\n            DocumentImpl diff = diffProxy.getDocument();\n        \n            MemTreeBuilder builder = context.getDocumentBuilder();\n            DocumentBuilderReceiver receiver = new DocumentBuilderReceiver(builder);\n            Patch patch = new Patch(context.getBroker(), diff);\n            if (isCalledAs(\"annotate\"))\n                patch.annotate(reader, receiver);\n            else\n                patch.patch(reader, receiver);\n            NodeValue result = (NodeValue) builder.getDocument().getDocumentElement();\n            return result == null ? Sequence.EMPTY_SEQUENCE : result;\n        } catch (IOException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        } catch (XMLStreamException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        } catch (DiffException e) {\n            throw new XPathException(getASTNode(), e.getMessage(), e);\n        } finally {\n            context.popDocumentContext();\n        }\n    }","commit_id":"105d00e3e06574a1502f72d8d1f599d01d3c969d","url":"https://github.com/eXist-db/exist"},{"original_method":"public PatchFunction(XQueryContext context) {\n        super(context, signature);\n    }","id":34393,"modified_method":"public PatchFunction(XQueryContext context, FunctionSignature signature) {\n        super(context, signature);\n    }","commit_id":"105d00e3e06574a1502f72d8d1f599d01d3c969d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void finish(int event, DBBroker broker, Txn transaction, XmldbURI documentPath, DocumentImpl document) {\n        User activeUser = broker.getUser();\n        try {\n            broker.setUser(org.exist.security.SecurityManager.SYSTEM_USER);\n            if (event == STORE_DOCUMENT_EVENT) {\n                try {\n                    Collection collection = document.getCollection();\n                    if (collection.getURI().startsWith(VERSIONS_COLLECTION))\n                        return;\n                    vCollection = getCollection(broker, transaction, documentPath.removeLastSegment());\n\n                    String existingURI = document.getFileURI().toString();\n                    XmldbURI deletedURI = XmldbURI.create(existingURI + DELETED_SUFFIX);\n                    lastRev = vCollection.getDocument(broker, deletedURI);\n                    if (lastRev == null) {\n                        lastRev = vCollection.getDocument(broker, XmldbURI.create(existingURI + BASE_SUFFIX));\n                        removeLast = false;\n                    } else\n                        removeLast = true;\n                } catch (IOException e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } catch (PermissionDeniedException e) {\n                    LOG.warn(\"Permission denied in VersioningTrigger: \" + e.getMessage(), e);\n                }\n            }\n            if (lastRev != null || event == REMOVE_DOCUMENT_EVENT) {\n                XMLDiff diff = new XMLDiff(broker);\n                if (documentPath.isCollectionPathAbsolute())\n                    documentPath = documentPath.lastSegment();\n                DocumentImpl base = null;\n                try {\n                    vCollection.setTriggersEnabled(false);\n\n                    long rev = newRevision(broker.getBrokerPool());\n                    Properties properties = new Properties();\n                    properties.setProperty(\"document\", documentPath.toString());\n                    properties.setProperty(\"revision\", Long.toString(rev));\n                    properties.setProperty(\"date\", new DateTimeValue(new Date()).getStringValue());\n                    properties.setProperty(\"user\", broker.getUser().getName());\n                    StringWriter writer = new StringWriter();\n                    SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(\n                            SAXSerializer.class);\n                    Properties outputProperties = new Properties();\n                    outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n                    outputProperties.setProperty(OutputKeys.INDENT, \"no\");\n                    sax.setOutput(writer, outputProperties);\n                    sax.startDocument();\n\n                    sax.startElement(ELEMENT_VERSION, null);\n                    writeProperties(sax, properties);\n                    if (event == REMOVE_DOCUMENT_EVENT) {\n                        sax.startElement(ELEMENT_REMOVED, null);\n                        sax.endElement(ELEMENT_REMOVED);\n                    } else {\n                        diff.diff(lastRev, document);\n                        diff.diff2XML(sax);\n                    }\n                    sax.endElement(ELEMENT_VERSION);\n\n                    sax.endDocument();\n                    String editscript = writer.toString();\n\n                    System.out.println(\"documentPath: \" + documentPath);\n                    System.out.println(editscript);\n\n                    if (removeLast)\n                        vCollection.removeXMLResource(transaction, broker, lastRev.getFileURI());\n\n                    XmldbURI diffUri = XmldbURI.createInternal(documentPath.toString() + '.' + rev);\n                    IndexInfo info = vCollection.validateXMLResource(transaction, broker, diffUri, editscript);\n                    vCollection.store(transaction, broker, info, editscript, false);\n                } catch (Exception e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } finally {\n                    if (base != null)\n                        base.getUpdateLock().release(Lock.READ_LOCK);\n                    vCollection.setTriggersEnabled(true);\n                }\n            }\n        } finally {\n            broker.setUser(activeUser);\n        }\n    }","id":34394,"modified_method":"public void finish(int event, DBBroker broker, Txn transaction, XmldbURI documentPath, DocumentImpl document) {\n        User activeUser = broker.getUser();\n        try {\n            broker.setUser(org.exist.security.SecurityManager.SYSTEM_USER);\n            if (event == STORE_DOCUMENT_EVENT) {\n                try {\n                    Collection collection = document.getCollection();\n                    if (collection.getURI().startsWith(VERSIONS_COLLECTION))\n                        return;\n                    vCollection = getCollection(broker, transaction, documentPath.removeLastSegment());\n\n                    String existingURI = document.getFileURI().toString();\n                    XmldbURI deletedURI = XmldbURI.create(existingURI + DELETED_SUFFIX);\n                    lastRev = vCollection.getDocument(broker, deletedURI);\n                    if (lastRev == null) {\n                        lastRev = vCollection.getDocument(broker, XmldbURI.create(existingURI + BASE_SUFFIX));\n                        removeLast = false;\n                    } else\n                        removeLast = true;\n                } catch (IOException e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } catch (PermissionDeniedException e) {\n                    LOG.warn(\"Permission denied in VersioningTrigger: \" + e.getMessage(), e);\n                }\n            }\n            if (lastRev != null || event == REMOVE_DOCUMENT_EVENT) {\n                XMLDiff diff = new XMLDiff(broker);\n                if (documentPath.isCollectionPathAbsolute())\n                    documentPath = documentPath.lastSegment();\n                DocumentImpl base = null;\n                try {\n                    vCollection.setTriggersEnabled(false);\n\n                    long rev = newRevision(broker.getBrokerPool());\n                    Properties properties = new Properties();\n                    properties.setProperty(\"document\", documentPath.toString());\n                    properties.setProperty(\"revision\", Long.toString(rev));\n                    properties.setProperty(\"date\", new DateTimeValue(new Date()).getStringValue());\n                    properties.setProperty(\"user\", broker.getUser().getName());\n                    StringWriter writer = new StringWriter();\n                    SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(\n                            SAXSerializer.class);\n                    Properties outputProperties = new Properties();\n                    outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n                    outputProperties.setProperty(OutputKeys.INDENT, \"no\");\n                    sax.setOutput(writer, outputProperties);\n                    sax.startDocument();\n\n                    sax.startElement(ELEMENT_VERSION, null);\n                    writeProperties(sax, properties);\n                    if (event == REMOVE_DOCUMENT_EVENT) {\n                        sax.startElement(ELEMENT_REMOVED, null);\n                        sax.endElement(ELEMENT_REMOVED);\n                    } else {\n                        diff.diff(lastRev, document);\n                        diff.diff2XML(sax);\n                    }\n                    sax.endElement(ELEMENT_VERSION);\n\n                    sax.endDocument();\n                    String editscript = writer.toString();\n\n//                    System.out.println(\"documentPath: \" + documentPath);\n//                    System.out.println(editscript);\n\n                    if (removeLast)\n                        vCollection.removeXMLResource(transaction, broker, lastRev.getFileURI());\n\n                    XmldbURI diffUri = XmldbURI.createInternal(documentPath.toString() + '.' + rev);\n                    IndexInfo info = vCollection.validateXMLResource(transaction, broker, diffUri, editscript);\n                    vCollection.store(transaction, broker, info, editscript, false);\n                } catch (Exception e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } finally {\n                    if (base != null)\n                        base.getUpdateLock().release(Lock.READ_LOCK);\n                    vCollection.setTriggersEnabled(true);\n                }\n            }\n        } finally {\n            broker.setUser(activeUser);\n        }\n    }","commit_id":"105d00e3e06574a1502f72d8d1f599d01d3c969d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void executeAsynchronousGet(String urlPath) throws Exception {\n\t\tSession session = SessionManager.getSession(_syncAccountId);\n\n\t\t_httpGet = new HttpGet(urlPath);\n\n\t\tsession.asynchronousExecute(_httpGet, _handler);\n\t}","id":34395,"modified_method":"public void executeAsynchronousGet(HttpGet httpGet) throws Exception {\n\t\tSession session = SessionManager.getSession(_syncAccountId);\n\n\t\t_httpGet = httpGet;\n\n\t\tsession.asynchronousExecute(_httpGet, _handler);\n\t}","commit_id":"051f0bd5080a9bd01e3c5b2c6b452f8e30dc0e0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Void handleResponse(HttpResponse httpResponse) {\n\t\ttry {\n\t\t\tStatusLine statusLine = httpResponse.getStatusLine();\n\n\t\t\tif (statusLine.getStatusCode() != HttpStatus.SC_OK) {\n\t\t\t\t_logger.error(\"Status code {}\", statusLine.getStatusCode());\n\n\t\t\t\tthrow new HttpResponseException(\n\t\t\t\t\tstatusLine.getStatusCode(), statusLine.getReasonPhrase());\n\t\t\t}\n\n\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\tClass<?> clazz = getClass();\n\n\t\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\t\tif (syncFile != null) {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Handling response {} file path {}\",\n\t\t\t\t\t\t\tclazz.getSimpleName(), syncFile.getFilePathName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Handling response {}\", clazz.getSimpleName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoHandleResponse(httpResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\thandleException(e);\n\t\t}\n\t\tfinally {\n\t\t\tprocessFinally();\n\t\t}\n\n\t\treturn null;\n\t}","id":34396,"modified_method":"@Override\n\tpublic Void handleResponse(HttpResponse httpResponse) {\n\t\ttry {\n\t\t\tStatusLine statusLine = httpResponse.getStatusLine();\n\n\t\t\tif ((statusLine.getStatusCode() != HttpStatus.SC_OK) &&\n\t\t\t\t(statusLine.getStatusCode() != HttpStatus.SC_PARTIAL_CONTENT)) {\n\n\t\t\t\t_logger.error(\"Status code {}\", statusLine.getStatusCode());\n\n\t\t\t\tthrow new HttpResponseException(\n\t\t\t\t\tstatusLine.getStatusCode(), statusLine.getReasonPhrase());\n\t\t\t}\n\n\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\tClass<?> clazz = getClass();\n\n\t\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\t\tif (syncFile != null) {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Handling response {} file path {}\",\n\t\t\t\t\t\t\tclazz.getSimpleName(), syncFile.getFilePathName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Handling response {}\", clazz.getSimpleName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoHandleResponse(httpResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\thandleException(e);\n\t\t}\n\t\tfinally {\n\t\t\tprocessFinally();\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"051f0bd5080a9bd01e3c5b2c6b452f8e30dc0e0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\tsyncFile.setPreviousModifiedTime(\n\t\t\tFileUtil.getLastModifiedTime(filePath));\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tif ((boolean)getParameterValue(\"batch\")) {\n\t\t\tBatchDownloadEvent batchDownloadEvent =\n\t\t\t\tBatchEventManager.getBatchDownloadEvent(getSyncAccountId());\n\n\t\t\tif (batchDownloadEvent.addEvent(this)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tsb.append(syncAccount.getUrl());\n\n\t\tsb.append(_URL_PATH);\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getRepositoryId());\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getTypeUuid());\n\n\t\tif ((Boolean)getParameterValue(\"patch\")) {\n\t\t\tsb.append(\"?patch=true&sourceVersionId=\");\n\t\t\tsb.append(getParameterValue(\"sourceVersionId\"));\n\t\t\tsb.append(\"&targetVersionId=\");\n\t\t\tsb.append(getParameterValue(\"targetVersionId\"));\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"?version=\");\n\t\t\tsb.append(syncFile.getVersion());\n\t\t}\n\n\t\texecuteAsynchronousGet(sb.toString());\n\t}","id":34397,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\tsyncFile.setPreviousModifiedTime(\n\t\t\tFileUtil.getLastModifiedTime(filePath));\n\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\tSyncFileService.update(syncFile);\n\n\t\tif ((boolean)getParameterValue(\"batch\")) {\n\t\t\tBatchDownloadEvent batchDownloadEvent =\n\t\t\t\tBatchEventManager.getBatchDownloadEvent(getSyncAccountId());\n\n\t\t\tif (batchDownloadEvent.addEvent(this)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tsb.append(syncAccount.getUrl());\n\n\t\tsb.append(_URL_PATH);\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getRepositoryId());\n\t\tsb.append(\"/\");\n\t\tsb.append(syncFile.getTypeUuid());\n\n\t\tif ((Boolean)getParameterValue(\"patch\")) {\n\t\t\tsb.append(\"?patch=true&sourceVersionId=\");\n\t\t\tsb.append(getParameterValue(\"sourceVersionId\"));\n\t\t\tsb.append(\"&targetVersionId=\");\n\t\t\tsb.append(getParameterValue(\"targetVersionId\"));\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"?version=\");\n\t\t\tsb.append(syncFile.getVersion());\n\t\t}\n\n\t\tHttpGet httpGet = new HttpGet(sb.toString());\n\n\t\tPath tempFilePath = FileUtil.getFilePath(\n\t\t\tsyncAccount.getFilePathName(), \".data\",\n\t\t\tString.valueOf(syncFile.getSyncFileId()));\n\n\t\tif (Files.exists(tempFilePath)) {\n\t\t\thttpGet.setHeader(\n\t\t\t\t\"Range\", \"bytes=\" + Files.size(tempFilePath) + \"-\");\n\t\t}\n\n\t\texecuteAsynchronousGet(httpGet);\n\t}","commit_id":"051f0bd5080a9bd01e3c5b2c6b452f8e30dc0e0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void copyFile(\n\t\t\tSyncFile syncFile, Path filePath, InputStream inputStream)\n\t\tthrows Exception {\n\n\t\tWatcher watcher = WatcherRegistry.getWatcher(getSyncAccountId());\n\n\t\tList<String> downloadedFilePathNames =\n\t\t\twatcher.getDownloadedFilePathNames();\n\n\t\ttry {\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\tgetSyncAccountId());\n\n\t\t\tPath tempFilePath = FileUtil.getFilePath(\n\t\t\t\tsyncAccount.getFilePathName(), \".data\",\n\t\t\t\tString.valueOf(syncFile.getSyncFileId()));\n\n\t\t\tboolean exists = Files.exists(filePath);\n\n\t\t\tif (exists) {\n\t\t\t\tFiles.copy(\n\t\t\t\t\tfilePath, tempFilePath,\n\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\n\t\t\tif ((Boolean)getParameterValue(\"patch\")) {\n\t\t\t\tIODeltaUtil.patch(tempFilePath, inputStream);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFiles.copy(\n\t\t\t\t\tinputStream, tempFilePath,\n\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\n\t\t\tdownloadedFilePathNames.add(filePath.toString());\n\n\t\t\tif (exists) {\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED_UPDATE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED_NEW);\n\t\t\t}\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\ttempFilePath, String.valueOf(syncFile.getSyncFileId()), false);\n\n\t\t\tFileUtil.setModifiedTime(tempFilePath, syncFile.getModifiedTime());\n\n\t\t\tFiles.move(\n\t\t\t\ttempFilePath, filePath, StandardCopyOption.ATOMIC_MOVE,\n\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tIODeltaUtil.checksums(syncFile);\n\t\t}\n\t\tcatch (FileSystemException fse) {\n\t\t\tdownloadedFilePathNames.remove(filePath.toString());\n\n\t\t\tString message = fse.getMessage();\n\n\t\t\t_logger.error(message, fse);\n\n\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t}\n\t\t}\n\t}","id":34398,"modified_method":"protected void copyFile(\n\t\t\tSyncFile syncFile, Path filePath, InputStream inputStream,\n\t\t\tboolean append)\n\t\tthrows Exception {\n\n\t\tWatcher watcher = WatcherRegistry.getWatcher(getSyncAccountId());\n\n\t\tList<String> downloadedFilePathNames =\n\t\t\twatcher.getDownloadedFilePathNames();\n\n\t\ttry {\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\tgetSyncAccountId());\n\n\t\t\tPath tempFilePath = FileUtil.getFilePath(\n\t\t\t\tsyncAccount.getFilePathName(), \".data\",\n\t\t\t\tString.valueOf(syncFile.getSyncFileId()));\n\n\t\t\tboolean exists = Files.exists(filePath);\n\n\t\t\tif (append) {\n\t\t\t\tOutputStream outputStream = Files.newOutputStream(\n\t\t\t\t\ttempFilePath, StandardOpenOption.APPEND);\n\n\t\t\t\tIOUtils.copyLarge(inputStream, outputStream);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (exists && (boolean)getParameterValue(\"patch\")) {\n\t\t\t\t\tFiles.copy(\n\t\t\t\t\t\tfilePath, tempFilePath,\n\t\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\t\t\t\tIODeltaUtil.patch(tempFilePath, inputStream);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tFiles.copy(\n\t\t\t\t\t\tinputStream, tempFilePath,\n\t\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdownloadedFilePathNames.add(filePath.toString());\n\n\t\t\tif (exists) {\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED_UPDATE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED_NEW);\n\t\t\t}\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\ttempFilePath, String.valueOf(syncFile.getSyncFileId()), false);\n\n\t\t\tFileUtil.setModifiedTime(tempFilePath, syncFile.getModifiedTime());\n\n\t\t\tFiles.move(\n\t\t\t\ttempFilePath, filePath, StandardCopyOption.ATOMIC_MOVE,\n\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tIODeltaUtil.checksums(syncFile);\n\t\t}\n\t\tcatch (FileSystemException fse) {\n\t\t\tdownloadedFilePathNames.remove(filePath.toString());\n\n\t\t\tString message = fse.getMessage();\n\n\t\t\t_logger.error(message, fse);\n\n\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t}\n\t\t}\n\t}","commit_id":"051f0bd5080a9bd01e3c5b2c6b452f8e30dc0e0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doHandleResponse(HttpResponse httpResponse)\n\t\tthrows Exception {\n\n\t\tHeader errorHeader = httpResponse.getFirstHeader(\"Sync-Error\");\n\n\t\tif (errorHeader != null) {\n\t\t\thandleSiteDeactivatedException();\n\t\t}\n\n\t\tfinal Session session = SessionManager.getSession(getSyncAccountId());\n\n\t\tHeader tokenHeader = httpResponse.getFirstHeader(\"Sync-JWT\");\n\n\t\tif (tokenHeader != null) {\n\t\t\tsession.setToken(tokenHeader.getValue());\n\t\t}\n\n\t\tInputStream inputStream = null;\n\n\t\tSyncFile syncFile = getLocalSyncFile();\n\n\t\tif (isUnsynced(syncFile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\ttry {\n\t\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\n\t\t\tinputStream = new CountingInputStream(httpEntity.getContent()) {\n\n\t\t\t\t@Override\n\t\t\t\tprotected synchronized void afterRead(int n) {\n\t\t\t\t\tsession.incrementDownloadedBytes(n);\n\n\t\t\t\t\tsuper.afterRead(n);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcopyFile(syncFile, filePath, inputStream);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","id":34399,"modified_method":"@Override\n\tprotected void doHandleResponse(HttpResponse httpResponse)\n\t\tthrows Exception {\n\n\t\tHeader errorHeader = httpResponse.getFirstHeader(\"Sync-Error\");\n\n\t\tif (errorHeader != null) {\n\t\t\thandleSiteDeactivatedException();\n\t\t}\n\n\t\tfinal Session session = SessionManager.getSession(getSyncAccountId());\n\n\t\tHeader tokenHeader = httpResponse.getFirstHeader(\"Sync-JWT\");\n\n\t\tif (tokenHeader != null) {\n\t\t\tsession.setToken(tokenHeader.getValue());\n\t\t}\n\n\t\tInputStream inputStream = null;\n\n\t\tSyncFile syncFile = getLocalSyncFile();\n\n\t\tif (isUnsynced(syncFile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\ttry {\n\t\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\n\t\t\tinputStream = new CountingInputStream(httpEntity.getContent()) {\n\n\t\t\t\t@Override\n\t\t\t\tprotected synchronized void afterRead(int n) {\n\t\t\t\t\tsession.incrementDownloadedBytes(n);\n\n\t\t\t\t\tsuper.afterRead(n);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tif (httpResponse.getFirstHeader(\"Accept-Ranges\") != null) {\n\t\t\t\tcopyFile(syncFile, filePath, inputStream, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcopyFile(syncFile, filePath, inputStream, false);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","commit_id":"051f0bd5080a9bd01e3c5b2c6b452f8e30dc0e0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doHandleResponse(HttpResponse httpResponse)\n\t\tthrows Exception {\n\n\t\tfinal Session session = SessionManager.getSession(getSyncAccountId());\n\n\t\tHeader tokenHeader = httpResponse.getFirstHeader(\"Sync-JWT\");\n\n\t\tif (tokenHeader != null) {\n\t\t\tsession.setToken(tokenHeader.getValue());\n\t\t}\n\n\t\tMap<String, DownloadFileHandler> handlers =\n\t\t\t(Map<String, DownloadFileHandler>)getParameterValue(\"handlers\");\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\n\t\t\tinputStream = new CountingInputStream(httpEntity.getContent()) {\n\n\t\t\t\t@Override\n\t\t\t\tprotected synchronized void afterRead(int n) {\n\t\t\t\t\tsession.incrementDownloadedBytes(n);\n\n\t\t\t\t\tsuper.afterRead(n);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tZipInputStream zipInputStream = new ZipInputStream(inputStream);\n\n\t\t\tZipEntry zipEntry = null;\n\n\t\t\twhile ((zipEntry = zipInputStream.getNextEntry()) != null) {\n\t\t\t\tString zipEntryName = zipEntry.getName();\n\n\t\t\t\tif (zipEntryName.equals(\"errors.json\")) {\n\t\t\t\t\tJsonNode rootJsonNode = JSONUtil.readTree(zipInputStream);\n\n\t\t\t\t\tIterator<Map.Entry<String, JsonNode>> fields =\n\t\t\t\t\t\trootJsonNode.fields();\n\n\t\t\t\t\twhile (fields.hasNext()) {\n\t\t\t\t\t\tMap.Entry<String, JsonNode> field = fields.next();\n\n\t\t\t\t\t\tHandler<Void> handler = handlers.get(field.getKey());\n\n\t\t\t\t\t\tJsonNode valueJsonNode = field.getValue();\n\n\t\t\t\t\t\tJsonNode exceptionJsonNode = valueJsonNode.get(\n\t\t\t\t\t\t\t\"exception\");\n\n\t\t\t\t\t\thandler.handlePortalException(\n\t\t\t\t\t\t\texceptionJsonNode.textValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tDownloadFileHandler downloadFileHandler = handlers.get(\n\t\t\t\t\tzipEntryName);\n\n\t\t\t\tSyncFile syncFile =\n\t\t\t\t\t(SyncFile)downloadFileHandler.getParameterValue(\"syncFile\");\n\n\t\t\t\tif (downloadFileHandler.isUnsynced(syncFile)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Handling response {} file path {}\",\n\t\t\t\t\t\t\tDownloadFileHandler.class.getSimpleName(),\n\t\t\t\t\t\t\tsyncFile.getFilePathName());\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tdownloadFileHandler.copyFile(\n\t\t\t\t\t\tsyncFile, Paths.get(syncFile.getFilePathName()),\n\t\t\t\t\t\tnew CloseShieldInputStream(zipInputStream));\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.debug(e.getMessage(), e);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","id":34400,"modified_method":"@Override\n\tprotected void doHandleResponse(HttpResponse httpResponse)\n\t\tthrows Exception {\n\n\t\tfinal Session session = SessionManager.getSession(getSyncAccountId());\n\n\t\tHeader tokenHeader = httpResponse.getFirstHeader(\"Sync-JWT\");\n\n\t\tif (tokenHeader != null) {\n\t\t\tsession.setToken(tokenHeader.getValue());\n\t\t}\n\n\t\tMap<String, DownloadFileHandler> handlers =\n\t\t\t(Map<String, DownloadFileHandler>)getParameterValue(\"handlers\");\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\n\t\t\tinputStream = new CountingInputStream(httpEntity.getContent()) {\n\n\t\t\t\t@Override\n\t\t\t\tprotected synchronized void afterRead(int n) {\n\t\t\t\t\tsession.incrementDownloadedBytes(n);\n\n\t\t\t\t\tsuper.afterRead(n);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tZipInputStream zipInputStream = new ZipInputStream(inputStream);\n\n\t\t\tZipEntry zipEntry = null;\n\n\t\t\twhile ((zipEntry = zipInputStream.getNextEntry()) != null) {\n\t\t\t\tString zipEntryName = zipEntry.getName();\n\n\t\t\t\tif (zipEntryName.equals(\"errors.json\")) {\n\t\t\t\t\tJsonNode rootJsonNode = JSONUtil.readTree(zipInputStream);\n\n\t\t\t\t\tIterator<Map.Entry<String, JsonNode>> fields =\n\t\t\t\t\t\trootJsonNode.fields();\n\n\t\t\t\t\twhile (fields.hasNext()) {\n\t\t\t\t\t\tMap.Entry<String, JsonNode> field = fields.next();\n\n\t\t\t\t\t\tHandler<Void> handler = handlers.get(field.getKey());\n\n\t\t\t\t\t\tJsonNode valueJsonNode = field.getValue();\n\n\t\t\t\t\t\tJsonNode exceptionJsonNode = valueJsonNode.get(\n\t\t\t\t\t\t\t\"exception\");\n\n\t\t\t\t\t\thandler.handlePortalException(\n\t\t\t\t\t\t\texceptionJsonNode.textValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tDownloadFileHandler downloadFileHandler = handlers.get(\n\t\t\t\t\tzipEntryName);\n\n\t\t\t\tSyncFile syncFile =\n\t\t\t\t\t(SyncFile)downloadFileHandler.getParameterValue(\"syncFile\");\n\n\t\t\t\tif (downloadFileHandler.isUnsynced(syncFile)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Handling response {} file path {}\",\n\t\t\t\t\t\t\tDownloadFileHandler.class.getSimpleName(),\n\t\t\t\t\t\t\tsyncFile.getFilePathName());\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tdownloadFileHandler.copyFile(\n\t\t\t\t\t\tsyncFile, Paths.get(syncFile.getFilePathName()),\n\t\t\t\t\t\tnew CloseShieldInputStream(zipInputStream), false);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.debug(e.getMessage(), e);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","commit_id":"051f0bd5080a9bd01e3c5b2c6b452f8e30dc0e0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void doScheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tif (!_running) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncAccount syncAccount = ServerEventUtil.synchronizeSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tsyncAccount.setState(SyncAccount.STATE_CONNECTED);\n\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tPath syncAccountFilePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tSyncFile syncAccountFile = SyncFileService.fetchSyncFile(\n\t\t\tsyncAccount.getFilePathName());\n\n\t\tif (!FileKeyUtil.hasFileKey(\n\t\t\t\tsyncAccountFilePath, syncAccountFile.getSyncFileId())) {\n\n\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t_logger.trace(\n\t\t\t\t\t\"Missing sync account file path {}\", syncAccountFilePath);\n\t\t\t}\n\n\t\t\tsyncAccount.setActive(false);\n\t\t\tsyncAccount.setUiEvent(\n\t\t\t\tSyncAccount.UI_EVENT_SYNC_ACCOUNT_FOLDER_MISSING);\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (!syncAccount.isActive()) {\n\t\t\tSyncAccountService.activateSyncAccount(syncAccountId, false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tList<SyncSite> syncSites = SyncSiteService.findSyncSites(syncAccountId);\n\n\t\tfor (SyncSite syncSite : syncSites) {\n\t\t\tsyncSite.setState(SyncSite.STATE_SYNCED);\n\n\t\t\tSyncSiteService.update(syncSite);\n\n\t\t\tif (!syncSite.isActive() || (syncSite.getRemoteSyncTime() == -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPath syncSiteFilePath = Paths.get(syncSite.getFilePathName());\n\n\t\t\tif (Files.notExists(syncSiteFilePath)) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Missing sync site file path {}\", syncSiteFilePath);\n\t\t\t\t}\n\n\t\t\t\tsyncSite.setUiEvent(SyncSite.UI_EVENT_SYNC_SITE_FOLDER_MISSING);\n\n\t\t\t\tSyncSiteService.update(syncSite);\n\n\t\t\t\tSyncSiteService.deactivateSyncSite(syncSite.getSyncSiteId());\n\t\t\t}\n\t\t}\n\n\t\tSyncWatchEventService.deleteSyncWatchEvents(syncAccountId);\n\n\t\tPath dataFilePath = FileUtil.getFilePath(\n\t\t\tsyncAccount.getFilePathName(), \".data\");\n\n\t\tif (Files.exists(dataFilePath)) {\n\t\t\tFileUtils.cleanDirectory(dataFilePath.toFile());\n\t\t}\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tServerEventUtil.synchronizeSyncSites(syncAccountId);\n\t\t}\n\n\t\tSyncWatchEventProcessor syncWatchEventProcessor =\n\t\t\tnew SyncWatchEventProcessor(syncAccountId);\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t_localEventsScheduledExecutorService.scheduleWithFixedDelay(\n\t\t\t\tsyncWatchEventProcessor, 0, 3, TimeUnit.SECONDS);\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccountId);\n\n\t\tWatcher watcher = null;\n\n\t\tif (OSDetector.isApple()) {\n\t\t\twatcher = new BarbaryWatcher(\n\t\t\t\tsyncAccountFilePath, watchEventListener);\n\t\t}\n\t\telse {\n\t\t\twatcher = new JPathWatcher(syncAccountFilePath, watchEventListener);\n\t\t}\n\n\t\t_executorService.execute(watcher);\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tsynchronizeSyncFiles(syncAccountFilePath, syncAccountId);\n\t\t}\n\n\t\tscheduleGetSyncDLObjectUpdateEvent(\n\t\t\tsyncAccount, syncWatchEventProcessor, scheduledFuture, watcher);\n\t}","id":34401,"modified_method":"protected static void doScheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tif (!_running) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncAccount syncAccount = ServerEventUtil.synchronizeSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tsyncAccount.setState(SyncAccount.STATE_CONNECTED);\n\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tPath syncAccountFilePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tSyncFile syncAccountFile = SyncFileService.fetchSyncFile(\n\t\t\tsyncAccount.getFilePathName());\n\n\t\tif (!FileKeyUtil.hasFileKey(\n\t\t\t\tsyncAccountFilePath, syncAccountFile.getSyncFileId())) {\n\n\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t_logger.trace(\n\t\t\t\t\t\"Missing sync account file path {}\", syncAccountFilePath);\n\t\t\t}\n\n\t\t\tsyncAccount.setActive(false);\n\t\t\tsyncAccount.setUiEvent(\n\t\t\t\tSyncAccount.UI_EVENT_SYNC_ACCOUNT_FOLDER_MISSING);\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (!syncAccount.isActive()) {\n\t\t\tSyncAccountService.activateSyncAccount(syncAccountId, false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tList<SyncSite> syncSites = SyncSiteService.findSyncSites(syncAccountId);\n\n\t\tfor (SyncSite syncSite : syncSites) {\n\t\t\tsyncSite.setState(SyncSite.STATE_SYNCED);\n\n\t\t\tSyncSiteService.update(syncSite);\n\n\t\t\tif (!syncSite.isActive() || (syncSite.getRemoteSyncTime() == -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPath syncSiteFilePath = Paths.get(syncSite.getFilePathName());\n\n\t\t\tif (Files.notExists(syncSiteFilePath)) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(\n\t\t\t\t\t\t\"Missing sync site file path {}\", syncSiteFilePath);\n\t\t\t\t}\n\n\t\t\t\tsyncSite.setUiEvent(SyncSite.UI_EVENT_SYNC_SITE_FOLDER_MISSING);\n\n\t\t\t\tSyncSiteService.update(syncSite);\n\n\t\t\t\tSyncSiteService.deactivateSyncSite(syncSite.getSyncSiteId());\n\t\t\t}\n\t\t}\n\n\t\tSyncWatchEventService.deleteSyncWatchEvents(syncAccountId);\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tServerEventUtil.synchronizeSyncSites(syncAccountId);\n\t\t}\n\n\t\tSyncWatchEventProcessor syncWatchEventProcessor =\n\t\t\tnew SyncWatchEventProcessor(syncAccountId);\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t_localEventsScheduledExecutorService.scheduleWithFixedDelay(\n\t\t\t\tsyncWatchEventProcessor, 0, 3, TimeUnit.SECONDS);\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccountId);\n\n\t\tWatcher watcher = null;\n\n\t\tif (OSDetector.isApple()) {\n\t\t\twatcher = new BarbaryWatcher(\n\t\t\t\tsyncAccountFilePath, watchEventListener);\n\t\t}\n\t\telse {\n\t\t\twatcher = new JPathWatcher(syncAccountFilePath, watchEventListener);\n\t\t}\n\n\t\t_executorService.execute(watcher);\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tsynchronizeSyncFiles(syncAccountFilePath, syncAccountId);\n\t\t}\n\n\t\tscheduleGetSyncDLObjectUpdateEvent(\n\t\t\tsyncAccount, syncWatchEventProcessor, scheduledFuture, watcher);\n\t}","commit_id":"051f0bd5080a9bd01e3c5b2c6b452f8e30dc0e0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void handleException(Exception e) {\n\t\t_logger.error(e.getMessage(), e);\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\n\t\tif (e instanceof HttpHostConnectException) {\n\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t}\n\t\telse if (e instanceof HttpResponseException) {\n\t\t\tHttpResponseException hre = (HttpResponseException)e;\n\n\t\t\tint statusCode = hre.getStatusCode();\n\n\t\t\tif (statusCode == HttpServletResponse.SC_UNAUTHORIZED) {\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_AUTHENTICATION_EXCEPTION);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tretryServerConnection();\n\t}","id":34402,"modified_method":"@Override\n\tpublic void handleException(Exception e) {\n\t\t_logger.error(e.getMessage(), e);\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tif (e instanceof FileNotFoundException) {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tif (syncFile.getVersion() == null) {\n\t\t\t\tSyncFileService.deleteSyncFile(syncFile);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse if (e instanceof HttpHostConnectException) {\n\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t}\n\t\telse if (e instanceof HttpResponseException) {\n\t\t\tHttpResponseException hre = (HttpResponseException)e;\n\n\t\t\tint statusCode = hre.getStatusCode();\n\n\t\t\tif (statusCode == HttpServletResponse.SC_UNAUTHORIZED) {\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_AUTHENTICATION_EXCEPTION);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t\t}\n\t\t}\n\n\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tretryServerConnection();\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected void doHandleResponse(HttpResponse httpResponse)\n\t\tthrows Exception {\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\n\t\t\tinputStream = httpEntity.getContent();\n\n\t\t\tif ((Boolean)getParameterValue(\"patch\")) {\n\t\t\t\tIODeltaUtil.patch(filePath, inputStream);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFiles.copy(\n\t\t\t\t\tinputStream, filePath, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\n\t\t\tsyncFile.setFileKey(FileUtil.getFileKey(filePath));\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","id":34403,"modified_method":"@Override\n\tprotected void doHandleResponse(HttpResponse httpResponse)\n\t\tthrows Exception {\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\n\t\t\tinputStream = httpEntity.getContent();\n\n\t\t\tPath tempFilePath = Files.createTempFile(\n\t\t\t\tString.valueOf(filePath.getFileName()), \".tmp\");\n\n\t\t\tif (Files.exists(filePath)) {\n\t\t\t\tFiles.copy(filePath, tempFilePath);\n\t\t\t}\n\n\t\t\tif ((Boolean)getParameterValue(\"patch\")) {\n\t\t\t\tIODeltaUtil.patch(tempFilePath, inputStream);\n\n\t\t\t\tFiles.move(\n\t\t\t\t\ttempFilePath, filePath, StandardCopyOption.ATOMIC_MOVE,\n\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFiles.copy(\n\t\t\t\t\tinputStream, tempFilePath,\n\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\t\t\tFiles.move(\n\t\t\t\t\ttempFilePath, filePath, StandardCopyOption.ATOMIC_MOVE,\n\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\n\t\t\tsyncFile.setFileKey(FileUtil.getFileKey(filePath));\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static Path patch(\n\t\tPath targetFilePath, InputStream deltaInputStream) {\n\n\t\tif (Files.notExists(targetFilePath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tFileInputStream targetInputStream = null;\n\t\tFileChannel targetFileChannel = null;\n\t\tOutputStream patchedFileOutputStream = null;\n\t\tWritableByteChannel patchedWritableByteChannel = null;\n\t\tReadableByteChannel deltaReadableByteChannel = null;\n\n\t\ttry {\n\t\t\ttargetInputStream = new FileInputStream(\n\t\t\t\tFilePathNameUtil.getFilePathName(targetFilePath));\n\n\t\t\ttargetFileChannel = targetInputStream.getChannel();\n\n\t\t\tPath patchedFilePath = Files.createTempFile(\n\t\t\t\tString.valueOf(targetFilePath.getFileName()), \"tmp\");\n\n\t\t\tpatchedFileOutputStream = Files.newOutputStream(patchedFilePath);\n\n\t\t\tpatchedWritableByteChannel = Channels.newChannel(\n\t\t\t\tpatchedFileOutputStream);\n\n\t\t\tdeltaReadableByteChannel = Channels.newChannel(deltaInputStream);\n\n\t\t\tByteChannelReader deltaByteChannelReader = new ByteChannelReader(\n\t\t\t\tdeltaReadableByteChannel);\n\n\t\t\tDeltaUtil.patch(\n\t\t\t\ttargetFileChannel, patchedWritableByteChannel,\n\t\t\t\tdeltaByteChannelReader);\n\n\t\t\tFiles.move(\n\t\t\t\tpatchedFilePath, targetFilePath,\n\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\t\treturn targetFilePath;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_logger.error(ioe.getMessage(), ioe);\n\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(targetInputStream);\n\t\t\tStreamUtil.cleanUp(targetFileChannel);\n\t\t\tStreamUtil.cleanUp(patchedFileOutputStream);\n\t\t\tStreamUtil.cleanUp(patchedWritableByteChannel);\n\t\t\tStreamUtil.cleanUp(deltaReadableByteChannel);\n\t\t}\n\t}","id":34404,"modified_method":"public static Path patch(\n\t\tPath targetFilePath, InputStream deltaInputStream) {\n\n\t\tif (Files.notExists(targetFilePath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tFileInputStream targetInputStream = null;\n\t\tFileChannel targetFileChannel = null;\n\t\tOutputStream patchedFileOutputStream = null;\n\t\tWritableByteChannel patchedWritableByteChannel = null;\n\t\tReadableByteChannel deltaReadableByteChannel = null;\n\n\t\ttry {\n\t\t\ttargetInputStream = new FileInputStream(\n\t\t\t\tFilePathNameUtil.getFilePathName(targetFilePath));\n\n\t\t\ttargetFileChannel = targetInputStream.getChannel();\n\n\t\t\tPath patchedFilePath = Files.createTempFile(\n\t\t\t\tString.valueOf(targetFilePath.getFileName()), \".tmp\");\n\n\t\t\tpatchedFileOutputStream = Files.newOutputStream(patchedFilePath);\n\n\t\t\tpatchedWritableByteChannel = Channels.newChannel(\n\t\t\t\tpatchedFileOutputStream);\n\n\t\t\tdeltaReadableByteChannel = Channels.newChannel(deltaInputStream);\n\n\t\t\tByteChannelReader deltaByteChannelReader = new ByteChannelReader(\n\t\t\t\tdeltaReadableByteChannel);\n\n\t\t\tDeltaUtil.patch(\n\t\t\t\ttargetFileChannel, patchedWritableByteChannel,\n\t\t\t\tdeltaByteChannelReader);\n\n\t\t\tFiles.move(\n\t\t\t\tpatchedFilePath, targetFilePath,\n\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\t\treturn targetFilePath;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_logger.error(ioe.getMessage(), ioe);\n\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(targetInputStream);\n\t\t\tStreamUtil.cleanUp(targetFileChannel);\n\t\t\tStreamUtil.cleanUp(patchedFileOutputStream);\n\t\t\tStreamUtil.cleanUp(patchedWritableByteChannel);\n\t\t\tStreamUtil.cleanUp(deltaReadableByteChannel);\n\t\t}\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static SyncFile updateFileSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tPath deltaFilePath = null;\n\n\t\tString changeLog = String.valueOf(\n\t\t\tDouble.valueOf(syncFile.getVersion()) + .1);\n\t\tString name = String.valueOf(filePath.getFileName());\n\t\tString sourceChecksum = syncFile.getChecksum();\n\t\tString sourceFileName = syncFile.getName();\n\t\tString sourceVersion = syncFile.getVersion();\n\t\tString targetChecksum = FileUtil.getChecksum(filePath);\n\n\t\tif (!sourceChecksum.equals(targetChecksum) &&\n\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(syncFile)) {\n\n\t\t\tdeltaFilePath = Files.createTempFile(\n\t\t\t\tString.valueOf(filePath.getFileName()), \"tmp\");\n\n\t\t\tdeltaFilePath = IODeltaUtil.delta(\n\t\t\t\tfilePath, IODeltaUtil.getChecksumsFilePath(syncFile),\n\t\t\t\tdeltaFilePath);\n\t\t}\n\n\t\tsyncFile.setChangeLog(changeLog);\n\t\tsyncFile.setChecksum(targetChecksum);\n\t\tsyncFile.setFilePathName(FilePathNameUtil.getFilePathName(filePath));\n\t\tsyncFile.setName(name);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_LOCAL);\n\n\t\tupdate(syncFile);\n\n\t\t// Remote sync file\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"changeLog\", changeLog);\n\t\tparameters.put(\"checksum\", targetChecksum);\n\t\tparameters.put(\"description\", syncFile.getDescription());\n\t\tparameters.put(\"fileEntryId\", syncFile.getTypePK());\n\t\tparameters.put(\"majorVersion\", false);\n\t\tparameters.put(\"mimeType\", syncFile.getMimeType());\n\t\tparameters.put(\"sourceFileName\", name);\n\t\tparameters.put(\"syncFile\", syncFile);\n\t\tparameters.put(\"title\", name);\n\n\t\tif (!sourceChecksum.equals(targetChecksum)) {\n\t\t\tif ((deltaFilePath != null) &&\n\t\t\t\t(Files.size(filePath) / Files.size(deltaFilePath)) >=\n\t\t\t\t\tPropsValues.SYNC_FILE_PATCHING_SIZE_RATIO_THRESHOLD) {\n\n\t\t\t\tparameters.put(\"deltaFilePath\", deltaFilePath);\n\t\t\t\tparameters.put(\"sourceFileName\", sourceFileName);\n\t\t\t\tparameters.put(\"sourceVersion\", sourceVersion);\n\n\t\t\t\tPatchFileEntryEvent patchFileEntryEvent =\n\t\t\t\t\tnew PatchFileEntryEvent(syncAccountId, parameters);\n\n\t\t\t\tpatchFileEntryEvent.run();\n\n\t\t\t\treturn syncFile;\n\t\t\t}\n\n\t\t\tparameters.put(\"filePath\", filePath);\n\t\t}\n\n\t\tUpdateFileEntryEvent updateFileEntryEvent = new UpdateFileEntryEvent(\n\t\t\tsyncAccountId, parameters);\n\n\t\tupdateFileEntryEvent.run();\n\n\t\treturn syncFile;\n\t}","id":34405,"modified_method":"public static SyncFile updateFileSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tPath deltaFilePath = null;\n\n\t\tString changeLog = String.valueOf(\n\t\t\tDouble.valueOf(syncFile.getVersion()) + .1);\n\t\tString name = String.valueOf(filePath.getFileName());\n\t\tString sourceChecksum = syncFile.getChecksum();\n\t\tString sourceFileName = syncFile.getName();\n\t\tString sourceVersion = syncFile.getVersion();\n\t\tString targetChecksum = FileUtil.getChecksum(filePath);\n\n\t\tif (!sourceChecksum.equals(targetChecksum) &&\n\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(syncFile)) {\n\n\t\t\tdeltaFilePath = Files.createTempFile(\n\t\t\t\tString.valueOf(filePath.getFileName()), \".tmp\");\n\n\t\t\tdeltaFilePath = IODeltaUtil.delta(\n\t\t\t\tfilePath, IODeltaUtil.getChecksumsFilePath(syncFile),\n\t\t\t\tdeltaFilePath);\n\t\t}\n\n\t\tsyncFile.setChangeLog(changeLog);\n\t\tsyncFile.setChecksum(targetChecksum);\n\t\tsyncFile.setFilePathName(FilePathNameUtil.getFilePathName(filePath));\n\t\tsyncFile.setName(name);\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_LOCAL);\n\n\t\tupdate(syncFile);\n\n\t\t// Remote sync file\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"changeLog\", changeLog);\n\t\tparameters.put(\"checksum\", targetChecksum);\n\t\tparameters.put(\"description\", syncFile.getDescription());\n\t\tparameters.put(\"fileEntryId\", syncFile.getTypePK());\n\t\tparameters.put(\"majorVersion\", false);\n\t\tparameters.put(\"mimeType\", syncFile.getMimeType());\n\t\tparameters.put(\"sourceFileName\", name);\n\t\tparameters.put(\"syncFile\", syncFile);\n\t\tparameters.put(\"title\", name);\n\n\t\tif (!sourceChecksum.equals(targetChecksum)) {\n\t\t\tif ((deltaFilePath != null) &&\n\t\t\t\t(Files.size(filePath) / Files.size(deltaFilePath)) >=\n\t\t\t\t\tPropsValues.SYNC_FILE_PATCHING_SIZE_RATIO_THRESHOLD) {\n\n\t\t\t\tparameters.put(\"deltaFilePath\", deltaFilePath);\n\t\t\t\tparameters.put(\"sourceFileName\", sourceFileName);\n\t\t\t\tparameters.put(\"sourceVersion\", sourceVersion);\n\n\t\t\t\tPatchFileEntryEvent patchFileEntryEvent =\n\t\t\t\t\tnew PatchFileEntryEvent(syncAccountId, parameters);\n\n\t\t\t\tpatchFileEntryEvent.run();\n\n\t\t\t\treturn syncFile;\n\t\t\t}\n\n\t\t\tparameters.put(\"filePath\", filePath);\n\t\t}\n\n\t\tUpdateFileEntryEvent updateFileEntryEvent = new UpdateFileEntryEvent(\n\t\t\tsyncAccountId, parameters);\n\n\t\tupdateFileEntryEvent.run();\n\n\t\treturn syncFile;\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static SyncFile addFileSyncFile(\n\t\t\tPath filePath, long folderId, long repositoryId, long syncAccountId)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tString checksum = FileUtil.getChecksum(filePath);\n\t\tString name = String.valueOf(filePath.getFileName());\n\t\tString mimeType = Files.probeContentType(filePath);\n\n\t\tSyncFile syncFile = addSyncFile(\n\t\t\t_VERSION_DEFAULT, checksum, name, FileUtil.getFileKey(filePath),\n\t\t\tFilePathNameUtil.getFilePathName(filePath), mimeType, name,\n\t\t\tfolderId, repositoryId, syncAccountId, SyncFile.TYPE_FILE);\n\n\t\t// Remote sync file\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"changeLog\", _VERSION_DEFAULT);\n\t\tparameters.put(\"checksum\", checksum);\n\t\tparameters.put(\"description\", name);\n\t\tparameters.put(\"filePath\", filePath);\n\t\tparameters.put(\"folderId\", folderId);\n\t\tparameters.put(\"mimeType\", mimeType);\n\t\tparameters.put(\"repositoryId\", repositoryId);\n\t\tparameters.put(\"sourceFileName\", name);\n\t\tparameters.put(\"syncFile\", syncFile);\n\t\tparameters.put(\"title\", name);\n\n\t\tAddFileEntryEvent addFileEntryEvent = new AddFileEntryEvent(\n\t\t\tsyncAccountId, parameters);\n\n\t\taddFileEntryEvent.run();\n\n\t\treturn syncFile;\n\t}","id":34406,"modified_method":"public static SyncFile addFileSyncFile(\n\t\t\tPath filePath, long folderId, long repositoryId, long syncAccountId)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tString checksum = FileUtil.getChecksum(filePath);\n\t\tString name = String.valueOf(filePath.getFileName());\n\t\tString mimeType = Files.probeContentType(filePath);\n\n\t\tif (Files.notExists(filePath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSyncFile syncFile = addSyncFile(\n\t\t\t_VERSION_DEFAULT, checksum, name, FileUtil.getFileKey(filePath),\n\t\t\tFilePathNameUtil.getFilePathName(filePath), mimeType, name,\n\t\t\tfolderId, repositoryId, syncAccountId, SyncFile.TYPE_FILE);\n\n\t\t// Remote sync file\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"changeLog\", _VERSION_DEFAULT);\n\t\tparameters.put(\"checksum\", checksum);\n\t\tparameters.put(\"description\", name);\n\t\tparameters.put(\"filePath\", filePath);\n\t\tparameters.put(\"folderId\", folderId);\n\t\tparameters.put(\"mimeType\", mimeType);\n\t\tparameters.put(\"repositoryId\", repositoryId);\n\t\tparameters.put(\"sourceFileName\", name);\n\t\tparameters.put(\"syncFile\", syncFile);\n\t\tparameters.put(\"title\", name);\n\n\t\tAddFileEntryEvent addFileEntryEvent = new AddFileEntryEvent(\n\t\t\tsyncAccountId, parameters);\n\n\t\taddFileEntryEvent.run();\n\n\t\treturn syncFile;\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tPath targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tFilePathNameUtil.getFilePathName(parentTargetFilePath),\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\tFileUtil.getFileKey(targetFilePath),\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tif (syncFile == null) {\n\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tparentSyncFile.getRepositoryId(),\n\t\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE, syncFile.getFilePathName(),\n\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\tif (relatedSyncWatchEvent == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(\n\t\t\trelatedSyncWatchEvent.getFilePathName());\n\n\t\tif (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, syncWatchEvent.getSyncAccountId(), syncFile);\n\t\t}\n\t\telse {\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tsyncWatchEvent.getSyncAccountId(), syncFile);\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tif (syncAccount.getState() != SyncAccount.STATE_DISCONNECTED) {\n\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t}\n\t}","id":34407,"modified_method":"protected void addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tPath targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tFilePathNameUtil.getFilePathName(parentTargetFilePath),\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\tFileUtil.getFileKey(targetFilePath),\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tif (syncFile == null) {\n\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tparentSyncFile.getRepositoryId(),\n\t\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE, syncFile.getFilePathName(),\n\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\tif (relatedSyncWatchEvent == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(\n\t\t\trelatedSyncWatchEvent.getFilePathName());\n\n\t\tif (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, syncWatchEvent.getSyncAccountId(), syncFile);\n\t\t}\n\t\telse {\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tsyncWatchEvent.getSyncAccountId(), syncFile);\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tif (syncAccount.getState() != SyncAccount.STATE_DISCONNECTED) {\n\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t}\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void deleteFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tPath filePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\tFilePathNameUtil.getFilePathName(filePath),\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tSyncFileService.deleteFileSyncFile(\n\t\t\tsyncWatchEvent.getSyncAccountId(), syncFile);\n\t}","id":34408,"modified_method":"protected void deleteFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tPath filePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\tFilePathNameUtil.getFilePathName(filePath),\n\t\t\tsyncWatchEvent.getSyncAccountId());\n\n\t\tif (syncFile == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFileService.deleteFileSyncFile(\n\t\t\tsyncWatchEvent.getSyncAccountId(), syncFile);\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void register(Path filePath, boolean recursive)\n\t\tthrows IOException {\n\n\t\tif (recursive) {\n\t\t\tFiles.walkFileTree(\n\t\t\t\tfilePath,\n\t\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult preVisitDirectory(\n\t\t\t\t\t\t\tPath filePath,\n\t\t\t\t\t\t\tBasicFileAttributes basicFileAttributes)\n\t\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\t\tregister(filePath, false);\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult visitFile(\n\t\t\t\t\t\tPath filePath,\n\t\t\t\t\t\tBasicFileAttributes basicFileAttributes) {\n\n\t\t\t\t\t\tfireWatchEventListener(\n\t\t\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_CREATE, filePath);\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tname.pachler.nio.file.Path jpathwatchFilePath = Paths.get(\n\t\t\t\tfilePath.toString());\n\n\t\t\tWatchKey watchKey = jpathwatchFilePath.register(\n\t\t\t\t_watchService, StandardWatchEventKind.ENTRY_CREATE,\n\t\t\t\tStandardWatchEventKind.ENTRY_DELETE,\n\t\t\t\tStandardWatchEventKind.ENTRY_MODIFY);\n\n\t\t\t_filePaths.put(watchKey, filePath);\n\n\t\t\tfireWatchEventListener(SyncWatchEvent.EVENT_TYPE_CREATE, filePath);\n\n\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t_logger.trace(\"Registered file path {}\", filePath);\n\t\t\t}\n\t\t}\n\t}","id":34409,"modified_method":"protected void register(Path filePath, boolean recursive)\n\t\tthrows IOException {\n\n\t\tif (recursive) {\n\t\t\tFiles.walkFileTree(\n\t\t\t\tfilePath,\n\t\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult preVisitDirectory(\n\t\t\t\t\t\t\tPath filePath,\n\t\t\t\t\t\t\tBasicFileAttributes basicFileAttributes)\n\t\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\t\tregister(filePath, false);\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult visitFile(\n\t\t\t\t\t\tPath filePath,\n\t\t\t\t\t\tBasicFileAttributes basicFileAttributes) {\n\n\t\t\t\t\t\tif (Files.exists(filePath)) {\n\t\t\t\t\t\t\tfireWatchEventListener(\n\t\t\t\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_CREATE, filePath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tname.pachler.nio.file.Path jpathwatchFilePath = Paths.get(\n\t\t\t\tfilePath.toString());\n\n\t\t\tWatchKey watchKey = jpathwatchFilePath.register(\n\t\t\t\t_watchService, StandardWatchEventKind.ENTRY_CREATE,\n\t\t\t\tStandardWatchEventKind.ENTRY_DELETE,\n\t\t\t\tStandardWatchEventKind.ENTRY_MODIFY);\n\n\t\t\t_filePaths.put(watchKey, filePath);\n\n\t\t\tfireWatchEventListener(SyncWatchEvent.EVENT_TYPE_CREATE, filePath);\n\n\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t_logger.trace(\"Registered file path {}\", filePath);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a72b6055d7c96343b585924dc9e9b071d0de23d1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Test(dependsOnMethods = \"testSaveCircularLink\")\r\n\tpublic void testQueryCircular() {\r\n\t\tList<ODocument> result = database.getUnderlying().command(new OSQLSynchQuery<ODocument>(\"select * from Profile\")).execute();\r\n\r\n\t\tODocument parent;\r\n\t\tfor (ODocument r : result) {\r\n\r\n\t\t\tSystem.out.println(r.field(\"name\") + \" \" + r.field(\"surname\"));\r\n\r\n\t\t\tparent = r.field(\"invitedBy\");\r\n\r\n\t\t\tif (parent != null)\r\n\t\t\t\tSystem.out.println(\"- parent: \" + parent.field(\"name\") + \" \" + parent.field(\"surname\"));\r\n\t\t}\r\n\t}","id":34410,"modified_method":"@Test(dependsOnMethods = \"testSaveCircularLink\")\r\n\tpublic void testQueryCircular() {\r\n\t\tList<Profile> result = database.query(new OSQLSynchQuery<ODocument>(\"select * from Profile\"));\r\n\r\n\t\tProfile parent;\r\n\t\tfor (Profile r : result) {\r\n\r\n\t\t\tSystem.out.println(r.getName() + \" \" + r.getSurname());\r\n\r\n\t\t\tparent = r.getInvitedBy();\r\n\r\n\t\t\tif (parent != null)\r\n\t\t\t\tSystem.out.println(\"- parent: \" + parent.getName() + \" \" + parent.getSurname());\r\n\t\t}\r\n\t}","commit_id":"9878a7b289997782f663121c507a1b6b07ad81fd","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  @SuppressWarnings(\"unchecked\")\r\n  public boolean execute(final OHttpRequest iRequest, OHttpResponse iResponse) throws Exception {\r\n    String[] urlParts = checkSyntax(\r\n        iRequest.url,\r\n        4,\r\n        \"Syntax error: query/<database>/sql/<query-text>[/<limit>][/<fetchPlan>].<br/>Limit is optional and is setted to 20 by default. Set expressely to 0 to have no limits.\");\r\n\r\n    final int limit = urlParts.length > 4 ? Integer.parseInt(urlParts[4]) : 20;\r\n\r\n    final String fetchPlan = urlParts.length > 5 ? urlParts[5] : null;\r\n\r\n    final String text = urlParts[3];\r\n\r\n    iRequest.data.commandInfo = \"Query\";\r\n    iRequest.data.commandDetail = text;\r\n\r\n    ODatabaseDocumentTx db = null;\r\n\r\n    final List<OIdentifiable> response;\r\n\r\n    try {\r\n      db = getProfiledDatabaseInstance(iRequest);\r\n\r\n      response = (List<OIdentifiable>) db.command(new OSQLSynchQuery<ORecordSchemaAware<?>>(text, limit).setFetchPlan(fetchPlan))\r\n          .execute();\r\n\r\n      iResponse.writeRecords(response, fetchPlan);\r\n\r\n    } finally {\r\n      if (db != null)\r\n        db.close();\r\n    }\r\n\r\n    return false;\r\n  }","id":34411,"modified_method":"@Override\r\n  @SuppressWarnings(\"unchecked\")\r\n  public boolean execute(final OHttpRequest iRequest, OHttpResponse iResponse) throws Exception {\r\n    String[] urlParts = checkSyntax(\r\n        iRequest.url,\r\n        4,\r\n        \"Syntax error: query/<database>/sql/<query-text>[/<limit>][/<fetchPlan>].<br/>Limit is optional and is setted to 20 by default. Set expressely to 0 to have no limits.\");\r\n\r\n    final int limit = urlParts.length > 4 ? Integer.parseInt(urlParts[4]) : 20;\r\n\r\n    final String fetchPlan = urlParts.length > 5 ? urlParts[5] : null;\r\n\r\n    final String text = urlParts[3];\r\n\r\n    iRequest.data.commandInfo = \"Query\";\r\n    iRequest.data.commandDetail = text;\r\n\r\n    ODatabaseDocumentTx db = null;\r\n\r\n    final List<OIdentifiable> response;\r\n\r\n    try {\r\n      db = getProfiledDatabaseInstance(iRequest);\r\n\r\n      response = (List<OIdentifiable>) db.query(new OSQLSynchQuery<ORecordSchemaAware<?>>(text, limit).setFetchPlan(fetchPlan));\r\n\r\n      iResponse.writeRecords(response, fetchPlan);\r\n\r\n    } finally {\r\n      if (db != null)\r\n        db.close();\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"8f7cea04d6761e83655d5279bdfa25f973d72c42","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public boolean execute(final OHttpRequest iRequest, OHttpResponse iResponse) throws Exception {\r\n    final String[] urlParts = checkSyntax(iRequest.url, 3,\r\n        \"Syntax error: command/<database>/<language>/<command-text>[/limit][/<fetchPlan>]\");\r\n\r\n    // TRY TO GET THE COMMAND FROM THE URL, THEN FROM THE CONTENT\r\n    final String language = urlParts.length > 2 ? urlParts[2].trim() : \"sql\";\r\n    String text = urlParts.length > 3 ? urlParts[3].trim() : iRequest.content;\r\n    final int limit = urlParts.length > 4 ? Integer.parseInt(urlParts[4].trim()) : -1;\r\n    final String fetchPlan = urlParts.length > 5 ? urlParts[5] : null;\r\n\r\n    if (iRequest.content != null)\r\n      // CONTENT REPLACES TEXT\r\n      text = iRequest.content;\r\n\r\n    iRequest.data.commandInfo = \"Command\";\r\n    iRequest.data.commandDetail = text;\r\n\r\n    ODatabaseDocumentTx db = null;\r\n\r\n    Object response;\r\n\r\n    try {\r\n      db = getProfiledDatabaseInstance(iRequest);\r\n\r\n      final OCommandRequestText cmd = (OCommandRequestText) OCommandManager.instance().getRequester(language);\r\n      cmd.setText(text);\r\n      cmd.setLimit(limit);\r\n      cmd.setFetchPlan(fetchPlan);\r\n      response = db.command(cmd).execute();\r\n\r\n      final String format = fetchPlan != null ? \"fetchPlan:\" + fetchPlan : null;\r\n\r\n      iResponse.writeResult(response, format);\r\n      \r\n    } finally {\r\n      if (db != null)\r\n        db.close();\r\n    }\r\n\r\n    return false;\r\n  }","id":34412,"modified_method":"@Override\r\n  public boolean execute(final OHttpRequest iRequest, OHttpResponse iResponse) throws Exception {\r\n    final String[] urlParts = checkSyntax(iRequest.url, 3,\r\n        \"Syntax error: command/<database>/<language>/<command-text>[/limit][/<fetchPlan>]\");\r\n\r\n    // TRY TO GET THE COMMAND FROM THE URL, THEN FROM THE CONTENT\r\n    final String language = urlParts.length > 2 ? urlParts[2].trim() : \"sql\";\r\n    String text = urlParts.length > 3 ? urlParts[3].trim() : iRequest.content;\r\n    final int limit = urlParts.length > 4 ? Integer.parseInt(urlParts[4].trim()) : -1;\r\n    final String fetchPlan = urlParts.length > 5 ? urlParts[5] : null;\r\n\r\n    if (iRequest.content != null)\r\n      // CONTENT REPLACES TEXT\r\n      text = iRequest.content;\r\n\r\n    if (text == null)\r\n      throw new IllegalArgumentException(\"text cannot be null\");\r\n\r\n    iRequest.data.commandInfo = \"Command\";\r\n    iRequest.data.commandDetail = text;\r\n\r\n    ODatabaseDocumentTx db = null;\r\n\r\n    Object response;\r\n\r\n    try {\r\n      db = getProfiledDatabaseInstance(iRequest);\r\n\r\n      final OCommandRequestText cmd = (OCommandRequestText) OCommandManager.instance().getRequester(language);\r\n\r\n      cmd.setText(text);\r\n      cmd.setLimit(limit);\r\n      cmd.setFetchPlan(fetchPlan);\r\n\r\n      final OCommandExecutor executor = OCommandManager.instance().getExecutor(cmd);\r\n      executor.setContext(cmd.getContext());\r\n      executor.setProgressListener(cmd.getProgressListener());\r\n      executor.parse(cmd);\r\n\r\n      if (!executor.isIdempotent() && iRequest.httpMethod.equals(\"GET\"))\r\n        throw new OCommandExecutionException(\"Cannot execute non idempotent command using HTTP GET\");\r\n\r\n      response = executor.execute(null);\r\n\r\n      final String format = fetchPlan != null ? \"fetchPlan:\" + fetchPlan : null;\r\n\r\n      iResponse.writeResult(response, format);\r\n\r\n    } finally {\r\n      if (db != null)\r\n        db.close();\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"8f7cea04d6761e83655d5279bdfa25f973d72c42","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@NotNull\n  public SoftWrapModel getSoftWrapModel() {\n    return myDelegate.getSoftWrapModel();\n  }","id":34413,"modified_method":"@NotNull\n  public SoftWrapModelEx getSoftWrapModel() {\n    return myDelegate.getSoftWrapModel();\n  }","commit_id":"4ba05812c053e4d6b3b240f5ee6e705aa6c611fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EditorWindow(@NotNull DocumentWindowImpl documentWindow, @NotNull final EditorImpl delegate, @NotNull PsiFile injectedFile, boolean oneLine) {\n    myDocumentWindow = documentWindow;\n    myDelegate = delegate;\n    myInjectedFile = injectedFile;\n    myOneLine = oneLine;\n    myCaretModelDelegate = new CaretModelWindow(myDelegate.getCaretModel(), this);\n    mySelectionModelDelegate = new SelectionModelWindow(myDelegate, myDocumentWindow,this);\n    myMarkupModelDelegate = new MarkupModelWindow((MarkupModelEx)myDelegate.getMarkupModel(), myDocumentWindow);\n    myFoldingModelWindow = new FoldingModelWindow((FoldingModelEx)delegate.getFoldingModel(), documentWindow, this);\n  }","id":34414,"modified_method":"private EditorWindow(@NotNull DocumentWindowImpl documentWindow, @NotNull final EditorImpl delegate, @NotNull PsiFile injectedFile, boolean oneLine) {\n    myDocumentWindow = documentWindow;\n    myDelegate = delegate;\n    myInjectedFile = injectedFile;\n    myOneLine = oneLine;\n    myCaretModelDelegate = new CaretModelWindow(myDelegate.getCaretModel(), this);\n    mySelectionModelDelegate = new SelectionModelWindow(myDelegate, myDocumentWindow,this);\n    myMarkupModelDelegate = new MarkupModelWindow((MarkupModelEx)myDelegate.getMarkupModel(), myDocumentWindow);\n    myFoldingModelWindow = new FoldingModelWindow(delegate.getFoldingModel(), documentWindow, this);\n  }","commit_id":"4ba05812c053e4d6b3b240f5ee6e705aa6c611fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadFromEditor(Editor editor) {\n    clear();\n\n    PsiDocumentManager.getInstance(myProject).commitDocument(editor.getDocument());\n\n    EditorFoldingInfo info = EditorFoldingInfo.get(editor);\n    FoldRegion[] foldRegions = editor.getFoldingModel().getAllFoldRegions();\n    for (FoldRegion region : foldRegions) {\n      PsiElement element = info.getPsiElement(region);\n      boolean expanded = region.isExpanded();\n      boolean collapseByDefault = element != null &&\n                                  FoldingPolicy.isCollapseByDefault(element) &&\n                                  !FoldingUtil.caretInsideRange(editor, new TextRange(region.getStartOffset(), region.getEndOffset()));\n      if (collapseByDefault != !expanded || element == null) {\n        if (element != null) {\n          myPsiElementsOrRangeMarkers.add(element);\n        }\n        else if (region.isValid()) {\n          myPsiElementsOrRangeMarkers.add(region);\n          String placeholderText = region.getPlaceholderText();\n          myPlaceholderTexts.put(region, placeholderText);\n        }\n        myExpandedStates.add(expanded ? Boolean.TRUE : Boolean.FALSE);\n      }\n    }\n  }","id":34415,"modified_method":"public void loadFromEditor(Editor editor) {\n    LOG.assertTrue(!editor.isDisposed());\n    clear();\n\n    PsiDocumentManager.getInstance(myProject).commitDocument(editor.getDocument());\n\n    EditorFoldingInfo info = EditorFoldingInfo.get(editor);\n    FoldRegion[] foldRegions = editor.getFoldingModel().getAllFoldRegions();\n    for (FoldRegion region : foldRegions) {\n      PsiElement element = info.getPsiElement(region);\n      boolean expanded = region.isExpanded();\n      boolean collapseByDefault = element != null &&\n                                  FoldingPolicy.isCollapseByDefault(element) &&\n                                  !FoldingUtil.caretInsideRange(editor, new TextRange(region.getStartOffset(), region.getEndOffset()));\n      if (collapseByDefault != !expanded || element == null) {\n        if (element != null) {\n          myPsiElementsOrRangeMarkers.add(element);\n        }\n        else if (region.isValid()) {\n          myPsiElementsOrRangeMarkers.add(region);\n          String placeholderText = region.getPlaceholderText();\n          myPlaceholderTexts.put(region, placeholderText);\n        }\n        myExpandedStates.add(expanded ? Boolean.TRUE : Boolean.FALSE);\n      }\n    }\n  }","commit_id":"2a1ec9ea3793c027900548290c680a410d5c7d19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void setToEditor(Editor editor) {\n    LOG.assertTrue(ApplicationManager.getApplication().isReadAccessAllowed());\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    if (psiManager.isDisposed()) return;\n\n    if (!myFile.isValid()) return;\n    final PsiFile psiFile = psiManager.findFile(myFile);\n    if (psiFile == null) return;\n\n    Map<PsiElement, FoldingDescriptor> ranges = null;\n    for(int i = 0; i < myPsiElementsOrRangeMarkers.size(); i++){\n      Object o = myPsiElementsOrRangeMarkers.get(i);\n      if (o instanceof PsiElement) {\n        PsiElement element = (PsiElement)o;\n        if (!element.isValid()) continue;\n\n        if (ranges == null) ranges = buildRanges(editor, psiFile);\n        FoldingDescriptor descriptor = ranges.get(element);\n        if (descriptor == null) continue;\n\n        TextRange range = descriptor.getRange();\n        FoldRegion region = FoldingUtil.findFoldRegion(editor, range.getStartOffset(), range.getEndOffset());\n        if (region != null) {\n          boolean state = myExpandedStates.get(i).booleanValue();\n          region.setExpanded(state);\n        }\n      }\n      else if (o instanceof RangeMarker) {\n        RangeMarker marker = (RangeMarker)o;\n        if (!marker.isValid()) continue;\n        FoldRegion region = FoldingUtil.findFoldRegion(editor, marker.getStartOffset(), marker.getEndOffset());\n        if (region == null) {\n          String placeHolderText = myPlaceholderTexts.get(marker);\n          region = ((FoldingModelEx)editor.getFoldingModel()).createFoldRegion(marker.getStartOffset(), marker.getEndOffset(), placeHolderText, null);  \n          //may fail to add in case intersecting region exists\n          if (region == null || !editor.getFoldingModel().addFoldRegion(region)) return;\n        }\n\n        boolean state = myExpandedStates.get(i).booleanValue();\n        region.setExpanded(state);\n      }\n      else{\n        LOG.error(\"o = \" + o);\n      }\n    }\n  }","id":34416,"modified_method":"void setToEditor(Editor editor) {\n    LOG.assertTrue(ApplicationManager.getApplication().isReadAccessAllowed());\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    if (psiManager.isDisposed()) return;\n\n    if (!myFile.isValid()) return;\n    final PsiFile psiFile = psiManager.findFile(myFile);\n    if (psiFile == null) return;\n\n    Map<PsiElement, FoldingDescriptor> ranges = null;\n    for(int i = 0; i < myPsiElementsOrRangeMarkers.size(); i++){\n      Object o = myPsiElementsOrRangeMarkers.get(i);\n      if (o instanceof PsiElement) {\n        PsiElement element = (PsiElement)o;\n        if (!element.isValid()) continue;\n\n        if (ranges == null) ranges = buildRanges(editor, psiFile);\n        FoldingDescriptor descriptor = ranges.get(element);\n        if (descriptor == null) continue;\n\n        TextRange range = descriptor.getRange();\n        FoldRegion region = FoldingUtil.findFoldRegion(editor, range.getStartOffset(), range.getEndOffset());\n        if (region != null) {\n          boolean state = myExpandedStates.get(i).booleanValue();\n          region.setExpanded(state);\n        }\n      }\n      else if (o instanceof RangeMarker) {\n        RangeMarker marker = (RangeMarker)o;\n        if (!marker.isValid()) continue;\n        FoldRegion region = FoldingUtil.findFoldRegion(editor, marker.getStartOffset(), marker.getEndOffset());\n        if (region == null) {\n          String placeHolderText = myPlaceholderTexts.get(marker);\n          region = editor.getFoldingModel().addFoldRegion(marker.getStartOffset(), marker.getEndOffset(), placeHolderText);\n          if (region == null) return;\n        }\n\n        boolean state = myExpandedStates.get(i).booleanValue();\n        region.setExpanded(state);\n      }\n      else{\n        LOG.error(\"o = \" + o);\n      }\n    }\n  }","commit_id":"2a1ec9ea3793c027900548290c680a410d5c7d19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<FoldRegion> addNewRegions(EditorFoldingInfo info,\n                                         FoldingModelEx foldingModel,\n                                         Map<TextRange, Boolean> rangeToExpandStatusMap,\n                                         Map<FoldRegion, Boolean> shouldExpand,\n                                         Map<FoldingGroup, Boolean> groupExpand) {\n    List<FoldRegion> newRegions = arrayList();\n    SmartPointerManager smartPointerManager = SmartPointerManager.getInstance(myProject);\n\n    for (final Map.Entry<PsiElement, FoldingDescriptor> entry : myElementsToFoldMap.entrySet()) {\n      ProgressManager.checkCanceled();\n      PsiElement element = entry.getKey();\n      final FoldingDescriptor descriptor = entry.getValue();\n      FoldingGroup group = descriptor.getGroup();\n      TextRange range = descriptor.getRange();\n      String placeholder = descriptor.getPlaceholderText();\n      FoldRegion region = foldingModel.createFoldRegion(range.getStartOffset(), range.getEndOffset(), placeholder == null ? \"...\" : placeholder, group);\n      if (region == null || !foldingModel.addFoldRegion(region)) continue;\n\n      info.addRegion(region, smartPointerManager.createSmartPsiElementPointer(descriptor.getElement().getPsi()));\n      newRegions.add(region);\n\n      boolean expandStatus = shouldExpandNewRegion(element, range, rangeToExpandStatusMap);\n      if (group == null) {\n        shouldExpand.put(region, expandStatus);\n      }\n      else {\n        final Boolean alreadyExpanded = groupExpand.get(group);\n        groupExpand.put(group, alreadyExpanded == null ? expandStatus : alreadyExpanded.booleanValue() || expandStatus);\n      }\n    }\n    return newRegions;\n  }","id":34417,"modified_method":"private List<FoldRegion> addNewRegions(EditorFoldingInfo info,\n                                         FoldingModelEx foldingModel,\n                                         Map<TextRange, Boolean> rangeToExpandStatusMap,\n                                         Map<FoldRegion, Boolean> shouldExpand,\n                                         Map<FoldingGroup, Boolean> groupExpand) {\n    List<FoldRegion> newRegions = arrayList();\n    SmartPointerManager smartPointerManager = SmartPointerManager.getInstance(myProject);\n\n    for (final Map.Entry<PsiElement, FoldingDescriptor> entry : myElementsToFoldMap.entrySet()) {\n      ProgressManager.checkCanceled();\n      PsiElement element = entry.getKey();\n      final FoldingDescriptor descriptor = entry.getValue();\n      FoldingGroup group = descriptor.getGroup();\n      TextRange range = descriptor.getRange();\n      String placeholder = descriptor.getPlaceholderText();\n      FoldRegion region = foldingModel.createFoldRegion(range.getStartOffset(), range.getEndOffset(), placeholder == null ? \"...\" : placeholder, group);\n      if (region == null) continue;\n\n      if (!foldingModel.addFoldRegion(region)) {\n        region.dispose();\n        continue;\n      }\n\n      info.addRegion(region, smartPointerManager.createSmartPsiElementPointer(descriptor.getElement().getPsi()));\n      newRegions.add(region);\n\n      boolean expandStatus = shouldExpandNewRegion(element, range, rangeToExpandStatusMap);\n      if (group == null) {\n        shouldExpand.put(region, expandStatus);\n      }\n      else {\n        final Boolean alreadyExpanded = groupExpand.get(group);\n        groupExpand.put(group, alreadyExpanded == null ? expandStatus : alreadyExpanded.booleanValue() || expandStatus);\n      }\n    }\n    return newRegions;\n  }","commit_id":"2a1ec9ea3793c027900548290c680a410d5c7d19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static LightweightHint showEditorFragmentHint(Editor editor, TextRange range, boolean showFolding, boolean hideByAnyKey){\n    int x = -2;\n    int y = 0;\n\n    JComponent editorComponent = editor.getComponent();\n    final JRootPane rootPane = editorComponent.getRootPane();\n    if (rootPane == null) return null;\n    JLayeredPane layeredPane = rootPane.getLayeredPane();\n    Point point = SwingUtilities.convertPoint(editorComponent, x, y, layeredPane);\n\n    return showEditorFragmentHintAt(editor, range, point.x, point.y, true, showFolding, hideByAnyKey);\n  }","id":34418,"modified_method":"@Nullable\n  public static LightweightHint showEditorFragmentHint(Editor editor, TextRange range, boolean showFolding, boolean hideByAnyKey){\n\n    JComponent editorComponent = editor.getComponent();\n    final JRootPane rootPane = editorComponent.getRootPane();\n    if (rootPane == null) return null;\n    JLayeredPane layeredPane = rootPane.getLayeredPane();\n    int x = -2;\n    int y = 0;\n    Point point = SwingUtilities.convertPoint(editorComponent, x, y, layeredPane);\n\n    return showEditorFragmentHintAt(editor, range, point.x, point.y, true, showFolding, hideByAnyKey);\n  }","commit_id":"5133fb6c7a2e8c2fd6f7f1889208c7850674a8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EditorFragmentComponent(EditorEx editor, int startLine, int endLine, boolean showFolding, boolean showGutter) {\n    Document doc = editor.getDocument();\n    final int endOffset = endLine < doc.getLineCount() ? doc.getLineEndOffset(endLine) : doc.getTextLength();\n    int textWidth = Math.min(editor.getMaxWidthInRange(doc.getLineStartOffset(startLine), endOffset), ScreenUtil.getScreenRectangle(1, 1).width);\n\n    FoldingModelEx foldingModel = (FoldingModelEx) editor.getFoldingModel();\n    boolean isFoldingEnabled = foldingModel.isFoldingEnabled();\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(false);\n    }\n\n    Point p1 = editor.logicalPositionToXY(new LogicalPosition(startLine, 0));\n    Point p2 = editor.logicalPositionToXY(new LogicalPosition(Math.max(endLine, startLine + 1), 0));\n    int y1 = p1.y;\n    int y2 = p2.y;\n\n    int savedScrollOfset = editor.getScrollingModel().getHorizontalScrollOffset();\n    if (savedScrollOfset > 0) {\n      editor.stopOptimizedScrolling();\n      editor.getScrollingModel().scrollHorizontally(0);\n    }\n\n    final Image textImage = new BufferedImage(textWidth, y2 - y1, BufferedImage.TYPE_INT_RGB);\n    Graphics textGraphics = textImage.getGraphics();\n\n    final JComponent rowHeader;\n    final Image markersImage;\n    if (showGutter) {\n      rowHeader = editor.getGutterComponentEx();\n      markersImage = new BufferedImage(Math.max(1, rowHeader.getWidth()), y2 - y1, BufferedImage.TYPE_INT_RGB);\n      Graphics markerGraphics = markersImage.getGraphics();\n\n      markerGraphics.translate(0, -y1);\n      markerGraphics.setClip(0, y1, rowHeader.getWidth(), y2 - y1);\n      markerGraphics.setColor(getBackgroundColor(editor));\n      markerGraphics.fillRect(0, y1, rowHeader.getWidth(), y2 - y1);\n      rowHeader.paint(markerGraphics);\n    }\n    else {\n      rowHeader = null;\n      markersImage = null;\n    }\n\n    textGraphics.translate(0, -y1);\n    textGraphics.setClip(0, y1, textWidth, y2 - y1);\n    final boolean wasVisible = editor.setCaretVisible(false);\n    editor.getContentComponent().paint(textGraphics);\n    if (wasVisible) {\n      editor.setCaretVisible(true);\n    }\n\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(isFoldingEnabled);\n    }\n\n    if (savedScrollOfset > 0) {\n      editor.stopOptimizedScrolling();\n      editor.getScrollingModel().scrollHorizontally(savedScrollOfset);\n    }\n\n    JComponent component = new JComponent() {\n      public Dimension getPreferredSize() {\n        return new Dimension(textImage.getWidth(null) +(markersImage == null ? 0 : markersImage.getWidth(null)), textImage.getHeight(null));\n      }\n\n      protected void paintComponent(Graphics graphics) {\n        if (markersImage != null) {\n          graphics.drawImage(markersImage, 0, 0, null);\n          graphics.drawImage(textImage, rowHeader.getWidth(), 0, null);\n        }\n        else {\n          graphics.drawImage(textImage, 0, 0, null);\n        }\n      }\n    };\n\n    setLayout(new BorderLayout());\n    add(component);\n\n    final Color borderColor = editor.getColorsScheme().getColor(EditorColors.SELECTED_TEARLINE_COLOR);\n\n    Border outsideBorder = BorderFactory.createLineBorder(borderColor, 1);\n    Border insideBorder = BorderFactory.createEmptyBorder(2, 2, 2, 2);\n    setBorder(BorderFactory.createCompoundBorder(outsideBorder, insideBorder));\n  }","id":34419,"modified_method":"private EditorFragmentComponent(EditorEx editor, int startLine, int endLine, boolean showFolding, boolean showGutter) {\n    Document doc = editor.getDocument();\n    final int endOffset = endLine < doc.getLineCount() ? doc.getLineEndOffset(endLine) : doc.getTextLength();\n    int textWidth = Math.min(editor.getMaxWidthInRange(doc.getLineStartOffset(startLine), endOffset), ScreenUtil.getScreenRectangle(1, 1).width);\n\n    FoldingModelEx foldingModel = editor.getFoldingModel();\n    boolean isFoldingEnabled = foldingModel.isFoldingEnabled();\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(false);\n    }\n\n    Point p1 = editor.logicalPositionToXY(new LogicalPosition(startLine, 0));\n    Point p2 = editor.logicalPositionToXY(new LogicalPosition(Math.max(endLine, startLine + 1), 0));\n    int y1 = p1.y;\n    int y2 = p2.y;\n\n    int savedScrollOfset = editor.getScrollingModel().getHorizontalScrollOffset();\n    if (savedScrollOfset > 0) {\n      editor.stopOptimizedScrolling();\n      editor.getScrollingModel().scrollHorizontally(0);\n    }\n\n    final Image textImage = new BufferedImage(textWidth, y2 - y1, BufferedImage.TYPE_INT_RGB);\n    Graphics textGraphics = textImage.getGraphics();\n\n    final JComponent rowHeader;\n    final Image markersImage;\n    if (showGutter) {\n      rowHeader = editor.getGutterComponentEx();\n      markersImage = new BufferedImage(Math.max(1, rowHeader.getWidth()), y2 - y1, BufferedImage.TYPE_INT_RGB);\n      Graphics markerGraphics = markersImage.getGraphics();\n\n      markerGraphics.translate(0, -y1);\n      markerGraphics.setClip(0, y1, rowHeader.getWidth(), y2 - y1);\n      markerGraphics.setColor(getBackgroundColor(editor));\n      markerGraphics.fillRect(0, y1, rowHeader.getWidth(), y2 - y1);\n      rowHeader.paint(markerGraphics);\n    }\n    else {\n      rowHeader = null;\n      markersImage = null;\n    }\n\n    textGraphics.translate(0, -y1);\n    textGraphics.setClip(0, y1, textWidth, y2 - y1);\n    final boolean wasVisible = editor.setCaretVisible(false);\n    editor.getContentComponent().paint(textGraphics);\n    if (wasVisible) {\n      editor.setCaretVisible(true);\n    }\n\n    if (!showFolding) {\n      foldingModel.setFoldingEnabled(isFoldingEnabled);\n    }\n\n    if (savedScrollOfset > 0) {\n      editor.stopOptimizedScrolling();\n      editor.getScrollingModel().scrollHorizontally(savedScrollOfset);\n    }\n\n    JComponent component = new JComponent() {\n      public Dimension getPreferredSize() {\n        return new Dimension(textImage.getWidth(null) +(markersImage == null ? 0 : markersImage.getWidth(null)), textImage.getHeight(null));\n      }\n\n      protected void paintComponent(Graphics graphics) {\n        if (markersImage != null) {\n          graphics.drawImage(markersImage, 0, 0, null);\n          graphics.drawImage(textImage, rowHeader.getWidth(), 0, null);\n        }\n        else {\n          graphics.drawImage(textImage, 0, 0, null);\n        }\n      }\n    };\n\n    setLayout(new BorderLayout());\n    add(component);\n\n    final Color borderColor = editor.getColorsScheme().getColor(EditorColors.SELECTED_TEARLINE_COLOR);\n\n    Border outsideBorder = BorderFactory.createLineBorder(borderColor, 1);\n    Border insideBorder = BorderFactory.createEmptyBorder(2, 2, 2, 2);\n    setBorder(BorderFactory.createCompoundBorder(outsideBorder, insideBorder));\n  }","commit_id":"5133fb6c7a2e8c2fd6f7f1889208c7850674a8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void compareTexts(Collection<HighlightInfo> infos, String text, String failMessage) {\n    final ArrayList<HighlightInfo> list = new ArrayList<HighlightInfo>(infos);\n    Collections.sort(list, new Comparator<HighlightInfo>() {\n      public int compare(HighlightInfo o1, HighlightInfo o2) {\n        final int start = o2.startOffset - o1.startOffset;\n        return start != 0 ? start : o1.endOffset - o2.endOffset;\n      }\n    });\n\n    StringBuilder sb = new StringBuilder();\n\n    int end = text.length();\n    HighlightInfo prev = null;\n    String prevSeverity = null;\n    for (HighlightInfo info : list) {\n      for (Map.Entry<String, ExpectedHighlightingSet> entry : highlightingTypes.entrySet()) {\n        final ExpectedHighlightingSet set = entry.getValue();\n        if (set.enabled\n            && set.severity == info.getSeverity()\n            && set.endOfLine == info.isAfterEndOfLine) {\n          final String severity = entry.getKey();\n\n          if (prev != null && info.endOffset > prev.startOffset) {  // nested ranges\n            Assert.assertTrue(\"Overlapped highlightings: \" + info + \" and \" + prev,\n                              info.endOffset >= prev.endOffset);\n\n            int offset = prevSeverity.length()*2 + 14 + (prev.description != null ? prev.description.length() : 4) + // open and closing tags\n                         (prev.endOffset - prev.startOffset) + (info.endOffset - prev.endOffset);\n            sb.insert(offset, \"<\/\" + severity + \">\");\n            sb.insert(0, text.substring(info.startOffset, prev.startOffset));\n            sb.insert(0, \"<\" + severity + \" descr=\\\"\" + info.description + \"\\\">\");\n          }\n          else {  // sequential ranges\n            sb.insert(0, text.substring(info.endOffset, end));\n            sb.insert(0, \"<\" + severity + \" descr=\\\"\" + info.description + \"\\\">\" +\n                         text.substring(info.startOffset, info.endOffset) +\n                         \"<\/\" + severity + \">\");\n          }\n\n          end = info.startOffset;\n          prev = info;\n          prevSeverity = severity;\n          break;\n        }\n      }\n    }\n    sb.insert(0, text.substring(0, end));\n\n    Assert.assertEquals(failMessage + \"\\n\", myText, sb.toString());\n    Assert.fail(failMessage);\n  }","id":34420,"modified_method":"private void compareTexts(Collection<HighlightInfo> infos, String text, String failMessage) {\n    final ArrayList<HighlightInfo> list = new ArrayList<HighlightInfo>(infos);\n    Collections.sort(list, HighlightInfo.BY_START_OFFSET);\n\n    StringBuilder sb = new StringBuilder();\n\n    int end = text.length();\n    HighlightInfo prev = null;\n    String prevSeverity = null;\n    for (HighlightInfo info : list) {\n      for (Map.Entry<String, ExpectedHighlightingSet> entry : highlightingTypes.entrySet()) {\n        final ExpectedHighlightingSet set = entry.getValue();\n        if (set.enabled\n            && set.severity == info.getSeverity()\n            && set.endOfLine == info.isAfterEndOfLine) {\n          final String severity = entry.getKey();\n\n          if (prev != null && info.endOffset > prev.startOffset) {  // nested ranges\n            Assert.assertTrue(\"Overlapped highlightings: \" + info + \" and \" + prev,\n                              info.endOffset >= prev.endOffset);\n\n            int offset = prevSeverity.length()*2 + 14 + (prev.description != null ? prev.description.length() : 4) + // open and closing tags\n                         (prev.endOffset - prev.startOffset) + (info.endOffset - prev.endOffset);\n            sb.insert(offset, \"<\/\" + severity + \">\");\n            sb.insert(0, text.substring(info.startOffset, prev.startOffset));\n            sb.insert(0, \"<\" + severity + \" descr=\\\"\" + info.description + \"\\\">\");\n          }\n          else {  // sequential ranges\n            sb.insert(0, text.substring(info.endOffset, end));\n            sb.insert(0, \"<\" + severity + \" descr=\\\"\" + info.description + \"\\\">\" +\n                         text.substring(info.startOffset, info.endOffset) +\n                         \"<\/\" + severity + \">\");\n          }\n\n          end = info.startOffset;\n          prev = info;\n          prevSeverity = severity;\n          break;\n        }\n      }\n    }\n    sb.insert(0, text.substring(0, end));\n\n    Assert.assertEquals(failMessage + \"\\n\", myText, sb.toString());\n    Assert.fail(failMessage);\n  }","commit_id":"78cd31b4c3750897e56025f2d1617c7eacb9fd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String toString() {\n    return \"FoldRegion \" + (isExpanded() ? \"-\" : \"+\") +\n           \"(\" + getStartOffset() + \":\" + getEndOffset() + \")\";\n  }","id":34421,"modified_method":"public String toString() {\n    return \"FoldRegion \" + (isExpanded() ? \"-\" : \"+\") +\n           \"(\" + getStartOffset() + \":\" + getEndOffset() + \")\" + (isValid() ? \"\" : \"(invalid)\");\n  }","commit_id":"78cd31b4c3750897e56025f2d1617c7eacb9fd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static FoldRegion findFoldRegion(Editor editor, int startOffset, int endOffset) {\n    FoldRegion[] foldRegions = ((FoldingModelEx)editor.getFoldingModel()).getAllFoldRegionsIncludingInvalid();\n    for (FoldRegion region : foldRegions) {\n      if (region.isValid() &&\n          region.getStartOffset() == startOffset\n          && region.getEndOffset() == endOffset) {\n        return region;\n      }\n    }\n\n    return null;\n  }","id":34422,"modified_method":"@Nullable\n  public static FoldRegion findFoldRegion(Editor editor, int startOffset, int endOffset) {\n    FoldRegion[] foldRegions = editor.getFoldingModel().getAllFoldRegions();\n    for (FoldRegion region : foldRegions) {\n      if (region.isValid() &&\n          region.getStartOffset() == startOffset\n          && region.getEndOffset() == endOffset) {\n        return region;\n      }\n    }\n\n    return null;\n  }","commit_id":"78cd31b4c3750897e56025f2d1617c7eacb9fd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getActualStartOffset() {\n    return highlighter == null ? startOffset : highlighter.getStartOffset();\n  }","id":34423,"modified_method":"public int getActualStartOffset() {\n    return highlighter == null || !highlighter.isValid() ? startOffset : highlighter.getStartOffset();\n  }","commit_id":"78cd31b4c3750897e56025f2d1617c7eacb9fd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getActualEndOffset() {\n    return highlighter == null ? endOffset : highlighter.getEndOffset();\n  }","id":34424,"modified_method":"public int getActualEndOffset() {\n    return highlighter == null || !highlighter.isValid() ? endOffset : highlighter.getEndOffset();\n  }","commit_id":"78cd31b4c3750897e56025f2d1617c7eacb9fd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PersistentRangeMarker(DocumentEx document, int startOffset, int endOffset) {\n    super(document, startOffset, endOffset);\n    storeLinesAndCols();\n  }","id":34425,"modified_method":"PersistentRangeMarker(DocumentEx document, int startOffset, int endOffset) {\n    super(document, startOffset, endOffset);\n    storeLinesAndCols();\n  }","commit_id":"78cd31b4c3750897e56025f2d1617c7eacb9fd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) {\n    myProject = project;\n    myFile = file;\n    myDocument = editor.getDocument();\n\n    if (!myFile.isWritable()) {\n      if (!FileDocumentManager.fileForDocumentCheckedOutSuccessfully(myDocument, project)) {\n        return;\n      }\n    }\n\n    PsiDocumentManager.getInstance(project).commitDocument(myDocument);\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.comment.line\");\n\n    //myCodeInsightSettings = (CodeInsightSettings)ApplicationManager.getApplication().getComponent(CodeInsightSettings.class);\n    myCodeStyleManager = CodeStyleManager.getInstance(myProject);\n\n    final SelectionModel selectionModel = editor.getSelectionModel();\n\n    boolean hasSelection = selectionModel.hasSelection();\n    myStartOffset = selectionModel.getSelectionStart();\n    myEndOffset = selectionModel.getSelectionEnd();\n\n    if (myDocument.getTextLength() == 0) return;\n\n    int lastLineEnd = myDocument.getLineEndOffset(myDocument.getLineNumber(myEndOffset));\n    FoldRegion collapsedAt = ((FoldingModelImpl)editor.getFoldingModel()).getCollapsedRegionAtOffset(lastLineEnd);\n    if (collapsedAt != null) {\n      myEndOffset = Math.max(myEndOffset, collapsedAt.getEndOffset());\n    }\n\n    boolean wholeLinesSelected = !hasSelection || (\n      myStartOffset == myDocument.getLineStartOffset(myDocument.getLineNumber(myStartOffset)) &&\n      myEndOffset == myDocument.getLineEndOffset(myDocument.getLineNumber(myEndOffset - 1)) + 1);\n\n    boolean startingNewLineComment = !hasSelection && isLineEmpty(myDocument.getLineNumber(myStartOffset)) && !Comparing\n      .equal(IdeActions.ACTION_COMMENT_LINE, ActionManagerEx.getInstanceEx().getPrevPreformedActionId());\n    doComment();\n\n    if (startingNewLineComment) {\n      final Commenter commenter = myCommenters[0];\n      if (commenter != null) {\n        String prefix = commenter.getLineCommentPrefix();\n        if (prefix == null) prefix = commenter.getBlockCommentPrefix();\n        int lineStart = myDocument.getLineStartOffset(myLine1);\n        lineStart = CharArrayUtil.shiftForward(myDocument.getCharsSequence(), lineStart, \" \\t\");\n        lineStart += prefix.length();\n        if (lineStart < myDocument.getTextLength() && myDocument.getCharsSequence().charAt(lineStart) == ' ') lineStart++;\n        editor.getCaretModel().moveToOffset(lineStart);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      }\n    }\n    else {\n      if (!hasSelection) {\n        editor.getCaretModel().moveCaretRelatively(0, 1, false, false, true);\n      }\n      else {\n        if (wholeLinesSelected) {\n          selectionModel.setSelection(myStartOffset, selectionModel.getSelectionEnd());\n        }\n      }\n    }\n  }","id":34426,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) {\n    myProject = project;\n    myFile = file;\n    myDocument = editor.getDocument();\n\n    if (!myFile.isWritable()) {\n      if (!FileDocumentManager.fileForDocumentCheckedOutSuccessfully(myDocument, project)) {\n        return;\n      }\n    }\n\n    PsiDocumentManager.getInstance(project).commitDocument(myDocument);\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.comment.line\");\n\n    //myCodeInsightSettings = (CodeInsightSettings)ApplicationManager.getApplication().getComponent(CodeInsightSettings.class);\n    myCodeStyleManager = CodeStyleManager.getInstance(myProject);\n\n    final SelectionModel selectionModel = editor.getSelectionModel();\n\n    boolean hasSelection = selectionModel.hasSelection();\n    myStartOffset = selectionModel.getSelectionStart();\n    myEndOffset = selectionModel.getSelectionEnd();\n\n    if (myDocument.getTextLength() == 0) return;\n\n    int lastLineEnd = myDocument.getLineEndOffset(myDocument.getLineNumber(myEndOffset));\n    FoldRegion collapsedAt = editor.getFoldingModel().getCollapsedRegionAtOffset(lastLineEnd);\n    if (collapsedAt != null) {\n      myEndOffset = Math.max(myEndOffset, collapsedAt.getEndOffset());\n    }\n\n    boolean wholeLinesSelected = !hasSelection || (\n      myStartOffset == myDocument.getLineStartOffset(myDocument.getLineNumber(myStartOffset)) &&\n      myEndOffset == myDocument.getLineEndOffset(myDocument.getLineNumber(myEndOffset - 1)) + 1);\n\n    boolean startingNewLineComment = !hasSelection && isLineEmpty(myDocument.getLineNumber(myStartOffset)) && !Comparing\n      .equal(IdeActions.ACTION_COMMENT_LINE, ActionManagerEx.getInstanceEx().getPrevPreformedActionId());\n    doComment();\n\n    if (startingNewLineComment) {\n      final Commenter commenter = myCommenters[0];\n      if (commenter != null) {\n        String prefix = commenter.getLineCommentPrefix();\n        if (prefix == null) prefix = commenter.getBlockCommentPrefix();\n        int lineStart = myDocument.getLineStartOffset(myLine1);\n        lineStart = CharArrayUtil.shiftForward(myDocument.getCharsSequence(), lineStart, \" \\t\");\n        lineStart += prefix.length();\n        if (lineStart < myDocument.getTextLength() && myDocument.getCharsSequence().charAt(lineStart) == ' ') lineStart++;\n        editor.getCaretModel().moveToOffset(lineStart);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      }\n    }\n    else {\n      if (!hasSelection) {\n        editor.getCaretModel().moveCaretRelatively(0, 1, false, false, true);\n      }\n      else {\n        if (wholeLinesSelected) {\n          selectionModel.setSelection(myStartOffset, selectionModel.getSelectionEnd());\n        }\n      }\n    }\n  }","commit_id":"650f186b3c92947e25fc6b10f357d18fd3c1a10e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GutterIconRenderer getGutterRenderer(final Point p) {\n    final int ex = convertX((int)p.getX());\n    int line = myEditor.xyToLogicalPosition(new Point(0, (int)p.getY())).line;\n    ArrayList<GutterIconRenderer> renderers = myLineToGutterRenderers.get(line);\n    if (renderers == null) return null;\n\n    if (line >= myEditor.getDocument().getLineCount()) return null;\n\n    int startOffset = myEditor.getDocument().getLineStartOffset(line);\n    if (myEditor.getFoldingModel().isOffsetCollapsed(startOffset)) return null;\n\n    final GutterIconRenderer[] result = new GutterIconRenderer[]{null};\n    processIconsRow(line, renderers, new LineGutterIconRendererProcessor() {\n      public void process(int x, int y, GutterIconRenderer renderer) {\n        Icon icon = renderer.getIcon();\n        if (x <= ex && ex <= x + icon.getIconWidth() &&\n            y <= p.getY() && p.getY() <= y + icon.getIconHeight()) {\n          result[0] = renderer;\n        }\n      }\n    });\n\n    return result[0];\n  }","id":34427,"modified_method":"@Nullable\n  private GutterIconRenderer getGutterRenderer(final Point p) {\n    final int ex = convertX((int)p.getX());\n    int line = myEditor.xyToLogicalPosition(new Point(0, (int)p.getY())).line;\n\n    if (line >= myEditor.getDocument().getLineCount()) return null;\n    int startOffset = myEditor.getDocument().getLineStartOffset(line);\n    final FoldRegion region = myEditor.getFoldingModel().getCollapsedRegionAtOffset(startOffset);\n    if (region != null) {\n      line = myEditor.getDocument().getLineNumber(region.getEndOffset());\n      if (line >= myEditor.getDocument().getLineCount()) return null;\n    }\n\n    ArrayList<GutterIconRenderer> renderers = myLineToGutterRenderers.get(line);\n    if (renderers == null) return null;\n\n    final GutterIconRenderer[] result = new GutterIconRenderer[]{null};\n    processIconsRow(line, renderers, new LineGutterIconRendererProcessor() {\n      public void process(int x, int y, GutterIconRenderer renderer) {\n        Icon icon = renderer.getIcon();\n        if (x <= ex && ex <= x + icon.getIconWidth() &&\n            y <= p.getY() && p.getY() <= y + icon.getIconHeight()) {\n          result[0] = renderer;\n        }\n      }\n    });\n\n    return result[0];\n  }","commit_id":"650f186b3c92947e25fc6b10f357d18fd3c1a10e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintIcons(final int firstVisibleLine, final int lastVisibleLine, final Graphics g) {\n    myLineToGutterRenderers.forEachKey(new TIntProcedure() {\n      public boolean execute(int line) {\n        if (firstVisibleLine > line || lastVisibleLine < line) return true;\n        int startOffset = myEditor.getDocument().getLineStartOffset(line);\n        if (myEditor.getFoldingModel().isOffsetCollapsed(startOffset)) return true;\n        ArrayList<GutterIconRenderer> renderers = myLineToGutterRenderers.get(line);\n        paintIconRow(line, renderers, g);\n        return true;\n      }\n    });\n  }","id":34428,"modified_method":"private void paintIcons(final int firstVisibleLine, final int lastVisibleLine, final Graphics g) {\n    myLineToGutterRenderers.forEachKey(new TIntProcedure() {\n      public boolean execute(int line) {\n        if (firstVisibleLine > line || lastVisibleLine < line) return true;\n        if (isLineCollapsed(line)) return true;\n        ArrayList<GutterIconRenderer> renderers = myLineToGutterRenderers.get(line);\n        paintIconRow(line, renderers, g);\n        return true;\n      }\n    });\n  }","commit_id":"650f186b3c92947e25fc6b10f357d18fd3c1a10e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isFoldingOutlineShown() {\n    return myEditor.getSettings().isFoldingOutlineShown() &&\n           ((FoldingModelEx)myEditor.getFoldingModel()).isFoldingEnabled();\n  }","id":34429,"modified_method":"public boolean isFoldingOutlineShown() {\n    return myEditor.getSettings().isFoldingOutlineShown() &&\n           myEditor.getFoldingModel().isFoldingEnabled();\n  }","commit_id":"90db1e61e0fdaf175a84da796ff98301f61745e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void moveToLogicalPosition(LogicalPosition pos) {\n    validateCallContext();\n    int column = pos.column;\n    int line = pos.line;\n\n    Document doc = myEditor.getDocument();\n\n    if (column < 0) column = 0;\n    if (line < 0) line = 0;\n\n    int lineCount = doc.getLineCount();\n    if (lineCount == 0) {\n      line = 0;\n    }\n    else if (line > lineCount - 1) {\n      line = lineCount - 1;\n    }\n\n    EditorSettings editorSettings = myEditor.getSettings();\n\n    if (!editorSettings.isVirtualSpace() && line < lineCount) {\n      int lineEndOffset = doc.getLineEndOffset(line);\n      int lineEndColumnNumber = myEditor.offsetToLogicalPosition(lineEndOffset).column;\n      if (column > lineEndColumnNumber) {\n        column = lineEndColumnNumber;\n      }\n    }\n\n    ((FoldingModelImpl)myEditor.getFoldingModel()).flushCaretPosition();\n\n    int oldY = myEditor.visibleLineNumberToYPosition(myVisibleCaret.line);\n\n    LogicalPosition oldCaretPosition = myLogicalCaret;\n\n    myLogicalCaret = new LogicalPosition(line, column);\n\n    final int offset = myEditor.logicalPositionToOffset(myLogicalCaret);\n\n    FoldRegion collapsedAt = ((FoldingModelImpl)myEditor.getFoldingModel()).getCollapsedRegionAtOffset(offset);\n\n    if (collapsedAt != null && offset > collapsedAt.getStartOffset()) {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          FoldRegion[] allCollapsedAt = ((FoldingModelImpl)myEditor.getFoldingModel()).fetchCollapsedAt(offset);\n          for (FoldRegion foldRange : allCollapsedAt) {\n            foldRange.setExpanded(true);\n          }\n        }\n      };\n\n      myEditor.getFoldingModel().runBatchFoldingOperation(runnable);\n    }\n\n    myEditor.setLastColumnNumber(myLogicalCaret.column);\n    myVisibleCaret = myEditor.logicalToVisualPosition(myLogicalCaret);\n\n    myOffset = myEditor.logicalPositionToOffset(myLogicalCaret);\n    LOG.assertTrue(myOffset >= 0 && myOffset <= myEditor.getDocument().getTextLength());\n\n    myVisualLineStart =\n    myEditor.logicalPositionToOffset(myEditor.visualToLogicalPosition(new VisualPosition(myVisibleCaret.line, 0)));\n    myVisualLineEnd =\n    myEditor.logicalPositionToOffset(myEditor.visualToLogicalPosition(new VisualPosition(myVisibleCaret.line + 1, 0)));\n\n    myEditor.updateCaretCursor();\n    requestRepaint(oldY);\n\n    if (oldCaretPosition.column != myLogicalCaret.column || oldCaretPosition.line != myLogicalCaret.line) {\n      CaretEvent event = new CaretEvent(myEditor, oldCaretPosition, myLogicalCaret);\n      for (CaretListener listener : myCaretListeners) {\n        listener.caretPositionChanged(event);\n      }\n    }\n  }","id":34430,"modified_method":"public void moveToLogicalPosition(LogicalPosition pos) {\n    validateCallContext();\n    int column = pos.column;\n    int line = pos.line;\n\n    Document doc = myEditor.getDocument();\n\n    if (column < 0) column = 0;\n    if (line < 0) line = 0;\n\n    int lineCount = doc.getLineCount();\n    if (lineCount == 0) {\n      line = 0;\n    }\n    else if (line > lineCount - 1) {\n      line = lineCount - 1;\n    }\n\n    EditorSettings editorSettings = myEditor.getSettings();\n\n    if (!editorSettings.isVirtualSpace() && line < lineCount) {\n      int lineEndOffset = doc.getLineEndOffset(line);\n      int lineEndColumnNumber = myEditor.offsetToLogicalPosition(lineEndOffset).column;\n      if (column > lineEndColumnNumber) {\n        column = lineEndColumnNumber;\n      }\n    }\n\n    ((FoldingModelImpl)myEditor.getFoldingModel()).flushCaretPosition();\n\n    int oldY = myEditor.visibleLineNumberToYPosition(myVisibleCaret.line);\n\n    LogicalPosition oldCaretPosition = myLogicalCaret;\n\n    myLogicalCaret = new LogicalPosition(line, column);\n\n    final int offset = myEditor.logicalPositionToOffset(myLogicalCaret);\n\n    FoldRegion collapsedAt = myEditor.getFoldingModel().getCollapsedRegionAtOffset(offset);\n\n    if (collapsedAt != null && offset > collapsedAt.getStartOffset()) {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          FoldRegion[] allCollapsedAt = ((FoldingModelImpl)myEditor.getFoldingModel()).fetchCollapsedAt(offset);\n          for (FoldRegion foldRange : allCollapsedAt) {\n            foldRange.setExpanded(true);\n          }\n        }\n      };\n\n      myEditor.getFoldingModel().runBatchFoldingOperation(runnable);\n    }\n\n    myEditor.setLastColumnNumber(myLogicalCaret.column);\n    myVisibleCaret = myEditor.logicalToVisualPosition(myLogicalCaret);\n\n    myOffset = myEditor.logicalPositionToOffset(myLogicalCaret);\n    LOG.assertTrue(myOffset >= 0 && myOffset <= myEditor.getDocument().getTextLength());\n\n    myVisualLineStart =\n    myEditor.logicalPositionToOffset(myEditor.visualToLogicalPosition(new VisualPosition(myVisibleCaret.line, 0)));\n    myVisualLineEnd =\n    myEditor.logicalPositionToOffset(myEditor.visualToLogicalPosition(new VisualPosition(myVisibleCaret.line + 1, 0)));\n\n    myEditor.updateCaretCursor();\n    requestRepaint(oldY);\n\n    if (oldCaretPosition.column != myLogicalCaret.column || oldCaretPosition.line != myLogicalCaret.line) {\n      CaretEvent event = new CaretEvent(myEditor, oldCaretPosition, myLogicalCaret);\n      for (CaretListener listener : myCaretListeners) {\n        listener.caretPositionChanged(event);\n      }\n    }\n  }","commit_id":"2671a5c037412a33c525937c71fa4546bf8fe3fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public static String relativeClassNameToFilePath(@NotNull FqNameUnsafe className) {\n        List<String> correctedSegments = new ArrayList<String>();\n        for (Name segment : className.pathSegments()) {\n            if (segment.asString().startsWith(\"<class-object-for\")) {\n                correctedSegments.add(CLASS_OBJECT_NAME);\n            }\n            else {\n                assert !segment.isSpecial();\n                correctedSegments.add(segment.asString());\n            }\n        }\n        return FqName.fromSegments(correctedSegments).asString();\n    }","id":34431,"modified_method":"@NotNull\n    public static String relativeClassNameToFilePath(@NotNull FqNameUnsafe className) {\n        List<Name> segments = className.pathSegments();\n        List<String> correctedSegments = new ArrayList<String>(segments.size());\n        for (Name segment : segments) {\n            correctedSegments.add(isClassObjectName(segment) ? CLASS_OBJECT_NAME : segment.getIdentifier());\n        }\n        return FqName.fromSegments(correctedSegments).asString();\n    }","commit_id":"8b5aa94484378b60129156b151b5b5563f711430","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static FqName kotlinFqNameToJavaFqName(@NotNull FqNameUnsafe kotlinFqName) {\n        List<String> correctedSegments = new ArrayList<String>();\n        for (Name segment : kotlinFqName.pathSegments()) {\n            if (segment.asString().startsWith(\"<class-object-for\")) {\n                correctedSegments.add(JvmAbi.CLASS_OBJECT_CLASS_NAME);\n            }\n            else {\n                assert !segment.isSpecial();\n                correctedSegments.add(segment.asString());\n            }\n        }\n        return FqName.fromSegments(correctedSegments);\n    }","id":34432,"modified_method":"@NotNull\n    public static FqName kotlinFqNameToJavaFqName(@NotNull FqNameUnsafe kotlinFqName) {\n        List<Name> segments = kotlinFqName.pathSegments();\n        List<String> correctedSegments = new ArrayList<String>(segments.size());\n        for (Name segment : segments) {\n            correctedSegments.add(isClassObjectName(segment) ? JvmAbi.CLASS_OBJECT_CLASS_NAME : segment.getIdentifier());\n        }\n        return FqName.fromSegments(correctedSegments);\n    }","commit_id":"8b5aa94484378b60129156b151b5b5563f711430","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static Name getClassObjectName(@NotNull Name className) {\n        return Name.special(\"<class-object-for-\" + className.asString() + \">\");\n    }","id":34433,"modified_method":"@NotNull\n    public static Name getClassObjectName(@NotNull Name className) {\n        return Name.special(CLASS_OBJECT_FOR + className.asString() + \">\");\n    }","commit_id":"8b5aa94484378b60129156b151b5b5563f711430","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\r\n  public Expr compile(final QueryContext ctx, final VarScope scp) throws QueryException {\r\n    ts = ts.compile(ctx, scp);\r\n    // static condition: return branch in question\r\n    if(ts.isValue()) {\r\n      final Value val = ts.value(ctx);\r\n      for(final TypeCase tc : cases) {\r\n        if(tc.matches(val))\r\n          return optPre(tc.compile(ctx, scp, (Value) ts).expr, ctx);\r\n      }\r\n    }\r\n    // compile branches\r\n    for(final TypeCase tc : cases) tc.compile(ctx, scp);\r\n\r\n    // return first branch if all branches are equal (e.g., empty) and use no variables\r\n    boolean eq = true;\r\n    for(int i = 1; i < cases.length; ++i) {\r\n      final TypeCase tc = cases[i - 1];\r\n      eq &= tc.expr.sameAs(cases[i].expr) && tc.var == null;\r\n    }\r\n    if(eq) return optPre(cases[0].expr.item(ctx, info), ctx);\r\n\r\n    type = cases[0].type();\r\n    for(int c = 1; c < cases.length; ++c) {\r\n      type = type.union(cases[c].type());\r\n    }\r\n    return this;\r\n  }","id":34434,"modified_method":"@Override\r\n  public Expr compile(final QueryContext ctx, final VarScope scp) throws QueryException {\r\n    ts = ts.compile(ctx, scp);\r\n    // static condition: return branch in question\r\n    if(ts.isValue()) {\r\n      final Value val = ts.value(ctx);\r\n      for(final TypeCase tc : cases) {\r\n        if(tc.matches(val))\r\n          return optPre(tc.compile(ctx, scp, (Value) ts).expr, ctx);\r\n      }\r\n    }\r\n    // compile branches\r\n    for(final TypeCase tc : cases) tc.compile(ctx, scp);\r\n\r\n    // return first branch if all branches are equal (e.g., empty) and use no variables\r\n    final TypeCase tc = cases[0];\r\n    boolean eq = tc.var == null;\r\n    for(int c = 1; eq && c < cases.length; ++c) {\r\n      eq = tc.expr.sameAs(cases[c].expr);\r\n    }\r\n    if(eq) return optPre(tc.expr, ctx);\r\n\r\n    // combine return types\r\n    type = cases[0].type();\r\n    for(int c = 1; c < cases.length; ++c) {\r\n      type = type.union(cases[c].type());\r\n    }\r\n    return this;\r\n  }","commit_id":"8dd6c33eed540195531a48392599e9ae79735a8b","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Expr compile(final QueryContext ctx, final VarScope scp) throws QueryException {\r\n    ts = ts.compile(ctx, scp);\r\n    // static condition: return branch in question\r\n    if(ts.isValue()) {\r\n      final Value val = ts.value(ctx);\r\n      for(final TypeCase tc : cases) {\r\n        if(tc.matches(val))\r\n          return optPre(tc.compile(ctx, scp, (Value) ts).expr, ctx);\r\n      }\r\n    }\r\n    // compile branches\r\n    for(final TypeCase tc : cases) tc.compile(ctx, scp);\r\n\r\n    // return result if all branches are equal (e.g., empty)\r\n    boolean eq = true;\r\n    for(int i = 1; i < cases.length; ++i) {\r\n      eq &= cases[i - 1].expr.sameAs(cases[i].expr);\r\n    }\r\n    if(eq) return preEval(ctx);\r\n\r\n    type = cases[0].type();\r\n    for(int c = 1; c < cases.length; ++c) {\r\n      type = type.union(cases[c].type());\r\n    }\r\n    return this;\r\n  }","id":34435,"modified_method":"@Override\r\n  public Expr compile(final QueryContext ctx, final VarScope scp) throws QueryException {\r\n    ts = ts.compile(ctx, scp);\r\n    // static condition: return branch in question\r\n    if(ts.isValue()) {\r\n      final Value val = ts.value(ctx);\r\n      for(final TypeCase tc : cases) {\r\n        if(tc.matches(val))\r\n          return optPre(tc.compile(ctx, scp, (Value) ts).expr, ctx);\r\n      }\r\n    }\r\n    // compile branches\r\n    for(final TypeCase tc : cases) tc.compile(ctx, scp);\r\n\r\n    // return first branch if all branches are equal (e.g., empty) and use no variables\r\n    boolean eq = true;\r\n    for(int i = 1; i < cases.length; ++i) {\r\n      final TypeCase tc = cases[i - 1];\r\n      eq &= tc.expr.sameAs(cases[i].expr) && tc.var == null;\r\n    }\r\n    if(eq) return optPre(cases[0].expr.item(ctx, info), ctx);\r\n\r\n    type = cases[0].type();\r\n    for(int c = 1; c < cases.length; ++c) {\r\n      type = type.union(cases[c].type());\r\n    }\r\n    return this;\r\n  }","commit_id":"4645a18843cba440f33824dd9fa8863fe836592d","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected HighlighterMessage createHighlighterMessage(SNode node, String message, IErrorReporter errorReporter) {\n    if (errorReporter == null) {\n      errorReporter = new SimpleErrorReporter(node, message, null, null, MessageStatus.ERROR, new NodeErrorTarget());\n    }\n    final MessageStatus status = errorReporter.getMessageStatus();\n    HighlighterMessage error = new HighlighterMessage(node, status, errorReporter.getErrorTarget(), getMessageColor(status), message, getOwner(node.getContainingRoot()));\n    error.setErrorReporter(errorReporter);\n    return error;\n  }","id":34436,"modified_method":"protected HighlighterMessage createHighlighterMessage(SNode node, String message, IErrorReporter errorReporter) {\n    if (errorReporter == null) {\n      errorReporter = new SimpleErrorReporter(node, message, null, null, MessageStatus.ERROR, new NodeErrorTarget());\n    }\n    final MessageStatus status = errorReporter.getMessageStatus();\n    HighlighterMessage error = new HighlighterMessage(node, status,\n      errorReporter.getErrorTarget().toEditorMessageTarget(), getMessageColor(status), message, getOwner(node.getContainingRoot()));\n    error.setErrorReporter(errorReporter);\n    return error;\n  }","commit_id":"c45e573f9dad90bc702873125d9efc6825892447","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean sameAs(EditorMessage message) {\n    if (!(message instanceof HighlighterMessage)) {\n      return false;\n    }\n    if (!super.sameAs(message)) {\n      return false;\n    }\n    return myErrorTarget.sameAs(((HighlighterMessage) message).myErrorTarget);\n  }","id":34437,"modified_method":"@Override\n  public boolean sameAs(EditorMessage message) {\n    if (!(message instanceof HighlighterMessage)) {\n      return false;\n    }\n    return super.sameAs(message);\n  }","commit_id":"c45e573f9dad90bc702873125d9efc6825892447","url":"https://github.com/JetBrains/MPS"},{"original_method":"public HighlighterMessage(SNode errorNode, MessageStatus status, IErrorTarget target, Color color, String string, EditorMessageOwner owner) {\n    super(errorNode, status, color, string, owner);\n    myErrorTarget = target;\n  }","id":34438,"modified_method":"public HighlighterMessage(SNode errorNode, MessageStatus status, EditorMessageTarget target, Color color, String string, EditorMessageOwner owner) {\n    super(errorNode, status, target, color, string, owner);\n  }","commit_id":"c45e573f9dad90bc702873125d9efc6825892447","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ErrorTargetEnum getTarget() {\n    return ErrorTargetEnum.NODE;\n  }","id":34439,"modified_method":"public MessageTargetEnum getTarget() {\n    return MessageTargetEnum.NODE;\n  }","commit_id":"c45e573f9dad90bc702873125d9efc6825892447","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ErrorTargetEnum getTarget() {\n    return ErrorTargetEnum.PROPERTY;\n  }","id":34440,"modified_method":"public MessageTargetEnum getTarget() {\n    return MessageTargetEnum.PROPERTY;\n  }","commit_id":"c45e573f9dad90bc702873125d9efc6825892447","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ErrorTargetEnum getTarget() {\n    return ErrorTargetEnum.REFERENCE;\n  }","id":34441,"modified_method":"public MessageTargetEnum getTarget() {\n    return MessageTargetEnum.REFERENCE;\n  }","commit_id":"c45e573f9dad90bc702873125d9efc6825892447","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean sameAs(EditorMessage message) {\n    if (!(message instanceof EditorMessageWithTarget)) {\n      return false;\n    }\n    if (!super.sameAs(message)) {\n      return false;\n    }\n    return myMessageTarget.sameAs(((EditorMessageWithTarget) message).myMessageTarget);\n  }","id":34442,"modified_method":"@Override\n  public boolean sameAs(EditorMessage message) {\n    return super.sameAs(message) && message instanceof EditorMessageWithTarget\n      && myMessageTarget.sameAs(((EditorMessageWithTarget) message).myMessageTarget);\n  }","commit_id":"c622f224d95610e133951e9f92ce917ee9535f8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell getCell(EditorComponent editor) {\n    final EditorCell rawCell = super.getCell(editor);\n    if (rawCell == null) {\n      return null;\n    }\n    if (myMessageTarget.getTarget() == MessageTargetEnum.NODE) {\n      return rawCell;\n    }\n    if (myMessageTarget.getTarget() == MessageTargetEnum.REFERENCE) {\n      EditorCell child = rawCell.findChild(CellFinders.byCondition(new Condition<EditorCell>() {\n        public boolean met(EditorCell cell) {\n          return cell.isReferenceCell() && myMessageTarget.getRole().equals(cell.getRole()) && cell.getSNode() == getNode();\n        }\n      }, true), true);\n      if (child != null) {\n        return child;\n      } else {\n        return rawCell;\n      }\n    }\n    if (myMessageTarget.getTarget() == MessageTargetEnum.PROPERTY) {\n      EditorCell child = rawCell.findChild(CellFinders.byCondition(new Condition<EditorCell>() {\n        public boolean met(EditorCell cell) {\n          if (!(cell instanceof EditorCell_Property)) return false;\n          EditorCell_Property propertyCell = (EditorCell_Property) cell;\n          ModelAccessor modelAccessor = propertyCell.getModelAccessor();\n          if (!(modelAccessor instanceof PropertyAccessor)) {\n            return false;\n          }\n          if (getNode() == propertyCell.getSNode() && myMessageTarget.getRole().equals(((PropertyAccessor) modelAccessor).getPropertyName())) {\n            return true;\n          }\n          return false;\n        }\n      }, true), true);\n      if (child != null) {\n        return child;\n      } else {\n        return rawCell;\n      }\n    }\n    if (myMessageTarget.getTarget() == MessageTargetEnum.DELETED_CHILD) {\n      EditorCell child = rawCell.findChild(CellFinders.byCondition(new Condition<EditorCell>() {\n        @Override\n        public boolean met(EditorCell cell) {\n          return myMessageTarget.getRole().equals(cell.getRole()) && getNode() == cell.getSNode();\n        }\n      }, true), true);\n      if (child != null) {\n        return child;\n      }\n      return rawCell;\n    }\n    return null;\n  }","id":34443,"modified_method":"public EditorCell getCell(EditorComponent editor) {\n    switch (myMessageTarget.getTarget()) {\n      case NODE:\n        return super.getCell(editor);\n      case REFERENCE:\n        return CellFinder.getCellForReference(editor, getNode(), myMessageTarget.getRole());\n      case PROPERTY:\n        return CellFinder.getCellForProperty(editor, getNode(), myMessageTarget.getRole());\n      case DELETED_CHILD:\n        return CellFinder.getCellForDeletedChild(editor, getNode(), myMessageTarget.getRole());\n      default:\n        return null;\n    }\n  }","commit_id":"c622f224d95610e133951e9f92ce917ee9535f8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean acceptCell(EditorCell cell, EditorComponent editor) {\n    //cell can be not a big one so we don't call super.acceptCell\n    if (cell == null) {\n      return false;\n    }\n    if (!editor.isValid(cell)) {\n      return false;\n    }\n\n    if (cell.getSNode() != getNode()) {\n      return false;\n    }\n\n    //for ErrorTargetEnum.NODE should be a big cell\n    if (myMessageTarget.getTarget() == MessageTargetEnum.NODE) {\n      return cell.isBigCell();\n    }\n\n    if (myMessageTarget.getTarget() == MessageTargetEnum.REFERENCE) {\n      if (cell.isReferenceCell()) {\n        return myMessageTarget.getRole().equals(cell.getRole()) && getNode() == cell.getSNode();\n      } else {\n        return cell.isBigCell() && getCell(editor) == cell;\n      }\n    }\n\n    if (myMessageTarget.getTarget() == MessageTargetEnum.PROPERTY) {\n      if (!(cell instanceof EditorCell_Property)) {\n        return cell.isBigCell() && getCell(editor) == cell;\n      }\n      EditorCell_Property propertyCell = (EditorCell_Property) cell;\n      ModelAccessor modelAccessor = propertyCell.getModelAccessor();\n      if (modelAccessor instanceof PropertyAccessor) {\n        return myMessageTarget.getRole().equals(((PropertyAccessor) modelAccessor).getPropertyName()) && getNode() == propertyCell.getSNode();\n      }\n    }\n\n    if (myMessageTarget.getTarget() == MessageTargetEnum.DELETED_CHILD) {\n      return getCell(editor) == cell;\n    }\n\n    return false;\n  }","id":34444,"modified_method":"public boolean acceptCell(EditorCell cell, EditorComponent editor) {\n    //cell can be not a big one so we don't call super.acceptCell\n    if (cell == null || !editor.isValid(cell) || cell.getSNode() != getNode()) {\n      return false;\n    }\n\n    switch (myMessageTarget.getTarget()) {\n      case NODE:\n        return cell.isBigCell();\n      case REFERENCE:\n        if (cell.isReferenceCell()) {\n          return myMessageTarget.getRole().equals(cell.getRole()) && getNode() == cell.getSNode();\n        } else {\n          return cell.isBigCell() && getCell(editor) == cell;\n        }\n      case PROPERTY:\n        if (!(cell instanceof EditorCell_Property)) {\n          return cell.isBigCell() && getCell(editor) == cell;\n        }\n        EditorCell_Property propertyCell = (EditorCell_Property) cell;\n        ModelAccessor modelAccessor = propertyCell.getModelAccessor();\n        if (modelAccessor instanceof PropertyAccessor) {\n          return myMessageTarget.getRole().equals(((PropertyAccessor) modelAccessor).getPropertyName()) && getNode() == propertyCell.getSNode();\n        }\n      case DELETED_CHILD:\n        if (myMessageTarget.getTarget() == MessageTargetEnum.DELETED_CHILD) {\n          return getCell(editor) == cell;\n        }\n      default:\n        return false;\n    }\n  }","commit_id":"c622f224d95610e133951e9f92ce917ee9535f8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void process(XmlXpathHelper eventXml) throws XmlXpathHelper.XmlParserException {\n\n    final String testId = getTestId(eventXml);\n\n    final String startTime = eventXml.queryXml(\"/ijLog/event/test/result/@startTime\");\n    final String endTime = eventXml.queryXml(\"/ijLog/event/test/result/@endTime\");\n    final String exceptionMsg = eventXml.queryXml(\"/ijLog/event/test/result/errorMsg\");\n    final String stackTrace = eventXml.queryXml(\"/ijLog/event/test/result/stackTrace\");\n\n    final SMTestProxy testProxy = findTestProxy(testId);\n    if (testProxy == null) return;\n\n    try {\n      testProxy.setDuration(Long.valueOf(endTime) - Long.valueOf(startTime));\n    }\n    catch (NumberFormatException ignored) {\n    }\n\n    final CompositeRunnable runInEdt = new CompositeRunnable();\n    final TestEventResult result = getTestEventResultType(eventXml);\n    switch (result) {\n      case SUCCESS:\n        runInEdt.add(() -> testProxy.setFinished());\n        break;\n      case FAILURE:\n        final String failureType = eventXml.queryXml(\"/ijLog/event/test/result/failureType\");\n        if (\"comparison\".equals(failureType)) {\n          String actualText = eventXml.queryXml(\"/ijLog/event/test/result/actual\");\n          String expectedText = eventXml.queryXml(\"/ijLog/event/test/result/expected\");\n          final Condition<String> emptyString = s -> StringUtil.isEmpty(s);\n          String filePath = ObjectUtils.nullizeByCondition(\n            eventXml.queryXml(\"/ijLog/event/test/result/filePath\"), emptyString);\n          String actualFilePath = ObjectUtils.nullizeByCondition(\n            eventXml.queryXml(\"/ijLog/event/test/result/actualFilePath\"), emptyString);\n          testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, actualText, expectedText, filePath, actualFilePath);\n        }\n        else {\n          Couple<String> comparisonPair =\n            parseComparisonMessage(exceptionMsg, \"\\nExpected: is \\\"(.*)\\\"\\n\\\\s*got: \\\"(.*)\\\"\\n\");\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\nExpected: is \\\"(.*)\\\"\\n\\\\s*but: was \\\"(.*)\\\"\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\nExpected: (.*)\\n\\\\s*got: (.*)\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\\\s*expected same:<(.*)> was not:<(.*)>\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \".*\\\\s*expected:<(.*)> but was:<(.*)>\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\nExpected: \\\"(.*)\\\"\\n\\\\s*but: was \\\"(.*)\\\"\");\n          }\n\n          final Couple<String> finalComparisonPair = comparisonPair;\n          runInEdt.add(() -> {\n            if (finalComparisonPair != null) {\n              testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, finalComparisonPair.second, finalComparisonPair.first);\n            }\n            else {\n              testProxy.setTestFailed(exceptionMsg, stackTrace, \"error\".equals(failureType));\n            }\n          });\n        }\n        runInEdt.add(() -> getResultsViewer().onTestFailed(testProxy));\n        break;\n      case SKIPPED:\n        runInEdt.add(() -> {\n          testProxy.setTestIgnored(null, null);\n          getResultsViewer().onTestIgnored(testProxy);\n        });\n        break;\n      case UNKNOWN_RESULT:\n        break;\n    }\n\n    runInEdt.add(() -> getResultsViewer().onTestFinished(testProxy));\n\n    addToInvokeLater(runInEdt);\n  }","id":34445,"modified_method":"@Override\n  public void process(XmlXpathHelper eventXml) throws XmlXpathHelper.XmlParserException {\n\n    final String testId = getTestId(eventXml);\n\n    final String startTime = eventXml.queryXml(\"/ijLog/event/test/result/@startTime\");\n    final String endTime = eventXml.queryXml(\"/ijLog/event/test/result/@endTime\");\n    final String exceptionMsg = decode(eventXml.queryXml(\"/ijLog/event/test/result/errorMsg\"));\n    final String stackTrace = decode(eventXml.queryXml(\"/ijLog/event/test/result/stackTrace\"));\n\n    final SMTestProxy testProxy = findTestProxy(testId);\n    if (testProxy == null) return;\n\n    try {\n      testProxy.setDuration(Long.valueOf(endTime) - Long.valueOf(startTime));\n    }\n    catch (NumberFormatException ignored) {\n    }\n\n    final CompositeRunnable runInEdt = new CompositeRunnable();\n    final TestEventResult result = getTestEventResultType(eventXml);\n    switch (result) {\n      case SUCCESS:\n        runInEdt.add(testProxy::setFinished);\n        break;\n      case FAILURE:\n        final String failureType = eventXml.queryXml(\"/ijLog/event/test/result/failureType\");\n        if (\"comparison\".equals(failureType)) {\n          String actualText = decode(eventXml.queryXml(\"/ijLog/event/test/result/actual\"));\n          String expectedText = decode(eventXml.queryXml(\"/ijLog/event/test/result/expected\"));\n          final Condition<String> emptyString = StringUtil::isEmpty;\n          String filePath = ObjectUtils.nullizeByCondition(decode(eventXml.queryXml(\"/ijLog/event/test/result/filePath\")), emptyString);\n          String actualFilePath = ObjectUtils.nullizeByCondition(\n            decode(eventXml.queryXml(\"/ijLog/event/test/result/actualFilePath\")), emptyString);\n          testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, actualText, expectedText, filePath, actualFilePath);\n        }\n        else {\n          Couple<String> comparisonPair =\n            parseComparisonMessage(exceptionMsg, \"\\nExpected: is \\\"(.*)\\\"\\n\\\\s*got: \\\"(.*)\\\"\\n\");\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\nExpected: is \\\"(.*)\\\"\\n\\\\s*but: was \\\"(.*)\\\"\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\nExpected: (.*)\\n\\\\s*got: (.*)\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\\\s*expected same:<(.*)> was not:<(.*)>\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \".*\\\\s*expected:<(.*)> but was:<(.*)>\");\n          }\n          if (comparisonPair == null) {\n            comparisonPair = parseComparisonMessage(exceptionMsg, \"\\nExpected: \\\"(.*)\\\"\\n\\\\s*but: was \\\"(.*)\\\"\");\n          }\n\n          final Couple<String> finalComparisonPair = comparisonPair;\n          runInEdt.add(() -> {\n            if (finalComparisonPair != null) {\n              testProxy.setTestComparisonFailed(exceptionMsg, stackTrace, finalComparisonPair.second, finalComparisonPair.first);\n            }\n            else {\n              testProxy.setTestFailed(exceptionMsg, stackTrace, \"error\".equals(failureType));\n            }\n          });\n        }\n        runInEdt.add(() -> getResultsViewer().onTestFailed(testProxy));\n        break;\n      case SKIPPED:\n        runInEdt.add(() -> {\n          testProxy.setTestIgnored(null, null);\n          getResultsViewer().onTestIgnored(testProxy);\n        });\n        break;\n      case UNKNOWN_RESULT:\n        break;\n    }\n\n    runInEdt.add(() -> getResultsViewer().onTestFinished(testProxy));\n\n    addToInvokeLater(runInEdt);\n  }","commit_id":"1a62bdc946b111ac204f4ebd68f38954ef956c3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void process(XmlXpathHelper eventXml) throws XmlXpathHelper.XmlParserException {\n    final String testId = getTestId(eventXml);\n    final String destination = eventXml.queryXml(\"/ijLog/event/test/event/@destination\");\n    final String output = eventXml.queryXml(\"/ijLog/event/test/event\");\n\n    SMTestProxy testProxy = findTestProxy(testId);\n    if (testProxy == null) return;\n\n    testProxy.addStdOutput(output, \"StdOut\".equals(destination) ? ProcessOutputTypes.STDOUT : ProcessOutputTypes.STDERR);\n  }","id":34446,"modified_method":"@Override\n  public void process(XmlXpathHelper eventXml) throws XmlXpathHelper.XmlParserException {\n    final String testId = getTestId(eventXml);\n    final String destination = eventXml.queryXml(\"/ijLog/event/test/event/@destination\");\n    final String output = decode(eventXml.queryXml(\"/ijLog/event/test/event\"));\n\n    SMTestProxy testProxy = findTestProxy(testId);\n    if (testProxy == null) return;\n\n    testProxy.addStdOutput(output, \"StdOut\".equals(destination) ? ProcessOutputTypes.STDOUT : ProcessOutputTypes.STDERR);\n  }","commit_id":"1a62bdc946b111ac204f4ebd68f38954ef956c3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int wordsintitle() {\r\n        return (int) this.entry.getColLong(col_wordsInTitle);\r\n    }","id":34447,"modified_method":"public int wordsintitle() {\r\n        return (0xff & this.entry.getColByte(col_wordsInTitle));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int hitcount() {\r\n        return (int) this.entry.getColLong(col_hitcount);\r\n    }","id":34448,"modified_method":"public int hitcount() {\r\n        return (0xff & this.entry.getColByte(col_hitcount));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int posinphrase() {\r\n        return (int) this.entry.getColLong(col_posinphrase);\r\n    }","id":34449,"modified_method":"public int posinphrase() {\r\n        return (0xff & this.entry.getColByte(col_posinphrase));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int urllength() {\r\n        return (int) this.entry.getColLong(col_urlLength);\r\n    }","id":34450,"modified_method":"public int urllength() {\r\n        return (0xff & this.entry.getColByte(col_urlLength));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int posofphrase() {\r\n        return (int) this.entry.getColLong(col_posofphrase);\r\n    }","id":34451,"modified_method":"public int posofphrase() {\r\n        return (0xff & this.entry.getColByte(col_posofphrase));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int llocal() {\r\n        return (int) this.entry.getColLong(col_llocal);\r\n    }","id":34452,"modified_method":"public int llocal() {\r\n        return (0xff & this.entry.getColByte(col_llocal));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int lother() {\r\n        return (int) this.entry.getColLong(col_lother);\r\n    }","id":34453,"modified_method":"public int lother() {\r\n        return (0xff & this.entry.getColByte(col_lother));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int urlcomps() {\r\n        return (int) this.entry.getColLong(col_urlComps);\r\n    }","id":34454,"modified_method":"public int urlcomps() {\r\n        return (0xff & this.entry.getColByte(col_urlComps));\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n\r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        if (!authenticated) {\r\n            final UserDB.Entry user = sb.userDB.getUser(header);\r\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\r\n        }\r\n        final boolean localhostAccess = sb.accessFromLocalhost(header);\r\n        final String promoteSearchPageGreeting =\r\n                (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ?\r\n                    env.getConfig(\"network.unit.description\", \"\") :\r\n                    env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n\r\n        // get query\r\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\r\n        String querystring =  originalquerystring.replace('+', ' ').replace('*', ' ').trim();\r\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", \"cacheonly\"));\r\n        final servletProperties prop = new servletProperties();\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        if (post != null && post.containsKey(\"segment\")) {\r\n            final String segmentName = post.get(\"segment\");\r\n            if (sb.indexSegments.segmentExist(segmentName)) {\r\n                indexSegment = sb.indexSegments.segment(segmentName);\r\n            }\r\n        } else {\r\n            // take default segment\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n\r\n        final String EXT = header.get(\"EXT\", \"\");\r\n        final boolean rss = EXT.equals(\"rss\");\r\n        final boolean json = EXT.equals(\"json\");\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        if (post == null || indexSegment == null || env == null || !searchAllowed) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"count\", \"10\");\r\n            prop.put(\"offset\", \"0\");\r\n            prop.put(\"resource\", \"global\");\r\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\r\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\r\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\r\n            prop.put(\"indexof\", \"off\");\r\n            prop.put(\"constraint\", \"\");\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n            prop.put(\"search.verify\", (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\r\n            prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n            prop.put(\"contentdom\", \"text\");\r\n            prop.put(\"contentdomCheckText\", \"1\");\r\n            prop.put(\"contentdomCheckAudio\", \"0\");\r\n            prop.put(\"contentdomCheckVideo\", \"0\");\r\n            prop.put(\"contentdomCheckImage\", \"0\");\r\n            prop.put(\"contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            prop.put(\"num-results_totalcount\", 0);\r\n            prop.put(\"num-results_offset\", 0);\r\n            prop.put(\"num-results_itemsPerPage\", 10);\r\n            prop.put(\"geoinfo\", \"0\");\r\n            prop.put(\"rss_queryenc\", \"\");\r\n            prop.put(\"meanCount\", 5);\r\n            return prop;\r\n        }\r\n\r\n        // check for JSONP\r\n        if (post.containsKey(\"callback\")) {\r\n        \tfinal String jsonp = post.get(\"callback\")+ \"([\";\r\n        \tprop.put(\"jsonp-start\", jsonp);\r\n        \tprop.put(\"jsonp-end\", \"])\");\r\n        } else {\r\n        \tprop.put(\"jsonp-start\", \"\");\r\n        \tprop.put(\"jsonp-end\", \"\");\r\n        }\r\n\r\n        // Adding CORS Access header for yacysearch.rss output\r\n        if (rss) {\r\n            final ResponseHeader outgoingHeader = new ResponseHeader();\r\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\r\n            prop.setOutgoingHeader(outgoingHeader);\r\n        }\r\n\r\n        // collect search attributes\r\n        final boolean newsearch =post.hasValue(\"query\") && post.hasValue(\"former\") && !post.get(\"query\",\"\").equalsIgnoreCase(post.get(\"former\",\"\")); //new search term\r\n\r\n        int itemsPerPage = Math.min((authenticated) ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 100 : 5000) : (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000), post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = (newsearch) ? 0 : post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n\r\n        boolean global = post.get(\"resource\", \"local\").equals(\"global\") && sb.peers.sizeConnected() > 0;\r\n        final boolean indexof = (post != null && post.get(\"indexof\",\"\").equals(\"on\"));\r\n\r\n        final String originalUrlMask;\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) { // option search all\r\n            originalUrlMask = \".*\";\r\n        } else if (!newsearch && post.containsKey(\"urlmaskfilter\")) {\r\n            originalUrlMask = post.get(\"urlmaskfilter\", \".*\");\r\n        } else {\r\n            originalUrlMask = \".*\";\r\n        }\r\n\r\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        if (!prefermask.isEmpty() && prefermask.indexOf(\".*\") < 0) {\r\n            prefermask = \".*\" + prefermask + \".*\";\r\n        }\r\n\r\n        Bitfield constraint = (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty()) ? new Bitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new Bitfield(4);\r\n            constraint.set(Condenser.flag_cat_indexof, true);\r\n        }\r\n\r\n        // SEARCH\r\n        final boolean clustersearch = sb.isRobinsonMode() && (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") || sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) || sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true) || clustersearch;\r\n        global = global && indexReceiveGranted; // if the user does not want indexes from remote peers, it cannot be a global searchnn\r\n\r\n        // increase search statistic counter\r\n        if (!global) {\r\n            // we count only searches on the local peer here, because global searches\r\n            // are counted on the target peer to preserve privacy of the searcher\r\n            if (authenticated) {\r\n                // local or authenticated search requests are counted separately\r\n                // because they are not part of a public available peer statistic\r\n                sb.searchQueriesRobinsonFromLocal++;\r\n            } else {\r\n                // robinson-searches from non-authenticated requests are public\r\n                // and may be part of the public available statistic\r\n                sb.searchQueriesRobinsonFromRemote++;\r\n            }\r\n        }\r\n\r\n        // find search domain\r\n        final ContentDomain contentdom = ContentDomain.contentdomParser(post == null ? \"text\" : post.get(\"contentdom\", \"text\"));\r\n\r\n        // patch until better search profiles are available\r\n        if ((contentdom != ContentDomain.TEXT) && (itemsPerPage <= 32)) {\r\n            itemsPerPage = 64;\r\n        }\r\n\r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) {\r\n            trackerHandles = new TreeSet<Long>();\r\n        }\r\n        boolean block = false;\r\n        if (Domains.matchesList(client, sb.networkBlacklist)) {\r\n            global = false;\r\n            if (snippetFetchStrategy != null) {\r\n                snippetFetchStrategy = null;\r\n            }\r\n            block = true;\r\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \" + client + \" gets no permission to search\");\r\n        } else if (Domains.matchesList(client, sb.networkWhitelist)) {\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \" + client + \" gets no search restrictions\");\r\n        } else if (!authenticated && !localhostAccess) {\r\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\r\n            synchronized (trackerHandles) {\r\n                final int accInThreeSeconds = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\r\n                final int accInOneMinute = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\r\n                final int accInTenMinutes = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\r\n                // protections against too strong YaCy network load, reduces remote search\r\n                if (global) {\r\n                    if (accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1) {\r\n                        global = false;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed global search\");\r\n                    }\r\n                }\r\n                // protection against too many remote server snippet loads (protects traffic on server)\r\n                if (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()) {\r\n                    if (accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1) {\r\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed remote snippet loading\");\r\n                    }\r\n                }\r\n                // general load protection\r\n                if (accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60) {\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed search\");\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((!block) && (post == null || post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            String urlmask = null;\r\n\r\n            // check available memory and clean up if necessary\r\n            if (!MemoryControl.request(8000000L, false)) {\r\n                indexSegment.urlMetadata().clearCache();\r\n                SearchEventCache.cleanupEvents(true);\r\n            }\r\n\r\n            final RankingProfile ranking = sb.getRanking();\r\n\r\n            if (querystring.indexOf(\"/near\") >= 0) {\r\n            \tquerystring = querystring.replace(\"/near\", \"\");\r\n            \tranking.coeff_worddistance = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/date\") >= 0) {\r\n                querystring = querystring.replace(\"/date\", \"\");\r\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/http\") >= 0) {\r\n                querystring = querystring.replace(\"/http\", \"\");\r\n                urlmask = \"http://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/https\") >= 0) {\r\n                querystring = querystring.replace(\"/https\", \"\");\r\n                urlmask = \"https://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/ftp\") >= 0) {\r\n                querystring = querystring.replace(\"/ftp\", \"\");\r\n                urlmask = \"ftp://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/smb\") >= 0) {\r\n                querystring = querystring.replace(\"/smb\", \"\");\r\n                urlmask = \"smb://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/file\") >= 0) {\r\n                querystring = querystring.replace(\"/file\", \"\");\r\n                urlmask = \"file://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/location\") >= 0) {\r\n                querystring = querystring.replace(\"/location\", \"\");\r\n                if (constraint == null) {\r\n                    constraint = new Bitfield(4);\r\n                }\r\n                constraint.set(Condenser.flag_cat_haslocation, true);\r\n            }\r\n            final int lrp = querystring.indexOf(\"/language/\");\r\n            String lr = \"\";\r\n            if (lrp >= 0) {\r\n                if (querystring.length() >= (lrp + 11)) {\r\n                    lr = querystring.substring(lrp + 9, lrp + 11);\r\n                }\r\n\r\n                querystring = querystring.replace(\"/language/\" + lr, \"\");\r\n                lr = lr.toLowerCase();\r\n            }\r\n            final int inurl = querystring.indexOf(\"inurl:\");\r\n            if (inurl >= 0) {\r\n                int ftb = querystring.indexOf(' ', inurl);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                final String urlstr = querystring.substring(inurl + 6, ftb);\r\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\r\n                if (!urlstr.isEmpty()) {\r\n                    urlmask = \".*\" + urlstr + \".*\";\r\n                }\r\n            }\r\n            final int filetype = querystring.indexOf(\"filetype:\");\r\n            if (filetype >= 0) {\r\n                int ftb = querystring.indexOf(' ', filetype);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String ft = querystring.substring(filetype + 9, ftb);\r\n                querystring = querystring.replace(\"filetype:\" + ft, \"\");\r\n                while (!ft.isEmpty() && ft.charAt(0) == '.') ft = ft.substring(1);\r\n                if (!ft.isEmpty()) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\\\\.\" + ft;\r\n                    } else {\r\n                        urlmask = urlmask + \".*\\\\.\" + ft;\r\n                    }\r\n                }\r\n            }\r\n            String tenant = null;\r\n            if (post.containsKey(\"tenant\")) {\r\n                tenant = post.get(\"tenant\");\r\n                if (tenant != null && tenant.isEmpty()) {\r\n                    tenant = null;\r\n                }\r\n                if (tenant != null) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\" + tenant + \".*\";\r\n                    } else urlmask = \".*\" + tenant + urlmask;\r\n                }\r\n            }\r\n            final int site = querystring.indexOf(\"site:\");\r\n            String sitehash = null;\r\n            String sitehost = null;\r\n            if (site >= 0) {\r\n                int ftb = querystring.indexOf(' ', site);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                sitehost = querystring.substring(site + 5, ftb);\r\n                querystring = querystring.replace(\"site:\" + sitehost, \"\");\r\n                while (sitehost.length() > 0 && sitehost.charAt(0) == '.') {\r\n                    sitehost = sitehost.substring(1);\r\n                }\r\n                while (sitehost.endsWith(\".\")) {\r\n                    sitehost = sitehost.substring(0, sitehost.length() - 1);\r\n                }\r\n                sitehash = DigestURI.hosthash(sitehost);\r\n            }\r\n\r\n            final int heuristicScroogle = querystring.indexOf(\"heuristic:scroogle\");\r\n            if (heuristicScroogle >= 0) {\r\n                querystring = querystring.replace(\"heuristic:scroogle\", \"\");\r\n            }\r\n\r\n            final int heuristicBlekko = querystring.indexOf(\"heuristic:blekko\");\r\n            if (heuristicBlekko >= 0) {\r\n                querystring = querystring.replace(\"heuristic:blekko\", \"\");\r\n            }\r\n\r\n            final int authori = querystring.indexOf(\"author:\");\r\n        \tString authorhash = null;\r\n            if (authori >= 0) {\r\n            \t// check if the author was given with single quotes or without\r\n            \tfinal boolean quotes = (querystring.charAt(authori + 7) == (char) 39);\r\n            \tString author;\r\n            \tif (quotes) {\r\n                    int ftb = querystring.indexOf((char) 39, authori + 8);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length() + 1;\r\n                    }\r\n                    author = querystring.substring(authori + 8, ftb);\r\n                    querystring = querystring.replace(\"author:'\" + author + \"'\", \"\");\r\n            \t} else {\r\n                    int ftb = querystring.indexOf(' ', authori);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length();\r\n                    }\r\n                    author = querystring.substring(authori + 7, ftb);\r\n                    querystring = querystring.replace(\"author:\" + author, \"\");\r\n            \t}\r\n            \tauthorhash = ASCII.String(Word.word2hash(author));\r\n            }\r\n            final int tld = querystring.indexOf(\"tld:\");\r\n            if (tld >= 0) {\r\n                int ftb = querystring.indexOf(' ', tld);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String domain = querystring.substring(tld + 4, ftb);\r\n                querystring = querystring.replace(\"tld:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') {\r\n                    domain = domain.substring(1);\r\n                }\r\n                if (domain.indexOf('.') < 0) {\r\n                    domain = \"\\\\.\" + domain;\r\n                } // is tld\r\n                if (domain.length() > 0) {\r\n                    urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\" + ((urlmask != null) ? urlmask : \"\");\r\n                }\r\n            }\r\n            if (urlmask == null || urlmask.isEmpty()) {\r\n                urlmask = originalUrlMask;\r\n            } //if no urlmask was given\r\n\r\n            // read the language from the language-restrict option 'lr'\r\n            // if no one is given, use the user agent or the system language as default\r\n            String language = (post == null) ? lr : post.get(\"lr\", lr);\r\n            if (language.startsWith(\"lang_\")) {\r\n                language = language.substring(5);\r\n            }\r\n            if (!ISO639.exists(language)) {\r\n                // find out language of the user by reading of the user-agent string\r\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\r\n                if (agent == null) {\r\n                    agent = System.getProperty(\"user.language\");\r\n                }\r\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\r\n                if (language == null) {\r\n                    language = \"en\";\r\n                }\r\n            }\r\n\r\n            // navigation\r\n            final String navigation = (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"\");\r\n\r\n            // the query\r\n            final TreeSet<String>[] query = QueryParams.cleanQuery(querystring.trim()); // converts also umlaute\r\n\r\n            final int maxDistance = (querystring.indexOf('\"') >= 0) ? query.length - 1 : Integer.MAX_VALUE;\r\n\r\n            // filter out stopwords\r\n            final SortedSet<String> filtered = SetTools.joinConstructive(query[0], Switchboard.stopwords);\r\n            if (!filtered.isEmpty()) {\r\n                SetTools.excludeDestructive(query[0], Switchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post != null && post.containsKey(\"deleteref\")) {\r\n                try {\r\n                    if (!sb.verifyAuthentication(header, false)) {\r\n                        prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                        return prop;\r\n                    }\r\n\r\n                    // delete the index entry locally\r\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                    indexSegment.termIndex().remove(Word.words2hashesHandles(query[0]), delHash.getBytes());\r\n\r\n                    // make new news message with negative voting\r\n                    if (!sb.isRobinsonMode()) {\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"urlhash\", delHash);\r\n                        map.put(\"vote\", \"negative\");\r\n                        map.put(\"refid\", \"\");\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), NewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map);\r\n                    }\r\n\r\n                    // delete the search history since this still shows the entry\r\n                    SearchEventCache.delete(delHash);\r\n                } catch (final IOException e) {\r\n                    Log.logException(e);\r\n                }\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post != null && post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, false)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(UTF8.getBytes(recommendHash));\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    Document[] documents = null;\r\n                    try {\r\n                        documents = sb.loader.loadDocuments(sb.loader.request(metadata.url(), true, false), CacheStrategy.IFEXIST, 5000, Integer.MAX_VALUE);\r\n                    } catch (final IOException e) {\r\n                    } catch (final Parser.Failure e) {\r\n                    }\r\n                    if (documents != null) {\r\n                        // create a news message\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", metadata.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", metadata.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\r\n                        map.put(\"author\", documents[0].dc_creator());\r\n                        map.put(\"tags\", documents[0].dc_subject(' '));\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), NewsPool.CATEGORY_SURFTIPP_ADD, map);\r\n                        documents[0].close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if a bookmarks-button was hit, create new bookmark entry\r\n            if (post != null && post.containsKey(\"bookmarkref\")) {\r\n                if (!sb.verifyAuthentication(header, false)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(UTF8.getBytes(bookmarkHash));\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    try {\r\n                        sb.tables.bookmarks.createBookmark(sb.loader, metadata.url(), YMarkTables.USER_ADMIN, true, \"searchresult\", \"/search\");\r\n                    } catch (final Throwable e) {\r\n                    }\r\n                }\r\n            }\r\n\r\n            // do the search\r\n            final HandleSet queryHashes = Word.words2hashesHandles(query[0]);\r\n            final Pattern snippetPattern = QueryParams.stringSearchPattern(originalquerystring);\r\n\r\n            // check filters\r\n            try {\r\n                Pattern.compile(urlmask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal URL mask, not a valid regex: \" + urlmask);\r\n                prop.put(\"urlmaskerror\", 1);\r\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\r\n                urlmask = \".*\";\r\n            }\r\n\r\n            try {\r\n                Pattern.compile(prefermask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal prefer mask, not a valid regex: \" + prefermask);\r\n                prop.put(\"prefermaskerror\", 1);\r\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\r\n                prefermask = \"\";\r\n            }\r\n\r\n            final QueryParams theQuery = new QueryParams(\r\n                    originalquerystring,\r\n                    queryHashes,\r\n                    Word.words2hashesHandles(query[1]),\r\n                    Word.words2hashesHandles(query[2]),\r\n                    snippetPattern,\r\n                    tenant,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdom,\r\n                    language,\r\n                    navigation,\r\n                    snippetFetchStrategy,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER :\r\n                    (global && indexReceiveGranted ? QueryParams.Searchdom.GLOBAL : QueryParams.Searchdom.LOCAL),\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    sitehash,\r\n                    authorhash,\r\n                    DigestURI.TLD_any_zone_filter,\r\n                    client,\r\n                    authenticated,\r\n                    indexSegment,\r\n                    ranking,\r\n                    header.get(RequestHeader.USER_AGENT, \"\"),\r\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false) && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false) && sb.peers.mySeed().getFlagAcceptRemoteIndex());\r\n            EventTracker.delete(EventTracker.EClass.SEARCH);\r\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theQuery.id(true), SearchEvent.Type.INITIALIZATION, \"\", 0, 0), false);\r\n\r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(3000);\r\n\r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(Switchboard.blueList);\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + QueryParams.hashSet2hashString(theQuery.queryHashes) + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            final long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (SearchEventCache.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\r\n                offset = 0;\r\n            }\r\n            final SearchEvent theSearch = SearchEventCache.getEvent(\r\n                theQuery, sb.peers, sb.tables, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false, sb.loader,\r\n                (int) sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\r\n                      sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_ROBINSON, 0),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_MULTIWORD, 0));\r\n\r\n            if (offset == 0) {\r\n                if (sitehost != null && sb.getConfigBool(\"heuristic.site\", false) && authenticated) {\r\n                    sb.heuristicSite(theSearch, sitehost);\r\n                }\r\n                if ((heuristicScroogle >= 0  || sb.getConfigBool(\"heuristic.scroogle\", false)) && authenticated) {\r\n                    sb.heuristicScroogle(theSearch);\r\n                }\r\n                if ((heuristicBlekko >= 0  || sb.getConfigBool(\"heuristic.blekko\", false)) && authenticated) {\r\n                    sb.heuristicRSS(\"http://blekko.com/ws/$+/rss\", theSearch, \"blekko\");\r\n                }\r\n            }\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    \"local-unfiltered(\" + theSearch.getRankingResult().getLocalIndexCount() + \"), \" +\r\n                    \"local_miss(\" + theSearch.getRankingResult().getMissCount() + \"), \" +\r\n                    \"local_sortout(\" + theSearch.getRankingResult().getSortOutCount() + \"), \" +\r\n                    \"remote(\" + theSearch.getRankingResult().getRemoteResourceSize() + \") links found, \" +\r\n                    (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.result().getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.result().getSnippetComputationTime();\r\n            AccessTracker.add(AccessTracker.Location.local, theQuery);\r\n\r\n            // check suggestions\r\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\r\n\r\n            prop.put(\"meanCount\", meanMax);\r\n            if (meanMax > 0 && !json && !rss) {\r\n                final DidYouMean didYouMean = new DidYouMean(indexSegment.termIndex(), new StringBuilder(querystring));\r\n            \tfinal Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\r\n                int meanCount = 0;\r\n                String suggestion;\r\n                while( meanCount<meanMax && meanIt.hasNext()) {\r\n                    suggestion = meanIt.next().toString();\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_word\", suggestion);\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_url\",\r\n                            QueryParams.navurl(\"html\", 0, theQuery, suggestion, originalUrlMask.toString(), theQuery.navigators).toString()\r\n    \t             );\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_sep\",\"|\");\r\n                    meanCount++;\r\n                }\r\n                prop.put(\"didYouMean_suggestions_\"+(meanCount-1)+\"_sep\",\"\");\r\n                prop.put(\"didYouMean\", meanCount>0 ? 1:0);\r\n                prop.put(\"didYouMean_suggestions\", meanCount);\r\n            } else {\r\n                prop.put(\"didYouMean\", 0);\r\n            }\r\n\r\n            // find geographic info\r\n            final SortedSet<Location> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\r\n            if (coordinates == null || coordinates.isEmpty() || offset > 0) {\r\n                prop.put(\"geoinfo\", \"0\");\r\n            } else {\r\n                int i = 0;\r\n                for (final Location c: coordinates) {\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\r\n                    i++;\r\n                    if (i >= 10) break;\r\n                }\r\n                prop.put(\"geoinfo_loc\", i);\r\n                prop.put(\"geoinfo\", \"1\");\r\n            }\r\n\r\n            // update the search tracker\r\n            try {\r\n                synchronized (trackerHandles) {\r\n                    trackerHandles.add(theQuery.time);\r\n                    while (trackerHandles.size() > 600) {\r\n                        if (!trackerHandles.remove(trackerHandles.first())) break;\r\n                    }\r\n                }\r\n                sb.localSearchTracker.put(client, trackerHandles);\r\n            \tif (sb.localSearchTracker.size() > 100) {\r\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\r\n                }\r\n            \tif (MemoryControl.shortStatus()) sb.localSearchTracker.clear();\r\n            } catch (final Exception e) {\r\n                Log.logException(e);\r\n            }\r\n\r\n            final int indexcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", Formatter.number(0, true));\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", Formatter.number(indexcount, true));\r\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_localMissCount\", Formatter.number(theSearch.getRankingResult().getMissCount(), true));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.getRankingResult().getRemoteIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.getRankingResult().getRemotePeerCount(), true));\r\n\r\n            // compose page navigation\r\n            final StringBuilder resnav = new StringBuilder(200);\r\n            final int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n            } else {\r\n            \tresnav.append(\"<a id=\\\"prevpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, theQuery, null, originalUrlMask, navigation).toString());\r\n            \tresnav.append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n            }\r\n            final int numberofpages = Math.min(10, 1 + ((indexcount - 1) / theQuery.displayResults()));\r\n\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n                } else {\r\n                    resnav.append(\"<a href=\\\"\");\r\n                    resnav.append(QueryParams.navurl(\"html\", i, theQuery, null, originalUrlMask, navigation).toString());\r\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" />\");\r\n            } else {\r\n                resnav.append(\"<a id=\\\"nextpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, theQuery, null, originalUrlMask, navigation).toString());\r\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>\");\r\n            }\r\n            final String resnavs = resnav.toString();\r\n            prop.put(\"num-results_resnav\", resnavs);\r\n            prop.put(\"pageNavBottom\", (indexcount - offset > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\r\n            prop.put(\"pageNavBottom_resnav\", resnavs);\r\n\r\n            // generate the search result lines; the content will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n\r\n            // process result of search\r\n            if (!filtered.isEmpty()) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.isEmpty()) {\r\n                if (post.get(\"query\", post.get(\"search\", \"\")).length() < 2) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(':') == -1) {\r\n                hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8090\"));\r\n            }\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n\r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.putHTML(\"former\", originalquerystring);\r\n        prop.put(\"count\", itemsPerPage);\r\n        prop.put(\"offset\", offset);\r\n        prop.put(\"resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"urlmaskfilter\", originalUrlMask);\r\n        prop.putHTML(\"prefermaskfilter\", prefermask);\r\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\r\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        prop.put(\"searchdomswitches\", sb.getConfigBool(\"search.text\", true) || sb.getConfigBool(\"search.audio\", true) || sb.getConfigBool(\"search.video\", true) || sb.getConfigBool(\"search.image\", true) || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n\r\n        // copy properties for \"more options\" link\r\n        prop.put(\"searchdomswitches_count\", prop.get(\"count\"));\r\n        prop.put(\"searchdomswitches_urlmaskfilter\", prop.get(\"urlmaskfilter\"));\r\n        prop.put(\"searchdomswitches_prefermaskfilter\", prop.get(\"prefermaskfilter\"));\r\n        prop.put(\"searchdomswitches_cat\", prop.get(\"cat\"));\r\n        prop.put(\"searchdomswitches_constraint\", prop.get(\"constraint\"));\r\n        prop.put(\"searchdomswitches_contentdom\", prop.get(\"contentdom\"));\r\n        prop.put(\"searchdomswitches_former\", prop.get(\"former\"));\r\n        prop.put(\"searchdomswitches_meanCount\", prop.get(\"meanCount\"));\r\n\r\n        // for RSS: don't HTML encode some elements\r\n        prop.putXML(\"rss_query\", originalquerystring);\r\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":34455,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n\r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        if (!authenticated) {\r\n            final UserDB.Entry user = sb.userDB.getUser(header);\r\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\r\n        }\r\n        final boolean localhostAccess = sb.accessFromLocalhost(header);\r\n        final String promoteSearchPageGreeting =\r\n                (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ?\r\n                    env.getConfig(\"network.unit.description\", \"\") :\r\n                    env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n\r\n        // get query\r\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\r\n        String querystring =  originalquerystring.replace('+', ' ').replace('*', ' ').trim();\r\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", \"cacheonly\"));\r\n        final servletProperties prop = new servletProperties();\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        if (post != null && post.containsKey(\"segment\")) {\r\n            final String segmentName = post.get(\"segment\");\r\n            if (sb.indexSegments.segmentExist(segmentName)) {\r\n                indexSegment = sb.indexSegments.segment(segmentName);\r\n            }\r\n        } else {\r\n            // take default segment\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n\r\n        final String EXT = header.get(\"EXT\", \"\");\r\n        final boolean rss = EXT.equals(\"rss\");\r\n        final boolean json = EXT.equals(\"json\");\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        if (post == null || indexSegment == null || env == null || !searchAllowed) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"count\", \"10\");\r\n            prop.put(\"offset\", \"0\");\r\n            prop.put(\"resource\", \"global\");\r\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\r\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\r\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\r\n            prop.put(\"indexof\", \"off\");\r\n            prop.put(\"constraint\", \"\");\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n            prop.put(\"search.verify\", (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\r\n            prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n            prop.put(\"contentdom\", \"text\");\r\n            prop.put(\"contentdomCheckText\", \"1\");\r\n            prop.put(\"contentdomCheckAudio\", \"0\");\r\n            prop.put(\"contentdomCheckVideo\", \"0\");\r\n            prop.put(\"contentdomCheckImage\", \"0\");\r\n            prop.put(\"contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            prop.put(\"num-results_totalcount\", 0);\r\n            prop.put(\"num-results_offset\", 0);\r\n            prop.put(\"num-results_itemsPerPage\", 10);\r\n            prop.put(\"geoinfo\", \"0\");\r\n            prop.put(\"rss_queryenc\", \"\");\r\n            prop.put(\"meanCount\", 5);\r\n            return prop;\r\n        }\r\n\r\n        // check for JSONP\r\n        if (post.containsKey(\"callback\")) {\r\n        \tfinal String jsonp = post.get(\"callback\")+ \"([\";\r\n        \tprop.put(\"jsonp-start\", jsonp);\r\n        \tprop.put(\"jsonp-end\", \"])\");\r\n        } else {\r\n        \tprop.put(\"jsonp-start\", \"\");\r\n        \tprop.put(\"jsonp-end\", \"\");\r\n        }\r\n\r\n        // Adding CORS Access header for yacysearch.rss output\r\n        if (rss) {\r\n            final ResponseHeader outgoingHeader = new ResponseHeader();\r\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\r\n            prop.setOutgoingHeader(outgoingHeader);\r\n        }\r\n\r\n        // collect search attributes\r\n        final boolean newsearch =post.hasValue(\"query\") && post.hasValue(\"former\") && !post.get(\"query\",\"\").equalsIgnoreCase(post.get(\"former\",\"\")); //new search term\r\n\r\n        int itemsPerPage = Math.min((authenticated) ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 100 : 5000) : (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000), post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = (newsearch) ? 0 : post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n\r\n        boolean global = post.get(\"resource\", \"local\").equals(\"global\") && sb.peers.sizeConnected() > 0;\r\n        final boolean indexof = (post != null && post.get(\"indexof\",\"\").equals(\"on\"));\r\n\r\n        final String originalUrlMask;\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) { // option search all\r\n            originalUrlMask = \".*\";\r\n        } else if (!newsearch && post.containsKey(\"urlmaskfilter\")) {\r\n            originalUrlMask = post.get(\"urlmaskfilter\", \".*\");\r\n        } else {\r\n            originalUrlMask = \".*\";\r\n        }\r\n\r\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        if (!prefermask.isEmpty() && prefermask.indexOf(\".*\") < 0) {\r\n            prefermask = \".*\" + prefermask + \".*\";\r\n        }\r\n\r\n        Bitfield constraint = (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty()) ? new Bitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new Bitfield(4);\r\n            constraint.set(Condenser.flag_cat_indexof, true);\r\n        }\r\n\r\n        // SEARCH\r\n        final boolean clustersearch = sb.isRobinsonMode() && (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") || sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) || sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true) || clustersearch;\r\n        global = global && indexReceiveGranted; // if the user does not want indexes from remote peers, it cannot be a global searchnn\r\n\r\n        // increase search statistic counter\r\n        if (!global) {\r\n            // we count only searches on the local peer here, because global searches\r\n            // are counted on the target peer to preserve privacy of the searcher\r\n            if (authenticated) {\r\n                // local or authenticated search requests are counted separately\r\n                // because they are not part of a public available peer statistic\r\n                sb.searchQueriesRobinsonFromLocal++;\r\n            } else {\r\n                // robinson-searches from non-authenticated requests are public\r\n                // and may be part of the public available statistic\r\n                sb.searchQueriesRobinsonFromRemote++;\r\n            }\r\n        }\r\n\r\n        // find search domain\r\n        final ContentDomain contentdom = ContentDomain.contentdomParser(post == null ? \"text\" : post.get(\"contentdom\", \"text\"));\r\n\r\n        // patch until better search profiles are available\r\n        if ((contentdom != ContentDomain.TEXT) && (itemsPerPage <= 32)) {\r\n            itemsPerPage = 64;\r\n        }\r\n\r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) {\r\n            trackerHandles = new TreeSet<Long>();\r\n        }\r\n        boolean block = false;\r\n        if (Domains.matchesList(client, sb.networkBlacklist)) {\r\n            global = false;\r\n            if (snippetFetchStrategy != null) {\r\n                snippetFetchStrategy = null;\r\n            }\r\n            block = true;\r\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \" + client + \" gets no permission to search\");\r\n        } else if (Domains.matchesList(client, sb.networkWhitelist)) {\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \" + client + \" gets no search restrictions\");\r\n        } else if (!authenticated && !localhostAccess) {\r\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\r\n            synchronized (trackerHandles) {\r\n                final int accInThreeSeconds = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\r\n                final int accInOneMinute = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\r\n                final int accInTenMinutes = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\r\n                // protections against too strong YaCy network load, reduces remote search\r\n                if (global) {\r\n                    if (accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1) {\r\n                        global = false;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed global search\");\r\n                    }\r\n                }\r\n                // protection against too many remote server snippet loads (protects traffic on server)\r\n                if (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()) {\r\n                    if (accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1) {\r\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed remote snippet loading\");\r\n                    }\r\n                }\r\n                // general load protection\r\n                if (accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60) {\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed search\");\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((!block) && (post == null || post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            String urlmask = null;\r\n\r\n            // check available memory and clean up if necessary\r\n            if (!MemoryControl.request(8000000L, false)) {\r\n                indexSegment.urlMetadata().clearCache();\r\n                SearchEventCache.cleanupEvents(true);\r\n            }\r\n\r\n            final RankingProfile ranking = sb.getRanking();\r\n\r\n            if (querystring.indexOf(\"/near\") >= 0) {\r\n            \tquerystring = querystring.replace(\"/near\", \"\");\r\n            \tranking.coeff_worddistance = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/date\") >= 0) {\r\n                querystring = querystring.replace(\"/date\", \"\");\r\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/http\") >= 0) {\r\n                querystring = querystring.replace(\"/http\", \"\");\r\n                urlmask = \"https?://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/https\") >= 0) {\r\n                querystring = querystring.replace(\"/https\", \"\");\r\n                urlmask = \"https?://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/ftp\") >= 0) {\r\n                querystring = querystring.replace(\"/ftp\", \"\");\r\n                urlmask = \"ftp://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/smb\") >= 0) {\r\n                querystring = querystring.replace(\"/smb\", \"\");\r\n                urlmask = \"smb://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/file\") >= 0) {\r\n                querystring = querystring.replace(\"/file\", \"\");\r\n                urlmask = \"file://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/location\") >= 0) {\r\n                querystring = querystring.replace(\"/location\", \"\");\r\n                if (constraint == null) {\r\n                    constraint = new Bitfield(4);\r\n                }\r\n                constraint.set(Condenser.flag_cat_haslocation, true);\r\n            }\r\n            final int lrp = querystring.indexOf(\"/language/\");\r\n            String lr = \"\";\r\n            if (lrp >= 0) {\r\n                if (querystring.length() >= (lrp + 11)) {\r\n                    lr = querystring.substring(lrp + 9, lrp + 11);\r\n                }\r\n\r\n                querystring = querystring.replace(\"/language/\" + lr, \"\");\r\n                lr = lr.toLowerCase();\r\n            }\r\n            final int inurl = querystring.indexOf(\"inurl:\");\r\n            if (inurl >= 0) {\r\n                int ftb = querystring.indexOf(' ', inurl);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                final String urlstr = querystring.substring(inurl + 6, ftb);\r\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\r\n                if (!urlstr.isEmpty()) {\r\n                    urlmask = \".*\" + urlstr + \".*\";\r\n                }\r\n            }\r\n            final int filetype = querystring.indexOf(\"filetype:\");\r\n            if (filetype >= 0) {\r\n                int ftb = querystring.indexOf(' ', filetype);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String ft = querystring.substring(filetype + 9, ftb);\r\n                querystring = querystring.replace(\"filetype:\" + ft, \"\");\r\n                while (!ft.isEmpty() && ft.charAt(0) == '.') ft = ft.substring(1);\r\n                if (!ft.isEmpty()) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\\\\.\" + ft;\r\n                    } else {\r\n                        urlmask = urlmask + \".*\\\\.\" + ft;\r\n                    }\r\n                }\r\n            }\r\n            String tenant = null;\r\n            if (post.containsKey(\"tenant\")) {\r\n                tenant = post.get(\"tenant\");\r\n                if (tenant != null && tenant.isEmpty()) {\r\n                    tenant = null;\r\n                }\r\n                if (tenant != null) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\" + tenant + \".*\";\r\n                    } else urlmask = \".*\" + tenant + urlmask;\r\n                }\r\n            }\r\n            final int site = querystring.indexOf(\"site:\");\r\n            String sitehash = null;\r\n            String sitehost = null;\r\n            if (site >= 0) {\r\n                int ftb = querystring.indexOf(' ', site);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                sitehost = querystring.substring(site + 5, ftb);\r\n                querystring = querystring.replace(\"site:\" + sitehost, \"\");\r\n                while (sitehost.length() > 0 && sitehost.charAt(0) == '.') {\r\n                    sitehost = sitehost.substring(1);\r\n                }\r\n                while (sitehost.endsWith(\".\")) {\r\n                    sitehost = sitehost.substring(0, sitehost.length() - 1);\r\n                }\r\n                sitehash = DigestURI.hosthash(sitehost);\r\n            }\r\n\r\n            final int heuristicScroogle = querystring.indexOf(\"heuristic:scroogle\");\r\n            if (heuristicScroogle >= 0) {\r\n                querystring = querystring.replace(\"heuristic:scroogle\", \"\");\r\n            }\r\n\r\n            final int heuristicBlekko = querystring.indexOf(\"heuristic:blekko\");\r\n            if (heuristicBlekko >= 0) {\r\n                querystring = querystring.replace(\"heuristic:blekko\", \"\");\r\n            }\r\n\r\n            final int authori = querystring.indexOf(\"author:\");\r\n        \tString authorhash = null;\r\n            if (authori >= 0) {\r\n            \t// check if the author was given with single quotes or without\r\n            \tfinal boolean quotes = (querystring.charAt(authori + 7) == (char) 39);\r\n            \tString author;\r\n            \tif (quotes) {\r\n                    int ftb = querystring.indexOf((char) 39, authori + 8);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length() + 1;\r\n                    }\r\n                    author = querystring.substring(authori + 8, ftb);\r\n                    querystring = querystring.replace(\"author:'\" + author + \"'\", \"\");\r\n            \t} else {\r\n                    int ftb = querystring.indexOf(' ', authori);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length();\r\n                    }\r\n                    author = querystring.substring(authori + 7, ftb);\r\n                    querystring = querystring.replace(\"author:\" + author, \"\");\r\n            \t}\r\n            \tauthorhash = ASCII.String(Word.word2hash(author));\r\n            }\r\n            final int tld = querystring.indexOf(\"tld:\");\r\n            if (tld >= 0) {\r\n                int ftb = querystring.indexOf(' ', tld);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String domain = querystring.substring(tld + 4, ftb);\r\n                querystring = querystring.replace(\"tld:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') {\r\n                    domain = domain.substring(1);\r\n                }\r\n                if (domain.indexOf('.') < 0) {\r\n                    domain = \"\\\\.\" + domain;\r\n                } // is tld\r\n                if (domain.length() > 0) {\r\n                    urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\" + ((urlmask != null) ? urlmask : \"\");\r\n                }\r\n            }\r\n            if (urlmask == null || urlmask.isEmpty()) {\r\n                urlmask = originalUrlMask;\r\n            } //if no urlmask was given\r\n\r\n            // read the language from the language-restrict option 'lr'\r\n            // if no one is given, use the user agent or the system language as default\r\n            String language = (post == null) ? lr : post.get(\"lr\", lr);\r\n            if (language.startsWith(\"lang_\")) {\r\n                language = language.substring(5);\r\n            }\r\n            if (!ISO639.exists(language)) {\r\n                // find out language of the user by reading of the user-agent string\r\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\r\n                if (agent == null) {\r\n                    agent = System.getProperty(\"user.language\");\r\n                }\r\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\r\n                if (language == null) {\r\n                    language = \"en\";\r\n                }\r\n            }\r\n\r\n            // navigation\r\n            final String navigation = (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"\");\r\n\r\n            // the query\r\n            final TreeSet<String>[] query = QueryParams.cleanQuery(querystring.trim()); // converts also umlaute\r\n\r\n            final int maxDistance = (querystring.indexOf('\"') >= 0) ? query.length - 1 : Integer.MAX_VALUE;\r\n\r\n            // filter out stopwords\r\n            final SortedSet<String> filtered = SetTools.joinConstructive(query[0], Switchboard.stopwords);\r\n            if (!filtered.isEmpty()) {\r\n                SetTools.excludeDestructive(query[0], Switchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post != null && post.containsKey(\"deleteref\")) {\r\n                try {\r\n                    if (!sb.verifyAuthentication(header, false)) {\r\n                        prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                        return prop;\r\n                    }\r\n\r\n                    // delete the index entry locally\r\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                    indexSegment.termIndex().remove(Word.words2hashesHandles(query[0]), delHash.getBytes());\r\n\r\n                    // make new news message with negative voting\r\n                    if (!sb.isRobinsonMode()) {\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"urlhash\", delHash);\r\n                        map.put(\"vote\", \"negative\");\r\n                        map.put(\"refid\", \"\");\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), NewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map);\r\n                    }\r\n\r\n                    // delete the search history since this still shows the entry\r\n                    SearchEventCache.delete(delHash);\r\n                } catch (final IOException e) {\r\n                    Log.logException(e);\r\n                }\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post != null && post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, false)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(UTF8.getBytes(recommendHash));\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    Document[] documents = null;\r\n                    try {\r\n                        documents = sb.loader.loadDocuments(sb.loader.request(metadata.url(), true, false), CacheStrategy.IFEXIST, 5000, Integer.MAX_VALUE);\r\n                    } catch (final IOException e) {\r\n                    } catch (final Parser.Failure e) {\r\n                    }\r\n                    if (documents != null) {\r\n                        // create a news message\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", metadata.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", metadata.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\r\n                        map.put(\"author\", documents[0].dc_creator());\r\n                        map.put(\"tags\", documents[0].dc_subject(' '));\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), NewsPool.CATEGORY_SURFTIPP_ADD, map);\r\n                        documents[0].close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if a bookmarks-button was hit, create new bookmark entry\r\n            if (post != null && post.containsKey(\"bookmarkref\")) {\r\n                if (!sb.verifyAuthentication(header, false)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(UTF8.getBytes(bookmarkHash));\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    try {\r\n                        sb.tables.bookmarks.createBookmark(sb.loader, metadata.url(), YMarkTables.USER_ADMIN, true, \"searchresult\", \"/search\");\r\n                    } catch (final Throwable e) {\r\n                    }\r\n                }\r\n            }\r\n\r\n            // do the search\r\n            final HandleSet queryHashes = Word.words2hashesHandles(query[0]);\r\n            final Pattern snippetPattern = QueryParams.stringSearchPattern(originalquerystring);\r\n\r\n            // check filters\r\n            try {\r\n                Pattern.compile(urlmask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal URL mask, not a valid regex: \" + urlmask);\r\n                prop.put(\"urlmaskerror\", 1);\r\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\r\n                urlmask = \".*\";\r\n            }\r\n\r\n            try {\r\n                Pattern.compile(prefermask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal prefer mask, not a valid regex: \" + prefermask);\r\n                prop.put(\"prefermaskerror\", 1);\r\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\r\n                prefermask = \"\";\r\n            }\r\n\r\n            final QueryParams theQuery = new QueryParams(\r\n                    originalquerystring,\r\n                    queryHashes,\r\n                    Word.words2hashesHandles(query[1]),\r\n                    Word.words2hashesHandles(query[2]),\r\n                    snippetPattern,\r\n                    tenant,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdom,\r\n                    language,\r\n                    navigation,\r\n                    snippetFetchStrategy,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER :\r\n                    (global && indexReceiveGranted ? QueryParams.Searchdom.GLOBAL : QueryParams.Searchdom.LOCAL),\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    sitehash,\r\n                    authorhash,\r\n                    DigestURI.TLD_any_zone_filter,\r\n                    client,\r\n                    authenticated,\r\n                    indexSegment,\r\n                    ranking,\r\n                    header.get(RequestHeader.USER_AGENT, \"\"),\r\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false) && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false) && sb.peers.mySeed().getFlagAcceptRemoteIndex());\r\n            EventTracker.delete(EventTracker.EClass.SEARCH);\r\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theQuery.id(true), SearchEvent.Type.INITIALIZATION, \"\", 0, 0), false);\r\n\r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(3000);\r\n\r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(Switchboard.blueList);\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + QueryParams.hashSet2hashString(theQuery.queryHashes) + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            final long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (SearchEventCache.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\r\n                offset = 0;\r\n            }\r\n            final SearchEvent theSearch = SearchEventCache.getEvent(\r\n                theQuery, sb.peers, sb.tables, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false, sb.loader,\r\n                (int) sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\r\n                      sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_ROBINSON, 0),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_MULTIWORD, 0));\r\n\r\n            if (offset == 0) {\r\n                if (sitehost != null && sb.getConfigBool(\"heuristic.site\", false) && authenticated) {\r\n                    sb.heuristicSite(theSearch, sitehost);\r\n                }\r\n                if ((heuristicScroogle >= 0  || sb.getConfigBool(\"heuristic.scroogle\", false)) && authenticated) {\r\n                    sb.heuristicScroogle(theSearch);\r\n                }\r\n                if ((heuristicBlekko >= 0  || sb.getConfigBool(\"heuristic.blekko\", false)) && authenticated) {\r\n                    sb.heuristicRSS(\"http://blekko.com/ws/$+/rss\", theSearch, \"blekko\");\r\n                }\r\n            }\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    \"local-unfiltered(\" + theSearch.getRankingResult().getLocalIndexCount() + \"), \" +\r\n                    \"local_miss(\" + theSearch.getRankingResult().getMissCount() + \"), \" +\r\n                    \"local_sortout(\" + theSearch.getRankingResult().getSortOutCount() + \"), \" +\r\n                    \"remote(\" + theSearch.getRankingResult().getRemoteResourceSize() + \") links found, \" +\r\n                    (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.result().getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.result().getSnippetComputationTime();\r\n            AccessTracker.add(AccessTracker.Location.local, theQuery);\r\n\r\n            // check suggestions\r\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\r\n\r\n            prop.put(\"meanCount\", meanMax);\r\n            if (meanMax > 0 && !json && !rss) {\r\n                final DidYouMean didYouMean = new DidYouMean(indexSegment.termIndex(), new StringBuilder(querystring));\r\n            \tfinal Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\r\n                int meanCount = 0;\r\n                String suggestion;\r\n                while( meanCount<meanMax && meanIt.hasNext()) {\r\n                    suggestion = meanIt.next().toString();\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_word\", suggestion);\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_url\",\r\n                            QueryParams.navurl(\"html\", 0, theQuery, suggestion, originalUrlMask.toString(), theQuery.navigators).toString()\r\n    \t             );\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_sep\",\"|\");\r\n                    meanCount++;\r\n                }\r\n                prop.put(\"didYouMean_suggestions_\"+(meanCount-1)+\"_sep\",\"\");\r\n                prop.put(\"didYouMean\", meanCount>0 ? 1:0);\r\n                prop.put(\"didYouMean_suggestions\", meanCount);\r\n            } else {\r\n                prop.put(\"didYouMean\", 0);\r\n            }\r\n\r\n            // find geographic info\r\n            final SortedSet<Location> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\r\n            if (coordinates == null || coordinates.isEmpty() || offset > 0) {\r\n                prop.put(\"geoinfo\", \"0\");\r\n            } else {\r\n                int i = 0;\r\n                for (final Location c: coordinates) {\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\r\n                    i++;\r\n                    if (i >= 10) break;\r\n                }\r\n                prop.put(\"geoinfo_loc\", i);\r\n                prop.put(\"geoinfo\", \"1\");\r\n            }\r\n\r\n            // update the search tracker\r\n            try {\r\n                synchronized (trackerHandles) {\r\n                    trackerHandles.add(theQuery.time);\r\n                    while (trackerHandles.size() > 600) {\r\n                        if (!trackerHandles.remove(trackerHandles.first())) break;\r\n                    }\r\n                }\r\n                sb.localSearchTracker.put(client, trackerHandles);\r\n            \tif (sb.localSearchTracker.size() > 100) {\r\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\r\n                }\r\n            \tif (MemoryControl.shortStatus()) sb.localSearchTracker.clear();\r\n            } catch (final Exception e) {\r\n                Log.logException(e);\r\n            }\r\n\r\n            final int indexcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", Formatter.number(0, true));\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", Formatter.number(indexcount, true));\r\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_localMissCount\", Formatter.number(theSearch.getRankingResult().getMissCount(), true));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.getRankingResult().getRemoteIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.getRankingResult().getRemotePeerCount(), true));\r\n\r\n            // compose page navigation\r\n            final StringBuilder resnav = new StringBuilder(200);\r\n            final int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n            } else {\r\n            \tresnav.append(\"<a id=\\\"prevpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, theQuery, null, originalUrlMask, navigation).toString());\r\n            \tresnav.append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n            }\r\n            final int numberofpages = Math.min(10, 1 + ((indexcount - 1) / theQuery.displayResults()));\r\n\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n                } else {\r\n                    resnav.append(\"<a href=\\\"\");\r\n                    resnav.append(QueryParams.navurl(\"html\", i, theQuery, null, originalUrlMask, navigation).toString());\r\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" />\");\r\n            } else {\r\n                resnav.append(\"<a id=\\\"nextpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, theQuery, null, originalUrlMask, navigation).toString());\r\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>\");\r\n            }\r\n            final String resnavs = resnav.toString();\r\n            prop.put(\"num-results_resnav\", resnavs);\r\n            prop.put(\"pageNavBottom\", (indexcount - offset > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\r\n            prop.put(\"pageNavBottom_resnav\", resnavs);\r\n\r\n            // generate the search result lines; the content will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n\r\n            // process result of search\r\n            if (!filtered.isEmpty()) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.isEmpty()) {\r\n                if (post.get(\"query\", post.get(\"search\", \"\")).length() < 2) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(':') == -1) {\r\n                hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8090\"));\r\n            }\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n\r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.putHTML(\"former\", originalquerystring);\r\n        prop.put(\"count\", itemsPerPage);\r\n        prop.put(\"offset\", offset);\r\n        prop.put(\"resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"urlmaskfilter\", originalUrlMask);\r\n        prop.putHTML(\"prefermaskfilter\", prefermask);\r\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\r\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        prop.put(\"searchdomswitches\", sb.getConfigBool(\"search.text\", true) || sb.getConfigBool(\"search.audio\", true) || sb.getConfigBool(\"search.video\", true) || sb.getConfigBool(\"search.image\", true) || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n\r\n        // copy properties for \"more options\" link\r\n        prop.put(\"searchdomswitches_count\", prop.get(\"count\"));\r\n        prop.put(\"searchdomswitches_urlmaskfilter\", prop.get(\"urlmaskfilter\"));\r\n        prop.put(\"searchdomswitches_prefermaskfilter\", prop.get(\"prefermaskfilter\"));\r\n        prop.put(\"searchdomswitches_cat\", prop.get(\"cat\"));\r\n        prop.put(\"searchdomswitches_constraint\", prop.get(\"constraint\"));\r\n        prop.put(\"searchdomswitches_contentdom\", prop.get(\"contentdom\"));\r\n        prop.put(\"searchdomswitches_former\", prop.get(\"former\"));\r\n        prop.put(\"searchdomswitches_meanCount\", prop.get(\"meanCount\"));\r\n\r\n        // for RSS: don't HTML encode some elements\r\n        prop.putXML(\"rss_query\", originalquerystring);\r\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"0cf9ebc3b02b80ab4fab605aebf5fdd9a9c31db4","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!applicationFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"application_not_found\", applicationFile.getAbsolutePath());\r\n\t\t}\r\n\r\n\t\tlogger.info(\"Validating file \" + applicationFile.getName());\r\n\t\tfinal Application application = ServiceReader.getApplicationFromFile(applicationFile).getApplication();\r\n\r\n\t\tnormalizeApplicationName(application);\r\n\r\n\t\tif (adminFacade.getApplicationsList().contains(applicationName)) {\r\n\t\t\tthrow new CLIStatusException(\"application_already_deployed\", application.getName());\r\n\t\t}\r\n\r\n\t\tFile zipFile = null;\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile = Packager.packApplication(application, applicationFile);\r\n\t\t} else {\r\n\t\t\tif (applicationFile.getName().endsWith(\".zip\") || applicationFile.getName().endsWith(\".jar\")) {\r\n\t\t\t\tzipFile = applicationFile;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new CLIStatusException(\"application_file_format_mismatch\", applicationFile.getPath());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// toString of string list (i.e. [service1, service2])\r\n\t\tlogger.info(\"Uploading application \" + applicationName);\r\n\t\tString serviceOrder = adminFacade.installApplication(zipFile, applicationName);\r\n\t\t// If temp file was created, Delete it.\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile.delete();\r\n\t\t}\r\n\r\n\t\tif (serviceOrder.charAt(0) != '[' && serviceOrder.charAt(serviceOrder.length() - 1) != ']') {\r\n\t\t\tthrow new IllegalStateException(\"Cannot parse service order response: \" + serviceOrder);\r\n\t\t}\r\n\t\tif (serviceOrder.length() > 2) {\r\n\t\t\tserviceOrder = serviceOrder.substring(1, serviceOrder.length() - 1);\r\n\t\t\tlogger.fine(\"Services will be installed in the following order: \" + serviceOrder);\r\n\t\t\tprintApplicationInfo(application);\r\n\t\t\tfor (final String serviceName : serviceOrder.split(Pattern.quote(\",\"))) {\r\n\t\t\t\tfinal String trimmedServiceName = serviceName.trim();\r\n\t\t\t\tfinal Service service = getServiceByName(application, trimmedServiceName);\r\n\t\t\t\tfinal int plannedNumberOfInstances = service.getNumInstances();\r\n\t\t\t\tadminFacade.waitForServiceInstances(trimmedServiceName, applicationName, plannedNumberOfInstances,\r\n\t\t\t\t\t\tTIMEOUT_ERROR_MESSAGE, timeoutInMinutes, TimeUnit.MINUTES);\r\n\t\t\t\tlogger.info(MessageFormat.format(messages.getString(\"service_install_ended\"), trimmedServiceName));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsession.put(Constants.ACTIVE_APP, applicationName);\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(applicationName);\r\n\r\n\t\treturn this.getFormattedMessage(\"application_installed_succesfully\", Color.GREEN, applicationName);\r\n\t}","id":34456,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!applicationFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"application_not_found\", applicationFile.getAbsolutePath());\r\n\t\t}\r\n\r\n\t\tlogger.info(\"Validating file \" + applicationFile.getName());\r\n\t\tfinal Application application = ServiceReader.getApplicationFromFile(applicationFile).getApplication();\r\n\r\n\t\tnormalizeApplicationName(application);\r\n\r\n\t\tif (adminFacade.getApplicationsList().contains(applicationName)) {\r\n\t\t\tthrow new CLIStatusException(\"application_already_deployed\", application.getName());\r\n\t\t}\r\n\r\n\t\tFile zipFile = null;\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile = Packager.packApplication(application, applicationFile);\r\n\t\t} else {\r\n\t\t\tif (applicationFile.getName().endsWith(\".zip\") || applicationFile.getName().endsWith(\".jar\")) {\r\n\t\t\t\tzipFile = applicationFile;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new CLIStatusException(\"application_file_format_mismatch\", applicationFile.getPath());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// toString of string list (i.e. [service1, service2])\r\n\t\tlogger.info(\"Uploading application \" + applicationName);\r\n\t\tMap<String, String> result = adminFacade.installApplication(zipFile, applicationName, timeoutInMinutes);\n\t\tString serviceOrder = result.get(CloudifyConstants.SERVICE_ORDER);\n\t\tString pollingID = result.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\r\n\t\t// If temp file was created, Delete it.\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile.delete();\r\n\t\t}\r\n\r\n\t\tif (serviceOrder.charAt(0) != '[' && serviceOrder.charAt(serviceOrder.length() - 1) != ']') {\r\n\t\t\tthrow new IllegalStateException(\"Cannot parse service order response: \" + serviceOrder);\r\n\t\t}\n\t\t\n\t\tprintApplicationInfo(application);\n\t\t((RestAdminFacade)adminFacade).waitForLifecycleEvents(pollingID, TIMEOUT_ERROR_MESSAGE);\r\n\r\n\t\tsession.put(Constants.ACTIVE_APP, applicationName);\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(applicationName);\r\n\r\n\t\treturn this.getFormattedMessage(\"application_installed_succesfully\", Color.GREEN, applicationName);\r\n\t}","commit_id":"5f1af3aceb5ccf0e82510b4be5709ec21e98c04c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!serviceFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", serviceFile.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tint plannedNumberOfInstances = 1;\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (serviceFile.getName().endsWith(\".jar\") || serviceFile.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = serviceFile;\r\n\t\t\t} else if (serviceFile.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\r\n\t\t\t\tpackedFile = Packager.pack(serviceFile);\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t\tservice = ServiceReader.readService(serviceFile);\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = serviceFile;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\r\n\t\t\tplannedNumberOfInstances = service.getNumInstances();\r\n\t\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\tserviceName = serviceFile.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.length() == 0) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName = null;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service != null && service.getCompute() != null) {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttemplateName = \"\";\r\n\t\t}\r\n\t\tadminFacade.installElastic(packedFile, currentApplicationName, serviceName, zone, props, templateName);\r\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (serviceFile.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\t// TODO: Refactor waitXXX outside of adminFacade\r\n\t\tadminFacade.waitForServiceInstances(serviceName, currentApplicationName, plannedNumberOfInstances,\r\n\t\t\t\tTIMEOUT_ERROR_MESSAGE, timeoutInMinutes, TimeUnit.MINUTES);\r\n\r\n\t\treturn getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\r\n\t}","id":34457,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!serviceFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", serviceFile.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tint plannedNumberOfInstances = 1;\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (serviceFile.getName().endsWith(\".jar\") || serviceFile.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = serviceFile;\r\n\t\t\t} else if (serviceFile.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\r\n\t\t\t\tpackedFile = Packager.pack(serviceFile);\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t\tservice = ServiceReader.readService(serviceFile);\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = serviceFile;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\r\n\t\t\tplannedNumberOfInstances = service.getNumInstances();\r\n\t\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\tserviceName = serviceFile.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.length() == 0) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName = null;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service != null && service.getCompute() != null) {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttemplateName = \"\";\r\n\t\t}\r\n\t\tString lifecycleEventContainerPollingID = adminFacade.installElastic(packedFile, currentApplicationName, serviceName, zone, props, templateName, timeoutInMinutes);\n\n\t\t((RestAdminFacade)adminFacade).waitForLifecycleEvents(lifecycleEventContainerPollingID, TIMEOUT_ERROR_MESSAGE);\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (serviceFile.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\treturn getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\r\n\t}","commit_id":"5f1af3aceb5ccf0e82510b4be5709ec21e98c04c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String installApplication(final File applicationFile, final String applicationName) throws CLIException {\n\n\t\tString result = null;\n\t\ttry {\n\t\t\tfinal String url = SERVICE_CONTROLLER_URL + \"applications/\" + applicationName;\n\t\t\tresult = client.postFile(url, applicationFile);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\n\t\treturn result;\n\t}","id":34458,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic Map<String, String> installApplication(final File applicationFile, final String applicationName, int timeout) throws CLIException {\n\n\t\tMap<String, String> result = null;\n\t\ttry {\n\t\t\tfinal String url = SERVICE_CONTROLLER_URL + \"applications/\" + applicationName + \"/timeout/\" + timeout;\n\t\t\tresult = (Map<String, String>)client.postFile(url, applicationFile);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"5f1af3aceb5ccf0e82510b4be5709ec21e98c04c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String installElastic(final File packedFile, final String applicationName, final String serviceName,\n\t\t\tfinal String zone, final Properties contextProperties, final String templateName) throws CLIException {\n\n\t\tString result = null;\n\t\ttry {\n\t\t\tfinal String url = SERVICE_CONTROLLER_URL + \"applications/\" + applicationName + \"/services/\" + serviceName;\n\t\t\tresult = client\n\t\t\t\t\t.postFile(url + \"?zone=\" + zone + \"&template=\" + templateName, packedFile, contextProperties);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\n\t\treturn result;\n\t}","id":34459,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String installElastic(final File packedFile, final String applicationName, final String serviceName,\n\t\t\tfinal String zone, final Properties contextProperties, final String templateName, int timeout) throws CLIException {\n\n\t\tString result = null;\n\t\ttry {\n\t\t\tfinal String url = SERVICE_CONTROLLER_URL + \"applications/\" + applicationName + \"/services/\" + serviceName + \"/timeout/\" + timeout;\n\t\t\tresult = (String)client.postFile(url + \"?zone=\" + zone + \"&template=\" + templateName, packedFile,\n\t\t\t\t\tcontextProperties);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"5f1af3aceb5ccf0e82510b4be5709ec21e98c04c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected String doDeploy(final String applicationName, final File packedFile) throws CLIException {\n\n\t\tString result = null;\n\t\ttry {\n\t\t\tresult = client.postFile(SERVICE_CONTROLLER_URL + CLOUD_CONTROLLER_URL + \"deploy?\" + \"applicationName=\"\n\t\t\t\t\t+ applicationName, packedFile);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\n\t\treturn result;\n\t}","id":34460,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected String doDeploy(final String applicationName, final File packedFile) throws CLIException {\n\n\t\tString result = null;\n\t\ttry {\n\t\t\tresult = (String)client.postFile(SERVICE_CONTROLLER_URL + CLOUD_CONTROLLER_URL + \"deploy?\" + \"applicationName=\"\n\t\t\t\t\t+ applicationName, packedFile);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"5f1af3aceb5ccf0e82510b4be5709ec21e98c04c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n     *  Constructor\n     *\n     *  Most of the initialization is defered to the background thread\n     */\n    public OsgiInstallerImpl(final BundleContext ctx) {\n        this.ctx = ctx;\n        // Initialize file util\n        new FileDataStore(ctx);\n        final File f = FileDataStore.SHARED.getDataFile(\"RegisteredResourceList.ser\");\n        this.listener = new InstallListener(ctx, logger);\n        this.persistentList = new PersistentResourceList(f, listener);\n    }","id":34461,"modified_method":"/**\n     *  Constructor\n     *\n     *  Most of the initialization is defered to the background thread\n     */\n    public OsgiInstallerImpl(final BundleContext ctx) {\n        this.ctx = ctx;\n        // Initialize file util\n        new FileDataStore(ctx);\n        final File f = FileDataStore.SHARED.getDataFile(\"RegisteredResourceList.ser\");\n        this.listener = new InstallListener(ctx, logger);\n        this.persistentList = new PersistentResourceList(f, listener);\n        this.switchStartLevel = PropertiesUtil.toBoolean(ctx.getProperty(START_LEVEL_HANDLING), false);\n    }","commit_id":"7925aea7a849606e58937ce187ec42225f01be75","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Execute all tasks\n     */\n    private ACTION executeTasks(final SortedSet<InstallTask> tasks) {\n        if ( !tasks.isEmpty() ) {\n\n            final InstallationContext ctx = new InstallationContext() {\n\n                public void addTaskToNextCycle(final InstallTask t) {\n                    logger.warn(\"Deprecated method addTaskToNextCycle was called. Task will be executed in this cycle instead: {}\", t);\n                    synchronized ( tasks ) {\n                        tasks.add(t);\n                    }\n                }\n\n                public void addTaskToCurrentCycle(final InstallTask t) {\n                    logger.debug(\"Adding {}task to current cycle: {}\", t.isAsynchronousTask() ? \"async \" : \"\", t);\n                    synchronized ( tasks ) {\n                        tasks.add(t);\n                    }\n                }\n\n                public void addAsyncTask(final InstallTask t) {\n                    if ( t.isAsynchronousTask() ) {\n                        logger.warn(\"Deprecated method addAsyncTask was called: {}\", t);\n                        this.addTaskToCurrentCycle(t);\n                    } else {\n                        logger.warn(\"Deprecated method addAsyncTask is called with non async task(!): {}\", t);\n                        this.addTaskToCurrentCycle(new AsyncWrapperInstallTask(t));\n                    }\n                }\n\n                public void log(final String message, final Object... args) {\n                    auditLogger.info(message, args);\n                }\n\n                public void asyncTaskFailed(final InstallTask t) {\n                    // persist all changes and retry restart\n                    // remove attribute\n                    logger.debug(\"asyncTaskFailed: {}\", t);\n                    if ( t.getResource() != null ) {\n                        t.getResource().setAttribute(InstallTask.ASYNC_ATTR_NAME, null);\n                    }\n                    persistentList.save();\n                    synchronized ( resourcesLock ) {\n                        if ( !active ) {\n                            logger.debug(\"Restarting background thread from asyncTaskFailed\");\n                            active = true;\n                            startBackgroundThread();\n                        } else {\n                            logger.debug(\"active={}, no need to restart background thread\", active);\n                        }\n                    }\n                }\n            };\n            while (this.active && !tasks.isEmpty()) {\n                InstallTask task = null;\n                synchronized (tasks) {\n                    task = tasks.first();\n                    tasks.remove(task);\n                }\n                // async tasks are executed \"immediately\"\n                if ( task.isAsynchronousTask() ) {\n                    logger.debug(\"Executing async task: {}\", task);\n                    // set attribute\n                    final Integer oldValue;\n                    if ( task.getResource() != null ) {\n                        oldValue = (Integer)task.getResource().getAttribute(InstallTask.ASYNC_ATTR_NAME);\n                        final Integer newValue;\n                        if ( oldValue == null ) {\n                            newValue = 1;\n                        } else {\n                            newValue = oldValue + 1;\n                        }\n                        task.getResource().setAttribute(InstallTask.ASYNC_ATTR_NAME, newValue);\n                    } else {\n                        oldValue = null;\n                    }\n                    // save new state\n                    this.cleanupInstallableResources();\n                    final InstallTask aSyncTask = task;\n                    final String threadName = \"BackgroundTaskThread\" + backgroundTaskCounter.incrementAndGet();\n                    final Thread t = new Thread(threadName) {\n\n                        @Override\n                        public void run() {\n                            logger.debug(\"Starting background thread {} to execute {}\",\n                                    Thread.currentThread().getName(),\n                                    aSyncTask);\n                            try {\n                                Thread.sleep(2000L);\n                            } catch (final InterruptedException ie) {\n                                // ignore\n                            }\n                            // reset attribute\n                            if ( aSyncTask.getResource() != null ) {\n                                aSyncTask.getResource().setAttribute(InstallTask.ASYNC_ATTR_NAME, oldValue);\n                            }\n                            aSyncTask.execute(ctx);\n                            logger.debug(\"Background thread {} ends\",  Thread.currentThread().getName());\n                        }\n                    };\n                    t.start();\n                    return ACTION.SHUTDOWN;\n                }\n                try {\n                    logger.debug(\"Executing task: {}\", task);\n                    task.execute(ctx);\n                } catch (final Throwable t) {\n                    logger.error(\"Uncaught exception during task execution!\", t);\n                }\n            }\n            // save new state\n            final boolean newCycle = this.cleanupInstallableResources();\n            if ( newCycle ) {\n                return ACTION.CYCLE;\n            }\n\n        }\n        return ACTION.SLEEP;\n    }","id":34462,"modified_method":"/**\n     * Execute all tasks\n     * @param tasks The tasks to executed.\n     * @return The action to perform after the execution.\n     */\n    private ACTION executeTasks(final SortedSet<InstallTask> tasks) {\n        if (this.switchStartLevel && this.hasBundleUpdateTask(tasks)) {\n            // StartLevel service is always available\n            final ServiceReference ref = ctx.getServiceReference(StartLevel.class.getName());\n            final StartLevel startLevel = (StartLevel) ctx.getService(ref);\n            try {\n                final int targetStartLevel = this.getLowestStartLevel(tasks, startLevel);\n                final int currentStartLevel = startLevel.getStartLevel();\n                if (targetStartLevel < currentStartLevel) {\n                    auditLogger.info(\"Switching to start level {}\", targetStartLevel);\n                    try {\n                        startLevel.setStartLevel(targetStartLevel);\n                        // now we have to wait until the start level is reached\n                        while (startLevel.getStartLevel() > targetStartLevel) {\n                            try {\n                                Thread.sleep(300);\n                            } catch (final InterruptedException ie) {\n                                Thread.currentThread().interrupt();\n                            }\n\n                        }\n\n                        return doExecuteTasks(tasks);\n\n                    } finally {\n                        // restore old start level in any case\n                        startLevel.setStartLevel(currentStartLevel);\n                        auditLogger.info(\"Switching back to start level {} after performing the required \" +\n                                \"installation tasks\", currentStartLevel);\n\n                    }\n                }\n\n            } finally {\n                ctx.ungetService(ref);\n            }\n        }\n        return doExecuteTasks(tasks);\n    }","commit_id":"7925aea7a849606e58937ce187ec42225f01be75","url":"https://github.com/apache/sling"},{"original_method":"protected Option[] defaultConfiguration() {\n    \tString vmOpt = \"-Dosgi.installer.testing\";\n\n    \t// This runs in the VM that runs the build, but the tests run in another one.\n    \t// Make all osgi.installer.* system properties available to OSGi framework VM\n    \tfor(Object o : System.getProperties().keySet()) {\n    \t\tfinal String key = (String)o;\n    \t\tif(key.startsWith(\"osgi.installer.\")) {\n    \t\t\tvmOpt += \" -D\" + key + \"=\" + System.getProperty(key);\n    \t\t}\n    \t}\n\n    \t// optional debugging\n    \tfinal String paxDebugLevel = System.getProperty(\"pax.exam.log.level\", \"INFO\");\n    \tfinal String paxDebugPort = System.getProperty(\"pax.exam.debug.port\");\n    \tif(paxDebugPort != null && paxDebugPort.length() > 0) {\n        \tvmOpt += \" -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=\" + paxDebugPort;\n    \t}\n\n    \tString localRepo = System.getProperty(\"maven.repo.local\", \"\");\n\n    \treturn options(\n                junitBundles(),\n                when( localRepo.length() > 0 ).useOptions(\n                        systemProperty(\"org.ops4j.pax.url.mvn.localRepository\").value(localRepo)\n                ),\n                systemProperty( \"org.ops4j.pax.logging.DefaultServiceLog.level\" ).value(paxDebugLevel),\n                provision(\n                        mavenBundle(\"org.apache.sling\", \"org.apache.sling.commons.log\", \"3.0.0\"),\n                        mavenBundle(\"org.apache.sling\", \"org.apache.sling.commons.logservice\", \"1.0.2\"),\n\n                        mavenBundle(\"org.slf4j\", \"slf4j-api\", \"1.6.4\"),\n                        mavenBundle(\"org.slf4j\", \"jcl-over-slf4j\", \"1.6.4\"),\n                        mavenBundle(\"org.slf4j\", \"log4j-over-slf4j\", \"1.6.4\"),\n\n        \t            mavenBundle(\"org.apache.felix\", \"org.apache.felix.scr\", \"1.8.0\"),\n        \t            mavenBundle(\"org.apache.felix\", \"org.apache.felix.configadmin\", \"1.2.8\"),\n                        mavenBundle(\"org.apache.felix\", \"org.apache.felix.metatype\", \"1.0.2\"),\n        \t        \tmavenBundle(\"org.apache.sling\", \"org.apache.sling.installer.core\", POM_VERSION),\n                        mavenBundle(\"org.apache.sling\", \"org.apache.sling.installer.factory.configuration\", CONFIG_VERSION)\n        \t\t)\n        );\n    }","id":34463,"modified_method":"protected Option[] defaultConfiguration() {\n    \tString vmOpt = \"-Dosgi.installer.testing\";\n\n    \t// This runs in the VM that runs the build, but the tests run in another one.\n    \t// Make all osgi.installer.* system properties available to OSGi framework VM\n    \tfor(Object o : System.getProperties().keySet()) {\n    \t\tfinal String key = (String)o;\n    \t\tif(key.startsWith(\"osgi.installer.\")) {\n    \t\t\tvmOpt += \" -D\" + key + \"=\" + System.getProperty(key);\n    \t\t}\n    \t}\n\n    \t// optional debugging\n    \tfinal String paxDebugLevel = System.getProperty(\"pax.exam.log.level\", \"INFO\");\n    \tfinal String paxDebugPort = System.getProperty(\"pax.exam.debug.port\");\n    \tif(paxDebugPort != null && paxDebugPort.length() > 0) {\n        \tvmOpt += \" -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=\" + paxDebugPort;\n    \t}\n\n    \tString localRepo = System.getProperty(\"maven.repo.local\", \"\");\n\n    \treturn options(\n\n                junitBundles(),\n                when( localRepo.length() > 0 ).useOptions(\n                        systemProperty(\"org.ops4j.pax.url.mvn.localRepository\").value(localRepo)\n                ),\n                systemProperty( \"org.ops4j.pax.logging.DefaultServiceLog.level\" ).value(paxDebugLevel),\n                provision(\n                        mavenBundle(\"org.apache.sling\", \"org.apache.sling.commons.log\", \"3.0.0\"),\n                        mavenBundle(\"org.apache.sling\", \"org.apache.sling.commons.logservice\", \"1.0.2\"),\n\n                        mavenBundle(\"org.slf4j\", \"slf4j-api\", \"1.6.4\"),\n                        mavenBundle(\"org.slf4j\", \"jcl-over-slf4j\", \"1.6.4\"),\n                        mavenBundle(\"org.slf4j\", \"log4j-over-slf4j\", \"1.6.4\"),\n\n        \t            mavenBundle(\"org.apache.felix\", \"org.apache.felix.scr\", \"1.8.0\"),\n        \t            mavenBundle(\"org.apache.felix\", \"org.apache.felix.configadmin\", \"1.2.8\"),\n                        mavenBundle(\"org.apache.felix\", \"org.apache.felix.metatype\", \"1.0.2\"),\n        \t        \tmavenBundle(\"org.apache.sling\", \"org.apache.sling.installer.core\", POM_VERSION).startLevel(5),\n                        mavenBundle(\"org.apache.sling\", \"org.apache.sling.installer.factory.configuration\", CONFIG_VERSION).startLevel(5)\n        \t\t)\n        );\n    }","commit_id":"7925aea7a849606e58937ce187ec42225f01be75","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @throws BundleException\n     * @see org.apache.sling.jcr.jcrinstall.osgi.OsgiResourceProcessor#installOrUpdate(java.lang.String,\n     *      java.util.Map, java.io.InputStream)\n     */\n    public int installOrUpdate(String uri, Map<String, Object> attributes,\n            InstallableData installableData) throws BundleException, IOException {\n    \t\n    \t// Check that we have bundle data and manifest\n    \tInputStream data = installableData.adaptTo(InputStream.class);\n    \tif(data == null) {\n    \t\tthrow new IOException(\"InstallableData does not adapt to an InputStream: \" + uri);\n    \t}\n    \t\n\t\tfinal Manifest m = getManifest(installableData);\n\t\tif(m == null) {\n\t\t\tthrow new IOException(\"Manifest not found for InstallableData \" + uri);\n\t\t}\n\t\t\n        // Update if we already have a bundle id, else install\n\t\tBundle b;\n\t\tboolean updated;\n\t\ttry {\n\t\t\tb = null;\n\t\t\tupdated = false;\n\n\t\t\t// check whether we know the bundle and it exists\n\t\t\tfinal Long longId = (Long) attributes.get(KEY_BUNDLE_ID);\n\t\t\tif (longId != null) {\n\t\t\t    b = ctx.getBundle(longId);\n\t\t\t}\n\n\t\t\t// either we don't know the bundle yet or it does not exist,\n\t\t\t// so check whether the bundle can be found by its symbolic name\n\t\t\tif (b == null) {\n\t\t\t    b = getMatchingBundle(m);\n\t\t\t}\n\t\t\t\n\t\t\t// If the bundle (or one with the same symbolic name) is\n\t\t\t// already installed, ignore the new one if it's a lower\n\t\t\t// version\n\t\t\tif(b != null && m!= null) {\n\t\t\t\tfinal Version installedVersion = new Version((String)(b.getHeaders().get(Constants.BUNDLE_VERSION)));\n\t\t\t\tfinal Version newBundleVersion = new Version(m.getMainAttributes().getValue(Constants.BUNDLE_VERSION));\n\t\t\t\tif (newBundleVersion.compareTo(installedVersion) <= 0) {\n\t\t            log.debug(\n\t\t                \"Ignore update of bundle {} from {} as the installed version is equal or higher.\",\n\t\t                b.getSymbolicName(), uri);\n\t\t            return IGNORED;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (b != null) {\n\t\t\t\t// Existing bundle -> stop and update\n\t\t\t    log.debug(\"Calling Bundle.stop() and updating {}\", uri);\n\t\t\t    b.stop();\n\t\t\t    b.update(data);\n\t\t\t    updated = true;\n\t\t\t    needsRefresh = true;\n\t\t\t} else {\n\t\t\t\t// New bundle -> install\n\t\t\t    uri = OsgiControllerImpl.getResourceLocation(uri);\n\t\t\t    int level = installableData.getBundleStartLevel();\n\t\t\t    b = ctx.installBundle(uri, data);\n\t\t\t    if(level > 0) {\n\t\t\t        startLevel.setBundleStartLevel(b, level);\n\t                log.debug(\"No matching Bundle for uri {}, installed with start level {}\", uri, level);\n\t\t\t    } else {\n\t\t\t        level = startLevel.getBundleStartLevel(b);\n\t                log.debug(\"No matching Bundle for uri {}, installing with current default start level {}\", uri, level);\n\t\t\t    }\n\t\t\t}\n\t\t} finally {\n\t\t    // data is never null here\n\t\t    try {\n\t\t\t\tdata.close();\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\n        // ensure the bundle id in the attributes, this may be overkill\n        // in simple update situations, but is required for installations\n        // and updates where there are no attributes yet\n        attributes.put(KEY_BUNDLE_ID, b.getBundleId());\n\n        synchronized (activeBundles) {\n            installedBundles.add(b.getBundleId());\n        }\n\n        return updated ? UPDATED : INSTALLED;\n    }","id":34464,"modified_method":"/**\n     * @throws BundleException\n     * @see org.apache.sling.jcr.jcrinstall.osgi.OsgiResourceProcessor#installOrUpdate(java.lang.String,\n     *      java.util.Map, java.io.InputStream)\n     */\n    public int installOrUpdate(String uri, Map<String, Object> attributes,\n            InstallableData installableData) throws BundleException, IOException {\n    \t\n    \t// Check that we have bundle data and manifest\n    \tInputStream data = installableData.adaptTo(InputStream.class);\n    \tif(data == null) {\n    \t\tthrow new IOException(\"InstallableData does not adapt to an InputStream: \" + uri);\n    \t}\n    \t\n\t\tfinal Manifest m = getManifest(installableData);\n\t\tif(m == null) {\n\t\t\tthrow new IOException(\"Manifest not found for InstallableData \" + uri);\n\t\t}\n\t\t\n        // Update if we already have a bundle id, else install\n\t\tBundle b;\n\t\tboolean updated;\n\t\ttry {\n\t\t\tb = null;\n\t\t\tupdated = false;\n\n\t\t\t// check whether we know the bundle and it exists\n\t\t\tfinal Long longId = (Long) attributes.get(KEY_BUNDLE_ID);\n\t\t\tif (longId != null) {\n\t\t\t    b = ctx.getBundle(longId);\n\t\t\t}\n\n\t\t\t// either we don't know the bundle yet or it does not exist,\n\t\t\t// so check whether the bundle can be found by its symbolic name\n\t\t\tif (b == null) {\n\t\t\t    b = getMatchingBundle(m);\n\t\t\t}\n\t\t\t\n\t\t\t// If the bundle (or one with the same symbolic name) is\n\t\t\t// already installed, ignore the new one if it's a lower\n\t\t\t// version\n\t\t\tif(b != null && m!= null) {\n\t\t\t\tfinal Version installedVersion = new Version((String)(b.getHeaders().get(Constants.BUNDLE_VERSION)));\n\t\t\t\tfinal Version newBundleVersion = new Version(m.getMainAttributes().getValue(Constants.BUNDLE_VERSION));\n\t\t\t\tif (newBundleVersion.compareTo(installedVersion) <= 0) {\n\t\t            log.debug(\n\t\t                \"Ignore update of bundle {} from {} as the installed version is equal or higher.\",\n\t\t                b.getSymbolicName(), uri);\n\t\t            return IGNORED;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (b != null) {\n\t\t\t\t// Existing bundle -> stop, update, restart\n\t\t\t    log.debug(\"Calling Bundle.stop() and updating {}\", uri);\n\t\t\t    b.stop();\n\t\t\t    b.update(data);\n\t\t\t    b.start();\n\t\t\t    updated = true;\n\t\t\t    needsRefresh = true;\n\t\t\t} else {\n\t\t\t\t// New bundle -> install\n\t\t\t    uri = OsgiControllerImpl.getResourceLocation(uri);\n\t\t\t    int level = installableData.getBundleStartLevel();\n\t\t\t    b = ctx.installBundle(uri, data);\n\t\t\t    if(level > 0) {\n\t\t\t        startLevel.setBundleStartLevel(b, level);\n\t                log.debug(\"No matching Bundle for uri {}, installed with start level {}\", uri, level);\n\t\t\t    } else {\n\t\t\t        level = startLevel.getBundleStartLevel(b);\n\t                log.debug(\"No matching Bundle for uri {}, installing with current default start level {}\", uri, level);\n\t\t\t    }\n\t\t\t}\n\t\t} finally {\n\t\t    // data is never null here\n\t\t    try {\n\t\t\t\tdata.close();\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\n        // ensure the bundle id in the attributes, this may be overkill\n        // in simple update situations, but is required for installations\n        // and updates where there are no attributes yet\n        attributes.put(KEY_BUNDLE_ID, b.getBundleId());\n\n        synchronized (activeBundles) {\n            installedBundles.add(b.getBundleId());\n        }\n\n        return updated ? UPDATED : INSTALLED;\n    }","commit_id":"07369423e5810f7b6583847ac947a6767e2f823d","url":"https://github.com/apache/sling"},{"original_method":"@org.ops4j.pax.exam.junit.Configuration\n    public static Option[] configuration() {\n    \tString vmOpt = \"-Djrcinstall.testing\";\n    \t\n    \t// make all jcrinstall.* system properties available to OSGi framework VM\n    \tfor(Object o : System.getProperties().keySet()) {\n    \t\tfinal String key = (String)o;\n    \t\tif(key.startsWith(\"jcrinstall.\")) {\n    \t\t\tvmOpt += \" -D\" + key + \"=\" + System.getProperty(key);\n    \t\t}\n    \t}\n\n    \t// optional debugging\n    \tfinal String paxDebugPort = System.getProperty(\"pax.exam.debug.port\");\n    \tif(paxDebugPort != null && paxDebugPort.length() > 0) {\n        \tvmOpt += \" -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=\" + paxDebugPort; \n    \t}\n    \t\n        return options(\n            mavenBundle(\"org.apache.felix\", \"org.apache.felix.scr\"),\n            mavenBundle(\"org.apache.felix\", \"org.apache.felix.configadmin\"),\n            mavenBundle(\"org.apache.sling\", \"org.apache.sling.commons.log\"),\n        \tmavenBundle(\"org.apache.sling\", \"org.apache.sling.osgi.installer\", POM_VERSION),\n            felix(),\n            vmOption(vmOpt),\n            waitForFrameworkStartup()\n        );\n    }","id":34465,"modified_method":"@org.ops4j.pax.exam.junit.Configuration\n    public static Option[] configuration() {\n    \tString vmOpt = \"-Djrcinstall.testing\";\n    \t\n    \t// This runs in the VM that runs the build, but the tests run in another one.\n    \t// Make all jcrinstall.* system properties available to OSGi framework VM\n    \tfor(Object o : System.getProperties().keySet()) {\n    \t\tfinal String key = (String)o;\n    \t\tif(key.startsWith(\"jcrinstall.\")) {\n    \t\t\tvmOpt += \" -D\" + key + \"=\" + System.getProperty(key);\n    \t\t}\n    \t}\n\n    \t// optional debugging\n    \tfinal String paxDebugPort = System.getProperty(\"pax.exam.debug.port\");\n    \tif(paxDebugPort != null && paxDebugPort.length() > 0) {\n        \tvmOpt += \" -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=\" + paxDebugPort; \n    \t}\n    \t\n        return options(\n                felix(),\n                vmOption(vmOpt),\n                waitForFrameworkStartup(),\n        \t\tprovision(\n        \t            mavenBundle(\"org.apache.felix\", \"org.apache.felix.scr\", \"1.0.6\"),\n        \t            mavenBundle(\"org.apache.felix\", \"org.apache.felix.configadmin\").startLevel(CONFIG_ADMIN_START_LEVEL),\n        \t            mavenBundle(\"org.apache.sling\", \"org.apache.sling.commons.log\"),\n        \t        \tmavenBundle(\"org.apache.sling\", \"org.apache.sling.osgi.installer\", POM_VERSION)\n        \t\t)\n        );\n    }","commit_id":"07369423e5810f7b6583847ac947a6767e2f823d","url":"https://github.com/apache/sling"},{"original_method":"protected Configuration findConfiguration(String pid) throws Exception {\n    \tfinal Configuration[] cfgs = getService(ConfigurationAdmin.class).listConfigurations(null);\n    \tif(cfgs != null) {\n\t    \tfor(Configuration cfg : cfgs) {\n\t    \t\tif(cfg.getPid().equals(pid)) {\n\t    \t\t\treturn cfg;\n\t    \t\t}\n\t    \t}\n    \t}\n    \treturn null;\n    }","id":34466,"modified_method":"protected Configuration findConfiguration(String pid) throws Exception {\n    \tfinal ConfigurationAdmin ca = getService(ConfigurationAdmin.class);\n    \tif(ca != null) {\n\t    \tfinal Configuration[] cfgs = ca.listConfigurations(null);\n\t    \tif(cfgs != null) {\n\t\t    \tfor(Configuration cfg : cfgs) {\n\t\t    \t\tif(cfg.getPid().equals(pid)) {\n\t\t    \t\t\treturn cfg;\n\t\t    \t\t}\n\t\t    \t}\n\t    \t}\n    \t}\n    \treturn null;\n    }","commit_id":"07369423e5810f7b6583847ac947a6767e2f823d","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testInstallUpgradeDowngradeBundle() throws Exception {\n    \tfinal String symbolicName = \"jcrinstall-testbundle\";\n    \tfinal String uri = symbolicName + \".jar\";\n    \tfinal String BUNDLE_VERSION = \"Bundle-Version\";\n    \t\n    \tassertNull(\"Test bundle must not be present before test\", findBundle(symbolicName));\n    \t\n    \t// Install first test bundle and check version\n    \tlong bundleId = 0;\n    \tfinal OsgiController c = getService(OsgiController.class);\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.1.jar\")));\n        \tassertNull(\"Test bundle must be absent right after scheduleInstallOrUpdate\", findBundle(symbolicName));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tbundleId = b.getBundleId();\n        \tassertNotNull(\"Test bundle 1.1 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Version must be 1.1\", \"1.1\", b.getHeaders().get(BUNDLE_VERSION));\n    \t}\n    \t\n    \t// Upgrade to later version, verify\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.2.jar\")));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNotNull(\"Test bundle 1.2 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Version must be 1.2 after upgrade\", \"1.2\", b.getHeaders().get(BUNDLE_VERSION));\n        \tassertEquals(\"Bundle ID must not change after upgrade\", bundleId, b.getBundleId());\n    \t}\n    \t\n    \t// Downgrade to lower version, installed bundle must not change\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.0.jar\")));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNotNull(\"Test bundle 1.2 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Version must be 1.2 after ignored downgrade\", \"1.2\", b.getHeaders().get(BUNDLE_VERSION));\n        \tassertEquals(\"Bundle ID must not change after downgrade\", bundleId, b.getBundleId());\n    \t}\n    \t\n    \t// Uninstall\n    \t{\n        \tc.scheduleUninstall(uri);\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNull(\"Test bundle 1.2 must be gone\", b);\n    \t}\n    \t\n    \t// Install lower version, must work\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.0.jar\")));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNotNull(\"Test bundle 1.0 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Version must be 1.0 after uninstall and downgrade\", \"1.0\", b.getHeaders().get(BUNDLE_VERSION));\n        \tassertFalse(\"Bundle ID must have changed after uninstall and reinstall\", bundleId == b.getBundleId());\n    \t}\n    }","id":34467,"modified_method":"@Test\n    public void testInstallUpgradeDowngradeBundle() throws Exception {\n    \tfinal String symbolicName = \"jcrinstall-testbundle\";\n    \tfinal String uri = symbolicName + \".jar\";\n    \tfinal String BUNDLE_VERSION = \"Bundle-Version\";\n    \t\n    \tassertNull(\"Test bundle must not be present before test\", findBundle(symbolicName));\n    \t\n    \t// Install first test bundle and check version\n    \tlong bundleId = 0;\n    \tfinal OsgiController c = getService(OsgiController.class);\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.1.jar\")));\n        \tassertNull(\"Test bundle must be absent right after scheduleInstallOrUpdate\", findBundle(symbolicName));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tbundleId = b.getBundleId();\n        \tassertNotNull(\"Test bundle 1.1 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Installed bundle must be started\", Bundle.ACTIVE, b.getState());\n        \tassertEquals(\"Version must be 1.1\", \"1.1\", b.getHeaders().get(BUNDLE_VERSION));\n    \t}\n    \t\n    \t// Upgrade to later version, verify\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.2.jar\")));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNotNull(\"Test bundle 1.2 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Installed bundle must be started\", Bundle.ACTIVE, b.getState());\n        \tassertEquals(\"Version must be 1.2 after upgrade\", \"1.2\", b.getHeaders().get(BUNDLE_VERSION));\n        \tassertEquals(\"Bundle ID must not change after upgrade\", bundleId, b.getBundleId());\n    \t}\n    \t\n    \t// Downgrade to lower version, installed bundle must not change\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.0.jar\")));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNotNull(\"Test bundle 1.2 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Installed bundle must be started\", Bundle.ACTIVE, b.getState());\n        \tassertEquals(\"Version must be 1.2 after ignored downgrade\", \"1.2\", b.getHeaders().get(BUNDLE_VERSION));\n        \tassertEquals(\"Bundle ID must not change after downgrade\", bundleId, b.getBundleId());\n    \t}\n    \t\n    \t// Uninstall\n    \t{\n        \tc.scheduleUninstall(uri);\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNull(\"Test bundle 1.2 must be gone\", b);\n    \t}\n    \t\n    \t// Install lower version, must work\n    \t{\n        \tc.scheduleInstallOrUpdate(uri, new SimpleFileInstallableData(getTestBundle(\"org.apache.sling.jcr.jcrinstall.it-\" + POM_VERSION + \"-testbundle-1.0.jar\")));\n        \tc.executeScheduledOperations();\n        \tfinal Bundle b = findBundle(symbolicName);\n        \tassertNotNull(\"Test bundle 1.0 must be found after executeScheduledOperations\", b);\n        \tassertEquals(\"Installed bundle must be started\", Bundle.ACTIVE, b.getState());\n        \tassertEquals(\"Version must be 1.0 after uninstall and downgrade\", \"1.0\", b.getHeaders().get(BUNDLE_VERSION));\n        \tassertFalse(\"Bundle ID must have changed after uninstall and reinstall\", bundleId == b.getBundleId());\n    \t}\n    }","commit_id":"07369423e5810f7b6583847ac947a6767e2f823d","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testInstallAndRemoveConfig() throws Exception {\n    \tfinal OsgiController c = getService(OsgiController.class);\n    \tfinal Dictionary<String, Object> cfgData = new Hashtable<String, Object>();\n    \tcfgData.put(\"foo\", \"bar\");\n    \tfinal String cfgPid = getClass().getName() + \".\" + System.currentTimeMillis();\n    \t\n    \tassertNull(\"Config \" + cfgPid + \" must not be found before test\", findConfiguration(cfgPid));\n    \t\n    \tc.scheduleInstallOrUpdate(cfgPid, new DictionaryInstallableData(cfgData));\n    \tassertNull(\"Config \" + cfgPid + \" must not be found right after scheduleInstall\", findConfiguration(cfgPid));\n    \tc.executeScheduledOperations();\n    \t\n    \tfinal Configuration cfg = findConfiguration(cfgPid);\n    \tassertNotNull(\"Config \" + cfgPid + \" must be found right after executeScheduledOperations()\", cfg);\n    \tfinal String value = (String)cfg.getProperties().get(\"foo\");\n    \tassertEquals(\"Config value must match\", \"bar\", value);\n    \t\n    \tc.scheduleUninstall(cfgPid);\n    \tassertNotNull(\"Config \" + cfgPid + \" must still be found right after scheduleUninstall\", cfg);\n    \tc.executeScheduledOperations();\n    \tassertNull(\"Config \" + cfgPid + \" must be gone after executeScheduledOperations\", findConfiguration(cfgPid));\n    }","id":34468,"modified_method":"@Test\n    public void testInstallAndRemoveConfig() throws Exception {\n    \tsetStartLevel(CONFIG_ADMIN_START_LEVEL);\n    \tfinal OsgiController c = getService(OsgiController.class);\n    \tfinal Dictionary<String, Object> cfgData = new Hashtable<String, Object>();\n    \tcfgData.put(\"foo\", \"bar\");\n    \tfinal String cfgPid = getClass().getName() + \".\" + System.currentTimeMillis();\n    \t\n    \tassertNull(\"Config \" + cfgPid + \" must not be found before test\", findConfiguration(cfgPid));\n    \t\n    \tc.scheduleInstallOrUpdate(cfgPid, new DictionaryInstallableData(cfgData));\n    \tassertNull(\"Config \" + cfgPid + \" must not be found right after scheduleInstall\", findConfiguration(cfgPid));\n    \tc.executeScheduledOperations();\n    \t\n    \tfinal Configuration cfg = findConfiguration(cfgPid);\n    \tassertNotNull(\"Config \" + cfgPid + \" must be found right after executeScheduledOperations()\", cfg);\n    \tfinal String value = (String)cfg.getProperties().get(\"foo\");\n    \tassertEquals(\"Config value must match\", \"bar\", value);\n    \t\n    \tc.scheduleUninstall(cfgPid);\n    \tassertNotNull(\"Config \" + cfgPid + \" must still be found right after scheduleUninstall\", cfg);\n    \tc.executeScheduledOperations();\n    \tassertNull(\"Config \" + cfgPid + \" must be gone after executeScheduledOperations\", findConfiguration(cfgPid));\n    }","commit_id":"07369423e5810f7b6583847ac947a6767e2f823d","url":"https://github.com/apache/sling"},{"original_method":"public GrFileStub(GroovyFile file) {\n    super(file);\n    myPackageName = StringRef.fromString(file.getPackageName());\n    myName = StringRef.fromString(StringUtil.trimEnd(file.getName(), \".groovy\"));\n    isScript = file.isScript();\n    final GrPackageDefinition definition = file.getPackageDefinition();\n    if (definition != null) {\n      myAnnotations = GrStubUtils.getAnnotationNames(definition);\n    } else {\n      myAnnotations = ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n  }","id":34469,"modified_method":"public GrFileStub(GroovyFile file) {\n    super(file);\n    myName = StringRef.fromString(StringUtil.trimEnd(file.getName(), \".groovy\"));\n    isScript = file.isScript();\n    final GrPackageDefinition definition = file.getPackageDefinition();\n    if (definition != null) {\n      myAnnotations = GrStubUtils.getAnnotationNames(definition);\n    } else {\n      myAnnotations = ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrFileStub(StringRef packName, StringRef name, boolean isScript, String[] annotations) {\n    super(null);\n    myPackageName = packName;\n    myName = name;\n    this.isScript = isScript;\n    myAnnotations = annotations;\n  }","id":34470,"modified_method":"public GrFileStub(StringRef name, boolean isScript, String[] annotations) {\n    super(null);\n    myName = name;\n    this.isScript = isScript;\n    myAnnotations = annotations;\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrModifierList getAnnotationList() {\n    return (GrModifierList)findChildByType(GroovyElementTypes.MODIFIERS);\n  }","id":34471,"modified_method":"public GrModifierList getAnnotationList() {\n    return getStubOrPsiChild(GroovyElementTypes.MODIFIERS);\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPackageName() {\n    GrCodeReferenceElement ref = getPackageReference();\n    if (ref == null) return \"\";\n    return PsiUtil.getQualifiedReferenceText(ref);\n  }","id":34472,"modified_method":"public String getPackageName() {\n    final GrPackageDefinitionStub stub = getStub();\n    if (stub != null) {\n      return stub.getPackageName();\n    }\n\n    GrCodeReferenceElement ref = getPackageReference();\n    if (ref == null) return \"\";\n    return PsiUtil.getQualifiedReferenceText(ref);\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public GrFileStub deserialize(final StubInputStream dataStream, final StubElement parentStub) throws IOException {\n    StringRef packName = dataStream.readName();\n    StringRef name = dataStream.readName();\n    boolean isScript = dataStream.readBoolean();\n    return new GrFileStub(packName, name, isScript, GrStubUtils.readStringArray(dataStream));\n  }","id":34473,"modified_method":"@Override\n  public GrFileStub deserialize(final StubInputStream dataStream, final StubElement parentStub) throws IOException {\n    StringRef name = dataStream.readName();\n    boolean isScript = dataStream.readBoolean();\n    return new GrFileStub(name, isScript, GrStubUtils.readStringArray(dataStream));\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void serialize(final GrFileStub stub, final StubOutputStream dataStream) throws IOException {\n    dataStream.writeName(stub.getPackageName().toString());\n    dataStream.writeName(stub.getName().toString());\n    dataStream.writeBoolean(stub.isScript());\n    GrStubUtils.writeStringArray(dataStream, stub.getAnnotations());\n  }","id":34474,"modified_method":"@Override\n  public void serialize(final GrFileStub stub, final StubOutputStream dataStream) throws IOException {\n    dataStream.writeName(stub.getName().toString());\n    dataStream.writeBoolean(stub.isScript());\n    GrStubUtils.writeStringArray(dataStream, stub.getAnnotations());\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void indexStub(GrFileStub stub, IndexSink sink) {\n    String name = stub.getName().toString();\n    if (stub.isScript() && name != null) {\n      sink.occurrence(GrScriptClassNameIndex.KEY, name);\n      final String pName = stub.getPackageName().toString();\n      final String fqn = pName == null || pName.length() == 0 ? name : pName + \".\" + name;\n      sink.occurrence(GrFullScriptNameIndex.KEY, fqn.hashCode());\n    }\n\n    for (String anno : stub.getAnnotations()) {\n      sink.occurrence(GrAnnotatedMemberIndex.KEY, anno);\n    }\n  }","id":34475,"modified_method":"public void indexStub(GrFileStub stub, IndexSink sink) {\n    String name = stub.getName().toString();\n    if (stub.isScript() && name != null) {\n      sink.occurrence(GrScriptClassNameIndex.KEY, name);\n      final String pName = GrStubUtils.getPackageName(stub);\n      final String fqn = StringUtil.isEmpty(pName) ? name : pName + \".\" + name;\n      sink.occurrence(GrFullScriptNameIndex.KEY, fqn.hashCode());\n    }\n\n    for (String anno : stub.getAnnotations()) {\n      sink.occurrence(GrAnnotatedMemberIndex.KEY, anno);\n    }\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getStubVersion() {\n    return super.getStubVersion() + 13;\n  }","id":34476,"modified_method":"@Override\n  public int getStubVersion() {\n    return super.getStubVersion() + 14;\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getPackageName() {\n    final StubElement stub = getStub();\n    if (stub instanceof GrFileStub) {\n      return ((GrFileStub)stub).getPackageName().toString();\n    }\n    GrPackageDefinition packageDef = getPackageDefinition();\n    if (packageDef != null) {\n      return packageDef.getPackageName();\n    }\n    return \"\";\n  }","id":34477,"modified_method":"@NotNull\n  public String getPackageName() {\n    GrPackageDefinition packageDef = getPackageDefinition();\n    if (packageDef != null) {\n      final String name = packageDef.getPackageName();\n      if (name != null) {\n        return name;\n      }\n    }\n    return \"\";\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrPackageDefinition getPackageDefinition() {\n    ASTNode node = calcTreeElement().findChildByType(GroovyElementTypes.PACKAGE_DEFINITION);\n    return node != null ? (GrPackageDefinition)node.getPsi() : null;\n  }","id":34478,"modified_method":"public GrPackageDefinition getPackageDefinition() {\n    final StubElement<?> stub = getStub();\n    if (stub != null) {\n      for (StubElement element : stub.getChildrenStubs()) {\n        if (element instanceof GrPackageDefinition) return (GrPackageDefinition)element;\n      }\n      return null;\n    }\n\n    ASTNode node = calcTreeElement().findChildByType(GroovyElementTypes.PACKAGE_DEFINITION);\n    return node != null ? (GrPackageDefinition)node.getPsi() : null;\n  }","commit_id":"c5058bec2e389230ca5463d57aa9f06ac50601cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GrModifierList getModifierList() {\n    return (GrModifierList)findChildByType(GroovyElementTypes.MODIFIERS);\n  }","id":34479,"modified_method":"@Nullable\n  public GrModifierList getModifierList() {\n    return getStubOrPsiChild(GroovyElementTypes.MODIFIERS);\n  }","commit_id":"88a4f681c88021b95bb7e3f20464002bf30b28a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrEnumConstant[] getEnumConstants() {\n    return findChildrenByClass(GrEnumConstant.class);\n  }","id":34480,"modified_method":"public GrEnumConstant[] getEnumConstants() {\n    return getStubOrPsiChildren(GroovyElementTypes.ENUM_CONSTANT, GrEnumConstant.ARRAY_FACTORY);\n  }","commit_id":"7ce982118978323059c49ba9888a237ef9d4dfe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrEnumDefinitionBody getBody() {\n    return (GrEnumDefinitionBody)findChildByType(GroovyElementTypes.ENUM_BODY);\n  }","id":34481,"modified_method":"public GrEnumDefinitionBody getBody() {\n    return getStubOrPsiChild(GroovyElementTypes.ENUM_BODY);\n  }","commit_id":"7ce982118978323059c49ba9888a237ef9d4dfe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getStubVersion() {\n    return super.getStubVersion() + 10;\n  }","id":34482,"modified_method":"@Override\n  public int getStubVersion() {\n    return super.getStubVersion() + 11;\n  }","commit_id":"7ce982118978323059c49ba9888a237ef9d4dfe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrEnumConstantList getEnumConstantList() {\n      return findChildByClass(GrEnumConstantList.class);\n    }","id":34483,"modified_method":"@Nullable\n    public GrEnumConstantList getEnumConstantList() {\n      return getStubOrPsiChild(GroovyElementTypes.ENUM_CONSTANTS);\n    }","commit_id":"7ce982118978323059c49ba9888a237ef9d4dfe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiElement getDefinitionParent() {\n    final PsiElement candidate = getParentByStub();\n    if (candidate instanceof GroovyFile) {\n      return candidate;\n    }\n\n    return getParentByTree();\n  }","id":34484,"modified_method":"protected PsiElement getDefinitionParent() {\n    final PsiElement candidate = getParentByStub();\n    if (candidate instanceof GroovyFile || candidate instanceof GrTypeDefinitionBody) {\n      return candidate;\n    }\n\n    return getParentByTree();\n  }","commit_id":"e430b0fbb13ef1c3aaeb6ab929a1345cb01f1c17","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrMethod[] getGroovyMethods() {\n    return findChildrenByClass(GrMethod.class);\n  }","id":34485,"modified_method":"public GrMethod[] getGroovyMethods() {\n    return getStubOrPsiChildren(GroovyElementTypes.METHOD_DEFS, METHOD_ARRAY_FACTORY);\n  }","commit_id":"e430b0fbb13ef1c3aaeb6ab929a1345cb01f1c17","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GrTypeDefinitionBody getBody() {\n    return (GrTypeDefinitionBody)findChildByType(GroovyElementTypes.CLASS_BODY);\n  }","id":34486,"modified_method":"@Nullable\n  public GrTypeDefinitionBody getBody() {\n    return getStubOrPsiChild(GroovyElementTypes.CLASS_BODY);\n  }","commit_id":"e430b0fbb13ef1c3aaeb6ab929a1345cb01f1c17","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n  public String toString() {\r\n    final ArrayOutput ao = new ArrayOutput();\r\n    try {\r\n      serialize(Serializer.get(ao));\r\n    } catch(final IOException ex) {\r\n      Util.notexpected(ex);\r\n    }\r\n    return ao.toString();\r\n  }","id":34487,"modified_method":"@Override\r\n  public String toString() {\r\n    try {\r\n      return serialize().toString();\r\n    } catch(final IOException ex) {\r\n      throw Util.notexpected(ex);\r\n    }\r\n  }","commit_id":"9eea50073cf8ff4cdb3423421e633d7e957c3e13","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public String toString() {\r\n    final ArrayOutput ao = new ArrayOutput();\r\n    try {\r\n      serialize(Serializer.get(ao));\r\n    } catch(final IOException ex) {\r\n      // [LW] is that OK? Example: (1, 2, upper-case#1)\r\n      Util.notexpected(ex);\r\n    }\r\n    return ao.toString();\r\n  }","id":34488,"modified_method":"@Override\r\n  public String toString() {\r\n    try {\r\n      return serialize().toString();\r\n    } catch(final IOException ex) {\r\n      throw Util.notexpected(ex);\r\n    }\r\n  }","commit_id":"9eea50073cf8ff4cdb3423421e633d7e957c3e13","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Iter iter(final QueryContext ctx) throws QueryException {\r\n    switch(def) {\r\n      case INDEXOF:   return indexOf(ctx);\r\n      case DISTINCT:  return distinctValues(ctx);\r\n      case INSBEF:    return insertBefore(ctx);\r\n      case REVERSE:   return reverse(ctx);\r\n      case REMOVE:    return remove(ctx);\r\n      case SUBSEQ:    return subsequence(ctx);\r\n      case TAIL:      return tail(ctx);\r\n      case OUTERMOST: return outermost(ctx);\r\n      case INNERMOST: return innermost(ctx);\r\n      default:        return super.iter(ctx);\r\n    }\r\n  }","id":34489,"modified_method":"@Override\r\n  public Iter iter(final QueryContext ctx) throws QueryException {\r\n    switch(def) {\r\n      case INDEXOF:   return indexOf(ctx);\r\n      case DISTINCT:  return distinctValues(ctx);\r\n      case INSBEF:    return insertBefore(ctx);\r\n      case REVERSE:   return reverse(ctx);\r\n      case REMOVE:    return remove(ctx);\r\n      case SUBSEQ:    return subsequence(ctx);\r\n      case TAIL:      return tail(ctx);\r\n      case OUTERMOST: return most(ctx, true);\r\n      case INNERMOST: return most(ctx, false);\r\n      default:        return super.iter(ctx);\r\n    }\r\n  }","commit_id":"6de20da0e7d320753fe16bd181497ba4a4995891","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the outermost nodes of a node sequence, i.e. a node is only\r\n   * contained, if none of its ancestors are.\r\n   * @param ctx query context\r\n   * @return innermost nodes\r\n   * @throws QueryException exception\r\n   */\r\n  private Iter outermost(final QueryContext ctx) throws QueryException {\r\n    final Iter iter = expr[0].iter(ctx);\r\n    final NodeCache nc = new NodeCache().random();\r\n    for(Item it; (it = iter.next()) != null;) nc.add(checkNode(it));\r\n    final int len = (int) nc.size();\r\n\r\n    // only go further if there's at least one node\r\n    if(len == 0) return Empty.ITER;\r\n\r\n    if(nc.dbnodes()) {\r\n      // nodes are sorted, so ancestors always come before their descendants\r\n      // the first node is thus always included in the output\r\n      final DBNode fst = (DBNode) nc.get(0);\r\n      final Data data = fst.data;\r\n      final ANode[] nodes = nc.item.clone();\r\n      nc.size(1);\r\n\r\n      // skip the subtree of the last added node\r\n      int next = fst.pre + data.size(fst.pre, kind(fst.type));\r\n      for(int i = 1; i < len; i++) {\r\n        final DBNode nd = (DBNode) nodes[i];\r\n        if(nd.pre >= next) {\r\n          nc.add(nd);\r\n          next = nd.pre + data.size(nd.pre, kind(nd.type));\r\n        }\r\n      }\r\n    } else {\r\n      // [LW] multiple documents and/or constructed fragments\r\n      throw Util.notimplemented(\"doesn't work yet for constructed nodes\");\r\n    }\r\n    return nc;\r\n  }","id":34490,"modified_method":"/**\r\n   * Returns the outermost/innermost nodes of a node sequence, i.e. a node is\r\n   * only contained, if none of its ancestors/descendants are.\r\n   * @param ctx query context\r\n   * @param outer outermost flag\r\n   * @return outermost/innermost nodes\r\n   * @throws QueryException exception\r\n   */\r\n  private Iter most(final QueryContext ctx, final boolean outer)\r\n      throws QueryException {\r\n    final Iter iter = expr[0].iter(ctx);\r\n    final NodeCache nc = new NodeCache().random();\r\n    for(Item it; (it = iter.next()) != null;) nc.add(checkNode(it));\r\n    final int len = (int) nc.size();\r\n\r\n    // only go further if there are at least two nodes\r\n    if(len < 2) return nc;\r\n\r\n    // after this, the iterator is sorted and duplicate free\r\n    if(nc.dbnodes()) {\r\n      // nodes are sorted, so ancestors always come before their descendants\r\n      // the first/last node is thus always included in the output\r\n      final DBNode fst = (DBNode) nc.get(outer ? 0 : len - 1);\r\n      final Data data = fst.data;\r\n      final ANode[] nodes = nc.item.clone();\r\n      nc.item[0] = fst;\r\n      nc.size(1);\r\n\r\n      // [LW] improve with NodeCache.binarySearch()\r\n      if(outer) {\r\n        // skip the subtree of the last added node\r\n        int next = fst.pre + data.size(fst.pre, kind(fst.type));\r\n        for(int i = 1; i < len; i++) {\r\n          final DBNode nd = (DBNode) nodes[i];\r\n          if(nd.pre >= next) {\r\n            nc.add(nd);\r\n            next = nd.pre + data.size(nd.pre, kind(nd.type));\r\n          }\r\n        }\r\n      } else {\r\n        // skip ancestors of the last added node\r\n        int before = fst.pre;\r\n        for(int i = len - 1; i-- != 0;) {\r\n          final DBNode nd = (DBNode) nodes[i];\r\n          if(nd.pre + data.size(nd.pre, kind(nd.type)) <= before) {\r\n            nc.add(nd);\r\n            before = nd.pre;\r\n          }\r\n        }\r\n\r\n        // nodes were added in reverse order, correct that\r\n        Array.reverse(nc.item, 0, (int) nc.size());\r\n      }\r\n\r\n      return nc;\r\n    }\r\n\r\n    // multiple documents and/or constructed fragments\r\n    final NodeCache out = new NodeCache(new ANode[len], 0);\r\n    outer: for(int i = 0; i < len; i++) {\r\n      final ANode nd = nc.item[i];\r\n      final AxisIter ax = outer ? nd.anc() : nd.descendant();\r\n      for(ANode a; (a = ax.next()) != null;)\r\n        if(nc.indexOf(a, false) != -1) continue outer;\r\n      out.add(nc.item[i]);\r\n    }\r\n\r\n    return out;\r\n  }","commit_id":"6de20da0e7d320753fe16bd181497ba4a4995891","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates the hash of the given xs:string, using the algorithm {@code algo}.\r\n   * @param ctx query context\r\n   * @param algo hashing algorithm\r\n   * @return xs:hexBinary instance containing the hash\r\n   * @throws QueryException exception\r\n   */\r\n  private Hex hash(final QueryContext ctx, final String algo)\r\n      throws QueryException {\r\n\r\n    final byte[] str = checkStr(expr[0], ctx);\r\n    try {\r\n      return new Hex(MessageDigest.getInstance(algo).digest(str));\r\n    } catch(final NoSuchAlgorithmException ex) {\r\n      Util.notexpected(ex);\r\n      return null;\r\n    }\r\n  }","id":34491,"modified_method":"/**\r\n   * Creates the hash of the given xs:string, using the algorithm {@code algo}.\r\n   * @param ctx query context\r\n   * @param algo hashing algorithm\r\n   * @return xs:hexBinary instance containing the hash\r\n   * @throws QueryException exception\r\n   */\r\n  private Hex hash(final QueryContext ctx, final String algo)\r\n      throws QueryException {\r\n\r\n    final byte[] str = checkStr(expr[0], ctx);\r\n    try {\r\n      return new Hex(MessageDigest.getInstance(algo).digest(str));\r\n    } catch(final NoSuchAlgorithmException ex) {\r\n      throw Util.notexpected(ex);\r\n    }\r\n  }","commit_id":"6de20da0e7d320753fe16bd181497ba4a4995891","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Checks if the iterator contains a database node with the specified\r\n   * pre value.\r\n   * @param node node to be found\r\n   * @param db indicates if all nodes are sorted {@link DBNode} references\r\n   * @return position, or {@code -1}\r\n   */\r\n  public int indexOf(final ANode node, final boolean db) {\r\n    if(db) {\r\n      // binary search\r\n      final DBNode dbn = (DBNode) node;\r\n      int l = 0, h = size - 1;\r\n      while(l <= h) {\r\n        final int m = l + h >>> 1;\r\n        final DBNode n = (DBNode) item[m];\r\n        final int c = n.pre - dbn.pre;\r\n        if(c == 0) return n.data == dbn.data ? m : -1;\r\n        if(c < 0) l = m + 1;\r\n        else h = m - 1;\r\n      }\r\n    } else {\r\n      for(int s = 0; s < size(); ++s) {\r\n        if(item[s].is(node)) return s;\r\n      }\r\n    }\r\n    return -1;\r\n  }","id":34492,"modified_method":"/**\r\n   * Checks if the iterator contains a database node with the specified\r\n   * pre value.\r\n   * @param node node to be found\r\n   * @param db indicates if all nodes are sorted {@link DBNode} references\r\n   * @return position, or {@code -1}\r\n   */\r\n  public int indexOf(final ANode node, final boolean db) {\r\n    if(db) return binarySearch(((DBNode) node).pre, 0, size);\r\n    for(int s = 0; s < size(); ++s) if(item[s].is(node)) return s;\r\n    return -1;\r\n  }","commit_id":"6de20da0e7d320753fe16bd181497ba4a4995891","url":"https://github.com/BaseXdb/basex"},{"original_method":"private static String showDialogUrl(@NotNull final String url) {\n    return Messages.showInputDialog(\"Ipython Notebook URL:\", \"Start Ipython Notebook\", null, url,\n                                   new InputValidator() {\n                                     @Override\n                                     public boolean checkInput(String inputString) {\n                                       try {\n                                         new URL(inputString);\n                                       }\n                                       catch (MalformedURLException e) {\n                                         return false;\n                                       }\n                                       return !inputString.isEmpty();\n                                     }\n\n                                     @Override\n                                     public boolean canClose(String inputString) {\n                                       return true;\n                                     }\n                                   });\n  }","id":34493,"modified_method":"private static String showDialogUrl(@NotNull final String initialUrl) {\n    final String url = Messages.showInputDialog(\"Ipython Notebook URL:\", \"Start Ipython Notebook\", null, initialUrl,\n                                              new InputValidator() {\n                                                @Override\n                                                public boolean checkInput(String inputString) {\n                                                  try {\n                                                    new URL(inputString);\n                                                  }\n                                                  catch (MalformedURLException e) {\n                                                    return false;\n                                                  }\n                                                  return !inputString.isEmpty();\n                                                }\n\n                                                @Override\n                                                public boolean canClose(String inputString) {\n                                                  return true;\n                                                }\n                                              });\n    return url == null ? null : StringUtil.trimEnd(url, \"/\");\n  }","commit_id":"e7621abdcb8d4b8b56d834cc8d3e728605ed5325","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void executeCell(@NotNull final IpnbCodePanel codePanel) {\n    final IpnbFileEditor fileEditor = codePanel.getFileEditor();\n    final VirtualFile virtualFile = fileEditor.getVirtualFile();\n    final String path = virtualFile.getPath();\n    if (!myKernels.containsKey(path)) {\n      String url = IpnbSettings.getInstance(myProject).getURL();\n      if (StringUtil.isEmptyOrSpaces(url)) {\n        url = DEFAULT_URL;\n      }\n      if (!isAvailable(url)) {\n        url = showDialogUrl(url);\n        if (url == null) return;\n        startIpythonServer(url, fileEditor);\n        if (myProcessHandler != null) {\n          waitForIpythonServer();\n          startConnection(codePanel, path, url);\n          return;\n        }\n        else {\n          return;\n        }\n      }\n      if (StringUtil.isEmptyOrSpaces(url)) {\n        showWarning(fileEditor, \"Please, specify IPython Notebook URL in <a href=\\\"\\\">Settings->IPython Notebook<\/a>\");\n        return;\n      }\n      startConnection(codePanel, path, url);\n    }\n    else {\n      final IpnbConnection connection = myKernels.get(path);\n      if (connection != null) {\n        final String messageId = connection.execute(codePanel.getCell().getSourceAsString());\n        myUpdateMap.put(messageId, codePanel);\n      }\n    }\n  }","id":34494,"modified_method":"public void executeCell(@NotNull final IpnbCodePanel codePanel) {\n    final IpnbFileEditor fileEditor = codePanel.getFileEditor();\n    final VirtualFile virtualFile = fileEditor.getVirtualFile();\n    final String path = virtualFile.getPath();\n    if (!myKernels.containsKey(path)) {\n      String url = IpnbSettings.getInstance(myProject).getURL();\n      if (StringUtil.isEmptyOrSpaces(url)) {\n        url = DEFAULT_URL;\n      }\n      if (!isAvailable(url)) {\n        url = showDialogUrl(url);\n        if (url == null) return;\n        final boolean serverStarted = startIpythonServer(url, fileEditor);\n        if (myProcessHandler != null) {\n          waitForIpythonServer();\n          boolean connectionStarted = startConnection(codePanel, path, url);\n          if (connectionStarted && serverStarted) {\n            final Notification notification = new Notification(\"IpythonNotebook\", \"\", \"<html>Ipython notebook started at <a href=\\\"\" + url +\n                                                                                      \"\\\">\" + url + \"<\/a><\/html>\", NotificationType.INFORMATION, NotificationListener.URL_OPENING_LISTENER);\n            notification.notify(myProject);\n            IpnbSettings.getInstance(myProject).setURL(url);\n          }\n          return;\n        }\n        else {\n          return;\n        }\n      }\n      if (StringUtil.isEmptyOrSpaces(url)) {\n        showWarning(fileEditor, \"Please, specify IPython Notebook URL in <a href=\\\"\\\">Settings->IPython Notebook<\/a>\");\n        return;\n      }\n      startConnection(codePanel, path, url);\n    }\n    else {\n      final IpnbConnection connection = myKernels.get(path);\n      if (connection != null) {\n        final String messageId = connection.execute(codePanel.getCell().getSourceAsString());\n        myUpdateMap.put(messageId, codePanel);\n      }\n    }\n  }","commit_id":"e7621abdcb8d4b8b56d834cc8d3e728605ed5325","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean startIpythonServer(@NotNull final String url, @NotNull final IpnbFileEditor fileEditor) {\n    final Module module = ProjectFileIndex.SERVICE.getInstance(myProject).getModuleForFile(fileEditor.getVirtualFile());\n    if (module == null) return false;\n    final Sdk sdk = PythonSdkType.findPythonSdk(module);\n    if (sdk == null) {\n      showWarning(fileEditor, \"Please check Python Interpreter in Settings->Python Interpreter\");\n      return false;\n    }\n    try {\n      final PyPackage ipythonPackage = PyPackageManager.getInstance(sdk).findPackage(\"ipython\", false);\n      if (ipythonPackage == null) {\n        showWarning(fileEditor, \"Please check ipython installed in Python Interpreter in Settings->Python Interpreter\");\n        return false;\n      }\n    }\n    catch (ExecutionException ignored) {\n    }\n    final Map<String, String> env = ImmutableMap.of(\"PYCHARM_EP_DIST\", \"ipython\", \"PYCHARM_EP_NAME\", \"ipython\");\n    try {\n      final String ipython = PythonHelpersLocator.getHelperPath(\"pycharm/pycharm_load_entry_point.py\");\n      final GeneralCommandLine commandLine = new GeneralCommandLine(sdk.getHomePath(), ipython, \"notebook\", \"--no-browser\").\n        withWorkDirectory(myProject.getBasePath()).withEnvironment(env);\n\n      myProcessHandler = new KillableColoredProcessHandler(commandLine);\n\n      IpnbSettings.getInstance(myProject).setURL(url);\n      final Notification notification = new Notification(\"IpythonNotebook\", \"\", \"<html>Ipython notebook started at <a href=\\\"\" + url +\n        \"\\\">\" + url + \"<\/a><\/html>\", NotificationType.INFORMATION, NotificationListener.URL_OPENING_LISTENER);\n      notification.notify(myProject);\n      return true;\n    }\n    catch (ExecutionException e) {\n      return false;\n    }\n  }","id":34495,"modified_method":"private boolean startIpythonServer(@NotNull final String url, @NotNull final IpnbFileEditor fileEditor) {\n    final Module module = ProjectFileIndex.SERVICE.getInstance(myProject).getModuleForFile(fileEditor.getVirtualFile());\n    if (module == null) return false;\n    final Sdk sdk = PythonSdkType.findPythonSdk(module);\n    if (sdk == null) {\n      showWarning(fileEditor, \"Please check Python Interpreter in Settings->Python Interpreter\");\n      return false;\n    }\n    try {\n      final PyPackage ipythonPackage = PyPackageManager.getInstance(sdk).findPackage(\"ipython\", false);\n      if (ipythonPackage == null) {\n        showWarning(fileEditor, \"Please check ipython installed in Python Interpreter in Settings->Python Interpreter\");\n        return false;\n      }\n    }\n    catch (ExecutionException ignored) {\n    }\n    final Map<String, String> env = ImmutableMap.of(\"PYCHARM_EP_DIST\", \"ipython\", \"PYCHARM_EP_NAME\", \"ipython\");\n    try {\n      final String ipython = PythonHelpersLocator.getHelperPath(\"pycharm/pycharm_load_entry_point.py\");\n      final GeneralCommandLine commandLine = new GeneralCommandLine(sdk.getHomePath(), ipython, \"notebook\", \"--no-browser\").\n        withWorkDirectory(myProject.getBasePath()).withEnvironment(env);\n\n      myProcessHandler = new KillableColoredProcessHandler(commandLine);\n\n      return true;\n    }\n    catch (ExecutionException e) {\n      return false;\n    }\n  }","commit_id":"e7621abdcb8d4b8b56d834cc8d3e728605ed5325","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void startConnection(@NotNull final IpnbCodePanel codePanel, @NotNull final String path, @NotNull final String url) {\n    try {\n      final IpnbConnection connection = new IpnbConnection(new URI(url), new IpnbConnectionListenerBase() {\n        @Override\n        public void onOpen(@NotNull IpnbConnection connection) {\n          final String messageId = connection.execute(codePanel.getCell().getSourceAsString());\n          myUpdateMap.put(messageId, codePanel);\n        }\n\n        @Override\n        public void onOutput(@NotNull IpnbConnection connection,\n                             @NotNull String parentMessageId,\n                             @NotNull List<IpnbOutputCell> outputs,\n                             @Nullable Integer execCount) {\n          if (!myUpdateMap.containsKey(parentMessageId)) return;\n          final IpnbCodePanel cell = myUpdateMap.remove(parentMessageId);\n          cell.getCell().setPromptNumber(execCount);\n          cell.updatePanel(outputs);\n        }\n      });\n      myKernels.put(path, connection);\n    }\n    catch (URISyntaxException e) {\n      showWarning(codePanel.getFileEditor(), \"Please, check IPython Notebook URL in Settings->IPython Notebook\");\n    }\n    catch (IOException e) {\n      showWarning(codePanel.getFileEditor(), \"IPython Notebook connection refused\");\n    }\n  }","id":34496,"modified_method":"private boolean startConnection(@NotNull final IpnbCodePanel codePanel, @NotNull final String path, @NotNull final String url) {\n    try {\n      final IpnbConnection connection = new IpnbConnection(new URI(url), new IpnbConnectionListenerBase() {\n        @Override\n        public void onOpen(@NotNull IpnbConnection connection) {\n          final String messageId = connection.execute(codePanel.getCell().getSourceAsString());\n          myUpdateMap.put(messageId, codePanel);\n        }\n\n        @Override\n        public void onOutput(@NotNull IpnbConnection connection,\n                             @NotNull String parentMessageId,\n                             @NotNull List<IpnbOutputCell> outputs,\n                             @Nullable Integer execCount) {\n          if (!myUpdateMap.containsKey(parentMessageId)) return;\n          final IpnbCodePanel cell = myUpdateMap.remove(parentMessageId);\n          cell.getCell().setPromptNumber(execCount);\n          cell.updatePanel(outputs);\n        }\n      });\n      myKernels.put(path, connection);\n    }\n    catch (URISyntaxException e) {\n      showWarning(codePanel.getFileEditor(), \"Please, check IPython Notebook URL in Settings->IPython Notebook\");\n      return false;\n    }\n    catch (IOException e) {\n      showWarning(codePanel.getFileEditor(), \"IPython Notebook connection refused\");\n      return false;\n    }\n    return true;\n  }","commit_id":"e7621abdcb8d4b8b56d834cc8d3e728605ed5325","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private String showEditDialog(final String initialValue) {\n      return Messages.showInputDialog(this, myQuery, \"Folding pattern\", Messages.getQuestionIcon(), initialValue, null);\n    }","id":34497,"modified_method":"@Nullable\n    private String showEditDialog(final String initialValue) {\n      return Messages.showInputDialog(this, myQuery, \"Folding pattern\", Messages.getQuestionIcon(), initialValue, new InputValidator() {\n        @Override\n        public boolean checkInput(String inputString) {\n           return true;\n        }\n\n        @Override\n        public boolean canClose(String inputString) {\n          if (StringUtil.isEmpty(inputString)) {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                Messages.showErrorDialog(\"Console folding rule string cannot be empty\", \"Console Folding Rule Adding Error\");\n              }\n            });\n            return false;\n          }\n          return true;\n        }\n      });\n    }","commit_id":"ccd81f5a343864f09cb27d7cef6f03243dca5edf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Process the given {@link JavaClass}, ie add missing javadoc tags depending user parameters.\n     *\n     * @param javaClass not null\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     */\n    private void processFix( JavaClass javaClass )\n        throws IOException, MojoExecutionException\n    {\n        // Skipping inner classes\n        if ( javaClass.isInner() )\n        {\n            return;\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Reading \" + javaClass.getFullyQualifiedName() );\n        }\n        final File javaFile = javaClass.getSource().getFile();\n        Reader fileReader = null;\n        // the original java content in memory\n        String originalContent;\n        try\n        {\n            fileReader = ReaderFactory.newReader( javaFile, encoding );\n            originalContent = StringUtils.unifyLineSeparators( IOUtil.toString( fileReader ) );\n        }\n        finally\n        {\n            IOUtil.close( fileReader );\n        }\n\n        final StringWriter stringWriter = new StringWriter();\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Fixing \" + javaClass.getFullyQualifiedName() );\n        }\n        BufferedReader reader = null;\n        try\n        {\n            reader = new BufferedReader( new StringReader( originalContent ) );\n\n            String line;\n            int lineNumber = 0;\n            while ( ( line = reader.readLine() ) != null )\n            {\n                lineNumber++;\n                final String indent = autodetectIndentation( line );\n\n                if ( lineNumber == javaClass.getLineNumber() )\n                {\n                    fixClassComment( stringWriter, originalContent, javaClass, indent );\n\n                    takeCareSingleComment( stringWriter, originalContent, javaClass );\n                }\n\n                if ( javaClass.getFields() != null )\n                {\n                    for ( int i = 0; i < javaClass.getFields().length; i++ )\n                    {\n                        JavaField field = javaClass.getFields()[i];\n\n                        if ( lineNumber == field.getLineNumber() )\n                        {\n                            fixFieldComment( stringWriter, field, indent );\n                        }\n                    }\n                }\n\n                if ( javaClass.getMethods() != null )\n                {\n                    for ( int i = 0; i < javaClass.getMethods().length; i++ )\n                    {\n                        JavaMethod method = javaClass.getMethods()[i];\n\n                        if ( lineNumber == method.getLineNumber() )\n                        {\n                            fixMethodComment( stringWriter, originalContent, method, indent );\n\n                            takeCareSingleComment( stringWriter, originalContent, method );\n                        }\n                    }\n                }\n\n                stringWriter.write( line );\n                stringWriter.write( EOL );\n            }\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Saving \" + javaClass.getFullyQualifiedName() );\n        }\n        final Writer writer = WriterFactory.newWriter( javaFile, encoding );\n        try\n        {\n            writer.write( stringWriter.toString() );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","id":34498,"modified_method":"/**\n     * Process the given {@link JavaClass}, ie add missing javadoc tags depending user parameters.\n     *\n     * @param javaClass not null\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     */\n    private void processFix( JavaClass javaClass )\n        throws IOException, MojoExecutionException\n    {\n        // Skipping inner classes\n        if ( javaClass.isInner() )\n        {\n            return;\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Reading '\" + javaClass.getFullyQualifiedName() + \"' class.\" );\n        }\n\n        final File javaFile = javaClass.getSource().getFile();\n        // the original java content in memory\n        final String originalContent = readFile( javaFile, encoding );\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Fixing \" + javaClass.getFullyQualifiedName() );\n        }\n\n        final StringWriter stringWriter = new StringWriter();\n        BufferedReader reader = null;\n        try\n        {\n            reader = new BufferedReader( new StringReader( originalContent ) );\n\n            String line;\n            int lineNumber = 0;\n            while ( ( line = reader.readLine() ) != null )\n            {\n                lineNumber++;\n                final String indent = autodetectIndentation( line );\n\n                // fixing classes\n                if ( javaClass.getComment() == null && javaClass.getAnnotations() != null\n                    && javaClass.getAnnotations().length != 0 )\n                {\n                    if ( lineNumber == javaClass.getAnnotations()[0].getLineNumber() )\n                    {\n                        fixClassComment( stringWriter, originalContent, javaClass, indent );\n\n                        takeCareSingleComment( stringWriter, originalContent, javaClass );\n                    }\n                }\n                else\n                {\n                    if ( lineNumber == javaClass.getLineNumber() )\n                    {\n                        fixClassComment( stringWriter, originalContent, javaClass, indent );\n\n                        takeCareSingleComment( stringWriter, originalContent, javaClass );\n                    }\n                }\n\n                // fixing fields\n                if ( javaClass.getFields() != null )\n                {\n                    for ( int i = 0; i < javaClass.getFields().length; i++ )\n                    {\n                        JavaField field = javaClass.getFields()[i];\n\n                        if ( lineNumber == field.getLineNumber() )\n                        {\n                            fixFieldComment( stringWriter, javaClass, field, indent );\n                        }\n                    }\n                }\n\n                // fixing methods\n                if ( javaClass.getMethods() != null )\n                {\n                    for ( int i = 0; i < javaClass.getMethods().length; i++ )\n                    {\n                        JavaMethod method = javaClass.getMethods()[i];\n\n                        if ( lineNumber == method.getLineNumber() )\n                        {\n                            fixMethodComment( stringWriter, originalContent, method, indent );\n\n                            takeCareSingleComment( stringWriter, originalContent, method );\n                        }\n                    }\n                }\n\n                stringWriter.write( line );\n                stringWriter.write( EOL );\n            }\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Saving \" + javaClass.getFullyQualifiedName() );\n        }\n        writeFile( javaFile, encoding, stringWriter.toString() );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param stringWriter not null\n     * @param originalContent not null\n     * @param entity not null\n     * @param indent not null\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     */\n    private void updateEntityComment( final StringWriter stringWriter, final String originalContent,\n                                      final AbstractInheritableJavaEntity entity, final String indent )\n        throws MojoExecutionException, IOException\n    {\n        String s = stringWriter.toString();\n        int i = s.lastIndexOf( START_JAVADOC );\n        if ( i != -1 )\n        {\n            int eol = 0;\n            for ( int j = i - 1; j > 0; j-- )\n            {\n                if ( !Character.isWhitespace( s.charAt( j ) ) )\n                {\n                    eol = StringUtils.countMatches( s.substring( j, i + 1 ), EOL );\n                    break;\n                }\n            }\n\n            String tmp = trimRight( s.substring( 0, i ) );\n            stringWriter.getBuffer().delete( 0, stringWriter.getBuffer().length() );\n            stringWriter.write( tmp );\n            if ( eol > 0 )\n            {\n                for ( int j = 0; j < eol; j++ )\n                {\n                    stringWriter.write( EOL );\n                }\n            }\n        }\n\n        updateJavadocComment( stringWriter, originalContent, entity, indent );\n    }","id":34499,"modified_method":"/**\n     * @param stringWriter not null\n     * @param originalContent not null\n     * @param entity not null\n     * @param indent not null\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     */\n    private void updateEntityComment( final StringWriter stringWriter, final String originalContent,\n                                      final AbstractInheritableJavaEntity entity, final String indent )\n        throws MojoExecutionException, IOException\n    {\n        String s = stringWriter.toString();\n        int i = s.lastIndexOf( START_JAVADOC );\n        if ( i != -1 )\n        {\n            String tmp = s.substring( 0, i );\n            if ( tmp.lastIndexOf( EOL ) != -1 )\n            {\n                tmp = tmp.substring( 0, tmp.lastIndexOf( EOL ) );\n            }\n            stringWriter.getBuffer().delete( 0, stringWriter.getBuffer().length() );\n            stringWriter.write( tmp );\n            stringWriter.write( EOL );\n        }\n\n        updateJavadocComment( stringWriter, originalContent, entity, indent );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Work around for QDOX-146 about whitespace.\n     * Ideally we want to use <code>docletTag.getValue()<\/code>\n     *\n     * @param javaClassContent original class content not null\n     * @param entity not null\n     * @param docletTag not null\n     * @return the javadoc comment for the entity without Javadoc tags.\n     * @throws IOException if any\n     */\n    private static String getJavadocComment( String javaClassContent, AbstractInheritableJavaEntity entity,\n                                             DocletTag docletTag )\n        throws IOException\n    {\n        if ( docletTag.getValue() == null )\n        {\n            return \"\";\n        }\n\n        String originalJavadoc = extractOriginalJavadoc( javaClassContent, entity );\n        if ( originalJavadoc.indexOf( START_JAVADOC ) != -1 )\n        {\n            originalJavadoc =\n                originalJavadoc.substring( originalJavadoc.indexOf( START_JAVADOC ) + START_JAVADOC.length() );\n        }\n        if ( originalJavadoc.indexOf( END_JAVADOC ) != -1 )\n        {\n            originalJavadoc = originalJavadoc.substring( 0, originalJavadoc.indexOf( END_JAVADOC ) );\n        }\n        String[] originalJavadocLines = getLines( originalJavadoc );\n\n        if ( originalJavadocLines.length == 1 )\n        {\n            return originalJavadocLines[0];\n        }\n        String[] docletTagLines = getLines( docletTag.getValue() );\n\n        StringBuffer sb = new StringBuffer();\n\n        boolean intag = false;\n        for ( int i = 0; i < originalJavadocLines.length; i++ )\n        {\n            String line = originalJavadocLines[i];\n\n            if ( intag )\n            {\n                Matcher matcher = JAVADOC_TAG_LINE_PATTERN.matcher( line );\n                if ( matcher.find() || line.indexOf( END_JAVADOC ) != -1 )\n                {\n                    break;\n                }\n                sb.append( line );\n                sb.append( EOL );\n            }\n\n            if ( !intag\n                && line.indexOf( \"@\" + docletTag.getName() ) != -1\n                && StringUtils.removeDuplicateWhitespace( line )\n                              .endsWith( StringUtils.removeDuplicateWhitespace( docletTagLines[0] ) ) )\n            {\n                intag = true;\n\n                sb.append( line );\n                sb.append( EOL );\n            }\n        }\n\n        if ( sb.toString().lastIndexOf( EOL ) != -1 )\n        {\n            return sb.toString().substring( 0, sb.toString().lastIndexOf( EOL ) );\n        }\n\n        return sb.toString();\n    }","id":34500,"modified_method":"/**\n     * Work around for QDOX-146 about whitespace.\n     * Ideally we want to use <code>docletTag.getValue()<\/code>\n     *\n     * @param javaClassContent original class content not null\n     * @param entity not null\n     * @param docletTag not null\n     * @return the javadoc comment for the entity without Javadoc tags.\n     * @throws IOException if any\n     */\n    private static String getJavadocComment( String javaClassContent, AbstractInheritableJavaEntity entity,\n                                             DocletTag docletTag )\n        throws IOException\n    {\n        if ( docletTag.getValue() == null )\n        {\n            return \"\";\n        }\n\n        String originalJavadoc = extractOriginalJavadoc( javaClassContent, entity );\n        if ( originalJavadoc.indexOf( START_JAVADOC ) != -1 )\n        {\n            originalJavadoc =\n                originalJavadoc.substring( originalJavadoc.indexOf( START_JAVADOC ) + START_JAVADOC.length() );\n        }\n        if ( originalJavadoc.indexOf( END_JAVADOC ) != -1 )\n        {\n            originalJavadoc = originalJavadoc.substring( 0, originalJavadoc.indexOf( END_JAVADOC ) );\n        }\n        String[] originalJavadocLines = getLines( originalJavadoc );\n\n        if ( originalJavadocLines.length == 1 )\n        {\n            return originalJavadocLines[0];\n        }\n\n        // Note: docletTag.getValue() removes duplicate whitespace\n        String[] docletTagLines = getLines( docletTag.getValue() );\n\n        StringBuffer sb = new StringBuffer();\n        for ( int i = 0; i < docletTagLines.length; i++ )\n        {\n            boolean found = false;\n            for ( int j = 0; j < originalJavadocLines.length; j++ )\n            {\n                String line = originalJavadocLines[j];\n\n                if ( line.indexOf( \"@\" + docletTag.getName() ) != -1 )\n                {\n                    found = true;\n                }\n                if ( found\n                    && StringUtils.removeDuplicateWhitespace( line ).trim()\n                                  .endsWith( StringUtils.removeDuplicateWhitespace( docletTagLines[i] ).trim() ) )\n                {\n                    sb.append( line );\n                    sb.append( EOL );\n                    if ( docletTag.getParameters().length == 1 )\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if ( sb.toString().lastIndexOf( EOL ) != -1 )\n        {\n            return sb.toString().substring( 0, sb.toString().lastIndexOf( EOL ) );\n        }\n\n        return sb.toString();\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Take care of block or single comments between Javadoc comment and entity declaration ie:\n     * <pre>\n     * &#47;&#42;&#42;\n     * &#32;&#42; {Javadoc Comment}\n     * &#32;&#42;&#47;\n     * &#47;&#42;\n     * &#32;&#42; {Block Comment}\n     * &#32;&#42;&#47;\n     * &#47;&#47; {Single comment}\n     * entity\n     * <\/pre>\n     *\n     * @param stringWriter not null\n     * @param originalContent not null\n     * @param entity not null\n     * @throws IOException if any\n     * @see #extractOriginalJavadoc(String, AbstractJavaEntity)\n     */\n    private void takeCareSingleComment( final StringWriter stringWriter, final String originalContent,\n                                        final AbstractInheritableJavaEntity entity )\n        throws IOException\n    {\n        if ( entity.getComment() == null )\n        {\n            return;\n        }\n\n        String javadocComment = extractOriginalJavadoc( originalContent, entity );\n        String extraComment =\n            javadocComment.substring( javadocComment.indexOf( END_JAVADOC ) + END_JAVADOC.length() );\n        if ( StringUtils.isNotEmpty( extraComment ) )\n        {\n            if ( extraComment.indexOf( EOL ) != -1 )\n            {\n                stringWriter.write( extraComment.substring( extraComment.indexOf( EOL ) + EOL.length() ) );\n            }\n            else\n            {\n                stringWriter.write( extraComment );\n            }\n            stringWriter.write( EOL );\n        }\n    }","id":34501,"modified_method":"/**\n     * Take care of block or single comments between Javadoc comment and entity declaration ie:\n     * <pre>\n     * &#47;&#42;&#42;\n     * &#32;&#42; {Javadoc Comment}\n     * &#32;&#42;&#47;\n     * &#47;&#42;\n     * &#32;&#42; {Block Comment}\n     * &#32;&#42;&#47;\n     * &#47;&#47; {Single comment}\n     * entity\n     * <\/pre>\n     *\n     * @param stringWriter not null\n     * @param originalContent not null\n     * @param entity not null\n     * @throws IOException if any\n     * @see #extractOriginalJavadoc(String, AbstractJavaEntity)\n     */\n    private void takeCareSingleComment( final StringWriter stringWriter, final String originalContent,\n                                        final AbstractInheritableJavaEntity entity )\n        throws IOException\n    {\n        if ( entity.getComment() == null )\n        {\n            return;\n        }\n\n        String javadocComment = trimRight( extractOriginalJavadoc( originalContent, entity ) );\n        String extraComment =\n            javadocComment.substring( javadocComment.indexOf( END_JAVADOC ) + END_JAVADOC.length() );\n        if ( StringUtils.isNotEmpty( extraComment ) )\n        {\n            if ( extraComment.indexOf( EOL ) != -1 )\n            {\n                stringWriter.write( extraComment.substring( extraComment.indexOf( EOL ) + EOL.length() ) );\n            }\n            else\n            {\n                stringWriter.write( extraComment );\n            }\n            stringWriter.write( EOL );\n        }\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Add in the buffer a default Javadoc for the given class:\n     * <pre>\n     * &#47;&#42;&#42;\n     * &#32;&#42; {<i>Comment based on the class name<\/i>}\n     * &#32;&#42;\n     * &#32;&#42; &#64;param X {<i>added if <code>addMissingParam<\/code><\/i>}\n     * &#32;&#42; &#64;return X {<i>added if <code>addMissingReturn<\/code><\/i>}\n     * &#32;&#42; &#64;throws X {<i>added if <code>addMissingThrows<\/code>}\n     * &#32;&#42; &#64;since X {<i>added if <code>addMissingSince<\/code> and new classes from previous version<\/i>}\n     * &#32;&#42;&#47;\n     * <\/pre>\n     *\n     * @param buffer not null\n     * @param javaMethod not null\n     * @param indent not null\n     * @throws MojoExecutionException if any\n     * @see #getDefaultMethodJavadocComment(JavaMethod)\n     * @see #addDefaultSince(StringBuffer, String)\n     */\n    private void addDefaultMethodComment( final StringWriter stringWriter, final JavaMethod javaMethod,\n                                          final String indent )\n        throws MojoExecutionException\n    {\n        StringBuffer sb = new StringBuffer();\n\n        // special case\n        if ( isInherited( javaMethod ) )\n        {\n            sb.append( indent ).append( INHERITED_JAVADOC );\n            sb.append( EOL );\n\n            stringWriter.write( sb.toString() );\n            return;\n        }\n\n        sb.append( indent ).append( START_JAVADOC );\n        sb.append( EOL );\n        sb.append( indent ).append( SEPARATOR_JAVADOC );\n        sb.append( getDefaultMethodJavadocComment( javaMethod ) );\n        sb.append( EOL );\n\n        boolean addSeparator = false;\n        if ( fixTag( PARAM_TAG ) && javaMethod.getParameters() != null )\n        {\n            for ( int i = 0; i < javaMethod.getParameters().length; i++ )\n            {\n                JavaParameter javaParameter = javaMethod.getParameters()[i];\n\n                if ( !addSeparator )\n                {\n                    addSeparator( sb, indent );\n                    addSeparator = true;\n                }\n\n                sb.append( indent ).append( \" * @\" ).append( PARAM_TAG ).append( \" \" );\n                sb.append( javaParameter.getName() );\n                sb.append( \" \" );\n                sb.append( getDefaultJavadocForType( javaParameter.getType() ) );\n                sb.append( EOL );\n            }\n        }\n        if ( fixTag( RETURN_TAG ) && javaMethod.getReturns() != null && !javaMethod.getReturns().isVoid() )\n        {\n            if ( !addSeparator )\n            {\n                addSeparator( sb, indent );\n                addSeparator = true;\n            }\n            sb.append( indent ).append( \" * @\" ).append( RETURN_TAG ).append( \" \" );\n            sb.append( getDefaultJavadocForType( javaMethod.getReturns() ) );\n            sb.append( EOL );\n        }\n        if ( fixTag( THROWS_TAG ) && javaMethod.getExceptions() != null && javaMethod.getExceptions().length > 0 )\n        {\n            for ( int i = 0; i < javaMethod.getExceptions().length; i++ )\n            {\n                Type exception = javaMethod.getExceptions()[i];\n\n                if ( !addSeparator )\n                {\n                    addSeparator( sb, indent );\n                    addSeparator = true;\n                }\n\n                sb.append( indent ).append( \" * @\" ).append( THROWS_TAG ).append( \" \" );\n                sb.append( exception.getJavaClass().getFullyQualifiedName() );\n                sb.append( \" if any.\" );\n                sb.append( EOL );\n            }\n        }\n        if ( fixTag( SINCE_TAG ) && isNewMethodFromLastRevision( javaMethod ) )\n        {\n            if ( !addSeparator )\n            {\n                addSeparator( sb, indent );\n                addSeparator = true;\n            }\n            addDefaultSince( sb, indent );\n        }\n\n        sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","id":34502,"modified_method":"/**\n     * Add in the buffer a default Javadoc for the given class:\n     * <pre>\n     * &#47;&#42;&#42;\n     * &#32;&#42; {<i>Comment based on the class name<\/i>}\n     * &#32;&#42;\n     * &#32;&#42; &#64;param X {<i>added if <code>addMissingParam<\/code><\/i>}\n     * &#32;&#42; &#64;return X {<i>added if <code>addMissingReturn<\/code><\/i>}\n     * &#32;&#42; &#64;throws X {<i>added if <code>addMissingThrows<\/code>}\n     * &#32;&#42; &#64;since X {<i>added if <code>addMissingSince<\/code> and new classes from previous version<\/i>}\n     * &#32;&#42;&#47;\n     * <\/pre>\n     *\n     * @param buffer not null\n     * @param javaMethod not null\n     * @param indent not null\n     * @throws MojoExecutionException if any\n     * @see #getDefaultMethodJavadocComment(JavaMethod)\n     * @see #appendDefaultSinceTag(StringBuffer, String)\n     */\n    private void addDefaultMethodComment( final StringWriter stringWriter, final JavaMethod javaMethod,\n                                          final String indent )\n        throws MojoExecutionException\n    {\n        StringBuffer sb = new StringBuffer();\n\n        // special case\n        if ( isInherited( javaMethod ) )\n        {\n            sb.append( indent ).append( INHERITED_JAVADOC );\n            sb.append( EOL );\n\n            stringWriter.write( sb.toString() );\n            return;\n        }\n\n        sb.append( indent ).append( START_JAVADOC );\n        sb.append( EOL );\n        sb.append( indent ).append( SEPARATOR_JAVADOC );\n        sb.append( getDefaultMethodJavadocComment( javaMethod ) );\n        sb.append( EOL );\n\n        boolean separatorAdded = false;\n        if ( fixTag( PARAM_TAG ) && javaMethod.getParameters() != null )\n        {\n            for ( int i = 0; i < javaMethod.getParameters().length; i++ )\n            {\n                JavaParameter javaParameter = javaMethod.getParameters()[i];\n\n                separatorAdded = appendDefaultParamTag( sb, indent, separatorAdded, javaParameter );\n            }\n        }\n        if ( fixTag( RETURN_TAG ) && javaMethod.getReturns() != null && !javaMethod.getReturns().isVoid() )\n        {\n            separatorAdded = appendDefaultReturnTag( sb, indent, separatorAdded, javaMethod );\n        }\n        if ( fixTag( THROWS_TAG ) && javaMethod.getExceptions() != null && javaMethod.getExceptions().length > 0 )\n        {\n            for ( int i = 0; i < javaMethod.getExceptions().length; i++ )\n            {\n                Type exception = javaMethod.getExceptions()[i];\n\n                separatorAdded = appendDefaultThrowsTag( sb, indent, separatorAdded, exception );\n            }\n        }\n        if ( fixTag( SINCE_TAG ) && isNewMethodFromLastRevision( javaMethod ) )\n        {\n            separatorAdded = appendDefaultSinceTag( sb, indent, separatorAdded );\n        }\n\n        sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param modifiers list of modifiers (public, private, protected, package)\n     * @return <code>true<\/code> if modifier is align with <code>level<\/code>.\n     */\n    private boolean isInLevel( String[] modifiers )\n    {\n        List modifiersAsList = Arrays.asList( modifiers );\n\n        if ( \"public\".equalsIgnoreCase( level.trim() ) )\n        {\n            if ( modifiersAsList.contains( \"public\" ) )\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        if ( \"protected\".equalsIgnoreCase( level.trim() ) )\n        {\n            if ( modifiersAsList.contains( \"public\" ) || modifiersAsList.contains( \"protected\" ) )\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        if ( \"package\".equalsIgnoreCase( level.trim() ) )\n        {\n            if ( !modifiersAsList.contains( \"private\" ) )\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        // should be private (shows all classes and members)\n        return true;\n    }","id":34503,"modified_method":"/**\n     * @param modifiers list of modifiers (public, private, protected, package)\n     * @return <code>true<\/code> if modifier is align with <code>level<\/code>.\n     */\n    private boolean isInLevel( String[] modifiers )\n    {\n        List modifiersAsList = Arrays.asList( modifiers );\n\n        if ( LEVEL_PUBLIC.equalsIgnoreCase( level.trim() ) )\n        {\n            if ( modifiersAsList.contains( LEVEL_PUBLIC ) )\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        if ( LEVEL_PROTECTED.equalsIgnoreCase( level.trim() ) )\n        {\n            if ( modifiersAsList.contains( LEVEL_PUBLIC ) || modifiersAsList.contains( LEVEL_PROTECTED ) )\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        if ( LEVEL_PACKAGE.equalsIgnoreCase( level.trim() ) )\n        {\n            if ( !modifiersAsList.contains( LEVEL_PRIVATE ) )\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        // should be private (shows all classes and members)\n        return true;\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Init goal parameters.\n     */\n    private void init()\n    {\n        // defaultAuthor\n        if ( StringUtils.isEmpty( defaultAuthor ) )\n        {\n            defaultAuthor = System.getProperty( \"user.name\" );\n        }\n\n        // defaultSince\n        int i = defaultSince.indexOf( \"-SNAPSHOT\" );\n        if ( i != -1 )\n        {\n            defaultSince = defaultSince.substring( 0, i );\n        }\n\n        // fixTags\n        if ( StringUtils.isEmpty( fixTags ) )\n        {\n            // default\n            fixTags = \"all\";\n        }\n        if ( !fixTags.trim().equals( \"all\" ) )\n        {\n            String[] split = StringUtils.split( fixTags, \",\" );\n            List filtered = new LinkedList();\n            for ( int j = 0; j < split.length; j++ )\n            {\n                String s = split[j];\n                if ( !( s.equals( \"all\" ) || s.equals( AUTHOR_TAG ) || s.equals( VERSION_TAG )\n                    || s.equals( SINCE_TAG ) || s.equals( PARAM_TAG ) || s.equals( RETURN_TAG ) || s\n                                                                                                    .equals( THROWS_TAG ) ) )\n                {\n                    if ( getLog().isWarnEnabled() )\n                    {\n                        getLog().warn( \"Unrecognized '\" + s + \"' for fixTags parameter. Ignored it!\" );\n                    }\n                }\n                else\n                {\n                    filtered.add( s );\n                }\n            }\n            fixTags = StringUtils.join( filtered.iterator(), \",\" );\n        }\n        fixTagsSplitted = StringUtils.split( fixTags, \",\" );\n\n        // encoding\n        if ( StringUtils.isEmpty( encoding ) )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn(\n                               \"File encoding has not been set, using platform encoding \"\n                                   + ReaderFactory.FILE_ENCODING + \", i.e. build is platform dependent!\" );\n            }\n            encoding = ReaderFactory.FILE_ENCODING;\n        }\n\n        // level\n        if ( !( \"public\".equalsIgnoreCase( level.trim() ) || \"protected\".equalsIgnoreCase( level.trim() )\n            || \"package\".equalsIgnoreCase( level.trim() ) || \"private\".equalsIgnoreCase( level.trim() ) ) )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn( \"Unrecognized '\" + level + \"' for level parameter, using 'protected' level.\" );\n                level = \"protected\";\n            }\n        }\n    }","id":34504,"modified_method":"/**\n     * Init goal parameters.\n     */\n    private void init()\n    {\n        // defaultAuthor\n        if ( StringUtils.isEmpty( defaultAuthor ) )\n        {\n            defaultAuthor = System.getProperty( \"user.name\" );\n        }\n\n        // defaultSince\n        int i = defaultSince.indexOf( \"-\" + Artifact.SNAPSHOT_VERSION );\n        if ( i != -1 )\n        {\n            defaultSince = defaultSince.substring( 0, i );\n        }\n\n        // fixTags\n        if ( !FIX_TAGS_ALL.equalsIgnoreCase( fixTags.trim() ) )\n        {\n            String[] split = StringUtils.split( fixTags, \",\" );\n            List filtered = new LinkedList();\n            for ( int j = 0; j < split.length; j++ )\n            {\n                String s = split[j].trim();\n                if ( FIX_TAGS_ALL.equalsIgnoreCase( s.trim() ) || AUTHOR_TAG.equalsIgnoreCase( s.trim() )\n                    || VERSION_TAG.equalsIgnoreCase( s.trim() ) || SINCE_TAG.equalsIgnoreCase( s.trim() )\n                    || PARAM_TAG.equalsIgnoreCase( s.trim() ) || RETURN_TAG.equalsIgnoreCase( s.trim() )\n                    || THROWS_TAG.equalsIgnoreCase( s.trim() ) )\n                {\n                    filtered.add( s );\n                }\n                else\n                {\n                    if ( getLog().isWarnEnabled() )\n                    {\n                        getLog().warn( \"Unrecognized '\" + s + \"' for fixTags parameter. Ignored it!\" );\n                    }\n                }\n            }\n            fixTags = StringUtils.join( filtered.iterator(), \",\" );\n        }\n        fixTagsSplitted = StringUtils.split( fixTags, \",\" );\n\n        // encoding\n        if ( StringUtils.isEmpty( encoding ) )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn(\n                               \"File encoding has not been set, using platform encoding \"\n                                   + ReaderFactory.FILE_ENCODING + \", i.e. build is platform dependent!\" );\n            }\n            encoding = ReaderFactory.FILE_ENCODING;\n        }\n\n        // level\n        if ( !( LEVEL_PUBLIC.equalsIgnoreCase( level.trim() ) || LEVEL_PROTECTED.equalsIgnoreCase( level.trim() )\n            || LEVEL_PACKAGE.equalsIgnoreCase( level.trim() ) || LEVEL_PRIVATE.equalsIgnoreCase( level.trim() ) ) )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn( \"Unrecognized '\" + level + \"' for level parameter, using 'protected' level.\" );\n                level = \"protected\";\n            }\n        }\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Calling Clirr to find API differences via clirr-maven-plugin.\n     *\n     * @throws MojoExecutionException if any\n     */\n    private void executeClirr()\n        throws MojoExecutionException\n    {\n        if ( ignoreClirr )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Clirr is ignored.\" );\n            }\n            return;\n        }\n\n        ClirrMojoWrapper wrapper = null;\n        try\n        {\n            wrapper =\n                new ClirrMojoWrapper( getClassesDirectory(), comparisonVersion, getArtifactType( project ),\n                                      artifactFactory, localRepository, mavenProjectBuilder,\n                                      artifactMetadataSource, project, artifactResolver, includes, excludes );\n\n            wrapper.execute();\n        }\n        catch ( Exception e )\n        {\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().error( \"Error when executing Clirr: \" + e.getMessage(), e );\n            }\n            else\n            {\n                getLog().error( \"Error when executing Clirr: \" + e.getMessage() );\n            }\n            getLog().error( \"Clirr is ignored\" );\n            return;\n        }\n\n        clirrNewClasses = wrapper.getNewClasses();\n        clirrNewMethods = wrapper.getNewMethods();\n\n        if ( getLog().isInfoEnabled() )\n        {\n            if ( clirrNewClasses.isEmpty() && clirrNewMethods.isEmpty() )\n            {\n                getLog().info( \"Clirr NOT found API differences.\" );\n            }\n            else\n            {\n                getLog().info( \"Clirr found API differences, i.e. new classes or new methods.\" );\n                writeClirr();\n            }\n        }\n    }","id":34505,"modified_method":"/**\n     * Calling Clirr to find API differences via clirr-maven-plugin.\n     *\n     * @throws MojoExecutionException if any\n     */\n    private void executeClirr()\n        throws MojoExecutionException\n    {\n        if ( ignoreClirr )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Clirr is ignored.\" );\n            }\n            return;\n        }\n\n        ClirrMojoWrapper wrapper = null;\n        try\n        {\n            wrapper =\n                new ClirrMojoWrapper( getClassesDirectory(), comparisonVersion, getArtifactType( project ),\n                                      artifactFactory, localRepository, mavenProjectBuilder,\n                                      artifactMetadataSource, project, artifactResolver, includes, excludes );\n\n            wrapper.execute();\n        }\n        catch ( Exception e )\n        {\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().error( \"Error when executing Clirr: \" + e.getMessage(), e );\n            }\n            else\n            {\n                getLog().error( \"Error when executing Clirr: \" + e.getMessage() );\n            }\n            getLog().error( \"Clirr is ignored due to the error above.\" );\n            return;\n        }\n\n        clirrNewClasses = wrapper.getNewClasses();\n        clirrNewMethods = wrapper.getNewMethods();\n\n        if ( getLog().isInfoEnabled() )\n        {\n            if ( clirrNewClasses.isEmpty() && clirrNewMethods.isEmpty() )\n            {\n                getLog().info( \"Clirr NOT found API differences.\" );\n            }\n            else\n            {\n                getLog().info( \"Clirr found API differences, i.e. new classes/interfaces or methods.\" );\n                try\n                {\n                    writeClirr();\n                }\n                catch ( IOException e )\n                {\n                    if ( getLog().isDebugEnabled() )\n                    {\n                        getLog().error( \"IOException: \" + e.getMessage(), e );\n                    }\n                    else\n                    {\n                        getLog().error( \"IOException: \" + e.getMessage() );\n                    }\n                }\n            }\n        }\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Add a default Javadoc for the given field, i.e.:\n     * <pre>\n     * &#47;&#42;&#42; Field name &#42;&#47;\n     * <\/pre>\n     *\n     * @param stringWriter not null\n     * @param field not null\n     * @param indent not null\n     * @throws IOException if any\n     */\n    private void addDefaultFieldComment( final StringWriter stringWriter, final JavaField field,\n                                         final String indent )\n        throws IOException\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( indent ).append( START_JAVADOC ).append( \" \" );\n        sb.append( \"Constant <code>\" ).append( field.getName() );\n\n        if ( StringUtils.isNotEmpty( field.getInitializationExpression() ) )\n        {\n            String qualifiedName = field.getType().getJavaClass().getFullyQualifiedName();\n\n            if ( qualifiedName.equals( Byte.TYPE.toString() ) || qualifiedName.equals( Short.TYPE.toString() )\n                || qualifiedName.equals( Integer.TYPE.toString() ) || qualifiedName.equals( Long.TYPE.toString() )\n                || qualifiedName.equals( Float.TYPE.toString() ) || qualifiedName.equals( Double.TYPE.toString() )\n                || qualifiedName.equals( Boolean.TYPE.toString() )\n                || qualifiedName.equals( Character.TYPE.toString() ) )\n            {\n                sb.append( \"=\" );\n                sb.append( field.getInitializationExpression().trim() );\n            }\n\n            if ( qualifiedName.equals( \"java.lang.String\" ) )\n            {\n                StringBuffer value = new StringBuffer();\n                String[] lines = getLines( field.getInitializationExpression() );\n                for ( int i = 0; i < lines.length; i++ )\n                {\n                    String line = lines[i];\n\n                    StringTokenizer token = new StringTokenizer( line.trim(), \"\\\"\\n\\r\" );\n\n                    while ( token.hasMoreTokens() )\n                    {\n                        String s = token.nextToken();\n\n                        if ( s.trim().equals( \"+\" ) )\n                        {\n                            continue;\n                        }\n                        if ( s.trim().endsWith( \"\\\\\" ) )\n                        {\n                            s += \"\\\"\";\n                        }\n                        value.append( s );\n                    }\n                }\n\n                sb.append( \"=\\\"\" );\n                // reduce the size\n                if ( value.length() < 40 )\n                {\n                    sb.append( value.toString() ).append( \"\\\"\" );\n                }\n                else\n                {\n                    sb.append( value.toString().substring( 0, 39 ) ).append( \"\\\"{trunked}\" );\n                }\n            }\n        }\n\n        sb.append( \"<\/code> \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","id":34506,"modified_method":"/**\n     * Add a default Javadoc for the given field, i.e.:\n     * <pre>\n     * &#47;&#42;&#42; Constant &lt;code&gt;Field name&lt;/code&gt; &#42;&#47;\n     * <\/pre>\n     *\n     * @param stringWriter not null\n     * @param field not null\n     * @param indent not null\n     * @throws IOException if any\n     */\n    private void addDefaultFieldComment( final StringWriter stringWriter, final JavaField field,\n                                         final String indent )\n        throws IOException\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( indent ).append( START_JAVADOC ).append( \" \" );\n        sb.append( \"Constant <code>\" ).append( field.getName() );\n\n        if ( StringUtils.isNotEmpty( field.getInitializationExpression() ) )\n        {\n            String qualifiedName = field.getType().getJavaClass().getFullyQualifiedName();\n\n            if ( qualifiedName.equals( Byte.TYPE.toString() ) || qualifiedName.equals( Short.TYPE.toString() )\n                || qualifiedName.equals( Integer.TYPE.toString() ) || qualifiedName.equals( Long.TYPE.toString() )\n                || qualifiedName.equals( Float.TYPE.toString() ) || qualifiedName.equals( Double.TYPE.toString() )\n                || qualifiedName.equals( Boolean.TYPE.toString() )\n                || qualifiedName.equals( Character.TYPE.toString() ) )\n            {\n                sb.append( \"=\" );\n                // QDOX-155 for char\n                sb.append( field.getInitializationExpression().trim() );\n            }\n\n            if ( qualifiedName.equals( String.class.getName() ) )\n            {\n                StringBuffer value = new StringBuffer();\n                String[] lines = getLines( field.getInitializationExpression() );\n                for ( int i = 0; i < lines.length; i++ )\n                {\n                    String line = lines[i];\n\n                    StringTokenizer token = new StringTokenizer( line.trim(), \"\\\"\\n\\r\" );\n\n                    while ( token.hasMoreTokens() )\n                    {\n                        String s = token.nextToken();\n\n                        if ( s.trim().equals( \"+\" ) )\n                        {\n                            continue;\n                        }\n                        if ( s.trim().endsWith( \"\\\\\" ) )\n                        {\n                            s += \"\\\"\";\n                        }\n                        value.append( s );\n                    }\n                }\n\n                sb.append( \"=\\\"\" );\n                // reduce the size\n                if ( value.length() < 40 )\n                {\n                    sb.append( value.toString() ).append( \"\\\"\" );\n                }\n                else\n                {\n                    sb.append( value.toString().substring( 0, 39 ) ).append( \"\\\"{trunked}\" );\n                }\n            }\n        }\n\n        sb.append( \"<\/code> \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param sb not null\n     * @param entity not null\n     * @param indent not null\n     * @throws MojoExecutionException if any\n     */\n    private void addDefaultJavadocTags( final StringBuffer sb, final AbstractInheritableJavaEntity entity,\n                                        final String indent )\n        throws MojoExecutionException\n    {\n        boolean isJavaMethod = false;\n        if ( entity instanceof JavaMethod )\n        {\n            isJavaMethod = true;\n        }\n        boolean addSeparator = false;\n        if ( isJavaMethod )\n        {\n            JavaMethod javaMethod = (JavaMethod) entity;\n\n            if ( fixTag( PARAM_TAG ) && javaMethod.getParameters() != null )\n            {\n                for ( int i = 0; i < javaMethod.getParameters().length; i++ )\n                {\n                    JavaParameter javaParameter = javaMethod.getParameters()[i];\n\n                    if ( !addSeparator )\n                    {\n                        addSeparator( sb, indent );\n                        addSeparator = true;\n                    }\n\n                    sb.append( indent ).append( \" * @\" ).append( PARAM_TAG ).append( \" \" );\n                    sb.append( javaParameter.getName() );\n                    sb.append( \" \" );\n                    sb.append( getDefaultJavadocForType( javaParameter.getType() ) );\n                    sb.append( EOL );\n                }\n            }\n\n            if ( fixTag( RETURN_TAG ) )\n            {\n                if ( javaMethod.getReturns() != null && !javaMethod.getReturns().isVoid() )\n                {\n                    if ( !addSeparator )\n                    {\n                        addSeparator( sb, indent );\n                        addSeparator = true;\n                    }\n\n                    sb.append( indent ).append( \" * @\" ).append( RETURN_TAG ).append( \" \" );\n                    sb.append( getDefaultJavadocForType( javaMethod.getReturns() ) );\n                    sb.append( EOL );\n                }\n            }\n\n            if ( fixTag( THROWS_TAG ) && javaMethod.getExceptions() != null )\n            {\n                for ( int i = 0; i < javaMethod.getExceptions().length; i++ )\n                {\n                    Type exception = javaMethod.getExceptions()[i];\n\n                    if ( !addSeparator )\n                    {\n                        addSeparator( sb, indent );\n                        addSeparator = true;\n                    }\n\n                    sb.append( indent ).append( \" * @\" ).append( THROWS_TAG ).append( \" \" );\n                    sb.append( getDefaultJavadocForType( exception ) );\n                    sb.append( \" if any\" );\n                    sb.append( EOL );\n                }\n            }\n        }\n\n        if ( !isJavaMethod )\n        {\n            if ( fixTag( AUTHOR_TAG ) )\n            {\n                if ( !addSeparator )\n                {\n                    addSeparator( sb, indent );\n                    addSeparator = true;\n                }\n\n                addDefaultAuthor( sb, indent );\n            }\n            if ( fixTag( VERSION_TAG ) )\n            {\n                if ( !addSeparator )\n                {\n                    addSeparator( sb, indent );\n                    addSeparator = true;\n                }\n\n                addDefaultVersion( sb, indent );\n            }\n        }\n\n        if ( fixTag( SINCE_TAG ) )\n        {\n            if ( !isJavaMethod )\n            {\n                JavaClass javaClass = (JavaClass) entity;\n\n                if ( !ignoreClirr )\n                {\n                    if ( isNewClassFromLastVersion( javaClass ) )\n                    {\n                        if ( !addSeparator )\n                        {\n                            addSeparator( sb, indent );\n                            addSeparator = true;\n                        }\n\n                        addDefaultSince( sb, indent );\n                    }\n                }\n                else\n                {\n                    if ( !addSeparator )\n                    {\n                        addSeparator( sb, indent );\n                        addSeparator = true;\n                    }\n\n                    addDefaultSince( sb, indent );\n                    addSinceClasses( javaClass );\n                }\n            }\n            else\n            {\n                JavaMethod javaMethod = (JavaMethod) entity;\n\n                if ( !ignoreClirr )\n                {\n                    if ( isNewMethodFromLastRevision( javaMethod ) )\n                    {\n                        if ( !addSeparator )\n                        {\n                            addSeparator( sb, indent );\n                            addSeparator = true;\n                        }\n\n                        addDefaultSince( sb, indent );\n                    }\n                }\n                else\n                {\n                    if ( sinceClasses != null && !sinceClassesContains( javaMethod.getParentClass() ) )\n                    {\n                        if ( !addSeparator )\n                        {\n                            addSeparator( sb, indent );\n                            addSeparator = true;\n                        }\n\n                        addDefaultSince( sb, indent );\n                    }\n                }\n            }\n        }\n    }","id":34507,"modified_method":"/**\n     * @param sb not null\n     * @param entity not null\n     * @param indent not null\n     * @param isJavaMethod\n     * @throws MojoExecutionException if any\n     */\n    private void addDefaultJavadocTags( final StringBuffer sb, final AbstractInheritableJavaEntity entity,\n                                        final String indent, final boolean isJavaMethod )\n        throws MojoExecutionException\n    {\n        boolean separatorAdded = false;\n        if ( isJavaMethod )\n        {\n            JavaMethod javaMethod = (JavaMethod) entity;\n\n            if ( fixTag( PARAM_TAG ) && javaMethod.getParameters() != null )\n            {\n                for ( int i = 0; i < javaMethod.getParameters().length; i++ )\n                {\n                    JavaParameter javaParameter = javaMethod.getParameters()[i];\n\n                    separatorAdded = appendDefaultParamTag( sb, indent, separatorAdded, javaParameter );\n                }\n            }\n\n            if ( fixTag( RETURN_TAG ) )\n            {\n                if ( javaMethod.getReturns() != null && !javaMethod.getReturns().isVoid() )\n                {\n                    separatorAdded = appendDefaultReturnTag( sb, indent, separatorAdded, javaMethod );\n                }\n            }\n\n            if ( fixTag( THROWS_TAG ) && javaMethod.getExceptions() != null )\n            {\n                for ( int i = 0; i < javaMethod.getExceptions().length; i++ )\n                {\n                    Type exception = javaMethod.getExceptions()[i];\n\n                    separatorAdded = appendDefaultThrowsTag( sb, indent, separatorAdded, exception );\n                }\n            }\n        }\n        else\n        {\n            separatorAdded = appendDefaultAuthorTag( sb, indent, separatorAdded );\n\n            separatorAdded = appendDefaultVersionTag( sb, indent, separatorAdded );\n        }\n\n        if ( fixTag( SINCE_TAG ) )\n        {\n            if ( !isJavaMethod )\n            {\n                JavaClass javaClass = (JavaClass) entity;\n\n                if ( !ignoreClirr )\n                {\n                    if ( isNewClassFromLastVersion( javaClass ) )\n                    {\n                        separatorAdded = appendDefaultSinceTag( sb, indent, separatorAdded );\n                    }\n                }\n                else\n                {\n                    separatorAdded = appendDefaultSinceTag( sb, indent, separatorAdded );\n\n                    addSinceClasses( javaClass );\n                }\n            }\n            else\n            {\n                JavaMethod javaMethod = (JavaMethod) entity;\n\n                if ( !ignoreClirr )\n                {\n                    if ( isNewMethodFromLastRevision( javaMethod ) )\n                    {\n                        separatorAdded = appendDefaultSinceTag( sb, indent, separatorAdded );\n                    }\n                }\n                else\n                {\n                    if ( sinceClasses != null && !sinceClassesContains( javaMethod.getParentClass() ) )\n                    {\n                        separatorAdded = appendDefaultSinceTag( sb, indent, separatorAdded );\n                    }\n                }\n            }\n        }\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param sb not null\n     * @param entity not null\n     * @param indent not null\n     */\n    private void addDefaultJavadocComment( final StringBuffer sb, final AbstractInheritableJavaEntity entity,\n                                           final String indent )\n    {\n        sb.append( indent ).append( SEPARATOR_JAVADOC );\n        if ( entity instanceof JavaMethod )\n        {\n            sb.append( getDefaultMethodJavadocComment( (JavaMethod) entity ) );\n        }\n        else\n        {\n            sb.append( getDefaultClassJavadocComment( (JavaClass) entity ) );\n        }\n        sb.append( EOL );\n    }","id":34508,"modified_method":"/**\n     * @param sb not null\n     * @param entity not null\n     * @param indent not null\n     * @param isJavaMethod\n     */\n    private void addDefaultJavadocComment( final StringBuffer sb, final AbstractInheritableJavaEntity entity,\n                                           final String indent, final boolean isJavaMethod )\n    {\n        sb.append( indent ).append( SEPARATOR_JAVADOC );\n        if ( isJavaMethod )\n        {\n            sb.append( getDefaultMethodJavadocComment( (JavaMethod) entity ) );\n        }\n        else\n        {\n            sb.append( getDefaultClassJavadocComment( (JavaClass) entity ) );\n        }\n        sb.append( EOL );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param stringWriter not null\n     * @param originalContent not null\n     * @param entity not null\n     * @param indent not null\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     */\n    private void updateJavadocComment( final StringWriter stringWriter, final String originalContent,\n                                       final AbstractInheritableJavaEntity entity, final String indent )\n        throws MojoExecutionException, IOException\n    {\n        if ( entity.getComment() == null && ( entity.getTags() == null || entity.getTags().length == 0 ) )\n        {\n            return;\n        }\n\n        StringBuffer sb = new StringBuffer();\n\n        // special case for inherited method\n        if ( entity instanceof JavaMethod )\n        {\n            JavaMethod javaMethod = (JavaMethod) entity;\n\n            if ( isInherited( javaMethod ) )\n            {\n                if ( StringUtils.isEmpty( javaMethod.getComment() ) )\n                {\n                    sb.append( indent ).append( INHERITED_JAVADOC );\n                    sb.append( EOL );\n                    sb.append( EOL );\n                    stringWriter.write( sb.toString() );\n                    return;\n                }\n\n                String javadoc = getJavadocComment( originalContent, javaMethod );\n                if ( StringUtils.removeDuplicateWhitespace( javadoc.trim() ).equals( INHERITED_JAVADOC ) )\n                {\n                    sb.append( indent ).append( INHERITED_JAVADOC );\n                    sb.append( EOL );\n                    stringWriter.write( sb.toString() );\n                    return;\n                }\n\n                javadoc = removeLastEmptyJavadocLines( javadoc );\n                if ( javadoc.indexOf( START_JAVADOC ) != -1 )\n                {\n                    javadoc = javadoc.substring( javadoc.indexOf( START_JAVADOC ) + START_JAVADOC.length() );\n                }\n                if ( javadoc.indexOf( END_JAVADOC ) != -1 )\n                {\n                    javadoc = javadoc.substring( 0, javadoc.indexOf( END_JAVADOC ) );\n                }\n\n                if ( javadoc.trim().equals( INHERITED_TAG )\n                    && ( javaMethod.getTags() == null || javaMethod.getTags().length == 0 ) )\n                {\n                    sb.append( indent ).append( START_JAVADOC ).append( javadoc ).append( END_JAVADOC );\n                    sb.append( EOL );\n                }\n                else\n                {\n                    sb.append( indent ).append( START_JAVADOC );\n                    sb.append( EOL );\n                    if ( javadoc.indexOf( INHERITED_TAG ) == -1 )\n                    {\n                        sb.append( indent ).append( SEPARATOR_JAVADOC ).append( INHERITED_TAG );\n                        sb.append( EOL );\n                        addSeparator( sb, indent );\n                    }\n                    String leftTrimmed = trimLeft( javadoc );\n                    if ( leftTrimmed.startsWith( \"* \" ) )\n                    {\n                        sb.append( indent ).append( \" \" ).append( leftTrimmed );\n                    }\n                    else\n                    {\n                        sb.append( indent ).append( SEPARATOR_JAVADOC ).append( leftTrimmed );\n                    }\n                    sb.append( EOL );\n                    if ( javaMethod.getTags() != null )\n                    {\n                        for ( int i = 0; i < javaMethod.getTags().length; i++ )\n                        {\n                            DocletTag docletTag = javaMethod.getTags()[i];\n\n                            // volontary ignore these tags\n                            if ( docletTag.getName().equals( PARAM_TAG )\n                                || docletTag.getName().equals( RETURN_TAG )\n                                || docletTag.getName().equals( THROWS_TAG ) )\n                            {\n                                continue;\n                            }\n\n                            String s = getJavadocComment( originalContent, entity, docletTag );\n                            sb.append( trimRight( s ) );\n                            sb.append( EOL );\n                        }\n                    }\n                    sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n                    sb.append( EOL );\n                }\n\n                stringWriter.write( sb.toString() );\n                return;\n            }\n        }\n\n        sb.append( indent ).append( START_JAVADOC );\n        sb.append( EOL );\n\n        // comment\n        if ( StringUtils.isNotEmpty( entity.getComment() ) )\n        {\n            updateJavadocComment( sb, originalContent, entity, indent );\n        }\n        else\n        {\n            addDefaultJavadocComment( sb, entity, indent );\n        }\n\n        // tags\n        if ( entity.getTags() != null && entity.getTags().length > 0 )\n        {\n            updateJavadocTags( sb, originalContent, entity, indent );\n        }\n        else\n        {\n            addDefaultJavadocTags( sb, entity, indent );\n        }\n\n        sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","id":34509,"modified_method":"/**\n     * @param stringWriter not null\n     * @param originalContent not null\n     * @param entity not null\n     * @param indent not null\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     */\n    private void updateJavadocComment( final StringWriter stringWriter, final String originalContent,\n                                       final AbstractInheritableJavaEntity entity, final String indent )\n        throws MojoExecutionException, IOException\n    {\n        if ( entity.getComment() == null && ( entity.getTags() == null || entity.getTags().length == 0 ) )\n        {\n            return;\n        }\n\n        boolean isJavaMethod = false;\n        if ( entity instanceof JavaMethod )\n        {\n            isJavaMethod = true;\n        }\n\n        StringBuffer sb = new StringBuffer();\n\n        // special case for inherited method\n        if ( isJavaMethod )\n        {\n            JavaMethod javaMethod = (JavaMethod) entity;\n\n            if ( isInherited( javaMethod ) )\n            {\n                // QDOX-154 could be empty\n                if ( StringUtils.isEmpty( javaMethod.getComment() ) )\n                {\n                    sb.append( indent ).append( INHERITED_JAVADOC );\n                    sb.append( EOL );\n                    stringWriter.write( sb.toString() );\n                    return;\n                }\n\n                String javadoc = getJavadocComment( originalContent, javaMethod );\n                if ( StringUtils.removeDuplicateWhitespace( javadoc.trim() ).equals( INHERITED_JAVADOC ) )\n                {\n                    sb.append( indent ).append( INHERITED_JAVADOC );\n                    sb.append( EOL );\n                    stringWriter.write( sb.toString() );\n                    return;\n                }\n\n                javadoc = removeLastEmptyJavadocLines( javadoc );\n                if ( javadoc.indexOf( START_JAVADOC ) != -1 )\n                {\n                    javadoc = javadoc.substring( javadoc.indexOf( START_JAVADOC ) + START_JAVADOC.length() );\n                }\n                if ( javadoc.indexOf( END_JAVADOC ) != -1 )\n                {\n                    javadoc = javadoc.substring( 0, javadoc.indexOf( END_JAVADOC ) );\n                }\n                if ( StringUtils.removeDuplicateWhitespace( javadoc.trim() ).equals( \"* \" + INHERITED_TAG )\n                    && ( javaMethod.getTags() == null || javaMethod.getTags().length == 0 ) )\n                {\n                    sb.append( indent ).append( START_JAVADOC ).append( INHERITED_TAG ).append( END_JAVADOC );\n                    sb.append( EOL );\n                }\n                else\n                {\n                    sb.append( indent ).append( START_JAVADOC );\n                    sb.append( EOL );\n                    if ( javadoc.indexOf( INHERITED_TAG ) == -1 )\n                    {\n                        sb.append( indent ).append( SEPARATOR_JAVADOC ).append( INHERITED_TAG );\n                        sb.append( EOL );\n                        appendSeparator( sb, indent );\n                    }\n                    String leftTrimmed = trimLeft( javadoc );\n                    if ( leftTrimmed.startsWith( \"* \" ) )\n                    {\n                        sb.append( indent ).append( \" \" ).append( leftTrimmed );\n                    }\n                    else\n                    {\n                        sb.append( indent ).append( SEPARATOR_JAVADOC ).append( leftTrimmed );\n                    }\n                    sb.append( EOL );\n                    if ( javaMethod.getTags() != null )\n                    {\n                        for ( int i = 0; i < javaMethod.getTags().length; i++ )\n                        {\n                            DocletTag docletTag = javaMethod.getTags()[i];\n\n                            // Voluntary ignore these tags\n                            if ( docletTag.getName().equals( PARAM_TAG )\n                                || docletTag.getName().equals( RETURN_TAG )\n                                || docletTag.getName().equals( THROWS_TAG ) )\n                            {\n                                continue;\n                            }\n\n                            String s = getJavadocComment( originalContent, entity, docletTag );\n                            sb.append( trimRight( s ) );\n                            sb.append( EOL );\n                        }\n                    }\n                    sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n                    sb.append( EOL );\n                }\n\n                stringWriter.write( sb.toString() );\n                return;\n            }\n        }\n\n        sb.append( indent ).append( START_JAVADOC );\n        sb.append( EOL );\n\n        // comment\n        if ( StringUtils.isNotEmpty( entity.getComment() ) )\n        {\n            updateJavadocComment( sb, originalContent, entity, indent );\n        }\n        else\n        {\n            addDefaultJavadocComment( sb, entity, indent, isJavaMethod );\n        }\n\n        // tags\n        if ( entity.getTags() != null && entity.getTags().length > 0 )\n        {\n            updateJavadocTags( sb, originalContent, entity, indent, isJavaMethod );\n        }\n        else\n        {\n            addDefaultJavadocTags( sb, entity, indent, isJavaMethod );\n        }\n\n        sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Take care of getter/setter in the javaMethod.getName()\n     *\n     * @param javaMethod\n     * @return\n     */\n    private static String getDefaultMethodJavadocComment( JavaMethod javaMethod )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        if ( javaMethod.isConstructor() )\n        {\n            sb.append( \"<p>Constructor for \" );\n            sb.append( javaMethod.getName() ).append( \".<\/p>\" );\n            return sb.toString();\n        }\n\n        if ( javaMethod.getName().length() > 3\n            && ( javaMethod.getName().startsWith( \"get\" ) || javaMethod.getName().startsWith( \"set\" ) ) )\n        {\n            String field = StringUtils.lowercaseFirstLetter( javaMethod.getName().substring( 3 ) );\n\n            JavaClass clazz = javaMethod.getParentClass();\n\n            if ( clazz.getFieldByName( field ) == null )\n            {\n                sb.append( \"<p>\" ).append( javaMethod.getName() ).append( \"<\/p>\" );\n                return sb.toString();\n            }\n\n            sb.append( \"<p>\" );\n            if ( javaMethod.getName().startsWith( \"get\" ) )\n            {\n                sb.append( \"Getter \" );\n            }\n            if ( javaMethod.getName().startsWith( \"set\" ) )\n            {\n                sb.append( \"Setter \" );\n            }\n            sb.append( \"for the field <code>\" ).append( field ).append( \"<\/code>.\" );\n            sb.append( \"<\/p>\" );\n\n            return sb.toString();\n        }\n\n        sb.append( \"<p>\" ).append( javaMethod.getName() ).append( \"<\/p>\" );\n\n        return sb.toString();\n    }","id":34510,"modified_method":"/**\n     * Default comment for method with taking care of getter/setter in the javaMethod name.\n     *\n     * @param javaMethod not null\n     * @return a default comment for method.\n     */\n    private static String getDefaultMethodJavadocComment( JavaMethod javaMethod )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        if ( javaMethod.isConstructor() )\n        {\n            sb.append( \"<p>Constructor for \" );\n            sb.append( javaMethod.getName() ).append( \".<\/p>\" );\n            return sb.toString();\n        }\n\n        if ( javaMethod.getName().length() > 3\n            && ( javaMethod.getName().startsWith( \"get\" ) || javaMethod.getName().startsWith( \"set\" ) ) )\n        {\n            String field = StringUtils.lowercaseFirstLetter( javaMethod.getName().substring( 3 ) );\n\n            JavaClass clazz = javaMethod.getParentClass();\n\n            if ( clazz.getFieldByName( field ) == null )\n            {\n                sb.append( \"<p>\" ).append( javaMethod.getName() ).append( \"<\/p>\" );\n                return sb.toString();\n            }\n\n            sb.append( \"<p>\" );\n            if ( javaMethod.getName().startsWith( \"get\" ) )\n            {\n                sb.append( \"Getter \" );\n            }\n            if ( javaMethod.getName().startsWith( \"set\" ) )\n            {\n                sb.append( \"Setter \" );\n            }\n            sb.append( \"for the field <code>\" ).append( field ).append( \"<\/code>.\" );\n            sb.append( \"<\/p>\" );\n\n            return sb.toString();\n        }\n\n        sb.append( \"<p>\" ).append( javaMethod.getName() ).append( \"<\/p>\" );\n\n        return sb.toString();\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param type\n     * @return\n     */\n    private String getDefaultJavadocForType( Type type )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        if ( type.isPrimitive() )\n        {\n            sb.append( \"a \" );\n            sb.append( type.getJavaClass().getFullyQualifiedName() );\n            sb.append( \".\" );\n        }\n        else if ( type.isArray() )\n        {\n            sb.append( \"an array of \" );\n            sb.append( type.getJavaClass().getFullyQualifiedName() );\n            sb.append( \".\" );\n        }\n        else\n        {\n            try\n            {\n                Class clazz = getClass( type.getJavaClass(), project );\n\n                if ( Exception.class.isAssignableFrom( clazz ) )\n                {\n                    sb.append( type.getJavaClass().getFullyQualifiedName() );\n                }\n                else\n                {\n                    sb.append( \"a {@link \" );\n                    String s = type.getJavaClass().getFullyQualifiedName();\n                    s = StringUtils.replace( s, \"$\", \".\" );\n                    sb.append( s );\n                    sb.append( \"} object.\" );\n                }\n            }\n            catch ( Exception e )\n            {\n                sb.append( type.getJavaClass().getFullyQualifiedName() );\n            }\n        }\n\n        return sb.toString();\n    }","id":34511,"modified_method":"/**\n     * @param type\n     * @return\n     */\n    private String getDefaultJavadocForType( Type type )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        if ( type.isPrimitive() )\n        {\n            if ( type.isArray() )\n            {\n                sb.append( \"an array of \" );\n            }\n            else\n            {\n                sb.append( \"a \" );\n            }\n            sb.append( type.getJavaClass().getFullyQualifiedName() );\n            sb.append( \".\" );\n            return sb.toString();\n        }\n\n        StringBuffer javadocLink = new StringBuffer();\n        try\n        {\n            getClass( type.getJavaClass(), project );\n\n            javadocLink.append( \"{@link \" );\n            String s = type.getJavaClass().getFullyQualifiedName();\n            s = StringUtils.replace( s, \"$\", \".\" );\n            javadocLink.append( s );\n            javadocLink.append( \"}\" );\n        }\n        catch ( Exception e )\n        {\n            javadocLink.append( type.getJavaClass().getFullyQualifiedName() );\n        }\n\n        if ( type.isArray() )\n        {\n            sb.append( \"an array of \" );\n            sb.append( javadocLink.toString() );\n            sb.append( \" objects.\" );\n        }\n        else\n        {\n            sb.append( \"a \" ).append( javadocLink.toString() ).append( \" object.\" );\n        }\n\n        return sb.toString();\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void addDefaultSince( final StringBuffer sb, final String indent )\n    {\n        sb.append( indent ).append( \" * @\" ).append( SINCE_TAG ).append( \" \" );\n        sb.append( defaultSince );\n        sb.append( EOL );\n    }","id":34512,"modified_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void appendDefaultSinceTag( final StringBuffer sb, final String indent )\n    {\n        if ( !fixTag( SINCE_TAG ) )\n        {\n            return;\n        }\n\n        sb.append( indent ).append( \" * @\" ).append( SINCE_TAG ).append( \" \" );\n        sb.append( defaultSince );\n        sb.append( EOL );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void addDefaultVersion( final StringBuffer sb, final String indent )\n    {\n        sb.append( indent ).append( \" * @\" ).append( VERSION_TAG ).append( \" \" );\n        sb.append( defaultVersion );\n        sb.append( EOL );\n    }","id":34513,"modified_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void appendDefaultVersionTag( final StringBuffer sb, final String indent )\n    {\n        if ( !fixTag( VERSION_TAG ) )\n        {\n            return;\n        }\n\n        sb.append( indent ).append( \" * @\" ).append( VERSION_TAG ).append( \" \" );\n        sb.append( defaultVersion );\n        sb.append( EOL );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param tag not null\n     * @return <code>true<\/code> if <code>tag<\/code> is defined in {@link #fixTags}.\n     */\n    private boolean fixTag( String tag )\n    {\n        if ( fixTagsSplitted.length == 1 && fixTagsSplitted[0].equals( \"all\" ) )\n        {\n            return true;\n        }\n\n        for ( int i = 0; i < fixTagsSplitted.length; i++ )\n        {\n            if ( fixTagsSplitted[i].trim().equals( tag ) )\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }","id":34514,"modified_method":"/**\n     * @param tag not null\n     * @return <code>true<\/code> if <code>tag<\/code> is defined in {@link #fixTags}.\n     */\n    private boolean fixTag( String tag )\n    {\n        if ( fixTagsSplitted.length == 1 && fixTagsSplitted[0].equals( FIX_TAGS_ALL ) )\n        {\n            return true;\n        }\n\n        for ( int i = 0; i < fixTagsSplitted.length; i++ )\n        {\n            if ( fixTagsSplitted[i].trim().equals( tag ) )\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Add Javadoc field comment.\n     * Acutally, only for static fields.\n     *\n     * @param stringWriter not null\n     * @param field not null\n     * @param indent not null\n     * @throws IOException if any\n     */\n    private void fixFieldComment( final StringWriter stringWriter, final JavaField field, final String indent )\n        throws IOException\n    {\n        if ( !fixFieldComment )\n        {\n            return;\n        }\n\n        if ( !isInLevel( field.getModifiers() ) )\n        {\n            return;\n        }\n\n        if ( !field.isStatic() )\n        {\n            return;\n        }\n\n        // add\n        if ( field.getComment() == null )\n        {\n            addDefaultFieldComment( stringWriter, field, indent );\n            return;\n        }\n    }","id":34515,"modified_method":"/**\n     * Add Javadoc field comment, only for static fields or interface fields.\n     *\n     * @param stringWriter not null\n     * @param javaClass not null\n     * @param field not null\n     * @param indent not null\n     * @throws IOException if any\n     */\n    private void fixFieldComment( final StringWriter stringWriter, final JavaClass javaClass,\n                                  final JavaField field, final String indent )\n        throws IOException\n    {\n        if ( !fixFieldComment )\n        {\n            return;\n        }\n\n        if ( !javaClass.isInterface() )\n        {\n            if ( !isInLevel( field.getModifiers() ) )\n            {\n                return;\n            }\n\n            if ( !field.isStatic() )\n            {\n                return;\n            }\n        }\n\n        // add\n        if ( field.getComment() == null )\n        {\n            addDefaultFieldComment( stringWriter, field, indent );\n            return;\n        }\n\n        // no update\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param javaClass\n     * @return\n     */\n    private static String getDefaultClassJavadocComment( JavaClass javaClass )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"<p>\" );\n        if ( Arrays.asList( javaClass.getModifiers() ).contains( \"abstract\" ) )\n        {\n            sb.append( \"Abstract \" );\n        }\n\n        sb.append( javaClass.getName() );\n\n        if ( !javaClass.isInterface() )\n        {\n            sb.append( \" class.\" );\n        }\n        else\n        {\n            sb.append( \" interface.\" );\n        }\n\n        sb.append( \"<\/p>\" );\n\n        return sb.toString();\n    }","id":34516,"modified_method":"/**\n     * Default comment for class.\n     *\n     * @param javaClass not null\n     * @return a default comment for class.\n     */\n    private static String getDefaultClassJavadocComment( JavaClass javaClass )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"<p>\" );\n        if ( Arrays.asList( javaClass.getModifiers() ).contains( \"abstract\" ) )\n        {\n            sb.append( \"Abstract \" );\n        }\n\n        sb.append( javaClass.getName() );\n\n        if ( !javaClass.isInterface() )\n        {\n            sb.append( \" class.\" );\n        }\n        else\n        {\n            sb.append( \" interface.\" );\n        }\n\n        sb.append( \"<\/p>\" );\n\n        return sb.toString();\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Add a default Javadoc for the given class, i.e.:\n     * <pre>\n     * &#47;&#42;&#42;\n     * &#32;&#42; {<i>Comment based on the class name<\/i>}\n     * &#32;&#42;\n     * &#32;&#42; &#64;author X {<i>added if <code>addMissingAuthor<\/code><\/i>}\n     * &#32;&#42; &#64;version X {<i>added if <code>addMissingVersion<\/code><\/i>}\n     * &#32;&#42; &#64;since X {<i>added if <code>addMissingSince<\/code> and new classes from previous version<\/i>}\n     * &#32;&#42;&#47;\n     * <\/pre>\n     *\n     * @param buffer not null\n     * @param javaClass not null\n     * @param indent not null\n     * @see #getDefaultClassJavadocComment(JavaClass)\n     * @see #addDefaultAuthor(StringBuffer, String)\n     * @see #addDefaultSince(StringBuffer, String)\n     * @see #addDefaultVersion(StringBuffer, String)\n     */\n    private void addDefaultClassComment( final StringWriter stringWriter, final JavaClass javaClass,\n                                         final String indent )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( indent ).append( START_JAVADOC );\n        sb.append( EOL );\n        sb.append( indent ).append( SEPARATOR_JAVADOC );\n        sb.append( getDefaultClassJavadocComment( javaClass ) );\n        sb.append( EOL );\n        addSeparator( sb, indent );\n        if ( fixTag( AUTHOR_TAG ) )\n        {\n            addDefaultAuthor( sb, indent );\n        }\n        if ( fixTag( VERSION_TAG ) )\n        {\n            addDefaultVersion( sb, indent );\n        }\n        if ( fixTag( SINCE_TAG ) )\n        {\n            if ( !ignoreClirr )\n            {\n                if ( isNewClassFromLastVersion( javaClass ) )\n                {\n                    addDefaultSince( sb, indent );\n                }\n            }\n            else\n            {\n                addDefaultSince( sb, indent );\n                addSinceClasses( javaClass );\n            }\n        }\n        sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","id":34517,"modified_method":"/**\n     * Add a default Javadoc for the given class, i.e.:\n     * <pre>\n     * &#47;&#42;&#42;\n     * &#32;&#42; {<i>Comment based on the class name<\/i>}\n     * &#32;&#42;\n     * &#32;&#42; &#64;author X {<i>added if <code>addMissingAuthor<\/code><\/i>}\n     * &#32;&#42; &#64;version X {<i>added if <code>addMissingVersion<\/code><\/i>}\n     * &#32;&#42; &#64;since X {<i>added if <code>addMissingSince<\/code> and new classes from previous version<\/i>}\n     * &#32;&#42;&#47;\n     * <\/pre>\n     *\n     * @param buffer not null\n     * @param javaClass not null\n     * @param indent not null\n     * @see #getDefaultClassJavadocComment(JavaClass)\n     * @see #appendDefaultAuthorTag(StringBuffer, String)\n     * @see #appendDefaultSinceTag(StringBuffer, String)\n     * @see #appendDefaultVersionTag(StringBuffer, String)\n     */\n    private void addDefaultClassComment( final StringWriter stringWriter, final JavaClass javaClass,\n                                         final String indent )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( indent ).append( START_JAVADOC );\n        sb.append( EOL );\n        sb.append( indent ).append( SEPARATOR_JAVADOC );\n        sb.append( getDefaultClassJavadocComment( javaClass ) );\n        sb.append( EOL );\n\n        appendSeparator( sb, indent );\n\n        appendDefaultAuthorTag( sb, indent );\n\n        appendDefaultVersionTag( sb, indent );\n\n        if ( fixTag( SINCE_TAG ) )\n        {\n            if ( !ignoreClirr )\n            {\n                if ( isNewClassFromLastVersion( javaClass ) )\n                {\n                    appendDefaultSinceTag( sb, indent );\n                }\n            }\n            else\n            {\n                appendDefaultSinceTag( sb, indent );\n                addSinceClasses( javaClass );\n            }\n        }\n\n        sb.append( indent ).append( \" \" ).append( END_JAVADOC );\n        sb.append( EOL );\n\n        stringWriter.write( sb.toString() );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * In debug mode, write {@link #clirrNewClasses} and {@link #clirrNewMethods} in the file\n     * <code>project.getBuild().getDirectory()/clirr.diff<\/code>\n     */\n    private void writeClirr()\n    {\n        if ( !getLog().isDebugEnabled() )\n        {\n            return;\n        }\n\n        StringBuffer sb = new StringBuffer();\n\n        for ( Iterator it = clirrNewClasses.iterator(); it.hasNext(); )\n        {\n            String newClass = (String) it.next();\n\n            sb.append( \"Added Class \" );\n            sb.append( \"'\" ).append( newClass ).append( \"'\" );\n            sb.append( EOL );\n        }\n        for ( Iterator it = clirrNewMethods.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n\n            sb.append( \"In the Class \" );\n            sb.append( \"'\" ).append( entry.getKey() ).append( \"'\" );\n            sb.append( EOL );\n\n            for ( Iterator it2 = ( (List) entry.getValue() ).iterator(); it2.hasNext(); )\n            {\n                String newMethod = (String) it2.next();\n\n                sb.append( \"\\tAdded Method \" );\n                sb.append( \"'\" ).append( newMethod ).append( \"'\" );\n                if ( it2.hasNext() )\n                {\n                    sb.append( EOL );\n                }\n            }\n            sb.append( EOL );\n        }\n\n        File f = new File( project.getBuild().getDirectory(), \"clirr.diff\" );\n        Writer writer = null;\n        try\n        {\n            writer = WriterFactory.newWriter( f, WriterFactory.UTF_8 );\n            writer.write( sb.toString() );\n        }\n        catch ( IOException e )\n        {\n            if ( getLog().isErrorEnabled() )\n            {\n                getLog().error( \"IOException: \" + e.getMessage() );\n            }\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n        getLog().debug( \"Writing Clirr difference to: \" + f.getAbsolutePath() );\n    }","id":34518,"modified_method":"/**\n     * In debug mode, write {@link #clirrNewClasses} and {@link #clirrNewMethods} in the file\n     * <code>project.getBuild().getDirectory()/clirr.diff<\/code>.\n     * @throws IOException\n     */\n    private void writeClirr()\n        throws IOException\n    {\n        if ( !getLog().isDebugEnabled() )\n        {\n            return;\n        }\n\n        StringBuffer sb = new StringBuffer();\n\n        for ( Iterator it = clirrNewClasses.iterator(); it.hasNext(); )\n        {\n            String newClass = (String) it.next();\n\n            sb.append( \"Added Class \" );\n            sb.append( \"'\" ).append( newClass ).append( \"'\" );\n            sb.append( EOL );\n        }\n\n        for ( Iterator it = clirrNewMethods.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n\n            sb.append( \"In the Class \" );\n            sb.append( \"'\" ).append( entry.getKey() ).append( \"'\" );\n            sb.append( EOL );\n\n            for ( Iterator it2 = ( (List) entry.getValue() ).iterator(); it2.hasNext(); )\n            {\n                String newMethod = (String) it2.next();\n\n                sb.append( \"\\tAdded Method \" );\n                sb.append( \"'\" ).append( newMethod ).append( \"'\" );\n                if ( it2.hasNext() )\n                {\n                    sb.append( EOL );\n                }\n            }\n            sb.append( EOL );\n        }\n\n        File f = new File( project.getBuild().getDirectory(), \"clirr.diff\" );\n        writeFile( f, WriterFactory.UTF_8, sb.toString() );\n\n        getLog().debug( \"Writing Clirr difference to: \" + f.getAbsolutePath() );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void addDefaultAuthor( final StringBuffer sb, final String indent )\n    {\n        sb.append( indent ).append( \" * @\" ).append( AUTHOR_TAG ).append( \" \" );\n        sb.append( defaultAuthor );\n        sb.append( EOL );\n    }","id":34519,"modified_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void appendDefaultAuthorTag( final StringBuffer sb, final String indent )\n    {\n        if ( !fixTag( AUTHOR_TAG ) )\n        {\n            return;\n        }\n\n        sb.append( indent ).append( \" * @\" ).append( AUTHOR_TAG ).append( \" \" );\n        sb.append( defaultAuthor );\n        sb.append( EOL );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( !fixClassComment && !fixFieldComment && !fixMethodComment )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Specified to NOT fix classes, fields and methods. Nothing to do.\" );\n            }\n            return;\n        }\n\n        // add warranty msg\n        if ( !preCheck() )\n        {\n            return;\n        }\n\n        // verify goal params\n        init();\n\n        // run clirr\n        executeClirr();\n\n        // run qdox and processing\n        try\n        {\n            JavaClass[] javaClasses = getQdoxClasses();\n\n            for ( int i = 0; i < javaClasses.length; i++ )\n            {\n                JavaClass javaClass = javaClasses[i];\n\n                processFix( javaClass );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"IOException: \" + e.getMessage(), e );\n        }\n    }","id":34520,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( !fixClassComment && !fixFieldComment && !fixMethodComment )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Specified to NOT fix classes, fields and methods. Nothing to do.\" );\n            }\n            return;\n        }\n\n        // verify goal params\n        init();\n\n        if ( fixTagsSplitted.length == 0 )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"No fix tag specified. Nothing to do.\" );\n            }\n            return;\n        }\n\n        // add warranty msg\n        if ( !preCheck() )\n        {\n            return;\n        }\n\n        // run clirr\n        executeClirr();\n\n        // run qdox and process\n        try\n        {\n            JavaClass[] javaClasses = getQdoxClasses();\n\n            for ( int i = 0; i < javaClasses.length; i++ )\n            {\n                JavaClass javaClass = javaClasses[i];\n\n                processFix( javaClass );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"IOException: \" + e.getMessage(), e );\n        }\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param sb not null\n     * @param originalContent not null\n     * @param entity not null\n     * @param indent not null\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     */\n    private void updateJavadocTags( final StringBuffer sb, final String originalContent,\n                                    final AbstractInheritableJavaEntity entity, final String indent )\n        throws IOException, MojoExecutionException\n    {\n        boolean isJavaMethod = false;\n        if ( entity instanceof JavaMethod )\n        {\n            isJavaMethod = true;\n        }\n\n        addSeparator( sb, indent );\n\n        List tagNames = new LinkedList();\n        List tagParams = new LinkedList();\n        boolean hasTagReturn = false;\n        List tagThrows = new LinkedList();\n\n        for ( int i = 0; i < entity.getTags().length; i++ )\n        {\n            DocletTag docletTag = entity.getTags()[i];\n\n            tagNames.add( docletTag.getName() );\n\n            if ( docletTag.getName().equals( RETURN_TAG ) )\n            {\n                hasTagReturn = true;\n            }\n\n            if ( docletTag.getName().equals( THROWS_TAG ) )\n            {\n                String originalTag = getJavadocComment( originalContent, entity, docletTag );\n                originalTag = removeLastEmptyJavadocLines( originalTag );\n\n                String atThrows = \"@\" + THROWS_TAG;\n                if ( originalTag.indexOf( atThrows ) != -1 )\n                {\n                    StringTokenizer token =\n                        new StringTokenizer( originalTag.substring( originalTag.indexOf( atThrows )\n                            + atThrows.length() ), EOL + \" \" );\n                    if ( token.countTokens() > 0 )\n                    {\n                        tagThrows.add( token.nextToken() );\n                    }\n                }\n            }\n\n            if ( docletTag.getValue().length() > 0 )\n            {\n                String originalTag = getJavadocComment( originalContent, entity, docletTag );\n                originalTag = removeLastEmptyJavadocLines( originalTag );\n                originalTag = trimRight( originalTag );\n\n                String param = null;\n\n                String atParam = \"@\" + PARAM_TAG;\n                if ( docletTag.getName().equals( PARAM_TAG ) && originalTag.indexOf( atParam ) != -1 )\n                {\n                    StringTokenizer token =\n                        new StringTokenizer( originalTag.substring( originalTag.indexOf( atParam )\n                            + atParam.length() ), EOL + \" \" );\n                    if ( token.countTokens() > 0 )\n                    {\n                        param = token.nextToken();\n                        tagParams.add( param );\n                    }\n                }\n\n                if ( isJavaMethod && param != null )\n                {\n                    JavaMethod javaMethod = (JavaMethod) entity;\n\n                    JavaParameter javaParam = javaMethod.getParameterByName( param );\n                    if ( javaParam == null )\n                    {\n                        if ( getLog().isWarnEnabled() )\n                        {\n                            StringBuffer warn = new StringBuffer();\n\n                            warn.append( \"Fixed unknown param '\" ).append( param ).append( \"' defined in \" );\n                            warn.append( javaMethod.getParentClass().getFullyQualifiedName() );\n                            warn.append( \"#\" ).append( javaMethod.getCallSignature() );\n\n                            getLog().warn( warn.toString() );\n                        }\n\n                        if ( sb.toString().endsWith( EOL ) )\n                        {\n                            sb.delete( sb.toString().lastIndexOf( EOL ), sb.toString().length() );\n                        }\n                    }\n                    else\n                    {\n                        sb.append( originalTag );\n                        if ( StringUtils.removeDuplicateWhitespace( originalContent ).indexOf( \"param \" + param ) == -1 )\n                        {\n                            sb.append( \" \" );\n                            sb.append( getDefaultJavadocForType( javaParam.getType() ) );\n                        }\n                    }\n                }\n                else\n                {\n                    if ( isJavaMethod && docletTag.getName().equals( THROWS_TAG ) && tagThrows.size() > 0 )\n                    {\n                        JavaMethod javaMethod = (JavaMethod) entity;\n\n                        if ( javaMethod.getExceptions() != null )\n                        {\n                            for ( int j = 0; j < javaMethod.getExceptions().length; j++ )\n                            {\n                                Type exception = javaMethod.getExceptions()[j];\n\n                                String throwException = tagThrows.get( tagThrows.size() - 1 ).toString();\n                                if ( exception.getValue().endsWith( throwException ) )\n                                {\n                                    originalTag =\n                                        StringUtils.replace( originalTag, throwException, exception.getValue() );\n                                    tagThrows.add( tagThrows.size() - 1, exception.getValue() );\n                                    if ( originalTag.endsWith( exception.getValue() ) )\n                                    {\n                                        originalTag += \" if any\";\n                                    }\n\n                                    break;\n                                }\n                            }\n                        }\n                        if ( !originalTag.trim().startsWith( \"*\" ) )\n                        {\n                            sb.append( indent ).append( \" *\" );\n                        }\n                        sb.append( originalTag );\n                    }\n                    else\n                    {\n                        if ( !originalTag.trim().startsWith( \"*\" ) )\n                        {\n                            sb.append( indent ).append( \" *\" );\n                        }\n                        sb.append( originalTag );\n                    }\n                }\n            }\n            else\n            {\n                if ( docletTag.getName().equals( RETURN_TAG ) )\n                {\n                    if ( isJavaMethod )\n                    {\n                        JavaMethod javaMethod = (JavaMethod) entity;\n\n                        if ( javaMethod.getReturns() != null && !javaMethod.getReturns().isVoid() )\n                        {\n                            sb.append( indent ).append( \" * @\" ).append( RETURN_TAG ).append( \" \" );\n                            sb.append( getDefaultJavadocForType( javaMethod.getReturns() ) );\n                        }\n                    }\n                    else\n                    {\n                        sb.append( indent ).append( \" * @\" );\n                        sb.append( docletTag.getName() );\n                    }\n                }\n                else if ( !docletTag.getName().equals( PARAM_TAG ) )\n                {\n                    sb.append( indent ).append( \" * @\" );\n                    sb.append( docletTag.getName() );\n                }\n            }\n            sb.append( EOL );\n        }\n\n        // add missing tags...\n        if ( isJavaMethod )\n        {\n            JavaMethod javaMethod = (JavaMethod) entity;\n\n            for ( int i = 0; i < javaMethod.getParameters().length; i++ )\n            {\n                JavaParameter param = javaMethod.getParameters()[i];\n\n                if ( !tagParams.contains( param.getName() ) )\n                {\n                    sb.append( indent ).append( \" * @\" ).append( PARAM_TAG ).append( \" \" );\n                    sb.append( param.getName() );\n                    sb.append( \" \" );\n                    sb.append( getDefaultJavadocForType( param.getType() ) );\n                    sb.append( EOL );\n                }\n            }\n\n            if ( !hasTagReturn && javaMethod.getReturns() != null && !javaMethod.getReturns().isVoid() )\n            {\n                sb.append( indent ).append( \" * @\" ).append( RETURN_TAG ).append( \" \" );\n                sb.append( getDefaultJavadocForType( javaMethod.getReturns() ) );\n                sb.append( EOL );\n            }\n\n            if ( javaMethod.getExceptions() != null )\n            {\n                for ( int i = 0; i < javaMethod.getExceptions().length; i++ )\n                {\n                    Type exception = javaMethod.getExceptions()[i];\n\n                    if ( !tagThrows.contains( exception.getValue() ) )\n                    {\n                        sb.append( indent ).append( \" * @\" ).append( THROWS_TAG ).append( \" \" );\n                        sb.append( getDefaultJavadocForType( exception ) );\n                        sb.append( \" if any\" );\n                        sb.append( EOL );\n                    }\n                }\n            }\n        }\n        if ( !isJavaMethod )\n        {\n            if ( fixTag( AUTHOR_TAG ) && !tagNames.contains( AUTHOR_TAG ) )\n            {\n                addDefaultAuthor( sb, indent );\n            }\n            if ( fixTag( VERSION_TAG ) && !tagNames.contains( VERSION_TAG ) )\n            {\n                addDefaultVersion( sb, indent );\n            }\n        }\n        if ( fixTag( SINCE_TAG ) && !tagNames.contains( SINCE_TAG ) )\n        {\n            if ( !isJavaMethod )\n            {\n                if ( !ignoreClirr )\n                {\n                    if ( isNewClassFromLastVersion( (JavaClass) entity ) )\n                    {\n                        addDefaultSince( sb, indent );\n                    }\n                }\n                else\n                {\n                    addDefaultSince( sb, indent );\n                    addSinceClasses( (JavaClass) entity );\n                }\n            }\n            else\n            {\n                if ( !ignoreClirr )\n                {\n                    if ( isNewMethodFromLastRevision( (JavaMethod) entity ) )\n                    {\n                        addDefaultSince( sb, indent );\n                    }\n                }\n                else\n                {\n                    if ( sinceClasses != null && !sinceClassesContains( ( (JavaMethod) entity ).getParentClass() ) )\n                    {\n                        addDefaultSince( sb, indent );\n                    }\n                }\n            }\n        }\n    }","id":34521,"modified_method":"/**\n     * @param sb not null\n     * @param originalContent not null\n     * @param entity not null\n     * @param indent not null\n     * @param isJavaMethod\n     * @throws IOException if any\n     * @throws MojoExecutionException if any\n     */\n    private void updateJavadocTags( final StringBuffer sb, final String originalContent,\n                                    final AbstractInheritableJavaEntity entity, final String indent,\n                                    final boolean isJavaMethod )\n        throws IOException, MojoExecutionException\n    {\n        appendSeparator( sb, indent );\n\n        // parse tags\n        JavaEntityTags javaEntityTags = parseJavadocTags( originalContent, entity, isJavaMethod );\n\n        // update and write tags\n        updateJavadocTags( sb, entity, isJavaMethod, javaEntityTags );\n\n        // add missing tags...\n        addMissingJavadocTags( sb, entity, indent, isJavaMethod, javaEntityTags );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void addSeparator( final StringBuffer sb, final String indent )\n    {\n        sb.append( indent ).append( \" *\" );\n        sb.append( EOL );\n    }","id":34522,"modified_method":"/**\n     * @param sb not null\n     * @param indent not null\n     */\n    private void appendSeparator( final StringBuffer sb, final String indent )\n    {\n        sb.append( indent ).append( \" *\" );\n        sb.append( EOL );\n    }","commit_id":"7bbd19e550fb69d305b7708f6ca60eb01e0a63ad","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        for ( Iterator it = projects.iterator(); it.hasNext(); )\n        {\n            MavenProject project = (MavenProject) it.next();\n\n            getActiveProfileStatement( project, message );\n\n            message.append( \"\\n\\n\" );\n        }\n\n        if ( output != null )\n        {\n            writeFile( message );\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","id":34523,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        for ( Iterator it = projects.iterator(); it.hasNext(); )\n        {\n            MavenProject project = (MavenProject) it.next();\n\n            getActiveProfileStatement( project, message );\n\n            message.append( \"\\n\\n\" );\n        }\n\n        if ( output != null )\n        {\n            StringBuffer sb = new StringBuffer();\n            sb.append( \"Created by: \" + getClass().getName() ).append( \"\\n\" );\n            sb.append( \"Created on: \" + new Date() ).append( \"\\n\" ).append( \"\\n\" );\n            sb.append( message.toString() );\n\n            try\n            {\n                writeFile( output, sb );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write active profiles to output: \" + output, e );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Active profile report written to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","commit_id":"7fdb8f9c0fdce220ab3a1da95a4cd06eebf9a6ef","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method to write the mojo description into the output file\n     *\n     * @param descriptionBuffer contains the description to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeDescription( StringBuffer descriptionBuffer )\n        throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n\n                out = WriterFactory.newPlatformWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n\n                out.flush();\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                IOUtil.close( out );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Wrote descriptions to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( descriptionBuffer.toString() );\n            }\n        }\n    }","id":34524,"modified_method":"/**\n     * Method to write the mojo description into the output file\n     *\n     * @param descriptionBuffer contains the description to be written to the file\n     * @throws MojoExecutionException\n     */\n    private void writeDescription( StringBuffer descriptionBuffer )\n        throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            try\n            {\n                writeFile( output, descriptionBuffer );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description to output: \" + output, e );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Wrote descriptions to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( descriptionBuffer.toString() );\n            }\n        }\n    }","commit_id":"7fdb8f9c0fdce220ab3a1da95a4cd06eebf9a6ef","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        if ( projects.get( 0 ).equals( project ) )\n        {\n            // this is normal in aggregation mode.\n\n            for ( Iterator it = projects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                getEffectivePom( project, message );\n\n                message.append( \"\\n\\n\" );\n            }\n        }\n        else\n        {\n            getEffectivePom( project, message );\n            message.append( \"\\n\\n\" );\n        }\n\n        if ( output != null )\n        {\n            Writer fWriter = null;\n            try\n            {\n                File dir = output.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n\n                fWriter = WriterFactory.newPlatformWriter( output );\n\n                fWriter.write( \"Created by: \" + getClass().getName() + \"\\n\" );\n                fWriter.write( \"Created on: \" + new Date() + \"\\n\\n\" );\n                fWriter.write( message.toString() );\n\n                fWriter.flush();\n\n                if ( getLog().isInfoEnabled() )\n                {\n                    getLog().info( \"Effective-POM written to: \" + output );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-POM to output: \" + output, e );\n            }\n            finally\n            {\n                if ( fWriter != null )\n                {\n                    try\n                    {\n                        fWriter.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        if ( getLog().isDebugEnabled() )\n                        {\n                            getLog().debug( \"Cannot close FileWriter to output location: \" + output, e );\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            StringBuffer formatted = new StringBuffer();\n\n            formatted.append( \"\\nEffective POMs, after inheritance, interpolation, and profiles are applied:\\n\\n\" );\n            formatted.append( message.toString() );\n            formatted.append( \"\\n\" );\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","id":34525,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        if ( projects.get( 0 ).equals( project ) )\n        {\n            // this is normal in aggregation mode.\n\n            for ( Iterator it = projects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                getEffectivePom( project, message );\n\n                message.append( \"\\n\\n\" );\n            }\n        }\n        else\n        {\n            getEffectivePom( project, message );\n            message.append( \"\\n\\n\" );\n        }\n\n        if ( output != null )\n        {\n            StringBuffer sb = new StringBuffer();\n            sb.append( \"Created by: \" + getClass().getName() ).append( \"\\n\" );\n            sb.append( \"Created on: \" + new Date() ).append( \"\\n\" ).append( \"\\n\" );\n            sb.append( message.toString() );\n\n            try\n            {\n                writeFile( output, sb );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-POM to output: \" + output, e );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Effective-POM written to: \" + output );\n            }\n        }\n        else\n        {\n            StringBuffer formatted = new StringBuffer();\n\n            formatted.append( \"\\nEffective POMs, after inheritance, interpolation, and profiles are applied:\\n\\n\" );\n            formatted.append( message.toString() );\n            formatted.append( \"\\n\" );\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","commit_id":"7fdb8f9c0fdce220ab3a1da95a4cd06eebf9a6ef","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringWriter sWriter = new StringWriter();\n\n        SettingsXpp3Writer settingsWriter = new SettingsXpp3Writer();\n\n        try\n        {\n            settingsWriter.write( sWriter, settings );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot serialize Settings to XML.\", e );\n        }\n\n        if ( output != null && output.trim().length() > 0 )\n        {\n            Writer fWriter = null;\n            try\n            {\n                File outFile = new File( output ).getAbsoluteFile();\n\n                File dir = outFile.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n\n                fWriter = WriterFactory.newPlatformWriter( outFile );\n                fWriter.write( sWriter.toString() );\n\n                fWriter.flush();\n\n                if ( getLog().isInfoEnabled() )\n                {\n                    getLog().info( \"Effective-settings written to: \" + output );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-settings to output: \" + output, e );\n            }\n            finally\n            {\n                if ( fWriter != null )\n                {\n                    try\n                    {\n                        fWriter.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        if ( getLog().isDebugEnabled() )\n                        {\n                            getLog().debug( \"Cannot close FileWriter to output location: \" + output, e );\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            StringBuffer message = new StringBuffer();\n\n            message.append( \"\\nEffective settings:\\n\\n\" );\n            message.append( sWriter.toString() );\n            message.append( \"\\n\\n\" );\n\n            getLog().info( message );\n        }\n    }","id":34526,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringWriter sWriter = new StringWriter();\n\n        SettingsXpp3Writer settingsWriter = new SettingsXpp3Writer();\n\n        try\n        {\n            settingsWriter.write( sWriter, settings );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot serialize Settings to XML.\", e );\n        }\n\n        if ( output != null )\n        {\n            try\n            {\n                writeFile( output, sWriter.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write effective-settings to output: \" + output, e );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Effective-settings written to: \" + output );\n            }\n        }\n        else\n        {\n            StringBuffer message = new StringBuffer();\n\n            message.append( \"\\nEffective settings:\\n\\n\" );\n            message.append( sWriter.toString() );\n            message.append( \"\\n\\n\" );\n\n            getLog().info( message );\n        }\n    }","commit_id":"7fdb8f9c0fdce220ab3a1da95a4cd06eebf9a6ef","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        message.append( \"===== Platform Details =====\" ).append( '\\n' );\n        message.append( '\\n' );\n        message.append( \"===== System Properties =====\" ).append( '\\n' );\n\n        Properties systemProperties = System.getProperties();\n        for ( Iterator it = systemProperties.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            message.append( \"\\n\" );\n            message.append( key ).append( \"=\" ).append( systemProperties.get( key ) );\n        }\n\n        message.append( '\\n' ).append( '\\n' );\n        message.append( \"===== Environment Variables =====\" ).append( '\\n' );\n        try\n        {\n            Properties envVars = CommandLineUtils.getSystemEnvVars();\n            for ( Iterator it2 = envVars.keySet().iterator(); it2.hasNext(); )\n            {\n                String key = it2.next().toString();\n                message.append( \"\\n\" );\n                message.append( key ).append( \"=\" ).append( envVars.get( key ) );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn( \"IOException: \" + e.getMessage() );\n            }\n        }\n\n        message.append( \"\\n\" );\n\n        if ( output != null )\n        {\n            writeFile( message );\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","id":34527,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        StringBuffer message = new StringBuffer();\n\n        message.append( \"===== Platform Details =====\" ).append( '\\n' );\n        message.append( '\\n' );\n        message.append( \"===== System Properties =====\" ).append( '\\n' );\n\n        Properties systemProperties = System.getProperties();\n        for ( Iterator it = systemProperties.keySet().iterator(); it.hasNext(); )\n        {\n            String key = it.next().toString();\n            message.append( \"\\n\" );\n            message.append( key ).append( \"=\" ).append( systemProperties.get( key ) );\n        }\n\n        message.append( '\\n' ).append( '\\n' );\n        message.append( \"===== Environment Variables =====\" ).append( '\\n' );\n        try\n        {\n            Properties envVars = CommandLineUtils.getSystemEnvVars();\n            for ( Iterator it2 = envVars.keySet().iterator(); it2.hasNext(); )\n            {\n                String key = it2.next().toString();\n                message.append( \"\\n\" );\n                message.append( key ).append( \"=\" ).append( envVars.get( key ) );\n            }\n        }\n        catch ( IOException e )\n        {\n            if ( getLog().isWarnEnabled() )\n            {\n                getLog().warn( \"IOException: \" + e.getMessage() );\n            }\n        }\n\n        message.append( \"\\n\" );\n\n        if ( output != null )\n        {\n            StringBuffer sb = new StringBuffer();\n            sb.append( \"Created by: \" + getClass().getName() ).append( \"\\n\" );\n            sb.append( \"Created on: \" + new Date() ).append( \"\\n\" ).append( \"\\n\" );\n            sb.append( message.toString() );\n\n            try\n            {\n                writeFile( output, sb );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write system report to output: \" + output, e );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"System report written to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( message );\n            }\n        }\n    }","commit_id":"7fdb8f9c0fdce220ab3a1da95a4cd06eebf9a6ef","url":"https://github.com/apache/maven-plugins"},{"original_method":"public WikiPage updatePage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tString content, String summary, boolean minorEdit, String format,\n\t\t\tString parentTitle, String redirectTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Page\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tWikiPage oldPage = null;\n\n\t\ttry {\n\t\t\toldPage = wikiPagePersistence.findByN_T_First(nodeId, title, null);\n\t\t}\n\t\tcatch (NoSuchPageException nspe) {\n\t\t\treturn addPage(\n\t\t\t\tuserId, nodeId, title, WikiPageConstants.VERSION_DEFAULT,\n\t\t\t\tcontent, summary, minorEdit, format, true, parentTitle,\n\t\t\t\tredirectTitle, serviceContext);\n\t\t}\n\n\t\tlong pageId = 0;\n\n\t\tif (oldPage.isApproved()) {\n\t\t\tpageId = counterLocalService.increment();\n\t\t}\n\t\telse {\n\t\t\tpageId = oldPage.getPageId();\n\t\t}\n\n\t\tcontent = SanitizerUtil.sanitize(\n\t\t\tuser.getCompanyId(), oldPage.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), pageId, \"text/\" + format, content);\n\n\t\tvalidate(nodeId, content, format);\n\n\t\tdouble oldVersion = oldPage.getVersion();\n\n\t\tif ((version > 0) && (version != oldVersion)) {\n\t\t\tthrow new PageVersionException();\n\t\t}\n\n\t\tserviceContext.validateModifiedDate(\n\t\t\toldPage, PageVersionException.class);\n\n\t\tlong resourcePrimKey =\n\t\t\twikiPageResourceLocalService.getPageResourcePrimKey(nodeId, title);\n\t\tlong groupId = oldPage.getGroupId();\n\n\t\tWikiPage page = oldPage;\n\n\t\tdouble newVersion = oldVersion;\n\n\t\tif (oldPage.isApproved()) {\n\t\t\tnewVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\t\tpage = wikiPagePersistence.create(pageId);\n\t\t}\n\n\t\tpage.setResourcePrimKey(resourcePrimKey);\n\t\tpage.setGroupId(groupId);\n\t\tpage.setCompanyId(user.getCompanyId());\n\t\tpage.setUserId(user.getUserId());\n\t\tpage.setUserName(user.getFullName());\n\t\tpage.setCreateDate(serviceContext.getModifiedDate(now));\n\t\tpage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tpage.setNodeId(nodeId);\n\t\tpage.setTitle(title);\n\t\tpage.setVersion(newVersion);\n\t\tpage.setMinorEdit(minorEdit);\n\t\tpage.setContent(content);\n\n\t\tif (oldPage.isPending()) {\n\t\t\tpage.setStatus(oldPage.getStatus());\n\t\t}\n\t\telse {\n\t\t\tpage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tpage.setSummary(summary);\n\t\tpage.setFormat(format);\n\n\t\tif (Validator.isNotNull(parentTitle)) {\n\t\t\tpage.setParentTitle(parentTitle);\n\t\t}\n\n\t\tif (Validator.isNotNull(redirectTitle)) {\n\t\t\tpage.setRedirectTitle(redirectTitle);\n\t\t}\n\n\t\twikiPagePersistence.update(page, false);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = page.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Node\n\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(nodeId);\n\n\t\tnode.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\twikiNodePersistence.update(node, false);\n\n\t\t// Asset\n\n\t\tif (serviceContext.getCommand().equals(Constants.REVERT)) {\n\t\t\tString[] assetTagNames = AssetTagLocalServiceUtil.getTagNames(\n\t\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey());\n\n\t\t\tlong[] assetCategoryIds = AssetCategoryLocalServiceUtil.\n\t\t\t\t\t\tgetCategoryIds(WikiPage.class.getName(),\n\t\t\t\t\t\t\tpage.getResourcePrimKey());\n\n\t\t\tAssetEntry entry = AssetEntryLocalServiceUtil.getEntry(\n\t\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey());\n\n\t\t\tList<AssetLink> assetLinks = AssetLinkLocalServiceUtil.getLinks(\n\t\t\t\tentry.getEntryId());\n\n\t\t\tlong[] assetLinkIds = StringUtil.split(\n\t\t\t\tListUtil.toString(\n\t\t\t\t\tassetLinks, AssetLink.ENTRY_ID2_ACCESSOR), 0L);\n\n\t\t\tupdateAsset(\n\t\t\t\tuserId, page, assetCategoryIds, assetTagNames, assetLinkIds);\n\t\t}\n\t\telse {\n\t\t\tupdateAsset(\n\t\t\t\tuserId, page, serviceContext.getAssetCategoryIds(),\n\t\t\t\tserviceContext.getAssetTagNames(),\n\t\t\t\tserviceContext.getAssetLinkEntryIds());\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), page.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), page.getPageId(), page, serviceContext);\n\n\t\treturn page;\n\t}","id":34528,"modified_method":"public WikiPage updatePage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tString content, String summary, boolean minorEdit, String format,\n\t\t\tString parentTitle, String redirectTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Page\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tWikiPage oldPage = null;\n\n\t\ttry {\n\t\t\toldPage = wikiPagePersistence.findByN_T_First(nodeId, title, null);\n\t\t}\n\t\tcatch (NoSuchPageException nspe) {\n\t\t\treturn addPage(\n\t\t\t\tuserId, nodeId, title, WikiPageConstants.VERSION_DEFAULT,\n\t\t\t\tcontent, summary, minorEdit, format, true, parentTitle,\n\t\t\t\tredirectTitle, serviceContext);\n\t\t}\n\n\t\tlong pageId = 0;\n\n\t\tif (oldPage.isApproved()) {\n\t\t\tpageId = counterLocalService.increment();\n\t\t}\n\t\telse {\n\t\t\tpageId = oldPage.getPageId();\n\t\t}\n\n\t\tcontent = SanitizerUtil.sanitize(\n\t\t\tuser.getCompanyId(), oldPage.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), pageId, \"text/\" + format, content);\n\n\t\tvalidate(nodeId, content, format);\n\n\t\tdouble oldVersion = oldPage.getVersion();\n\n\t\tif ((version > 0) && (version != oldVersion)) {\n\t\t\tthrow new PageVersionException();\n\t\t}\n\n\t\tserviceContext.validateModifiedDate(\n\t\t\toldPage, PageVersionException.class);\n\n\t\tlong resourcePrimKey =\n\t\t\twikiPageResourceLocalService.getPageResourcePrimKey(nodeId, title);\n\t\tlong groupId = oldPage.getGroupId();\n\n\t\tWikiPage page = oldPage;\n\n\t\tdouble newVersion = oldVersion;\n\n\t\tif (oldPage.isApproved()) {\n\t\t\tnewVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\t\tpage = wikiPagePersistence.create(pageId);\n\t\t}\n\n\t\tpage.setResourcePrimKey(resourcePrimKey);\n\t\tpage.setGroupId(groupId);\n\t\tpage.setCompanyId(user.getCompanyId());\n\t\tpage.setUserId(user.getUserId());\n\t\tpage.setUserName(user.getFullName());\n\t\tpage.setCreateDate(serviceContext.getModifiedDate(now));\n\t\tpage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tpage.setNodeId(nodeId);\n\t\tpage.setTitle(title);\n\t\tpage.setVersion(newVersion);\n\t\tpage.setMinorEdit(minorEdit);\n\t\tpage.setContent(content);\n\n\t\tif (oldPage.isPending()) {\n\t\t\tpage.setStatus(oldPage.getStatus());\n\t\t}\n\t\telse {\n\t\t\tpage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tpage.setSummary(summary);\n\t\tpage.setFormat(format);\n\n\t\tif (Validator.isNotNull(parentTitle)) {\n\t\t\tpage.setParentTitle(parentTitle);\n\t\t}\n\n\t\tif (Validator.isNotNull(redirectTitle)) {\n\t\t\tpage.setRedirectTitle(redirectTitle);\n\t\t}\n\n\t\twikiPagePersistence.update(page, false);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = page.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Node\n\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(nodeId);\n\n\t\tnode.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\twikiNodePersistence.update(node, false);\n\n\t\t// Asset\n\n\t\tString cmd = serviceContext.getCommand();\n\n\t\tupdateAsset(\n\t\t\tuserId, page, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), page.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), page.getPageId(), page, serviceContext);\n\n\t\treturn page;\n\t}","commit_id":"27c165db025fd8006cb34028e711ddb4d1afee66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WikiPage revertPage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tWikiPage oldPage = getPage(nodeId, title, version);\n\n\t\treturn updatePage(\n\t\t\tuserId, nodeId, title, 0, oldPage.getContent(),\n\t\t\tWikiPageConstants.REVERTED + \" to \" + version, false,\n\t\t\toldPage.getFormat(), getParentPageTitle(oldPage),\n\t\t\toldPage.getRedirectTitle(), serviceContext);\n\t}","id":34529,"modified_method":"public WikiPage revertPage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tWikiPage oldPage = getPage(nodeId, title, version);\n\n\t\tString[] assetTagNames = assetTagLocalService.getTagNames(\n\t\t\tWikiPage.class.getName(), oldPage.getResourcePrimKey());\n\n\t\tlong[] assetCategoryIds = assetCategoryLocalService.getCategoryIds(\n\t\t\tWikiPage.class.getName(), oldPage.getResourcePrimKey());\n\n\t\tAssetEntry entry = assetEntryLocalService.getEntry(\n\t\t\tWikiPage.class.getName(), oldPage.getResourcePrimKey());\n\n\t\tList<AssetLink> assetLinks = assetLinkLocalService.getLinks(\n\t\t\tentry.getEntryId());\n\n\t\tlong[] assetLinkIds = StringUtil.split(\n\t\t\tListUtil.toString(assetLinks, AssetLink.ENTRY_ID2_ACCESSOR), 0L);\n\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetLinkEntryIds(assetLinkIds);\n\n\t\treturn updatePage(\n\t\t\tuserId, nodeId, title, 0, oldPage.getContent(),\n\t\t\tWikiPageConstants.REVERTED + \" to \" + version, false,\n\t\t\toldPage.getFormat(), getParentPageTitle(oldPage),\n\t\t\toldPage.getRedirectTitle(), serviceContext);\n\t}","commit_id":"27c165db025fd8006cb34028e711ddb4d1afee66","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean hasPermission(\n\t\t\tPermissionChecker permissionChecker, long classPK, String actionId)\n\t\tthrows Exception {\n\n\t\tCalendarBooking calendarBooking =\n\t\t\tCalendarBookingLocalServiceUtil.getCalendarBooking(classPK);\n\n\t\tif (actionId.equals(ActionKeys.UPDATE) ||\n\t\t\tactionId.equals(ActionKeys.DELETE)) {\n\n\t\t\tactionId = ActionKeys.MANAGE_BOOKINGS;\n\t\t}\n\n\t\treturn CalendarPermission.contains(\n\t\t\tpermissionChecker, calendarBooking.getCalendarId(), actionId);\n\t}","id":34530,"modified_method":"@Override\n\tpublic boolean hasPermission(\n\t\t\tPermissionChecker permissionChecker, long classPK, String actionId)\n\t\tthrows Exception {\n\n\t\tCalendarBooking calendarBooking =\n\t\t\tCalendarBookingLocalServiceUtil.getCalendarBooking(classPK);\n\n\t\tif (actionId.equals(ActionKeys.DELETE) ||\n\t\t\tactionId.equals(ActionKeys.UPDATE)) {\n\n\t\t\tactionId = ActionKeys.MANAGE_BOOKINGS;\n\t\t}\n\n\t\treturn CalendarPermission.contains(\n\t\t\tpermissionChecker, calendarBooking.getCalendarId(), actionId);\n\t}","commit_id":"ad4c32d1a27e289b695bddbfd59d50752b448d0d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarBooking addCalendarBooking(\n\t\t\tlong userId, long calendarId, long[] childCalendarIds,\n\t\t\tlong parentCalendarBookingId, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tlong calendarBookingId = counterLocalService.increment();\n\n\t\tCalendarBooking calendarBooking = calendarBookingPersistence.create(\n\t\t\tcalendarBookingId);\n\n\t\tcalendarBooking.setUuid(serviceContext.getUuid());\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setCalendarResourceId(calendar.getCalendarResourceId());\n\n\t\tif (parentCalendarBookingId > 0) {\n\t\t\tcalendarBooking.setParentCalendarBookingId(parentCalendarBookingId);\n\t\t}\n\t\telse {\n\t\t\tcalendarBooking.setParentCalendarBookingId(calendarBookingId);\n\t\t}\n\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\n\t\tint status = CalendarBookingWorkflowConstants.STATUS_PENDING;\n\n\t\tif (parentCalendarBookingId == 0) {\n\t\t\tstatus = CalendarBookingWorkflowConstants.STATUS_APPROVED;\n\t\t}\n\n\t\tcalendarBooking.setStatus(status);\n\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.startWorkflow(\n\t\t\tuserId, calendarBookingId, serviceContext);\n\n\t\t// Asset\n\n\t\tcalendarBooking = fetchCalendarBooking(calendarBookingId);\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\treturn calendarBooking;\n\t}","id":34531,"modified_method":"public CalendarBooking addCalendarBooking(\n\t\t\tlong userId, long calendarId, long[] childCalendarIds,\n\t\t\tlong parentCalendarBookingId, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tlong calendarBookingId = counterLocalService.increment();\n\n\t\tCalendarBooking calendarBooking = calendarBookingPersistence.create(\n\t\t\tcalendarBookingId);\n\n\t\tcalendarBooking.setUuid(serviceContext.getUuid());\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setCalendarResourceId(calendar.getCalendarResourceId());\n\n\t\tif (parentCalendarBookingId > 0) {\n\t\t\tcalendarBooking.setParentCalendarBookingId(parentCalendarBookingId);\n\t\t}\n\t\telse {\n\t\t\tcalendarBooking.setParentCalendarBookingId(calendarBookingId);\n\t\t}\n\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\n\t\tint status = CalendarBookingWorkflowConstants.STATUS_PENDING;\n\n\t\tif (parentCalendarBookingId == 0) {\n\t\t\tstatus = CalendarBookingWorkflowConstants.STATUS_APPROVED;\n\t\t}\n\n\t\tcalendarBooking.setStatus(status);\n\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.startWorkflow(\n\t\t\tuserId, calendarBookingId, serviceContext);\n\n\t\treturn calendarBooking;\n\t}","commit_id":"ad4c32d1a27e289b695bddbfd59d50752b448d0d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarBooking updateCalendarBooking(\n\t\t\tlong userId, long calendarBookingId, long calendarId,\n\t\t\tlong[] childCalendarIds, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendarBooking calendarBooking =\n\t\t\tcalendarBookingPersistence.findByPrimaryKey(calendarBookingId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.invokeTransition(\n\t\t\tuserId, calendarBookingId,\n\t\t\tCalendarBookingWorkflowConstants.toLabel(status), serviceContext);\n\n\t\t// Asset\n\n\t\tcalendarBooking = fetchCalendarBooking(calendarBookingId);\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\treturn calendarBooking;\n\t}","id":34532,"modified_method":"public CalendarBooking updateCalendarBooking(\n\t\t\tlong userId, long calendarBookingId, long calendarId,\n\t\t\tlong[] childCalendarIds, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendarBooking calendarBooking =\n\t\t\tcalendarBookingPersistence.findByPrimaryKey(calendarBookingId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.invokeTransition(\n\t\t\tuserId, calendarBookingId,\n\t\t\tCalendarBookingWorkflowConstants.toLabel(status), serviceContext);\n\n\t\treturn calendarBooking;\n\t}","commit_id":"ad4c32d1a27e289b695bddbfd59d50752b448d0d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private HColumnDescriptor putColumnFamilyXml(Element columnfamily) {\n    Node name_node = columnfamily.getElementsByTagName(\"name\").item(0);\n    String colname = name_node.getFirstChild().getNodeValue();\n    \n    if (colname.indexOf(\":\") == -1) {\n      colname += \":\";\n    }\n    \n    int max_versions = HColumnDescriptor.DEFAULT_VERSIONS;\n    NodeList max_versions_list = columnfamily.getElementsByTagName(\"max-versions\");\n    if (max_versions_list.getLength() > 0) {\n      max_versions = Integer.parseInt(max_versions_list.item(0).getFirstChild().getNodeValue());\n    }\n    CompressionType compression = HColumnDescriptor.DEFAULT_COMPRESSION;\n    NodeList compression_list = columnfamily.getElementsByTagName(\"compression\");\n    if (compression_list.getLength() > 0) {\n      compression = CompressionType.valueOf(compression_list.item(0).getFirstChild().getNodeValue());\n    }\n    boolean in_memory = HColumnDescriptor.DEFAULT_IN_MEMORY;\n    NodeList in_memory_list = columnfamily.getElementsByTagName(\"in-memory\");\n    if (in_memory_list.getLength() > 0) {\n      in_memory = Boolean.valueOf(in_memory_list.item(0).getFirstChild().getNodeValue());\n    }\n    boolean block_cache = HColumnDescriptor.DEFAULT_BLOCKCACHE;\n    NodeList block_cache_list = columnfamily.getElementsByTagName(\"block-cache\");\n    if (block_cache_list.getLength() > 0) {\n      block_cache = Boolean.valueOf(block_cache_list.item(0).getFirstChild().getNodeValue());\n    }\n    int max_cell_size = HColumnDescriptor.DEFAULT_LENGTH;\n    NodeList max_cell_size_list = columnfamily.getElementsByTagName(\"max-cell-size\");\n    if (max_cell_size_list.getLength() > 0) {\n      max_cell_size = Integer.valueOf(max_cell_size_list.item(0).getFirstChild().getNodeValue());\n    }\n    int ttl = HColumnDescriptor.DEFAULT_TTL;\n    NodeList ttl_list = columnfamily.getElementsByTagName(\"time-to-live\");\n    if (ttl_list.getLength() > 0) {\n      ttl = Integer.valueOf(ttl_list.item(0).getFirstChild().getNodeValue());\n    }\n    boolean bloomfilter = HColumnDescriptor.DEFAULT_BLOOMFILTER;\n    NodeList bloomfilter_list = columnfamily.getElementsByTagName(\"bloomfilter\");\n    if (bloomfilter_list.getLength() > 0) {\n      bloomfilter = Boolean.valueOf(bloomfilter_list.item(0).getFirstChild().getNodeValue());\n    }\n    return new HColumnDescriptor(Bytes.toBytes(colname), max_versions, compression, in_memory, block_cache, max_cell_size, ttl, bloomfilter);\n  }","id":34533,"modified_method":"private HColumnDescriptor putColumnFamilyXml(Element columnfamily) {\n    Node name_node = columnfamily.getElementsByTagName(\"name\").item(0);\n    String colname = makeColumnName(name_node.getFirstChild().getNodeValue());\n    \n    int max_versions = HColumnDescriptor.DEFAULT_VERSIONS;\n    NodeList max_versions_list = columnfamily.getElementsByTagName(\"max-versions\");\n    if (max_versions_list.getLength() > 0) {\n      max_versions = Integer.parseInt(max_versions_list.item(0).getFirstChild().getNodeValue());\n    }\n    CompressionType compression = HColumnDescriptor.DEFAULT_COMPRESSION;\n    NodeList compression_list = columnfamily.getElementsByTagName(\"compression\");\n    if (compression_list.getLength() > 0) {\n      compression = CompressionType.valueOf(compression_list.item(0).getFirstChild().getNodeValue());\n    }\n    boolean in_memory = HColumnDescriptor.DEFAULT_IN_MEMORY;\n    NodeList in_memory_list = columnfamily.getElementsByTagName(\"in-memory\");\n    if (in_memory_list.getLength() > 0) {\n      in_memory = Boolean.valueOf(in_memory_list.item(0).getFirstChild().getNodeValue());\n    }\n    boolean block_cache = HColumnDescriptor.DEFAULT_BLOCKCACHE;\n    NodeList block_cache_list = columnfamily.getElementsByTagName(\"block-cache\");\n    if (block_cache_list.getLength() > 0) {\n      block_cache = Boolean.valueOf(block_cache_list.item(0).getFirstChild().getNodeValue());\n    }\n    int max_cell_size = HColumnDescriptor.DEFAULT_LENGTH;\n    NodeList max_cell_size_list = columnfamily.getElementsByTagName(\"max-cell-size\");\n    if (max_cell_size_list.getLength() > 0) {\n      max_cell_size = Integer.valueOf(max_cell_size_list.item(0).getFirstChild().getNodeValue());\n    }\n    int ttl = HColumnDescriptor.DEFAULT_TTL;\n    NodeList ttl_list = columnfamily.getElementsByTagName(\"time-to-live\");\n    if (ttl_list.getLength() > 0) {\n      ttl = Integer.valueOf(ttl_list.item(0).getFirstChild().getNodeValue());\n    }\n    boolean bloomfilter = HColumnDescriptor.DEFAULT_BLOOMFILTER;\n    NodeList bloomfilter_list = columnfamily.getElementsByTagName(\"bloomfilter\");\n    if (bloomfilter_list.getLength() > 0) {\n      bloomfilter = Boolean.valueOf(bloomfilter_list.item(0).getFirstChild().getNodeValue());\n    }\n    return new HColumnDescriptor(Bytes.toBytes(colname), max_versions,\n        compression, in_memory, block_cache, max_cell_size, ttl, bloomfilter);\n  }","commit_id":"b174254d9eaea706246693948ad7b1964a518905","url":"https://github.com/apache/hbase"},{"original_method":"private void deleteTable(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments) throws IOException {\n    String tableName = pathSegments[0];\n    admin.deleteTable(tableName);\n    response.setStatus(202);\n  }","id":34534,"modified_method":"private void deleteTable(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments)\n  throws ServletException {\n    try {\n      String tableName = pathSegments[0];\n      String[] column_params = request.getParameterValues(COLUMN);\n      if (column_params != null && column_params.length > 0) {\n        for (String column : column_params) {\n          admin.deleteColumn(tableName, makeColumnName(column));\n        }\n      } else {\n        admin.deleteTable(tableName);\n      }\n      response.setStatus(202);\n    } catch (Exception e) {\n      throw new ServletException(e);\n    }\n  }","commit_id":"b174254d9eaea706246693948ad7b1964a518905","url":"https://github.com/apache/hbase"},{"original_method":"private void updateTableXml(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments) throws IOException,\n      ServletException {\n    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory\n        .newInstance();\n    // ignore all comments inside the xml file\n    docBuilderFactory.setIgnoringComments(true);\n\n    DocumentBuilder builder = null;\n    Document doc = null;\n\n    try {\n      builder = docBuilderFactory.newDocumentBuilder();\n      doc = builder.parse(request.getInputStream());\n    } catch (javax.xml.parsers.ParserConfigurationException e) {\n      throw new ServletException(e);\n    } catch (org.xml.sax.SAXException e) {\n      throw new ServletException(e);\n    }\n\n    try {\n      String tableName = pathSegments[0];\n\n      NodeList columnfamily_nodes = doc.getElementsByTagName(\"columnfamily\");\n      for (int i = 0; i < columnfamily_nodes.getLength(); i++) {\n        Element columnfamily = (Element) columnfamily_nodes.item(i);\n        HColumnDescriptor hcd = putColumnFamilyXml(columnfamily);\n        admin.modifyColumn(tableName, hcd.getNameAsString(), hcd);\n      }\n    } catch (Exception e) {\n      throw new ServletException(e);\n    }\n  }","id":34535,"modified_method":"private void updateTableXml(HttpServletRequest request,\n      HttpServletResponse response, String[] pathSegments) throws IOException,\n      ServletException {\n    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory\n        .newInstance();\n    // ignore all comments inside the xml file\n    docBuilderFactory.setIgnoringComments(true);\n\n    DocumentBuilder builder = null;\n    Document doc = null;\n\n    try {\n      builder = docBuilderFactory.newDocumentBuilder();\n      doc = builder.parse(request.getInputStream());\n    } catch (javax.xml.parsers.ParserConfigurationException e) {\n      throw new ServletException(e);\n    } catch (org.xml.sax.SAXException e) {\n      throw new ServletException(e);\n    }\n\n    try {\n      String tableName = pathSegments[0];\n      HTableDescriptor htd = admin.getTableDescriptor(tableName);\n      \n      NodeList columnfamily_nodes = doc.getElementsByTagName(\"columnfamily\");\n\n      for (int i = 0; i < columnfamily_nodes.getLength(); i++) {\n        Element columnfamily = (Element) columnfamily_nodes.item(i);\n        HColumnDescriptor hcd = putColumnFamilyXml(columnfamily);\n        if (htd.hasFamily(Bytes.toBytes(hcd.getNameAsString()))) {\n          admin.modifyColumn(tableName, hcd.getNameAsString(), hcd);\n        } else {\n          admin.addColumn(tableName, hcd);\n        }\n      }\n    } catch (Exception e) {\n      throw new ServletException(e);\n    }\n  }","commit_id":"b174254d9eaea706246693948ad7b1964a518905","url":"https://github.com/apache/hbase"},{"original_method":"public HTablePool(final Configuration config, final int maxSize,\n      final HTableInterfaceFactory tableFactory) {\n    // Make a new configuration instance so I can safely cleanup when\n    // done with the pool.\n    this.config = new Configuration(config);\n    this.maxSize = maxSize;\n    this.tableFactory = tableFactory == null? new HTableFactory(): tableFactory;\n  }","id":34536,"modified_method":"public HTablePool(final Configuration config, final int maxSize,\n      final HTableInterfaceFactory tableFactory) {\n    // Make a new configuration instance so I can safely cleanup when\n    // done with the pool.\n    this.config = config == null? new Configuration(): new Configuration(config);\n    this.maxSize = maxSize;\n    this.tableFactory = tableFactory == null? new HTableFactory(): tableFactory;\n  }","commit_id":"1b5666c84bb224760913780125b1922bdb7970a5","url":"https://github.com/apache/hbase"},{"original_method":"@BeforeClass\n  public static void beforeClass() throws Exception {\n    TEST_UTIL.startMiniCluster(1);\n\n  }","id":34537,"modified_method":"@BeforeClass\n  public static void beforeClass() throws Exception {\n    TEST_UTIL.startMiniCluster(1);\n    TEST_UTIL.createTable(TABLENAME, HConstants.CATALOG_FAMILY);\n  }","commit_id":"1b5666c84bb224760913780125b1922bdb7970a5","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testTableWithByteArrayName() {\n    HTablePool pool = new HTablePool((HBaseConfiguration)null, Integer.MAX_VALUE);\n    byte[] tableName = Bytes.toBytes(\"testTable\");\n\n    // Request a table from an empty pool\n    HTableInterface table = pool.getTable(tableName);\n    Assert.assertNotNull(table);\n\n    // Return the table to the pool\n    pool.putTable(table);\n\n    // Request a table of the same name\n    HTableInterface sameTable = pool.getTable(tableName);\n    Assert.assertSame(table, sameTable);\n  }","id":34538,"modified_method":"@Test\n  public void testTableWithByteArrayName() throws IOException {\n    HTablePool pool = new HTablePool(TEST_UTIL.getConfiguration(), Integer.MAX_VALUE);\n\n    // Request a table from an empty pool\n    HTableInterface table = pool.getTable(TABLENAME);\n    Assert.assertNotNull(table);\n\n    // Return the table to the pool\n    pool.putTable(table);\n\n    // Request a table of the same name\n    HTableInterface sameTable = pool.getTable(TABLENAME);\n    Assert.assertSame(table, sameTable);\n  }","commit_id":"1b5666c84bb224760913780125b1922bdb7970a5","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testTableWithStringName() {\n    HTablePool pool = new HTablePool((HBaseConfiguration)null, Integer.MAX_VALUE);\n    String tableName = \"testTable\";\n\n    // Request a table from an empty pool\n    HTableInterface table = pool.getTable(tableName);\n    Assert.assertNotNull(table);\n\n    // Return the table to the pool\n    pool.putTable(table);\n\n    // Request a table of the same name\n    HTableInterface sameTable = pool.getTable(tableName);\n    Assert.assertSame(table, sameTable);\n  }","id":34539,"modified_method":"@Test\n  public void testTableWithStringName() {\n    HTablePool pool =\n      new HTablePool(TEST_UTIL.getConfiguration(), Integer.MAX_VALUE);\n    String tableName = Bytes.toString(TABLENAME);\n\n    // Request a table from an empty pool\n    HTableInterface table = pool.getTable(tableName);\n    Assert.assertNotNull(table);\n\n    // Return the table to the pool\n    pool.putTable(table);\n\n    // Request a table of the same name\n    HTableInterface sameTable = pool.getTable(tableName);\n    Assert.assertSame(table, sameTable);\n  }","commit_id":"1b5666c84bb224760913780125b1922bdb7970a5","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testTablesWithDifferentNames() {\n    HTablePool pool = new HTablePool((HBaseConfiguration)null, Integer.MAX_VALUE);\n    String tableName1 = \"testTable1\";\n    String tableName2 = \"testTable2\";\n\n    // Request a table from an empty pool\n    HTableInterface table1 = pool.getTable(tableName1);\n    HTableInterface table2 = pool.getTable(tableName2);\n    Assert.assertNotNull(table2);\n\n    // Return the tables to the pool\n    pool.putTable(table1);\n    pool.putTable(table2);\n\n    // Request tables of the same names\n    HTableInterface sameTable1 = pool.getTable(tableName1);\n    HTableInterface sameTable2 = pool.getTable(tableName2);\n    Assert.assertSame(table1, sameTable1);\n    Assert.assertSame(table2, sameTable2);\n  }","id":34540,"modified_method":"@Test\n  public void testTablesWithDifferentNames() throws IOException {\n    HTablePool pool = new HTablePool(TEST_UTIL.getConfiguration(), Integer.MAX_VALUE);\n    byte [] otherTable = Bytes.toBytes(\"OtherTable\");\n    TEST_UTIL.createTable(otherTable, HConstants.CATALOG_FAMILY);\n\n    // Request a table from an empty pool\n    HTableInterface table1 = pool.getTable(TABLENAME);\n    HTableInterface table2 = pool.getTable(otherTable);\n    Assert.assertNotNull(table2);\n\n    // Return the tables to the pool\n    pool.putTable(table1);\n    pool.putTable(table2);\n\n    // Request tables of the same names\n    HTableInterface sameTable1 = pool.getTable(TABLENAME);\n    HTableInterface sameTable2 = pool.getTable(otherTable);\n    Assert.assertSame(table1, sameTable1);\n    Assert.assertSame(table2, sameTable2);\n  }","commit_id":"1b5666c84bb224760913780125b1922bdb7970a5","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testCloseTablePool() throws IOException {\n\n    HTablePool pool = new HTablePool(TEST_UTIL.getConfiguration(), 4);\n    String tableName = \"testTable\";\n    HBaseAdmin admin = new HBaseAdmin(TEST_UTIL.getConfiguration());\n\n    if (admin.tableExists(tableName)) {\n      admin.deleteTable(tableName);\n    }\n\n    HTableDescriptor tableDescriptor = new HTableDescriptor(Bytes\n        .toBytes(tableName));\n    tableDescriptor.addFamily(new HColumnDescriptor(\"randomFamily\"));\n    admin.createTable(tableDescriptor);\n\n\n    // Request tables from an empty pool\n    HTableInterface[] tables = new HTableInterface[4];\n    for (int i = 0; i < 4; ++i ) {\n      tables[i] = pool.getTable(tableName);\n    }\n\n    pool.closeTablePool(tableName);\n\n    for (int i = 0; i < 4; ++i ) {\n      pool.putTable(tables[i]);\n    }\n\n    Assert.assertEquals(4, pool.getCurrentPoolSize(tableName));\n\n    pool.closeTablePool(tableName);\n\n    Assert.assertEquals(0, pool.getCurrentPoolSize(tableName));\n\n  }","id":34541,"modified_method":"@Test\n  public void testCloseTablePool() throws IOException {\n    HTablePool pool = new HTablePool(TEST_UTIL.getConfiguration(), 4);\n    HBaseAdmin admin = new HBaseAdmin(TEST_UTIL.getConfiguration());\n\n    if (admin.tableExists(TABLENAME)) {\n      admin.disableTable(TABLENAME);\n      admin.deleteTable(TABLENAME);\n    }\n\n    HTableDescriptor tableDescriptor = new HTableDescriptor(TABLENAME);\n    tableDescriptor.addFamily(new HColumnDescriptor(\"randomFamily\"));\n    admin.createTable(tableDescriptor);\n\n\n    // Request tables from an empty pool\n    HTableInterface[] tables = new HTableInterface[4];\n    for (int i = 0; i < 4; ++i ) {\n      tables[i] = pool.getTable(TABLENAME);\n    }\n\n    pool.closeTablePool(TABLENAME);\n\n    for (int i = 0; i < 4; ++i ) {\n      pool.putTable(tables[i]);\n    }\n\n    Assert.assertEquals(4, pool.getCurrentPoolSize(Bytes.toString(TABLENAME)));\n\n    pool.closeTablePool(TABLENAME);\n\n    Assert.assertEquals(0, pool.getCurrentPoolSize(Bytes.toString(TABLENAME)));\n  }","commit_id":"1b5666c84bb224760913780125b1922bdb7970a5","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testTableWithMaxSize() {\n    HTablePool pool = new HTablePool((HBaseConfiguration)null, 2);\n    String tableName = \"testTable\";\n\n    // Request tables from an empty pool\n    HTableInterface table1 = pool.getTable(tableName);\n    HTableInterface table2 = pool.getTable(tableName);\n    HTableInterface table3 = pool.getTable(tableName);\n\n    // Return the tables to the pool\n    pool.putTable(table1);\n    pool.putTable(table2);\n    // The pool should reject this one since it is already full\n    pool.putTable(table3);\n\n    // Request tables of the same name\n    HTableInterface sameTable1 = pool.getTable(tableName);\n    HTableInterface sameTable2 = pool.getTable(tableName);\n    HTableInterface sameTable3 = pool.getTable(tableName);\n    Assert.assertSame(table1, sameTable1);\n    Assert.assertSame(table2, sameTable2);\n    Assert.assertNotSame(table3, sameTable3);\n  }","id":34542,"modified_method":"@Test\n  public void testTableWithMaxSize() {\n    HTablePool pool = new HTablePool(TEST_UTIL.getConfiguration(), 2);\n\n    // Request tables from an empty pool\n    HTableInterface table1 = pool.getTable(TABLENAME);\n    HTableInterface table2 = pool.getTable(TABLENAME);\n    HTableInterface table3 = pool.getTable(TABLENAME);\n\n    // Return the tables to the pool\n    pool.putTable(table1);\n    pool.putTable(table2);\n    // The pool should reject this one since it is already full\n    pool.putTable(table3);\n\n    // Request tables of the same name\n    HTableInterface sameTable1 = pool.getTable(TABLENAME);\n    HTableInterface sameTable2 = pool.getTable(TABLENAME);\n    HTableInterface sameTable3 = pool.getTable(TABLENAME);\n    Assert.assertSame(table1, sameTable1);\n    Assert.assertSame(table2, sameTable2);\n    Assert.assertNotSame(table3, sameTable3);\n  }","commit_id":"1b5666c84bb224760913780125b1922bdb7970a5","url":"https://github.com/apache/hbase"},{"original_method":"@SuppressWarnings(\"unchecked\")\n        public void handleMessage(Message outMessage) throws Fault {\n            \n            OperationResourceInfo ori = outMessage.getContent(OperationResourceInfo.class);\n            OutputStream os = outMessage.getContent(OutputStream.class);\n            if ((os == null && outMessage.getContent(XMLStreamWriter.class) == null)\n                || ori == null) {\n                return;\n            }\n            MessageContentsList objs = MessageContentsList.getContentsList(outMessage);\n            if (objs == null || objs.size() == 0) {\n                return;\n            }\n            MultivaluedMap<String, Object> headers = \n                (MultivaluedMap<String, Object>)outMessage.get(Message.PROTOCOL_HEADERS);\n            Method method = ori.getMethodToInvoke();\n            int bodyIndex = (Integer)outMessage.get(\"BODY_INDEX\");\n            Method aMethod = ori.getAnnotatedMethod();\n            Annotation[] anns = aMethod == null || bodyIndex == -1 ? new Annotation[0] \n                                                  : aMethod.getParameterAnnotations()[bodyIndex];\n            Object body = objs.get(0);\n            try {\n                if (bodyIndex != -1) {\n                    writeBody(body, outMessage,\n                              method.getParameterTypes()[bodyIndex],\n                              method.getGenericParameterTypes()[bodyIndex],\n                              anns, headers, os);\n                } else {\n                    writeBody(body, outMessage, body.getClass(), body.getClass(), \n                              anns, headers, os);\n                }\n            } catch (Exception ex) {\n                throw new Fault(ex);\n            }\n            \n        }","id":34543,"modified_method":"@SuppressWarnings(\"unchecked\")\n        public void handleMessage(Message outMessage) throws Fault {\n            \n            OperationResourceInfo ori = outMessage.getContent(OperationResourceInfo.class);\n            OutputStream os = outMessage.getContent(OutputStream.class);\n            if ((os == null && outMessage.getContent(XMLStreamWriter.class) == null)\n                || ori == null) {\n                return;\n            }\n            MessageContentsList objs = MessageContentsList.getContentsList(outMessage);\n            if (objs == null || objs.size() == 0) {\n                return;\n            }\n            MultivaluedMap<String, Object> headers = \n                (MultivaluedMap<String, Object>)outMessage.get(Message.PROTOCOL_HEADERS);\n            Method method = ori.getMethodToInvoke();\n            int bodyIndex = (Integer)outMessage.get(\"BODY_INDEX\");\n            Method aMethod = ori.getAnnotatedMethod();\n            Annotation[] anns = aMethod == null || bodyIndex == -1 ? new Annotation[0] \n                                                  : aMethod.getParameterAnnotations()[bodyIndex];\n            Object body = objs.get(0);\n            try {\n                if (bodyIndex != -1) {\n                    Class<?> paramClass = method.getParameterTypes()[bodyIndex];\n                    Type paramType = method.getGenericParameterTypes()[bodyIndex];\n                    \n                    boolean isAssignable = paramClass.isAssignableFrom(body.getClass());\n                    writeBody(body, outMessage,\n                              isAssignable ? paramClass : body.getClass(),\n                              isAssignable ? paramType : body.getClass(),\n                              anns, headers, os);\n                } else {\n                    writeBody(body, outMessage, body.getClass(), body.getClass(), \n                              anns, headers, os);\n                }\n            } catch (Exception ex) {\n                throw new Fault(ex);\n            }\n            \n        }","commit_id":"05c37ce8eaf88ba30e75313bc21ae3155dc5be22","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n        public void handleMessage(Message outMessage) throws Fault {\n            \n            OutputStream os = outMessage.getContent(OutputStream.class);\n            XMLStreamWriter writer = outMessage.getContent(XMLStreamWriter.class);\n            if (os == null && writer == null) {\n                return;\n            }\n            MessageContentsList objs = MessageContentsList.getContentsList(outMessage);\n            if (objs == null || objs.size() == 0) {\n                return;\n            }\n            MultivaluedMap<String, Object> headers = \n                (MultivaluedMap<String, Object>)outMessage.get(Message.PROTOCOL_HEADERS);\n            Object body = objs.get(0);\n            \n            Map<String, Object> requestContext = WebClient.this.getRequestContext(outMessage);\n            Class<?> requestClass = null;\n            Type requestType = null;\n            if (requestContext != null) {\n                requestClass = (Class<?>)requestContext.get(REQUEST_CLASS);\n                requestType = (Type)requestContext.get(REQUEST_TYPE);\n            }\n            try {\n                writeBody(body, outMessage, \n                          requestClass == null ? body.getClass() : requestClass,\n                          requestType == null ? body.getClass() : requestType, \n                          new Annotation[]{}, headers, os);\n                if (os != null) {\n                    os.flush();\n                }\n            } catch (Exception ex) {\n                throw new Fault(ex);\n            }\n        }","id":34544,"modified_method":"@SuppressWarnings(\"unchecked\")\n        public void handleMessage(Message outMessage) throws Fault {\n            \n            OutputStream os = outMessage.getContent(OutputStream.class);\n            XMLStreamWriter writer = outMessage.getContent(XMLStreamWriter.class);\n            if (os == null && writer == null) {\n                return;\n            }\n            MessageContentsList objs = MessageContentsList.getContentsList(outMessage);\n            if (objs == null || objs.size() == 0) {\n                return;\n            }\n            MultivaluedMap<String, Object> headers = \n                (MultivaluedMap<String, Object>)outMessage.get(Message.PROTOCOL_HEADERS);\n            Object body = objs.get(0);\n            \n            Map<String, Object> requestContext = WebClient.this.getRequestContext(outMessage);\n            Class<?> requestClass = null;\n            Type requestType = null;\n            if (requestContext != null) {\n                requestClass = (Class<?>)requestContext.get(REQUEST_CLASS);\n                requestType = (Type)requestContext.get(REQUEST_TYPE);\n            }\n            boolean isAssignable = requestClass != null && requestClass.isAssignableFrom(body.getClass());\n            try {\n                writeBody(body, outMessage, \n                          requestClass == null || !isAssignable ? body.getClass() : requestClass,\n                          requestType == null || !isAssignable ? body.getClass() : requestType, \n                          new Annotation[]{}, headers, os);\n                if (os != null) {\n                    os.flush();\n                }\n            } catch (Exception ex) {\n                throw new Fault(ex);\n            }\n        }","commit_id":"05c37ce8eaf88ba30e75313bc21ae3155dc5be22","url":"https://github.com/apache/cxf"},{"original_method":"void addWrite(Object obj) {\n        boolean needDispatch;\n        synchronized (writeStateMachine) {\n            writeQueue.add(obj);\n            needDispatch = writeStateMachine.addWrite();\n        }\n        if (needDispatch) {\n            socketWrapper.processSocket(SocketStatus.OPEN_WRITE, true);\n        }\n    }","id":34545,"modified_method":"void addWrite(Object obj) {\n        writeQueue.add(obj);\n    }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"void writeBody(Stream stream, ByteBuffer data) throws IOException {\n        data.flip();\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.writeBody\", Integer.toString(connectionId),\n                    stream.getIdentifier(), Integer.toString(data.remaining())));\n        }\n        synchronized (socketWrapper) {\n            // TODO Manage window sizes\n            byte[] header = new byte[9];\n            ByteUtil.setThreeBytes(header, 0, data.remaining());\n            header[3] = FRAME_TYPE_DATA;\n            if (stream.getOutputBuffer().isFinished()) {\n                header[4] = FLAG_END_OF_STREAM;\n            }\n            ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());\n            socketWrapper.write(true, header, 0, header.length);\n            socketWrapper.write(true, data.array(), data.arrayOffset(), data.limit());\n            socketWrapper.flush(true);\n        }\n    }","id":34546,"modified_method":"void writeBody(Stream stream, ByteBuffer data, int len) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.writeBody\", Integer.toString(connectionId),\n                    stream.getIdentifier(), Integer.toString(data.remaining())));\n        }\n        synchronized (socketWrapper) {\n            // TODO Manage window sizes\n            byte[] header = new byte[9];\n            ByteUtil.setThreeBytes(header, 0, len);\n            header[3] = FRAME_TYPE_DATA;\n            if (stream.getOutputBuffer().isFinished()) {\n                header[4] = FLAG_END_OF_STREAM;\n            }\n            ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());\n            socketWrapper.write(true, header, 0, header.length);\n            socketWrapper.write(true, data.array(), data.arrayOffset() + data.position(),\n                    len);\n            socketWrapper.flush(true);\n        }\n    }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"private void processFrameWindowUpdate(int flags, int streamId, int payloadSize)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (payloadSize != 4) {\n            // Use stream 0 since this is always a connection error\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameWindowUpdate.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        byte[] payload = new byte[4];\n        readFully(payload);\n        int windowSizeIncrement = ByteUtil.get31Bits(payload, 0);\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrameWindowUpdate.debug\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(windowSizeIncrement)));\n        }\n\n        // Validate the data\n        if (windowSizeIncrement == 0) {\n            throw new Http2Exception(\"upgradeHandler.processFrameWindowUpdate.invalidIncrement\",\n                    streamId, Http2Exception.PROTOCOL_ERROR);\n        }\n        if (streamId == 0) {\n            flowControlWindowSize += windowSizeIncrement;\n        } else {\n            Stream stream = getStream(streamId);\n            if (stream == null) {\n                // Old stream already closed.\n                // Ignore\n            } else {\n                stream.incrementWindowSize(windowSizeIncrement);\n            }\n        }\n    }","id":34547,"modified_method":"private void processFrameWindowUpdate(int flags, int streamId, int payloadSize)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrame\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(flags), Integer.toString(payloadSize)));\n        }\n        // Validate the frame\n        if (payloadSize != 4) {\n            // Use stream 0 since this is always a connection error\n            throw new Http2Exception(sm.getString(\"upgradeHandler.processFrameWindowUpdate.invalidPayloadSize\",\n                    Integer.toString(payloadSize)), 0, Http2Exception.FRAME_SIZE_ERROR);\n        }\n\n        byte[] payload = new byte[4];\n        readFully(payload);\n        int windowSizeIncrement = ByteUtil.get31Bits(payload, 0);\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.processFrameWindowUpdate.debug\",\n                    Long.toString(connectionId), Integer.toString(streamId),\n                    Integer.toString(windowSizeIncrement)));\n        }\n\n        // Validate the data\n        if (windowSizeIncrement == 0) {\n            throw new Http2Exception(\"upgradeHandler.processFrameWindowUpdate.invalidIncrement\",\n                    streamId, Http2Exception.PROTOCOL_ERROR);\n        }\n        if (streamId == 0) {\n            incrementWindowSize(windowSizeIncrement);\n        } else {\n            Stream stream = getStream(streamId);\n            if (stream == null) {\n                // Old stream already closed.\n                // Ignore\n            } else {\n                stream.incrementWindowSize(windowSizeIncrement);\n            }\n        }\n    }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public SocketState upgradeDispatch(SocketStatus status) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.entry\",\n                    Long.toString(connectionId), status));\n        }\n\n        if (!initialized) {\n            // WebConnection is not used so passing null here is fine\n            init(null);\n        }\n\n        SocketState result = SocketState.CLOSED;\n\n        switch(status) {\n        case OPEN_READ:\n            writeStateMachine.startRead();\n            // Gets set to null once the connection preface has been\n            // successfully parsed.\n            if (connectionPrefaceParser != null) {\n                if (!connectionPrefaceParser.parse(socketWrapper)) {\n                    if (connectionPrefaceParser.isError()) {\n                        // Any errors will have already been logged.\n                        close();\n                        break;\n                    } else {\n                        // Incomplete\n                        result = SocketState.UPGRADED;\n                        break;\n                    }\n                }\n            }\n            connectionPrefaceParser = null;\n\n            // Process all the incoming data\n            try {\n                while (processFrame()) {\n                }\n\n                // We are on a container thread. There is no more data to read\n                // so check for writes (more efficient than dispatching to a new\n                // thread).\n                if (writeStateMachine.endRead()) {\n                    processWrites();\n                }\n            } catch (Http2Exception h2e) {\n                if (h2e.getStreamId() == 0) {\n                    // Connection error\n                    log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                    close(h2e);\n                    break;\n                } else {\n                    // Stream error\n                    // TODO Reset stream\n                }\n            } catch (IOException ioe) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"upgradeHandler.ioerror\",\n                            Long.toString(connectionId)), ioe);\n                }\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            result = SocketState.UPGRADED;\n            break;\n\n        case OPEN_WRITE:\n            if (writeStateMachine.startWrite()) {\n                try {\n                    processWrites();\n                } catch (Http2Exception h2e) {\n                    if (h2e.getStreamId() == 0) {\n                        // Connection error\n                        log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                        close(h2e);\n                        break;\n                    } else {\n                        // Stream error\n                        // TODO Reset stream\n                    }\n                } catch (IOException ioe) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"upgradeHandler.ioerror\",\n                                Long.toString(connectionId)), ioe);\n                    }\n                    close();\n                    result = SocketState.CLOSED;\n                    break;\n                }\n\n            }\n            result = SocketState.UPGRADED;\n            break;\n\n        case ASYNC_READ_ERROR:\n        case ASYNC_WRITE_ERROR:\n        case CLOSE_NOW:\n            // This should never happen and will be fatal for this connection.\n            // Add the exception to trace how this point was reached.\n            log.error(sm.getString(\"upgradeHandler.unexpectedStatus\", status),\n                    new IllegalStateException());\n            //$FALL-THROUGH$\n        case DISCONNECT:\n        case ERROR:\n        case TIMEOUT:\n        case STOP:\n            // For all of the above, including the unexpected values, close the\n            // connection.\n            close();\n            result = SocketState.CLOSED;\n            break;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.exit\",\n                    Long.toString(connectionId), result));\n        }\n        return result;\n    }","id":34548,"modified_method":"@Override\n    public SocketState upgradeDispatch(SocketStatus status) {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.entry\",\n                    Long.toString(connectionId), status));\n        }\n\n        if (!initialized) {\n            // WebConnection is not used so passing null here is fine\n            init(null);\n        }\n\n        SocketState result = SocketState.CLOSED;\n\n        switch(status) {\n        case OPEN_READ:\n            // Gets set to null once the connection preface has been\n            // successfully parsed.\n            if (connectionPrefaceParser != null) {\n                if (!connectionPrefaceParser.parse(socketWrapper)) {\n                    if (connectionPrefaceParser.isError()) {\n                        // Any errors will have already been logged.\n                        close();\n                        break;\n                    } else {\n                        // Incomplete\n                        result = SocketState.UPGRADED;\n                        break;\n                    }\n                }\n            }\n            connectionPrefaceParser = null;\n\n            // Process all the incoming data\n            try {\n                while (processFrame()) {\n                }\n            } catch (Http2Exception h2e) {\n                if (h2e.getStreamId() == 0) {\n                    // Connection error\n                    log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                    close(h2e);\n                    break;\n                } else {\n                    // Stream error\n                    // TODO Reset stream\n                }\n            } catch (IOException ioe) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"upgradeHandler.ioerror\",\n                            Long.toString(connectionId)), ioe);\n                }\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            result = SocketState.UPGRADED;\n            break;\n\n        case OPEN_WRITE:\n            try {\n                processWrites();\n            } catch (Http2Exception h2e) {\n                if (h2e.getStreamId() == 0) {\n                    // Connection error\n                    log.warn(sm.getString(\"upgradeHandler.connectionError\"), h2e);\n                    close(h2e);\n                    break;\n                } else {\n                    // Stream error\n                    // TODO Reset stream\n                }\n            } catch (IOException ioe) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"upgradeHandler.ioerror\",\n                            Long.toString(connectionId)), ioe);\n                }\n                close();\n                result = SocketState.CLOSED;\n                break;\n            }\n\n            result = SocketState.UPGRADED;\n            break;\n\n        case ASYNC_READ_ERROR:\n        case ASYNC_WRITE_ERROR:\n        case CLOSE_NOW:\n            // This should never happen and will be fatal for this connection.\n            // Add the exception to trace how this point was reached.\n            log.error(sm.getString(\"upgradeHandler.unexpectedStatus\", status),\n                    new IllegalStateException());\n            //$FALL-THROUGH$\n        case DISCONNECT:\n        case ERROR:\n        case TIMEOUT:\n        case STOP:\n            // For all of the above, including the unexpected values, close the\n            // connection.\n            close();\n            result = SocketState.CLOSED;\n            break;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"upgradeHandler.upgradeDispatch.exit\",\n                    Long.toString(connectionId), result));\n        }\n        return result;\n    }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"private Object getThingToWrite() {\n        synchronized (writeStateMachine) {\n            // TODO This is more complicated than pulling an object off a queue.\n\n            // Note: The checking of the queue for something to write and the\n            //       calling of endWrite() if nothing is found must be kept\n            //       within the same sync to avoid race conditions with adding\n            //       entries to the queue.\n            Object obj = writeQueue.poll();\n            if (obj == null) {\n                 writeStateMachine.endWrite(WriteState.IDLE);\n            }\n            return obj;\n        }\n    }","id":34549,"modified_method":"private Object getThingToWrite() {\n        // TODO This is more complicated than pulling an object off a queue.\n\n        // Note: The checking of the queue for something to write and the\n        //       calling of endWrite() if nothing is found must be kept\n        //       within the same sync to avoid race conditions with adding\n        //       entries to the queue.\n        return writeQueue.poll();\n    }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"public void incrementWindowSize(int windowSizeIncrement) {\n        flowControlWindowSize += windowSizeIncrement;\n    }","id":34550,"modified_method":"@Override\n    public void incrementWindowSize(int windowSizeIncrement) {\n        // If this is zero then any thread that has been trying to write for\n        // this stream will be waiting. Notify that thread it can continue. Use\n        // notify all even though only one thread is waiting to be on the safe\n        // side.\n        boolean notify = getWindowSize() == 0;\n        super.incrementWindowSize(windowSizeIncrement);\n        if (notify) {\n            synchronized (this) {\n                notifyAll();\n            }\n        }\n    }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"public void flush() throws IOException {\n            if (buffer.position() == 0) {\n                // Buffer is empty. Nothing to do.\n                return;\n            }\n            handler.writeBody(Stream.this, buffer);\n            buffer.clear();\n        }","id":34551,"modified_method":"public void flush() throws IOException {\n            if (!coyoteResponse.isCommitted()) {\n                coyoteResponse.sendHeaders();\n            }\n            if (buffer.position() == 0) {\n                // Buffer is empty. Nothing to do.\n                return;\n            }\n            buffer.flip();\n            int left = buffer.remaining();\n            int thisWriteStream;\n            while (left > 0) {\n                // Flow control for the Stream\n                do {\n                    thisWriteStream = reserveWindowSize(left);\n                    if (thisWriteStream < 1) {\n                        // Need to block until a WindowUpdate message is\n                        // processed for this stream;\n                        synchronized (this) {\n                            try {\n                                wait();\n                            } catch (InterruptedException e) {\n                                // TODO. Possible shutdown?\n                            }\n                        }\n                    }\n                } while (thisWriteStream < 1);\n\n                // Flow control for the connection\n                int thisWrite;\n                do {\n                    thisWrite = handler.reserveWindowSize(thisWriteStream);\n                    if (thisWrite < 1) {\n                        // TODO Flow control when connection window is exhausted\n                    }\n                } while (thisWrite < 1);\n\n                decrementWindowSize(thisWrite);\n                handler.decrementWindowSize(thisWrite);\n\n                // Do the write\n                handler.writeBody(Stream.this, buffer, thisWrite);\n                left -= thisWrite;\n                buffer.position(buffer.position() + thisWrite);\n            }\n            buffer.clear();\n        }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"public Stream(Integer identifier, Http2UpgradeHandler handler) {\n        super(identifier);\n        this.handler = handler;\n        setParentStream(handler);\n        flowControlWindowSize = handler.getRemoteSettings().getInitialWindowSize();\n        coyoteResponse.setOutputBuffer(outputBuffer);\n    }","id":34552,"modified_method":"public Stream(Integer identifier, Http2UpgradeHandler handler) {\n        super(identifier);\n        this.handler = handler;\n        setParentStream(handler);\n        setWindowSize(handler.getRemoteSettings().getInitialWindowSize());\n        coyoteResponse.setOutputBuffer(outputBuffer);\n    }","commit_id":"91ea5c8c95911a5759b985bed48b6203a5316559","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param increment\n     * @throws Http2Exception\n     */\n    protected void incrementWindowSize(int increment) throws Http2Exception {\n        synchronized (windowSizeLock) {\n            // Overflow protection\n            if (Long.MAX_VALUE - increment < windowSize) {\n                windowSize = Long.MAX_VALUE;\n            } else {\n                windowSize += increment;\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"abstractStream.windowSizeInc\", getConnectionId(),\n                        getIdentifier(), Integer.toString(increment), Long.toString(windowSize)));\n            }\n        }\n    }","id":34553,"modified_method":"/**\n     * @param increment\n     * @throws Http2Exception\n     */\n    protected synchronized void incrementWindowSize(int increment) throws Http2Exception {\n        // Overflow protection\n        if (Long.MAX_VALUE - increment < windowSize) {\n            windowSize = Long.MAX_VALUE;\n        } else {\n            windowSize += increment;\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"abstractStream.windowSizeInc\", getConnectionId(),\n                    getIdentifier(), Integer.toString(increment), Long.toString(windowSize)));\n        }\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"protected void decrementWindowSize(int decrement) {\n        // No need for overflow protection here. Decrement can never be larger\n        // the Integer.MAX_VALUE and once windowSize goes negative no further\n        // decrements are permitted\n        synchronized (windowSizeLock) {\n            windowSize -= decrement;\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"abstractStream.windowSizeDec\", getConnectionId(),\n                        getIdentifier(), Integer.toString(decrement), Long.toString(windowSize)));\n            }\n        }\n    }","id":34554,"modified_method":"protected synchronized void decrementWindowSize(int decrement) {\n        // No need for overflow protection here. Decrement can never be larger\n        // the Integer.MAX_VALUE and once windowSize goes negative no further\n        // decrements are permitted\n        windowSize -= decrement;\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"abstractStream.windowSizeDec\", getConnectionId(),\n                    getIdentifier(), Integer.toString(decrement), Long.toString(windowSize)));\n        }\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"protected void setWindowSize(long windowSize) {\n        synchronized (windowSizeLock) {\n            this.windowSize = windowSize;\n        }\n    }","id":34555,"modified_method":"protected synchronized void setWindowSize(long windowSize) {\n        this.windowSize = windowSize;\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"protected long getWindowSize() {\n        synchronized (windowSizeLock) {\n            return windowSize;\n        }\n    }","id":34556,"modified_method":"protected synchronized long getWindowSize() {\n        return windowSize;\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    protected void incrementWindowSize(int increment) throws Http2Exception {\n        synchronized (backLogLock) {\n            long windowSize = getWindowSize();\n            if (windowSize < 1 && windowSize + increment > 0) {\n                releaseBackLog(increment);\n            }\n            super.incrementWindowSize(increment);\n        }\n    }","id":34557,"modified_method":"@Override\n    protected synchronized void incrementWindowSize(int increment) throws Http2Exception {\n        long windowSize = getWindowSize();\n        if (windowSize < 1 && windowSize + increment > 0) {\n            releaseBackLog(increment);\n        }\n        super.incrementWindowSize(increment);\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"int reserveWindowSize(Stream stream, int toWrite) {\n        int result;\n        synchronized (backLogLock) {\n            long windowSize = getWindowSize();\n            if (windowSize < 1 || backLogSize > 0) {\n                // Has this stream been granted an allocation\n                int[] value = backLogStreams.remove(stream);\n                if (value != null && value[1] > 0) {\n                    result = value[1];\n                } else {\n                    value = new int[] { toWrite, 0 };\n                    backLogStreams.put(stream, value);\n                    backLogSize += toWrite;\n                    // Add the parents as well\n                    AbstractStream parent = stream.getParentStream();\n                    while (parent != null && backLogStreams.putIfAbsent(parent, new int[2]) == null) {\n                        parent = parent.getParentStream();\n                    }\n                    result = 0;\n                }\n            } else if (windowSize < toWrite) {\n                result = (int) windowSize;\n            } else {\n                result = toWrite;\n            }\n            decrementWindowSize(result);\n        }\n        return result;\n    }","id":34558,"modified_method":"int reserveWindowSize(Stream stream, int reservation) {\n        // Need to be holding the stream lock so releaseBacklog() can't notify\n        // this thread until after this thread enters wait()\n        int allocation = 0;\n        synchronized (stream) {\n            do {\n                synchronized (this) {\n                    long windowSize = getWindowSize();\n                    if (windowSize < 1 || backLogSize > 0) {\n                        // Has this stream been granted an allocation\n                        int[] value = backLogStreams.remove(stream);\n                        if (value != null && value[1] > 0) {\n                            allocation = value[1];\n                            decrementWindowSize(allocation);\n                        } else {\n                            value = new int[] { reservation, 0 };\n                            backLogStreams.put(stream, value);\n                            backLogSize += reservation;\n                            // Add the parents as well\n                            AbstractStream parent = stream.getParentStream();\n                            while (parent != null && backLogStreams.putIfAbsent(parent, new int[2]) == null) {\n                                parent = parent.getParentStream();\n                            }\n                        }\n                    } else if (windowSize < reservation) {\n                        allocation = (int) windowSize;\n                        decrementWindowSize(allocation);\n                    } else {\n                        allocation = reservation;\n                        decrementWindowSize(allocation);\n                    }\n                }\n                if (allocation == 0) {\n                    try {\n                        stream.wait();\n                    } catch (InterruptedException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                }\n            } while (allocation == 0);\n        }\n        return allocation;\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void incrementWindowSize(int windowSizeIncrement) throws Http2Exception {\n        // If this is zero then any thread that has been trying to write for\n        // this stream will be waiting. Notify that thread it can continue. Use\n        // notify all even though only one thread is waiting to be on the safe\n        // side.\n        boolean notify = getWindowSize() == 0;\n        super.incrementWindowSize(windowSizeIncrement);\n        if (notify) {\n            synchronized (this) {\n                notifyAll();\n            }\n        }\n    }","id":34559,"modified_method":"@Override\n    public synchronized void incrementWindowSize(int windowSizeIncrement) throws Http2Exception {\n        // If this is zero then any thread that has been trying to write for\n        // this stream will be waiting. Notify that thread it can continue. Use\n        // notify all even though only one thread is waiting to be on the safe\n        // side.\n        boolean notify = getWindowSize() < 1;\n        super.incrementWindowSize(windowSizeIncrement);\n        if (notify && getWindowSize() > 0) {\n            notifyAll();\n        }\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"private int checkWindowSize(int reservation) {\n        long windowSize = getWindowSize();\n        if (reservation > windowSize) {\n            return (int) windowSize;\n        } else {\n            return reservation;\n        }\n    }","id":34560,"modified_method":"private synchronized int reserveWindowSize(int reservation) {\n        long windowSize = getWindowSize();\n        while (windowSize < 1) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n            }\n            windowSize = getWindowSize();\n        }\n        int allocation;\n        if (windowSize < reservation) {\n            allocation = (int) windowSize;\n        } else {\n            allocation = reservation;\n        }\n        decrementWindowSize(allocation);\n        return allocation;\n    }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"private void flush(boolean writeInProgress) throws IOException {\n            if (!coyoteResponse.isCommitted()) {\n                coyoteResponse.sendHeaders();\n            }\n            if (buffer.position() == 0) {\n                // Buffer is empty. Nothing to do.\n                return;\n            }\n            buffer.flip();\n            int left = buffer.remaining();\n            int thisWriteStream;\n            while (left > 0) {\n                // Flow control for the Stream\n                do {\n                    thisWriteStream = checkWindowSize(left);\n                    if (thisWriteStream < 1) {\n                        // Need to block until a WindowUpdate message is\n                        // processed for this stream\n                        synchronized (Stream.this) {\n                            try {\n                                Stream.this.wait();\n                            } catch (InterruptedException e) {\n                                // TODO: Possible shutdown?\n                            }\n                        }\n                    }\n                } while (thisWriteStream < 1);\n\n                // Flow control for the connection\n                int thisWrite;\n                do {\n                    thisWrite = handler.reserveWindowSize(Stream.this, thisWriteStream);\n                    if (thisWrite < 1) {\n                        // Need to block until a WindowUpdate message is\n                        // processed for this connection\n                        synchronized (Stream.this) {\n                            try {\n                                Stream.this.wait();\n                            } catch (InterruptedException e) {\n                                // TODO: Possible shutdown?\n                            }\n                        }\n                    }\n                } while (thisWrite < 1);\n\n                // Stream.checkWindowSize() doesn't reduce the flow control\n                // window (reserveWindowSize() does) so the Stream's window\n                // needs to be reduced here.\n                decrementWindowSize(thisWrite);\n\n                // Do the write\n                handler.writeBody(Stream.this, buffer, thisWrite,\n                        !writeInProgress && closed && left == thisWrite);\n                left -= thisWrite;\n                buffer.position(buffer.position() + thisWrite);\n            }\n            buffer.clear();\n        }","id":34561,"modified_method":"private synchronized void flush(boolean writeInProgress) throws IOException {\n            if (!coyoteResponse.isCommitted()) {\n                coyoteResponse.sendHeaders();\n            }\n            if (buffer.position() == 0) {\n                // Buffer is empty. Nothing to do.\n                return;\n            }\n            buffer.flip();\n            int left = buffer.remaining();\n            while (left > 0) {\n                int streamReservation  = reserveWindowSize(left);\n                while (streamReservation > 0) {\n                    int connectionReservation =\n                                handler.reserveWindowSize(Stream.this, streamReservation);\n                    // Do the write\n                    handler.writeBody(Stream.this, buffer, connectionReservation,\n                            !writeInProgress && closed && left == connectionReservation);\n                    streamReservation -= connectionReservation;\n                    left -= connectionReservation;\n                    buffer.position(buffer.position() + connectionReservation);\n\n                }\n            }\n            buffer.clear();\n        }","commit_id":"bdcee7610db8446c07798867b661c6053f43dd71","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Implements the server thread receiving commands from clients and acting\n     * upon them.\n     */\n    public void run() {\n        ServerSocket server = null;\n        try {\n            server = new ServerSocket();\n            server.bind(socketAddress);\n            if ( this.writePortConfig ) {\n                this.writePortToConfigFile(server);\n            }\n            Main.info(\"Apache Sling Control Server started at \" + server.getInetAddress() + \":\" + server.getLocalPort(), null);\n        } catch (final IOException ioe) {\n            Main.error(\"Failed to start Sling Control Server\", ioe);\n            return;\n        }\n\n        try {\n            while (true) {\n\n                final Socket s = server.accept();\n                try {\n                    final String command = readLine(s);\n                    Main.info(s.getRemoteSocketAddress() + \">\" + command, null);\n\n                    if (COMMAND_STOP.equals(command)) {\n                        slingMain.doStop();\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + RESPONSE_OK, null);\n                        writeLine(s, RESPONSE_OK);\n\n                        Main.info(\"Apache Sling shut down, exiting Java VM\", null);\n                        System.exit(0);\n\n                    } else if (COMMAND_STATUS.equals(command)) {\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + RESPONSE_OK, null);\n                        writeLine(s, RESPONSE_OK);\n\n                    } else {\n                        final String msg = \"ERR:\" + command;\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n\n                    }\n                } finally {\n                    try {\n                        s.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        } catch (final IOException ioe) {\n            Main.error(\"Failure reading from client\", ioe);\n        } finally {\n            try {\n                server.close();\n            } catch (final IOException ignore) {\n            }\n        }\n    }","id":34562,"modified_method":"/**\n     * Implements the server thread receiving commands from clients and acting\n     * upon them.\n     */\n    public void run() {\n        this.configure(false);\n\n        ServerSocket server = null;\n        try {\n            server = new ServerSocket();\n            server.bind(this.socketAddress);\n            writePortToConfigFile(getConfigFile(),\n                new InetSocketAddress(server.getInetAddress(), server.getLocalPort()), this.secretKey);\n            Thread.currentThread().setName(\n                \"Apache Sling Control Listener@\" + server.getInetAddress() + \":\" + server.getLocalPort());\n            Main.info(\"Apache Sling Control Listener started\", null);\n        } catch (final IOException ioe) {\n            Main.error(\"Failed to start Apache Sling Control Listener\", ioe);\n            return;\n        }\n\n        long delay = 0;\n\n        try {\n            while (true) {\n\n                final Socket s = server.accept();\n\n                // delay processing after unsuccessfull attempts\n                if (delay > 0) {\n                    Main.info(s.getRemoteSocketAddress() + \": Delay: \" + (delay / 1000), null);\n                    try {\n                        Thread.sleep(delay);\n                    } catch (InterruptedException e) {\n                    }\n                }\n\n                try {\n                    final String commandLine = readLine(s);\n                    if (commandLine == null) {\n                        final String msg = \"ERR: missing command\";\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n                        continue;\n                    }\n\n                    final int blank = commandLine.indexOf(' ');\n                    if (blank < 0) {\n                        final String msg = \"ERR: missing key\";\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n                        continue;\n                    }\n\n                    if (!secretKey.equals(commandLine.substring(0, blank))) {\n                        final String msg = \"ERR: wrong key\";\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n                        delay = (delay > 0) ? delay * 2 : 1000L;\n                        continue;\n                    }\n\n                    final String command = commandLine.substring(blank + 1);\n                    Main.info(s.getRemoteSocketAddress() + \">\" + command, null);\n\n                    if (COMMAND_STOP.equals(command)) {\n                        slingMain.doStop();\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + RESPONSE_OK, null);\n                        writeLine(s, RESPONSE_OK);\n                        break;\n\n                    } else if (COMMAND_STATUS.equals(command)) {\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + RESPONSE_OK, null);\n                        writeLine(s, RESPONSE_OK);\n\n                    } else {\n                        final String msg = \"ERR:\" + command;\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n\n                    }\n                } finally {\n                    try {\n                        s.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        } catch (final IOException ioe) {\n            Main.error(\"Failure reading from client\", ioe);\n        } finally {\n            try {\n                server.close();\n            } catch (final IOException ignore) {\n            }\n        }\n\n        getConfigFile().delete();\n\n        // everything has stopped and when this thread terminates,\n        // the VM should stop. If there are still some non-daemon threads\n        // active, this will not happen, so we force this here ...\n        Main.info(\"Apache Sling terminated, exiting Java VM\", null);\n        slingMain.terminateVM(0);\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"private void writePortToConfigFile(final ServerSocket socket) {\n        final File configFile = this.getConfigFile();\n        configFile.getParentFile().mkdirs();\n        FileWriter fw = null;\n        try {\n            fw = new FileWriter(configFile);\n            fw.write(socket.getInetAddress().getHostName());\n            fw.write(':');\n            fw.write(String.valueOf(socket.getLocalPort()));\n            fw.write('\\n');\n        } catch (final IOException ignore) {\n            // ignore\n        } finally {\n            if ( fw != null ) {\n                try { fw.close(); } catch ( final IOException ignore ) {}\n            }\n        }\n\n    }","id":34563,"modified_method":"private static void writePortToConfigFile(final File configFile, final InetSocketAddress socketAddress,\n            final String secretKey) {\n        configFile.getParentFile().mkdirs();\n        FileWriter fw = null;\n        try {\n            fw = new FileWriter(configFile);\n            fw.write(socketAddress.getAddress().getHostAddress());\n            fw.write(':');\n            fw.write(String.valueOf(socketAddress.getPort()));\n            fw.write('\\n');\n            fw.write(secretKey);\n            fw.write('\\n');\n        } catch (final IOException ignore) {\n            // ignore\n        } finally {\n            if (fw != null) {\n                try {\n                    fw.close();\n                } catch (final IOException ignore) {\n                }\n            }\n        }\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Implements the client side of the control connection sending the command\n     * to shutdown Sling.\n     */\n    void shutdownServer() {\n        sendCommand(COMMAND_STOP);\n    }","id":34564,"modified_method":"/**\n     * Implements the client side of the control connection sending the command\n     * to shutdown Sling.\n     */\n    int shutdownServer() {\n        return sendCommand(COMMAND_STOP);\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Implements the server side of the control connection starting a thread\n     * listening on the host and port configured on setup of this instance.\n     */\n    void listen() {\n        if (socketAddress != null) {\n            final Thread listener = new Thread(this);\n            listener.setDaemon(true);\n            listener.setName(\"Apache Sling Control Listener@\" + socketAddress);\n            listener.start();\n        } else {\n            Main.info(\"No socket address to listen to\", null);\n        }\n    }","id":34565,"modified_method":"/**\n     * Implements the server side of the control connection starting a thread\n     * listening on the host and port configured on setup of this instance.\n     */\n    boolean listen() {\n        final File configFile = getConfigFile();\n        if (configFile.canRead() && statusServer() == 0) {\n            // server already running, fail\n            Main.error(\"Sling already active in \" + this.slingMain.getSlingHome(), null);\n            return false;\n        }\n        configFile.delete();\n\n        final Thread listener = new Thread(this);\n        listener.setDaemon(true);\n        listener.setName(\"Apache Sling Control Listener (inactive)\");\n        listener.start();\n        return true;\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Creates an instance of this control support class.\n     * <p>\n     * The host (name or address) and port number of the socket is defined by\n     * the <code>listenSpec<\/code> parameter. This parameter is defined as\n     * <code>[ host \":\" ] port<\/code>. If the parameter is empty or\n     * <code>null<\/code> it defaults to <i>localhost:0<\/i>. If the host name\n     * is missing it defaults to <i>localhost<\/i>.\n     *\n     * @param slingMain The Main class reference. This is only required if this\n     *            instance is used for the server side to listen for remote stop\n     *            commands. Otherwise this argument may be <code>null<\/code>.\n     * @param listenSpec The specification for the host and port for the socket\n     *            connection. See above for the format of this parameter.\n     * @param selectNewPort Parameter specifying if a new port should be selected\n     *                      or if no port is specified a stored port should be\n     *                      used.\n     */\n    ControlListener(final Main slingMain,\n                    final String listenSpec,\n                    final boolean selectNewPort) {\n        this.slingMain = slingMain;\n        this.socketAddress = this.getSocketAddress(listenSpec, selectNewPort);\n        this.writePortConfig = selectNewPort;\n    }","id":34566,"modified_method":"/**\n     * Creates an instance of this control support class.\n     * <p>\n     * The host (name or address) and port number of the socket is defined by\n     * the <code>listenSpec<\/code> parameter. This parameter is defined as\n     * <code>[ host \":\" ] port<\/code>. If the parameter is empty or\n     * <code>null<\/code> it defaults to <i>localhost:0<\/i>. If the host name\n     * is missing it defaults to <i>localhost<\/i>.\n     *\n     * @param slingMain The Main class reference. This is only required if this\n     *            instance is used for the server side to listen for remote stop\n     *            commands. Otherwise this argument may be <code>null<\/code>.\n     * @param listenSpec The specification for the host and port for the socket\n     *            connection. See above for the format of this parameter.\n     */\n    ControlListener(final Main slingMain, final String listenSpec) {\n        this.slingMain = slingMain;\n        this.listenSpec = listenSpec; // socketAddress = this.getSocketAddress(listenSpec, selectNewPort);\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Sends the given command to the server indicated by the configured\n     * socket address and logs the reply.\n     *\n     * @param command The command to send\n     *\n     * @return A code indicating success of sending the command.\n     */\n    private int sendCommand(final String command) {\n        if (socketAddress != null) {\n            Socket socket = null;\n            try {\n                socket = new Socket();\n                socket.connect(socketAddress);\n                writeLine(socket, command);\n                final String result = readLine(socket);\n                Main.info(\"Sent '\" + command + \"' to \" + socketAddress + \": \"\n                    + result, null);\n                return 0; // LSB code for everything's fine\n            } catch (final ConnectException ce) {\n                Main.info(\"No Apache Sling running at \" + socketAddress, null);\n                return 3; // LSB code for programm not running\n            } catch (final IOException ioe) {\n                Main.error(\"Failed sending '\" + command + \"' to \"\n                    + socketAddress, ioe);\n                return 1; // LSB code for programm dead\n            } finally {\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        }\n        Main.info(\"No socket address to send '\" + command + \"' to\", null);\n        return 4; // LSB code for unknown status\n    }","id":34567,"modified_method":"/**\n     * Sends the given command to the server indicated by the configured\n     * socket address and logs the reply.\n     *\n     * @param command The command to send\n     *\n     * @return A code indicating success of sending the command.\n     */\n    private int sendCommand(final String command) {\n        if (configure(true)) {\n            if (this.secretKey == null) {\n                Main.info(\"Missing secret key to protect sending '\" + command + \"' to \" + this.socketAddress, null);\n                return 4; // LSB code for unknown status\n            }\n\n            Socket socket = null;\n            try {\n                socket = new Socket();\n                socket.connect(this.socketAddress);\n                writeLine(socket, this.secretKey + \" \" + command);\n                final String result = readLine(socket);\n                Main.info(\"Sent '\" + command + \"' to \" + this.socketAddress + \": \" + result, null);\n                return 0; // LSB code for everything's fine\n            } catch (final ConnectException ce) {\n                Main.info(\"No Apache Sling running at \" + this.socketAddress, null);\n                return 3; // LSB code for programm not running\n            } catch (final IOException ioe) {\n                Main.error(\"Failed sending '\" + command + \"' to \" + this.socketAddress, ioe);\n                return 1; // LSB code for programm dead\n            } finally {\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        }\n        Main.info(\"No socket address to send '\" + command + \"' to\", null);\n        return 4; // LSB code for unknown status\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"private SocketAddress getSocketAddress(String listenSpec, final boolean selectNewPort) {\n        try {\n            if ( listenSpec == null && !selectNewPort ) {\n                listenSpec = this.readPortFromConfigFile();\n            }\n            if ( listenSpec == null ) {\n                listenSpec = DEFAULT_LISTEN_INTERFACE + \":\" + DEFAULT_LISTEN_PORT;\n            }\n            final int colon = listenSpec.indexOf(':');\n            final InetSocketAddress addr;\n            if (colon < 0) {\n                addr = new InetSocketAddress(DEFAULT_LISTEN_INTERFACE, Integer.parseInt(listenSpec));\n            } else {\n                addr = new InetSocketAddress(listenSpec.substring(0, colon),\n                    Integer.parseInt(listenSpec.substring(colon + 1)));\n            }\n            if (!addr.isUnresolved()) {\n                return addr;\n            }\n            Main.error(\"Unknown host in '\" + listenSpec, null);\n        } catch (final NumberFormatException nfe) {\n            Main.error(\"Cannot parse port number from '\" + listenSpec + \"'\",\n                null);\n        }\n\n        return null;\n    }","id":34568,"modified_method":"private static InetSocketAddress getSocketAddress(String listenSpec) {\n        try {\n\n            final String address;\n            final int port;\n            if (listenSpec == null) {\n                address = DEFAULT_LISTEN_INTERFACE;\n                port = DEFAULT_LISTEN_PORT;\n            } else {\n                final int colon = listenSpec.indexOf(':');\n                if (colon < 0) {\n                    address = DEFAULT_LISTEN_INTERFACE;\n                    port = Integer.parseInt(listenSpec);\n                } else {\n                    address = listenSpec.substring(0, colon);\n                    port = Integer.parseInt(listenSpec.substring(colon + 1));\n                }\n            }\n\n            final InetSocketAddress addr = new InetSocketAddress(address, port);\n            if (!addr.isUnresolved()) {\n                return addr;\n            }\n\n            Main.error(\"Unknown host in '\" + listenSpec, null);\n        } catch (final NumberFormatException nfe) {\n            Main.error(\"Cannot parse port number from '\" + listenSpec + \"'\",\n                null);\n        }\n\n        return null;\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"/** prints a simple usage plus optional error message */\n    private static boolean doHelp(Map<String, String> args) {\n        if (args.remove(\"h\") != null) {\n            System.out.println(\"usage: \"\n                + Main.class.getName()\n                + \" [ start | stop | status ] [ -j adr ] [ -l loglevel ] [ -f logfile ] [ -c slinghome ] [ -i launchpadhome ] [ -a address ] [ -p port ] { -D n=v } [ -h ]\");\n\n            System.out.println(\"    start         listen for control connection (uses -j)\");\n            System.out.println(\"    stop          terminate running Apache Sling (uses -j)\");\n            System.out.println(\"    status        check whether Apache Sling is running (uses -j)\");\n            System.out.println(\"    -j adr        host and port to use for control connection in the format '[host:]port' (default localhost:63000)\");\n            System.out.println(\"    -l loglevel   the initial loglevel (0..4, FATAL, ERROR, WARN, INFO, DEBUG)\");\n            System.out.println(\"    -f logfile    the log file, \\\"-\\\" for stdout (default logs/error.log)\");\n            System.out.println(\"    -c slinghome  the sling context directory (default sling)\");\n            System.out.println(\"    -i launchpadhome  the launchpad directory (default slinghome)\");\n            System.out.println(\"    -a address    the interfact to bind to (use 0.0.0.0 for any)\");\n            System.out.println(\"    -p port       the port to listen to (default 8080)\");\n            System.out.println(\"    -r path       the root servlet context path for the http service (default is /)\");\n            System.out.println(\"    -D n=v        sets property n to value v\");\n            System.out.println(\"    -h            prints this usage message\");\n\n            return true;\n        }\n        return false;\n    }","id":34569,"modified_method":"/** prints a simple usage plus optional error message */\n    private static boolean doHelp(Map<String, String> args) {\n        if (args.remove(\"h\") != null) {\n            System.out.println(\"usage: \"\n                + Main.class.getName()\n                + \" [ start | stop | status ] [ -j adr ] [ -l loglevel ] [ -f logfile ] [ -c slinghome ] [ -i launchpadhome ] [ -a address ] [ -p port ] { -D n=v } [ -h ]\");\n\n            System.out.println(\"    start         listen for control connection (uses -j)\");\n            System.out.println(\"    stop          terminate running Apache Sling (uses -j)\");\n            System.out.println(\"    status        check whether Apache Sling is running (uses -j)\");\n            System.out.println(\"    -j adr        host and port to use for control connection in the format '[host:]port' (default 127.0.0.1:0)\");\n            System.out.println(\"    -l loglevel   the initial loglevel (0..4, FATAL, ERROR, WARN, INFO, DEBUG)\");\n            System.out.println(\"    -f logfile    the log file, \\\"-\\\" for stdout (default logs/error.log)\");\n            System.out.println(\"    -c slinghome  the sling context directory (default sling)\");\n            System.out.println(\"    -i launchpadhome  the launchpad directory (default slinghome)\");\n            System.out.println(\"    -a address    the interfact to bind to (use 0.0.0.0 for any)\");\n            System.out.println(\"    -p port       the port to listen to (default 8080)\");\n            System.out.println(\"    -r path       the root servlet context path for the http service (default is /)\");\n            System.out.println(\"    -D n=v        sets property n to value v\");\n            System.out.println(\"    -h            prints this usage message\");\n\n            return true;\n        }\n        return false;\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * The main entry point to the Sling Launcher Standalone Java Application.\n     * This method is generally only called by the Java VM to launch Sling.\n     *\n     * @param args The command line arguments supplied when starting the Sling\n     *            Launcher through the Java VM.\n     */\n    public static void main(final String[] args) {\n        final Map<String, String> rawArgs = parseCommandLine(args);\n\n        // support usage first\n        if (doHelp(rawArgs)) {\n            System.exit(0);\n        }\n\n        final Map<String, String> props = convertCommandLineArgs(rawArgs);\n        if (props == null) {\n            System.exit(1);\n        }\n\n        final Main main = new Main(props);\n\n        // check for control commands\n        int rc = main.doControlAction();\n        if (rc >= 0) {\n            System.exit(rc);\n        }\n\n        // finally start Sling\n        main.doStart();\n    }","id":34570,"modified_method":"/**\n     * The main entry point to the Sling Launcher Standalone Java Application.\n     * This method is generally only called by the Java VM to launch Sling.\n     *\n     * @param args The command line arguments supplied when starting the Sling\n     *            Launcher through the Java VM.\n     */\n    public static void main(final String[] args) {\n        final Map<String, String> rawArgs = parseCommandLine(args);\n\n        // support usage first\n        if (doHelp(rawArgs)) {\n            System.exit(0);\n        }\n\n        final Map<String, String> props = convertCommandLineArgs(rawArgs);\n        if (props == null) {\n            System.exit(1);\n        }\n\n        final Main main = new Main(props);\n\n        // check for control commands\n        int rc = main.doControlAction();\n        if (rc >= 0) {\n            main.terminateVM(rc);\n        }\n\n        // finally start Sling\n        main.doStart();\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * After instantiating this class, this method may be called to help with\n     * the communication with a running Sling instance. To setup this\n     * communication the configuration properties supplied to the constructor\n     * are evaluated as follows:\n     * <p>\n     * <table>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_SOCKET}<\/code><\/td>\n     * <td>Specifies the socket to use for the control connection. This\n     * specification is of the form <i>host:port<\/i> where the host can be a\n     * host name or IP Address and may be omitted (along with the separating\n     * colon) and port is just the numberic port number at which to listen. The\n     * default is <i>localhost:63000<\/i>. It is suggested to not use an\n     * externally accessible interface for security reasons because there is no\n     * added security on this control channel for now.<\/td>\n     * <\/tr>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_ACTION}<\/code><\/td>\n     * <td>The actual action to execute:\n     * <ul>\n     * <b>start<\/b> -- Start the listener on the configured socket and expect\n     * commands there. This action is useful only when launching the Sling\n     * application since this action helps manage a running system.\n     * <\/ul>\n     * <ul>\n     * <b>stop<\/b> -- Connects to the listener running on the configured socket\n     * and send the command to terminate the Sling Application. If this command\n     * is used, it is expected the Sling Application will not start.\n     * <\/ul>\n     * <ul>\n     * <b>status<\/b> -- Connects to the listener running on the configured\n     * socket and query about its status. If this command is used, it is\n     * expected the Sling Application will not start.\n     * <\/ul>\n     * <\/td>\n     * <\/tr>\n     * <\/table>\n     * <p>\n     * After this method has executed the <code>j<\/code> and\n     * {@link #PROP_CONTROL_ACTION} properties have been removed from the\n     * configuration properties.\n     * <p>\n     * While the {@link #doStart()} and {@link #doStop()} methods may be called\n     * multiple times this method should only be called once after creating this\n     * class's instance.\n     *\n     * @return An code indicating whether the Java VM is expected to be\n     *         terminated or not. If <code>-1<\/code> is returned, the VM should\n     *         continue as intended, maybe starting the Sling Application. This\n     *         code is returned if the start action (or no action at all) is\n     *         supplied. Otherwise the VM should terminate with the returned\n     *         code as its exit code. For the stop action, this will be zero. For\n     *         the status action, this will be a LSB compliant code for daemon\n     *         status check: 0 (application running), 1 (Programm Dead), 3\n     *         (Programm Not Running), 4 (Unknown Problem).\n     */\n    protected int doControlAction() {\n        final ControlAction action = getControlAction();\n        if (action != null) {\n            final ControlListener sl = new ControlListener(this,\n                commandLineArgs.remove(PROP_CONTROL_SOCKET), action == ControlAction.START);\n            switch (action) {\n                case START:\n                    sl.listen();\n                    break;\n                case STATUS:\n                    return sl.statusServer();\n                case STOP:\n                    sl.shutdownServer();\n                    return 0;\n            }\n        }\n\n        return -1;\n    }","id":34571,"modified_method":"/**\n     * After instantiating this class, this method may be called to help with\n     * the communication with a running Sling instance. To setup this\n     * communication the configuration properties supplied to the constructor\n     * are evaluated as follows:\n     * <p>\n     * <table>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_SOCKET}<\/code><\/td>\n     * <td>Specifies the socket to use for the control connection. This\n     * specification is of the form <i>host:port<\/i> where the host can be a\n     * host name or IP Address and may be omitted (along with the separating\n     * colon) and port is just the numberic port number at which to listen. The\n     * default is <i>localhost:63000<\/i>. It is suggested to not use an\n     * externally accessible interface for security reasons because there is no\n     * added security on this control channel for now.<\/td>\n     * <\/tr>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_ACTION}<\/code><\/td>\n     * <td>The actual action to execute:\n     * <ul>\n     * <b>start<\/b> -- Start the listener on the configured socket and expect\n     * commands there. This action is useful only when launching the Sling\n     * application since this action helps manage a running system.\n     * <\/ul>\n     * <ul>\n     * <b>stop<\/b> -- Connects to the listener running on the configured socket\n     * and send the command to terminate the Sling Application. If this command\n     * is used, it is expected the Sling Application will not start.\n     * <\/ul>\n     * <ul>\n     * <b>status<\/b> -- Connects to the listener running on the configured\n     * socket and query about its status. If this command is used, it is\n     * expected the Sling Application will not start.\n     * <\/ul>\n     * <\/td>\n     * <\/tr>\n     * <\/table>\n     * <p>\n     * After this method has executed the <code>j<\/code> and\n     * {@link #PROP_CONTROL_ACTION} properties have been removed from the\n     * configuration properties.\n     * <p>\n     * While the {@link #doStart()} and {@link #doStop()} methods may be called\n     * multiple times this method should only be called once after creating this\n     * class's instance.\n     *\n     * @return An code indicating whether the Java VM is expected to be\n     *         terminated or not. If <code>-1<\/code> is returned, the VM should\n     *         continue as intended, maybe starting the Sling Application. This\n     *         code is returned if the start action (or no action at all) is\n     *         supplied. Otherwise the VM should terminate with the returned\n     *         code as its exit code. For the stop action, this will be zero.\n     *         For the status action, this will be a LSB compliant code for\n     *         daemon status check: 0 (application running), 1 (Programm Dead),\n     *         3 (Programm Not Running), 4 (Unknown Problem).\n     * @see <a\n     *      href=\"http://refspecs.linuxbase.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html\">Init Script Actions<\/a>\n     *      for a definition of the LSB status codes\n     */\n    protected int doControlAction() {\n        final ControlAction action = getControlAction();\n        if (action != null) {\n            final ControlListener sl = new ControlListener(this,\n                commandLineArgs.remove(PROP_CONTROL_SOCKET));\n            switch (action) {\n                case START:\n                    if (!sl.listen()) {\n                        // assume service already running\n                        return 0;\n                    }\n                    break;\n                case STATUS:\n                    return sl.statusServer();\n                case STOP:\n                    return sl.shutdownServer();\n            }\n        }\n\n        return -1;\n    }","commit_id":"0e6edfda14555cc9d657eaa23e916f8966fae099","url":"https://github.com/apache/sling"},{"original_method":"private void sendCommand(String command) {\n        if (socketAddress != null) {\n            Socket socket = null;\n            try {\n                socket = new Socket();\n                socket.connect(socketAddress);\n                writeLine(socket, command);\n                String result = readLine(socket);\n                Main.info(\"Sent '\" + command + \"' to \" + socketAddress + \": \"\n                    + result, null);\n            } catch (ConnectException ce) {\n                Main.info(\"No Sling running at \" + socketAddress, null);\n            } catch (IOException ioe) {\n                Main.error(\"Failed sending '\" + command + \"' to \"\n                    + socketAddress, ioe);\n            } finally {\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        } else {\n            Main.info(\"No socket address to send '\" + command + \"' to\", null);\n        }\n    }","id":34572,"modified_method":"/**\n     * Sends the given command to the server indicated by the configured\n     * socket address and logs the reply.\n     *\n     * @param command The command to send\n     *\n     * @return A code indicating success of sending the command.\n     */\n    private int sendCommand(String command) {\n        if (socketAddress != null) {\n            Socket socket = null;\n            try {\n                socket = new Socket();\n                socket.connect(socketAddress);\n                writeLine(socket, command);\n                String result = readLine(socket);\n                Main.info(\"Sent '\" + command + \"' to \" + socketAddress + \": \"\n                    + result, null);\n                return 0; // LSB code for everything's fine\n            } catch (ConnectException ce) {\n                Main.info(\"No Sling running at \" + socketAddress, null);\n                return 3; // LSB code for programm not running\n            } catch (IOException ioe) {\n                Main.error(\"Failed sending '\" + command + \"' to \"\n                    + socketAddress, ioe);\n                return 1; // LSB code for programm dead\n            } finally {\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        } else {\n            Main.info(\"No socket address to send '\" + command + \"' to\", null);\n            return 4; // LSB code for unknown status\n        }\n    }","commit_id":"cf96e884c708d9b728d8a7ea945a5d1688f0ca7b","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Implements the client side of the control connection sending the command\n     * to check whether Sling is active.\n     */\n    void statusServer() {\n        sendCommand(COMMAND_STATUS);\n    }","id":34573,"modified_method":"/**\n     * Implements the client side of the control connection sending the command\n     * to check whether Sling is active.\n     */\n    int statusServer() {\n        return sendCommand(COMMAND_STATUS);\n    }","commit_id":"cf96e884c708d9b728d8a7ea945a5d1688f0ca7b","url":"https://github.com/apache/sling"},{"original_method":"private void doControlCommand() {\n        String commandSocketSpec = commandLineArgs.remove(\"j\");\n        if (\"j\".equals(commandSocketSpec)) {\n            commandSocketSpec = null;\n        }\n\n        ControlListener sl = new ControlListener(this, commandSocketSpec);\n        if (commandLineArgs.remove(ControlListener.COMMAND_STOP) != null) {\n            sl.shutdownServer();\n            System.exit(0);\n        } else if (commandLineArgs.remove(ControlListener.COMMAND_STATUS) != null) {\n            sl.statusServer();\n            System.exit(0);\n        } else if (commandLineArgs.remove(\"start\") != null) {\n            sl.listen();\n        }\n    }","id":34574,"modified_method":"private void doControlCommand() {\n        String commandSocketSpec = commandLineArgs.remove(\"j\");\n        if (\"j\".equals(commandSocketSpec)) {\n            commandSocketSpec = null;\n        }\n\n        ControlListener sl = new ControlListener(this, commandSocketSpec);\n        if (commandLineArgs.remove(ControlListener.COMMAND_STOP) != null) {\n            sl.shutdownServer();\n            System.exit(0);\n        } else if (commandLineArgs.remove(ControlListener.COMMAND_STATUS) != null) {\n            final int status = sl.statusServer();\n            System.exit(status);\n        } else if (commandLineArgs.remove(\"start\") != null) {\n            sl.listen();\n        }\n    }","commit_id":"cf96e884c708d9b728d8a7ea945a5d1688f0ca7b","url":"https://github.com/apache/sling"},{"original_method":"@Override\n\tpublic void addMonitorActions(ContextMenuAdapter qa, MonitoringInfoControl li, OsmandMapTileView view) {\n\t\tfinal boolean off = service.isActive();\n\t\tqa.item(off ? R.string.osmodroid_mode_off : R.string.osmodroid_mode_on\n)\n\t\t\t\t.icon(off ? R.drawable.monitoring_rec_inactive : R.drawable.monitoring_rec_big)\n\t\t\t\t.listen(new OnContextMenuClick() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onContextMenuClick(int itemId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString response;\n\t\t\t\t\t\t\tif (off) {\n\t\t\t\t\t\t\t\tresponse = service.activate(getUUID(app));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponse = service.deactivate();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapp.showToastMessage(response);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tapp.showToastMessage(app.getString(R.string.error_io_error) + \": \" + e.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t}).reg();\n\t}","id":34575,"modified_method":"@Override\n\tpublic void addMonitorActions(ContextMenuAdapter qa, MonitoringInfoControl li, final OsmandMapTileView view) {\n\t\tfinal boolean off = service.isActive();\n\t\tqa.item(off ? R.string.osmodroid_mode_off : R.string.osmodroid_mode_on)\n\t\t\t\t.icon(off ? R.drawable.monitoring_rec_inactive : R.drawable.monitoring_rec_big)\n\t\t\t\t.listen(new OnContextMenuClick() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onContextMenuClick(int itemId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString response;\n\t\t\t\t\t\t\tif (off) {\n\t\t\t\t\t\t\t\tresponse = service.activate(getUUID(app));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponse = service.deactivate();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapp.showToastMessage(response);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tapp.showToastMessage(app.getString(R.string.error_io_error) + \": \" + e.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t}).reg();\n\t\tqa.item(\"Test (send)\").\n\t\ticons(R.drawable.ic_action_grefresh_dark, R.drawable.ic_action_grefresh_light).\t\tlisten(new OnContextMenuClick() {\n\n\t\t\t@Override\n\t\t\tpublic void onContextMenuClick(int itemId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\ttry {\n\t\t\t\t\tString response = service.sendCoordinate(view.getLatitude(), view.getLongitude(), 0, 0, 0, 0);\n\t\t\t\t\tapp.showToastMessage(response);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tapp.showToastMessage(app.getString(R.string.error_io_error) + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t}).reg();\n\t}","commit_id":"1deeef93c90b278efc109072f1ec4e2a75e14ba7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void sendCoordinate(double lat, double lon, float hdop, float alt, float speed, float bearing) throws IOException {\n\t\tsendCommand(\"p|\"+lat+\":\"+lon+\":\"+hdop+\":\"+alt+\":\"+speed+\":\"+bearing);\n\t}","id":34576,"modified_method":"public String sendCoordinate(double lat, double lon, float hdop, float alt, float speed, float bearing) throws IOException {\n\t\treturn sendCommand(\"p|\"+lat+\":\"+lon+\":\"+hdop+\":\"+alt+\":\"+speed+\":\"+bearing);\n\t}","commit_id":"1deeef93c90b278efc109072f1ec4e2a75e14ba7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n   * Get the location of the rule file.\n   */\n  public List<String> getRuleFileName() {\n      List<String> ruleFiles = new ArrayList<String>();\n      ruleFiles.add(JLanguageTool.getDataBroker().getRulesDir() + \n              \"/\" + getShortName() + \"/\" + JLanguageTool.PATTERN_FILE);\n      if (getShortNameWithVariant().length() > 2) {\n          final String fileName = getShortName() + \"/\" +\n                  getShortNameWithVariant() + \n                  \"/\" + JLanguageTool.PATTERN_FILE;\n          if (JLanguageTool.getDataBroker().ruleFileExists(fileName)) {\n              ruleFiles.add(JLanguageTool.getDataBroker().getRulesDir() + \n                      \"/\" + fileName);\n          }\n      }\n      return ruleFiles;\n  }","id":34577,"modified_method":"/**\n   * Get the location of the rule file(s).\n   */\n  public List<String> getRuleFileName() {\n    final List<String> ruleFiles = new ArrayList<String>();\n    final ResourceDataBroker dataBroker = JLanguageTool.getDataBroker();\n    ruleFiles.add(dataBroker.getRulesDir()\n            + \"/\" + getShortName() + \"/\" + JLanguageTool.PATTERN_FILE);\n    if (getShortNameWithVariant().length() > 2) {\n      final String fileName = getShortName() + \"/\"\n              + getShortNameWithVariant()\n              + \"/\" + JLanguageTool.PATTERN_FILE;\n      if (dataBroker.ruleFileExists(fileName)) {\n        ruleFiles.add(dataBroker.getRulesDir() + \"/\" + fileName);\n      }\n    }\n    return ruleFiles;\n  }","commit_id":"93404746bae665beddf94716a0c2c06761da34e5","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Languages that have variants need to overwrite this to select their most common variant.\n   */\n  public Language getDefaultVariant() {\n    return null;\n  }","id":34578,"modified_method":"/**\n   * Languages that have variants need to overwrite this to select their most common variant.\n   * @return default variant or <code>null<\/code>\n   * @since 1.8\n   */\n  public Language getDefaultVariant() {\n    return null;\n  }","commit_id":"93404746bae665beddf94716a0c2c06761da34e5","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\r\n    public void testGetLanguageForShortName() {\r\n        assertEquals(Language.AMERICAN_ENGLISH, Language.getLanguageForShortName(\"en-US\"));\r\n        assertEquals(Language.GERMAN, Language.getLanguageForShortName(\"de\"));\r\n    }","id":34579,"modified_method":"@Test\r\n    public void testGetLanguageForShortName() {\r\n        assertEquals(Language.AMERICAN_ENGLISH, Language.getLanguageForShortName(\"en-US\"));\r\n        assertEquals(Language.GERMAN, Language.getLanguageForShortName(\"de\"));\r\n        assertEquals(null, Language.getLanguageForShortName(\"xy\"));\r\n    }","commit_id":"93404746bae665beddf94716a0c2c06761da34e5","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\r\n    public void testGetLanguageForName() {\r\n        assertEquals(Language.AMERICAN_ENGLISH, Language.getLanguageForName(\"English (US)\"));\r\n        assertEquals(Language.GERMAN, Language.getLanguageForName(\"German\"));\r\n    }","id":34580,"modified_method":"@Test\r\n    public void testGetLanguageForName() {\r\n        assertEquals(Language.AMERICAN_ENGLISH, Language.getLanguageForName(\"English (US)\"));\r\n        assertEquals(Language.GERMAN, Language.getLanguageForName(\"German\"));\r\n        assertEquals(null, Language.getLanguageForName(\"Foobar\"));\r\n    }","commit_id":"93404746bae665beddf94716a0c2c06761da34e5","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\r\n  public List<String> tokenize(String text) {\r\n    init();\r\n    final ArrayList<String> ret = new ArrayList<String>();\r\n    String result;\r\n    try {\r\n      result = seg.split(chinesdJF.chineseFan2Jan(text)).getFinalResult();\r\n    } catch (Exception e) {\r\n      // Occasionally, the Chinese tokenization/segment component throws NullPointerException or\r\n      // ArrayIndexOutOfBoundsException, due to some internal bugs of ictclas4j. The reasons of the\r\n      // bugs and how to resolve them are unknown now. In this case, we can just bypass the sentence\r\n      // and return a empty List.\r\n      return ret;\r\n    }\r\n    final String[] list = result.split(\" \");\r\n\r\n    for (int i = 0; i < list.length; i++) {\r\n      ret.add(list[i]);\r\n    }\r\n    return ret;\r\n  }","id":34581,"modified_method":"@Override\r\n  public List<String> tokenize(String text) {\r\n    init();\r\n    final String result;\r\n    try {\r\n      result = seg.split(chinesdJF.chineseFan2Jan(text)).getFinalResult();\r\n    } catch (Exception e) {\r\n      // Occasionally, the Chinese tokenization/segment component throws NullPointerException or\r\n      // ArrayIndexOutOfBoundsException, due to some internal bugs of ictclas4j. The reasons of the\r\n      // bugs and how to resolve them are unknown now. In this case, we can just bypass the sentence\r\n      // and return a empty List.\r\n      return new ArrayList<String>();\r\n    }\r\n    final String[] list = result.split(\" \");\r\n    return Arrays.asList(list);\r\n  }","commit_id":"d69af42aab3ef5bdc19a23af0c504f47e3fdd0cc","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void init() {\r\n    if (chinesdJF == null) {\r\n      chinesdJF = CJFBeanFactory.getChineseJF();\r\n    }\r\n    if (seg == null) {\r\n      InputStream coreDictIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(\r\n          \"/zh/coreDict.dct\");\r\n      InputStream bigramDictIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(\r\n          \"/zh/BigramDict.dct\");\r\n      InputStream personTaggerDctIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(\r\n          \"/zh/nr.dct\");\r\n      InputStream personTaggerCtxIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(\r\n          \"/zh/nr.ctx\");\r\n      InputStream transPersonTaggerDctIn = JLanguageTool.getDataBroker()\r\n          .getFromResourceDirAsStream(\"/zh/tr.dct\");\r\n      InputStream transPersonTaggerCtxIn = JLanguageTool.getDataBroker()\r\n          .getFromResourceDirAsStream(\"/zh/tr.ctx\");\r\n      InputStream placeTaggerDctIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(\r\n          \"/zh/ns.dct\");\r\n      InputStream placeTaggerCtxIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(\r\n          \"/zh/ns.ctx\");\r\n      InputStream lexTaggerCtxIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(\r\n          \"/zh/lexical.ctx\");\r\n      seg = new SegTag(1, coreDictIn, bigramDictIn, personTaggerDctIn, personTaggerCtxIn,\r\n          transPersonTaggerDctIn, transPersonTaggerCtxIn, placeTaggerDctIn, placeTaggerCtxIn,\r\n          lexTaggerCtxIn);\r\n    }\r\n  }","id":34582,"modified_method":"private void init() {\r\n    if (chinesdJF == null) {\r\n      chinesdJF = CJFBeanFactory.getChineseJF();\r\n    }\r\n    if (seg == null) {\r\n      final ResourceDataBroker dataBroker = JLanguageTool.getDataBroker();\r\n      final InputStream coreDictIn = dataBroker.getFromResourceDirAsStream(\"/zh/coreDict.dct\");\r\n      final InputStream bigramDictIn = dataBroker.getFromResourceDirAsStream(\"/zh/BigramDict.dct\");\r\n      final InputStream personTaggerDctIn = dataBroker.getFromResourceDirAsStream(\"/zh/nr.dct\");\r\n      final InputStream personTaggerCtxIn = dataBroker.getFromResourceDirAsStream(\"/zh/nr.ctx\");\r\n      final InputStream transPersonTaggerDctIn = dataBroker.getFromResourceDirAsStream(\"/zh/tr.dct\");\r\n      final InputStream transPersonTaggerCtxIn = dataBroker.getFromResourceDirAsStream(\"/zh/tr.ctx\");\r\n      final InputStream placeTaggerDctIn = dataBroker.getFromResourceDirAsStream(\"/zh/ns.dct\");\r\n      final InputStream placeTaggerCtxIn = dataBroker.getFromResourceDirAsStream(\"/zh/ns.ctx\");\r\n      final InputStream lexTaggerCtxIn = dataBroker.getFromResourceDirAsStream(\"/zh/lexical.ctx\");\r\n      seg = new SegTag(1, coreDictIn, bigramDictIn, personTaggerDctIn, personTaggerCtxIn,\r\n          transPersonTaggerDctIn, transPersonTaggerCtxIn, placeTaggerDctIn, placeTaggerCtxIn,\r\n          lexTaggerCtxIn);\r\n    }\r\n  }","commit_id":"d69af42aab3ef5bdc19a23af0c504f47e3fdd0cc","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private boolean skipCountryVariant(Language lang) {\n    final String shortName = lang.getShortNameWithVariant();\n    if (shortName.contains(\"-\") && !shortName.endsWith(\"-ANY\")) {\n      final String variantSpecificRuleFile = lang.getShortName() + \"/\" + shortName\n              + \"/\" + JLanguageTool.PATTERN_FILE;\n      return !JLanguageTool.getDataBroker().ruleFileExists(variantSpecificRuleFile);\n    }\n    return false;\n  }","id":34583,"modified_method":"private boolean skipCountryVariant(Language lang) {\n    final ResourceDataBroker dataBroker = JLanguageTool.getDataBroker();\n    return !dataBroker.ruleFileExists(getGrammarFileName(lang));\n  }","commit_id":"dc335d9c7adca762581d4b2f311aca197ad40edc","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/** To be called from language modules. */\n  protected void runGrammarRulesFromXmlTest() throws IOException {\n    for (final Language lang : Language.REAL_LANGUAGES) {\n      if (skipCountryVariant(lang)) {\n        System.out.println(\"Skipping \" + lang + \" because there are no specific rules for that variant\");\n        continue;\n      }\n      runTestForLanguage(lang);\n    }\n  }","id":34584,"modified_method":"/** To be called from language modules. */\n  protected void runGrammarRulesFromXmlTest() throws IOException {\n    for (final Language lang : Language.REAL_LANGUAGES) {\n      if (skipCountryVariant(lang)) {\n        System.out.println(\"Skipping \" + lang + \" because there are no specific rules for that variant\");\n        continue;\n      }\n      validatePatternFile(lang);\n      runTestForLanguage(lang);\n    }\n  }","commit_id":"dc335d9c7adca762581d4b2f311aca197ad40edc","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Validate XML file using the given XSD. Throws an exception on error  \n   * @param filename File to validate.\n   * @param xmlSchema Schema to use.\n   * @throws IOException Thrown on error.\n   */\n  public final void validate(String filename, String xmlSchema) throws IOException {\n    try {\n      validateInternal(this.getClass().getResourceAsStream(filename), \n          this.getClass().getResource(xmlSchema));\n    } catch (Exception e) {\n      throw new IOException(\"Cannot load or parse '\" + filename + \"'\", e);\n    }\n  }","id":34585,"modified_method":"/**\n   * Validate XML file using the given XSD. Throws an exception on error  \n   * @param filename File in classpath to validate.\n   * @param xmlSchema Schema to use.\n   * @throws IOException Thrown on error.\n   */\n  public final void validate(String filename, String xmlSchema) throws IOException {\n    try {\n      final InputStream xmlStream = this.getClass().getResourceAsStream(filename);\n      if (xmlStream == null) {\n        throw new IOException(\"Not found in classpath: \" + filename);\n      }\n      final URL schemaStream = this.getClass().getResource(xmlSchema);\n      if (schemaStream == null) {\n        throw new IOException(\"Not found in classpath: \" + xmlSchema);\n      }\n      validateInternal(xmlStream, schemaStream);\n    } catch (Exception e) {\n      throw new IOException(\"Cannot load or parse '\" + filename + \"'\", e);\n    }\n  }","commit_id":"dc335d9c7adca762581d4b2f311aca197ad40edc","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public void annotate(Annotation annotation){\n    try {\n      if (!annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n        log.error(\"this coreference resolution system requires SentencesAnnotation!\");\n        return;\n      }\n\n      if (hasSpeakerAnnotations(annotation)) {\n        annotation.set(CoreAnnotations.UseMarkedDiscourseAnnotation.class, true);\n      }\n\n      corefSystem.annotate(annotation);\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","id":34586,"modified_method":"@Override\n  public void annotate(Annotation annotation){\n    try {\n      if (!annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n        log.error(\"this coreference resolution system requires SentencesAnnotation!\");\n        return;\n      }\n\n      if (hasSpeakerAnnotations(annotation)) {\n        annotation.set(CoreAnnotations.UseMarkedDiscourseAnnotation.class, true);\n      }\n\n      // choose between hybrid mode or statistical mode\n      if (COREF_MODE.equals(HYBRID_MODE)) {\n        Document corefDoc = hcorefSystem.docMaker.makeDocument(annotation);\n        Map<Integer, CorefChain> result = hcorefSystem.coref(corefDoc);\n        annotation.set(CorefCoreAnnotations.CorefChainAnnotation.class, result);\n        // for backward compatibility\n        if(OLD_FORMAT) annotateOldFormat(result, corefDoc);\n      } else if (COREF_MODE.equals(STATISTICAL_MODE)) {\n        scorefSystem.annotate(annotation);\n      } else {\n        log.error(\"invalid selection for coreference mode!\");\n        throw new RuntimeException() ;\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public CorefAnnotator(Properties props) {\n    this.props = props;\n    try {\n      corefSystem = new CorefSystem(props);\n      oldFormat = Boolean.parseBoolean(props.getProperty(\"oldCorefFormat\", \"false\"));\n    } catch (Exception e) {\n      log.error(\"cannot create CorefAnnotator!\");\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }","id":34587,"modified_method":"public CorefAnnotator(Properties props) {\n    this.props = props;\n    try {\n      COREF_MODE = props.getProperty(\"coref.mode\", STATISTICAL_MODE);\n      if (COREF_MODE.equals(HYBRID_MODE)) {\n        hcorefSystem = new HybridCorefSystem(props);\n        scorefSystem = null;\n      } else if (COREF_MODE.equals(STATISTICAL_MODE)) {\n        // create corefSystem for statistical\n        scorefSystem = StatisticalCorefSystem.fromProps(props);\n        hcorefSystem = null;\n      } else {\n        scorefSystem = null;\n        hcorefSystem = null;\n      }\n      OLD_FORMAT = Boolean.parseBoolean(props.getProperty(\"oldCorefFormat\", \"false\"));\n    } catch (Exception e) {\n      log.error(\"cannot create CorefAnnotator!\");\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  @Override\n  public Set<Class<? extends CoreAnnotation>> requires() {\n    Set<Class<? extends CoreAnnotation>> requirements = new HashSet<>(Arrays.asList(\n        CoreAnnotations.TextAnnotation.class,\n        CoreAnnotations.TokensAnnotation.class,\n        CoreAnnotations.CharacterOffsetBeginAnnotation.class,\n        CoreAnnotations.CharacterOffsetEndAnnotation.class,\n        CoreAnnotations.IndexAnnotation.class,\n        CoreAnnotations.ValueAnnotation.class,\n        CoreAnnotations.SentencesAnnotation.class,\n        CoreAnnotations.SentenceIndexAnnotation.class,\n        CoreAnnotations.PartOfSpeechAnnotation.class,\n        CoreAnnotations.LemmaAnnotation.class,\n        CoreAnnotations.NamedEntityTagAnnotation.class,\n        CorefCoreAnnotations.CorefMentionsAnnotation.class,\n        SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class,\n        SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class\n        ));\n    if (CorefProperties.mdType(this.props) != CorefProperties.MentionDetectionType.DEPENDENCY) {\n      requirements.add(TreeCoreAnnotations.TreeAnnotation.class);\n      requirements.add(CoreAnnotations.CategoryAnnotation.class);\n    }\n    return Collections.unmodifiableSet(requirements);\n  }","id":34588,"modified_method":"@SuppressWarnings(\"unchecked\")\n  @Override\n  public Set<Class<? extends CoreAnnotation>> requires() {\n    Set<Class<? extends CoreAnnotation>> requirements = new HashSet<>(Arrays.asList(\n        CoreAnnotations.TextAnnotation.class,\n        CoreAnnotations.TokensAnnotation.class,\n        CoreAnnotations.CharacterOffsetBeginAnnotation.class,\n        CoreAnnotations.CharacterOffsetEndAnnotation.class,\n        CoreAnnotations.IndexAnnotation.class,\n        CoreAnnotations.ValueAnnotation.class,\n        CoreAnnotations.SentencesAnnotation.class,\n        CoreAnnotations.SentenceIndexAnnotation.class,\n        CoreAnnotations.ParagraphAnnotation.class,\n        CoreAnnotations.PartOfSpeechAnnotation.class,\n        CoreAnnotations.LemmaAnnotation.class,\n        CoreAnnotations.NamedEntityTagAnnotation.class,\n        CorefCoreAnnotations.CorefMentionsAnnotation.class,\n        CoreAnnotations.UtteranceAnnotation.class,\n        CoreAnnotations.SpeakerAnnotation.class,\n        SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class,\n        SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class\n        ));\n    if (CorefProperties.getMDType(this.props) != CorefProperties.MentionDetectionType.DEPENDENCY) {\n      requirements.add(TreeCoreAnnotations.TreeAnnotation.class);\n      requirements.add(CoreAnnotations.CategoryAnnotation.class);\n    }\n    return Collections.unmodifiableSet(requirements);\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Set<Class<? extends CoreAnnotation>> requirementsSatisfied() {\n    return Collections.singleton(CorefCoreAnnotations.CorefChainAnnotation.class);\n  }","id":34589,"modified_method":"@Override\n  public Set<Class<? extends CoreAnnotation>> requirementsSatisfied() {\n    switch (COREF_MODE) {\n      case STATISTICAL_MODE:\n      case HYBRID_MODE:\n        return Collections.singleton(CorefCoreAnnotations.CorefChainAnnotation.class);\n      default:\n        throw new IllegalStateException(\"Unknown requirementsSatisfied() for coref mode: \" + COREF_MODE);\n    }\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String modelPath(Properties props) {\n    String defaultPath = \"edu/stanford/nlp/models/coref/neural/\" +\n        (CorefProperties.getLanguage(props) == Locale.CHINESE ? \"chinese\" : \"english\") +\n        (CorefProperties.conll(props) ? \"-model-conll\" : \"-model-default\") + \".ser.gz\";\n    return PropertiesUtils.getString(props, \"coref.neural.modelPath\", defaultPath);\n  }","id":34590,"modified_method":"public static String modelPath(Properties props) {\n    String defaultPath = \"edu/stanford/nlp/models/coref/neural/\" +\n        (CorefProperties.getLanguage(props) == Locale.CHINESE ? \"chinese\" : \"english\") +\n        (CorefProperties.conll(props) ? \"-model-conll\" : \"-model-conll\") + \".ser.gz\";\n    return PropertiesUtils.getString(props, \"coref.neural.modelPath\", defaultPath);\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String clusteringModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.clusteringModel\",\n        \"edu/stanford/nlp/models/scoref/clustering_model.ser\");\n  }","id":34591,"modified_method":"public static String clusteringModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.clusteringModel\",\n        \"edu/stanford/nlp/models/coref/statistical/clustering_model.ser.gz\");\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String rankingModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.rankingModel\",\n        \"edu/stanford/nlp/models/scoref/ranking_model.ser.gz\");\n  }","id":34592,"modified_method":"public static String rankingModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.rankingModel\",\n        \"edu/stanford/nlp/models/coref/statistical/ranking_model.ser.gz\");\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String classificationModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.classificationModel\",\n        \"edu/stanford/nlp/models/scoref/classification_model.ser.gz\");\n  }","id":34593,"modified_method":"public static String classificationModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.classificationModel\",\n        \"edu/stanford/nlp/models/coref/statistical/classification_model.ser.gz\");\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String anaphoricityModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.anaphoricityModel\",\n        \"edu/stanford/nlp/models/scoref/anaphoricity_model.ser.gz\");\n  }","id":34594,"modified_method":"public static String anaphoricityModelPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.anaphoricityModel\",\n        \"edu/stanford/nlp/models/coref/statistical/anaphoricity_model.ser.gz\");\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static String wordCountsPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.wordCounts\",\n        \"edu/stanford/nlp/models/scoref/word_counts.ser.gz\");\n  }","id":34595,"modified_method":"public static String wordCountsPath(Properties props) {\n    return PropertiesUtils.getString(props, \"coref.wordCounts\",\n        \"edu/stanford/nlp/models/coref/statistical/word_counts.ser.gz\");\n  }","commit_id":"f726c417fdeb90ff8b756e088c69472944eacec1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext stratifiedContext, VariantContext vc, Genotype g) {\n        Double ratio = annotateSNP(stratifiedContext, vc, g);\n        if (ratio == null)\n            return null;\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.2f\", ratio.doubleValue()));\n        return map;\n\n    }","id":34596,"modified_method":"public void annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext stratifiedContext, VariantContext vc, Genotype g, final GenotypeBuilder gb) {\n        Double ratio = annotateSNP(stratifiedContext, vc, g);\n        if (ratio == null)\n            return;\n\n        gb.attribute(getKeyNames().get(0), Double.valueOf(String.format(\"%.2f\", ratio.doubleValue())));\n    }","commit_id":"76fbb0f2e4dce090f5c334d8e7daaf395dd9ae59","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext stratifiedContext, VariantContext vc, Genotype g) {\n        if ( g == null || !g.isCalled() )\n            return null;\n\n        if ( vc.isSNP() )\n            return annotateSNP(stratifiedContext, vc);\n        if ( vc.isIndel() )\n            return annotateIndel(stratifiedContext, vc);\n\n        return null;\n    }","id":34597,"modified_method":"public void annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext stratifiedContext, VariantContext vc, Genotype g, GenotypeBuilder gb) {\n        if ( g == null || !g.isCalled() )\n            return;\n\n        if ( vc.isSNP() )\n            annotateSNP(stratifiedContext, vc, gb);\n        else if ( vc.isIndel() )\n            annotateIndel(stratifiedContext, vc, gb);\n    }","commit_id":"76fbb0f2e4dce090f5c334d8e7daaf395dd9ae59","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<String,Object> annotateSNP(AlignmentContext stratifiedContext, VariantContext vc) {\n\n        if ( ! stratifiedContext.hasBasePileup() )\n            return null;\n\n        HashMap<Byte, Integer> alleleCounts = new HashMap<Byte, Integer>();\n        for ( Allele allele : vc.getAlleles() )\n            alleleCounts.put(allele.getBases()[0], 0);\n\n        ReadBackedPileup pileup = stratifiedContext.getBasePileup();\n        for ( PileupElement p : pileup ) {\n            if ( alleleCounts.containsKey(p.getBase()) )\n                alleleCounts.put(p.getBase(), alleleCounts.get(p.getBase())+1);\n        }\n\n        // we need to add counts in the correct order\n        int[] counts = new int[alleleCounts.size()];\n        counts[0] = alleleCounts.get(vc.getReference().getBases()[0]);\n        for (int i = 0; i < vc.getAlternateAlleles().size(); i++)\n            counts[i+1] = alleleCounts.get(vc.getAlternateAllele(i).getBases()[0]);\n\n        return toADAnnotation(counts);\n    }","id":34598,"modified_method":"private void annotateSNP(AlignmentContext stratifiedContext, VariantContext vc, GenotypeBuilder gb) {\n\n        if ( ! stratifiedContext.hasBasePileup() )\n            return;\n\n        HashMap<Byte, Integer> alleleCounts = new HashMap<Byte, Integer>();\n        for ( Allele allele : vc.getAlleles() )\n            alleleCounts.put(allele.getBases()[0], 0);\n\n        ReadBackedPileup pileup = stratifiedContext.getBasePileup();\n        for ( PileupElement p : pileup ) {\n            if ( alleleCounts.containsKey(p.getBase()) )\n                alleleCounts.put(p.getBase(), alleleCounts.get(p.getBase())+1);\n        }\n\n        // we need to add counts in the correct order\n        int[] counts = new int[alleleCounts.size()];\n        counts[0] = alleleCounts.get(vc.getReference().getBases()[0]);\n        for (int i = 0; i < vc.getAlternateAlleles().size(); i++)\n            counts[i+1] = alleleCounts.get(vc.getAlternateAllele(i).getBases()[0]);\n\n        gb.AD(counts);\n    }","commit_id":"76fbb0f2e4dce090f5c334d8e7daaf395dd9ae59","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<String,Object> annotateIndel(AlignmentContext stratifiedContext, VariantContext vc) {\n\n        if ( ! stratifiedContext.hasBasePileup() )\n            return null;\n\n        ReadBackedPileup pileup = stratifiedContext.getBasePileup();\n        if ( pileup == null )\n            return null;\n\n        final HashMap<String, Integer> alleleCounts = new HashMap<String, Integer>();\n        alleleCounts.put(REF_ALLELE, 0);\n        final Allele refAllele = vc.getReference();\n\n        for ( Allele allele : vc.getAlternateAlleles() ) {\n\n            if ( allele.isNoCall() ) {\n                continue; // this does not look so good, should we die???\n            }\n\n            alleleCounts.put(getAlleleRepresentation(allele), 0);\n        }\n\n        for ( PileupElement p : pileup ) {\n            if ( p.isBeforeInsertion() ) {\n\n                final String b = p.getEventBases();\n                if ( alleleCounts.containsKey(b) ) {\n                    alleleCounts.put(b, alleleCounts.get(b)+1);\n                }\n\n            } else if ( p.isBeforeDeletionStart() ) {\n                    if ( p.getEventLength() == refAllele.length() ) {\n                        // this is indeed the deletion allele recorded in VC\n                        final String b = DEL;\n                        if ( alleleCounts.containsKey(b) ) {\n                            alleleCounts.put(b, alleleCounts.get(b)+1);\n                        }\n                    }\n            } else if ( p.getRead().getAlignmentEnd() > vc.getStart() ) {\n                alleleCounts.put(REF_ALLELE, alleleCounts.get(REF_ALLELE)+1);\n            }\n        }\n\n        int[] counts = new int[alleleCounts.size()];\n        counts[0] = alleleCounts.get(REF_ALLELE);\n        for (int i = 0; i < vc.getAlternateAlleles().size(); i++)\n            counts[i+1] = alleleCounts.get( getAlleleRepresentation(vc.getAlternateAllele(i)) );\n\n        return toADAnnotation(counts);\n    }","id":34599,"modified_method":"private void annotateIndel(AlignmentContext stratifiedContext, VariantContext vc, GenotypeBuilder gb) {\n        if ( ! stratifiedContext.hasBasePileup() )\n            return;\n\n        ReadBackedPileup pileup = stratifiedContext.getBasePileup();\n        if ( pileup == null )\n            return;\n\n        final HashMap<String, Integer> alleleCounts = new HashMap<String, Integer>();\n        alleleCounts.put(REF_ALLELE, 0);\n        final Allele refAllele = vc.getReference();\n\n        for ( Allele allele : vc.getAlternateAlleles() ) {\n\n            if ( allele.isNoCall() ) {\n                continue; // this does not look so good, should we die???\n            }\n\n            alleleCounts.put(getAlleleRepresentation(allele), 0);\n        }\n\n        for ( PileupElement p : pileup ) {\n            if ( p.isBeforeInsertion() ) {\n\n                final String b = p.getEventBases();\n                if ( alleleCounts.containsKey(b) ) {\n                    alleleCounts.put(b, alleleCounts.get(b)+1);\n                }\n\n            } else if ( p.isBeforeDeletionStart() ) {\n                    if ( p.getEventLength() == refAllele.length() ) {\n                        // this is indeed the deletion allele recorded in VC\n                        final String b = DEL;\n                        if ( alleleCounts.containsKey(b) ) {\n                            alleleCounts.put(b, alleleCounts.get(b)+1);\n                        }\n                    }\n            } else if ( p.getRead().getAlignmentEnd() > vc.getStart() ) {\n                alleleCounts.put(REF_ALLELE, alleleCounts.get(REF_ALLELE)+1);\n            }\n        }\n\n        int[] counts = new int[alleleCounts.size()];\n        counts[0] = alleleCounts.get(REF_ALLELE);\n        for (int i = 0; i < vc.getAlternateAlleles().size(); i++)\n            counts[i+1] = alleleCounts.get( getAlleleRepresentation(vc.getAlternateAllele(i)) );\n\n        gb.AD(counts);\n    }","commit_id":"76fbb0f2e4dce090f5c334d8e7daaf395dd9ae59","url":"https://github.com/broadgsa/gatk"},{"original_method":"public abstract Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker,\n                                                 ReferenceContext ref, AlignmentContext stratifiedContext, VariantContext vc, Genotype g);","id":34600,"modified_method":"public abstract void annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker,\n                                  ReferenceContext ref, AlignmentContext stratifiedContext,\n                                  VariantContext vc, Genotype g, GenotypeBuilder gb );","commit_id":"76fbb0f2e4dce090f5c334d8e7daaf395dd9ae59","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker,\n                                        AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext context, VariantContext vc, Genotype g) {\n        if ( g == null || !g.isCalled() )\n            return null;\n\n        int mq0 = 0;\n        if ( context.hasBasePileup() ) {\n            final ReadBackedPileup pileup = context.getBasePileup();\n            for (PileupElement p : pileup ) {\n                if ( p.getMappingQual() == 0 )\n                    mq0++;\n            }\n        }\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%d\", mq0));\n        return map;\n    }","id":34601,"modified_method":"public void annotate(RefMetaDataTracker tracker,\n                         AnnotatorCompatibleWalker walker, ReferenceContext ref, AlignmentContext context,\n                         VariantContext vc, Genotype g, GenotypeBuilder gb) {\n        if ( g == null || !g.isCalled() )\n            return;\n\n        int mq0 = 0;\n        if ( context.hasBasePileup() ) {\n            final ReadBackedPileup pileup = context.getBasePileup();\n            for (PileupElement p : pileup ) {\n                if ( p.getMappingQual() == 0 )\n                    mq0++;\n            }\n        }\n\n        gb.attribute(getKeyNames().get(0), mq0);\n    }","commit_id":"76fbb0f2e4dce090f5c334d8e7daaf395dd9ae59","url":"https://github.com/broadgsa/gatk"},{"original_method":"private GenotypesContext annotateGenotypes(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( requestedGenotypeAnnotations.size() == 0 )\n            return vc.getGenotypes();\n\n        GenotypesContext genotypes = GenotypesContext.create(vc.getNSamples());\n        for ( final Genotype genotype : vc.getGenotypes() ) {\n            AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n            if ( context == null ) {\n                genotypes.add(genotype);\n                continue;\n            }\n\n            Map<String, Object> genotypeAnnotations = new HashMap<String, Object>(genotype.getExtendedAttributes());\n            for ( GenotypeAnnotation annotation : requestedGenotypeAnnotations ) {\n                Map<String, Object> result = annotation.annotate(tracker, walker, ref, context, vc, genotype);\n                if ( result != null )\n                    genotypeAnnotations.putAll(result);\n            }\n            genotypes.add(new GenotypeBuilder(genotype).attributes(genotypeAnnotations).make());\n        }\n\n        return genotypes;\n    }","id":34602,"modified_method":"private GenotypesContext annotateGenotypes(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( requestedGenotypeAnnotations.isEmpty() )\n            return vc.getGenotypes();\n\n        final GenotypesContext genotypes = GenotypesContext.create(vc.getNSamples());\n        for ( final Genotype genotype : vc.getGenotypes() ) {\n            AlignmentContext context = stratifiedContexts.get(genotype.getSampleName());\n\n            if ( context == null ) {\n                genotypes.add(genotype);\n            } else {\n                final GenotypeBuilder gb = new GenotypeBuilder(genotype);\n                for ( final GenotypeAnnotation annotation : requestedGenotypeAnnotations ) {\n                    annotation.annotate(tracker, walker, ref, context, vc, genotype, gb);\n                }\n                genotypes.add(gb.make());\n            }\n        }\n\n        return genotypes;\n    }","commit_id":"76fbb0f2e4dce090f5c334d8e7daaf395dd9ae59","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n   * Set the properties to the paths they appear at on the servlet.\n   * See build.xml for where these paths get copied.\n   * @throws ServletException Thrown by the implementation\n   */\n  public void init()  throws ServletException {\n    Properties commonProps = new Properties() {{\n      setProperty(\"depparse.extradependencies\", \"ref_only_uncollapsed\");\n      setProperty(\"openie.splitter.threshold\", \"0.10\");\n      setProperty(\"openie.optimze_for\", \"GENERAL\");\n      setProperty(\"openie.ignoreaffinity\", \"false\");\n      setProperty(\"openie.max_entailments_per_clause\", \"1000\");\n      setProperty(\"openie.triple.strict\", \"true\");\n    }};\n    try {\n      String dataDir = getServletContext().getRealPath(\"/WEB-INF/data\");\n      System.setProperty(\"de.jollyday.config\",\n          getServletContext().getRealPath(\"/WEB-INF/classes/holidays/jollyday.properties\"));\n      commonProps.setProperty(\"pos.model\", dataDir + \"/english-left3words-distsim.tagger\");\n      commonProps.setProperty(\"ner.model\", dataDir + \"/english.all.3class.distsim.crf.ser.gz,\" + dataDir + \"/english.conll.4class.distsim.crf.ser.gz,\" + dataDir + \"/english.muc.7class.distsim.crf.ser.gz\");\n      commonProps.setProperty(\"depparse.model\", dataDir + \"/english_SD.gz\");\n      commonProps.setProperty(\"parse.model\", dataDir + \"/englishPCFG.ser.gz\");\n      commonProps.setProperty(\"sutime.rules\", dataDir + \"/defs.sutime.txt,\" + dataDir + \"/english.sutime.txt,\" + dataDir + \"/english.hollidays.sutime.txt\");\n      commonProps.setProperty(\"openie.splitter.model\", dataDir + \"/clauseSplitterModel.ser.gz\");\n      commonProps.setProperty(\"openie.affinity_models\", dataDir);\n    } catch (NullPointerException e) {\n      System.err.println(\"Could not load servlet context. Are you on the command line?\");\n    }\n    if (this.pipeline == null) {\n      Properties fullProps = new Properties(commonProps);\n      fullProps.setProperty(\"annotators\", \"tokenize,ssplit,pos,lemma,depparse,ner,natlog,openie\");\n      this.pipeline = new StanfordCoreNLP(fullProps);\n    }\n    if (this.backoff == null) {\n      Properties backoffProps = new Properties(commonProps);\n      backoffProps.setProperty(\"annotators\", \"parse,natlog,openie\");\n      backoffProps.setProperty(\"enforceRequirements\", \"false\");\n      this.backoff = new StanfordCoreNLP(backoffProps);\n\n    }\n  }","id":34603,"modified_method":"/**\n   * Set the properties to the paths they appear at on the servlet.\n   * See build.xml for where these paths get copied.\n   * @throws ServletException Thrown by the implementation\n   */\n  public void init()  throws ServletException {\n    Properties commonProps = new Properties() {{\n      setProperty(\"depparse.extradependencies\", \"ref_only_uncollapsed\");\n      setProperty(\"parse.extradependencies\", \"ref_only_uncollapsed\");\n      setProperty(\"openie.splitter.threshold\", \"0.10\");\n      setProperty(\"openie.optimze_for\", \"GENERAL\");\n      setProperty(\"openie.ignoreaffinity\", \"false\");\n      setProperty(\"openie.max_entailments_per_clause\", \"1000\");\n      setProperty(\"openie.triple.strict\", \"true\");\n    }};\n    try {\n      String dataDir = getServletContext().getRealPath(\"/WEB-INF/data\");\n      System.setProperty(\"de.jollyday.config\",\n          getServletContext().getRealPath(\"/WEB-INF/classes/holidays/jollyday.properties\"));\n      commonProps.setProperty(\"pos.model\", dataDir + \"/english-left3words-distsim.tagger\");\n      commonProps.setProperty(\"ner.model\", dataDir + \"/english.all.3class.distsim.crf.ser.gz,\" + dataDir + \"/english.conll.4class.distsim.crf.ser.gz,\" + dataDir + \"/english.muc.7class.distsim.crf.ser.gz\");\n      commonProps.setProperty(\"depparse.model\", dataDir + \"/english_SD.gz\");\n      commonProps.setProperty(\"parse.model\", dataDir + \"/englishPCFG.ser.gz\");\n      commonProps.setProperty(\"sutime.rules\", dataDir + \"/defs.sutime.txt,\" + dataDir + \"/english.sutime.txt,\" + dataDir + \"/english.hollidays.sutime.txt\");\n      commonProps.setProperty(\"openie.splitter.model\", dataDir + \"/clauseSplitterModel.ser.gz\");\n      commonProps.setProperty(\"openie.affinity_models\", dataDir);\n    } catch (NullPointerException e) {\n      System.err.println(\"Could not load servlet context. Are you on the command line?\");\n    }\n    if (this.pipeline == null) {\n      Properties fullProps = new Properties(commonProps);\n      fullProps.setProperty(\"annotators\", \"tokenize,ssplit,pos,lemma,depparse,ner,natlog,openie\");\n      this.pipeline = new StanfordCoreNLP(fullProps);\n    }\n    if (this.backoff == null) {\n      Properties backoffProps = new Properties(commonProps);\n      backoffProps.setProperty(\"annotators\", \"parse,natlog,openie\");\n      backoffProps.setProperty(\"enforceRequirements\", \"false\");\n      this.backoff = new StanfordCoreNLP(backoffProps);\n\n    }\n  }","commit_id":"26842102f13f8ecddd9e9b8b0f5edde458e7daa3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Annotate a document (which is usually just a sentence).\n   */\n  public void annotate(Annotation ann) {\n    pipeline.annotate(ann);\n    if (ann.get(CoreAnnotations.SentencesAnnotation.class).size() == 1) {\n      CoreMap sentence = ann.get(CoreAnnotations.SentencesAnnotation.class).get(0);\n      if (sentence.get(NaturalLogicAnnotations.RelationTriplesAnnotation.class) != null) {\n        if (sentence.get(NaturalLogicAnnotations.RelationTriplesAnnotation.class).isEmpty()) {\n          for (CoreLabel token : sentence.get(CoreAnnotations.TokensAnnotation.class)) {\n            token.remove(NaturalLogicAnnotations.OperatorAnnotation.class);\n            token.remove(NaturalLogicAnnotations.PolarityAnnotation.class);\n          }\n          sentence.remove(NaturalLogicAnnotations.RelationTriplesAnnotation.class);\n          sentence.remove(NaturalLogicAnnotations.EntailedSentencesAnnotation.class);\n          sentence.remove(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class);\n          sentence.remove(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class);\n          sentence.remove(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class);\n          backoff.annotate(ann);\n        }\n      }\n    }\n  }","id":34604,"modified_method":"/**\n   * Annotate a document (which is usually just a sentence).\n   */\n  public void annotate(StanfordCoreNLP pipeline, Annotation ann) {\n    if (ann.get(CoreAnnotations.SentencesAnnotation.class) == null) {\n      pipeline.annotate(ann);\n    } else {\n      if (ann.get(CoreAnnotations.SentencesAnnotation.class).size() == 1) {\n        CoreMap sentence = ann.get(CoreAnnotations.SentencesAnnotation.class).get(0);\n        for (CoreLabel token : sentence.get(CoreAnnotations.TokensAnnotation.class)) {\n          token.remove(NaturalLogicAnnotations.OperatorAnnotation.class);\n          token.remove(NaturalLogicAnnotations.PolarityAnnotation.class);\n        }\n        sentence.remove(NaturalLogicAnnotations.RelationTriplesAnnotation.class);\n        sentence.remove(NaturalLogicAnnotations.EntailedSentencesAnnotation.class);\n        sentence.remove(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class);\n        sentence.remove(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class);\n        sentence.remove(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class);\n        pipeline.annotate(ann);\n      }\n    }\n  }","commit_id":"26842102f13f8ecddd9e9b8b0f5edde458e7daa3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Actually perform the GET request, given all the relevant information (already sanity checked).\n   * This is the meat of the servlet code.\n   * @param out The writer to write the output to.\n   * @param q The query string.\n   */\n  private void doGet(PrintWriter out, String q) {\n    // Clean the string a bit\n    q = q.trim();\n    if (q.length() == 0) {\n      return;\n    }\n    char lastChar = q.charAt(q.length() - 1);\n    if (lastChar != '.' && lastChar != '!' && lastChar != '?') {\n      q = q + \".\";\n    }\n    // Annotate\n    Annotation ann = new Annotation(q);\n    try {\n      // Annotate\n      annotate(ann);\n      // Collect results\n      List<String> entailments = new ArrayList<>();\n      Set<String> triples = new LinkedHashSet<>();\n      for (CoreMap sentence : ann.get(CoreAnnotations.SentencesAnnotation.class)) {\n        for (SentenceFragment fragment : sentence.get(NaturalLogicAnnotations.EntailedSentencesAnnotation.class)) {\n          entailments.add(quote(fragment.toString()));\n        }\n        for (RelationTriple fragment : sentence.get(NaturalLogicAnnotations.RelationTriplesAnnotation.class)) {\n          triples.add(\"[ \" + quote(fragment.subjectLemmaGloss()) + \", \" + quote(fragment.relationLemmaGloss()) + \", \" + quote(fragment.objectLemmaGloss()) + \" ]\");\n        }\n      }\n      // Write results\n      out.println(\"{ \" +\n          \"\\\"ok\\\":true, \" +\n          \"\\\"entailments\\\": [\" + StringUtils.join(entailments, \",\") + \"], \" +\n          \"\\\"triples\\\": [\" + StringUtils.join(triples, \",\") + \"], \" +\n          \"\\\"msg\\\": \\\"\\\"\" +\n          \" }\");\n    } catch (Throwable t) {\n      out.println(\"{ok:false, entailments:[], triples:[], msg:\" + quote(t.getMessage()) + \"}\");\n    }\n  }","id":34605,"modified_method":"/**\n   * Actually perform the GET request, given all the relevant information (already sanity checked).\n   * This is the meat of the servlet code.\n   * @param out The writer to write the output to.\n   * @param q The query string.\n   */\n  private void doGet(PrintWriter out, String q) {\n    // Clean the string a bit\n    q = q.trim();\n    if (q.length() == 0) {\n      return;\n    }\n    char lastChar = q.charAt(q.length() - 1);\n    if (lastChar != '.' && lastChar != '!' && lastChar != '?') {\n      q = q + \".\";\n    }\n    // Annotate\n    Annotation ann = new Annotation(q);\n    try {\n      // Collect results\n      Set<String> entailments = new HashSet<>();\n      Set<String> triples = new LinkedHashSet<>();\n      runWithPipeline(pipeline, ann, triples, entailments);  // pipeline must come before backoff\n      runWithPipeline(backoff, ann, triples, entailments);   // backoff must come after pipeline\n      // Write results\n      out.println(\"{ \" +\n          \"\\\"ok\\\":true, \" +\n          \"\\\"entailments\\\": [\" + StringUtils.join(entailments, \",\") + \"], \" +\n          \"\\\"triples\\\": [\" + StringUtils.join(triples, \",\") + \"], \" +\n          \"\\\"msg\\\": \\\"\\\"\" +\n          \" }\");\n    } catch (Throwable t) {\n      out.println(\"{ok:false, entailments:[], triples:[], msg:\" + quote(t.getMessage()) + \"}\");\n    }\n  }","commit_id":"26842102f13f8ecddd9e9b8b0f5edde458e7daa3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public void annotate(Annotation annotation){\n    try {\n      if (!annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n        log.error(\"this coreference resolution system requires SentencesAnnotation!\");\n        return;\n      }\n\n      if (hasSpeakerAnnotations(annotation)) {\n        annotation.set(CoreAnnotations.UseMarkedDiscourseAnnotation.class, true);\n      }\n\n      corefSystem.annotate(annotation);\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","id":34606,"modified_method":"@Override\n  public void annotate(Annotation annotation){\n    try {\n      if (!annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n        log.error(\"this coreference resolution system requires SentencesAnnotation!\");\n        return;\n      }\n\n      if (hasSpeakerAnnotations(annotation)) {\n        annotation.set(CoreAnnotations.UseMarkedDiscourseAnnotation.class, true);\n      }\n\n      // choose between hybrid mode or statistical mode\n      if (COREF_MODE.equals(HYBRID_MODE)) {\n        Document corefDoc = hcorefSystem.docMaker.makeDocument(annotation);\n        Map<Integer, CorefChain> result = hcorefSystem.coref(corefDoc);\n        annotation.set(CorefCoreAnnotations.CorefChainAnnotation.class, result);\n        // for backward compatibility\n        if(OLD_FORMAT) annotateOldFormat(result, corefDoc);\n      } else if (COREF_MODE.equals(STATISTICAL_MODE)) {\n        scorefSystem.annotate(annotation);\n      } else {\n        log.error(\"invalid selection for coreference mode!\");\n        throw new RuntimeException() ;\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"bf0e5d5779f7ddc0681d44345c69c535dfd2af69","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  @Override\n  public Set<Class<? extends CoreAnnotation>> requires() {\n    Set<Class<? extends CoreAnnotation>> requirements = new HashSet<>(Arrays.asList(\n        CoreAnnotations.TextAnnotation.class,\n        CoreAnnotations.TokensAnnotation.class,\n        CoreAnnotations.CharacterOffsetBeginAnnotation.class,\n        CoreAnnotations.CharacterOffsetEndAnnotation.class,\n        CoreAnnotations.IndexAnnotation.class,\n        CoreAnnotations.ValueAnnotation.class,\n        CoreAnnotations.SentencesAnnotation.class,\n        CoreAnnotations.SentenceIndexAnnotation.class,\n        CoreAnnotations.PartOfSpeechAnnotation.class,\n        CoreAnnotations.LemmaAnnotation.class,\n        CoreAnnotations.NamedEntityTagAnnotation.class,\n        CorefCoreAnnotations.CorefMentionsAnnotation.class,\n        SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class,\n        SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class\n        ));\n    if (CorefProperties.mdType(this.props) != CorefProperties.MentionDetectionType.DEPENDENCY) {\n      requirements.add(TreeCoreAnnotations.TreeAnnotation.class);\n      requirements.add(CoreAnnotations.CategoryAnnotation.class);\n    }\n    return Collections.unmodifiableSet(requirements);\n  }","id":34607,"modified_method":"@SuppressWarnings(\"unchecked\")\n  @Override\n  public Set<Class<? extends CoreAnnotation>> requires() {\n    Set<Class<? extends CoreAnnotation>> requirements = new HashSet<>(Arrays.asList(\n        CoreAnnotations.TextAnnotation.class,\n        CoreAnnotations.TokensAnnotation.class,\n        CoreAnnotations.CharacterOffsetBeginAnnotation.class,\n        CoreAnnotations.CharacterOffsetEndAnnotation.class,\n        CoreAnnotations.IndexAnnotation.class,\n        CoreAnnotations.ValueAnnotation.class,\n        CoreAnnotations.SentencesAnnotation.class,\n        CoreAnnotations.SentenceIndexAnnotation.class,\n        CoreAnnotations.ParagraphAnnotation.class,\n        CoreAnnotations.PartOfSpeechAnnotation.class,\n        CoreAnnotations.LemmaAnnotation.class,\n        CoreAnnotations.NamedEntityTagAnnotation.class,\n        CorefCoreAnnotations.CorefMentionsAnnotation.class,\n        CoreAnnotations.UtteranceAnnotation.class,\n        CoreAnnotations.SpeakerAnnotation.class,\n        SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class,\n        SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class\n        ));\n    if (CorefProperties.getMDType(this.props) != CorefProperties.MentionDetectionType.DEPENDENCY) {\n      requirements.add(TreeCoreAnnotations.TreeAnnotation.class);\n      requirements.add(CoreAnnotations.CategoryAnnotation.class);\n    }\n    return Collections.unmodifiableSet(requirements);\n  }","commit_id":"bf0e5d5779f7ddc0681d44345c69c535dfd2af69","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public CorefAnnotator(Properties props) {\n    this.props = props;\n    try {\n      corefSystem = new CorefSystem(props);\n      oldFormat = Boolean.parseBoolean(props.getProperty(\"oldCorefFormat\", \"false\"));\n    } catch (Exception e) {\n      log.error(\"cannot create CorefAnnotator!\");\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }","id":34608,"modified_method":"public CorefAnnotator(Properties props) {\n    this.props = props;\n    try {\n      COREF_MODE = props.getProperty(\"coref.mode\", STATISTICAL_MODE);\n      if (COREF_MODE.equals(HYBRID_MODE)) {\n        hcorefSystem = new HybridCorefSystem(props);\n        scorefSystem = null;\n      } else if (COREF_MODE.equals(STATISTICAL_MODE)) {\n        // create corefSystem for statistical\n        scorefSystem = StatisticalCorefSystem.fromProps(props);\n        hcorefSystem = null;\n      } else {\n        scorefSystem = null;\n        hcorefSystem = null;\n      }\n      OLD_FORMAT = Boolean.parseBoolean(props.getProperty(\"oldCorefFormat\", \"false\"));\n    } catch (Exception e) {\n      log.error(\"cannot create CorefAnnotator!\");\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"bf0e5d5779f7ddc0681d44345c69c535dfd2af69","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Set<Class<? extends CoreAnnotation>> requirementsSatisfied() {\n    return Collections.singleton(CorefCoreAnnotations.CorefChainAnnotation.class);\n  }","id":34609,"modified_method":"@Override\n  public Set<Class<? extends CoreAnnotation>> requirementsSatisfied() {\n    switch (COREF_MODE) {\n      case STATISTICAL_MODE:\n      case HYBRID_MODE:\n        return Collections.singleton(CorefCoreAnnotations.CorefChainAnnotation.class);\n      default:\n        throw new IllegalStateException(\"Unknown requirementsSatisfied() for coref mode: \" + COREF_MODE);\n    }\n  }","commit_id":"bf0e5d5779f7ddc0681d44345c69c535dfd2af69","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Item item(final QueryContext qc, final InputInfo ii) throws QueryException {\n    Map map = Map.EMPTY;\n    final int es = exprs.length;\n    for(int e = 0; e < es; e += 2) {\n      final Value key = exprs[e].atomValue(qc, ii);\n      if(!(key instanceof Item)) throw SEQFOUND_X.get(ii, key);\n      final Item k = (Item) key;\n      final Value v = qc.value(exprs[e + 1]);\n      if(map.contains(k, ii)) throw MAPDUPLKEY_X_X_X.get(ii, k, map.get(k, ii), v);\n      map = map.put(k, v, ii);\n    }\n    return map;\n  }","id":34610,"modified_method":"@Override\n  public Item item(final QueryContext qc, final InputInfo ii) throws QueryException {\n    Map map = Map.EMPTY;\n    final int es = exprs.length;\n    for(int e = 0; e < es; e += 2) {\n      final Value key = exprs[e].atomValue(qc, ii);\n      if(!(key instanceof Item)) throw SEQFOUND_X.get(ii, key);\n      final Item k = (Item) key;\n      final Value v = qc.value(exprs[e + 1]);\n      final boolean c = map.contains(k, ii);\n      map = map.put(k, v, ii);\n      if(c) throw MAPDUPLKEY_X_X_X.get(ii, k, map.get(k, ii), v);\n    }\n    return map;\n  }","commit_id":"f7029734ab6dfe5b8b133e2aaeabf32b4ef992ef","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests for paring strings.\n   * @throws QueryIOException query I/O exception\n   */\n  @Test public void stringTest() throws QueryIOException {\n    parse(\"\\\"\\\"\", false);\n    parse(\"\\\"test\\\"\", false);\n    parse(\"\\\"\\u00e4\\\"\", false);\n    parse(\"\\\"\\uD834\\uDD1E\\\"\", false);\n    parse(\"\\\"\\uD853\\uDF5C\\\"\", false);\n    parse(\"\\\"\\\\n\\\"\", false);\n    parse(\"\\\"\\\\\\\"\\\\\\\\\\\"\", false);\n    parse(\"\\\"\\\\u000a\\\"\", \"\\\"\\\\n\\\"\", false);\n    parse(\"\\\"\\\\u000A\\\"\", \"\\\"\\\\n\\\"\", false);\n    parse(\"\\\"\\n\\\"\", \"\\\"\\\\n\\\"\", true);\n\n    unescape(\"\\\"\\\\b\\\\f\\\\t\\\\r\\\\n\\\"\", \"\\\"\\\\\\\\b\\\\\\\\f\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\"\");\n    // Unicode in JSON notation\n    unescape(\"\\\"\\\\uD853\\\\uDF5C\\\"\", \"\\\"\\\\\\\\uD853\\\\\\\\uDF5C\\\"\");\n    unescape(\"\\\"\\\\uD853asdf\\\"\", \"\\\"\\\\\\\\uD853asdf\\\"\");\n    unescape(\"\\\"\\\\uD853\\\"\", \"\\\"\\\\\\\\uD853\\\"\");\n    // Unicode in Java notation\n    unescape(\"\\\"\\u00E4\\\\t\\\"\", \"\\\"\\u00E4\\\\\\\\t\\\"\");\n    unescape(\"\\\"\\u00E4\\\\u00E4\\\\t\\\"\", \"\\\"\\u00E4\\\\\\\\u00E4\\\\\\\\t\\\"\");\n\n    error(\"\\\"\\\\u0A\", false);\n    error(\"\\\"\\\\uXX0A\\\"\", false);\n    error(\"\\\"\\\\u0 00\\\"\", false);\n    error(\"\\\"\\\\u0:00\\\"\", false);\n    error(\"\\\"\\\\u0_00\\\"\", false);\n    error(\"\\\"\\\\u0~00\\\"\", false);\n    error(\"\\\"test\", false);\n    error(\"\\\"\\uD800\", false);\n    error(\"\\\"\\n\\\"\", false);\n\n    error(\"\\\"\\uD834\\\"\", false);\n    error(\"\\\"\\uD853\\uFFFF\\\"\", false);\n    error(\"\\\"\\uFFFF\\\"\", false);\n    error(\"\\\"\\uD853a\\\"\", false);\n    error(\"\\\"\\\\b\\\\f\\\\t\\\\r\\\\n\\\"\", false);\n    error(\"\\\"\\\\u0000\\\\u001F\\\"\", false);\n  }","id":34611,"modified_method":"/**\n   * Tests for paring strings.\n   * @throws QueryIOException query I/O exception\n   */\n  @Test public void stringTest() throws QueryIOException {\n    parse(\"\\\"\\\"\", false);\n    parse(\"\\\"test\\\"\", false);\n    parse(\"\\\"\\u00e4\\\"\", false);\n    parse(\"\\\"\\uD834\\uDD1E\\\"\", false);\n    parse(\"\\\"\\uD853\\uDF5C\\\"\", false);\n    parse(\"\\\"\\\\n\\\"\", false);\n    parse(\"\\\"\\\\\\\"\\\\\\\\\\\"\", false);\n    parse(\"\\\"\\\\u000a\\\"\", \"\\\"\\\\n\\\"\", false);\n    parse(\"\\\"\\\\u000A\\\"\", \"\\\"\\\\n\\\"\", false);\n    parse(\"\\\"\\n\\\"\", \"\\\"\\\\n\\\"\", true);\n    parse(\"\\\"\\uD834\\\"\", \"\\\"\\uFFFD\\\"\", false);\n    parse(\"\\\"\\uD853\\uFFFF\\\"\", \"\\\"\\uFFFD\\uFFFD\\\"\", false);\n    parse(\"\\\"\\uFFFF\\\"\", \"\\\"\\uFFFD\\\"\", false);\n    parse(\"\\\"\\uD853a\\\"\", \"\\\"\\uFFFDa\\\"\", false);\n    parse(\"\\\"\\\\b\\\\f\\\\t\\\\r\\\\n\\\"\", \"\\\"\\uFFFD\\uFFFD\\\\t\\\\r\\\\n\\\"\", false);\n    parse(\"\\\"\\\\u0000\\\\u001F\\\"\", \"\\\"\\uFFFD\\uFFFD\\\"\", false);\n\n    unescape(\"\\\"\\\\b\\\\f\\\\t\\\\r\\\\n\\\"\", \"\\\"\\\\\\\\b\\\\\\\\f\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\"\");\n    // Unicode in JSON notation\n    unescape(\"\\\"\\\\uD853\\\\uDF5C\\\"\", \"\\\"\\\\\\\\uD853\\\\\\\\uDF5C\\\"\");\n    unescape(\"\\\"\\\\uD853asdf\\\"\", \"\\\"\\\\\\\\uD853asdf\\\"\");\n    unescape(\"\\\"\\\\uD853\\\"\", \"\\\"\\\\\\\\uD853\\\"\");\n    // Unicode in Java notation\n    unescape(\"\\\"\\u00E4\\\\t\\\"\", \"\\\"\\u00E4\\\\\\\\t\\\"\");\n    unescape(\"\\\"\\u00E4\\\\u00E4\\\\t\\\"\", \"\\\"\\u00E4\\\\\\\\u00E4\\\\\\\\t\\\"\");\n\n    error(\"\\\"\\\\u0A\", false);\n    error(\"\\\"\\\\uXX0A\\\"\", false);\n    error(\"\\\"\\\\u0 00\\\"\", false);\n    error(\"\\\"\\\\u0:00\\\"\", false);\n    error(\"\\\"\\\\u0_00\\\"\", false);\n    error(\"\\\"\\\\u0~00\\\"\", false);\n    error(\"\\\"test\", false);\n    error(\"\\\"\\uD800\", false);\n    error(\"\\\"\\n\\\"\", false);\n  }","commit_id":"f7029734ab6dfe5b8b133e2aaeabf32b4ef992ef","url":"https://github.com/BaseXdb/basex"},{"original_method":"public EditorCell createEditorCell(EditorContext context, SNode node) {\n    return this.createConstantCell(context, node, \"<abstract concept>\");\n  }","id":34612,"modified_method":"public EditorCell createEditorCell(EditorContext context, SNode node) {\n    return this.createConstantCell(context, node, \"\");\n  }","commit_id":"7cbcbf9883f301a14237a867eb770b5ab949f7b7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextColor(Color.lightGray);\n    editorCell.putUserObject(EditorCell.CELL_ID, \"1133921115694\");\n    editorCell.setLayoutConstraint(\"\");\n    return editorCell;\n  }","id":34613,"modified_method":"public EditorCell createConstantCell(EditorContext context, SNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<abstract concept>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextColor(Color.lightGray);\n    editorCell.putUserObject(EditorCell.CELL_ID, \"1133921115694\");\n    editorCell.setLayoutConstraint(\"\");\n    ((EditorCell_Basic)editorCell).setParseable(false);\n    return editorCell;\n  }","commit_id":"7cbcbf9883f301a14237a867eb770b5ab949f7b7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addEquation(NodeWrapperType lhs, NodeWrapperType rhs, EquationType eqType) {\n    NodeWrapperType rhsRepresentator = rhs.getRepresentator();\n    NodeWrapperType lhsRepresentator = lhs.getRepresentator();\n\n    // no equation needed\n    if (rhsRepresentator == lhsRepresentator) return;\n\n    // add var to type's multieq\n    RuntimeTypeVariable varRhs = NodeWrapperType.getTypeVar(rhsRepresentator);\n    RuntimeTypeVariable varLhs = NodeWrapperType.getTypeVar(lhsRepresentator);\n    if (varRhs != null) {\n      processEquation(rhsRepresentator, lhsRepresentator);\n      return;\n    } else {\n      if (varLhs != null) {\n        processEquation(lhsRepresentator, rhsRepresentator);\n        return;\n      }\n    }\n\n\n\n    // process nominal subtyping\n    switch(eqType) {\n      case GREATER: {\n        if (SubtypingManager.getInstance().isStrictSubtype(lhsRepresentator, rhsRepresentator)) {\n          processSubtyping(lhsRepresentator, rhsRepresentator);\n          return;\n        }\n        break;\n      }\n      case LESS: {\n        if (SubtypingManager.getInstance().isStrictSubtype(rhsRepresentator, lhsRepresentator)) {\n          processSubtyping(rhsRepresentator, lhsRepresentator);\n          return;\n        }\n        break;\n      }\n      case NORMAL: {\n        if (SubtypingManager.getInstance().isStrictSubtype(rhsRepresentator, lhsRepresentator)) {\n          processSubtyping(rhsRepresentator, lhsRepresentator);\n          return;\n        } else if (SubtypingManager.getInstance().isStrictSubtype(lhsRepresentator, rhsRepresentator)) {\n          processSubtyping(lhsRepresentator, rhsRepresentator);\n          return;\n        }\n      }\n    }\n\n    // solve equation\n    if (!compareNodes(rhsRepresentator.getNodeWrapper(), lhsRepresentator.getNodeWrapper())) {\n      String error = \"incompatible types: \" + rhsRepresentator + \" and \" + lhsRepresentator; //todo more friendly error representation\n      processErrorEquation(lhsRepresentator, rhsRepresentator, error);\n      return;\n    }\n    Set<Pair<NodeWrapperType, NodeWrapperType>> childEQs = createChildEquations(rhsRepresentator.getNodeWrapper(), lhsRepresentator.getNodeWrapper());\n    for (Pair<NodeWrapperType, NodeWrapperType> eq : childEQs) {\n      addEquation(eq.o2, eq.o1);\n    }\n  }","id":34614,"modified_method":"public void addInequation(NodeWrapperType subType, NodeWrapperType supertype) {\n    NodeWrapperType subtypeRepresentator = subType.getRepresentator();\n    NodeWrapperType supertypeRepresentator = supertype.getRepresentator();\n\n    // no equation needed\n    if (subtypeRepresentator == supertypeRepresentator) return;\n\n    // if one of them is a var\n    RuntimeTypeVariable varSubtype = NodeWrapperType.getTypeVar(subtypeRepresentator);\n    RuntimeTypeVariable varSupertype = NodeWrapperType.getTypeVar(supertypeRepresentator);\n    if (varSubtype != null || varSupertype != null) {\n      mySubtypesToSupertypesMap.put(subtypeRepresentator, supertypeRepresentator);\n      mySupertypesToSubtypesMap.put(supertypeRepresentator, subtypeRepresentator);\n      return;\n    }\n\n    // if strict subtyping\n    if (SubtypingManager.getInstance().isStrictSubtype(subtypeRepresentator, supertypeRepresentator)) {\n      processSubtyping(subtypeRepresentator, supertypeRepresentator);\n      return;\n    }\n\n    subtypeRepresentator.setErrorString(\"type \"+ subtypeRepresentator+\" should be a subtype of \"+supertypeRepresentator);\n    TypeChecker.reportTypeError(subtypeRepresentator, subtypeRepresentator.getNodeToReportErrors());\n  }","commit_id":"7cbcbf9883f301a14237a867eb770b5ab949f7b7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addEquation(NodeWrapperType lhs, NodeWrapperType rhs) {\n    addEquation(lhs, rhs, EquationType.NORMAL);\n  }","id":34615,"modified_method":"public void addEquation(NodeWrapperType lhs, NodeWrapperType rhs) {\n    NodeWrapperType rhsRepresentator = rhs.getRepresentator();\n    NodeWrapperType lhsRepresentator = lhs.getRepresentator();\n\n    // no equation needed\n    if (rhsRepresentator == lhsRepresentator) return;\n\n    // add var to type's multieq\n    RuntimeTypeVariable varRhs = NodeWrapperType.getTypeVar(rhsRepresentator);\n    RuntimeTypeVariable varLhs = NodeWrapperType.getTypeVar(lhsRepresentator);\n    if (varRhs != null) {\n      processEquation(rhsRepresentator, lhsRepresentator);\n      return;\n    } else {\n      if (varLhs != null) {\n        processEquation(lhsRepresentator, rhsRepresentator);\n        return;\n      }\n    }\n\n\n\n    // process nominal subtyping\n    if (SubtypingManager.getInstance().isStrictSubtype(rhsRepresentator, lhsRepresentator)) {\n      processSubtyping(rhsRepresentator, lhsRepresentator);\n      return;\n    } else if (SubtypingManager.getInstance().isStrictSubtype(lhsRepresentator, rhsRepresentator)) {\n      processSubtyping(lhsRepresentator, rhsRepresentator);\n      return;\n    }\n\n    // solve equation\n    if (!compareNodes(rhsRepresentator.getNodeWrapper(), lhsRepresentator.getNodeWrapper())) {\n      String error = \"incompatible types: \" + rhsRepresentator + \" and \" + lhsRepresentator; //todo more friendly error representation\n      processErrorEquation(lhsRepresentator, rhsRepresentator, error);\n      return;\n    }\n    Set<Pair<NodeWrapperType, NodeWrapperType>> childEQs = createChildEquations(rhsRepresentator.getNodeWrapper(), lhsRepresentator.getNodeWrapper());\n    for (Pair<NodeWrapperType, NodeWrapperType> eq : childEQs) {\n      addEquation(eq.o2, eq.o1);\n    }\n  }","commit_id":"7cbcbf9883f301a14237a867eb770b5ab949f7b7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void processEquation(NodeWrapperType var, NodeWrapperType type) {\n    var.setParent(type);\n    type.addAllVarSetsOfSourceAndRemoveSourceFromThem(var);\n    if (NodeWrapperType.getTypeVar(var) instanceof RuntimeErrorType) {\n      TypeChecker.reportTypeError(var, var.getNodeToReportErrors());\n    }\n  }","id":34616,"modified_method":"private void processEquation(NodeWrapperType var, NodeWrapperType type) {\n    var.setParent(type);\n    keepInequation(var, type);\n    type.addAllVarSetsOfSourceAndRemoveSourceFromThem(var);\n    if (NodeWrapperType.getTypeVar(var) instanceof RuntimeErrorType) {\n      TypeChecker.reportTypeError(var, var.getNodeToReportErrors());\n    }\n  }","commit_id":"7cbcbf9883f301a14237a867eb770b5ab949f7b7","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean validateMissingGroupReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tStagedModelDataHandler<?> stagedModelDataHandler =\n\t\t\tStagedModelDataHandlerRegistryUtil.getStagedModelDataHandler(\n\t\t\t\tStagedGroup.class.getName());\n\n\t\treturn stagedModelDataHandler.validateReference(\n\t\t\tportletDataContext, referenceElement);\n\t}","id":34617,"modified_method":"protected boolean validateMissingGroupReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tStagedModelDataHandler<StagedGroup> stagedModelDataHandler =\n\t\t\t(StagedModelDataHandler<StagedGroup>)\n\t\t\t\tStagedModelDataHandlerRegistryUtil.getStagedModelDataHandler(\n\t\t\t\t\tStagedGroup.class.getName());\n\n\t\treturn stagedModelDataHandler.validateReference(\n\t\t\tportletDataContext, referenceElement);\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importMissingGroupReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tStagedModelDataHandler<?> stagedModelDataHandler =\n\t\t\tStagedModelDataHandlerRegistryUtil.getStagedModelDataHandler(\n\t\t\t\tStagedGroup.class.getName());\n\n\t\tstagedModelDataHandler.importMissingReference(\n\t\t\tportletDataContext, referenceElement);\n\t}","id":34618,"modified_method":"protected void importMissingGroupReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tStagedModelDataHandler<StagedGroup> stagedModelDataHandler =\n\t\t\t(StagedModelDataHandler<StagedGroup>)\n\t\t\t\tStagedModelDataHandlerRegistryUtil.getStagedModelDataHandler(\n\t\t\t\t\tStagedGroup.class.getName());\n\n\t\tstagedModelDataHandler.importMissingReference(\n\t\t\tportletDataContext, referenceElement);\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong groupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\n\t\tif (!validateMissingGroupReference(\n\t\t\t\tportletDataContext, referenceElement)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tgroupId = MapUtil.getLong(groupIds, groupId, groupId);\n\n\t\ttry {\n\t\t\treturn validateMissingReference(\n\t\t\t\tuuid, portletDataContext.getCompanyId(), groupId);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}","id":34619,"modified_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong liveGroupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\n\t\tif (!validateMissingGroupReference(\n\t\t\t\tportletDataContext, referenceElement)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tliveGroupId = MapUtil.getLong(groupIds, liveGroupId, liveGroupId);\n\n\t\ttry {\n\t\t\treturn validateMissingReference(\n\t\t\t\tuuid, portletDataContext.getCompanyId(), liveGroupId);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong groupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\treferenceElement.attributeValue(\"referenced-class-name\"));\n\t\tString structureKey = referenceElement.attributeValue(\"structure-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tgroupId = MapUtil.getLong(groupIds, groupId, groupId);\n\n\t\tDDMStructure existingStructure = null;\n\n\t\ttry {\n\t\t\texistingStructure = fetchExistingStructure(\n\t\t\t\tuuid, groupId, classNameId, structureKey, preloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong structureId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\tstructureIds.put(structureId, existingStructure.getStructureId());\n\n\t\tMap<String, String> structureKeys =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class + \".ddmStructureKey\");\n\n\t\tstructureKeys.put(structureKey, existingStructure.getStructureKey());\n\t}","id":34620,"modified_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong liveGroupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\treferenceElement.attributeValue(\"referenced-class-name\"));\n\t\tString structureKey = referenceElement.attributeValue(\"structure-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tliveGroupId = MapUtil.getLong(groupIds, liveGroupId, liveGroupId);\n\n\t\tDDMStructure existingStructure = null;\n\n\t\ttry {\n\t\t\texistingStructure = fetchExistingStructure(\n\t\t\t\tuuid, liveGroupId, classNameId, structureKey, preloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong structureId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\tstructureIds.put(structureId, existingStructure.getStructureId());\n\n\t\tMap<String, String> structureKeys =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class + \".ddmStructureKey\");\n\n\t\tstructureKeys.put(structureKey, existingStructure.getStructureKey());\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong groupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\treferenceElement.attributeValue(\"referenced-class-name\"));\n\t\tString templateKey = referenceElement.attributeValue(\"template-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\tif (!validateMissingGroupReference(\n\t\t\t\tportletDataContext, referenceElement)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tgroupId = MapUtil.getLong(groupIds, groupId, groupId);\n\n\t\ttry {\n\t\t\tDDMTemplate existingTemplate = fetchExistingTemplate(\n\t\t\t\tuuid, groupId, classNameId, templateKey, preloaded);\n\n\t\t\tif (existingTemplate == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\treturn false;\n\t\t}\n\t}","id":34621,"modified_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong liveGroupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\treferenceElement.attributeValue(\"referenced-class-name\"));\n\t\tString templateKey = referenceElement.attributeValue(\"template-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\tif (!validateMissingGroupReference(\n\t\t\t\tportletDataContext, referenceElement)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tliveGroupId = MapUtil.getLong(groupIds, liveGroupId, liveGroupId);\n\n\t\ttry {\n\t\t\tDDMTemplate existingTemplate = fetchExistingTemplate(\n\t\t\t\tuuid, liveGroupId, classNameId, templateKey, preloaded);\n\n\t\t\tif (existingTemplate == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong groupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\treferenceElement.attributeValue(\"referenced-class-name\"));\n\t\tString templateKey = referenceElement.attributeValue(\"template-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tgroupId = MapUtil.getLong(groupIds, groupId, groupId);\n\n\t\tDDMTemplate existingTemplate = null;\n\n\t\ttry {\n\t\t\texistingTemplate = fetchExistingTemplate(\n\t\t\t\tuuid, groupId, classNameId, templateKey, preloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<Long, Long> templateIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMTemplate.class);\n\n\t\tlong templateId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\ttemplateIds.put(templateId, existingTemplate.getTemplateId());\n\n\t\tMap<String, String> templateKeys =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMTemplate.class + \".ddmTemplateKey\");\n\n\t\ttemplateKeys.put(templateKey, existingTemplate.getTemplateKey());\n\t}","id":34622,"modified_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong liveGroupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\treferenceElement.attributeValue(\"referenced-class-name\"));\n\t\tString templateKey = referenceElement.attributeValue(\"template-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tliveGroupId = MapUtil.getLong(groupIds, liveGroupId, liveGroupId);\n\n\t\tDDMTemplate existingTemplate = null;\n\n\t\ttry {\n\t\t\texistingTemplate = fetchExistingTemplate(\n\t\t\t\tuuid, liveGroupId, classNameId, templateKey, preloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<Long, Long> templateIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMTemplate.class);\n\n\t\tlong templateId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\ttemplateIds.put(templateId, existingTemplate.getTemplateId());\n\n\t\tMap<String, String> templateKeys =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMTemplate.class + \".ddmTemplateKey\");\n\n\t\ttemplateKeys.put(templateKey, existingTemplate.getTemplateKey());\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong groupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tString fileEntryTypeKey = referenceElement.attributeValue(\n\t\t\t\"file-entry-type-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tgroupId = MapUtil.getLong(groupIds, groupId, groupId);\n\n\t\tDLFileEntryType existingFileEntryType = null;\n\n\t\ttry {\n\t\t\texistingFileEntryType = fetchExistingFileEntryType(\n\t\t\t\tuuid, groupId, fileEntryTypeKey, preloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<Long, Long> fileEntryTypeIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFileEntryType.class);\n\n\t\tlong fileEntryTypeId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\tfileEntryTypeIds.put(\n\t\t\tfileEntryTypeId, existingFileEntryType.getFileEntryTypeId());\n\t}","id":34623,"modified_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\t\tlong liveGroupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tString fileEntryTypeKey = referenceElement.attributeValue(\n\t\t\t\"file-entry-type-key\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tliveGroupId = MapUtil.getLong(groupIds, liveGroupId, liveGroupId);\n\n\t\tDLFileEntryType existingFileEntryType = null;\n\n\t\ttry {\n\t\t\texistingFileEntryType = fetchExistingFileEntryType(\n\t\t\t\tuuid, liveGroupId, fileEntryTypeKey, preloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<Long, Long> fileEntryTypeIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFileEntryType.class);\n\n\t\tlong fileEntryTypeId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\tfileEntryTypeIds.put(\n\t\t\tfileEntryTypeId, existingFileEntryType.getFileEntryTypeId());\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString articleResourceUuid = referenceElement.attributeValue(\n\t\t\t\"article-resource-uuid\");\n\t\tlong groupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tString articleArticleId = referenceElement.attributeValue(\"article-id\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tgroupId = MapUtil.getLong(groupIds, groupId, groupId);\n\n\t\tJournalArticle existingArticle = null;\n\n\t\ttry {\n\t\t\texistingArticle = fetchExistingArticle(\n\t\t\t\tarticleResourceUuid, groupId, articleArticleId, null, 0.0,\n\t\t\t\tpreloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<String, String> articleArticleIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class + \".articleId\");\n\n\t\tarticleArticleIds.put(articleArticleId, existingArticle.getArticleId());\n\n\t\tMap<Long, Long> articleIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\tlong articleId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\tarticleIds.put(articleId, existingArticle.getId());\n\t}","id":34624,"modified_method":"@Override\n\tpublic void importMissingReference(\n\t\t\tPortletDataContext portletDataContext, Element referenceElement)\n\t\tthrows PortletDataException {\n\n\t\tString articleResourceUuid = referenceElement.attributeValue(\n\t\t\t\"article-resource-uuid\");\n\t\tlong liveGroupId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"live-group-id\"));\n\t\tString articleArticleId = referenceElement.attributeValue(\"article-id\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\timportMissingGroupReference(portletDataContext, referenceElement);\n\n\t\tMap<Long, Long> groupIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tGroup.class);\n\n\t\tliveGroupId = MapUtil.getLong(groupIds, liveGroupId, liveGroupId);\n\n\t\tJournalArticle existingArticle = null;\n\n\t\ttry {\n\t\t\texistingArticle = fetchExistingArticle(\n\t\t\t\tarticleResourceUuid, liveGroupId, articleArticleId, null, 0.0,\n\t\t\t\tpreloaded);\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow new PortletDataException(se);\n\t\t}\n\n\t\tMap<String, String> articleArticleIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class + \".articleId\");\n\n\t\tarticleArticleIds.put(articleArticleId, existingArticle.getArticleId());\n\n\t\tMap<Long, Long> articleIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\tlong articleId = GetterUtil.getLong(\n\t\t\treferenceElement.attributeValue(\"class-pk\"));\n\n\t\tarticleIds.put(articleId, existingArticle.getId());\n\t}","commit_id":"197c2fac6a5e2bdc4dde015002e1951df2c2d6a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic <T extends StagedModel> void sendStatusMessage(\n\t\tString messageType, T stagedModel, ManifestSummary manifestSummary) {\n\n\t\tif (!BackgroundTaskThreadLocal.hasBackgroundTask()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessage message = createMessage(messageType, manifestSummary);\n\n\t\tStagedModelDataHandler stagedModelDataHandler =\n\t\t\tStagedModelDataHandlerRegistryUtil.getStagedModelDataHandler(\n\t\t\t\tstagedModel.getModelClassName());\n\n\t\tmessage.put(\n\t\t\t\"stagedModelName\",\n\t\t\tstagedModelDataHandler.getDisplayName(stagedModel));\n\n\t\tmessage.put(\n\t\t\t\"stagedModelType\",\n\t\t\tString.valueOf(stagedModel.getStagedModelType()));\n\t\tmessage.put(\"uuid\", stagedModel.getUuid());\n\n\t\t_singleDestinationMessageSender.send(message);\n\t}","id":34625,"modified_method":"@Override\n\tpublic <T extends StagedModel> void sendStatusMessage(\n\t\tString messageType, T stagedModel, ManifestSummary manifestSummary) {\n\n\t\tif (!BackgroundTaskThreadLocal.hasBackgroundTask()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessage message = createMessage(messageType, manifestSummary);\n\n\t\tStagedModelDataHandler<T> stagedModelDataHandler =\n\t\t\t(StagedModelDataHandler<T>)\n\t\t\t\tStagedModelDataHandlerRegistryUtil.getStagedModelDataHandler(\n\t\t\t\t\tstagedModel.getModelClassName());\n\n\t\tmessage.put(\n\t\t\t\"stagedModelName\",\n\t\t\tstagedModelDataHandler.getDisplayName(stagedModel));\n\n\t\tmessage.put(\n\t\t\t\"stagedModelType\",\n\t\t\tString.valueOf(stagedModel.getStagedModelType()));\n\t\tmessage.put(\"uuid\", stagedModel.getUuid());\n\n\t\t_singleDestinationMessageSender.send(message);\n\t}","commit_id":"0105f201f8f217ba608bad410bece905e3cefaec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAsyncEndpoint() throws Exception {\n        // TODO: Fix me with async load balancer\n        //getMockEndpoint(\"mock:before\").expectedBodiesReceived(\"Hello Camel\");\n        //getMockEndpoint(\"mock:fail\").expectedBodiesReceived(\"Hello Camel\");\n        //getMockEndpoint(\"mock:after\").expectedBodiesReceived(\"Bye World\");\n        //getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n\n        //String reply = template.requestBody(\"direct:start\", \"Hello Camel\", String.class);\n        //assertEquals(\"Bye World\", reply);\n\n        //assertMockEndpointsSatisfied();\n\n        // assertFalse(\"Should use different threads\", beforeThreadName.equalsIgnoreCase(afterThreadName));\n    }","id":34626,"modified_method":"public void testAsyncEndpoint() throws Exception {\n        getMockEndpoint(\"mock:before\").expectedBodiesReceived(\"Hello Camel\");\n        getMockEndpoint(\"mock:fail\").expectedBodiesReceived(\"Hello Camel\");\n        getMockEndpoint(\"mock:after\").expectedBodiesReceived(\"Bye World\");\n        getMockEndpoint(\"mock:result\").expectedBodiesReceived(\"Bye World\");\n\n        String reply = template.requestBody(\"direct:start\", \"Hello Camel\", String.class);\n        assertEquals(\"Bye World\", reply);\n\n        assertMockEndpointsSatisfied();\n\n        assertFalse(\"Should use different threads\", beforeThreadName.equalsIgnoreCase(afterThreadName));\n    }","commit_id":"835017fe66e5f9b515676c5ba3cb6e604333ea51","url":"https://github.com/apache/camel"},{"original_method":"private boolean processExchange(Processor processor, Exchange exchange,\n                                    AtomicInteger attempts, AtomicInteger index,\n                                    AsyncCallback callback, List<Processor> processors) {\n        if (processor == null) {\n            throw new IllegalStateException(\"No processors could be chosen to process \" + exchange);\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Processing failover at attempt \" + attempts + \" for exchange: \" + exchange);\n        }\n\n        AsyncProcessor albp = AsyncProcessorTypeConverter.convert(processor);\n        boolean sync = albp.process(exchange, new FailOverAsyncCallback(exchange, attempts, index, callback, processors));\n        return sync;\n    }","id":34627,"modified_method":"private boolean processExchange(Processor processor, Exchange exchange,\n                                    AtomicInteger attempts, AtomicInteger index,\n                                    AsyncCallback callback, List<Processor> processors) {\n        if (processor == null) {\n            throw new IllegalStateException(\"No processors could be chosen to process \" + exchange);\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Processing failover at attempt \" + attempts + \" for exchange: \" + exchange);\n        }\n\n        AsyncProcessor albp = AsyncProcessorTypeConverter.convert(processor);\n        return albp.process(exchange, new FailOverAsyncCallback(exchange, attempts, index, callback, processors));\n    }","commit_id":"835017fe66e5f9b515676c5ba3cb6e604333ea51","url":"https://github.com/apache/camel"},{"original_method":"public void done(boolean doneSync) {\n            // should we failover?\n            if (shouldFailOver(exchange)) {\n                attempts.incrementAndGet();\n                // are we exhausted by attempts?\n                if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Braking out of failover after \" + attempts + \" failover attempts\");\n                    }\n                    callback.done(doneSync);\n                    return;\n                }\n\n                index.incrementAndGet();\n                counter.incrementAndGet();\n\n                if (index.get() >= processors.size()) {\n                    // out of bounds\n                    if (isRoundRobin()) {\n                        log.debug(\"Failover is round robin enabled and therefore starting from the first endpoint\");\n                        index.set(0);\n                        counter.set(0);\n                    } else {\n                        // no more processors to try\n                        log.debug(\"Braking out of failover as we reach the end of endpoints to use for failover\");\n                        callback.done(doneSync);\n                        return;\n                    }\n                }\n\n                // try again but prepare exchange before we failover\n                prepareExchangeForFailover(exchange);\n                Processor processor = processors.get(index.get());\n\n                // try to failover using the next processor\n                AsyncProcessor albp = AsyncProcessorTypeConverter.convert(processor);\n                albp.process(exchange, this);\n            } else {\n                // we are done doing failover\n                callback.done(doneSync);\n            }\n        }","id":34628,"modified_method":"public void done(boolean doneSync) {\n            // we only have to handle async completion of the pipeline\n            if (doneSync) {\n                return;\n            }\n\n            while (shouldFailOver(exchange)) {\n                attempts.incrementAndGet();\n                // are we exhausted by attempts?\n                if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Braking out of failover after \" + attempts + \" failover attempts\");\n                    }\n                    break;\n                }\n\n                index.incrementAndGet();\n                counter.incrementAndGet();\n\n                if (index.get() >= processors.size()) {\n                    // out of bounds\n                    if (isRoundRobin()) {\n                        log.debug(\"Failover is round robin enabled and therefore starting from the first endpoint\");\n                        index.set(0);\n                        counter.set(0);\n                    } else {\n                        // no more processors to try\n                        log.debug(\"Braking out of failover as we reach the end of endpoints to use for failover\");\n                        break;\n                    }\n                }\n\n                // try again but prepare exchange before we failover\n                prepareExchangeForFailover(exchange);\n                Processor processor = processors.get(index.get());\n\n                // try to failover using the next processor\n                doneSync = processExchange(processor, exchange, attempts, index, callback, processors);\n                if (!doneSync) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Processing exchangeId: \" + exchange.getExchangeId() + \" is continued being processed asynchronously\");\n                    }\n                    // the remainder of the pipeline will be completed async\n                    // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                    return;\n                }\n            }\n\n            // signal callback we are done\n            callback.done(false);\n        }","commit_id":"835017fe66e5f9b515676c5ba3cb6e604333ea51","url":"https://github.com/apache/camel"},{"original_method":"public boolean process(Exchange exchange, AsyncCallback callback) {\n        boolean sync;\n\n        List<Processor> processors = getProcessors();\n        if (processors.isEmpty()) {\n            throw new IllegalStateException(\"No processors available to process \" + exchange);\n        }\n\n        final AtomicInteger index = new AtomicInteger();\n        final AtomicInteger attempts = new AtomicInteger();\n\n        // pick the first endpoint to use\n        if (isRoundRobin()) {\n            if (counter.incrementAndGet() >= processors.size()) {\n                counter.set(0);\n            }\n            index.set(counter.get());\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Failover starting with endpoint index \" + index);\n        }\n\n        Processor processor = processors.get(index.get());\n\n        // process the failover\n        sync = processExchange(processor, exchange, attempts, index, callback, processors);\n\n        // continue as long its being processed synchronously\n        if (!sync) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Processing exchangeId: \" + exchange.getExchangeId() + \" is continued being processed asynchronously\");\n            }\n            // the remainder of the failover will be completed async\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n\n        callback.done(true);\n        return true;\n    }","id":34629,"modified_method":"public boolean process(Exchange exchange, AsyncCallback callback) {\n        final List<Processor> processors = getProcessors();\n\n        final AtomicInteger index = new AtomicInteger();\n        final AtomicInteger attempts = new AtomicInteger();\n        boolean first = true;\n\n        // get the next processor\n        if (isRoundRobin()) {\n            if (counter.incrementAndGet() >= processors.size()) {\n                counter.set(0);\n            }\n            index.set(counter.get());\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Failover starting with endpoint index \" + index);\n        }\n\n        while (first || shouldFailOver(exchange)) {\n            if (!first) {\n                attempts.incrementAndGet();\n                // are we exhausted by attempts?\n                if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Braking out of failover after \" + attempts + \" failover attempts\");\n                    }\n                    break;\n                }\n\n                index.incrementAndGet();\n                counter.incrementAndGet();\n            } else {\n                // flip first switch\n                first = false;\n            }\n\n            if (index.get() >= processors.size()) {\n                // out of bounds\n                if (isRoundRobin()) {\n                    log.debug(\"Failover is round robin enabled and therefore starting from the first endpoint\");\n                    index.set(0);\n                    counter.set(0);\n                } else {\n                    // no more processors to try\n                    log.debug(\"Braking out of failover as we reach the end of endpoints to use for failover\");\n                    break;\n                }\n            }\n\n            // try again but prepare exchange before we failover\n            prepareExchangeForFailover(exchange);\n            Processor processor = processors.get(index.get());\n\n            // process the exchange\n            boolean sync = processExchange(processor, exchange, attempts, index, callback, processors);\n\n            // continue as long its being processed synchronously\n            if (!sync) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing exchangeId: \" + exchange.getExchangeId() + \" is continued being processed asynchronously\");\n                }\n                // the remainder of the pipeline will be completed async\n                // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                return false;\n            }\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"Processing exchangeId: \" + exchange.getExchangeId() + \" is continued being processed synchronously\");\n            }\n        }\n\n        if (log.isTraceEnabled()) {\n            // logging nextExchange as it contains the exchange that might have altered the payload and since\n            // we are logging the completion if will be confusing if we log the original instead\n            // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots\n            log.trace(\"Failover complete for exchangeId: \" + exchange.getExchangeId() + \" >>> \" + exchange);\n        }\n\n        callback.done(true);\n        return true;\n    }","commit_id":"835017fe66e5f9b515676c5ba3cb6e604333ea51","url":"https://github.com/apache/camel"},{"original_method":"private boolean process(final Exchange original, final Exchange exchange, final AsyncCallback callback,\n                            final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\n        if (LOG.isTraceEnabled()) {\n            // this does the actual processing so log at trace level\n            LOG.trace(\"Processing exchangeId: \" + exchange.getExchangeId() + \" >>> \" + exchange);\n        }\n\n        // implement asynchronous routing logic in callback so we can have the callback being\n        // triggered and then continue routing where we left\n        boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\n            public void done(boolean sync) {\n                // we only have to handle async completion of the pipeline\n                if (sync) {\n                    return;\n                }\n\n                // continue processing the pipeline asynchronously\n                Exchange nextExchange = exchange;\n                while (processors.hasNext()) {\n                    AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());\n\n                    // check for error if so we should break out\n                    boolean exceptionHandled = hasExceptionBeenHandledByErrorHandler(nextExchange);\n                    if (nextExchange.isFailed() || nextExchange.isRollbackOnly() || exceptionHandled) {\n                        // The Exchange.ERRORHANDLED_HANDLED property is only set if satisfactory handling was done\n                        // by the error handler. It's still an exception, the exchange still failed.\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder sb = new StringBuilder();\n                            sb.append(\"Message exchange has failed so breaking out of pipeline: \").append(nextExchange);\n                            if (nextExchange.isRollbackOnly()) {\n                                sb.append(\" Marked as rollback only.\");\n                            }\n                            if (nextExchange.getException() != null) {\n                                sb.append(\" Exception: \").append(nextExchange.getException());\n                            }\n                            if (nextExchange.hasOut() && nextExchange.getOut().isFault()) {\n                                sb.append(\" Fault: \").append(nextExchange.getOut());\n                            }\n                            if (exceptionHandled) {\n                                sb.append(\" Handled by the error handler.\");\n                            }\n                            LOG.debug(sb.toString());\n                        }\n                        break;\n                    }\n\n                    nextExchange = createNextExchange(nextExchange);\n                    sync = process(original, nextExchange, callback, processors, processor);\n                    if (!sync) {\n                        return;\n                    }\n                }\n\n                ExchangeHelper.copyResults(original, nextExchange);\n                callback.done(false);\n            }\n        });\n\n\n        return sync;\n    }","id":34630,"modified_method":"private boolean process(final Exchange original, final Exchange exchange, final AsyncCallback callback,\n                            final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\n        if (LOG.isTraceEnabled()) {\n            // this does the actual processing so log at trace level\n            LOG.trace(\"Processing exchangeId: \" + exchange.getExchangeId() + \" >>> \" + exchange);\n        }\n\n        // implement asynchronous routing logic in callback so we can have the callback being\n        // triggered and then continue routing where we left\n        boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\n            public void done(boolean sync) {\n                // we only have to handle async completion of the pipeline\n                if (sync) {\n                    return;\n                }\n\n                // continue processing the pipeline asynchronously\n                Exchange nextExchange = exchange;\n                while (processors.hasNext()) {\n                    AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());\n\n                    // check for error if so we should break out\n                    boolean exceptionHandled = hasExceptionBeenHandledByErrorHandler(nextExchange);\n                    if (nextExchange.isFailed() || nextExchange.isRollbackOnly() || exceptionHandled) {\n                        // The Exchange.ERRORHANDLED_HANDLED property is only set if satisfactory handling was done\n                        // by the error handler. It's still an exception, the exchange still failed.\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder sb = new StringBuilder();\n                            sb.append(\"Message exchange has failed so breaking out of pipeline: \").append(nextExchange);\n                            if (nextExchange.isRollbackOnly()) {\n                                sb.append(\" Marked as rollback only.\");\n                            }\n                            if (nextExchange.getException() != null) {\n                                sb.append(\" Exception: \").append(nextExchange.getException());\n                            }\n                            if (nextExchange.hasOut() && nextExchange.getOut().isFault()) {\n                                sb.append(\" Fault: \").append(nextExchange.getOut());\n                            }\n                            if (exceptionHandled) {\n                                sb.append(\" Handled by the error handler.\");\n                            }\n                            LOG.debug(sb.toString());\n                        }\n                        break;\n                    }\n\n                    nextExchange = createNextExchange(nextExchange);\n                    sync = process(original, nextExchange, callback, processors, processor);\n                    if (!sync) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Processing exchangeId: \" + exchange.getExchangeId() + \" is continued being processed asynchronously\");\n                        }\n                        return;\n                    }\n                }\n\n                ExchangeHelper.copyResults(original, nextExchange);\n                callback.done(false);\n            }\n        });\n\n\n        return sync;\n    }","commit_id":"835017fe66e5f9b515676c5ba3cb6e604333ea51","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        Exchange fileExchange = endpoint.createExchange(exchange);\n        endpoint.configureExchange(fileExchange);\n        processExchange(fileExchange);\n        ExchangeHelper.copyResults(exchange, fileExchange);\n    }","id":34631,"modified_method":"public void process(Exchange exchange) throws Exception {\n        Exchange fileExchange = endpoint.createExchange(exchange);\n        endpoint.configureExchange(fileExchange);\n\n        String target = createFileName(exchange);\n\n        // use lock for same file name to avoid concurrent writes to the same file\n        // for example when you concurrently append to the same file\n        Lock lock;\n        synchronized (locks) {\n            lock = locks.get(target);\n            if (lock == null) {\n                lock = new ReentrantLock();\n                locks.put(target, lock);\n            }\n        }\n\n        lock.lock();\n        try {\n            processExchange(fileExchange, target);\n            ExchangeHelper.copyResults(exchange, fileExchange);\n        } finally {\n            // do not remove as the locks cache has an upper bound\n            // this ensure the locks is appropriate reused\n            lock.unlock();\n        }\n    }","commit_id":"9b509587167c88a3a3a3b6808429ffc55f9a97fb","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Perform the work to process the fileExchange\n     *\n     * @param exchange fileExchange\n     * @throws Exception is thrown if some error\n     */\n    protected void processExchange(Exchange exchange) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Processing \" + exchange);\n        }\n\n        try {\n            String target = createFileName(exchange);\n\n            preWriteCheck();\n\n            // should we write to a temporary name and then afterwards rename to real target\n            boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());\n            String tempTarget = null;\n            if (writeAsTempAndRename) {\n                // compute temporary name with the temp prefix\n                tempTarget = createTempFileName(exchange, target);\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Writing using tempNameFile: \" + tempTarget);\n                }\n\n                // cater for file exists option on the real target as\n                // the file operations code will work on the temp file\n\n                // if an existing file already exists what should we do?\n                if (operations.existsFile(target)) {\n                    if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                        // ignore but indicate that the file was written\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"An existing file already exists: \" + target + \". Ignore and do not override it.\");\n                        }\n                        return;\n                    } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n                        throw new GenericFileOperationFailedException(\"File already exist: \" + target + \". Cannot write new file.\");\n                    } else if (endpoint.isEagerDeleteTargetFile() && endpoint.getFileExist() == GenericFileExist.Override) {\n                        // we override the target so we do this by deleting it so the temp file can be renamed later\n                        // with success as the existing target file have been deleted\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Eagerly deleting existing file: \" + target);\n                        }\n                        if (!operations.deleteFile(target)) {\n                            throw new GenericFileOperationFailedException(\"Cannot delete file: \" + target);\n                        }\n                    }\n                }\n\n                // delete any pre existing temp file\n                if (operations.existsFile(tempTarget)) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Deleting existing temp file: \" + tempTarget);\n                    }\n                    if (!operations.deleteFile(tempTarget)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete file: \" + tempTarget);\n                    }\n                }\n            }\n\n            // write/upload the file\n            writeFile(exchange, tempTarget != null ? tempTarget : target);\n\n            // if we did write to a temporary name then rename it to the real\n            // name after we have written the file\n            if (tempTarget != null) {\n\n                // if we should not eager delete the target file then do it now just before renaming\n                if (!endpoint.isEagerDeleteTargetFile() && operations.existsFile(target)\n                        && endpoint.getFileExist() == GenericFileExist.Override) {\n                    // we override the target so we do this by deleting it so the temp file can be renamed later\n                    // with success as the existing target file have been deleted\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Deleting existing file: \" + target);\n                    }\n                    if (!operations.deleteFile(target)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete file: \" + target);\n                    }\n                }\n\n                // now we are ready to rename the temp file to the target file\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Renaming file: [\" + tempTarget + \"] to: [\" + target + \"]\");\n                }\n                boolean renamed = operations.renameFile(tempTarget, target);\n                if (!renamed) {\n                    throw new GenericFileOperationFailedException(\"Cannot rename file from: \" + tempTarget + \" to: \" + target);\n                }\n            }\n\n            // any done file to write?\n            if (endpoint.getDoneFileName() != null) {\n                String doneFileName = endpoint.createDoneFileName(target);\n                ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n\n                // create empty exchange with empty body to write as the done file\n                Exchange empty = new DefaultExchange(exchange);\n                empty.getIn().setBody(\"\");\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Writing done file: [\" + doneFileName + \"]\");\n                }\n                // delete any existing done file\n                if (operations.existsFile(doneFileName)) {\n                    if (!operations.deleteFile(doneFileName)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete existing done file: \" + doneFileName);\n                    }\n                }\n                writeFile(empty, doneFileName);\n            }\n\n            // lets store the name we really used in the header, so end-users\n            // can retrieve it\n            exchange.getIn().setHeader(Exchange.FILE_NAME_PRODUCED, target);\n        } catch (Exception e) {\n            handleFailedWrite(exchange, e);\n        }\n\n        postWriteCheck();\n    }","id":34632,"modified_method":"/**\n     * Perform the work to process the fileExchange\n     *\n     * @param exchange fileExchange\n     * @param target   the target filename\n     * @throws Exception is thrown if some error\n     */\n    protected void processExchange(Exchange exchange, String target) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Processing file: \" + target + \" for exchange: \" + exchange);\n        }\n\n        try {\n            preWriteCheck();\n\n            // should we write to a temporary name and then afterwards rename to real target\n            boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());\n            String tempTarget = null;\n            if (writeAsTempAndRename) {\n                // compute temporary name with the temp prefix\n                tempTarget = createTempFileName(exchange, target);\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Writing using tempNameFile: \" + tempTarget);\n                }\n\n                // cater for file exists option on the real target as\n                // the file operations code will work on the temp file\n\n                // if an existing file already exists what should we do?\n                if (operations.existsFile(target)) {\n                    if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                        // ignore but indicate that the file was written\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"An existing file already exists: \" + target + \". Ignore and do not override it.\");\n                        }\n                        return;\n                    } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n                        throw new GenericFileOperationFailedException(\"File already exist: \" + target + \". Cannot write new file.\");\n                    } else if (endpoint.isEagerDeleteTargetFile() && endpoint.getFileExist() == GenericFileExist.Override) {\n                        // we override the target so we do this by deleting it so the temp file can be renamed later\n                        // with success as the existing target file have been deleted\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Eagerly deleting existing file: \" + target);\n                        }\n                        if (!operations.deleteFile(target)) {\n                            throw new GenericFileOperationFailedException(\"Cannot delete file: \" + target);\n                        }\n                    }\n                }\n\n                // delete any pre existing temp file\n                if (operations.existsFile(tempTarget)) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Deleting existing temp file: \" + tempTarget);\n                    }\n                    if (!operations.deleteFile(tempTarget)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete file: \" + tempTarget);\n                    }\n                }\n            }\n\n            // write/upload the file\n            writeFile(exchange, tempTarget != null ? tempTarget : target);\n\n            // if we did write to a temporary name then rename it to the real\n            // name after we have written the file\n            if (tempTarget != null) {\n\n                // if we should not eager delete the target file then do it now just before renaming\n                if (!endpoint.isEagerDeleteTargetFile() && operations.existsFile(target)\n                        && endpoint.getFileExist() == GenericFileExist.Override) {\n                    // we override the target so we do this by deleting it so the temp file can be renamed later\n                    // with success as the existing target file have been deleted\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Deleting existing file: \" + target);\n                    }\n                    if (!operations.deleteFile(target)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete file: \" + target);\n                    }\n                }\n\n                // now we are ready to rename the temp file to the target file\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Renaming file: [\" + tempTarget + \"] to: [\" + target + \"]\");\n                }\n                boolean renamed = operations.renameFile(tempTarget, target);\n                if (!renamed) {\n                    throw new GenericFileOperationFailedException(\"Cannot rename file from: \" + tempTarget + \" to: \" + target);\n                }\n            }\n\n            // any done file to write?\n            if (endpoint.getDoneFileName() != null) {\n                String doneFileName = endpoint.createDoneFileName(target);\n                ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n\n                // create empty exchange with empty body to write as the done file\n                Exchange empty = new DefaultExchange(exchange);\n                empty.getIn().setBody(\"\");\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Writing done file: [\" + doneFileName + \"]\");\n                }\n                // delete any existing done file\n                if (operations.existsFile(doneFileName)) {\n                    if (!operations.deleteFile(doneFileName)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete existing done file: \" + doneFileName);\n                    }\n                }\n                writeFile(empty, doneFileName);\n            }\n\n            // lets store the name we really used in the header, so end-users\n            // can retrieve it\n            exchange.getIn().setHeader(Exchange.FILE_NAME_PRODUCED, target);\n        } catch (Exception e) {\n            handleFailedWrite(exchange, e);\n        }\n\n        postWriteCheck();\n    }","commit_id":"9b509587167c88a3a3a3b6808429ffc55f9a97fb","url":"https://github.com/apache/camel"},{"original_method":"protected Aggregator createAggregator(RouteContext routeContext) throws Exception {\n        final Processor processor = routeContext.createProcessor(this);\n\n        final Aggregator aggregator;\n        if (getAggregationCollection() == null) {\n            setAggregationCollection(createAggregationCollection(routeContext));\n        }\n        \n        if (aggregationCollection != null) {\n            // create the aggregator using the collection\n            // pre configure the collection if its expression and strategy is not set, then\n            // use the ones that is pre configured with this type\n            if (aggregationCollection.getCorrelationExpression() == null) {\n                aggregationCollection.setCorrelationExpression(getExpression());\n            }\n            if (aggregationCollection.getAggregationStrategy() == null) {\n                AggregationStrategy strategy = createAggregationStrategy(routeContext);\n                aggregationCollection.setAggregationStrategy(strategy);\n            }\n            aggregator = new Aggregator(processor, aggregationCollection);\n        } else {\n            // create the aggregator using a default collection\n            AggregationStrategy strategy = createAggregationStrategy(routeContext);\n\n            if (getExpression() == null) {\n                throw new IllegalArgumentException(\"You need to specify an expression or \"\n                                                   + \"aggregation collection for this aggregator: \" + this);\n            }\n            \n            Expression aggregateExpression = getExpression().createExpression(routeContext);           \n\n            Predicate predicate = null;\n            if (getCompletedPredicate() != null) {\n                predicate = getCompletedPredicate().createPredicate(routeContext);\n            }\n            if (predicate != null) {\n                aggregator = new Aggregator(processor, aggregateExpression, strategy, predicate);\n            } else {\n                aggregator = new Aggregator(processor, aggregateExpression, strategy);\n            }\n        }\n        \n        if (batchSize != null) {\n            aggregator.setBatchSize(batchSize);\n        }\n        \n        if (batchTimeout != null) {\n            aggregator.setBatchTimeout(batchTimeout);\n        }\n\n        if (outBatchSize != null) {\n            aggregator.setOutBatchSize(outBatchSize);\n        }\n        \n        return aggregator;\n    }","id":34633,"modified_method":"protected Aggregator createAggregator(RouteContext routeContext) throws Exception {\n        final Processor processor = routeContext.createProcessor(this);\n\n        final Aggregator aggregator;\n        if (getAggregationCollection() == null) {\n            setAggregationCollection(createAggregationCollection(routeContext));\n        }\n        \n        if (aggregationCollection != null) {\n            // create the aggregator using the collection\n            // pre configure the collection if its expression and strategy is not set, then\n            // use the ones that is pre configured with this type\n            if (aggregationCollection.getCorrelationExpression() == null) {\n                aggregationCollection.setCorrelationExpression(getExpression());\n            }\n            if (aggregationCollection.getAggregationStrategy() == null) {\n                AggregationStrategy strategy = createAggregationStrategy(routeContext);\n                aggregationCollection.setAggregationStrategy(strategy);\n            }\n            aggregator = new Aggregator(processor, aggregationCollection);\n        } else {\n            // create the aggregator using a default collection\n            AggregationStrategy strategy = createAggregationStrategy(routeContext);\n\n            if (getExpression() == null) {\n                throw new IllegalArgumentException(\"You need to specify an expression or \"\n                                                   + \"aggregation collection for this aggregator: \" + this);\n            }\n            \n            Expression aggregateExpression = getExpression().createExpression(routeContext);           \n\n            Predicate predicate = null;\n            if (getCompletedPredicate() != null) {\n                predicate = getCompletedPredicate().createPredicate(routeContext);\n            }\n            if (predicate != null) {\n                aggregator = new Aggregator(processor, aggregateExpression, strategy, predicate);\n            } else {\n                aggregator = new Aggregator(processor, aggregateExpression, strategy);\n            }\n        }\n        \n        if (batchSize != null) {\n            aggregator.setBatchSize(batchSize);\n        }\n        \n        if (batchTimeout != null) {\n            aggregator.setBatchTimeout(batchTimeout);\n        }\n\n        if (outBatchSize != null) {\n            aggregator.setOutBatchSize(outBatchSize);\n        }\n\n        if (groupExchanges != null) {\n            aggregator.setGroupExchanges(groupExchanges);\n        }\n        \n        return aggregator;\n    }","commit_id":"33cfe4d7efdd19217b1cbf1841239501ea53cebb","url":"https://github.com/apache/camel"},{"original_method":"private void sendExchanges() throws Exception {\n            Iterator<Exchange> iter = collection.iterator();\n            while (iter.hasNext()) {\n                Exchange exchange = iter.next();\n                iter.remove();\n                processExchange(exchange);\n            }\n        }","id":34634,"modified_method":"private void sendExchanges() throws Exception {\n            GroupedExchange grouped = null;\n\n            Iterator<Exchange> iter = collection.iterator();\n            while (iter.hasNext()) {\n                Exchange exchange = iter.next();\n                iter.remove();\n                if (!groupExchanges) {\n                    // non grouped so process the exchange one at a time\n                    processExchange(exchange);\n                } else {\n                    // grouped so add all exchanges into one group\n                    if (grouped == null) {\n                        grouped = new GroupedExchange(exchange.getContext());\n                    }\n                    grouped.addExchange(exchange);\n                }\n            }\n\n            // and after adding process the single grouped exchange\n            if (grouped != null) {\n                processExchange(grouped);\n            }\n        }","commit_id":"33cfe4d7efdd19217b1cbf1841239501ea53cebb","url":"https://github.com/apache/camel"},{"original_method":"private Queue<Exchange> createExchanges(List<Record> records, String lastSeenSequenceNumber) {\n        Queue<Exchange> exchanges = new ArrayDeque<>();\n        BigIntComparisons condition = null;\n        BigInteger providedSeqNum = null;\n        if (lastSeenSequenceNumber != null) {\n            providedSeqNum = new BigInteger(lastSeenSequenceNumber);\n            condition = BigIntComparisons.Conditions.LT;\n        }\n        switch(getEndpoint().getIteratorType()) {\n        case AFTER_SEQUENCE_NUMBER:\n            condition = BigIntComparisons.Conditions.LT;\n            providedSeqNum = new BigInteger(getEndpoint().getSequenceNumberProvider().getSequenceNumber());\n            break;\n        case AT_SEQUENCE_NUMBER:\n            condition = BigIntComparisons.Conditions.LTEQ;\n            providedSeqNum = new BigInteger(getEndpoint().getSequenceNumberProvider().getSequenceNumber());\n            break;\n        }\n        for (Record record : records) {\n            BigInteger recordSeqNum = new BigInteger(record.getDynamodb().getSequenceNumber());\n            if (condition == null || condition.matches(providedSeqNum, recordSeqNum)) {\n                exchanges.add(getEndpoint().createExchange(record));\n            }\n        }\n        return exchanges;\n    }","id":34635,"modified_method":"private Queue<Exchange> createExchanges(List<Record> records, String lastSeenSequenceNumber) {\n        Queue<Exchange> exchanges = new ArrayDeque<>();\n        BigIntComparisons condition = null;\n        BigInteger providedSeqNum = null;\n        if (lastSeenSequenceNumber != null) {\n            providedSeqNum = new BigInteger(lastSeenSequenceNumber);\n            condition = BigIntComparisons.Conditions.LT;\n        }\n        switch(getEndpoint().getIteratorType()) {\n        case AFTER_SEQUENCE_NUMBER:\n            condition = BigIntComparisons.Conditions.LT;\n            providedSeqNum = new BigInteger(getEndpoint().getSequenceNumberProvider().getSequenceNumber());\n            break;\n        case AT_SEQUENCE_NUMBER:\n            condition = BigIntComparisons.Conditions.LTEQ;\n            providedSeqNum = new BigInteger(getEndpoint().getSequenceNumberProvider().getSequenceNumber());\n            break;\n        default:\n        }\n        for (Record record : records) {\n            BigInteger recordSeqNum = new BigInteger(record.getDynamodb().getSequenceNumber());\n            if (condition == null || condition.matches(providedSeqNum, recordSeqNum)) {\n                exchanges.add(getEndpoint().createExchange(record));\n            }\n        }\n        return exchanges;\n    }","commit_id":"2f1c8599c689146cad9ec312086b565b05299287","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected int poll() throws Exception {\n        GetRecordsResult result;\n        try {\n            GetRecordsRequest req = new GetRecordsRequest()\n                        .withShardIterator(shardIteratorHandler.getShardIterator(null))\n                        .withLimit(getEndpoint().getMaxResultsPerRequest());\n            result = getClient().getRecords(req);\n        } catch (ExpiredIteratorException e) {\n            LOG.warn(\"Expired Shard Iterator, attempting to resume from \" + lastSeenSequenceNumber, e);\n            GetRecordsRequest req = new GetRecordsRequest()\n                        .withShardIterator(shardIteratorHandler.getShardIterator(lastSeenSequenceNumber))\n                        .withLimit(getEndpoint().getMaxResultsPerRequest());\n            result = getClient().getRecords(req);\n        }\n\n        Queue<Exchange> exchanges = createExchanges(result.getRecords(), lastSeenSequenceNumber);\n        int processedExchangeCount = processBatch(CastUtils.cast(exchanges));\n\n        shardIteratorHandler.updateShardIterator(result.getNextShardIterator());\n        if (!result.getRecords().isEmpty()) {\n            lastSeenSequenceNumber = result.getRecords().get((result.getRecords().size()-1)).getDynamodb().getSequenceNumber();\n        }\n\n        return processedExchangeCount;\n    }","id":34636,"modified_method":"@Override\n    protected int poll() throws Exception {\n        GetRecordsResult result;\n        try {\n            GetRecordsRequest req = new GetRecordsRequest()\n                        .withShardIterator(shardIteratorHandler.getShardIterator(null))\n                        .withLimit(getEndpoint().getMaxResultsPerRequest());\n            result = getClient().getRecords(req);\n        } catch (ExpiredIteratorException e) {\n            LOG.warn(\"Expired Shard Iterator, attempting to resume from \" + lastSeenSequenceNumber, e);\n            GetRecordsRequest req = new GetRecordsRequest()\n                        .withShardIterator(shardIteratorHandler.getShardIterator(lastSeenSequenceNumber))\n                        .withLimit(getEndpoint().getMaxResultsPerRequest());\n            result = getClient().getRecords(req);\n        }\n        List<Record> records = result.getRecords();\n\n        Queue<Exchange> exchanges = createExchanges(records, lastSeenSequenceNumber);\n        int processedExchangeCount = processBatch(CastUtils.cast(exchanges));\n\n        shardIteratorHandler.updateShardIterator(result.getNextShardIterator());\n        if (!records.isEmpty()) {\n            lastSeenSequenceNumber = records.get(records.size() - 1).getDynamodb().getSequenceNumber();\n        }\n\n        return processedExchangeCount;\n    }","commit_id":"2f1c8599c689146cad9ec312086b565b05299287","url":"https://github.com/apache/camel"},{"original_method":"String getShardIterator(String resumeFromSequenceNumber) {\n        ShardIteratorType iteratorType = getEndpoint().getIteratorType();\n        String sequenceNumber = getEndpoint().getSequenceNumber();\n        if (resumeFromSequenceNumber != null) {\n            iteratorType = ShardIteratorType.AFTER_SEQUENCE_NUMBER;\n            currentShard = null;\n            currentShardIterator = null;\n            sequenceNumber = resumeFromSequenceNumber;\n        }\n        // either return a cached one or get a new one via a GetShardIterator request.\n        if (currentShardIterator == null) {\n            ListStreamsRequest req0 = new ListStreamsRequest()\n                    .withTableName(getEndpoint().getTableName());\n            ListStreamsResult res0 = getClient().listStreams(req0);\n            final String streamArn = res0.getStreams().get(0).getStreamArn(); // XXX assumes there is only one stream\n            DescribeStreamRequest req1 = new DescribeStreamRequest()\n                    .withStreamArn(streamArn);\n            DescribeStreamResult res1 = getClient().describeStream(req1);\n            shardList.addAll(res1.getStreamDescription().getShards());\n\n            LOG.trace(\"Current shard is: {} (in {})\", currentShard, shardList);\n            if (currentShard == null) {\n                currentShard = resolveNewShard(iteratorType, resumeFromSequenceNumber);\n            } else {\n                currentShard = shardList.nextAfter(currentShard);\n            }\n            shardList.removeOlderThan(currentShard);\n            LOG.trace(\"Next shard is: {} (in {})\", currentShard, shardList);\n            GetShardIteratorRequest req = new GetShardIteratorRequest()\n                    .withStreamArn(streamArn)\n                    .withShardId(currentShard.getShardId())\n                    .withShardIteratorType(iteratorType);\n            if (getEndpoint().getIteratorType() == ShardIteratorType.AFTER_SEQUENCE_NUMBER\n                    || getEndpoint().getIteratorType() == ShardIteratorType.AFTER_SEQUENCE_NUMBER\n                    || resumeFromSequenceNumber != null\n                    ) {\n                // if you request with a sequence number that is LESS than the\n                // start of the shard, you get a HTTP 400 from AWS.\n                // So only add the sequence number if the endpoints\n                // sequence number is less than or equal to the starting\n                // sequence for the shard.\n                // Otherwise change the shart iterator type to trim_horizon\n                // because we get a 400 when we use one of the\n                // {at,after}_sequence_number iterator types and don't supply\n                // a sequence number.\n\n                if (BigIntComparisons.Conditions.LTEQ.matches(\n                        new BigInteger(currentShard.getSequenceNumberRange().getStartingSequenceNumber()),\n                        new BigInteger(sequenceNumber)\n                )) {\n                    req = req.withSequenceNumber(sequenceNumber);\n                } else {\n                    req = req.withShardIteratorType(ShardIteratorType.TRIM_HORIZON);\n                }\n            }\n            GetShardIteratorResult result = getClient().getShardIterator(req);\n            currentShardIterator = result.getShardIterator();\n        }\n        LOG.trace(\"Shard Iterator is: {}\", currentShardIterator);\n        return currentShardIterator;\n    }","id":34637,"modified_method":"String getShardIterator(String resumeFromSequenceNumber) {\n        ShardIteratorType iteratorType = getEndpoint().getIteratorType();\n        String sequenceNumber = getEndpoint().getSequenceNumber();\n        if (resumeFromSequenceNumber != null) {\n            // Reset things as we're in an error condition.\n            currentShard = null;\n            currentShardIterator = null;\n            iteratorType = ShardIteratorType.AFTER_SEQUENCE_NUMBER;\n            sequenceNumber = resumeFromSequenceNumber;\n        }\n        // either return a cached one or get a new one via a GetShardIterator request.\n        if (currentShardIterator == null) {\n            ListStreamsResult streamsListResult = getClient().listStreams(\n                    new ListStreamsRequest().withTableName(getEndpoint().getTableName())\n            );\n            final String streamArn = streamsListResult.getStreams().get(0).getStreamArn(); // XXX assumes there is only one stream\n            DescribeStreamResult streamDescriptionResult = getClient().describeStream(\n                    new DescribeStreamRequest().withStreamArn(streamArn)\n            );\n            shardList.addAll(streamDescriptionResult.getStreamDescription().getShards());\n\n            LOG.trace(\"Current shard is: {} (in {})\", currentShard, shardList);\n            if (currentShard == null) {\n                currentShard = resolveNewShard(iteratorType, resumeFromSequenceNumber);\n            } else {\n                currentShard = shardList.nextAfter(currentShard);\n            }\n            shardList.removeOlderThan(currentShard);\n            LOG.trace(\"Next shard is: {} (in {})\", currentShard, shardList);\n\n            GetShardIteratorResult result = getClient().getShardIterator(\n                    buildGetShardIteratorRequest(streamArn, iteratorType, sequenceNumber)\n            );\n            currentShardIterator = result.getShardIterator();\n        }\n        LOG.trace(\"Shard Iterator is: {}\", currentShardIterator);\n        return currentShardIterator;\n    }","commit_id":"2f1c8599c689146cad9ec312086b565b05299287","url":"https://github.com/apache/camel"},{"original_method":"public static long[] getGroupIds(\n\t\tPortletPreferences portletPreferences, long scopeGroupId,\n\t\tLayout layout) {\n\n\t\tboolean defaultScope = GetterUtil.getBoolean(\n\t\t\tportletPreferences.getValue(\"defaultScope\", null), true);\n\n\t\tif (defaultScope) {\n\t\t\treturn new long[] {scopeGroupId};\n\t\t}\n\n\t\tlong defaultScopeId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"defaultScope\", null));\n\n\t\tif (defaultScopeId > 0) {\n\t\t\treturn new long[] {defaultScopeId};\n\t\t}\n\n\t\tString[] scopeIds = portletPreferences.getValues(\n\t\t\t\"scopeIds\",\n\t\t\tnew String[] {\"group\" + StringPool.UNDERLINE + scopeGroupId});\n\n\t\tlong[] groupIds = new long[scopeIds.length];\n\n\t\tfor (int i = 0; i < scopeIds.length; i++) {\n\t\t\ttry {\n\t\t\t\tString[] scopeIdFragments = StringUtil.split(\n\t\t\t\t\tscopeIds[i], CharPool.UNDERLINE);\n\n\t\t\t\tif (scopeIdFragments[0].equals(\"Layout\")) {\n\t\t\t\t\tlong scopeIdLayoutId = GetterUtil.getLong(\n\t\t\t\t\t\tscopeIdFragments[1]);\n\n\t\t\t\t\tLayout scopeIdLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\tscopeGroupId, layout.isPrivateLayout(),\n\t\t\t\t\t\tscopeIdLayoutId);\n\n\t\t\t\t\tGroup scopeIdGroup = scopeIdLayout.getScopeGroup();\n\n\t\t\t\t\tgroupIds[i] = scopeIdGroup.getGroupId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (scopeIdFragments[1].equals(GroupConstants.DEFAULT)) {\n\t\t\t\t\t\tgroupIds[i] = scopeGroupId;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong scopeIdGroupId = GetterUtil.getLong(\n\t\t\t\t\t\t\tscopeIdFragments[1]);\n\n\t\t\t\t\t\tgroupIds[i] = scopeIdGroupId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn groupIds;\n\t}","id":34638,"modified_method":"public static long[] getGroupIds(\n\t\tPortletPreferences portletPreferences, long scopeGroupId,\n\t\tLayout layout) {\n\n\t\tString defaultScopeId = GetterUtil.getString(\n\t\t\tportletPreferences.getValue(\"defaultScope\", null));\n\n\t\tif (Validator.equals(defaultScopeId, StringPool.TRUE)) {\n\t\t\treturn new long[] {scopeGroupId};\n\t\t}\n\t\telse if (Validator.equals(defaultScopeId, StringPool.FALSE)) {\n\t\t\tString[] scopeIds = portletPreferences.getValues(\n\t\t\t\t\"scopeIds\",\n\t\t\t\tnew String[] {\"group\" + StringPool.UNDERLINE + scopeGroupId});\n\n\t\t\tlong[] groupIds = new long[scopeIds.length];\n\n\t\t\tfor (int i = 0; i < scopeIds.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tgroupIds[i] = getGroupId(\n\t\t\t\t\t\tscopeIds[i], scopeGroupId, layout.isPrivateLayout());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn groupIds;\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tlong groupId = getGroupId(\n\t\t\t\t\tdefaultScopeId, scopeGroupId, layout.isPrivateLayout());\n\n\t\t\t\treturn new long[] {groupId};\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\treturn new long[0];\n\t\t\t}\n\t\t}\n\t}","commit_id":"af97a766c3bacdb452b6451f89e22a0ffbefecf9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<PortletPreferences> findByC_G_O_O_P_P(\n\t\t\tlong companyId, long groupId, long ownerId, int ownerType,\n\t\t\tString portletId, boolean privateLayout)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_C_G_O_O_P_P);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addEntity(\"PortletPreferences\", PortletPreferencesImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(companyId);\n\t\t\tqPos.add(groupId);\n\t\t\tqPos.add(ownerId);\n\t\t\tqPos.add(ownerType);\n\t\t\tqPos.add(portletId);\n\t\t\tqPos.add(portletId.concat(\"_INSTANCE_%\"));\n\t\t\tqPos.add(privateLayout);\n\n\t\t\treturn q.list(true);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":34639,"modified_method":"public List<PortletPreferences> findByC_G_O_O_P_P(\n\t\t\tlong companyId, long groupId, long ownerId, int ownerType,\n\t\t\tString portletId, boolean privateLayout)\n\t\tthrows SystemException {\n\n\t\treturn doFindByC_G_O_O_P_P(\n\t\t\tcompanyId, groupId, ownerId, ownerType, portletId, privateLayout,\n\t\t\tfalse);\n\t}","commit_id":"5305f90e378b67998ea35df4b121cb8f82b09bda","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void clearCache(PortletPreferences portletPreferences) {\n\t\ttry {\n\t\t\tlong companyId = 0;\n\n\t\t\tLayout layout = LayoutUtil.fetchByPrimaryKey(\n\t\t\t\tportletPreferences.getPlid());\n\n\t\t\tif ((layout != null) && !layout.isPrivateLayout()) {\n\t\t\t\tcompanyId = layout.getCompanyId();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLayoutRevision layoutRevision =\n\t\t\t\t\tLayoutRevisionUtil.fetchByPrimaryKey(\n\t\t\t\t\t\tportletPreferences.getPlid());\n\n\t\t\t\tif ((layoutRevision != null) &&\n\t\t\t\t\t!layoutRevision.isPrivateLayout()) {\n\n\t\t\t\t\tcompanyId = layoutRevision.getCompanyId();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (companyId > 0) {\n\t\t\t\tCacheUtil.clearCache(companyId);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCacheUtil.clearCache();\n\t\t}\n\t}","id":34640,"modified_method":"protected void clearCache(PortletPreferences portletPreferences) {\n\t\ttry {\n\t\t\tlong companyId = 0;\n\t\t\tlong groupId = 0;\n\t\t\tboolean privateLayout = false;\n\n\t\t\tLayout layout = LayoutUtil.fetchByPrimaryKey(\n\t\t\t\tportletPreferences.getPlid());\n\n\t\t\tif (layout != null) {\n\t\t\t\tcompanyId = layout.getCompanyId();\n\t\t\t\tgroupId = layout.getGroupId();\n\t\t\t\tprivateLayout = layout.isPrivateLayout();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLayoutRevision layoutRevision =\n\t\t\t\t\tLayoutRevisionUtil.fetchByPrimaryKey(\n\t\t\t\t\t\tportletPreferences.getPlid());\n\n\t\t\t\tif (layoutRevision != null) {\n\t\t\t\t\tcompanyId = layoutRevision.getCompanyId();\n\t\t\t\t\tgroupId = layoutRevision.getGroupId();\n\t\t\t\t\tprivateLayout = layoutRevision.isPrivateLayout();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!privateLayout) {\n\t\t\t\tCacheUtil.clearCache();\n\t\t\t}\n\n\t\t\tif ((companyId > 0) && (groupId > 0)) {\n\t\t\t\tObject[] finderArgs = new Object[] {\n\t\t\t\t\tcompanyId, groupId, portletPreferences.getOwnerId(),\n\t\t\t\t\tportletPreferences.getOwnerType(),\n\t\t\t\t\tportletPreferences.getPortletId(), privateLayout\n\t\t\t\t};\n\n\t\t\t\tFinderCacheUtil.removeResult(\n\t\t\t\t\tPortletPreferencesFinderImpl\n\t\t\t\t\t\t.FINDER_PATH_FIND_PLIDS_BY_C_G_O_O_P_P,\n\t\t\t\t\tfinderArgs);\n\n\t\t\t\tFinderCacheUtil.removeResult(\n\t\t\t\t\tPortletPreferencesFinderImpl\n\t\t\t\t\t\t.FINDER_PATH_FIND_PORTLET_PREFERENCES_BY_C_G_O_O_P_P,\n\t\t\t\t\tfinderArgs);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\n\t\t\t\t\"Clearing cache for \" + portletPreferences + \" has failed.\", e);\n\t\t}\n\t}","commit_id":"5305f90e378b67998ea35df4b121cb8f82b09bda","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public LayoutsAdminDisplayContext(\n\t\tHttpServletRequest request,\n\t\tLiferayPortletResponse liferayPortletResponse) {\n\n\t\t_request = request;\n\t\t_liferayPortletResponse = liferayPortletResponse;\n\n\t\t_groupDisplayContextHelper = new GroupDisplayContextHelper(request);\n\n\t\tboolean privateLayout = false;\n\t\tString tabs1 = ParamUtil.getString(request, \"tabs1\");\n\n\t\t_themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (Validator.isNull(tabs1)) {\n\t\t\ttabs1 = \"public-pages\";\n\n\t\t\tLayoutSet layoutSet = _themeDisplay.getLayoutSet();\n\n\t\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\t\ttabs1 = \"private-pages\";\n\t\t\t}\n\t\t}\n\n\t\tif (tabs1.equals(\"my-dashboard\") || tabs1.equals(\"private-pages\")) {\n\t\t\tprivateLayout = true;\n\t\t}\n\n\t\tLayout selLayout = getSelLayout();\n\n\t\tif (selLayout != null) {\n\t\t\tprivateLayout = selLayout.isPrivateLayout();\n\t\t}\n\n\t\tGroup liveGroup = getLiveGroup();\n\n\t\tif (liveGroup.isUser() && !isPublicLayoutsModifiable() &&\n\t\t\tisPrivateLayoutsModifiable() && !privateLayout) {\n\n\t\t\tprivateLayout = true;\n\t\t\ttabs1 = \"my-dashboard\";\n\t\t}\n\n\t\tGroup selGroup = getSelGroup();\n\n\t\tif (selGroup.isLayoutSetPrototype()) {\n\t\t\tprivateLayout = true;\n\t\t}\n\n\t\t_privateLayout = privateLayout;\n\t\t_tabs1 = tabs1;\n\n\t\tString portletName = getPortletName();\n\n\t\tif (portletName.equals(PortletKeys.LAYOUTS_ADMIN) ||\n\t\t\tportletName.equals(PortletKeys.MY_ACCOUNT)) {\n\n\t\t\tPortletDisplay portletDisplay = _themeDisplay.getPortletDisplay();\n\n\t\t\tportletDisplay.setURLBack(getBackURL());\n\t\t}\n\n\t\t_request.setAttribute(\n\t\t\tcom.liferay.portal.util.WebKeys.LAYOUT_DESCRIPTIONS,\n\t\t\tgetLayoutDescriptions());\n\t}","id":34641,"modified_method":"public LayoutsAdminDisplayContext(\n\t\t\tHttpServletRequest request,\n\t\t\tLiferayPortletResponse liferayPortletResponse)\n\t\tthrows PortalException {\n\n\t\t_request = request;\n\t\t_liferayPortletResponse = liferayPortletResponse;\n\n\t\t_groupDisplayContextHelper = new GroupDisplayContextHelper(request);\n\n\t\tboolean privateLayout = false;\n\t\tString tabs1 = ParamUtil.getString(request, \"tabs1\");\n\n\t\t_themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (Validator.isNull(tabs1)) {\n\t\t\ttabs1 = \"public-pages\";\n\n\t\t\tLayoutSet layoutSet = _themeDisplay.getLayoutSet();\n\n\t\t\tGroup group = layoutSet.getGroup();\n\n\t\t\tif (!group.isControlPanel() && layoutSet.isPrivateLayout()) {\n\t\t\t\ttabs1 = \"private-pages\";\n\t\t\t}\n\t\t}\n\n\t\tif (tabs1.equals(\"my-dashboard\") || tabs1.equals(\"private-pages\")) {\n\t\t\tprivateLayout = true;\n\t\t}\n\n\t\tLayout selLayout = getSelLayout();\n\n\t\tif (selLayout != null) {\n\t\t\tprivateLayout = selLayout.isPrivateLayout();\n\t\t}\n\n\t\tGroup liveGroup = getLiveGroup();\n\n\t\tif (liveGroup.isUser() && !isPublicLayoutsModifiable() &&\n\t\t\tisPrivateLayoutsModifiable() && !privateLayout) {\n\n\t\t\tprivateLayout = true;\n\t\t\ttabs1 = \"my-dashboard\";\n\t\t}\n\n\t\tGroup selGroup = getSelGroup();\n\n\t\tif (selGroup.isLayoutSetPrototype()) {\n\t\t\tprivateLayout = true;\n\t\t}\n\n\t\t_privateLayout = privateLayout;\n\t\t_tabs1 = tabs1;\n\n\t\tString portletName = getPortletName();\n\n\t\tif (portletName.equals(PortletKeys.LAYOUTS_ADMIN) ||\n\t\t\tportletName.equals(PortletKeys.MY_ACCOUNT)) {\n\n\t\t\tPortletDisplay portletDisplay = _themeDisplay.getPortletDisplay();\n\n\t\t\tportletDisplay.setURLBack(getBackURL());\n\t\t}\n\n\t\t_request.setAttribute(\n\t\t\tcom.liferay.portal.util.WebKeys.LAYOUT_DESCRIPTIONS,\n\t\t\tgetLayoutDescriptions());\n\t}","commit_id":"0bae38d7de8c2bec30e2ce11cf3750abb2376a82","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String injectVirtualGroupURL(String layoutURL, Locale locale) {\n\t\tif (_sourceLayout.isTypeURL()) {\n\t\t\treturn layoutURL;\n\t\t}\n\n\t\ttry {\n\t\t\tGroup group = _sourceLayout.getGroup();\n\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tint pos = -1;\n\n\t\t\tif (_targetGroup.isUser() && isPrivateLayout()) {\n\t\t\t\tpos = layoutURL.indexOf(\n\t\t\t\t\tPropsValues.\n\t\t\t\t\t\tLAYOUT_FRIENDLY_URL_PRIVATE_GROUP_SERVLET_MAPPING);\n\n\t\t\t\tsb.append(layoutURL.substring(0, pos));\n\t\t\t\tsb.append(\n\t\t\t\t\tPropsValues.\n\t\t\t\t\t\tLAYOUT_FRIENDLY_URL_PRIVATE_USER_SERVLET_MAPPING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpos = layoutURL.indexOf(group.getFriendlyURL());\n\n\t\t\t\tsb.append(layoutURL.substring(0, pos));\n\t\t\t}\n\n\t\t\tsb.append(_targetGroup.getFriendlyURL());\n\t\t\tsb.append(getFriendlyURL(locale));\n\n\t\t\tpos = layoutURL.indexOf(StringPool.QUESTION);\n\n\t\t\tif (pos > 0) {\n\t\t\t\tsb.append(layoutURL.substring(pos));\n\t\t\t}\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}","id":34642,"modified_method":"protected String injectVirtualGroupURL(String layoutURL, Locale locale) {\n\t\tif (_sourceLayout.isTypeURL()) {\n\t\t\treturn layoutURL;\n\t\t}\n\n\t\ttry {\n\t\t\tGroup group = _sourceLayout.getGroup();\n\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tint pos = layoutURL.indexOf(\n\t\t\t\tPropsValues.LAYOUT_FRIENDLY_URL_PRIVATE_GROUP_SERVLET_MAPPING);\n\n\t\t\tif (_sourceLayout.isPrivateLayout() && _targetGroup.isUser() &&\n\t\t\t\t(pos > 0)) {\n\n\t\t\t\tsb.append(layoutURL.substring(0, pos));\n\t\t\t\tsb.append(\n\t\t\t\t\tPropsValues.\n\t\t\t\t\t\tLAYOUT_FRIENDLY_URL_PRIVATE_USER_SERVLET_MAPPING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpos = layoutURL.indexOf(group.getFriendlyURL());\n\n\t\t\t\tsb.append(layoutURL.substring(0, pos));\n\t\t\t}\n\n\t\t\tsb.append(_targetGroup.getFriendlyURL());\n\t\t\tsb.append(getFriendlyURL(locale));\n\n\t\t\tpos = layoutURL.indexOf(StringPool.QUESTION);\n\n\t\t\tif (pos > 0) {\n\t\t\t\tsb.append(layoutURL.substring(pos));\n\t\t\t}\n\n\t\t\treturn sb.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}","commit_id":"f4c80ca9b8d42647016407ed29cc0b11d1cbe41b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Future<Throwable> disable( ServiceConfiguration config ) {\n    return fireLifecycleEvent( new Disable( config ) );\n  }","id":34643,"modified_method":"public static void disable( ServiceConfiguration config ) {\n    fireLifecycleEvent( new Disable( config ) );\n  }","commit_id":"a7d8f73e6c50f58e76318a1cb0e8c786e2e3270f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Future<Throwable> stop( ServiceConfiguration config ) {\n    return fireLifecycleEvent( new Stop( config ) );\n  }","id":34644,"modified_method":"public static void stop( ServiceConfiguration config ) {\n    fireLifecycleEvent( new Stop( config ) );\n  }","commit_id":"a7d8f73e6c50f58e76318a1cb0e8c786e2e3270f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Future<Throwable> start( ServiceConfiguration config ) {\n    return fireLifecycleEvent( new Start( config ) );\n  }","id":34645,"modified_method":"public static void start( ServiceConfiguration config ) {\n    fireLifecycleEvent( new Start( config ) );\n  }","commit_id":"a7d8f73e6c50f58e76318a1cb0e8c786e2e3270f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Future<Throwable> enable( ServiceConfiguration config ) {\n    return fireLifecycleEvent( new Enable( config ) );\n  }","id":34646,"modified_method":"public static void enable( ServiceConfiguration config ) {\n    fireLifecycleEvent( new Enable( config ) );\n  }","commit_id":"a7d8f73e6c50f58e76318a1cb0e8c786e2e3270f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static Future<Throwable> fireLifecycleEvent( final LifecycleEvent event ) {\n    final ServiceConfiguration config = event.getReference( );\n    final ComponentId componentId = config.getComponentId( );\n    final Future<Throwable> future = Threads.lookup( Empyrean.class, LifecycleEvents.class ).submit( new Callable<Throwable>( ) {\n      \n      @Override\n      public Throwable call( ) throws Exception {\n        try {\n          ListenerRegistry.getInstance( ).fireEvent( config, event );\n        } catch ( Exception ex1 ) {\n          config.info( ex1 );\n          return ex1;\n        }\n        try {\n          ListenerRegistry.getInstance( ).fireEvent( componentId, event );\n        } catch ( Exception ex1 ) {\n          config.info( ex1 );\n          return ex1;\n        }\n        return null;\n      }\n      \n    } );\n    return future;\n  }","id":34647,"modified_method":"private static void fireLifecycleEvent( final LifecycleEvent event ) {\n    final ServiceConfiguration config = event.getReference( );\n    final ComponentId componentId = config.getComponentId( );\n    try {\n      ListenerRegistry.getInstance( ).fireEventAsync( config, event );\n    } catch ( Exception ex1 ) {\n      config.info( ex1 );\n      Logs.exhaust( ).error( ex1, ex1 );\n    }\n    try {\n      ListenerRegistry.getInstance( ).fireEventAsync( componentId, event );\n    } catch ( Exception ex1 ) {\n      config.info( ex1 );\n      Logs.exhaust( ).error( ex1, ex1 );\n    }\n  }","commit_id":"a7d8f73e6c50f58e76318a1cb0e8c786e2e3270f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void shutdown()\n    {\n        if ( graphDbInstance.started() )\n        {\n            sendShutdownEvent();\n        }\n\n        if ( this.shellService != null )\n        {\n            try\n            {\n                this.shellService.shutdown();\n                this.shellService = null;\n            }\n            catch ( Throwable t )\n            {\n                log.warning( \"Error shutting down shell server: \" + t );\n            }\n        }\n        graphDbInstance.shutdown();\n    }","id":34648,"modified_method":"public void shutdown()\n    {\n        if ( graphDbInstance.started() )\n        {\n            sendShutdownEvent();\n        }\n\n        jmxShutdownHook.run();\n\n        if ( this.shellService != null )\n        {\n            try\n            {\n                this.shellService.shutdown();\n                this.shellService = null;\n            }\n            catch ( Throwable t )\n            {\n                log.warning( \"Error shutting down shell server: \" + t );\n            }\n        }\n        graphDbInstance.shutdown();\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates an embedded {@link GraphDatabaseService} with a store located in\n     * <code>storeDir<\/code>, which will be created if it doesn't already exist.\n     *\n     * @param storeDir the store directory for the Neo4j db files\n     */\n    public EmbeddedGraphDbImpl( String storeDir, GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        initJMX( params );\n    }","id":34649,"modified_method":"/**\n     * Creates an embedded {@link GraphDatabaseService} with a store located in\n     * <code>storeDir<\/code>, which will be created if it doesn't already exist.\n     *\n     * @param storeDir the store directory for the Neo4j db files\n     */\n    public EmbeddedGraphDbImpl( String storeDir, GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        jmxShutdownHook = initJMX( params );\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void initJMX( final Map<Object, Object> params )\n    {\n        Neo4jJmx.initJMX( new Neo4jJmx.Creator(\n                instanceId, KERNEL_VERSION,\n                (NeoStoreXaDataSource) graphDbInstance.getConfig().getTxModule()\n                .getXaDataSourceManager().getXaDataSource( \"nioneodb\" ) )\n        {\n            @Override\n            protected void create( Neo4jJmx.Factory jmx )\n            {\n                jmx.createPrimitiveMBean( nodeManager );\n                jmx.createCacheMBean( nodeManager );\n                jmx.createDynamicConfigurationMBean( params );\n            }\n        } );\n    }","id":34650,"modified_method":"private Runnable initJMX( final Map<Object, Object> params )\n    {\n        return Neo4jJmx.initJMX( new Neo4jJmx.Creator(\n                instanceId, KERNEL_VERSION,\n                (NeoStoreXaDataSource) graphDbInstance.getConfig().getTxModule()\n                .getXaDataSourceManager().getXaDataSource( \"nioneodb\" ) )\n        {\n            @Override\n            protected void create( Neo4jJmx.Factory jmx )\n            {\n                jmx.createDynamicConfigurationMBean( params );\n                jmx.createPrimitiveMBean( nodeManager );\n                jmx.createCacheMBean( nodeManager );\n                // jmx.createLockManagerMBean();\n                jmx.createTransactionManagerMBean( getConfig().getTxModule() );\n                jmx.createMemoryMappingMBean( getConfig().getTxModule() );\n                // jmx.createXaManagerMBean();\n            }\n        } );\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * A non-standard way of creating an embedded {@link GraphDatabaseService}\n     * with a set of configuration parameters. Will most likely be removed in\n     * future releases.\n     * \n     * @param storeDir the store directory for the db files\n     * @param config configuration parameters\n     */\n    public EmbeddedGraphDbImpl( String storeDir, Map<String, String> config,\n        GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                config, kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        initJMX( params );\n    }","id":34651,"modified_method":"/**\n     * A non-standard way of creating an embedded {@link GraphDatabaseService}\n     * with a set of configuration parameters. Will most likely be removed in\n     * future releases.\n     *\n     * @param storeDir the store directory for the db files\n     * @param config configuration parameters\n     */\n    public EmbeddedGraphDbImpl( String storeDir, Map<String, String> config,\n        GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                config, kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        jmxShutdownHook = initJMX( params );\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getStoreId()\n    {\n        return storeId;\n    }","id":34652,"modified_method":"public String getStoreId()\n    {\n        return Long.toHexString( storeId );\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"Kernel( int instanceId, String kernelVersion, NeoStoreXaDataSource datasource )\n    {\n        super( instanceId );\n        this.kernelVersion = kernelVersion;\n        storeCreationDate = datasource.getCreationTime();\n        storeLogVersion = datasource.getCurrentLogVersion();\n        isReadOnly = datasource.isReadOnly();\n        storeDir = datasource.getStoreDir();\n        storeId = datasource.getRandomIdentifier();\n        kernelStartTime = new Date().getTime();\n    }","id":34653,"modified_method":"Kernel( int instanceId, String kernelVersion, NeoStoreXaDataSource datasource )\n    {\n        super( instanceId );\n        this.kernelVersion = kernelVersion;\n        storeCreationDate = datasource.getCreationTime();\n        storeLogVersion = datasource.getCurrentLogVersion();\n        isReadOnly = datasource.isReadOnly();\n        storeId = datasource.getRandomIdentifier();\n\n        @SuppressWarnings( \"hiding\" )\n        String storeDir;\n        try\n        {\n            storeDir = new File( datasource.getStoreDir() ).getCanonicalFile().getAbsolutePath();\n        }\n        catch ( IOException e )\n        {\n            storeDir = new File( datasource.getStoreDir() ).getAbsolutePath();\n        }\n        this.storeDir = storeDir;\n\n        kernelStartTime = new Date().getTime();\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createDynamicConfigurationMBean( Map<Object, Object> params )\n        {\n            register( mbs, new Configuration( instanceId, params ) );\n        }","id":34654,"modified_method":"public void createDynamicConfigurationMBean( Map<Object, Object> params )\n        {\n            if ( !register( new Configuration( instanceId, params ) ) )\n                failedToRegister( \"ConfigurationMBean\" );\n        }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createPrimitiveMBean( NodeManager nodeManager )\n        {\n            register( mbs, new Primitive( instanceId, nodeManager ) );\n        }","id":34655,"modified_method":"public void createPrimitiveMBean( NodeManager nodeManager )\n        {\n            if ( !register( new Primitive( instanceId, nodeManager ) ) )\n                failedToRegister( \"KernelMBean\" );\n        }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void initJMX( Neo4jJmx.Creator creator )\n    {\n        Factory jmx = new Factory( getPlatformMBeanServer(), creator.id );\n        creator.create( jmx );\n        jmx.createKernelMBean( creator.kernelVersion, creator.datasource );\n    }","id":34656,"modified_method":"public static Runnable initJMX( Neo4jJmx.Creator creator )\n    {\n        Factory jmx = new Factory( getPlatformMBeanServer(), creator.id );\n        creator.create( jmx );\n        jmx.createKernelMBean( creator.kernelVersion, creator.datasource );\n        return new JmxShutdown( jmx.beans );\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void register( MBeanServer mbs, Neo4jJmx monitor )\n    {\n        try\n        {\n            mbs.registerMBean( monitor, monitor.objectName );\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":34657,"modified_method":"private static Neo4jJmx registerBean( MBeanServer mbs, Neo4jJmx bean )\n    {\n        try\n        {\n            mbs.registerMBean( bean, bean.objectName );\n            return bean;\n        }\n        catch ( Exception e )\n        {\n            return null;\n        }\n    }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Creator( int instanceId, String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            this.id = instanceId;\n            this.kernelVersion = kernelVersion;\n            this.datasource = datasource;\n        }","id":34658,"modified_method":"protected Creator( int instanceId, String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            if ( kernelVersion == null || datasource == null )\n            {\n                throw new IllegalArgumentException( \"null valued argument\" );\n            }\n            this.id = instanceId;\n            this.kernelVersion = kernelVersion;\n            this.datasource = datasource;\n        }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createKernelMBean( String kernelVersion, NeoStoreXaDataSource datasource )\n        {\n            register( mbs, new Kernel( instanceId, kernelVersion, datasource ) );\n        }","id":34659,"modified_method":"private void createKernelMBean( String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            if ( !register( new Kernel( instanceId, kernelVersion, datasource ) ) )\n                failedToRegister( \"KernelMBean\" );\n        }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createCacheMBean( NodeManager nodeManager )\n        {\n            register( mbs, new Cache( instanceId, nodeManager ) );\n        }","id":34660,"modified_method":"public void createCacheMBean( NodeManager nodeManager )\n        {\n            if ( !register( new Cache( instanceId, nodeManager ) ) )\n                failedToRegister( \"CacheMBean\" );\n        }","commit_id":"481411706ab551797e0b5193320b4f59e7a8161d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        if ( graphDbInstance.started() )\n        {\n            sendShutdownEvent();\n        }\n\n        if ( this.shellService != null )\n        {\n            try\n            {\n                this.shellService.shutdown();\n                this.shellService = null;\n            }\n            catch ( Throwable t )\n            {\n                log.warning( \"Error shutting down shell server: \" + t );\n            }\n        }\n        graphDbInstance.shutdown();\n    }","id":34661,"modified_method":"public void shutdown()\n    {\n        if ( graphDbInstance.started() )\n        {\n            sendShutdownEvent();\n        }\n\n        jmxShutdownHook.run();\n\n        if ( this.shellService != null )\n        {\n            try\n            {\n                this.shellService.shutdown();\n                this.shellService = null;\n            }\n            catch ( Throwable t )\n            {\n                log.warning( \"Error shutting down shell server: \" + t );\n            }\n        }\n        graphDbInstance.shutdown();\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates an embedded {@link GraphDatabaseService} with a store located in\n     * <code>storeDir<\/code>, which will be created if it doesn't already exist.\n     *\n     * @param storeDir the store directory for the Neo4j db files\n     */\n    public EmbeddedGraphDbImpl( String storeDir, GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        initJMX( params );\n    }","id":34662,"modified_method":"/**\n     * Creates an embedded {@link GraphDatabaseService} with a store located in\n     * <code>storeDir<\/code>, which will be created if it doesn't already exist.\n     *\n     * @param storeDir the store directory for the Neo4j db files\n     */\n    public EmbeddedGraphDbImpl( String storeDir, GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        jmxShutdownHook = initJMX( params );\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * A non-standard way of creating an embedded {@link GraphDatabaseService}\n     * with a set of configuration parameters. Will most likely be removed in\n     * future releases.\n     * \n     * @param storeDir the store directory for the db files\n     * @param config configuration parameters\n     */\n    public EmbeddedGraphDbImpl( String storeDir, Map<String, String> config,\n        GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                config, kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        initJMX( params );\n    }","id":34663,"modified_method":"/**\n     * A non-standard way of creating an embedded {@link GraphDatabaseService}\n     * with a set of configuration parameters. Will most likely be removed in\n     * future releases.\n     *\n     * @param storeDir the store directory for the db files\n     * @param config configuration parameters\n     */\n    public EmbeddedGraphDbImpl( String storeDir, Map<String, String> config,\n        GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                config, kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        jmxShutdownHook = initJMX( params );\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void initJMX( final Map<Object, Object> params )\n    {\n        Neo4jJmx.initJMX( new Neo4jJmx.Creator(\n                instanceId, KERNEL_VERSION,\n                (NeoStoreXaDataSource) graphDbInstance.getConfig().getTxModule()\n                .getXaDataSourceManager().getXaDataSource( \"nioneodb\" ) )\n        {\n            @Override\n            protected void create( Neo4jJmx.Factory jmx )\n            {\n                jmx.createPrimitiveMBean( nodeManager );\n                jmx.createCacheMBean( nodeManager );\n                jmx.createDynamicConfigurationMBean( params );\n            }\n        } );\n    }","id":34664,"modified_method":"private Runnable initJMX( final Map<Object, Object> params )\n    {\n        return Neo4jJmx.initJMX( new Neo4jJmx.Creator(\n                instanceId, KERNEL_VERSION,\n                (NeoStoreXaDataSource) graphDbInstance.getConfig().getTxModule()\n                .getXaDataSourceManager().getXaDataSource( \"nioneodb\" ) )\n        {\n            @Override\n            protected void create( Neo4jJmx.Factory jmx )\n            {\n                jmx.createDynamicConfigurationMBean( params );\n                jmx.createPrimitiveMBean( nodeManager );\n                jmx.createCacheMBean( nodeManager );\n                // jmx.createLockManagerMBean();\n                jmx.createTransactionManagerMBean( getConfig().getTxModule() );\n                jmx.createMemoryMappingMBean( getConfig().getTxModule() );\n                // jmx.createXaManagerMBean();\n            }\n        } );\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getStoreId()\n    {\n        return storeId;\n    }","id":34665,"modified_method":"public String getStoreId()\n    {\n        return Long.toHexString( storeId );\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"Kernel( int instanceId, String kernelVersion, NeoStoreXaDataSource datasource )\n    {\n        super( instanceId );\n        this.kernelVersion = kernelVersion;\n        storeCreationDate = datasource.getCreationTime();\n        storeLogVersion = datasource.getCurrentLogVersion();\n        isReadOnly = datasource.isReadOnly();\n        storeDir = datasource.getStoreDir();\n        storeId = datasource.getRandomIdentifier();\n        kernelStartTime = new Date().getTime();\n    }","id":34666,"modified_method":"Kernel( int instanceId, String kernelVersion, NeoStoreXaDataSource datasource )\n    {\n        super( instanceId );\n        this.kernelVersion = kernelVersion;\n        storeCreationDate = datasource.getCreationTime();\n        storeLogVersion = datasource.getCurrentLogVersion();\n        isReadOnly = datasource.isReadOnly();\n        storeId = datasource.getRandomIdentifier();\n\n        @SuppressWarnings( \"hiding\" )\n        String storeDir;\n        try\n        {\n            storeDir = new File( datasource.getStoreDir() ).getCanonicalFile().getAbsolutePath();\n        }\n        catch ( IOException e )\n        {\n            storeDir = new File( datasource.getStoreDir() ).getAbsolutePath();\n        }\n        this.storeDir = storeDir;\n\n        kernelStartTime = new Date().getTime();\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createDynamicConfigurationMBean( Map<Object, Object> params )\n        {\n            register( mbs, new Configuration( instanceId, params ) );\n        }","id":34667,"modified_method":"public void createDynamicConfigurationMBean( Map<Object, Object> params )\n        {\n            if ( !register( new Configuration( instanceId, params ) ) )\n                failedToRegister( \"ConfigurationMBean\" );\n        }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void initJMX( Neo4jJmx.Creator creator )\n    {\n        Factory jmx = new Factory( getPlatformMBeanServer(), creator.id );\n        creator.create( jmx );\n        jmx.createKernelMBean( creator.kernelVersion, creator.datasource );\n    }","id":34668,"modified_method":"public static Runnable initJMX( Neo4jJmx.Creator creator )\n    {\n        Factory jmx = new Factory( getPlatformMBeanServer(), creator.id );\n        creator.create( jmx );\n        jmx.createKernelMBean( creator.kernelVersion, creator.datasource );\n        return new JmxShutdown( jmx.beans );\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Creator( int instanceId, String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            this.id = instanceId;\n            this.kernelVersion = kernelVersion;\n            this.datasource = datasource;\n        }","id":34669,"modified_method":"protected Creator( int instanceId, String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            if ( kernelVersion == null || datasource == null )\n            {\n                throw new IllegalArgumentException( \"null valued argument\" );\n            }\n            this.id = instanceId;\n            this.kernelVersion = kernelVersion;\n            this.datasource = datasource;\n        }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createCacheMBean( NodeManager nodeManager )\n        {\n            register( mbs, new Cache( instanceId, nodeManager ) );\n        }","id":34670,"modified_method":"public void createCacheMBean( NodeManager nodeManager )\n        {\n            if ( !register( new Cache( instanceId, nodeManager ) ) )\n                failedToRegister( \"CacheMBean\" );\n        }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createKernelMBean( String kernelVersion, NeoStoreXaDataSource datasource )\n        {\n            register( mbs, new Kernel( instanceId, kernelVersion, datasource ) );\n        }","id":34671,"modified_method":"private void createKernelMBean( String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            if ( !register( new Kernel( instanceId, kernelVersion, datasource ) ) )\n                failedToRegister( \"KernelMBean\" );\n        }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void register( MBeanServer mbs, Neo4jJmx monitor )\n    {\n        try\n        {\n            mbs.registerMBean( monitor, monitor.objectName );\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":34672,"modified_method":"private static Neo4jJmx registerBean( MBeanServer mbs, Neo4jJmx bean )\n    {\n        try\n        {\n            mbs.registerMBean( bean, bean.objectName );\n            return bean;\n        }\n        catch ( Exception e )\n        {\n            return null;\n        }\n    }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createPrimitiveMBean( NodeManager nodeManager )\n        {\n            register( mbs, new Primitive( instanceId, nodeManager ) );\n        }","id":34673,"modified_method":"public void createPrimitiveMBean( NodeManager nodeManager )\n        {\n            if ( !register( new Primitive( instanceId, nodeManager ) ) )\n                failedToRegister( \"KernelMBean\" );\n        }","commit_id":"ea18404639acc8edfb2eb1ddf999e3da9b00e779","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * A non-standard way of creating an embedded {@link GraphDatabaseService}\n     * with a set of configuration parameters. Will most likely be removed in\n     * future releases.\n     * \n     * @param storeDir the store directory for the db files\n     * @param config configuration parameters\n     */\n    public EmbeddedGraphDbImpl( String storeDir, Map<String, String> config,\n        GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                config, kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        initJMX( params );\n    }","id":34674,"modified_method":"/**\n     * A non-standard way of creating an embedded {@link GraphDatabaseService}\n     * with a set of configuration parameters. Will most likely be removed in\n     * future releases.\n     *\n     * @param storeDir the store directory for the db files\n     * @param config configuration parameters\n     */\n    public EmbeddedGraphDbImpl( String storeDir, Map<String, String> config,\n        GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                config, kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        jmxShutdownHook = initJMX( params );\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void initJMX( final Map<Object, Object> params )\n    {\n        Neo4jJmx.initJMX( new Neo4jJmx.Creator(\n                instanceId, KERNEL_VERSION,\n                (NeoStoreXaDataSource) graphDbInstance.getConfig().getTxModule()\n                .getXaDataSourceManager().getXaDataSource( \"nioneodb\" ) )\n        {\n            @Override\n            protected void create( Neo4jJmx.Factory jmx )\n            {\n                jmx.createPrimitiveMBean( nodeManager );\n                jmx.createCacheMBean( nodeManager );\n                jmx.createDynamicConfigurationMBean( params );\n            }\n        } );\n    }","id":34675,"modified_method":"private Runnable initJMX( final Map<Object, Object> params )\n    {\n        return Neo4jJmx.initJMX( new Neo4jJmx.Creator(\n                instanceId, KERNEL_VERSION,\n                (NeoStoreXaDataSource) graphDbInstance.getConfig().getTxModule()\n                .getXaDataSourceManager().getXaDataSource( \"nioneodb\" ) )\n        {\n            @Override\n            protected void create( Neo4jJmx.Factory jmx )\n            {\n                jmx.createDynamicConfigurationMBean( params );\n                jmx.createPrimitiveMBean( nodeManager );\n                jmx.createCacheMBean( nodeManager );\n                // jmx.createLockManagerMBean();\n                jmx.createTransactionManagerMBean( getConfig().getTxModule() );\n                jmx.createMemoryMappingMBean( getConfig().getTxModule() );\n                // jmx.createXaManagerMBean();\n            }\n        } );\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        if ( graphDbInstance.started() )\n        {\n            sendShutdownEvent();\n        }\n\n        if ( this.shellService != null )\n        {\n            try\n            {\n                this.shellService.shutdown();\n                this.shellService = null;\n            }\n            catch ( Throwable t )\n            {\n                log.warning( \"Error shutting down shell server: \" + t );\n            }\n        }\n        graphDbInstance.shutdown();\n    }","id":34676,"modified_method":"public void shutdown()\n    {\n        if ( graphDbInstance.started() )\n        {\n            sendShutdownEvent();\n        }\n\n        jmxShutdownHook.run();\n\n        if ( this.shellService != null )\n        {\n            try\n            {\n                this.shellService.shutdown();\n                this.shellService = null;\n            }\n            catch ( Throwable t )\n            {\n                log.warning( \"Error shutting down shell server: \" + t );\n            }\n        }\n        graphDbInstance.shutdown();\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates an embedded {@link GraphDatabaseService} with a store located in\n     * <code>storeDir<\/code>, which will be created if it doesn't already exist.\n     *\n     * @param storeDir the store directory for the Neo4j db files\n     */\n    public EmbeddedGraphDbImpl( String storeDir, GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        initJMX( params );\n    }","id":34677,"modified_method":"/**\n     * Creates an embedded {@link GraphDatabaseService} with a store located in\n     * <code>storeDir<\/code>, which will be created if it doesn't already exist.\n     *\n     * @param storeDir the store directory for the Neo4j db files\n     */\n    public EmbeddedGraphDbImpl( String storeDir, GraphDatabaseService graphDbService )\n    {\n        this.storeDir = storeDir;\n        graphDbInstance = new GraphDbInstance( storeDir, true );\n        Map<Object, Object> params = graphDbInstance.start( graphDbService,\n                kernelPanicEventGenerator );\n        nodeManager =\n            graphDbInstance.getConfig().getGraphDbModule().getNodeManager();\n        this.graphDbService = graphDbService;\n        jmxShutdownHook = initJMX( params );\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getStoreId()\n    {\n        return storeId;\n    }","id":34678,"modified_method":"public String getStoreId()\n    {\n        return Long.toHexString( storeId );\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"Kernel( int instanceId, String kernelVersion, NeoStoreXaDataSource datasource )\n    {\n        super( instanceId );\n        this.kernelVersion = kernelVersion;\n        storeCreationDate = datasource.getCreationTime();\n        storeLogVersion = datasource.getCurrentLogVersion();\n        isReadOnly = datasource.isReadOnly();\n        storeDir = datasource.getStoreDir();\n        storeId = datasource.getRandomIdentifier();\n        kernelStartTime = new Date().getTime();\n    }","id":34679,"modified_method":"Kernel( int instanceId, String kernelVersion, NeoStoreXaDataSource datasource )\n    {\n        super( instanceId );\n        this.kernelVersion = kernelVersion;\n        storeCreationDate = datasource.getCreationTime();\n        storeLogVersion = datasource.getCurrentLogVersion();\n        isReadOnly = datasource.isReadOnly();\n        storeId = datasource.getRandomIdentifier();\n\n        @SuppressWarnings( \"hiding\" )\n        String storeDir;\n        try\n        {\n            storeDir = new File( datasource.getStoreDir() ).getCanonicalFile().getAbsolutePath();\n        }\n        catch ( IOException e )\n        {\n            storeDir = new File( datasource.getStoreDir() ).getAbsolutePath();\n        }\n        this.storeDir = storeDir;\n\n        kernelStartTime = new Date().getTime();\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createKernelMBean( String kernelVersion, NeoStoreXaDataSource datasource )\n        {\n            register( mbs, new Kernel( instanceId, kernelVersion, datasource ) );\n        }","id":34680,"modified_method":"private void createKernelMBean( String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            if ( !register( new Kernel( instanceId, kernelVersion, datasource ) ) )\n                failedToRegister( \"KernelMBean\" );\n        }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createDynamicConfigurationMBean( Map<Object, Object> params )\n        {\n            register( mbs, new Configuration( instanceId, params ) );\n        }","id":34681,"modified_method":"public void createDynamicConfigurationMBean( Map<Object, Object> params )\n        {\n            if ( !register( new Configuration( instanceId, params ) ) )\n                failedToRegister( \"ConfigurationMBean\" );\n        }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void register( MBeanServer mbs, Neo4jJmx monitor )\n    {\n        try\n        {\n            mbs.registerMBean( monitor, monitor.objectName );\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":34682,"modified_method":"private static Neo4jJmx registerBean( MBeanServer mbs, Neo4jJmx bean )\n    {\n        try\n        {\n            mbs.registerMBean( bean, bean.objectName );\n            return bean;\n        }\n        catch ( Exception e )\n        {\n            return null;\n        }\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createPrimitiveMBean( NodeManager nodeManager )\n        {\n            register( mbs, new Primitive( instanceId, nodeManager ) );\n        }","id":34683,"modified_method":"public void createPrimitiveMBean( NodeManager nodeManager )\n        {\n            if ( !register( new Primitive( instanceId, nodeManager ) ) )\n                failedToRegister( \"KernelMBean\" );\n        }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void createCacheMBean( NodeManager nodeManager )\n        {\n            register( mbs, new Cache( instanceId, nodeManager ) );\n        }","id":34684,"modified_method":"public void createCacheMBean( NodeManager nodeManager )\n        {\n            if ( !register( new Cache( instanceId, nodeManager ) ) )\n                failedToRegister( \"CacheMBean\" );\n        }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void initJMX( Neo4jJmx.Creator creator )\n    {\n        Factory jmx = new Factory( getPlatformMBeanServer(), creator.id );\n        creator.create( jmx );\n        jmx.createKernelMBean( creator.kernelVersion, creator.datasource );\n    }","id":34685,"modified_method":"public static Runnable initJMX( Neo4jJmx.Creator creator )\n    {\n        Factory jmx = new Factory( getPlatformMBeanServer(), creator.id );\n        creator.create( jmx );\n        jmx.createKernelMBean( creator.kernelVersion, creator.datasource );\n        return new JmxShutdown( jmx.beans );\n    }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Creator( int instanceId, String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            this.id = instanceId;\n            this.kernelVersion = kernelVersion;\n            this.datasource = datasource;\n        }","id":34686,"modified_method":"protected Creator( int instanceId, String kernelVersion,\n                NeoStoreXaDataSource datasource )\n        {\n            if ( kernelVersion == null || datasource == null )\n            {\n                throw new IllegalArgumentException( \"null valued argument\" );\n            }\n            this.id = instanceId;\n            this.kernelVersion = kernelVersion;\n            this.datasource = datasource;\n        }","commit_id":"2b1a290faa31270908dd6e8d30bb82e5a412323b","url":"https://github.com/neo4j/neo4j"},{"original_method":"String[] computeHighlightingPerLine(DefaultInputFile file, @Nullable SyntaxHighlightingData highlighting) {\n    String[] highlightingPerLine = new String[file.lines()];\n    if (highlighting == null) {\n      return highlightingPerLine;\n    }\n    Iterable<SyntaxHighlightingRule> rules = highlighting.syntaxHighlightingRuleSet();\n    int currentLineIdx = 1;\n    StringBuilder currentLineSb = new StringBuilder();\n    for (SyntaxHighlightingRule rule : rules) {\n      long ruleStartOffset = rule.getStartPosition();\n      long ruleEndOffset = rule.getEndPosition();\n      while (currentLineIdx < file.lines() && ruleStartOffset >= file.originalLineOffsets()[currentLineIdx]) {\n        // This rule starts on another line so advance\n        saveLineHighlighting(highlightingPerLine, currentLineIdx, currentLineSb);\n        currentLineIdx++;\n      }\n      // Now we know current rule starts on current line\n      long ruleStartOffsetCurrentLine = ruleStartOffset;\n      while (currentLineIdx < file.lines() && ruleEndOffset >= file.originalLineOffsets()[currentLineIdx]) {\n        // rule continue on next line so write current line and continue on next line with same rule\n        writeRule(currentLineSb, ruleStartOffsetCurrentLine - file.originalLineOffsets()[currentLineIdx - 1], file.originalLineOffsets()[currentLineIdx] - 1, rule.getTextType());\n        saveLineHighlighting(highlightingPerLine, currentLineIdx, currentLineSb);\n        currentLineIdx++;\n        ruleStartOffsetCurrentLine = file.originalLineOffsets()[currentLineIdx];\n      }\n      // Rule ends on current line\n      writeRule(currentLineSb, ruleStartOffsetCurrentLine - file.originalLineOffsets()[currentLineIdx - 1], ruleEndOffset - file.originalLineOffsets()[currentLineIdx - 1],\n        rule.getTextType());\n    }\n    saveLineHighlighting(highlightingPerLine, currentLineIdx, currentLineSb);\n    return highlightingPerLine;\n  }","id":34687,"modified_method":"String[] computeHighlightingPerLine(DefaultInputFile file, @Nullable SyntaxHighlightingData highlighting) {\n    String[] result = new String[file.lines()];\n    if (highlighting == null) {\n      return result;\n    }\n    Iterable<SyntaxHighlightingRule> rules = highlighting.syntaxHighlightingRuleSet();\n    int currentLineIdx = 1;\n    StringBuilder[] highlightingPerLine = new StringBuilder[file.lines()];\n    for (SyntaxHighlightingRule rule : rules) {\n      while (currentLineIdx < file.lines() && rule.getStartPosition() >= file.originalLineOffsets()[currentLineIdx]) {\n        // This rule starts on another line so advance\n        currentLineIdx++;\n      }\n      // Now we know current rule starts on current line\n      writeRule(file, rule, highlightingPerLine, currentLineIdx);\n    }\n    for (int i = 0; i < file.lines(); i++) {\n      result[i] = highlightingPerLine[i] != null ? highlightingPerLine[i].toString() : null;\n    }\n    return result;\n  }","commit_id":"d10e163a67923e10247aa242b7463122e7e5b92c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void persist() {\n    DbSession session = mybatis.openSession(false);\n    try {\n      FileSourceMapper mapper = session.getMapper(FileSourceMapper.class);\n\n      for (InputPath inputPath : inputPathCache.all()) {\n        if (inputPath instanceof InputFile) {\n          DefaultInputFile inputFile = (DefaultInputFile) inputPath;\n          org.sonar.api.resources.File file = (org.sonar.api.resources.File) resourceCache.get(inputFile.key());\n          String fileUuid = file.getUuid();\n          FileSourceDto previous = mapper.select(fileUuid);\n          String newData = getSourceData(inputFile);\n          String dataHash = newData != null ? DigestUtils.md5Hex(newData) : \"0\";\n          Date now = system2.newDate();\n          if (previous == null) {\n            FileSourceDto newFileSource = new FileSourceDto().setProjectUuid(projectTree.getRootProject().getUuid()).setFileUuid(fileUuid).setData(newData).setDataHash(dataHash)\n              .setCreatedAt(now)\n              .setUpdatedAt(now);\n            mapper.insert(newFileSource);\n          } else {\n            if (dataHash.equals(previous.getDataHash())) {\n              continue;\n            } else {\n              previous.setData(newData).setDataHash(dataHash).setUpdatedAt(now);\n              mapper.update(previous);\n            }\n          }\n        }\n        session.commit();\n      }\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Unable to save file sources\", e);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n\n  }","id":34688,"modified_method":"@Override\n  public void persist() {\n    DbSession session = mybatis.openSession(false);\n    try {\n      FileSourceMapper mapper = session.getMapper(FileSourceMapper.class);\n\n      for (InputPath inputPath : inputPathCache.all()) {\n        if (inputPath instanceof InputFile) {\n          persist(session, mapper, inputPath);\n        }\n      }\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Unable to save file sources\", e);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n\n  }","commit_id":"d10e163a67923e10247aa242b7463122e7e5b92c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testPersistNewFileWithScmAndHighlighting() throws Exception {\n    setupData(\"file_sources\");\n    when(system2.newDate()).thenReturn(DateUtils.parseDateTime(\"2014-10-29T16:44:02+0100\"));\n\n    String relativePathNew = \"src/new.java\";\n    java.io.File newFile = new java.io.File(basedir, relativePathNew);\n    FileUtils.write(newFile, \"foo\\nbar\\nbiz\");\n    DefaultInputFile inputFileNew = new DefaultInputFile(PROJECT_KEY, relativePathNew)\n      .setLines(3)\n      .setAbsolutePath(newFile.getAbsolutePath())\n      .setOriginalLineOffsets(new long[] {0, 4, 7});\n    when(inputPathCache.all()).thenReturn(Arrays.<InputPath>asList(inputFileNew));\n\n    mockResourceCache(relativePathNew, PROJECT_KEY, \"uuidnew\");\n\n    when(measureCache.byMetric(PROJECT_KEY + \":\" + relativePathNew, CoreMetrics.SCM_AUTHORS_BY_LINE_KEY))\n      .thenReturn(Arrays.asList(new Measure(CoreMetrics.SCM_AUTHORS_BY_LINE, \"1=julien;2=simon;3=julien\")));\n    when(measureCache.byMetric(PROJECT_KEY + \":\" + relativePathNew, CoreMetrics.SCM_LAST_COMMIT_DATETIMES_BY_LINE_KEY))\n      .thenReturn(Arrays.asList(new Measure(CoreMetrics.SCM_LAST_COMMIT_DATETIMES_BY_LINE, \"1=2014-10-11T16:44:02+0100;2=2014-10-12T16:44:02+0100;3=2014-10-13T16:44:02+0100\")));\n    when(measureCache.byMetric(PROJECT_KEY + \":\" + relativePathNew, CoreMetrics.SCM_REVISIONS_BY_LINE_KEY))\n      .thenReturn(Arrays.asList(new Measure(CoreMetrics.SCM_REVISIONS_BY_LINE, \"1=123;2=234;3=345\")));\n\n    SyntaxHighlightingData highlighting = new SyntaxHighlightingData(Arrays.asList(\n      SyntaxHighlightingRule.create(0, 3, TypeOfText.ANNOTATION),\n      SyntaxHighlightingRule.create(4, 5, TypeOfText.COMMENT),\n      SyntaxHighlightingRule.create(7, 16, TypeOfText.CONSTANT)\n      ));\n    when(componentDataCache.getData(PROJECT_KEY + \":\" + relativePathNew, SnapshotDataTypes.SYNTAX_HIGHLIGHTING))\n      .thenReturn(highlighting);\n\n    sourcePersister.persist();\n    checkTables(\"testPersistNewFileWithScmAndHighlighting\", \"file_sources\");\n  }","id":34689,"modified_method":"@Test\n  public void testPersistNewFileWithScmAndHighlighting() throws Exception {\n    setupData(\"file_sources\");\n    when(system2.newDate()).thenReturn(DateUtils.parseDateTime(\"2014-10-29T16:44:02+0100\"));\n\n    String relativePathNew = \"src/new.java\";\n    java.io.File newFile = new java.io.File(basedir, relativePathNew);\n    FileUtils.write(newFile, \"foo\\nbar\\nbiz\");\n    DefaultInputFile inputFileNew = new DefaultInputFile(PROJECT_KEY, relativePathNew)\n      .setLines(3)\n      .setAbsolutePath(newFile.getAbsolutePath())\n      .setOriginalLineOffsets(new long[] {0, 4, 7});\n    when(inputPathCache.all()).thenReturn(Arrays.<InputPath>asList(inputFileNew));\n\n    mockResourceCache(relativePathNew, PROJECT_KEY, \"uuidnew\");\n\n    when(measureCache.byMetric(PROJECT_KEY + \":\" + relativePathNew, CoreMetrics.SCM_AUTHORS_BY_LINE_KEY))\n      .thenReturn(Arrays.asList(new Measure(CoreMetrics.SCM_AUTHORS_BY_LINE, \"1=julien;2=simon;3=julien\")));\n    when(measureCache.byMetric(PROJECT_KEY + \":\" + relativePathNew, CoreMetrics.SCM_LAST_COMMIT_DATETIMES_BY_LINE_KEY))\n      .thenReturn(Arrays.asList(new Measure(CoreMetrics.SCM_LAST_COMMIT_DATETIMES_BY_LINE, \"1=2014-10-11T16:44:02+0100;2=2014-10-12T16:44:02+0100;3=2014-10-13T16:44:02+0100\")));\n    when(measureCache.byMetric(PROJECT_KEY + \":\" + relativePathNew, CoreMetrics.SCM_REVISIONS_BY_LINE_KEY))\n      .thenReturn(Arrays.asList(new Measure(CoreMetrics.SCM_REVISIONS_BY_LINE, \"1=123;2=234;3=345\")));\n\n    SyntaxHighlightingData highlighting = new SyntaxHighlightingDataBuilder()\n      .registerHighlightingRule(0, 3, TypeOfText.ANNOTATION)\n      .registerHighlightingRule(4, 5, TypeOfText.COMMENT)\n      .registerHighlightingRule(7, 16, TypeOfText.CONSTANT)\n      .build();\n    when(componentDataCache.getData(PROJECT_KEY + \":\" + relativePathNew, SnapshotDataTypes.SYNTAX_HIGHLIGHTING))\n      .thenReturn(highlighting);\n\n    sourcePersister.persist();\n    checkTables(\"testPersistNewFileWithScmAndHighlighting\", \"file_sources\");\n  }","commit_id":"d10e163a67923e10247aa242b7463122e7e5b92c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SyntaxHighlightingDataBuilder() {\n    syntaxHighlightingRuleSet = Sets.newTreeSet(new Ordering<SyntaxHighlightingRule>() {\n      @Override\n      public int compare(@Nullable SyntaxHighlightingRule left,\n                         @Nullable SyntaxHighlightingRule right) {\n        int result = left.getStartPosition() - right.getStartPosition();\n        if (result == 0) {\n          result = left.getEndPosition() - right.getEndPosition();\n        }\n        return result;\n      }\n    });\n  }","id":34690,"modified_method":"public SyntaxHighlightingDataBuilder() {\n    syntaxHighlightingRuleSet = Sets.newTreeSet(new Ordering<SyntaxHighlightingRule>() {\n      @Override\n      public int compare(@Nullable SyntaxHighlightingRule left,\n        @Nullable SyntaxHighlightingRule right) {\n        int result = left.getStartPosition() - right.getStartPosition();\n        if (result == 0) {\n          result = right.getEndPosition() - left.getEndPosition();\n        }\n        return result;\n      }\n    });\n  }","commit_id":"d10e163a67923e10247aa242b7463122e7e5b92c","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@NotNull\n  @TestOnly\n  List<HighlightInfo> runPasses(@NotNull PsiFile file,\n                                @NotNull Document document,\n                                @NotNull List<TextEditor> textEditors,\n                                @NotNull int[] toIgnore,\n                                boolean canChangeDocument,\n                                @Nullable final Runnable callbackWhileWaiting) throws ProcessCanceledException {\n    assert myInitialized;\n    assert !myDisposed;\n    ApplicationEx application = ApplicationManagerEx.getApplicationEx();\n    application.assertIsDispatchThread();\n    if (application.isWriteAccessAllowed()) {\n      throw new AssertionError(\"Must not start highlighting from within write action, or deadlock is imminent\");\n    }\n    DaemonProgressIndicator.setDebug(true);\n    ((FileTypeManagerImpl)FileTypeManager.getInstance()).drainReDetectQueue();\n    // pump first so that queued event do not interfere\n    UIUtil.dispatchAllInvocationEvents();\n\n    // refresh will fire write actions interfering with highlighting\n    while (RefreshQueueImpl.isRefreshInProgress() || HeavyProcessLatch.INSTANCE.isRunning()) {\n      UIUtil.dispatchAllInvocationEvents();\n    }\n\n    UIUtil.dispatchAllInvocationEvents();\n\n    Project project = file.getProject();\n    FileStatusMap.getAndClearLog();\n    FileStatusMap fileStatusMap = getFileStatusMap();\n    fileStatusMap.allowDirt(canChangeDocument);\n\n    Map<FileEditor, HighlightingPass[]> map = new HashMap<FileEditor, HighlightingPass[]>();\n    for (TextEditor textEditor : textEditors) {\n      TextEditorBackgroundHighlighter highlighter = (TextEditorBackgroundHighlighter)textEditor.getBackgroundHighlighter();\n      final List<TextEditorHighlightingPass> passes = highlighter.getPasses(toIgnore);\n      HighlightingPass[] array = passes.toArray(new HighlightingPass[passes.size()]);\n      assert array.length != 0 : \"Highlighting is disabled for the file \" + file;\n      map.put(textEditor, array);\n    }\n    for (int ignoreId : toIgnore) {\n      fileStatusMap.markFileUpToDate(document, ignoreId);\n    }\n\n    myAlarm.cancelAllRequests();\n    final DaemonProgressIndicator progress = createUpdateProgress();\n    myPassExecutorService.submitPasses(map, progress);\n    try {\n      long start = System.currentTimeMillis();\n      while (progress.isRunning() && System.currentTimeMillis() < start + 5*60*1000) {\n        wrap(new ThrowableRunnable() {\n          @Override\n          public void run() throws Throwable {\n            progress.checkCanceled();\n            if (callbackWhileWaiting != null) {\n              callbackWhileWaiting.run();\n            }\n            myPassExecutorService.waitFor(50);\n            UIUtil.dispatchAllInvocationEvents();\n            Throwable savedException = PassExecutorService.getSavedException(progress);\n            if (savedException != null) throw savedException;\n          }\n        });\n      }\n      if (progress.isRunning()) {\n        throw new RuntimeException(\"Highlighting still running after \"+(System.currentTimeMillis()-start)/1000+\" seconds.\\n\"+ ThreadDumper.dumpThreadsToString());\n      }\n\n      final HighlightingSessionImpl session =\n        (HighlightingSessionImpl)HighlightingSessionImpl.getOrCreateHighlightingSession(file, textEditors.get(0).getEditor(), progress, null);\n      wrap(new ThrowableRunnable() {\n        @Override\n        public void run() throws Throwable {\n          if (!myPassExecutorService.waitFor(60000)) {\n            throw new TimeoutException(\"Unable to complete in 60s\");\n          }\n          session.waitForHighlightInfosApplied();\n        }\n      });\n      UIUtil.dispatchAllInvocationEvents();\n      UIUtil.dispatchAllInvocationEvents();\n      assert progress.isCanceled() && progress.isDisposed();\n\n      return getHighlights(document, null, project);\n    }\n    finally {\n      DaemonProgressIndicator.setDebug(false);\n      String log = FileStatusMap.getAndClearLog();\n      fileStatusMap.allowDirt(true);\n      try {\n        waitForTermination();\n      }\n      catch (Throwable e) {\n        LOG.error(log, e);\n      }\n    }\n  }","id":34691,"modified_method":"@NotNull\n  @TestOnly\n  List<HighlightInfo> runPasses(@NotNull PsiFile file,\n                                @NotNull Document document,\n                                @NotNull List<TextEditor> textEditors,\n                                @NotNull int[] toIgnore,\n                                boolean canChangeDocument,\n                                @Nullable final Runnable callbackWhileWaiting) throws ProcessCanceledException {\n    assert myInitialized;\n    assert !myDisposed;\n    ApplicationEx application = ApplicationManagerEx.getApplicationEx();\n    application.assertIsDispatchThread();\n    if (application.isWriteAccessAllowed()) {\n      throw new AssertionError(\"Must not start highlighting from within write action, or deadlock is imminent\");\n    }\n    DaemonProgressIndicator.setDebug(true);\n    ((FileTypeManagerImpl)FileTypeManager.getInstance()).drainReDetectQueue();\n    // pump first so that queued event do not interfere\n    UIUtil.dispatchAllInvocationEvents();\n\n    // refresh will fire write actions interfering with highlighting\n    while (RefreshQueueImpl.isRefreshInProgress() || HeavyProcessLatch.INSTANCE.isRunning()) {\n      UIUtil.dispatchAllInvocationEvents();\n    }\n\n    UIUtil.dispatchAllInvocationEvents();\n\n    Project project = file.getProject();\n    FileStatusMap.getAndClearLog();\n    FileStatusMap fileStatusMap = getFileStatusMap();\n    fileStatusMap.allowDirt(canChangeDocument);\n\n    Map<FileEditor, HighlightingPass[]> map = new HashMap<FileEditor, HighlightingPass[]>();\n    for (TextEditor textEditor : textEditors) {\n      TextEditorBackgroundHighlighter highlighter = (TextEditorBackgroundHighlighter)textEditor.getBackgroundHighlighter();\n      final List<TextEditorHighlightingPass> passes = highlighter.getPasses(toIgnore);\n      HighlightingPass[] array = passes.toArray(new HighlightingPass[passes.size()]);\n      assert array.length != 0 : \"Highlighting is disabled for the file \" + file;\n      map.put(textEditor, array);\n    }\n    for (int ignoreId : toIgnore) {\n      fileStatusMap.markFileUpToDate(document, ignoreId);\n    }\n\n    myAlarm.cancelAllRequests();\n    final DaemonProgressIndicator progress = createUpdateProgress();\n    myPassExecutorService.submitPasses(map, progress);\n    try {\n      long start = System.currentTimeMillis();\n      while (progress.isRunning() && System.currentTimeMillis() < start + 5*60*1000) {\n        wrap(new ThrowableRunnable() {\n          @Override\n          public void run() throws Throwable {\n            progress.checkCanceled();\n            if (callbackWhileWaiting != null) {\n              callbackWhileWaiting.run();\n            }\n            myPassExecutorService.waitFor(50);\n            UIUtil.dispatchAllInvocationEvents();\n            Throwable savedException = PassExecutorService.getSavedException(progress);\n            if (savedException != null) throw savedException;\n          }\n        });\n      }\n      if (progress.isRunning() && !progress.isCanceled()) {\n        throw new RuntimeException(\"Highlighting still running after \"+(System.currentTimeMillis()-start)/1000+\" seconds.\\n\"+ ThreadDumper.dumpThreadsToString());\n      }\n\n      final HighlightingSessionImpl session =\n        (HighlightingSessionImpl)HighlightingSessionImpl.getOrCreateHighlightingSession(file, textEditors.get(0).getEditor(), progress, null);\n      wrap(new ThrowableRunnable() {\n        @Override\n        public void run() throws Throwable {\n          if (!myPassExecutorService.waitFor(60000)) {\n            throw new TimeoutException(\"Unable to complete in 60s\");\n          }\n          session.waitForHighlightInfosApplied();\n        }\n      });\n      UIUtil.dispatchAllInvocationEvents();\n      UIUtil.dispatchAllInvocationEvents();\n      assert progress.isCanceled() && progress.isDisposed();\n\n      return getHighlights(document, null, project);\n    }\n    finally {\n      DaemonProgressIndicator.setDebug(false);\n      String log = FileStatusMap.getAndClearLog();\n      fileStatusMap.allowDirt(true);\n      try {\n        waitForTermination();\n      }\n      catch (Throwable e) {\n        LOG.error(log, e);\n      }\n    }\n  }","commit_id":"669cb8444c5e711b1711ab776543757df8f7583a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @TestOnly\n  List<HighlightInfo> runPasses(@NotNull PsiFile file,\n                                @NotNull Document document,\n                                @NotNull List<TextEditor> textEditors,\n                                @NotNull int[] toIgnore,\n                                boolean canChangeDocument,\n                                @Nullable final Runnable callbackWhileWaiting) throws ProcessCanceledException {\n    assert myInitialized;\n    assert !myDisposed;\n    ApplicationEx application = ApplicationManagerEx.getApplicationEx();\n    application.assertIsDispatchThread();\n    if (application.isWriteAccessAllowed()) {\n      throw new AssertionError(\"Must not start highlighting from within write action, or deadlock is imminent\");\n    }\n    DaemonProgressIndicator.setDebug(true);\n    ((FileTypeManagerImpl)FileTypeManager.getInstance()).drainReDetectQueue();\n    // pump first so that queued event do not interfere\n    UIUtil.dispatchAllInvocationEvents();\n\n    // refresh will fire write actions interfering with highlighting\n    while (RefreshQueueImpl.isRefreshInProgress() || HeavyProcessLatch.INSTANCE.isRunning()) {\n      UIUtil.dispatchAllInvocationEvents();\n    }\n\n    UIUtil.dispatchAllInvocationEvents();\n\n    Project project = file.getProject();\n    FileStatusMap.getAndClearLog();\n    FileStatusMap fileStatusMap = getFileStatusMap();\n    fileStatusMap.allowDirt(canChangeDocument);\n\n    Map<FileEditor, HighlightingPass[]> map = new HashMap<FileEditor, HighlightingPass[]>();\n    for (TextEditor textEditor : textEditors) {\n      TextEditorBackgroundHighlighter highlighter = (TextEditorBackgroundHighlighter)textEditor.getBackgroundHighlighter();\n      final List<TextEditorHighlightingPass> passes = highlighter.getPasses(toIgnore);\n      HighlightingPass[] array = passes.toArray(new HighlightingPass[passes.size()]);\n      assert array.length != 0 : \"Highlighting is disabled for the file \" + file;\n      map.put(textEditor, array);\n    }\n    for (int ignoreId : toIgnore) {\n      fileStatusMap.markFileUpToDate(document, ignoreId);\n    }\n\n    myAlarm.cancelAllRequests();\n    final DaemonProgressIndicator progress = createUpdateProgress();\n    myPassExecutorService.submitPasses(map, progress);\n    try {\n      while (progress.isRunning()) {\n        wrap(new ThrowableRunnable() {\n          @Override\n          public void run() throws Throwable {\n            progress.checkCanceled();\n            if (callbackWhileWaiting != null) {\n              callbackWhileWaiting.run();\n            }\n            myPassExecutorService.waitFor(50);\n            UIUtil.dispatchAllInvocationEvents();\n            Throwable savedException = PassExecutorService.getSavedException(progress);\n            if (savedException != null) throw savedException;\n          }\n        });\n      }\n\n      final HighlightingSessionImpl session =\n        (HighlightingSessionImpl)HighlightingSessionImpl.getOrCreateHighlightingSession(file, textEditors.get(0).getEditor(), progress, null);\n      wrap(new ThrowableRunnable() {\n        @Override\n        public void run() throws Throwable {\n          if (!myPassExecutorService.waitFor(60000)) {\n            throw new TimeoutException(\"Unable to complete in 60s\");\n          }\n          session.waitForHighlightInfosApplied();\n        }\n      });\n      UIUtil.dispatchAllInvocationEvents();\n      UIUtil.dispatchAllInvocationEvents();\n      assert progress.isCanceled() && progress.isDisposed();\n\n      return getHighlights(document, null, project);\n    }\n    finally {\n      DaemonProgressIndicator.setDebug(false);\n      String log = FileStatusMap.getAndClearLog();\n      fileStatusMap.allowDirt(true);\n      try {\n        waitForTermination();\n      }\n      catch (Throwable e) {\n        LOG.error(log, e);\n      }\n    }\n  }","id":34692,"modified_method":"@NotNull\n  @TestOnly\n  List<HighlightInfo> runPasses(@NotNull PsiFile file,\n                                @NotNull Document document,\n                                @NotNull List<TextEditor> textEditors,\n                                @NotNull int[] toIgnore,\n                                boolean canChangeDocument,\n                                @Nullable final Runnable callbackWhileWaiting) throws ProcessCanceledException {\n    assert myInitialized;\n    assert !myDisposed;\n    ApplicationEx application = ApplicationManagerEx.getApplicationEx();\n    application.assertIsDispatchThread();\n    if (application.isWriteAccessAllowed()) {\n      throw new AssertionError(\"Must not start highlighting from within write action, or deadlock is imminent\");\n    }\n    DaemonProgressIndicator.setDebug(true);\n    ((FileTypeManagerImpl)FileTypeManager.getInstance()).drainReDetectQueue();\n    // pump first so that queued event do not interfere\n    UIUtil.dispatchAllInvocationEvents();\n\n    // refresh will fire write actions interfering with highlighting\n    while (RefreshQueueImpl.isRefreshInProgress() || HeavyProcessLatch.INSTANCE.isRunning()) {\n      UIUtil.dispatchAllInvocationEvents();\n    }\n\n    UIUtil.dispatchAllInvocationEvents();\n\n    Project project = file.getProject();\n    FileStatusMap.getAndClearLog();\n    FileStatusMap fileStatusMap = getFileStatusMap();\n    fileStatusMap.allowDirt(canChangeDocument);\n\n    Map<FileEditor, HighlightingPass[]> map = new HashMap<FileEditor, HighlightingPass[]>();\n    for (TextEditor textEditor : textEditors) {\n      TextEditorBackgroundHighlighter highlighter = (TextEditorBackgroundHighlighter)textEditor.getBackgroundHighlighter();\n      final List<TextEditorHighlightingPass> passes = highlighter.getPasses(toIgnore);\n      HighlightingPass[] array = passes.toArray(new HighlightingPass[passes.size()]);\n      assert array.length != 0 : \"Highlighting is disabled for the file \" + file;\n      map.put(textEditor, array);\n    }\n    for (int ignoreId : toIgnore) {\n      fileStatusMap.markFileUpToDate(document, ignoreId);\n    }\n\n    myAlarm.cancelAllRequests();\n    final DaemonProgressIndicator progress = createUpdateProgress();\n    myPassExecutorService.submitPasses(map, progress);\n    try {\n      long start = System.currentTimeMillis();\n      while (progress.isRunning() && System.currentTimeMillis() < start + 5*60*1000) {\n        wrap(new ThrowableRunnable() {\n          @Override\n          public void run() throws Throwable {\n            progress.checkCanceled();\n            if (callbackWhileWaiting != null) {\n              callbackWhileWaiting.run();\n            }\n            myPassExecutorService.waitFor(50);\n            UIUtil.dispatchAllInvocationEvents();\n            Throwable savedException = PassExecutorService.getSavedException(progress);\n            if (savedException != null) throw savedException;\n          }\n        });\n      }\n      if (progress.isRunning()) {\n        throw new RuntimeException(\"Highlighting still running after \"+(System.currentTimeMillis()-start)/1000+\" seconds.\\n\"+ ThreadDumper.dumpThreadsToString());\n      }\n\n      final HighlightingSessionImpl session =\n        (HighlightingSessionImpl)HighlightingSessionImpl.getOrCreateHighlightingSession(file, textEditors.get(0).getEditor(), progress, null);\n      wrap(new ThrowableRunnable() {\n        @Override\n        public void run() throws Throwable {\n          if (!myPassExecutorService.waitFor(60000)) {\n            throw new TimeoutException(\"Unable to complete in 60s\");\n          }\n          session.waitForHighlightInfosApplied();\n        }\n      });\n      UIUtil.dispatchAllInvocationEvents();\n      UIUtil.dispatchAllInvocationEvents();\n      assert progress.isCanceled() && progress.isDisposed();\n\n      return getHighlights(document, null, project);\n    }\n    finally {\n      DaemonProgressIndicator.setDebug(false);\n      String log = FileStatusMap.getAndClearLog();\n      fileStatusMap.allowDirt(true);\n      try {\n        waitForTermination();\n      }\n      catch (Throwable e) {\n        LOG.error(log, e);\n      }\n    }\n  }","commit_id":"749aeb1138b0fd22a153ce0001bc6f88b4e45b03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initTestRunner() {\n    TestLightRunState runState = TransformationTestLightRunner.getRunState(Thread.currentThread().getId());\n    if (runState.isRunning()) {\n      setTestRunner(new TransformationTestLightRunner());\n    } else {\n      setTestRunner(new TransformationTestRunner());\n    }\n  }","id":34693,"modified_method":"private void initTestRunner() {\n    TestLightRunState runState = TransformationTestLightRunner.getRunState(Thread.currentThread().getId());\n    if (runState != null && runState.isRunning()) {\n      setTestRunner(new TransformationTestLightRunner());\n    } else {\n      setTestRunner(new TransformationTestRunner());\n    }\n  }","commit_id":"c3b25567cef78a6350663aeaa9409d852f098c5f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void start() {\n        live = true;\n    }","id":34694,"modified_method":"@Override\n    public void start() {\n        logger.fine(\"Starting connection manager\");\n        live = true;\n    }","commit_id":"c200d755f6f5d9de0f9ee5b51140822924f7054d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void stop() {\n        live = false;\n\n        for (Address address : nodes.keySet()) {\n            if (address.equals(node.getThisAddress())) {\n                continue;\n            }\n\n            final NodeEngineImpl nodeEngine = nodes.get(address);\n            if (nodeEngine != null && nodeEngine.getNode().getState() != NodeState.SHUT_DOWN) {\n                nodeEngine.getExecutionService().execute(ExecutionService.SYSTEM_EXECUTOR, new Runnable() {\n                    public void run() {\n                        ClusterServiceImpl clusterService = (ClusterServiceImpl) nodeEngine.getClusterService();\n                        clusterService.removeAddress(node.getThisAddress());\n                    }\n                });\n            }\n        }\n        for (MockConnection connection : mapConnections.values()) {\n            connection.close();\n        }\n    }","id":34695,"modified_method":"@Override\n    public void stop() {\n        logger.fine(\"Stopping connection manager\");\n        live = false;\n\n        for (Address address : nodes.keySet()) {\n            if (address.equals(node.getThisAddress())) {\n                continue;\n            }\n\n            final NodeEngineImpl otherNodeEngine = nodes.get(address);\n            if (otherNodeEngine != null && otherNodeEngine.getNode().getState() != NodeState.SHUT_DOWN) {\n                if (otherNodeEngine.getClusterService().getMember(node.getThisAddress()) == null) {\n                    continue;\n                }\n\n                logger.fine(otherNodeEngine.getThisAddress() + \" is instructed to remove this node.\");\n                otherNodeEngine.getExecutionService().execute(ExecutionService.SYSTEM_EXECUTOR, new Runnable() {\n                    public void run() {\n                        ClusterServiceImpl clusterService = (ClusterServiceImpl) otherNodeEngine.getClusterService();\n                        clusterService.removeAddress(node.getThisAddress());\n                    }\n                });\n            }\n        }\n        for (MockConnection connection : mapConnections.values()) {\n            connection.close();\n        }\n    }","commit_id":"c200d755f6f5d9de0f9ee5b51140822924f7054d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void lookupMasterAddress() {\n        NodeEngineImpl nodeEngine = findAliveNodeEngine();\n        if (nodeEngine == null) {\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        Address master;\n        if (nodeEngine.getNode().isMaster()) {\n            master = nodeEngine.getThisAddress();\n        } else {\n            master = nodeEngine.getMasterAddress();\n        }\n\n        if (master == null) {\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        NodeEngineImpl masterNodeEngine = nodes.get(master);\n        if (masterNodeEngine != null && masterNodeEngine.isRunning() && masterNodeEngine.getNode().joined()) {\n            masterAddress = master;\n        }\n    }","id":34696,"modified_method":"private void lookupMasterAddress() {\n        NodeEngineImpl nodeEngine = findAliveNodeEngine();\n        if (nodeEngine == null) {\n            logger.fine(\"Picking this node as master, no other running NodeEngine has been detected.\");\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        Address master;\n        if (nodeEngine.getNode().isMaster()) {\n            master = nodeEngine.getThisAddress();\n        } else {\n            master = nodeEngine.getMasterAddress();\n        }\n\n        if (master == null) {\n            logger.fine(\"Picking this node as master, found NodeEngine has no master information.\");\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        NodeEngineImpl masterNodeEngine = nodes.get(master);\n        if (masterNodeEngine == null) {\n            logger.fine(\"NodeEngine for discovered master \" + master + \" is null.\");\n            return;\n        }\n\n        if (!masterNodeEngine.isRunning()) {\n            logger.fine(\"NodeEngine for discovered master \" + master + \" is not running. -> \"\n                    + masterNodeEngine.getNode().getState());\n            return;\n        }\n\n        if (!masterNodeEngine.getNode().joined()) {\n            logger.fine(\"NodeEngine for discovered master \" + master + \" is not joined.\");\n            return;\n        }\n\n        logger.fine(\"Found possible master. Will try to connect to \" + master);\n        masterAddress = master;\n    }","commit_id":"c200d755f6f5d9de0f9ee5b51140822924f7054d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void doJoin() {\n        synchronized (joinerLock) {\n\n            ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n            long joinStartTime = Clock.currentTimeMillis();\n            long maxJoinMillis = getMaxJoinMillis();\n\n            while (node.isRunning() && !node.joined()\n                    && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {\n                try {\n                    lookupMasterAddress();\n\n                    if (node.getThisAddress().equals(masterAddress)) {\n                        node.setJoined();\n                        node.setAsMaster();\n                        break;\n                    }\n\n                    if (masterAddress != null) {\n                        node.setMasterAddress(masterAddress);\n                        clusterJoinManager.sendJoinRequest(masterAddress, true);\n                    }\n\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n            if (!node.joined()) {\n                logger.severe(\"Node[\" + node.getThisAddress() + \"] should have been joined to \" + node.getMasterAddress());\n                node.shutdown(true);\n            }\n        }\n    }","id":34697,"modified_method":"public void doJoin() {\n        synchronized (joinerLock) {\n\n            ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n            long joinStartTime = Clock.currentTimeMillis();\n            long maxJoinMillis = getMaxJoinMillis();\n\n            while (node.isRunning() && !node.joined()\n                    && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {\n                try {\n                    if (masterAddress == null) {\n                        lookupMasterAddress();\n                    }\n\n                    if (node.getThisAddress().equals(masterAddress)) {\n                        logger.fine(\"This node is found as master, no need to join.\");\n                        node.setJoined();\n                        node.setAsMaster();\n                        break;\n                    }\n\n                    if (masterAddress != null) {\n                        logger.fine(\"Sending join request to master \" + masterAddress);\n                        node.setMasterAddress(masterAddress);\n                        if (!clusterJoinManager.sendJoinRequest(masterAddress, true)) {\n                            logger.fine(\"Could not send join request to \" + masterAddress);\n                            masterAddress = null;\n                        }\n                    }\n\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n            if (!node.joined()) {\n                logger.severe(\"Node[\" + node.getThisAddress() + \"] should have been joined to \" + node.getMasterAddress());\n                node.shutdown(true);\n            }\n        }\n    }","commit_id":"c200d755f6f5d9de0f9ee5b51140822924f7054d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private NodeEngineImpl findAliveNodeEngine() {\n        for (Address address : joinAddresses) {\n            NodeEngineImpl nodeEngine = nodes.get(address);\n            if (nodeEngine != null && nodeEngine.isRunning() && nodeEngine.getNode().joined()) {\n                return nodeEngine;\n            }\n        }\n        return null;\n    }","id":34698,"modified_method":"private NodeEngineImpl findAliveNodeEngine() {\n        logger.fine(\"Searching possible addresses for master \" + joinAddresses);\n        for (Address address : joinAddresses) {\n            NodeEngineImpl nodeEngine = nodes.get(address);\n            if (nodeEngine == null) {\n                logger.fine(\"NodeEngine for \" + address + \" is null.\");\n                continue;\n            }\n\n            if (!nodeEngine.isRunning()) {\n                logger.fine(\"NodeEngine for \" + address + \" is not running. -> \" + nodeEngine.getNode().getState());\n                continue;\n            }\n\n            if (!nodeEngine.getNode().joined()) {\n                logger.fine(\"NodeEngine for \" + address + \" is not joined.\");\n                continue;\n            }\n\n            logger.fine(\"Found an alive node. Will ask master of \" + address);\n            return nodeEngine;\n        }\n        return null;\n    }","commit_id":"c200d755f6f5d9de0f9ee5b51140822924f7054d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public TestHazelcastInstanceFactory() {\n        this.count = 0;\n        this.registry = new TestNodeRegistry(addressMap.values());\n    }","id":34699,"modified_method":"public TestHazelcastInstanceFactory() {\n        this.count = 0;\n        this.registry = new TestNodeRegistry(Collections.unmodifiableCollection(addressMap.values()));\n    }","commit_id":"c200d755f6f5d9de0f9ee5b51140822924f7054d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void initFactory(Collection<Address> addresses) {\n        int ix = 0;\n        for (Address address : addresses) {\n            addressMap.put(ix++, address);\n        }\n        this.registry = new TestNodeRegistry(addressMap.values());\n    }","id":34700,"modified_method":"private void initFactory(Collection<Address> addresses) {\n        int ix = 0;\n        for (Address address : addresses) {\n            addressMap.put(ix++, address);\n        }\n        this.registry = new TestNodeRegistry(Collections.unmodifiableCollection(addressMap.values()));\n    }","commit_id":"c200d755f6f5d9de0f9ee5b51140822924f7054d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public JCExpression transform(Tree.NotEqualOp op) {\n        OperatorTranslation operator = Operators.OperatorTranslation.BINARY_EQUAL;\n        boolean optimised = operator.isOptimisable(op, this);\n        \n        // we want it unboxed only if the operator is optimised\n        // we don't care about the left erased type, since equals() is on Object\n        JCExpression left = transformExpression(op.getLeftTerm(), getBoxingStrategy(optimised), null);\n        // we don't care about the right erased type, since equals() is on Object\n        JCExpression expr = transformOverridableBinaryOperator(op, operator, optimised, left, null);\n        return at(op).Unary(JCTree.NOT, expr);\n    }","id":34701,"modified_method":"public JCExpression transform(Tree.NotEqualOp op) {\n        OperatorTranslation operator = Operators.OperatorTranslation.BINARY_EQUAL;\n        OptimisationStrategy optimisationStrategy = operator.getOptimisationStrategy(op, this);\n        \n        // we want it unboxed only if the operator is optimised\n        // we don't care about the left erased type, since equals() is on Object\n        JCExpression left = transformExpression(op.getLeftTerm(), optimisationStrategy.getBoxingStrategy(), null);\n        // we don't care about the right erased type, since equals() is on Object\n        JCExpression expr = transformOverridableBinaryOperator(op, operator, optimisationStrategy, left, null);\n        return at(op).Unary(JCTree.NOT, expr);\n    }","commit_id":"13a38f168af7cb71fd52e7cd076fbd8eb4af38b8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCExpression transform(final Tree.ArithmeticAssignmentOp op){\n        final AssignmentOperatorTranslation operator = Operators.getAssignmentOperator(op.getClass());\n        if(operator == null){\n            log.error(\"ceylon\", \"Not supported yet: \"+op.getNodeType());\n            return at(op).Erroneous(List.<JCTree>nil());\n        }\n\n        // see if we can optimise it\n        if(op.getUnboxed()){\n            return optimiseAssignmentOperator(op, operator);\n        }\n        \n        // find the proper type\n        Interface compoundType = op.getUnit().getNumericDeclaration();\n        if(op instanceof Tree.AddAssignOp){\n            compoundType = op.getUnit().getSummableDeclaration();\n        }else if(op instanceof Tree.RemainderAssignOp){\n            compoundType = op.getUnit().getIntegralDeclaration();\n        }\n        \n        final ProducedType leftType = getSupertype(op.getLeftTerm(), compoundType);\n        final ProducedType rightType = getTypeArgument(leftType, 0);\n\n        // we work on boxed types\n        return transformAssignAndReturnOperation(op, op.getLeftTerm(), true, \n                leftType, rightType, \n                new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // make this call: previousValue OP RHS\n                return transformOverridableBinaryOperator(op, operator.binaryOperator, false, previousValue, rightType);\n            }\n        });\n    }","id":34702,"modified_method":"public JCExpression transform(final Tree.ArithmeticAssignmentOp op){\n        final AssignmentOperatorTranslation operator = Operators.getAssignmentOperator(op.getClass());\n        if(operator == null){\n            log.error(\"ceylon\", \"Not supported yet: \"+op.getNodeType());\n            return at(op).Erroneous(List.<JCTree>nil());\n        }\n\n        // see if we can optimise it\n        if(op.getUnboxed()){\n            return optimiseAssignmentOperator(op, operator);\n        }\n        \n        // find the proper type\n        Interface compoundType = op.getUnit().getNumericDeclaration();\n        if(op instanceof Tree.AddAssignOp){\n            compoundType = op.getUnit().getSummableDeclaration();\n        }else if(op instanceof Tree.RemainderAssignOp){\n            compoundType = op.getUnit().getIntegralDeclaration();\n        }\n        \n        final ProducedType leftType = getSupertype(op.getLeftTerm(), compoundType);\n        final ProducedType rightType = getTypeArgument(leftType, 0);\n\n        // we work on boxed types\n        return transformAssignAndReturnOperation(op, op.getLeftTerm(), true, \n                leftType, rightType, \n                new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // make this call: previousValue OP RHS\n                return transformOverridableBinaryOperator(op, operator.binaryOperator, OptimisationStrategy.NONE, \n                        previousValue, rightType);\n            }\n        });\n    }","commit_id":"13a38f168af7cb71fd52e7cd076fbd8eb4af38b8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression transformOverridableUnaryOperator(Tree.UnaryOperatorExpression op, ProducedType expectedType) {\n        at(op);\n        Tree.Term term = op.getTerm();\n\n        OperatorTranslation operator = Operators.getOperator(op.getClass());\n        if (operator == null) {\n            return make().Erroneous();\n        }\n\n        boolean isUnboxed = term.getUnboxed();\n        if(isUnboxed && operator.isOptimisable(op, this)){\n            // optimisation for unboxed types\n            return make().Unary(operator.javacOperator, transformExpression(term, BoxingStrategy.UNBOXED, expectedType));\n        }\n        \n        return make().Apply(null, makeSelect(transformExpression(term, BoxingStrategy.BOXED, expectedType), \n                Util.getGetterName(operator.ceylonMethod)), List.<JCExpression> nil());\n    }","id":34703,"modified_method":"private JCExpression transformOverridableUnaryOperator(Tree.UnaryOperatorExpression op, ProducedType expectedType) {\n        at(op);\n        Tree.Term term = op.getTerm();\n\n        OperatorTranslation operator = Operators.getOperator(op.getClass());\n        if (operator == null) {\n            return make().Erroneous();\n        }\n\n        if(operator.getOptimisationStrategy(op, this).useJavaOperator()){\n            // optimisation for unboxed types\n            return make().Unary(operator.javacOperator, transformExpression(term, BoxingStrategy.UNBOXED, expectedType));\n        }\n        \n        return make().Apply(null, makeSelect(transformExpression(term, BoxingStrategy.BOXED, expectedType), \n                Util.getGetterName(operator.ceylonMethod)), List.<JCExpression> nil());\n    }","commit_id":"13a38f168af7cb71fd52e7cd076fbd8eb4af38b8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression transformOverridableBinaryOperator(Tree.BinaryOperatorExpression op, \n            OperatorTranslation originalOperator, boolean optimised, \n            JCExpression left, ProducedType rightType) {\n        JCExpression result = null;\n        \n        JCExpression right = transformExpression(op.getRightTerm(), getBoxingStrategy(optimised), rightType);\n\n        // optimise if we can\n        if(optimised){\n            return make().Binary(originalOperator.javacOperator, left, right);\n        }\n\n        boolean loseComparison = \n                originalOperator == OperatorTranslation.BINARY_SMALLER \n                || originalOperator == OperatorTranslation.BINARY_SMALL_AS \n                || originalOperator == OperatorTranslation.BINARY_LARGER\n                || originalOperator == OperatorTranslation.BINARY_LARGE_AS;\n\n        // for comparisons we need to invoke compare()\n        OperatorTranslation actualOperator = originalOperator;\n        if (loseComparison) {\n            actualOperator = Operators.OperatorTranslation.BINARY_COMPARE;\n            if (actualOperator == null) {\n                return make().Erroneous();\n            }\n        }\n\n        result = at(op).Apply(null, makeSelect(left, actualOperator.ceylonMethod), List.of(right));\n\n        if (loseComparison) {\n            result = at(op).Apply(null, makeSelect(result, originalOperator.ceylonMethod), List.<JCExpression> nil());\n        }\n\n        return result;\n    }","id":34704,"modified_method":"private JCExpression transformOverridableBinaryOperator(Tree.BinaryOperatorExpression op, \n            OperatorTranslation originalOperator, OptimisationStrategy optimisatonStrategy, \n            JCExpression left, ProducedType rightType) {\n        JCExpression result = null;\n        \n        JCExpression right = transformExpression(op.getRightTerm(), optimisatonStrategy.getBoxingStrategy(), rightType);\n\n        // optimise if we can\n        if(optimisatonStrategy.useJavaOperator()){\n            return make().Binary(originalOperator.javacOperator, left, right);\n        }\n\n        boolean loseComparison = \n                originalOperator == OperatorTranslation.BINARY_SMALLER \n                || originalOperator == OperatorTranslation.BINARY_SMALL_AS \n                || originalOperator == OperatorTranslation.BINARY_LARGER\n                || originalOperator == OperatorTranslation.BINARY_LARGE_AS;\n\n        // for comparisons we need to invoke compare()\n        OperatorTranslation actualOperator = originalOperator;\n        if (loseComparison) {\n            actualOperator = Operators.OperatorTranslation.BINARY_COMPARE;\n            if (actualOperator == null) {\n                return make().Erroneous();\n            }\n        }\n\n        result = at(op).Apply(null, makeSelect(left, actualOperator.ceylonMethod), List.of(right));\n\n        if (loseComparison) {\n            result = at(op).Apply(null, makeSelect(result, originalOperator.ceylonMethod), List.<JCExpression> nil());\n        }\n\n        return result;\n    }","commit_id":"13a38f168af7cb71fd52e7cd076fbd8eb4af38b8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCExpression transform(Tree.PrefixOperatorExpression expr) {\n        final OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            log.error(\"ceylon\", \"Not supported yet: \"+expr.getNodeType());\n            return at(expr).Erroneous(List.<JCTree>nil());\n        }\n        \n        if(expr.getUnboxed() && operator.isOptimisable(expr, this)){\n            JCExpression term = transformExpression(expr.getTerm(), BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, term);\n        }\n\n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(expr.getTerm(), compoundType);\n        ProducedType returnType = getTypeArgument(valueType, 0);\n        // we work on boxed types\n        return transformAssignAndReturnOperation(expr, expr.getTerm(), true, \n                valueType, returnType, new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // make this call: previousValue.getSuccessor() or previousValue.getPredecessor()\n                return make().Apply(null, makeSelect(previousValue, operator.ceylonMethod), List.<JCExpression>nil());\n            }\n        });\n    }","id":34705,"modified_method":"public JCExpression transform(Tree.PrefixOperatorExpression expr) {\n        final OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            log.error(\"ceylon\", \"Not supported yet: \"+expr.getNodeType());\n            return at(expr).Erroneous(List.<JCTree>nil());\n        }\n        \n        if(operator.getOptimisationStrategy(expr, this).useJavaOperator()){\n            JCExpression term = transformExpression(expr.getTerm(), BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, term);\n        }\n\n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(expr.getTerm(), compoundType);\n        ProducedType returnType = getTypeArgument(valueType, 0);\n        // we work on boxed types\n        return transformAssignAndReturnOperation(expr, expr.getTerm(), true, \n                valueType, returnType, new AssignAndReturnOperationFactory(){\n            @Override\n            public JCExpression getNewValue(JCExpression previousValue) {\n                // make this call: previousValue.getSuccessor() or previousValue.getPredecessor()\n                return make().Apply(null, makeSelect(previousValue, operator.ceylonMethod), List.<JCExpression>nil());\n            }\n        });\n    }","commit_id":"13a38f168af7cb71fd52e7cd076fbd8eb4af38b8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression transformOverridableBinaryOperator(Tree.BinaryOperatorExpression op, ProducedType leftType, ProducedType rightType) {\n        OperatorTranslation operator = Operators.getOperator(op.getClass());\n        if (operator == null) {\n            return make().Erroneous();\n        }\n        boolean optimised = operator.isOptimisable(op, this);\n\n        JCExpression left = transformExpression(op.getLeftTerm(), getBoxingStrategy(optimised), leftType);\n        return transformOverridableBinaryOperator(op, operator, optimised, left, rightType);\n    }","id":34706,"modified_method":"private JCExpression transformOverridableBinaryOperator(Tree.BinaryOperatorExpression op, ProducedType leftType, ProducedType rightType) {\n        OperatorTranslation operator = Operators.getOperator(op.getClass());\n        if (operator == null) {\n            return make().Erroneous();\n        }\n        OptimisationStrategy optimisationStrategy = operator.getOptimisationStrategy(op, this);\n\n        JCExpression left = transformExpression(op.getLeftTerm(), optimisationStrategy.getBoxingStrategy(), leftType);\n        return transformOverridableBinaryOperator(op, operator, optimisationStrategy, left, rightType);\n    }","commit_id":"13a38f168af7cb71fd52e7cd076fbd8eb4af38b8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCExpression transform(Tree.PostfixOperatorExpression expr) {\n        OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            log.error(\"ceylon\", \"Not supported yet: \"+expr.getNodeType());\n            return at(expr).Erroneous(List.<JCTree>nil());\n        }\n        \n        if(expr.getUnboxed() && operator.isOptimisable(expr, this)){\n            JCExpression term = transformExpression(expr.getTerm(), BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, term);\n        }\n        \n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(expr.getTerm(), compoundType);\n        ProducedType returnType = getTypeArgument(valueType, 0);\n\n        Tree.Term term = expr.getTerm();\n        List<JCVariableDecl> decls = List.nil();\n        List<JCStatement> stats = List.nil();\n        JCExpression result = null;\n        // attr++\n        // (let $tmp = attr; attr = $tmp.getSuccessor(); $tmp;)\n        if(term instanceof Tree.BaseMemberExpression){\n            JCExpression getter = transform((Tree.BaseMemberExpression)term, null);\n            at(expr);\n            // Type $tmp = attr\n            JCExpression exprType = makeJavaType(returnType, NO_PRIMITIVES);\n            Name varName = names().fromString(tempName(\"op\"));\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, BoxingStrategy.BOXED, returnType);\n            JCVariableDecl tmpVar = make().VarDef(make().Modifiers(0), varName, exprType, getter);\n            decls = decls.prepend(tmpVar);\n\n            // attr = $tmp.getSuccessor()\n            JCExpression successor = make().Apply(null, \n                                                  makeSelect(make().Ident(varName), operator.ceylonMethod), \n                                                  List.<JCExpression>nil());\n            // make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n            successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            JCExpression assignment = transformAssignment(expr, term, successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n\n            // $tmp\n            // always return boxed\n            result = make().Ident(varName);\n        }\n        else if(term instanceof Tree.QualifiedMemberExpression){\n            // e.attr++\n            // (let $tmpE = e, $tmpV = $tmpE.attr; $tmpE.attr = $tmpV.getSuccessor(); $tmpV;)\n            Tree.QualifiedMemberExpression qualified = (Tree.QualifiedMemberExpression) term;\n\n            // transform the primary, this will get us a boxed primary \n            JCExpression e = transformQualifiedMemberPrimary(qualified);\n            at(expr);\n            \n            // Type $tmpE = e\n            JCExpression exprType = makeJavaType(qualified.getTarget().getQualifyingType(), NO_PRIMITIVES);\n            Name varEName = names().fromString(tempName(\"opE\"));\n            JCVariableDecl tmpEVar = make().VarDef(make().Modifiers(0), varEName, exprType, e);\n\n            // Type $tmpV = $tmpE.attr\n            JCExpression attrType = makeJavaType(returnType, NO_PRIMITIVES);\n            Name varVName = names().fromString(tempName(\"opV\"));\n            JCExpression getter = transformMemberExpression(qualified, make().Ident(varEName), null);\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, BoxingStrategy.BOXED, returnType);\n            JCVariableDecl tmpVVar = make().VarDef(make().Modifiers(0), varVName, attrType, getter);\n\n            // define all the variables\n            decls = decls.prepend(tmpVVar);\n            decls = decls.prepend(tmpEVar);\n            \n            // $tmpE.attr = $tmpV.getSuccessor()\n            JCExpression successor = make().Apply(null, \n                                                  makeSelect(make().Ident(varVName), operator.ceylonMethod), \n                                                  List.<JCExpression>nil());\n            // make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n            successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            JCExpression assignment = transformAssignment(expr, term, make().Ident(varEName), successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n            \n            // $tmpV\n            // always return boxed\n            result = make().Ident(varVName);\n        }else{\n            log.error(\"ceylon\", \"Not supported yet\");\n            return at(expr).Erroneous(List.<JCTree>nil());\n        }\n        // e?.attr++ is probably not legal\n        // a[i]++ is not for M1 but will be:\n        // (let $tmpA = a, $tmpI = i, $tmpV = $tmpA.item($tmpI); $tmpA.setItem($tmpI, $tmpV.getSuccessor()); $tmpV;)\n        // a?[i]++ is probably not legal\n        // a[i1..i1]++ and a[i1...]++ are probably not legal\n        // a[].attr++ and a[].e.attr++ are probably not legal\n\n        return make().LetExpr(decls, stats, result);\n    }","id":34707,"modified_method":"public JCExpression transform(Tree.PostfixOperatorExpression expr) {\n        OperatorTranslation operator = Operators.getOperator(expr.getClass());\n        if(operator == null){\n            log.error(\"ceylon\", \"Not supported yet: \"+expr.getNodeType());\n            return at(expr).Erroneous(List.<JCTree>nil());\n        }\n        \n        if(operator.getOptimisationStrategy(expr, this).useJavaOperator()){\n            JCExpression term = transformExpression(expr.getTerm(), BoxingStrategy.UNBOXED, expr.getTypeModel());\n            return at(expr).Unary(operator.javacOperator, term);\n        }\n        \n        Interface compoundType = expr.getUnit().getOrdinalDeclaration();\n        ProducedType valueType = getSupertype(expr.getTerm(), compoundType);\n        ProducedType returnType = getTypeArgument(valueType, 0);\n\n        Tree.Term term = expr.getTerm();\n        List<JCVariableDecl> decls = List.nil();\n        List<JCStatement> stats = List.nil();\n        JCExpression result = null;\n        // attr++\n        // (let $tmp = attr; attr = $tmp.getSuccessor(); $tmp;)\n        if(term instanceof Tree.BaseMemberExpression){\n            JCExpression getter = transform((Tree.BaseMemberExpression)term, null);\n            at(expr);\n            // Type $tmp = attr\n            JCExpression exprType = makeJavaType(returnType, NO_PRIMITIVES);\n            Name varName = names().fromString(tempName(\"op\"));\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, BoxingStrategy.BOXED, returnType);\n            JCVariableDecl tmpVar = make().VarDef(make().Modifiers(0), varName, exprType, getter);\n            decls = decls.prepend(tmpVar);\n\n            // attr = $tmp.getSuccessor()\n            JCExpression successor = make().Apply(null, \n                                                  makeSelect(make().Ident(varName), operator.ceylonMethod), \n                                                  List.<JCExpression>nil());\n            // make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n            successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            JCExpression assignment = transformAssignment(expr, term, successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n\n            // $tmp\n            // always return boxed\n            result = make().Ident(varName);\n        }\n        else if(term instanceof Tree.QualifiedMemberExpression){\n            // e.attr++\n            // (let $tmpE = e, $tmpV = $tmpE.attr; $tmpE.attr = $tmpV.getSuccessor(); $tmpV;)\n            Tree.QualifiedMemberExpression qualified = (Tree.QualifiedMemberExpression) term;\n\n            // transform the primary, this will get us a boxed primary \n            JCExpression e = transformQualifiedMemberPrimary(qualified);\n            at(expr);\n            \n            // Type $tmpE = e\n            JCExpression exprType = makeJavaType(qualified.getTarget().getQualifyingType(), NO_PRIMITIVES);\n            Name varEName = names().fromString(tempName(\"opE\"));\n            JCVariableDecl tmpEVar = make().VarDef(make().Modifiers(0), varEName, exprType, e);\n\n            // Type $tmpV = $tmpE.attr\n            JCExpression attrType = makeJavaType(returnType, NO_PRIMITIVES);\n            Name varVName = names().fromString(tempName(\"opV\"));\n            JCExpression getter = transformMemberExpression(qualified, make().Ident(varEName), null);\n            // make sure we box the results if necessary\n            getter = applyErasureAndBoxing(getter, term, BoxingStrategy.BOXED, returnType);\n            JCVariableDecl tmpVVar = make().VarDef(make().Modifiers(0), varVName, attrType, getter);\n\n            // define all the variables\n            decls = decls.prepend(tmpVVar);\n            decls = decls.prepend(tmpEVar);\n            \n            // $tmpE.attr = $tmpV.getSuccessor()\n            JCExpression successor = make().Apply(null, \n                                                  makeSelect(make().Ident(varVName), operator.ceylonMethod), \n                                                  List.<JCExpression>nil());\n            // make sure the result is boxed if necessary, the result of successor/predecessor is always boxed\n            successor = boxUnboxIfNecessary(successor, true, term.getTypeModel(), Util.getBoxingStrategy(term));\n            JCExpression assignment = transformAssignment(expr, term, make().Ident(varEName), successor);\n            stats = stats.prepend(at(expr).Exec(assignment));\n            \n            // $tmpV\n            // always return boxed\n            result = make().Ident(varVName);\n        }else{\n            log.error(\"ceylon\", \"Not supported yet\");\n            return at(expr).Erroneous(List.<JCTree>nil());\n        }\n        // e?.attr++ is probably not legal\n        // a[i]++ is not for M1 but will be:\n        // (let $tmpA = a, $tmpI = i, $tmpV = $tmpA.item($tmpI); $tmpA.setItem($tmpI, $tmpV.getSuccessor()); $tmpV;)\n        // a?[i]++ is probably not legal\n        // a[i1..i1]++ and a[i1...]++ are probably not legal\n        // a[].attr++ and a[].e.attr++ are probably not legal\n\n        return make().LetExpr(decls, stats, result);\n    }","commit_id":"13a38f168af7cb71fd52e7cd076fbd8eb4af38b8","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visitNewExpression(PsiNewExpression expression){\n            final PsiType type = expression.getType();\n            if(type == null){\n                return;\n            }\n            final PsiType componentType = type.getDeepComponentType();\n            if(!(componentType instanceof PsiClassType)){\n                return;\n            }\n            final PsiClassType classType = (PsiClassType)componentType;\n            final PsiClass parentClass =\n                    PsiTreeUtil.getParentOfType(expression, PsiClass.class);\n            if(!isSubclass(classType, parentClass)){\n                return;\n            }\n            registerError(expression.getClassReference(), parentClass);\n        }","id":34708,"modified_method":"public void visitNewExpression(PsiNewExpression expression){\n            final PsiType type = expression.getType();\n            if(type == null){\n                return;\n            }\n            final PsiType componentType = type.getDeepComponentType();\n            if(!(componentType instanceof PsiClassType)){\n                return;\n            }\n            final PsiClassType classType = (PsiClassType)componentType;\n            final PsiClass parentClass =\n                    PsiTreeUtil.getParentOfType(expression, PsiClass.class);\n            if(!isSubclass(classType, parentClass)){\n                return;\n            }\n            final PsiJavaCodeReferenceElement classReference =\n                    expression.getClassReference();\n            if (classReference != null) {\n                registerError(classReference, parentClass);\n            } else {\n                final PsiAnonymousClass anonymousClass =\n                        expression.getAnonymousClass();\n                registerClassError(anonymousClass, parentClass);\n            }\n        }","commit_id":"22f6a91d5b0f71c2420f3c1b069a3c4ef1ee74ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String buildErrorString(Object... infos){\n        final PsiNamedElement element = (PsiNamedElement)infos[0];\n        final String containingClassName = element.getName();\n        return InspectionGadgetsBundle.message(\n                \"class.references.subclass.problem.descriptor\",\n                containingClassName);\n    }","id":34709,"modified_method":"@NotNull\n    public String buildErrorString(Object... infos){\n        final PsiNamedElement element = (PsiNamedElement)infos[0];\n        final PsiElement parentElement = element.getParent();\n        final String containingClassName = element.getName();\n        if (parentElement instanceof PsiAnonymousClass) {\n            return InspectionGadgetsBundle.message(\n                    \"class.references.subclass.problem.descriptor.anonymous\",\n                    containingClassName);\n        }\n        return InspectionGadgetsBundle.message(\n                \"class.references.subclass.problem.descriptor\",\n                containingClassName);\n    }","commit_id":"22f6a91d5b0f71c2420f3c1b069a3c4ef1ee74ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void registerCastActions(CandidateInfo[] candidates, PsiCall call, PsiJavaCodeReferenceElement methodRef, HighlightInfo highlightInfo) {\n    if (candidates.length == 0) return;\n    List<CandidateInfo> methodCandidates = new ArrayList<CandidateInfo>(Arrays.asList(candidates));\n    PsiExpressionList list = call.getArgumentList();\n    PsiExpression[] expressions = list.getExpressions();\n    if (expressions.length == 0) return;\n    // filter out not castable candidates\n    nextMethod:\n    for (int i = methodCandidates.size() - 1; i >= 0; i--) {\n      CandidateInfo candidate = methodCandidates.get(i);\n      PsiMethod method = (PsiMethod) candidate.getElement();\n      PsiSubstitutor substitutor = candidate.getSubstitutor();\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      if (expressions.length != parameters.length) {\n        methodCandidates.remove(i);\n        continue;\n      }\n      for (int j = 0; j < parameters.length; j++) {\n        PsiParameter parameter = parameters[j];\n        PsiExpression expression = expressions[j];\n        // check if we can cast to this method\n        PsiType exprType = expression.getType();\n        PsiType parameterType = substitutor.substitute(parameter.getType());\n        if (exprType == null\n            || parameterType == null\n            || !areTypesConvertible(exprType, parameterType)) {\n          methodCandidates.remove(i);\n          continue nextMethod;\n        }\n      }\n    }\n\n    if (methodCandidates.size() == 0) return;\n\n    try {\n      for (int i = 0; i < expressions.length; i++) {\n        PsiExpression expression = expressions[i];\n        PsiType exprType = expression.getType();\n        Set<String> suggestedCasts = new THashSet<String>();\n        // find to which type we can cast this param to get valid method call\n        for (CandidateInfo candidate : methodCandidates) {\n          PsiMethod method = (PsiMethod)candidate.getElement();\n          PsiSubstitutor substitutor = candidate.getSubstitutor();\n          PsiParameter[] parameters = method.getParameterList().getParameters();\n          PsiType originalParameterType = parameters[i].getType();\n          PsiType parameterType = substitutor.substitute(originalParameterType);\n          if (parameterType instanceof PsiWildcardType) continue;\n          if (suggestedCasts.contains(parameterType.getCanonicalText())) continue;\n          // strict compare since even widening cast may help\n          if (Comparing.equal(exprType, parameterType)) continue;\n          PsiCall newCall = (PsiCall) call.copy();\n          PsiExpression modifiedExpression = getModifiedArgument(expression, parameterType);\n          if (modifiedExpression == null) continue;\n          newCall.getArgumentList().getExpressions()[i].replace(modifiedExpression);\n          JavaResolveResult resolveResult = newCall.resolveMethodGenerics();\n          if (resolveResult.getElement() != null && resolveResult.isValidResult()) {\n            suggestedCasts.add(parameterType.getCanonicalText());\n            QuickFixAction.registerQuickFixAction(highlightInfo, createFix(list, i, parameterType));\n          }\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":34710,"modified_method":"public void registerCastActions(CandidateInfo[] candidates, PsiCall call, HighlightInfo highlightInfo) {\n    if (candidates.length == 0) return;\n    List<CandidateInfo> methodCandidates = new ArrayList<CandidateInfo>(Arrays.asList(candidates));\n    PsiExpressionList list = call.getArgumentList();\n    PsiExpression[] expressions = list.getExpressions();\n    if (expressions.length == 0) return;\n    // filter out not castable candidates\n    nextMethod:\n    for (int i = methodCandidates.size() - 1; i >= 0; i--) {\n      CandidateInfo candidate = methodCandidates.get(i);\n      PsiMethod method = (PsiMethod) candidate.getElement();\n      PsiSubstitutor substitutor = candidate.getSubstitutor();\n      assert method != null;\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      if (expressions.length != parameters.length) {\n        methodCandidates.remove(i);\n        continue;\n      }\n      for (int j = 0; j < parameters.length; j++) {\n        PsiParameter parameter = parameters[j];\n        PsiExpression expression = expressions[j];\n        // check if we can cast to this method\n        PsiType exprType = expression.getType();\n        PsiType parameterType = substitutor.substitute(parameter.getType());\n        if (exprType == null\n            || parameterType == null\n            || !areTypesConvertible(exprType, parameterType)) {\n          methodCandidates.remove(i);\n          continue nextMethod;\n        }\n      }\n    }\n\n    if (methodCandidates.isEmpty()) return;\n\n    try {\n      for (int i = 0; i < expressions.length; i++) {\n        PsiExpression expression = expressions[i];\n        PsiType exprType = expression.getType();\n        Set<String> suggestedCasts = new THashSet<String>();\n        // find to which type we can cast this param to get valid method call\n        for (CandidateInfo candidate : methodCandidates) {\n          PsiMethod method = (PsiMethod)candidate.getElement();\n          PsiSubstitutor substitutor = candidate.getSubstitutor();\n          assert method != null;\n          PsiParameter[] parameters = method.getParameterList().getParameters();\n          PsiType originalParameterType = parameters[i].getType();\n          PsiType parameterType = substitutor.substitute(originalParameterType);\n          if (parameterType instanceof PsiWildcardType) continue;\n          if (suggestedCasts.contains(parameterType.getCanonicalText())) continue;\n          // strict compare since even widening cast may help\n          if (Comparing.equal(exprType, parameterType)) continue;\n          PsiCall newCall = (PsiCall) call.copy();\n          PsiExpression modifiedExpression = getModifiedArgument(expression, parameterType);\n          if (modifiedExpression == null) continue;\n          newCall.getArgumentList().getExpressions()[i].replace(modifiedExpression);\n          JavaResolveResult resolveResult = newCall.resolveMethodGenerics();\n          if (resolveResult.getElement() != null && resolveResult.isValidResult()) {\n            suggestedCasts.add(parameterType.getCanonicalText());\n            QuickFixAction.registerQuickFixAction(highlightInfo, createFix(list, i, parameterType));\n          }\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"804fcc24a135e3a5d6fe939084d02565262c07bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void registerCastActions(PsiJavaCodeReferenceElement ctrRef, PsiConstructorCall constructorCall, HighlightInfo highlightInfo) {\n    if (ctrRef == null) return;\n    JavaResolveResult resolved = ctrRef.advancedResolve(false);\n    PsiClass aClass = (PsiClass) resolved.getElement();\n    if (aClass == null) return;\n    PsiMethod[] methods = aClass.getConstructors();\n    CandidateInfo[] candidates = new CandidateInfo[methods.length];\n    for (int i = 0; i < candidates.length; i++) {\n      candidates[i] = new CandidateInfo(methods[i], resolved.getSubstitutor());\n    }\n    CastMethodArgumentFix.REGISTRAR.registerCastActions(candidates, constructorCall, ctrRef, highlightInfo);\n  }","id":34711,"modified_method":"public static void registerCastActions(@NotNull PsiJavaCodeReferenceElement ctrRef, PsiConstructorCall constructorCall, HighlightInfo highlightInfo) {\n    JavaResolveResult resolved = ctrRef.advancedResolve(false);\n    PsiClass aClass = (PsiClass) resolved.getElement();\n    if (aClass == null) return;\n    PsiMethod[] methods = aClass.getConstructors();\n    CandidateInfo[] candidates = new CandidateInfo[methods.length];\n    for (int i = 0; i < candidates.length; i++) {\n      candidates[i] = new CandidateInfo(methods[i], resolved.getSubstitutor());\n    }\n    CastMethodArgumentFix.REGISTRAR.registerCastActions(candidates, constructorCall, highlightInfo);\n  }","commit_id":"804fcc24a135e3a5d6fe939084d02565262c07bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void registerMethodCallIntentions(HighlightInfo highlightInfo,\n                                                   PsiMethodCallExpression methodCall,\n                                                   PsiExpressionList list, PsiResolveHelper resolveHelper) {\n    TextRange range = getFixRange(methodCall);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateMethodFromUsageAction(methodCall), null, null);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateConstructorFromSuperAction(methodCall), null, null);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateConstructorFromThisAction(methodCall), null, null);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreatePropertyFromUsageAction(methodCall), null, null);\n    CandidateInfo[] methodCandidates = resolveHelper.getReferencedMethodCandidates(methodCall, false);\n    CastMethodArgumentFix.REGISTRAR.registerCastActions(methodCandidates, methodCall, methodCall.getMethodExpression(), highlightInfo);\n    AddTypeArgumentsFix.REGISTRAR.registerCastActions(methodCandidates, methodCall, methodCall.getMethodExpression(), highlightInfo);\n    registerMethodAccessLevelIntentions(methodCandidates, methodCall, list, highlightInfo);\n    ChangeMethodSignatureFromUsageFix.registerIntentions(methodCandidates, list, highlightInfo, range);\n    WrapExpressionFix.registerWrapAction(methodCandidates, list.getExpressions(), highlightInfo);\n    ChangeParameterClassFix.registerQuickFixActions(methodCall, list, highlightInfo);\n  }","id":34712,"modified_method":"private static void registerMethodCallIntentions(HighlightInfo highlightInfo,\n                                                   PsiMethodCallExpression methodCall,\n                                                   PsiExpressionList list, PsiResolveHelper resolveHelper) {\n    TextRange range = getFixRange(methodCall);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateMethodFromUsageAction(methodCall), null, null);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateConstructorFromSuperAction(methodCall), null, null);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateConstructorFromThisAction(methodCall), null, null);\n    QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreatePropertyFromUsageAction(methodCall), null, null);\n    CandidateInfo[] methodCandidates = resolveHelper.getReferencedMethodCandidates(methodCall, false);\n    CastMethodArgumentFix.REGISTRAR.registerCastActions(methodCandidates, methodCall, highlightInfo);\n    AddTypeArgumentsFix.REGISTRAR.registerCastActions(methodCandidates, methodCall, highlightInfo);\n    registerMethodAccessLevelIntentions(methodCandidates, methodCall, list, highlightInfo);\n    ChangeMethodSignatureFromUsageFix.registerIntentions(methodCandidates, list, highlightInfo, range);\n    WrapExpressionFix.registerWrapAction(methodCandidates, list.getExpressions(), highlightInfo);\n    ChangeParameterClassFix.registerQuickFixActions(methodCall, list, highlightInfo);\n  }","commit_id":"804fcc24a135e3a5d6fe939084d02565262c07bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkConstructorCall(PsiClassType.ClassResolveResult typeResolveResult,\n                                                   PsiConstructorCall constructorCall,\n                                                   PsiType type,\n                                                   PsiJavaCodeReferenceElement classReference) {\n    PsiExpressionList list = constructorCall.getArgumentList();\n    if (list == null) return null;\n    PsiClass aClass = typeResolveResult.getElement();\n    if (aClass == null) return null;\n    final PsiResolveHelper resolveHelper = constructorCall.getManager().getResolveHelper();\n    PsiClass accessObjectClass = null;\n    if (constructorCall instanceof PsiNewExpression) {\n      PsiExpression qualifier = ((PsiNewExpression)constructorCall).getQualifier();\n      if (qualifier != null) {\n        accessObjectClass = (PsiClass)PsiUtil.getAccessObjectClass(qualifier).getElement();\n      }\n    }\n    if (classReference != null && !resolveHelper.isAccessible(aClass, constructorCall, accessObjectClass)) {\n      String description = HighlightUtil.buildProblemWithAccessDescription(classReference, typeResolveResult);\n      HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, classReference.getReferenceNameElement(), description);\n      HighlightUtil.registerAccessQuickFixAction(aClass, classReference, info, null);\n      return info;\n    }\n    PsiMethod[] constructors = aClass.getConstructors();\n\n    if (constructors.length == 0) {\n      if (list.getExpressions().length != 0) {\n        String constructorName = aClass.getName();\n        String argTypes = HighlightUtil.buildArgTypesList(list);\n        String description = JavaErrorMessages.message(\"wrong.constructor.arguments\", constructorName+\"()\", argTypes);\n        String tooltip = createMismatchedArgumentsHtmlTooltip(list, PsiParameter.EMPTY_ARRAY, constructorName, PsiSubstitutor.EMPTY, aClass);\n        HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description, tooltip);\n        QuickFixAction.registerQuickFixAction(info, constructorCall.getTextRange(), new CreateConstructorFromCallAction(constructorCall), null, null);\n        info.navigationShift = +1;\n        return info;\n      }\n    }\n    else {\n      PsiElement place = list;\n      if (constructorCall instanceof PsiNewExpression) {\n        final PsiAnonymousClass anonymousClass = ((PsiNewExpression)constructorCall).getAnonymousClass();\n        if (anonymousClass != null) place = anonymousClass;\n      }\n\n      JavaResolveResult[] results = resolveHelper.multiResolveConstructor((PsiClassType)type, list, place);\n      MethodCandidateInfo result = null;\n      if (results.length == 1) result = (MethodCandidateInfo)results[0];\n\n      PsiMethod constructor = result == null ? null : result.getElement();\n      if (constructor == null) {\n        String name = aClass.getName();\n        name += HighlightUtil.buildArgTypesList(list);\n        String description = JavaErrorMessages.message(\"cannot.resolve.constructor\", name);\n        HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description);\n        QuickFixAction.registerQuickFixAction(info, constructorCall.getTextRange(), new CreateConstructorFromCallAction(constructorCall), null, null);\n        if (classReference != null) {\n          CastConstructorParametersFix.registerCastActions(classReference, constructorCall, info);\n        }\n        WrapExpressionFix.registerWrapAction(results, list.getExpressions(), info);\n        info.navigationShift = +1;\n        return info;\n      }\n      else {\n        if (!result.isAccessible() || callingProtectedConstructorFromDerivedClass(constructor, constructorCall)) {\n          String description = HighlightUtil.buildProblemWithAccessDescription(classReference, result);\n          HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description);\n          info.navigationShift = +1;\n          if (classReference != null && result.isStaticsScopeCorrect()) {\n            HighlightUtil.registerAccessQuickFixAction(constructor, classReference, info, result.getCurrentFileResolveScope());\n          }\n          return info;\n        }\n        else if (!result.isApplicable()) {\n          String constructorName = HighlightMessageUtil.getSymbolName(constructor, result.getSubstitutor());\n          String containerName = HighlightMessageUtil.getSymbolName(constructor.getParent(), result.getSubstitutor());\n          String argTypes = HighlightUtil.buildArgTypesList(list);\n          String description = JavaErrorMessages.message(\"wrong.method.arguments\", constructorName, containerName, argTypes);\n          String toolTip = createMismatchedArgumentsHtmlTooltip(result, list);\n          PsiElement infoElement = list.getTextLength() > 0 ? list : constructorCall;\n          HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, infoElement, description, toolTip);\n          QuickFixAction.registerQuickFixAction(info, constructorCall.getTextRange(), new CreateConstructorFromCallAction(constructorCall), null, null);\n          if (classReference != null) {\n            CastConstructorParametersFix.registerCastActions(classReference, constructorCall, info);\n            ChangeMethodSignatureFromUsageFix.registerIntentions(results, list, info, null);\n          }\n          info.navigationShift = +1;\n          return info;\n        }\n        else {\n          HighlightInfo highlightInfo = GenericsHighlightUtil.checkUncheckedCall(result, constructorCall);\n          if (highlightInfo != null) return highlightInfo;\n          if (constructorCall instanceof PsiNewExpression) {\n            highlightInfo = GenericsHighlightUtil.checkGenericCallWithRawArguments(result, (PsiCallExpression)constructorCall);\n          }\n          if (highlightInfo != null) return highlightInfo;\n        }\n      }\n    }\n    return null;\n  }","id":34713,"modified_method":"public static HighlightInfo checkConstructorCall(PsiClassType.ClassResolveResult typeResolveResult,\n                                                   PsiConstructorCall constructorCall,\n                                                   PsiType type,\n                                                   PsiJavaCodeReferenceElement classReference) {\n    PsiExpressionList list = constructorCall.getArgumentList();\n    if (list == null) return null;\n    PsiClass aClass = typeResolveResult.getElement();\n    if (aClass == null) return null;\n    final PsiResolveHelper resolveHelper = constructorCall.getManager().getResolveHelper();\n    PsiClass accessObjectClass = null;\n    if (constructorCall instanceof PsiNewExpression) {\n      PsiExpression qualifier = ((PsiNewExpression)constructorCall).getQualifier();\n      if (qualifier != null) {\n        accessObjectClass = (PsiClass)PsiUtil.getAccessObjectClass(qualifier).getElement();\n      }\n    }\n    if (classReference != null && !resolveHelper.isAccessible(aClass, constructorCall, accessObjectClass)) {\n      String description = HighlightUtil.buildProblemWithAccessDescription(classReference, typeResolveResult);\n      HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, classReference.getReferenceNameElement(), description);\n      HighlightUtil.registerAccessQuickFixAction(aClass, classReference, info, null);\n      return info;\n    }\n    PsiMethod[] constructors = aClass.getConstructors();\n\n    if (constructors.length == 0) {\n      if (list.getExpressions().length != 0) {\n        String constructorName = aClass.getName();\n        String argTypes = HighlightUtil.buildArgTypesList(list);\n        String description = JavaErrorMessages.message(\"wrong.constructor.arguments\", constructorName+\"()\", argTypes);\n        String tooltip = createMismatchedArgumentsHtmlTooltip(list, PsiParameter.EMPTY_ARRAY, constructorName, PsiSubstitutor.EMPTY, aClass);\n        HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description, tooltip);\n        QuickFixAction.registerQuickFixAction(info, constructorCall.getTextRange(), new CreateConstructorFromCallAction(constructorCall), null, null);\n        if (classReference != null) {\n          CastConstructorParametersFix.registerCastActions(classReference, constructorCall, info);\n        }\n        info.navigationShift = +1;\n        return info;\n      }\n    }\n    else {\n      PsiElement place = list;\n      if (constructorCall instanceof PsiNewExpression) {\n        final PsiAnonymousClass anonymousClass = ((PsiNewExpression)constructorCall).getAnonymousClass();\n        if (anonymousClass != null) place = anonymousClass;\n      }\n\n      JavaResolveResult[] results = resolveHelper.multiResolveConstructor((PsiClassType)type, list, place);\n      MethodCandidateInfo result = null;\n      if (results.length == 1) result = (MethodCandidateInfo)results[0];\n\n      PsiMethod constructor = result == null ? null : result.getElement();\n      if (constructor == null) {\n        String name = aClass.getName();\n        name += HighlightUtil.buildArgTypesList(list);\n        String description = JavaErrorMessages.message(\"cannot.resolve.constructor\", name);\n        HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description);\n        QuickFixAction.registerQuickFixAction(info, constructorCall.getTextRange(), new CreateConstructorFromCallAction(constructorCall), null, null);\n        if (classReference != null) {\n          CastConstructorParametersFix.registerCastActions(classReference, constructorCall, info);\n        }\n        WrapExpressionFix.registerWrapAction(results, list.getExpressions(), info);\n        info.navigationShift = +1;\n        return info;\n      }\n      else {\n        if (!result.isAccessible() || callingProtectedConstructorFromDerivedClass(constructor, constructorCall)) {\n          String description = HighlightUtil.buildProblemWithAccessDescription(classReference, result);\n          HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description);\n          info.navigationShift = +1;\n          if (classReference != null && result.isStaticsScopeCorrect()) {\n            HighlightUtil.registerAccessQuickFixAction(constructor, classReference, info, result.getCurrentFileResolveScope());\n          }\n          return info;\n        }\n        else if (!result.isApplicable()) {\n          String constructorName = HighlightMessageUtil.getSymbolName(constructor, result.getSubstitutor());\n          String containerName = HighlightMessageUtil.getSymbolName(constructor.getParent(), result.getSubstitutor());\n          String argTypes = HighlightUtil.buildArgTypesList(list);\n          String description = JavaErrorMessages.message(\"wrong.method.arguments\", constructorName, containerName, argTypes);\n          String toolTip = createMismatchedArgumentsHtmlTooltip(result, list);\n          PsiElement infoElement = list.getTextLength() > 0 ? list : constructorCall;\n          HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, infoElement, description, toolTip);\n          QuickFixAction.registerQuickFixAction(info, constructorCall.getTextRange(), new CreateConstructorFromCallAction(constructorCall), null, null);\n          if (classReference != null) {\n            CastConstructorParametersFix.registerCastActions(classReference, constructorCall, info);\n            ChangeMethodSignatureFromUsageFix.registerIntentions(results, list, info, null);\n          }\n          info.navigationShift = +1;\n          return info;\n        }\n        else {\n          HighlightInfo highlightInfo = GenericsHighlightUtil.checkUncheckedCall(result, constructorCall);\n          if (highlightInfo != null) return highlightInfo;\n          if (constructorCall instanceof PsiNewExpression) {\n            highlightInfo = GenericsHighlightUtil.checkGenericCallWithRawArguments(result, (PsiCallExpression)constructorCall);\n          }\n          if (highlightInfo != null) return highlightInfo;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"804fcc24a135e3a5d6fe939084d02565262c07bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static HighlightInfo checkAmbiguousMethodCall(final PsiReferenceExpression referenceToMethod,\n                                                        final PsiExpressionList list,\n                                                        final PsiElement element,\n                                                        final JavaResolveResult resolveResult,\n                                                        final PsiMethodCallExpression methodCall, final PsiResolveHelper resolveHelper) {\n    JavaResolveResult[] resolveResults = referenceToMethod.multiResolve(true);\n    MethodCandidateInfo methodCandidate1 = null;\n    MethodCandidateInfo methodCandidate2 = null;\n    for (JavaResolveResult result : resolveResults) {\n      if (!(result instanceof MethodCandidateInfo)) continue;\n      MethodCandidateInfo candidate = (MethodCandidateInfo)result;\n      if (candidate.isApplicable() && !candidate.getElement().isConstructor()) {\n        if (methodCandidate1 == null) {\n          methodCandidate1 = candidate;\n        }\n        else {\n          methodCandidate2 = candidate;\n          break;\n        }\n      }\n    }\n    List<MethodCandidateInfo> candidateList = new ArrayList<MethodCandidateInfo>();\n\n    for (JavaResolveResult result : resolveResults) {\n      if (!(result instanceof MethodCandidateInfo)) continue;\n      MethodCandidateInfo candidate = (MethodCandidateInfo)result;\n      if (candidate.isAccessible()) candidateList.add(candidate);\n    }\n\n    String description;\n    String toolTip;\n    PsiElement elementToHighlight;\n    HighlightInfoType highlightInfoType = HighlightInfoType.ERROR;\n    if (methodCandidate2 != null) {\n      String m1 = PsiFormatUtil.formatMethod(methodCandidate1.getElement(),\n                                             methodCandidate1.getSubstitutor(),\n                                             PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME |\n                                             PsiFormatUtil.SHOW_PARAMETERS,\n                                             PsiFormatUtil.SHOW_TYPE);\n      String m2 = PsiFormatUtil.formatMethod(methodCandidate2.getElement(),\n                                             methodCandidate2.getSubstitutor(),\n                                             PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME |\n                                             PsiFormatUtil.SHOW_PARAMETERS,\n                                             PsiFormatUtil.SHOW_TYPE);\n      description = JavaErrorMessages.message(\"ambiguous.method.call\", m1, m2);\n      toolTip = createAmbiguousMethodHtmlTooltip(new MethodCandidateInfo[]{methodCandidate1, methodCandidate2});\n      elementToHighlight = list;\n    }\n    else {\n      if (element != null && !resolveResult.isAccessible()) {\n        description = HighlightUtil.buildProblemWithAccessDescription(referenceToMethod, resolveResult);\n        elementToHighlight = referenceToMethod.getReferenceNameElement();\n      }\n      else if (element != null && !resolveResult.isStaticsScopeCorrect()) {\n        description = HighlightUtil.buildProblemWithStaticDescription(element);\n        elementToHighlight = referenceToMethod.getReferenceNameElement();\n      }\n      else {\n        String methodName = referenceToMethod.getReferenceName() + HighlightUtil.buildArgTypesList(list);\n        description = JavaErrorMessages.message(\"cannot.resolve.method\", methodName);\n        if (candidateList.isEmpty()) {\n          elementToHighlight = referenceToMethod.getReferenceNameElement();\n          highlightInfoType = HighlightInfoType.WRONG_REF;\n        }\n        else {\n          elementToHighlight = list;\n        }\n      }\n      toolTip = description;\n    }\n    HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(highlightInfoType, elementToHighlight, description, toolTip);\n    if (methodCandidate2 == null) {\n      registerMethodCallIntentions(highlightInfo, methodCall, list, resolveHelper);\n    }\n    if (!resolveResult.isAccessible() && resolveResult.isStaticsScopeCorrect() && methodCandidate2 != null) {\n      HighlightUtil.registerAccessQuickFixAction((PsiMember)element, referenceToMethod, highlightInfo, resolveResult.getCurrentFileResolveScope());\n    }\n    if (!resolveResult.isStaticsScopeCorrect()) {\n      HighlightUtil.registerStaticProblemQuickFixAction(element, highlightInfo, referenceToMethod);\n    }\n\n    MethodCandidateInfo[] candidates = candidateList.toArray(new MethodCandidateInfo[candidateList.size()]);\n    CastMethodArgumentFix.REGISTRAR.registerCastActions(candidates, methodCall, methodCall.getMethodExpression(), highlightInfo);\n    WrapExpressionFix.registerWrapAction(candidates, list.getExpressions(), highlightInfo);\n    ChangeParameterClassFix.registerQuickFixActions(methodCall, list, highlightInfo);\n    return highlightInfo;\n  }","id":34714,"modified_method":"private static HighlightInfo checkAmbiguousMethodCall(final PsiReferenceExpression referenceToMethod,\n                                                        final PsiExpressionList list,\n                                                        final PsiElement element,\n                                                        final JavaResolveResult resolveResult,\n                                                        final PsiMethodCallExpression methodCall, final PsiResolveHelper resolveHelper) {\n    JavaResolveResult[] resolveResults = referenceToMethod.multiResolve(true);\n    MethodCandidateInfo methodCandidate1 = null;\n    MethodCandidateInfo methodCandidate2 = null;\n    for (JavaResolveResult result : resolveResults) {\n      if (!(result instanceof MethodCandidateInfo)) continue;\n      MethodCandidateInfo candidate = (MethodCandidateInfo)result;\n      if (candidate.isApplicable() && !candidate.getElement().isConstructor()) {\n        if (methodCandidate1 == null) {\n          methodCandidate1 = candidate;\n        }\n        else {\n          methodCandidate2 = candidate;\n          break;\n        }\n      }\n    }\n    List<MethodCandidateInfo> candidateList = new ArrayList<MethodCandidateInfo>();\n\n    for (JavaResolveResult result : resolveResults) {\n      if (!(result instanceof MethodCandidateInfo)) continue;\n      MethodCandidateInfo candidate = (MethodCandidateInfo)result;\n      if (candidate.isAccessible()) candidateList.add(candidate);\n    }\n\n    String description;\n    String toolTip;\n    PsiElement elementToHighlight;\n    HighlightInfoType highlightInfoType = HighlightInfoType.ERROR;\n    if (methodCandidate2 != null) {\n      String m1 = PsiFormatUtil.formatMethod(methodCandidate1.getElement(),\n                                             methodCandidate1.getSubstitutor(),\n                                             PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME |\n                                             PsiFormatUtil.SHOW_PARAMETERS,\n                                             PsiFormatUtil.SHOW_TYPE);\n      String m2 = PsiFormatUtil.formatMethod(methodCandidate2.getElement(),\n                                             methodCandidate2.getSubstitutor(),\n                                             PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME |\n                                             PsiFormatUtil.SHOW_PARAMETERS,\n                                             PsiFormatUtil.SHOW_TYPE);\n      description = JavaErrorMessages.message(\"ambiguous.method.call\", m1, m2);\n      toolTip = createAmbiguousMethodHtmlTooltip(new MethodCandidateInfo[]{methodCandidate1, methodCandidate2});\n      elementToHighlight = list;\n    }\n    else {\n      if (element != null && !resolveResult.isAccessible()) {\n        description = HighlightUtil.buildProblemWithAccessDescription(referenceToMethod, resolveResult);\n        elementToHighlight = referenceToMethod.getReferenceNameElement();\n      }\n      else if (element != null && !resolveResult.isStaticsScopeCorrect()) {\n        description = HighlightUtil.buildProblemWithStaticDescription(element);\n        elementToHighlight = referenceToMethod.getReferenceNameElement();\n      }\n      else {\n        String methodName = referenceToMethod.getReferenceName() + HighlightUtil.buildArgTypesList(list);\n        description = JavaErrorMessages.message(\"cannot.resolve.method\", methodName);\n        if (candidateList.isEmpty()) {\n          elementToHighlight = referenceToMethod.getReferenceNameElement();\n          highlightInfoType = HighlightInfoType.WRONG_REF;\n        }\n        else {\n          elementToHighlight = list;\n        }\n      }\n      toolTip = description;\n    }\n    HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(highlightInfoType, elementToHighlight, description, toolTip);\n    if (methodCandidate2 == null) {\n      registerMethodCallIntentions(highlightInfo, methodCall, list, resolveHelper);\n    }\n    if (!resolveResult.isAccessible() && resolveResult.isStaticsScopeCorrect() && methodCandidate2 != null) {\n      HighlightUtil.registerAccessQuickFixAction((PsiMember)element, referenceToMethod, highlightInfo, resolveResult.getCurrentFileResolveScope());\n    }\n    if (!resolveResult.isStaticsScopeCorrect()) {\n      HighlightUtil.registerStaticProblemQuickFixAction(element, highlightInfo, referenceToMethod);\n    }\n\n    MethodCandidateInfo[] candidates = candidateList.toArray(new MethodCandidateInfo[candidateList.size()]);\n    CastMethodArgumentFix.REGISTRAR.registerCastActions(candidates, methodCall, highlightInfo);\n    WrapExpressionFix.registerWrapAction(candidates, list.getExpressions(), highlightInfo);\n    ChangeParameterClassFix.registerQuickFixActions(methodCall, list, highlightInfo);\n    return highlightInfo;\n  }","commit_id":"804fcc24a135e3a5d6fe939084d02565262c07bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static HighlightInfo checkNewExpression(PsiNewExpression expression) {\n    PsiType type = expression.getType();\n    if (!(type instanceof PsiClassType)) return null;\n    PsiClassType.ClassResolveResult typeResult = ((PsiClassType)type).resolveGenerics();\n    PsiClass aClass = typeResult.getElement();\n    if (aClass == null) return null;\n    if (aClass instanceof PsiAnonymousClass) {\n      type = ((PsiAnonymousClass)aClass).getBaseClassType();\n      typeResult = ((PsiClassType)type).resolveGenerics();\n      aClass = typeResult.getElement();\n      if (aClass == null) return null;\n    }\n\n    return checkConstructorCall(typeResult, expression, type, expression.getClassReference());\n  }","id":34715,"modified_method":"static HighlightInfo checkNewExpression(PsiNewExpression expression) {\n    PsiType type = expression.getType();\n    if (!(type instanceof PsiClassType)) return null;\n    PsiClassType.ClassResolveResult typeResult = ((PsiClassType)type).resolveGenerics();\n    PsiClass aClass = typeResult.getElement();\n    if (aClass == null) return null;\n    if (aClass instanceof PsiAnonymousClass) {\n      type = ((PsiAnonymousClass)aClass).getBaseClassType();\n      typeResult = ((PsiClassType)type).resolveGenerics();\n      aClass = typeResult.getElement();\n      if (aClass == null) return null;\n    }\n\n    PsiJavaCodeReferenceElement classReference = expression.getClassReference();\n    if (classReference == null) {\n      PsiAnonymousClass anonymousClass = expression.getAnonymousClass();\n      if (anonymousClass != null) classReference = anonymousClass.getBaseClassReference();\n    }\n    return checkConstructorCall(typeResult, expression, type, classReference);\n  }","commit_id":"804fcc24a135e3a5d6fe939084d02565262c07bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showCell() {\n      if (getEditorsPane().getCurrentEditor() instanceof NodeEditor) {\n        NodeEditor nodeEditor = (NodeEditor) getEditorsPane().getCurrentEditor();\n        nodeEditor.getEditorComponent().changeSelection(myCell);\n      }\n    }","id":34716,"modified_method":"private void showCell() {\n      getEditorsPane().getCurrentEditor().getCurrentEditorComponent().changeSelection(myCell);\n    }","commit_id":"051b99e6953ee8fc3b064ced83c840ae75fb0794","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void update() {\n    if (!getToolsPane().isVisible(this)) {\n      return;\n    }\n    removeListeners();\n\n    if (!(getEditorsPane().getCurrentEditor() instanceof NodeEditor)) {\n      return;\n    }\n\n    myCurrentEditor = ((NodeEditor) getEditorsPane().getCurrentEditor()).getEditorComponent();\n    if (myCurrentEditor != null) myCurrentEditor.addRebuildListener(myRebuildListener);\n    myTree.rebuildTree();\n  }","id":34717,"modified_method":"public void update() {\n    if (!getToolsPane().isVisible(this)) {\n      return;\n    }\n    removeListeners();\n\n    if (!(getEditorsPane().getCurrentEditor() instanceof NodeEditor)) {\n      return;\n    }\n\n    myCurrentEditor = getEditorsPane().getCurrentEditor().getCurrentEditorComponent();\n    if (myCurrentEditor != null) myCurrentEditor.addRebuildListener(myRebuildListener);\n    myTree.rebuildTree();\n  }","commit_id":"051b99e6953ee8fc3b064ced83c840ae75fb0794","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doUpdate() {\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        String commandName = \"update editor [\" + NameUtil.shortNameFromLongName(GenericEditorUpdater.this.getClass().getName()) + \"]\";\n        CommandProcessor commandProcessor = CommandProcessor.instance();\n        if (commandProcessor.isInsideCommand()) {\n          return;\n        }\n        commandProcessor.executeCommand(new Runnable() {\n          public void run() {\n            MPSProjects projects = ApplicationComponents.getInstance().getComponent(MPSProjects.class);\n            for (MPSProject project : projects.getProjects()) {\n              if (project.getComponent(IDEProjectFrame.class) == null) continue;\n\n              EditorsPane editorsPane = project.getComponent(AbstractProjectFrame.class).getEditorsPane();\n              boolean isUpdated = false;\n              for (IEditor editor : editorsPane.getEditors()) {\n\n\n                if (editor instanceof NodeEditor) {\n\n                  NodeEditor nodeEditor = (NodeEditor) editor;                  \n                  if (updateEditor(nodeEditor.getEditorComponent())) {\n                    isUpdated = true;\n                  }\n                }\n              }\n              if (isUpdated) {\n                editorsPane.repaint();\n              }\n            }\n          }\n        }, commandName);\n      }\n    });\n  }","id":34718,"modified_method":"protected void doUpdate() {\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        String commandName = \"update editor [\" + NameUtil.shortNameFromLongName(GenericEditorUpdater.this.getClass().getName()) + \"]\";\n        CommandProcessor commandProcessor = CommandProcessor.instance();\n        if (commandProcessor.isInsideCommand()) {\n          return;\n        }\n        commandProcessor.executeCommand(new Runnable() {\n          public void run() {\n            MPSProjects projects = ApplicationComponents.getInstance().getComponent(MPSProjects.class);\n            for (MPSProject project : projects.getProjects()) {\n              if (project.getComponent(IDEProjectFrame.class) == null) continue;\n\n              EditorsPane editorsPane = project.getComponent(AbstractProjectFrame.class).getEditorsPane();\n              boolean isUpdated = false;\n              for (IEditor editor : editorsPane.getEditors()) {\n                if (updateEditor(editor.getCurrentEditorComponent())) {\n                  isUpdated = true;\n                }\n              }\n              if (isUpdated) {\n                editorsPane.repaint();\n              }\n            }\n          }\n        }, commandName);\n      }\n    });\n  }","commit_id":"051b99e6953ee8fc3b064ced83c840ae75fb0794","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void openCurrentMessageNodeIfPossible() {\n    Message selectedMessage = (Message) myList.getSelectedValue();\n    if (selectedMessage == null) return;\n    SNode node = selectedMessage.getNode();\n    if (node == null) return;\n    IOperationContext context = selectedMessage.getContext();\n    if (context == null) return;\n    AbstractEditorComponent editor = context.getComponent(EditorsPane.class).openEditor(node, context).getEditorComponent();\n    if (editor != null) {\n      if (node.isRoot()) editor.selectFirstEditableCellOf(node);\n      else editor.selectNode(node);\n    }\n  }","id":34719,"modified_method":"private void openCurrentMessageNodeIfPossible() {\n    Message selectedMessage = (Message) myList.getSelectedValue();\n    if (selectedMessage == null) return;\n    SNode node = selectedMessage.getNode();\n    if (node == null) return;\n    IOperationContext context = selectedMessage.getContext();\n    if (context == null) return;\n    AbstractEditorComponent editor = context.getComponent(EditorsPane.class).openEditor(node, context).getCurrentEditorComponent();\n    if (editor != null) {\n      if (node.isRoot()) editor.selectFirstEditableCellOf(node);\n      else editor.selectNode(node);\n    }\n  }","commit_id":"051b99e6953ee8fc3b064ced83c840ae75fb0794","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AbstractEditorComponent getEditorComponent() {\n    return myEditorComponent;\n  }","id":34720,"modified_method":"public AbstractEditorComponent getCurrentEditorComponent() {\n    return myEditorComponent;\n  }","commit_id":"051b99e6953ee8fc3b064ced83c840ae75fb0794","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Editor getCurrentEditor() {\n    return ObjectUtils.notNull(myCurrentEditor, myConsoleEditor);\n  }","id":34721,"modified_method":"@NotNull\n  public EditorEx getCurrentEditor() {\n    return ObjectUtils.notNull(myCurrentEditor, myConsoleEditor);\n  }","commit_id":"fe48a58efa1838821acd13cce6d2992b97f95b37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String prepareExecuteAction(boolean addToHistory, boolean preserveMarkup, boolean clearInput) {\n    EditorEx editor = (EditorEx)getCurrentEditor();\n    Document document = editor.getDocument();\n    String text = document.getText();\n    TextRange range = new TextRange(0, document.getTextLength());\n    if (!clearInput) {\n      editor.getSelectionModel().setSelection(range.getStartOffset(), range.getEndOffset());\n    }\n\n    if (addToHistory) {\n      addToHistoryInner(range, editor, clearInput, preserveMarkup);\n    }\n    else if (clearInput) {\n      setInputText(\"\");\n    }\n    return text;\n  }","id":34722,"modified_method":"@NotNull\n  public String prepareExecuteAction(boolean addToHistory, boolean preserveMarkup, boolean clearInput) {\n    EditorEx editor = getCurrentEditor();\n    Document document = editor.getDocument();\n    String text = document.getText();\n    TextRange range = new TextRange(0, document.getTextLength());\n    if (!clearInput) {\n      editor.getSelectionModel().setSelection(range.getStartOffset(), range.getEndOffset());\n    }\n\n    if (addToHistory) {\n      addToHistoryInner(range, editor, clearInput, preserveMarkup);\n    }\n    else if (clearInput) {\n      setInputText(\"\");\n    }\n    return text;\n  }","commit_id":"fe48a58efa1838821acd13cce6d2992b97f95b37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void modificationCountChanged() {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    final String newText = myConsole.getFile().getText();\n    if (newText.equals(myLastText)) { // If text did not changed from last time, we do nothing\n      return;\n    }\n    myLastText = newText; // Store text for next time check\n\n\n    myNextArg = null; // Reset current argument\n\n\n    myDocumentLengthInChars = newText.length();\n    final PsiFile consoleFile = myConsole.getFile();\n    // Get next arg from file\n    if (consoleFile instanceof CommandLineFile) {\n      final ValidationResult result = ((CommandLineFile)consoleFile).getValidationResult();\n      if (result != null) {\n        myNextArg = result.getNextArg();\n        repaint(); // We need to repaint us if argument changed\n      }\n    }\n  }","id":34723,"modified_method":"@Override\n  public void modificationCountChanged() {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    final String newText = myConsole.getFile().getText();\n    if (newText.equals(myLastText)) { // If text did not changed from last time, we do nothing\n      return;\n    }\n    myLastText = newText; // Store text for next time check\n\n\n    myNextArg = null; // Reset current argument\n\n\n    myDocumentLengthInChars = StringUtil.trim(newText).length();\n    final PsiFile consoleFile = myConsole.getFile();\n    // Get next arg from file\n    if (consoleFile instanceof CommandLineFile) {\n      final ValidationResult result = ((CommandLineFile)consoleFile).getValidationResult();\n      myNextArg = result != null ? result.getNextArg() : null;\n      repaint(); // We need to repaint us if argument changed\n    }\n  }","commit_id":"81fde236dde3a5b3422148fa42b76f3d53094d11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n    // TODO: Move out this logic to prevent recalculation each swing call\n\n\n    final Pair<Boolean, Argument> nextArg = myNextArg;\n    if (nextArg == null) {\n      return; // Nothing to show\n    }\n\n\n    @SuppressWarnings(\"NumericCastThatLosesPrecision\") // Y will never be > Integer.MAX_VALUE\n    final int y = ((int)Math.round(myConsole.getCurrentEditor().getComponent().getLocation().getY())) + myLineHeightPx;\n    final int spaceToRight = myCharWidthPx * SPACES_BEFORE_ARG; // Space after line end to placeholder\n    final int x = (myPromptWidthPx + (myCharWidthPx * myDocumentLengthInChars)) + spaceToRight;\n\n    final boolean required = nextArg.first;\n    final String argumentText = nextArg.second.getHelp().getHelpString();\n\n\n    g.setColor(required ? myRequiredColor : myOptionalColor);\n    final String textToShow = StringUtil.isEmpty(argumentText) ? PyBundle.message(\"commandLine.argumentHint.defaultName\") : argumentText;\n    g.drawString(wrapBracesIfNeeded(required, textToShow), x, y);\n  }","id":34724,"modified_method":"@Override\n  protected void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n    // TODO: Move out this logic to prevent recalculation each swing call\n\n\n    final Pair<Boolean, Argument> nextArg = myNextArg;\n    if (nextArg == null) {\n      return; // Nothing to show\n    }\n\n\n    final EditorEx editor = myConsole.getCurrentEditor();\n    @SuppressWarnings(\"NumericCastThatLosesPrecision\") // Y will never be > Integer.MAX_VALUE\n    final int y = ((int)Math.floor(editor.getComponent().getLocation().getY())) + myLineHeightPx - 1;\n    //1 is hack here, just to align. TODO: investigate why do we need it\n    final int spaceToRight = myCharWidthPx * SPACES_BEFORE_ARG; // Space after line end to placeholder\n\n    /**\n     * We should display argument right after document end or cursor position what ever comes first.\n     * But document length is trimmed, so in case of documents with several white spaces at the end\n     * we do not count these spaces.\n     *\n     * We also need to add prompt length.\n     */\n    final int cursorOffset = editor.getCaretModel().getOffset();\n    final int lengthInChars = Math.max(cursorOffset, myDocumentLengthInChars);\n\n    final int x = myPromptWidthPx + spaceToRight + lengthInChars * myCharWidthPx;\n\n    final boolean required = nextArg.first;\n    final String argumentText = nextArg.second.getHelp().getHelpString();\n\n\n    g.setColor(myArgumentColor);\n    final String textToShow = StringUtil.isEmpty(argumentText) ? PyBundle.message(\"commandLine.argumentHint.defaultName\") : argumentText;\n    g.drawString(wrapBracesIfNeeded(required, textToShow), x, y);\n  }","commit_id":"81fde236dde3a5b3422148fa42b76f3d53094d11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param console console to wrap\n   */\n  private ArgumentHintLayer(@NotNull final LanguageConsoleImpl console) {\n    final FontMetrics metrics = console.getFontMetrics(console.getFont());\n    myCharWidthPx = metrics.charWidth('A'); // Should be monospace\n    myLineHeightPx = metrics.getHeight();\n    final String prompt = console.getPrompt();\n    myPromptWidthPx = (prompt != null ? prompt.length() * myCharWidthPx : 0);\n    myConsole = console;\n    myDocumentLengthInChars = console.getEditorDocument().getTextLength();\n    myLastText = console.getFile().getText();\n    final EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    myRequiredColor = scheme.getAttributes(ConsoleViewContentType.ERROR_OUTPUT_KEY).getForegroundColor();\n    myOptionalColor = scheme.getAttributes(EditorColors.FOLDED_TEXT_ATTRIBUTES).getForegroundColor();\n  }","id":34725,"modified_method":"/**\n   * @param console console to wrap\n   */\n  private ArgumentHintLayer(@NotNull final LanguageConsoleImpl console) {\n    final FontMetrics metrics = console.getFontMetrics(console.getFont());\n    myCharWidthPx = metrics.charWidth('A'); // Should be monospace\n    myLineHeightPx = metrics.getHeight();\n    final String prompt = console.getPrompt();\n    myPromptWidthPx = (prompt != null ? prompt.length() * myCharWidthPx : 0);\n    myConsole = console;\n    myDocumentLengthInChars = console.getEditorDocument().getTextLength();\n    myLastText = console.getFile().getText();\n    final EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    myArgumentColor = scheme.getAttributes(EditorColors.FOLDED_TEXT_ATTRIBUTES).getForegroundColor();\n  }","commit_id":"81fde236dde3a5b3422148fa42b76f3d53094d11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Initialize the container\n     *\n     * @param args       args from calling class\n     * @param configFile Location of master OFBiz configuration file\n     * @throws org.ofbiz.base.container.ContainerException\n     *\n     */\n    public void init(String[] args, String configFile) throws ContainerException {\n        this.configFile = configFile;       \n        this.stores = new LinkedHashMap();\n        this.pollTimer = new Timer();\n    }","id":34726,"modified_method":"/**\n     * Initialize the container\n     *\n     * @param args       args from calling class\n     * @param configFile Location of master OFBiz configuration file\n     * @throws org.ofbiz.base.container.ContainerException\n     *\n     */\n    public void init(String[] args, String configFile) throws ContainerException {\n        this.configFile = configFile;       \n        this.stores = new LinkedHashMap<Store, Session>();\n        this.pollTimer = new Timer();\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"public void run() {\n            if (stores != null && stores.size() > 0) {\n                Iterator i = stores.keySet().iterator();\n                while (i.hasNext()) {\n                    Store store = (Store) i.next();\n                    Session session = (Session) stores.get(store);\n                    try {\n                        checkMessages(store, session);\n                    } catch (GeneralException e) {\n                        Debug.logError(e, \"Mail service invocation error\", module);\n                    } catch (MessagingException e) {\n                        Debug.logError(e, \"Mail message error\", module);\n                    }\n                }\n            }\n        }","id":34727,"modified_method":"public void run() {\n            if (stores != null && stores.size() > 0) {\n                for (Map.Entry<Store, Session> entry: stores.entrySet()) {\n                    Store store = entry.getKey();\n                    Session session = entry.getValue();\n                    try {\n                        checkMessages(store, session);\n                    } catch (GeneralException e) {\n                        Debug.logError(e, \"Mail service invocation error\", module);\n                    } catch (MessagingException e) {\n                        Debug.logError(e, \"Mail message error\", module);\n                    }\n                }\n            }\n        }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"protected void checkMessages(Store store, Session session) throws MessagingException, GeneralException {\n            store.connect();\n\n            // open the default folder\n            Folder folder = store.getDefaultFolder();\n            if (folder == null) {\n                throw new MessagingException(\"No default folder available\");\n            }\n\n            // open the inbox\n            folder = folder.getFolder(INBOX);\n            if (folder == null) {\n                throw new MessagingException(\"No INBOX folder available\");\n            }\n\n            // get the message count; stop if nothing to do\n            folder.open(Folder.READ_WRITE);\n            int totalMessages = folder.getMessageCount();\n            if (totalMessages == 0) {\n                folder.close(false);\n                store.close();\n                return;\n            }\n\n            // get all messages\n            Message[] messages = folder.getMessages();\n            FetchProfile profile = new FetchProfile();\n            profile.add(FetchProfile.Item.ENVELOPE);\n            profile.add(FetchProfile.Item.FLAGS);\n            profile.add(\"X-Mailer\");\n            folder.fetch(messages, profile);\n\n            // process each message\n            for (int i = 0; i < messages.length; i++) {\n                // process each un-read message\n            \tif (!messages[i].isSet(Flags.Flag.SEEN)) {\n            \t\tlong messageSize = messages[i].getSize();\n            \t\tif (messages[i] instanceof MimeMessage && messageSize >= maxSize) {\n            \t\t\tDebug.logWarning(\"Message from: \" + messages[i].getFrom()[0] + \"not received, too big, size:\" + messageSize + \" cannot be more than \" + maxSize + \" bytes\", module);\n            \t\t} else {\n            \t\t\tthis.processMessage(messages[i], session);\n            \t\t\tif (Debug.verboseOn()) Debug.logVerbose(\"Message from \" + UtilMisc.toListArray(messages[i].getFrom()) + \" with subject [\" + messages[i].getSubject() + \"]  has been processed.\" , module);\n            \t\t\tmessages[i].setFlag(Flags.Flag.SEEN, true);\n            \t\t\tif (Debug.verboseOn()) Debug.logVerbose(\"Message [\" + messages[i].getSubject() + \"] is marked seen\", module);\n            \t\t}\n            \t}\n            \tif (deleteMail) {\n            \t\tif (Debug.verboseOn()) Debug.logVerbose(\"Message [\" + messages[i].getSubject() + \"] is being deleted\", module);\n            \t\tmessages[i].setFlag(Flags.Flag.DELETED, true);\n            \t}\n            }\n\n            // expunge and close the folder\n            folder.close(true);\n            store.close();\n        }","id":34728,"modified_method":"protected void checkMessages(Store store, Session session) throws MessagingException, GeneralException {\n            store.connect();\n\n            // open the default folder\n            Folder folder = store.getDefaultFolder();\n            if (folder == null) {\n                throw new MessagingException(\"No default folder available\");\n            }\n\n            // open the inbox\n            folder = folder.getFolder(INBOX);\n            if (folder == null) {\n                throw new MessagingException(\"No INBOX folder available\");\n            }\n\n            // get the message count; stop if nothing to do\n            folder.open(Folder.READ_WRITE);\n            int totalMessages = folder.getMessageCount();\n            if (totalMessages == 0) {\n                folder.close(false);\n                store.close();\n                return;\n            }\n\n            // get all messages\n            Message[] messages = folder.getMessages();\n            FetchProfile profile = new FetchProfile();\n            profile.add(FetchProfile.Item.ENVELOPE);\n            profile.add(FetchProfile.Item.FLAGS);\n            profile.add(\"X-Mailer\");\n            folder.fetch(messages, profile);\n\n            // process each message\n            for (Message message: messages) {\n                // process each un-read message\n            \tif (!message.isSet(Flags.Flag.SEEN)) {\n            \t\tlong messageSize = message.getSize();\n            \t\tif (message instanceof MimeMessage && messageSize >= maxSize) {\n            \t\t\tDebug.logWarning(\"Message from: \" + message.getFrom()[0] + \"not received, too big, size:\" + messageSize + \" cannot be more than \" + maxSize + \" bytes\", module);\n            \t\t} else {\n            \t\t\tthis.processMessage(message, session);\n            \t\t\tif (Debug.verboseOn()) Debug.logVerbose(\"Message from \" + UtilMisc.toListArray(message.getFrom()) + \" with subject [\" + message.getSubject() + \"]  has been processed.\" , module);\n            \t\t\tmessage.setFlag(Flags.Flag.SEEN, true);\n            \t\t\tif (Debug.verboseOn()) Debug.logVerbose(\"Message [\" + message.getSubject() + \"] is marked seen\", module);\n            \t\t}\n            \t}\n            \tif (deleteMail) {\n            \t\tif (Debug.verboseOn()) Debug.logVerbose(\"Message [\" + message.getSubject() + \"] is being deleted\", module);\n            \t\tmessage.setFlag(Flags.Flag.DELETED, true);\n            \t}\n            }\n\n            // expunge and close the folder\n            folder.close(true);\n            store.close();\n        }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Close all the JMS message listeners.\n     * @throws GenericServiceException\n     */\n    public void closeListeners() throws GenericServiceException {\n        loadable = 0;\n        Set listenerKeys = listeners.keySet();\n        Iterator listenerIterator = listenerKeys.iterator();\n        while (listenerIterator.hasNext()) {\n            String serverKey = (String) listenerIterator.next();\n            closeListener(serverKey);\n        }\n    }","id":34729,"modified_method":"/**\n     * Close all the JMS message listeners.\n     * @throws GenericServiceException\n     */\n    public void closeListeners() throws GenericServiceException {\n        loadable = 0;\n        for (String serverKey: listeners.keySet()) {\n            closeListener(serverKey);\n        }\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"private GenericMessageListener loadListener(String serverKey, Element server) throws GenericServiceException {\n        String serverName = server.getAttribute(\"jndi-server-name\");\n        String jndiName = server.getAttribute(\"jndi-name\");\n        String queueName = server.getAttribute(\"topic-queue\");\n        String type = server.getAttribute(\"type\");\n        String userName = server.getAttribute(\"username\");\n        String password = server.getAttribute(\"password\");\n        String className = server.getAttribute(\"listener-class\");\n\n        if (className == null || className.length() == 0) {\n            if (type.equals(\"topic\"))\n                className = JmsListenerFactory.TOPIC_LISTENER_CLASS;\n            else if (type.equals(\"queue\"))\n                className = JmsListenerFactory.QUEUE_LISTENER_CLASS;\n        }\n\n        GenericMessageListener listener = (GenericMessageListener) listeners.get(serverKey);\n\n        if (listener == null) {\n            synchronized (this) {\n                listener = (GenericMessageListener) listeners.get(serverKey);\n                if (listener == null) {\n                    ClassLoader cl = this.getClass().getClassLoader();\n\n                    try {\n                        Class<?> c = cl.loadClass(className);\n                        Constructor cn = c.getConstructor(ServiceDispatcher.class, String.class, String.class, String.class, String.class, String.class);\n\n                        listener = (GenericMessageListener) cn.newInstance(dispatcher, serverName, jndiName, queueName, userName, password);\n                    } catch (Exception e) {\n                        throw new GenericServiceException(e.getMessage(), e);\n                    }\n                    if (listener != null)\n                        listeners.put(serverKey, listener);\n                    loadable++;\n                }\n            }\n\n        }\n        if (listener != null && !listener.isConnected()) {\n            listener.load();\n            if (listener.isConnected())\n                connected++;\n        }\n        return listener;\n    }","id":34730,"modified_method":"private GenericMessageListener loadListener(String serverKey, Element server) throws GenericServiceException {\n        String serverName = server.getAttribute(\"jndi-server-name\");\n        String jndiName = server.getAttribute(\"jndi-name\");\n        String queueName = server.getAttribute(\"topic-queue\");\n        String type = server.getAttribute(\"type\");\n        String userName = server.getAttribute(\"username\");\n        String password = server.getAttribute(\"password\");\n        String className = server.getAttribute(\"listener-class\");\n\n        if (className == null || className.length() == 0) {\n            if (type.equals(\"topic\"))\n                className = JmsListenerFactory.TOPIC_LISTENER_CLASS;\n            else if (type.equals(\"queue\"))\n                className = JmsListenerFactory.QUEUE_LISTENER_CLASS;\n        }\n\n        GenericMessageListener listener = listeners.get(serverKey);\n\n        if (listener == null) {\n            synchronized (this) {\n                listener = listeners.get(serverKey);\n                if (listener == null) {\n                    ClassLoader cl = this.getClass().getClassLoader();\n\n                    try {\n                        Class<?> c = cl.loadClass(className);\n                        Constructor cn = c.getConstructor(ServiceDispatcher.class, String.class, String.class, String.class, String.class, String.class);\n\n                        listener = (GenericMessageListener) cn.newInstance(dispatcher, serverName, jndiName, queueName, userName, password);\n                    } catch (Exception e) {\n                        throw new GenericServiceException(e.getMessage(), e);\n                    }\n                    if (listener != null)\n                        listeners.put(serverKey, listener);\n                    loadable++;\n                }\n            }\n\n        }\n        if (listener != null && !listener.isConnected()) {\n            listener.load();\n            if (listener.isConnected())\n                connected++;\n        }\n        return listener;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Refresh a JMS message listener.\n     * @param serverKey Name of the jms-service\n     * @throws GenericServiceException\n     */\n    public void refreshListener(String serverKey) throws GenericServiceException {\n        GenericMessageListener listener = (GenericMessageListener) listeners.get(serverKey);\n\n        if (listener == null)\n            throw new GenericServiceException(\"No listener found with that serverKey.\");\n        listener.refresh();\n    }","id":34731,"modified_method":"/**\n     * Refresh a JMS message listener.\n     * @param serverKey Name of the jms-service\n     * @throws GenericServiceException\n     */\n    public void refreshListener(String serverKey) throws GenericServiceException {\n        GenericMessageListener listener = listeners.get(serverKey);\n\n        if (listener == null)\n            throw new GenericServiceException(\"No listener found with that serverKey.\");\n        listener.refresh();\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Close a JMS message listener.\n     * @param serverKey Name of the jms-service\n     * @throws GenericServiceException\n     */\n    public void closeListener(String serverKey) throws GenericServiceException {\n        GenericMessageListener listener = (GenericMessageListener) listeners.get(serverKey);\n\n        if (listener == null)\n            throw new GenericServiceException(\"No listener found with that serverKey.\");\n        listener.close();\n    }","id":34732,"modified_method":"/**\n     * Close a JMS message listener.\n     * @param serverKey Name of the jms-service\n     * @throws GenericServiceException\n     */\n    public void closeListener(String serverKey) throws GenericServiceException {\n        GenericMessageListener listener = listeners.get(serverKey);\n\n        if (listener == null)\n            throw new GenericServiceException(\"No listener found with that serverKey.\");\n        listener.close();\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Load a JMS message listener.\n     * @param serverKey Name of the jms-service\n     * @throws GenericServiceException\n     */\n    public void loadListener(String serverKey) throws GenericServiceException {\n        Element server = (Element) servers.get(serverKey);\n\n        if (server == null)\n            throw new GenericServiceException(\"No listener found with that serverKey.\");\n        loadListener(serverKey, server);\n    }","id":34733,"modified_method":"/**\n     * Load a JMS message listener.\n     * @param serverKey Name of the jms-service\n     * @throws GenericServiceException\n     */\n    public void loadListener(String serverKey) throws GenericServiceException {\n        Element server = servers.get(serverKey);\n\n        if (server == null)\n            throw new GenericServiceException(\"No listener found with that serverKey.\");\n        loadListener(serverKey, server);\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"protected Message makeMessage(Session session, ModelService modelService, Map context)\n        throws GenericServiceException, JMSException {\n        List outParams = modelService.getParameterNames(ModelService.OUT_PARAM, false);\n\n        if (outParams != null && outParams.size() > 0)\n            throw new GenericServiceException(\"JMS service cannot have required OUT parameters; no parameters will be returned.\");\n        String xmlContext = null;\n\n        try {\n            if (Debug.verboseOn()) Debug.logVerbose(\"Serializing Context --> \" + context, module);\n            xmlContext = XmlSerializer.serialize(context);\n        } catch (Exception e) {\n            throw new GenericServiceException(\"Cannot serialize context.\", e);\n        }\n        MapMessage message = session.createMapMessage();\n\n        message.setString(\"serviceName\", modelService.invoke);\n        message.setString(\"serviceContext\", xmlContext);\n        return message;\n    }","id":34734,"modified_method":"protected Message makeMessage(Session session, ModelService modelService, Map context)\n        throws GenericServiceException, JMSException {\n        List<String> outParams = modelService.getParameterNames(ModelService.OUT_PARAM, false);\n\n        if (outParams != null && outParams.size() > 0)\n            throw new GenericServiceException(\"JMS service cannot have required OUT parameters; no parameters will be returned.\");\n        String xmlContext = null;\n\n        try {\n            if (Debug.verboseOn()) Debug.logVerbose(\"Serializing Context --> \" + context, module);\n            xmlContext = XmlSerializer.serialize(context);\n        } catch (Exception e) {\n            throw new GenericServiceException(\"Cannot serialize context.\", e);\n        }\n        MapMessage message = session.createMapMessage();\n\n        message.setString(\"serviceName\", modelService.invoke);\n        message.setString(\"serviceContext\", xmlContext);\n        return message;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"protected Map run(ModelService modelService, Map context) throws GenericServiceException {\n        Element serviceElement = getServiceElement(modelService);\n        List serverList = serverList(serviceElement);\n\n        Map result = FastMap.newInstance();\n        Iterator i = serverList.iterator();\n\n        while (i.hasNext()) {\n            Element server = (Element) i.next();\n            String serverType = server.getAttribute(\"type\");\n\n            if (serverType.equals(\"topic\"))\n                result.putAll(runTopic(modelService, context, server));\n            else if (serverType.equals(\"queue\"))\n                result.putAll(runQueue(modelService, context, server));\n            else\n                throw new GenericServiceException(\"Illegal server messaging type.\");\n        }\n        return result;\n    }","id":34735,"modified_method":"protected Map run(ModelService modelService, Map context) throws GenericServiceException {\n        Element serviceElement = getServiceElement(modelService);\n        List<? extends Element> serverList = serverList(serviceElement);\n\n        Map result = FastMap.newInstance();\n        for (Element server: serverList) {\n            String serverType = server.getAttribute(\"type\");\n\n            if (serverType.equals(\"topic\"))\n                result.putAll(runTopic(modelService, context, server));\n            else if (serverType.equals(\"queue\"))\n                result.putAll(runQueue(modelService, context, server));\n            else\n                throw new GenericServiceException(\"Illegal server messaging type.\");\n        }\n        return result;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"public synchronized Iterator poll() {\n        List poll = FastList.newInstance();\n        Collection<GenericValue> jobEnt = null;\n\n        // sort the results by time\n        List<String> order = UtilMisc.toList(\"runTime\");\n\n        // basic query\n        List<EntityExpr> expressions = UtilMisc.toList(new EntityExpr(\"runTime\", EntityOperator.LESS_THAN_EQUAL_TO,\n                UtilDateTime.nowTimestamp()), new EntityExpr(\"startDateTime\", EntityOperator.EQUALS, null),\n                new EntityExpr(\"cancelDateTime\", EntityOperator.EQUALS, null),\n                new EntityExpr(\"runByInstanceId\", EntityOperator.EQUALS, null));\n\n        // limit to just defined pools\n        List pools = ServiceConfigUtil.getRunPools();\n        List<EntityExpr> poolsExpr = UtilMisc.toList(new EntityExpr(\"poolId\", EntityOperator.EQUALS, null));\n        if (pools != null) {\n            Iterator poolsIter = pools.iterator();\n            while (poolsIter.hasNext()) {\n                String poolName = (String) poolsIter.next();\n                poolsExpr.add(new EntityExpr(\"poolId\", EntityOperator.EQUALS, poolName));\n            }\n        }\n\n        // make the conditions\n        EntityCondition baseCondition = new EntityConditionList<EntityExpr>(expressions, EntityOperator.AND);\n        EntityCondition poolCondition = new EntityConditionList<EntityExpr>(poolsExpr, EntityOperator.OR);\n        EntityCondition mainCondition = new EntityConditionList<EntityCondition>(UtilMisc.toList(baseCondition, poolCondition), EntityOperator.AND);\n\n        // we will loop until we have no more to do\n        boolean pollDone = false;\n\n        while (!pollDone) {\n            boolean beganTransaction = false;\n\n            try {\n                beganTransaction = TransactionUtil.begin();\n                if (!beganTransaction) {\n                    Debug.logError(\"Unable to poll for jobs; transaction was not started by this process\", module);\n                    return null;\n                }\n                \n                List localPoll = FastList.newInstance();\n                \n                // first update the jobs w/ this instance running information\n                delegator.storeByCondition(\"JobSandbox\", updateFields, mainCondition);\n\n                // now query all the 'queued' jobs for this instance\n                jobEnt = delegator.findByAnd(\"JobSandbox\", updateFields, order);\n                //jobEnt = delegator.findByCondition(\"JobSandbox\", mainCondition, null, order);\n\n                if (jobEnt != null && jobEnt.size() > 0) {\n                    for (GenericValue v: jobEnt) {\n                        DispatchContext dctx = getDispatcher().getDispatchContext();\n                        if (dctx == null) {\n                            Debug.logError(\"Unable to locate DispatchContext object; not running job!\", module);\n                            continue;\n                        }\n                        Job job = new PersistedServiceJob(dctx, v, null); // TODO fix the requester\n                        try {\n                            job.queue();\n                            localPoll.add(job);\n                        } catch (InvalidJobException e) {\n                            Debug.logError(e, module);\n                        }\n                    }\n                } else {\n                    pollDone = true;\n                }\n                \n                // nothing should go wrong at this point, so add to the general list\n                poll.addAll(localPoll);\n            } catch (Throwable t) {\n                // catch Throwable so nothing slips through the cracks... this is a fairly sensitive operation\n                String errMsg = \"Error in polling JobSandbox: [\" + t.toString() + \"]. Rolling back transaction.\";\n                Debug.logError(t, errMsg, module);\n                try {\n                    // only rollback the transaction if we started one...\n                    TransactionUtil.rollback(beganTransaction, errMsg, t);\n                } catch (GenericEntityException e2) {\n                    Debug.logError(e2, \"[GenericDelegator] Could not rollback transaction: \" + e2.toString(), module);\n                }\n            } finally {\n                try {\n                    // only commit the transaction if we started one... but make sure we try\n                    TransactionUtil.commit(beganTransaction);\n                } catch (GenericTransactionException e) {\n                    String errMsg = \"Transaction error trying to commit when polling and updating the JobSandbox: \" + e.toString();\n                    // we don't really want to do anything different, so just log and move on\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n        }\n        return poll.iterator();\n    }","id":34736,"modified_method":"public synchronized Iterator<Job> poll() {\n        List<Job> poll = FastList.newInstance();\n        Collection<GenericValue> jobEnt = null;\n\n        // sort the results by time\n        List<String> order = UtilMisc.toList(\"runTime\");\n\n        // basic query\n        List<EntityExpr> expressions = UtilMisc.toList(new EntityExpr(\"runTime\", EntityOperator.LESS_THAN_EQUAL_TO,\n                UtilDateTime.nowTimestamp()), new EntityExpr(\"startDateTime\", EntityOperator.EQUALS, null),\n                new EntityExpr(\"cancelDateTime\", EntityOperator.EQUALS, null),\n                new EntityExpr(\"runByInstanceId\", EntityOperator.EQUALS, null));\n\n        // limit to just defined pools\n        List<String> pools = ServiceConfigUtil.getRunPools();\n        List<EntityExpr> poolsExpr = UtilMisc.toList(new EntityExpr(\"poolId\", EntityOperator.EQUALS, null));\n        if (pools != null) {\n            for (String poolName: pools) {\n                poolsExpr.add(new EntityExpr(\"poolId\", EntityOperator.EQUALS, poolName));\n            }\n        }\n\n        // make the conditions\n        EntityCondition baseCondition = new EntityConditionList<EntityExpr>(expressions, EntityOperator.AND);\n        EntityCondition poolCondition = new EntityConditionList<EntityExpr>(poolsExpr, EntityOperator.OR);\n        EntityCondition mainCondition = new EntityConditionList<EntityCondition>(UtilMisc.toList(baseCondition, poolCondition), EntityOperator.AND);\n\n        // we will loop until we have no more to do\n        boolean pollDone = false;\n\n        while (!pollDone) {\n            boolean beganTransaction = false;\n\n            try {\n                beganTransaction = TransactionUtil.begin();\n                if (!beganTransaction) {\n                    Debug.logError(\"Unable to poll for jobs; transaction was not started by this process\", module);\n                    return null;\n                }\n                \n                List<Job> localPoll = FastList.newInstance();\n                \n                // first update the jobs w/ this instance running information\n                delegator.storeByCondition(\"JobSandbox\", updateFields, mainCondition);\n\n                // now query all the 'queued' jobs for this instance\n                jobEnt = delegator.findByAnd(\"JobSandbox\", updateFields, order);\n                //jobEnt = delegator.findByCondition(\"JobSandbox\", mainCondition, null, order);\n\n                if (jobEnt != null && jobEnt.size() > 0) {\n                    for (GenericValue v: jobEnt) {\n                        DispatchContext dctx = getDispatcher().getDispatchContext();\n                        if (dctx == null) {\n                            Debug.logError(\"Unable to locate DispatchContext object; not running job!\", module);\n                            continue;\n                        }\n                        Job job = new PersistedServiceJob(dctx, v, null); // TODO fix the requester\n                        try {\n                            job.queue();\n                            localPoll.add(job);\n                        } catch (InvalidJobException e) {\n                            Debug.logError(e, module);\n                        }\n                    }\n                } else {\n                    pollDone = true;\n                }\n                \n                // nothing should go wrong at this point, so add to the general list\n                poll.addAll(localPoll);\n            } catch (Throwable t) {\n                // catch Throwable so nothing slips through the cracks... this is a fairly sensitive operation\n                String errMsg = \"Error in polling JobSandbox: [\" + t.toString() + \"]. Rolling back transaction.\";\n                Debug.logError(t, errMsg, module);\n                try {\n                    // only rollback the transaction if we started one...\n                    TransactionUtil.rollback(beganTransaction, errMsg, t);\n                } catch (GenericEntityException e2) {\n                    Debug.logError(e2, \"[GenericDelegator] Could not rollback transaction: \" + e2.toString(), module);\n                }\n            } finally {\n                try {\n                    // only commit the transaction if we started one... but make sure we try\n                    TransactionUtil.commit(beganTransaction);\n                } catch (GenericTransactionException e) {\n                    String errMsg = \"Transaction error trying to commit when polling and updating the JobSandbox: \" + e.toString();\n                    // we don't really want to do anything different, so just log and move on\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n        }\n        return poll.iterator();\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Returns the next job to run\n     */\n    public synchronized Job next() {\n        if (run.size() > 0)\n            return (Job) run.removeFirst();\n        return null;\n    }","id":34737,"modified_method":"/**\n     * Returns the next job to run\n     */\n    public synchronized Job next() {\n        if (run.size() > 0)\n            return run.removeFirst();\n        return null;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Stops all threads in the threadPool and clears\n     * the pool as final step.\n     */\n    private void destroyThreadPool() {\n        Debug.logInfo(\"Destroying thread pool...\", module);\n        Iterator it = pool.iterator();\n        while (it.hasNext()) {\n            JobInvoker ji = (JobInvoker) it.next();\n            ji.stop();\n        }\n        pool.clear();\n    }","id":34738,"modified_method":"/**\n     * Stops all threads in the threadPool and clears\n     * the pool as final step.\n     */\n    private void destroyThreadPool() {\n        Debug.logInfo(\"Destroying thread pool...\", module);\n        for (JobInvoker ji: pool) {\n            ji.stop();\n        }\n        pool.clear();\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"public List getPoolState() {\n        List stateList = new ArrayList();\n        Iterator i = this.pool.iterator();\n        while (i.hasNext()) {\n            JobInvoker invoker = (JobInvoker) i.next();\n            Map stateMap = FastMap.newInstance();\n            stateMap.put(\"threadName\", invoker.getName());\n            stateMap.put(\"jobName\", invoker.getJobName());\n            stateMap.put(\"serviceName\", invoker.getServiceName());\n            stateMap.put(\"runTime\", Long.valueOf(invoker.getCurrentRuntime()));\n            stateMap.put(\"status\", Integer.valueOf(invoker.getCurrentStatus()));\n            stateList.add(stateMap);\n        }\n        return stateList;\n    }","id":34739,"modified_method":"public List<Map<String, Object>> getPoolState() {\n        List<Map<String, Object>> stateList = new ArrayList<Map<String, Object>>();\n        for (JobInvoker invoker: this.pool) {\n            Map<String, Object> stateMap = FastMap.newInstance();\n            stateMap.put(\"threadName\", invoker.getName());\n            stateMap.put(\"jobName\", invoker.getJobName());\n            stateMap.put(\"serviceName\", invoker.getServiceName());\n            stateMap.put(\"runTime\", Long.valueOf(invoker.getCurrentRuntime()));\n            stateMap.put(\"status\", Integer.valueOf(invoker.getCurrentStatus()));\n            stateList.add(stateMap);\n        }\n        return stateList;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Creates a new JobScheduler\n     * @param jm JobManager associated with this scheduler\n     */\n    public JobPoller(JobManager jm, boolean enabled) {\n        this.jm = jm;\n        this.run = new LinkedList();\n\n        // create the thread pool\n        this.pool = createThreadPool();\n\n        if (enabled) {\n            // re-load crashed jobs\n            this.jm.reloadCrashedJobs();\n\n            // start the thread only if polling is enabled\n            if (pollEnabled()) {\n\n                // create the poller thread\n                thread = new Thread(this, this.toString());\n                thread.setDaemon(false);\n\n                // start the poller\n                this.isRunning = true;\n                thread.start();\n            }\n        }\n    }","id":34740,"modified_method":"/**\n     * Creates a new JobScheduler\n     * @param jm JobManager associated with this scheduler\n     */\n    public JobPoller(JobManager jm, boolean enabled) {\n        this.jm = jm;\n        this.run = new LinkedList<Job>();\n\n        // create the thread pool\n        this.pool = createThreadPool();\n\n        if (enabled) {\n            // re-load crashed jobs\n            this.jm.reloadCrashedJobs();\n\n            // start the thread only if polling is enabled\n            if (pollEnabled()) {\n\n                // create the poller thread\n                thread = new Thread(this, this.toString());\n                thread.setDaemon(false);\n\n                // start the poller\n                this.isRunning = true;\n                thread.start();\n            }\n        }\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"private LinkedList createThreadPool() {\n        LinkedList threadPool = new LinkedList();\n\n        while (threadPool.size() < minThreads()) {\n            JobInvoker iv = new JobInvoker(this, invokerWaitTime());\n            threadPool.add(iv);\n        }\n\n        return threadPool;\n    }","id":34741,"modified_method":"private LinkedList<JobInvoker> createThreadPool() {\n        LinkedList<JobInvoker> threadPool = new LinkedList<JobInvoker>();\n\n        while (threadPool.size() < minThreads()) {\n            JobInvoker iv = new JobInvoker(this, invokerWaitTime());\n            threadPool.add(iv);\n        }\n\n        return threadPool;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"private JobInvoker findThread(String threadName) {\n        Iterator i = this.pool.iterator();\n        while (i.hasNext()) {\n            JobInvoker inv = (JobInvoker) i.next();\n            if (threadName.equals(inv.getName())) {\n                return inv;\n            }\n        }\n        return null;\n    }","id":34742,"modified_method":"private JobInvoker findThread(String threadName) {\n        for (JobInvoker inv: pool) {\n            if (threadName.equals(inv.getName())) {\n                return inv;\n            }\n        }\n        return null;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"private Map serviceInvoker(ModelService modelService, Map context) throws GenericServiceException {\n        if (modelService.location == null || modelService.invoke == null)\n            throw new GenericServiceException(\"Cannot locate service to invoke\");\n        \n        Service service = null;\n        Call call = null;\n        \n        try {\n            service = new Service();\n            call = (Call) service.createCall();\n        } catch (javax.xml.rpc.JAXRPCException e) {\n            throw new GenericServiceException(\"RPC service error\", e);\n        } catch (ServiceException e) {//Add by Andy.Chen 2003.01.15\n            throw new GenericServiceException(\"RPC service error\", e);\n        }\n        \n        URL endPoint = null;\n        \n        try {\n            endPoint = new URL(this.getLocation(modelService));\n        } catch (MalformedURLException e) {\n            throw new GenericServiceException(\"Location not a valid URL\", e);\n        }\n        \n        List inModelParamList = modelService.getInModelParamList();\n        Object[] params = new Object[inModelParamList.size()];\n        \n        if (Debug.infoOn()) Debug.logInfo(\"[SOAPClientEngine.invoke] : Parameter length - \" + params.length, module);\n        \n        call.setTargetEndpointAddress(endPoint);\n        \n        if (UtilValidate.isNotEmpty(modelService.nameSpace)){\n            call.setOperationName(new QName(modelService.nameSpace, modelService.invoke));\n        } else {\n            call.setOperationName(modelService.invoke);\n        }\n        \n        int i = 0;\n        \n        call.setOperation(call.getOperationName().getLocalPart());\n        List vParams = new ArrayList();\n        Iterator iter = inModelParamList.iterator();\n        while (iter.hasNext()) {\n            ModelParam p = (ModelParam) iter.next();\n            \n            if (Debug.infoOn()) Debug.logInfo(\"[SOAPClientEngine.invoke} : Parameter: \" + p.name + \" (\" + p.mode + \") - \" + i, module);\n            \n            //Exclude params that ModelServiceReader insert into\n            if(!p.name.trim().equals(\"userLogin\") && !p.name.trim().equals(\"locale\")) {\n                QName qName = call.getParameterTypeByName(p.name); //.getTypeMapping().getTypeQName((Class) ObjectType.classNameClassMap.get(p.type));\n                call.addParameter(p.name, qName, getMode(p.mode));\n                vParams.add(context.get(p.name));\n            }\n            \n            // if the value is null, that's fine, it will go in null...\n            params[i] = context.get(p.name);\n            \n            i++;\n        }\n        \n        call.setReturnType(XMLType.XSD_ANYTYPE);\n        params=vParams.toArray();\n        \n        Object result = null;\n        \n        try {\n            Debug.logInfo(\"[SOAPClientEngine.invoke] : Sending Call To SOAP Server\", module);\n            result = call.invoke(params);\n        } catch (java.rmi.RemoteException e) {\n            throw new GenericServiceException(\"RPC error\", e);\n        }\n        if (Debug.verboseOn()) {\n            Debug.log(\"SOAP Service Result - \" + result, module);\n        }\n\n        return getResponseParams(call.getMessageContext().getResponseMessage());\n    }","id":34743,"modified_method":"private Map serviceInvoker(ModelService modelService, Map context) throws GenericServiceException {\n        if (modelService.location == null || modelService.invoke == null)\n            throw new GenericServiceException(\"Cannot locate service to invoke\");\n        \n        Service service = null;\n        Call call = null;\n        \n        try {\n            service = new Service();\n            call = (Call) service.createCall();\n        } catch (javax.xml.rpc.JAXRPCException e) {\n            throw new GenericServiceException(\"RPC service error\", e);\n        } catch (ServiceException e) {//Add by Andy.Chen 2003.01.15\n            throw new GenericServiceException(\"RPC service error\", e);\n        }\n        \n        URL endPoint = null;\n        \n        try {\n            endPoint = new URL(this.getLocation(modelService));\n        } catch (MalformedURLException e) {\n            throw new GenericServiceException(\"Location not a valid URL\", e);\n        }\n        \n        List<ModelParam> inModelParamList = modelService.getInModelParamList();\n        \n        if (Debug.infoOn()) Debug.logInfo(\"[SOAPClientEngine.invoke] : Parameter length - \" + inModelParamList.size(), module);\n        \n        call.setTargetEndpointAddress(endPoint);\n        \n        if (UtilValidate.isNotEmpty(modelService.nameSpace)){\n            call.setOperationName(new QName(modelService.nameSpace, modelService.invoke));\n        } else {\n            call.setOperationName(modelService.invoke);\n        }\n        \n        int i = 0;\n        \n        call.setOperation(call.getOperationName().getLocalPart());\n        List<Object> vParams = new ArrayList<Object>();\n        for (ModelParam p: inModelParamList) {\n            if (Debug.infoOn()) Debug.logInfo(\"[SOAPClientEngine.invoke} : Parameter: \" + p.name + \" (\" + p.mode + \") - \" + i, module);\n            \n            //Exclude params that ModelServiceReader insert into\n            if(!p.name.trim().equals(\"userLogin\") && !p.name.trim().equals(\"locale\")) {\n                QName qName = call.getParameterTypeByName(p.name); //.getTypeMapping().getTypeQName((Class) ObjectType.classNameClassMap.get(p.type));\n                call.addParameter(p.name, qName, getMode(p.mode));\n                vParams.add(context.get(p.name));\n            }\n            i++;\n        }\n        \n        call.setReturnType(XMLType.XSD_ANYTYPE);\n        Object[] params=vParams.toArray(new Object[vParams.size()]);\n        \n        Object result = null;\n        \n        try {\n            Debug.logInfo(\"[SOAPClientEngine.invoke] : Sending Call To SOAP Server\", module);\n            result = call.invoke(params);\n        } catch (java.rmi.RemoteException e) {\n            throw new GenericServiceException(\"RPC error\", e);\n        }\n        if (Debug.verboseOn()) {\n            Debug.log(\"SOAP Service Result - \" + result, module);\n        }\n\n        return getResponseParams(call.getMessageContext().getResponseMessage());\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"protected String[] getFieldValue(MimeMessage message, String fieldName) throws MessagingException, IOException {\n        String[] values = null;\n        if (\"to\".equals(fieldName)) {\n            Address[] addrs = message.getRecipients(MimeMessage.RecipientType.TO);\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"cc\".equals(fieldName)) {\n            Address[] addrs = message.getRecipients(MimeMessage.RecipientType.CC);\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"bcc\".equals(fieldName)) {\n            Address[] addrs = message.getRecipients(MimeMessage.RecipientType.BCC);\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"from\".equals(fieldName)) {\n            Address[] addrs = message.getFrom();\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"subject\".equals(fieldName)) {\n            values = new String[1];\n            values[0] = message.getSubject();\n        } else if (\"send-date\".equals(fieldName)) {\n            values = new String[1];\n            values[0] = message.getSentDate().toString();\n        } else if (\"received-date\".equals(fieldName)) {\n            values = new String[1];\n            values[0] = message.getReceivedDate().toString();\n        } else if (\"body\".equals(fieldName)) {\n            List bodyParts = this.getBodyText(message);\n            values = new String[bodyParts.size()];\n            for (int i = 0; i < bodyParts.size(); i++) {\n                values[i] = (String) bodyParts.get(i);\n            }\n        }\n        return values;\n    }","id":34744,"modified_method":"protected String[] getFieldValue(MimeMessage message, String fieldName) throws MessagingException, IOException {\n        String[] values = null;\n        if (\"to\".equals(fieldName)) {\n            Address[] addrs = message.getRecipients(MimeMessage.RecipientType.TO);\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"cc\".equals(fieldName)) {\n            Address[] addrs = message.getRecipients(MimeMessage.RecipientType.CC);\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"bcc\".equals(fieldName)) {\n            Address[] addrs = message.getRecipients(MimeMessage.RecipientType.BCC);\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"from\".equals(fieldName)) {\n            Address[] addrs = message.getFrom();\n            if (addrs != null) {\n                values = new String[addrs.length];\n                for (int i = 0; i < addrs.length; i++) {\n                    values[i] = addrs[i].toString();\n                }\n            }\n        } else if (\"subject\".equals(fieldName)) {\n            values = new String[1];\n            values[0] = message.getSubject();\n        } else if (\"send-date\".equals(fieldName)) {\n            values = new String[1];\n            values[0] = message.getSentDate().toString();\n        } else if (\"received-date\".equals(fieldName)) {\n            values = new String[1];\n            values[0] = message.getReceivedDate().toString();\n        } else if (\"body\".equals(fieldName)) {\n            List<String> bodyParts = this.getBodyText(message);\n            values = bodyParts.toArray(new String[bodyParts.size()]);\n        }\n        return values;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"public boolean eval(LocalDispatcher dispatcher, MimeMessageWrapper messageWrapper, GenericValue userLogin) {\n        boolean passedCondition = false;\n        if (serviceName != null) {\n            Map result = null;\n            try {\n                result = dispatcher.runSync(serviceName, UtilMisc.toMap(\"messageWrapper\", messageWrapper, \"userLogin\", userLogin));\n            } catch (GenericServiceException e) {\n                Debug.logError(e, module);\n                return false;\n            }\n            if (result == null) {\n                Debug.logError(\"Service MCA Condition Service [\" + serviceName + \"] returned null!\", module);\n                return false;\n            } else {\n                if (ServiceUtil.isError(result)) {\n                    Debug.logError(ServiceUtil.getErrorMessage(result), module);\n                    return false;\n                } else {\n                    Boolean reply = (Boolean) result.get(\"conditionReply\");\n                    if (reply == null) {\n                        reply = Boolean.FALSE;\n                    }\n                    return reply.booleanValue();\n                }\n            }\n            // invoke the condition service\n        } else if (headerName != null) {\n            // compare the header field\n            MimeMessage message = messageWrapper.getMessage();\n            String[] headerValue = null;\n            try {\n                headerValue = message.getHeader(headerName);\n            } catch (MessagingException e) {\n                Debug.logError(e, module);\n            }\n\n            if (headerValue != null) {\n                for (int i = 0; i < headerValue.length; i++) {\n                    if (\"equals\".equals(operator)) {\n                        if (headerValue[i].equals(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-equals\".equals(operator)) {\n                        if (!headerValue[i].equals(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"matches\".equals(operator)) {\n                        if (headerValue[i].matches(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-matches\".equals(operator)) {\n                        if (!headerValue[i].matches(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"not-empty\".equals(operator)) {\n                        passedCondition = true;\n                        break;\n                    }\n                }\n            } else if (\"empty\".equals(operator)) {\n                passedCondition = true;\n            }\n        } else if (fieldName != null) {\n            MimeMessage message = messageWrapper.getMessage();\n            String[] fieldValue = null;\n            try {\n                fieldValue = this.getFieldValue(message, fieldName);\n            } catch (MessagingException e) {\n                Debug.logError(e, module);\n            } catch (IOException e) {\n                Debug.logError(e, module);\n            }\n\n            if (fieldValue != null) {\n                for (int i = 0; i < fieldValue.length; i++) {\n                    if (\"equals\".equals(operator)) {\n                        if (fieldValue[i].equals(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-equals\".equals(operator)) {\n                        if (!fieldValue[i].equals(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"matches\".equals(operator)) {\n                        if (fieldValue[i].matches(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-matches\".equals(operator)) {\n                        if (!fieldValue[i].matches(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"not-empty\".equals(operator)) {\n                        passedCondition = true;\n                        break;\n                    }\n                }\n            } else if (\"empty\".equals(operator)) {\n                passedCondition = true;\n            }\n        } else {\n            passedCondition = false;\n        }\n\n        return passedCondition;\n    }","id":34745,"modified_method":"public boolean eval(LocalDispatcher dispatcher, MimeMessageWrapper messageWrapper, GenericValue userLogin) {\n        boolean passedCondition = false;\n        if (serviceName != null) {\n            Map result = null;\n            try {\n                result = dispatcher.runSync(serviceName, UtilMisc.toMap(\"messageWrapper\", messageWrapper, \"userLogin\", userLogin));\n            } catch (GenericServiceException e) {\n                Debug.logError(e, module);\n                return false;\n            }\n            if (result == null) {\n                Debug.logError(\"Service MCA Condition Service [\" + serviceName + \"] returned null!\", module);\n                return false;\n            } else {\n                if (ServiceUtil.isError(result)) {\n                    Debug.logError(ServiceUtil.getErrorMessage(result), module);\n                    return false;\n                } else {\n                    Boolean reply = (Boolean) result.get(\"conditionReply\");\n                    if (reply == null) {\n                        reply = Boolean.FALSE;\n                    }\n                    return reply.booleanValue();\n                }\n            }\n            // invoke the condition service\n        } else if (headerName != null) {\n            // compare the header field\n            MimeMessage message = messageWrapper.getMessage();\n            String[] headerValues = null;\n            try {\n                headerValues = message.getHeader(headerName);\n            } catch (MessagingException e) {\n                Debug.logError(e, module);\n            }\n\n            if (headerValues != null) {\n                for (String headerValue: headerValues) {\n                    if (\"equals\".equals(operator)) {\n                        if (headerValue.equals(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-equals\".equals(operator)) {\n                        if (!headerValue.equals(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"matches\".equals(operator)) {\n                        if (headerValue.matches(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-matches\".equals(operator)) {\n                        if (!headerValue.matches(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"not-empty\".equals(operator)) {\n                        passedCondition = true;\n                        break;\n                    }\n                }\n            } else if (\"empty\".equals(operator)) {\n                passedCondition = true;\n            }\n        } else if (fieldName != null) {\n            MimeMessage message = messageWrapper.getMessage();\n            String[] fieldValues = null;\n            try {\n                fieldValues = this.getFieldValue(message, fieldName);\n            } catch (MessagingException e) {\n                Debug.logError(e, module);\n            } catch (IOException e) {\n                Debug.logError(e, module);\n            }\n\n            if (fieldValues != null) {\n                for (String fieldValue: fieldValues) {\n                    if (\"equals\".equals(operator)) {\n                        if (fieldValue.equals(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-equals\".equals(operator)) {\n                        if (!fieldValue.equals(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"matches\".equals(operator)) {\n                        if (fieldValue.matches(value)) {\n                            passedCondition = true;\n                            break;\n                        }\n                    } else if (\"not-matches\".equals(operator)) {\n                        if (!fieldValue.matches(value)) {\n                            passedCondition = true;\n                        } else {\n                            passedCondition = false;\n                        }\n                    } else if (\"not-empty\".equals(operator)) {\n                        passedCondition = true;\n                        break;\n                    }\n                }\n            } else if (\"empty\".equals(operator)) {\n                passedCondition = true;\n            }\n        } else {\n            passedCondition = false;\n        }\n\n        return passedCondition;\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"private List getBodyText(Part part) throws MessagingException, IOException {\n        Object c = part.getContent();\n        if (c instanceof String) {\n            return UtilMisc.toList(c);\n        } else if (c instanceof Multipart) {\n            List textContent = new ArrayList();\n            int count = ((Multipart) c).getCount();\n            for (int i = 0; i < count; i++) {\n                BodyPart bp = ((Multipart) c).getBodyPart(i);\n                textContent.addAll(this.getBodyText(bp));\n            }\n            return textContent;\n        } else {\n            return new ArrayList();\n        }\n    }","id":34746,"modified_method":"private List<String> getBodyText(Part part) throws MessagingException, IOException {\n        Object c = part.getContent();\n        if (c instanceof String) {\n            return UtilMisc.toList((String) c);\n        } else if (c instanceof Multipart) {\n            List<String> textContent = FastList.newInstance();\n            int count = ((Multipart) c).getCount();\n            for (int i = 0; i < count; i++) {\n                BodyPart bp = ((Multipart) c).getBodyPart(i);\n                textContent.addAll(this.getBodyText(bp));\n            }\n            return textContent;\n        } else {\n            return FastList.newInstance();\n        }\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"public void eval(LocalDispatcher dispatcher, MimeMessageWrapper messageWrapper, Set actionsRun, GenericValue userLogin) throws GenericServiceException {\n        if (!enabled) {\n            Debug.logInfo(\"Service MCA [\" + ruleName + \"] is disabled; not running.\", module);\n            return;\n        }\n        \n        boolean allCondTrue = true;\n        Iterator i = conditions.iterator();\n        while (i.hasNext()) {\n            ServiceMcaCondition cond = (ServiceMcaCondition) i.next();\n            if (!cond.eval(dispatcher, messageWrapper, userLogin)) {\n                allCondTrue = false;\n                break;\n            }\n        }\n\n        if (allCondTrue) {\n            Iterator a = actions.iterator();\n            boolean allOkay = true;\n            while (a.hasNext() && allOkay) {\n                ServiceMcaAction action = (ServiceMcaAction) a.next();\n                if (!actionsRun.contains(action.serviceName)) {\n                    if (action.runAction(dispatcher, messageWrapper, userLogin)) {\n                        actionsRun.add(action.serviceName);\n                    } else {\n                        allOkay = false;\n                    }\n                }\n            }\n        }\n    }","id":34747,"modified_method":"public void eval(LocalDispatcher dispatcher, MimeMessageWrapper messageWrapper, Set<String> actionsRun, GenericValue userLogin) throws GenericServiceException {\n        if (!enabled) {\n            Debug.logInfo(\"Service MCA [\" + ruleName + \"] is disabled; not running.\", module);\n            return;\n        }\n        \n        boolean allCondTrue = true;\n        for (ServiceMcaCondition cond: conditions) {\n            if (!cond.eval(dispatcher, messageWrapper, userLogin)) {\n                allCondTrue = false;\n                break;\n            }\n        }\n\n        if (allCondTrue) {\n            for (ServiceMcaAction action: actions) {\n                if (!actionsRun.contains(action.serviceName)) {\n                    if (action.runAction(dispatcher, messageWrapper, userLogin)) {\n                        actionsRun.add(action.serviceName);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void evalRules(LocalDispatcher dispatcher, MimeMessageWrapper wrapper, GenericValue userLogin) throws GenericServiceException {\n        List rules = getServiceMcaRules();\n        Set actionsRun = new TreeSet();\n        if (rules != null) {\n            Iterator i = rules.iterator();\n            while (i.hasNext()) {\n                ServiceMcaRule rule = (ServiceMcaRule) i.next();\n                rule.eval(dispatcher, wrapper, actionsRun, userLogin);\n            }\n        }\n    }","id":34748,"modified_method":"public static void evalRules(LocalDispatcher dispatcher, MimeMessageWrapper wrapper, GenericValue userLogin) throws GenericServiceException {\n        Set<String> actionsRun = new TreeSet<String>();\n        for (ServiceMcaRule rule: getServiceMcaRules()) {\n            rule.eval(dispatcher, wrapper, actionsRun, userLogin);\n        }\n    }","commit_id":"0427b13e78cbdca37a046dc1dd5c7b80298e776a","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Starts this bundle by creating the Assembly Manager and starting to\n     * listen for bundle changes. The Assembly Manager is also started, which\n     * means that all bundles in the framework are checked to see whether any is\n     * an Assembly Bundle. Each Assembly Bundle is taken under control by the\n     * Assembly Manager.\n     *\n     * @param context The <code>BundleContext<\/code> of the starting bundle.\n     */\n    public void start(BundleContext context) {\n        // prepare the InstallerService\n        InstallerService installerService = new InstallerServiceImpl(context);\n\n        // register myself as the factory for the installer service\n        Dictionary props = new Hashtable();\n        props.put(Constants.SERVICE_DESCRIPTION,\n            \"Project Sling Bundle Installler Service\");\n        context.registerService(InstallerService.class.getName(),\n            installerService, props);\n\n        // set up the assembly manager\n        this.assemblyManager = new AssemblyManager(context, installerService);\n        context.addBundleListener(this);\n        this.assemblyManager.start();\n    }","id":34749,"modified_method":"/**\n     * Starts this bundle by creating the Assembly Manager and starting to\n     * listen for bundle changes. The Assembly Manager is also started, which\n     * means that all bundles in the framework are checked to see whether any is\n     * an Assembly Bundle. Each Assembly Bundle is taken under control by the\n     * Assembly Manager.\n     *\n     * @param context The <code>BundleContext<\/code> of the starting bundle.\n     */\n    public void start(BundleContext context) {\n        // prepare the InstallerService\n        InstallerService installerService = new InstallerServiceImpl(context);\n\n        // register myself as the factory for the installer service\n        Dictionary<String, String> props = new Hashtable<String, String>();\n        props.put(Constants.SERVICE_DESCRIPTION,\n            \"Project Sling Bundle Installler Service\");\n        context.registerService(InstallerService.class.getName(),\n            installerService, props);\n\n        // set up the assembly manager\n        this.assemblyManager = new AssemblyManager(context, installerService);\n        context.addBundleListener(this);\n        this.assemblyManager.start();\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"protected Bundle[] getBundles() {\n        Bundle[] bundles = this.getBundleContext().getBundles();\n        List assList = new ArrayList();\n        for (int i=0; i < bundles.length; i++) {\n            if (bundles[i].getHeaders().get(\"Assembly-Bundles\") != null) {\n                assList.add(bundles[i]);\n            }\n        }\n        return (Bundle[]) assList.toArray(new Bundle[assList.size()]);\n    }","id":34750,"modified_method":"protected Bundle[] getBundles() {\n        Bundle[] bundles = this.getBundleContext().getBundles();\n        List<Bundle> assList = new ArrayList<Bundle>();\n        for (int i=0; i < bundles.length; i++) {\n            if (bundles[i].getHeaders().get(\"Assembly-Bundles\") != null) {\n                assList.add(bundles[i]);\n            }\n        }\n        return assList.toArray(new Bundle[assList.size()]);\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"InstalledBundle removeInstalledBundle(String key) {\n        return (InstalledBundle) this.installedBundles.remove(key);\n    }","id":34751,"modified_method":"InstalledBundle removeInstalledBundle(String key) {\n        return this.installedBundles.remove(key);\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"private Assembly getOrCreateAssembly(Bundle bundle) {\n        Assembly assembly = (Assembly) this.assemblies.get(bundle.getLocation());\n        if (assembly == null) {\n            assembly = new Assembly(this, bundle);\n            this.assemblies.put(bundle.getLocation(), assembly);\n        }\n        return assembly;\n    }","id":34752,"modified_method":"private Assembly getOrCreateAssembly(Bundle bundle) {\n        Assembly assembly = this.assemblies.get(bundle.getLocation());\n        if (assembly == null) {\n            assembly = new Assembly(this, bundle);\n            this.assemblies.put(bundle.getLocation(), assembly);\n        }\n        return assembly;\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Removes a bundle event from the queue and waits (indefinitely) if no\n     * bundle events are currently available. Events are taken off of the front\n     * of the queue.\n     * <p>\n     * This method is only used internally by the {@link #run()} method.\n     */\n    private BundleEvent take() {\n        synchronized (this.queue) {\n            while (this.queue.isEmpty()) {\n                try {\n                    this.queue.wait();\n                } catch (InterruptedException ie) {\n                    // ignore\n                }\n            }\n\n            return (BundleEvent) this.queue.removeFirst();\n        }\n    }","id":34753,"modified_method":"/**\n     * Removes a bundle event from the queue and waits (indefinitely) if no\n     * bundle events are currently available. Events are taken off of the front\n     * of the queue.\n     * <p>\n     * This method is only used internally by the {@link #run()} method.\n     */\n    private BundleEvent take() {\n        synchronized (this.queue) {\n            while (this.queue.isEmpty()) {\n                try {\n                    this.queue.wait();\n                } catch (InterruptedException ie) {\n                    // ignore\n                }\n            }\n\n            return this.queue.removeFirst();\n        }\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"InstalledBundle getInstalledBundle(String key) {\n        return (InstalledBundle) this.installedBundles.get(key);\n    }","id":34754,"modified_method":"InstalledBundle getInstalledBundle(String key) {\n        return this.installedBundles.get(key);\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"InstalledBundle putInstalledBundle(String key, InstalledBundle bundle) {\n        return (InstalledBundle) this.installedBundles.put(key, bundle);\n    }","id":34755,"modified_method":"InstalledBundle putInstalledBundle(String key, InstalledBundle bundle) {\n        return this.installedBundles.put(key, bundle);\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"public Iterator<org.apache.sling.osgi.assembly.installer.Resource> getResources() {\n        Object lock = this.installerService.acquireLock(0);\n        try {\n            Repository[] repos = this.getRepositoryAdmin().listRepositories();\n            if (repos == null || repos.length == 0) {\n                return Collections.EMPTY_LIST.iterator();\n            }\n\n            SortedSet<org.apache.sling.osgi.assembly.installer.Resource> resSet = new TreeSet<org.apache.sling.osgi.assembly.installer.Resource>();\n            for (int i = 0; i < repos.length; i++) {\n                Resource[] resources = repos[i].getResources();\n                if (resources != null) {\n                    for (int j = 0; j < resources.length; j++) {\n                        resSet.add(new ResourceImpl(resources[j]));\n                    }\n                }\n            }\n            return resSet.iterator();\n        } finally {\n            this.installerService.releaseLock(lock);\n        }\n    }","id":34756,"modified_method":"public Iterator<org.apache.sling.osgi.assembly.installer.Resource> getResources() {\n        Object lock = this.installerService.acquireLock(0);\n        try {\n            org.osgi.service.obr.Repository[] repos = this.getRepositoryAdmin().listRepositories();\n            if (repos == null || repos.length == 0) {\n                return Collections.EMPTY_LIST.iterator();\n            }\n\n            SortedSet<org.apache.sling.osgi.assembly.installer.Resource> resSet = new TreeSet<org.apache.sling.osgi.assembly.installer.Resource>();\n            for (int i = 0; i < repos.length; i++) {\n                Resource[] resources = repos[i].getResources();\n                if (resources != null) {\n                    for (int j = 0; j < resources.length; j++) {\n                        resSet.add(new ResourceImpl(resources[j]));\n                    }\n                }\n            }\n            return resSet.iterator();\n        } finally {\n            this.installerService.releaseLock(lock);\n        }\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"RepositoryImpl(Repository delegatee) {\n            this.delegatee = delegatee;\n        }","id":34757,"modified_method":"RepositoryImpl(org.osgi.service.obr.Repository delegatee) {\n            this.delegatee = delegatee;\n        }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"public void refreshRepositories() {\n        // note: refreshing is implemented by re-adding the repositories\n        Object lock = this.installerService.acquireLock(0);\n        try {\n            Repository[] repos = this.getRepositoryAdmin().listRepositories();\n            for (int i = 0; repos != null && i < repos.length; i++) {\n                this.addRepository(repos[i].getURL());\n            }\n        } finally {\n            this.installerService.releaseLock(lock);\n        }\n    }","id":34758,"modified_method":"public void refreshRepositories() {\n        // note: refreshing is implemented by re-adding the repositories\n        Object lock = this.installerService.acquireLock(0);\n        try {\n            org.osgi.service.obr.Repository[] repos = this.getRepositoryAdmin().listRepositories();\n            for (int i = 0; repos != null && i < repos.length; i++) {\n                this.addRepository(repos[i].getURL());\n            }\n        } finally {\n            this.installerService.releaseLock(lock);\n        }\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"public Iterator getRepositories() {\n        Object lock = this.installerService.acquireLock(0);\n        try {\n            Repository[] repos = this.getRepositoryAdmin().listRepositories();\n            if (repos == null || repos.length == 0) {\n                return Collections.EMPTY_LIST.iterator();\n            }\n\n            SortedSet urlSet = new TreeSet();\n            for (int i = 0; i < repos.length; i++) {\n                urlSet.add(new RepositoryImpl(repos[i]));\n            }\n            return urlSet.iterator();\n        } finally {\n            this.installerService.releaseLock(lock);\n        }\n    }","id":34759,"modified_method":"public Iterator<Repository> getRepositories() {\n        Object lock = this.installerService.acquireLock(0);\n        try {\n            org.osgi.service.obr.Repository[] repos = this.getRepositoryAdmin().listRepositories();\n            if (repos == null || repos.length == 0) {\n                return Collections.EMPTY_LIST.iterator();\n            }\n\n            SortedSet<Repository> urlSet = new TreeSet<Repository>();\n            for (int i = 0; i < repos.length; i++) {\n                urlSet.add(new RepositoryImpl(repos[i]));\n            }\n            return urlSet.iterator();\n        } finally {\n            this.installerService.releaseLock(lock);\n        }\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.core.assembly.installer.Installer#addBundle(java.lang.String, java.io.InputStream, int)\n     */\n    public void addBundle(String location, InputStream source, int startLevel) {\n        this.addBundleDescriptor(new LocalBundleDescriptor(location, source,\n            startLevel));\n    }","id":34760,"modified_method":"/**\n     * @see org.apache.sling.osgi.assembly.installer.Installer#addBundle(java.lang.String, java.io.InputStream, int)\n     */\n    public void addBundle(String location, InputStream source, int startLevel) {\n        this.addBundleDescriptor(new LocalBundleDescriptor(location, source,\n            startLevel));\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.core.assembly.installer.Installer#dispose()\n     */\n    public void dispose() {\n        if (this.lock != null) {\n            // controller.releaseLock(lock);\n        }\n\n        if (this.repositoryURLs != null) {\n            this.repositoryURLs.clear();\n            this.repositoryURLs = null;\n        }\n\n        if (this.bundleDescriptors != null) {\n            for (Iterator<BundleDescriptor> bi = this.bundleDescriptors.iterator(); bi.hasNext();) {\n                (bi.next()).dispose();\n                bi.remove();\n            }\n            this.bundleDescriptors = null;\n        }\n    }","id":34761,"modified_method":"/**\n     * @see org.apache.sling.osgi.assembly.installer.Installer#dispose()\n     */\n    public void dispose() {\n        if (this.lock != null) {\n            // controller.releaseLock(lock);\n        }\n\n        if (this.repositoryURLs != null) {\n            this.repositoryURLs.clear();\n            this.repositoryURLs = null;\n        }\n\n        if (this.bundleDescriptors != null) {\n            for (Iterator<BundleDescriptor> bi = this.bundleDescriptors.iterator(); bi.hasNext();) {\n                (bi.next()).dispose();\n                bi.remove();\n            }\n            this.bundleDescriptors = null;\n        }\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.core.assembly.installer.Installer#setDefaultStartLevel(int)\n     */\n    public void setDefaultStartLevel(int startLevel) {\n        // TODO Auto-generated method stub\n\n    }","id":34762,"modified_method":"/**\n     * @see org.apache.sling.osgi.assembly.installer.Installer#setDefaultStartLevel(int)\n     */\n    public void setDefaultStartLevel(int startLevel) {\n        // TODO Auto-generated method stub\n\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.core.assembly.installer.Installer#addBundle(java.lang.String, org.apache.sling.core.assembly.installer.VersionRange, int)\n     */\n    public void addBundle(String symbolicName, VersionRange versionRange,\n            int startLevel) {\n        this.addBundleDescriptor(new RepositoryBundleDescriptor(symbolicName,\n            versionRange, startLevel));\n    }","id":34763,"modified_method":"/**\n     * @see org.apache.sling.osgi.assembly.installer.Installer#addBundle(java.lang.String, org.apache.sling.osgi.assembly.installer.VersionRange, int)\n     */\n    public void addBundle(String symbolicName, VersionRange versionRange,\n            int startLevel) {\n        this.addBundleDescriptor(new RepositoryBundleDescriptor(symbolicName,\n            versionRange, startLevel));\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.core.assembly.installer.Installer#install(boolean)\n     */\n    public Bundle[] install(boolean start) throws InstallerException {\n\n        // quick check for work\n        if (this.bundleDescriptors == null || this.bundleDescriptors.isEmpty()) {\n            return null;\n        }\n\n        Set<URL> addedRepos = null;\n\n        try {\n            this.lock = this.controller.acquireLock(LOCK_ACQUIRE_TIMEOUT);\n\n            addedRepos = this.addRepositories();\n\n            List<Bundle> installedBundles = new LinkedList<Bundle>();\n            for (Iterator<BundleDescriptor> di = this.bundleDescriptors.iterator(); di.hasNext();) {\n                BundleDescriptor bd = di.next();\n\n                try {\n                    bd.install(this.controller, installedBundles);\n                } catch (BundleException be) {\n                    this.controller.log(LogService.LOG_ERROR, be.getMessage());\n                }\n            }\n\n            boolean doResolve = false;\n            if (doResolve) {\n                RepositoryAdmin ra = this.controller.getRepositoryAdmin();\n                if (ra != null) {\n                    Resolver r = ra.resolver();\n                    System.err.println(\"Missing Resources:\");\n                    if (!r.resolve()) {\n                        Requirement[] unsatisfied = r.getUnsatisfiedRequirements();\n                        for (int j = 0; j < unsatisfied.length; j++) {\n                            System.err.println(\" Unsatisfied: \" + unsatisfied[j].getFilter());\n                        }\n\n                    }\n\n                    Resource[] res = r.getRequiredResources();\n                    for (int i=0; res != null && i < res.length; i++) {\n                        System.err.println(\" Required   : \" + res[i].getPresentationName());\n                    }\n                    res = r.getOptionalResources();\n                    for (int i=0; res != null && i < res.length; i++) {\n                        System.err.println(\" Optional   : \" + res[i].getPresentationName());\n                    }\n                }\n            }\n\n            Bundle[] bundles = installedBundles.toArray(new Bundle[installedBundles.size()]);\n\n            if (start) {\n                for (int i = 0; i < bundles.length; i++) {\n                    try {\n                        bundles[i].start();\n                    } catch (BundleException be) {\n                        this.controller.log(LogService.LOG_WARNING,\n                            \"Cannot start bundle \"\n                                + bundles[i].getSymbolicName() + \"(id:\"\n                                + bundles[i].getBundleId() + \")\", be);\n                    }\n                }\n            }\n\n            return bundles;\n\n        } catch (IllegalStateException ise) {\n            throw new InstallerException(ise.getMessage(), ise);\n\n        } catch (Throwable t) {\n            throw new InstallerException(\n                \"Unexpected Problem during installation\", t);\n\n        } finally {\n\n            // release temporary repositories\n            this.removeRepositories(addedRepos);\n\n            // release the lock, if we have it\n            if (this.lock != null) {\n                this.controller.releaseLock(this.lock);\n                this.lock = null;\n            }\n        }\n    }","id":34764,"modified_method":"/**\n     * @see org.apache.sling.osgi.assembly.installer.Installer#install(boolean)\n     */\n    public Bundle[] install(boolean start) throws InstallerException {\n\n        // quick check for work\n        if (this.bundleDescriptors == null || this.bundleDescriptors.isEmpty()) {\n            return null;\n        }\n\n        Set<URL> addedRepos = null;\n\n        try {\n            this.lock = this.controller.acquireLock(LOCK_ACQUIRE_TIMEOUT);\n\n            addedRepos = this.addRepositories();\n\n            List<Bundle> installedBundles = new LinkedList<Bundle>();\n            for (Iterator<BundleDescriptor> di = this.bundleDescriptors.iterator(); di.hasNext();) {\n                BundleDescriptor bd = di.next();\n\n                try {\n                    bd.install(this.controller, installedBundles);\n                } catch (BundleException be) {\n                    this.controller.log(LogService.LOG_ERROR, be.getMessage());\n                }\n            }\n\n            boolean doResolve = false;\n            if (doResolve) {\n                RepositoryAdmin ra = this.controller.getRepositoryAdmin();\n                if (ra != null) {\n                    Resolver r = ra.resolver();\n                    System.err.println(\"Missing Resources:\");\n                    if (!r.resolve()) {\n                        Requirement[] unsatisfied = r.getUnsatisfiedRequirements();\n                        for (int j = 0; j < unsatisfied.length; j++) {\n                            System.err.println(\" Unsatisfied: \" + unsatisfied[j].getFilter());\n                        }\n\n                    }\n\n                    Resource[] res = r.getRequiredResources();\n                    for (int i=0; res != null && i < res.length; i++) {\n                        System.err.println(\" Required   : \" + res[i].getPresentationName());\n                    }\n                    res = r.getOptionalResources();\n                    for (int i=0; res != null && i < res.length; i++) {\n                        System.err.println(\" Optional   : \" + res[i].getPresentationName());\n                    }\n                }\n            }\n\n            Bundle[] bundles = installedBundles.toArray(new Bundle[installedBundles.size()]);\n\n            if (start) {\n                for (int i = 0; i < bundles.length; i++) {\n                    try {\n                        bundles[i].start();\n                    } catch (BundleException be) {\n                        this.controller.log(LogService.LOG_WARNING,\n                            \"Cannot start bundle \"\n                                + bundles[i].getSymbolicName() + \"(id:\"\n                                + bundles[i].getBundleId() + \")\", be);\n                    }\n                }\n            }\n\n            return bundles;\n\n        } catch (IllegalStateException ise) {\n            throw new InstallerException(ise.getMessage(), ise);\n\n        } catch (Throwable t) {\n            throw new InstallerException(\n                \"Unexpected Problem during installation\", t);\n\n        } finally {\n\n            // release temporary repositories\n            this.removeRepositories(addedRepos);\n\n            // release the lock, if we have it\n            if (this.lock != null) {\n                this.controller.releaseLock(this.lock);\n                this.lock = null;\n            }\n        }\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.core.assembly.installer.Installer#addTemporaryRepository(java.net.URL)\n     */\n    public void addTemporaryRepository(URL url) {\n        if (this.repositoryURLs == null) {\n            this.repositoryURLs = new HashSet<URL>();\n        }\n\n        this.repositoryURLs.add(url);\n    }","id":34765,"modified_method":"/**\n     * @see org.apache.sling.osgi.assembly.installer.Installer#addTemporaryRepository(java.net.URL)\n     */\n    public void addTemporaryRepository(URL url) {\n        if (this.repositoryURLs == null) {\n            this.repositoryURLs = new HashSet<URL>();\n        }\n\n        this.repositoryURLs.add(url);\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Checks the <code>Authorization<\/code> header of the request for Basic\n     * authentication user name and password. If contained, the credentials are\n     * compared to the user name and password set for the Sling Console.\n     * <p>\n     * If no user name is set, the <code>Authorization<\/code> header is\n     * ignored and the client is assumed to be authenticated.\n     *\n     * @param request The HTTP request used to get the\n     *            <code>Authorization<\/code> header.\n     * @param response The HTTP response used to send the authentication request\n     *            if authentication is required but not satisfied.\n     * @return <code>true<\/code> if authentication is required and not\n     *         satisfied by the request.\n     * @throws IOException If an IO error occurrs while trying to request\n     *             authentication.\n     */\n    public boolean handleSecurity(HttpServletRequest request,\n            HttpServletResponse response) {\n\n        // don't care for authentication if no user name is configured\n        if (this.user == null) {\n            return true;\n        }\n\n        // Return immediately if the header is missing\n        String authHeader = request.getHeader(HEADER_AUTHORIZATION);\n        if (authHeader != null && authHeader.length() > 0) {\n\n            // Get the authType (Basic, Digest) and authInfo (user/password)\n            // from\n            // the header\n            authHeader = authHeader.trim();\n            int blank = authHeader.indexOf(' ');\n            if (blank > 0) {\n                String authType = authHeader.substring(0, blank);\n                String authInfo = authHeader.substring(blank).trim();\n\n                // Check whether authorization type matches\n                if (authType.equalsIgnoreCase(AUTHENTICATION_SCHEME_BASIC)\n                    && this.user.equals(authInfo)) {\n\n                    // as per the spec, set attributes\n                    request.setAttribute(HttpContext.AUTHENTICATION_TYPE, \"\");\n                    request.setAttribute(HttpContext.REMOTE_USER, this.userId);\n\n                    // succeed\n                    return true;\n                }\n            }\n        }\n\n        // request authentication\n        response.setHeader(HEADER_WWW_AUTHENTICATE, AUTHENTICATION_SCHEME_BASIC\n            + \" realm=\\\"\" + this.realm + \"\\\"\");\n        try {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        } catch (IOException ioe) {\n            // failed sending the error, fall back to setting the status\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n\n        // inform HttpService that authentication failed\n        return false;\n    }","id":34766,"modified_method":"/**\n     * Checks the <code>Authorization<\/code> header of the request for Basic\n     * authentication user name and password. If contained, the credentials are\n     * compared to the user name and password set for the Sling Console.\n     * <p>\n     * If no user name is set, the <code>Authorization<\/code> header is\n     * ignored and the client is assumed to be authenticated.\n     *\n     * @param request The HTTP request used to get the\n     *            <code>Authorization<\/code> header.\n     * @param response The HTTP response used to send the authentication request\n     *            if authentication is required but not satisfied.\n     * @return <code>true<\/code> if authentication is required and not\n     *         satisfied by the request.\n     */\n    public boolean handleSecurity(HttpServletRequest request,\n            HttpServletResponse response) {\n\n        // don't care for authentication if no user name is configured\n        if (this.user == null) {\n            return true;\n        }\n\n        // Return immediately if the header is missing\n        String authHeader = request.getHeader(HEADER_AUTHORIZATION);\n        if (authHeader != null && authHeader.length() > 0) {\n\n            // Get the authType (Basic, Digest) and authInfo (user/password)\n            // from\n            // the header\n            authHeader = authHeader.trim();\n            int blank = authHeader.indexOf(' ');\n            if (blank > 0) {\n                String authType = authHeader.substring(0, blank);\n                String authInfo = authHeader.substring(blank).trim();\n\n                // Check whether authorization type matches\n                if (authType.equalsIgnoreCase(AUTHENTICATION_SCHEME_BASIC)\n                    && this.user.equals(authInfo)) {\n\n                    // as per the spec, set attributes\n                    request.setAttribute(HttpContext.AUTHENTICATION_TYPE, \"\");\n                    request.setAttribute(HttpContext.REMOTE_USER, this.userId);\n\n                    // succeed\n                    return true;\n                }\n            }\n        }\n\n        // request authentication\n        response.setHeader(HEADER_WWW_AUTHENTICATE, AUTHENTICATION_SCHEME_BASIC\n            + \" realm=\\\"\" + this.realm + \"\\\"\");\n        try {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        } catch (IOException ioe) {\n            // failed sending the error, fall back to setting the status\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n\n        // inform HttpService that authentication failed\n        return false;\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the named property from the configuration. If the property does\n     * not exist, the default value <code>def<\/code> is returned.\n     *\n     * @param config The properties from which to returned the named one\n     * @param name The name of the property to return\n     * @param def The default value if the named property does not exist\n     * @return The value of the named property as a string or <code>def<\/code>\n     *         if the property does not exist\n     */\n    private String getProperty(Dictionary config, String name, String def) {\n        Object value = config.get(name);\n        if (value instanceof String) {\n            return (String) value;\n        }\n\n        if (value == null) {\n            return def;\n        }\n\n        return String.valueOf(value);\n    }","id":34767,"modified_method":"/**\n     * Returns the named property from the configuration. If the property does\n     * not exist, the default value <code>def<\/code> is returned.\n     *\n     * @param config The properties from which to returned the named one\n     * @param name The name of the property to return\n     * @param def The default value if the named property does not exist\n     * @return The value of the named property as a string or <code>def<\/code>\n     *         if the property does not exist\n     */\n    private String getProperty(Dictionary<String, Object> config, String name, String def) {\n        Object value = config.get(name);\n        if (value instanceof String) {\n            return (String) value;\n        }\n\n        if (value == null) {\n            return def;\n        }\n\n        return String.valueOf(value);\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"private String getParameter(HttpServletRequest request, String name) {\n        // just get the parameter if not a multipart/form-data POST\n        if (!ServletFileUpload.isMultipartContent(new ServletRequestContext(\n            request))) {\n            return request.getParameter(name);\n        }\n\n        // check, whether we alread have the parameters\n        Map<String, FileItem[]> params = (Map<String, FileItem[]>) request.getAttribute(Util.ATTR_FILEUPLOAD);\n        if (params == null) {\n            // parameters not read yet, read now\n            // Create a factory for disk-based file items\n            DiskFileItemFactory factory = new DiskFileItemFactory();\n            factory.setSizeThreshold(256000);\n\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload(factory);\n            upload.setSizeMax(-1);\n\n            // Parse the request\n            params = new HashMap<String, FileItem[]>();\n            try {\n                List /* FileItem */items = upload.parseRequest(request);\n                for (Iterator ii = items.iterator(); ii.hasNext();) {\n                    FileItem fi = (FileItem) ii.next();\n                    FileItem[] current = params.get(fi.getFieldName());\n                    if (current == null) {\n                        current = new FileItem[] { fi };\n                    } else {\n                        FileItem[] newCurrent = new FileItem[current.length + 1];\n                        System.arraycopy(current, 0, newCurrent, 0,\n                            current.length);\n                        newCurrent[current.length] = fi;\n                        current = newCurrent;\n                    }\n                    params.put(fi.getFieldName(), current);\n                }\n            } catch (FileUploadException fue) {\n                // TODO: log\n            }\n            request.setAttribute(Util.ATTR_FILEUPLOAD, params);\n        }\n\n        FileItem[] param = params.get(name);\n        if (param != null) {\n            for (int i = 0; i < param.length; i++) {\n                if (param[i].isFormField()) {\n                    return param[i].getString();\n                }\n            }\n        }\n\n        // no valid string parameter, fail\n        return null;\n    }","id":34768,"modified_method":"private String getParameter(HttpServletRequest request, String name) {\n        // just get the parameter if not a multipart/form-data POST\n        if (!ServletFileUpload.isMultipartContent(new ServletRequestContext(\n            request))) {\n            return request.getParameter(name);\n        }\n\n        // check, whether we alread have the parameters\n        @SuppressWarnings(\"unchecked\")\n        Map<String, FileItem[]> params = (Map<String, FileItem[]>) request.getAttribute(Util.ATTR_FILEUPLOAD);\n        if (params == null) {\n            // parameters not read yet, read now\n            // Create a factory for disk-based file items\n            DiskFileItemFactory factory = new DiskFileItemFactory();\n            factory.setSizeThreshold(256000);\n\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload(factory);\n            upload.setSizeMax(-1);\n\n            // Parse the request\n            params = new HashMap<String, FileItem[]>();\n            try {\n                @SuppressWarnings(\"unchecked\")\n                List<FileItem> items = upload.parseRequest(request);\n                for (FileItem fi : items) {\n                    FileItem[] current = params.get(fi.getFieldName());\n                    if (current == null) {\n                        current = new FileItem[] { fi };\n                    } else {\n                        FileItem[] newCurrent = new FileItem[current.length + 1];\n                        System.arraycopy(current, 0, newCurrent, 0,\n                            current.length);\n                        newCurrent[current.length] = fi;\n                        current = newCurrent;\n                    }\n                    params.put(fi.getFieldName(), current);\n                }\n            } catch (FileUploadException fue) {\n                // TODO: log\n            }\n            request.setAttribute(Util.ATTR_FILEUPLOAD, params);\n        }\n\n        FileItem[] param = params.get(name);\n        if (param != null) {\n            for (int i = 0; i < param.length; i++) {\n                if (param[i].isFormField()) {\n                    return param[i].getString();\n                }\n            }\n        }\n\n        // no valid string parameter, fail\n        return null;\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"protected void activate(ComponentContext context) {\n        this.componentContext = context;\n\n        Dictionary config = this.componentContext.getProperties();\n\n        this.defaultRenderName = (String) config.get(PROP_DEFAULT_RENDER);\n        if ( this.renders.get(this.defaultRenderName ) != null ) {\n            this.defaultRender = this.renders.get(this.defaultRenderName);\n        }\n\n        // get authentication details\n        String realm = this.getProperty(config, PROP_REALM,\n            \"Sling Management Console\");\n        String userId = this.getProperty(config, PROP_USER_NAME, null);\n        String password = this.getProperty(config, PROP_PASSWORD, null);\n\n        // get the web manager root path\n        this.webManagerRoot = this.getProperty(config, PROP_MANAGER_ROOT, \"/sling\");\n        if (!this.webManagerRoot.startsWith(\"/\")) {\n            this.webManagerRoot = \"/\" + this.webManagerRoot;\n        }\n\n        // register the servlet and resources\n        try {\n            HttpContext httpContext = new SlingHttpContext(this.httpService, realm,\n                userId, password);\n\n            // rest of sling\n            this.httpService.registerServlet(this.webManagerRoot, this, config,\n                httpContext);\n            this.httpService.registerResources(this.webManagerRoot + \"/res\", \"/res\",\n                httpContext);\n\n        } catch (Exception e) {\n            this.logService.log(LogService.LOG_ERROR, \"Problem setting up\", e);\n        }\n    }","id":34769,"modified_method":"protected void activate(ComponentContext context) {\n        this.componentContext = context;\n\n        @SuppressWarnings(\"unchecked\")\n        Dictionary<String, Object> config = this.componentContext.getProperties();\n\n        this.defaultRenderName = (String) config.get(PROP_DEFAULT_RENDER);\n        if ( this.renders.get(this.defaultRenderName ) != null ) {\n            this.defaultRender = this.renders.get(this.defaultRenderName);\n        }\n\n        // get authentication details\n        String realm = this.getProperty(config, PROP_REALM,\n            \"Sling Management Console\");\n        String userId = this.getProperty(config, PROP_USER_NAME, null);\n        String password = this.getProperty(config, PROP_PASSWORD, null);\n\n        // get the web manager root path\n        this.webManagerRoot = this.getProperty(config, PROP_MANAGER_ROOT, \"/sling\");\n        if (!this.webManagerRoot.startsWith(\"/\")) {\n            this.webManagerRoot = \"/\" + this.webManagerRoot;\n        }\n\n        // register the servlet and resources\n        try {\n            HttpContext httpContext = new SlingHttpContext(this.httpService, realm,\n                userId, password);\n\n            // rest of sling\n            this.httpService.registerServlet(this.webManagerRoot, this, config,\n                httpContext);\n            this.httpService.registerResources(this.webManagerRoot + \"/res\", \"/res\",\n                httpContext);\n\n        } catch (Exception e) {\n            this.logService.log(LogService.LOG_ERROR, \"Problem setting up\", e);\n        }\n    }","commit_id":"71a2b01f35fb3d750a7b9e0a73de03bdd87a6bdf","url":"https://github.com/apache/sling"},{"original_method":"/** Called after creating or deserializing the FECQueue. Initialises all the transient fields. */\n\tpublic void init(int priorities, int maxCacheSize, DBJobRunner dbJobRunner, Executor exec, ClientContext clientContext) {\n\t\tthis.priorities = priorities;\n\t\tthis.maxPersistentQueueCacheSize = maxCacheSize;\n\t\tthis.databaseJobRunner = dbJobRunner;\n\t\tthis.executor = exec;\n\t\tthis.clientContext = clientContext;\n\t\ttransientQueue = new LinkedList[priorities];\n\t\tpersistentQueueCache = new LinkedList[priorities];\n\t\tfor(int i=0;i<priorities;i++) {\n\t\t\ttransientQueue[i] = new LinkedList();\n\t\t\tpersistentQueueCache[i] = new LinkedList();\n\t\t}\n\t\tmaxRunningFECThreads = getMaxRunningFECThreads();\n\t\tOOMHandler.addOOMHook(this);\n\t\tinitRunner();\n\t\tinitCacheFillerJob();\n\t\tqueueCacheFiller();\n\t}","id":34770,"modified_method":"/** Called after creating or deserializing the FECQueue. Initialises all the transient fields. */\n\t@SuppressWarnings(\"unchecked\")\n    public void init(int priorities, int maxCacheSize, DBJobRunner dbJobRunner, Executor exec, ClientContext clientContext) {\n\t\tthis.priorities = priorities;\n\t\tthis.maxPersistentQueueCacheSize = maxCacheSize;\n\t\tthis.databaseJobRunner = dbJobRunner;\n\t\tthis.executor = exec;\n\t\tthis.clientContext = clientContext;\n\t\ttransientQueue = new LinkedList[priorities];\n\t\tpersistentQueueCache = new LinkedList[priorities];\n\t\tfor(int i=0;i<priorities;i++) {\n\t\t\ttransientQueue[i] = new LinkedList<FECJob>();\n\t\t\tpersistentQueueCache[i] = new LinkedList<FECJob>();\n\t\t}\n\t\tmaxRunningFECThreads = getMaxRunningFECThreads();\n\t\tOOMHandler.addOOMHook(this);\n\t\tinitRunner();\n\t\tinitCacheFillerJob();\n\t\tqueueCacheFiller();\n\t}","commit_id":"269f087f9d757ec780354b743402b3efb9ae8b1f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Find a FEC job to run.\n\t * @return null only if there are too many FEC threads running.\n\t */\n\tprotected synchronized FECJob getFECJobBlockingNoDBAccess() {\n\t\twhile(true) {\n\t\t\tif(runningFECThreads > getMaxRunningFECThreads())\n\t\t\t\treturn null;\n\t\t\tfor(int i=0;i<priorities;i++) {\n\t\t\t\tif(!transientQueue[i].isEmpty())\n\t\t\t\t\treturn (FECJob) transientQueue[i].removeFirst();\n\t\t\t\tif(!persistentQueueCache[i].isEmpty())\n\t\t\t\t\treturn (FECJob) persistentQueueCache[i].removeFirst();\n\t\t\t}\n\t\t\tqueueCacheFiller();\n\t\t\ttry {\n\t\t\t\twait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t}","id":34771,"modified_method":"/**\n\t * Find a FEC job to run.\n\t * @return null only if there are too many FEC threads running.\n\t */\n\tprotected synchronized FECJob getFECJobBlockingNoDBAccess() {\n\t\twhile(true) {\n\t\t\tif(runningFECThreads > getMaxRunningFECThreads())\n\t\t\t\treturn null;\n\t\t\tfor(int i=0;i<priorities;i++) {\n\t\t\t\tif(!transientQueue[i].isEmpty())\n\t\t\t\t\treturn transientQueue[i].removeFirst();\n\t\t\t\tif(!persistentQueueCache[i].isEmpty())\n\t\t\t\t\treturn persistentQueueCache[i].removeFirst();\n\t\t\t}\n\t\t\tqueueCacheFiller();\n\t\t\ttry {\n\t\t\t\twait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t}","commit_id":"269f087f9d757ec780354b743402b3efb9ae8b1f","url":"https://github.com/freenet/fred"},{"original_method":"private void initCacheFillerJob() {\n\t\tcacheFillerJob = new DBJob() {\n\n\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t// Try to avoid accessing the database while synchronized on the FECQueue.\n\t\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\tif(logMINOR) Logger.minor(this, \"Running FEC cache filler job\");\n\t\t\twhile(true) {\n\t\t\t\tboolean addedAny = false;\n\t\t\t\tint totalCached = 0;\n\t\t\t\tfor(short prio=0;prio<priorities;prio++) {\n\t\t\t\t\tint grab = 0;\n\t\t\t\t\tsynchronized(FECQueue.this) {\n\t\t\t\t\t\tint newCached = totalCached + persistentQueueCache[prio].size();\n\t\t\t\t\t\tif(newCached >= maxPersistentQueueCacheSize) return;\n\t\t\t\t\t\tgrab = maxPersistentQueueCacheSize - newCached;\n\t\t\t\t\t\ttotalCached = newCached;\n\t\t\t\t\t}\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Grabbing up to \"+grab+\" jobs at priority \"+prio);\n\t\t\t\t\tQuery query = container.query();\n\t\t\t\t\tquery.constrain(FECJob.class);\n\t\t\t\t\tConstraint con = query.descend(\"priority\").constrain(new Short(prio));\n\t\t\t\t\tcon.and(query.descend(\"queue\").constrain(FECQueue.this).identity());\n\t\t\t\t\tquery.descend(\"addedTime\").orderAscending();\n\t\t\t\t\tObjectSet results = query.execute();\n\t\t\t\t\tif(results.hasNext()) {\n\t\t\t\t\t\tfor(int j=0;j<grab && results.hasNext();j++) {\n\t\t\t\t\t\t\tFECJob job = (FECJob) results.next();\n\t\t\t\t\t\t\tjob.activateForExecution(container);\n\t\t\t\t\t\t\tif(job.isCancelled(container)) {\n\t\t\t\t\t\t\t\tcontainer.delete(job);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Maybe adding \"+job);\n\t\t\t\t\t\t\tsynchronized(FECQueue.this) {\n\t\t\t\t\t\t\t\tif(job.running) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not adding, already running: \"+job);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(persistentQueueCache[prio].contains(job)) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not adding as on persistent queue cache for \"+prio+\" : \"+job);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tboolean added = false;\n\t\t\t\t\t\t\t\tfor(ListIterator it = persistentQueueCache[prio].listIterator();it.hasNext();) {\n\t\t\t\t\t\t\t\t\tFECJob cmp = (FECJob) it.next();\n\t\t\t\t\t\t\t\t\tif(cmp.addedTime >= job.addedTime) {\n\t\t\t\t\t\t\t\t\t\tit.previous();\n\t\t\t\t\t\t\t\t\t\tit.add(job);\n\t\t\t\t\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Adding \"+job+\" before \"+it);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!added) persistentQueueCache[prio].addLast(job);\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Added \"+job);\n\t\t\t\t\t\t\t\taddedAny = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!addedAny) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No more jobs to add\");\n\t\t\t\t\t// Don't notify, let it sleep until more jobs are added.\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tsynchronized(FECQueue.this) {\n\t\t\t\t\t\tint maxRunningThreads = maxRunningFECThreads;\n\t\t\t\t\t\tif(runningFECThreads < maxRunningThreads) {\n\t\t\t\t\t\t\tint queueSize = 0;\n\t\t\t\t\t\t\tfor(int i=0;i<priorities;i++) {\n\t\t\t\t\t\t\t\tqueueSize += persistentQueueCache[i].size();\n\t\t\t\t\t\t\t\tif(queueSize + runningFECThreads > maxRunningThreads) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(queueSize + runningFECThreads < maxRunningThreads)\n\t\t\t\t\t\t\t\tmaxRunningThreads = queueSize + runningFECThreads;\n\t\t\t\t\t\t\twhile(runningFECThreads < maxRunningThreads) {\n\t\t\t\t\t\t\t\texecutor.execute(runner, \"FEC Pool \"+fecPoolCounter++);\n\t\t\t\t\t\t\t\trunningFECThreads++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFECQueue.this.notifyAll();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t};\n\t\t\n\t}","id":34772,"modified_method":"private void initCacheFillerJob() {\n\t\tcacheFillerJob = new DBJob() {\n\n\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t// Try to avoid accessing the database while synchronized on the FECQueue.\n\t\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\tif(logMINOR) Logger.minor(this, \"Running FEC cache filler job\");\n\t\t\twhile(true) {\n\t\t\t\tboolean addedAny = false;\n\t\t\t\tint totalCached = 0;\n\t\t\t\tfor(short prio=0;prio<priorities;prio++) {\n\t\t\t\t\tint grab = 0;\n\t\t\t\t\tsynchronized(FECQueue.this) {\n\t\t\t\t\t\tint newCached = totalCached + persistentQueueCache[prio].size();\n\t\t\t\t\t\tif(newCached >= maxPersistentQueueCacheSize) return;\n\t\t\t\t\t\tgrab = maxPersistentQueueCacheSize - newCached;\n\t\t\t\t\t\ttotalCached = newCached;\n\t\t\t\t\t}\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Grabbing up to \"+grab+\" jobs at priority \"+prio);\n\t\t\t\t\tQuery query = container.query();\n\t\t\t\t\tquery.constrain(FECJob.class);\n\t\t\t\t\tConstraint con = query.descend(\"priority\").constrain(Short.valueOf(prio));\n\t\t\t\t\tcon.and(query.descend(\"queue\").constrain(FECQueue.this).identity());\n\t\t\t\t\tquery.descend(\"addedTime\").orderAscending();\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tObjectSet<FECJob> results = query.execute();\n\t\t\t\t\tif(results.hasNext()) {\n\t\t\t\t\t\tfor(int j=0;j<grab && results.hasNext();j++) {\n\t\t\t\t\t\t\tFECJob job = results.next();\n\t\t\t\t\t\t\tjob.activateForExecution(container);\n\t\t\t\t\t\t\tif(job.isCancelled(container)) {\n\t\t\t\t\t\t\t\tcontainer.delete(job);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Maybe adding \"+job);\n\t\t\t\t\t\t\tsynchronized(FECQueue.this) {\n\t\t\t\t\t\t\t\tif(job.running) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not adding, already running: \"+job);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(persistentQueueCache[prio].contains(job)) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Not adding as on persistent queue cache for \"+prio+\" : \"+job);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tboolean added = false;\n\t\t\t\t\t\t\t\tfor(ListIterator<FECJob> it = persistentQueueCache[prio].listIterator();it.hasNext();) {\n\t\t\t\t\t\t\t\t\tFECJob cmp = it.next();\n\t\t\t\t\t\t\t\t\tif(cmp.addedTime >= job.addedTime) {\n\t\t\t\t\t\t\t\t\t\tit.previous();\n\t\t\t\t\t\t\t\t\t\tit.add(job);\n\t\t\t\t\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Adding \"+job+\" before \"+it);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!added) persistentQueueCache[prio].addLast(job);\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Added \"+job);\n\t\t\t\t\t\t\t\taddedAny = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!addedAny) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No more jobs to add\");\n\t\t\t\t\t// Don't notify, let it sleep until more jobs are added.\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tsynchronized(FECQueue.this) {\n\t\t\t\t\t\tint maxRunningThreads = maxRunningFECThreads;\n\t\t\t\t\t\tif(runningFECThreads < maxRunningThreads) {\n\t\t\t\t\t\t\tint queueSize = 0;\n\t\t\t\t\t\t\tfor(int i=0;i<priorities;i++) {\n\t\t\t\t\t\t\t\tqueueSize += persistentQueueCache[i].size();\n\t\t\t\t\t\t\t\tif(queueSize + runningFECThreads > maxRunningThreads) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(queueSize + runningFECThreads < maxRunningThreads)\n\t\t\t\t\t\t\t\tmaxRunningThreads = queueSize + runningFECThreads;\n\t\t\t\t\t\t\twhile(runningFECThreads < maxRunningThreads) {\n\t\t\t\t\t\t\t\texecutor.execute(runner, \"FEC Pool \"+fecPoolCounter++);\n\t\t\t\t\t\t\t\trunningFECThreads++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFECQueue.this.notifyAll();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t};\n\t\t\n\t}","commit_id":"269f087f9d757ec780354b743402b3efb9ae8b1f","url":"https://github.com/freenet/fred"},{"original_method":"public static FECQueue create(final long nodeDBHandle, ObjectContainer container) {\n\t\tObjectSet<FECQueue> result = container.query(new Predicate<FECQueue>() {\n\t\t\tpublic boolean match(FECQueue queue) {\n\t\t\t\tif(queue.nodeDBHandle == nodeDBHandle) return true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tif(result.hasNext()) {\n\t\t\tFECQueue queue = result.next();\n\t\t\tcontainer.activate(queue, 1);\n\t\t\treturn queue;\n\t\t} else {\n\t\t\tFECQueue queue = new FECQueue(nodeDBHandle);\n\t\t\tcontainer.store(queue);\n\t\t\treturn queue;\n\t\t}\n\t}","id":34773,"modified_method":"public static FECQueue create(final long nodeDBHandle, ObjectContainer container) {\n    \t@SuppressWarnings(\"serial\")\n\t\tObjectSet<FECQueue> result = container.query(new Predicate<FECQueue>() {\n\t\t\tpublic boolean match(FECQueue queue) {\n\t\t\t\tif(queue.nodeDBHandle == nodeDBHandle) return true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tif(result.hasNext()) {\n\t\t\tFECQueue queue = result.next();\n\t\t\tcontainer.activate(queue, 1);\n\t\t\treturn queue;\n\t\t} else {\n\t\t\tFECQueue queue = new FECQueue(nodeDBHandle);\n\t\t\tcontainer.store(queue);\n\t\t\treturn queue;\n\t\t}\n\t}","commit_id":"269f087f9d757ec780354b743402b3efb9ae8b1f","url":"https://github.com/freenet/fred"},{"original_method":"public int[] runningJobs() {\n\t\tint[] retval = new int[jobs.length];\n\t\tsynchronized(jobs) {\n\t\t\tfor(int i=0;i<retval.length;i++)\n\t\t\t\tretval[i] = jobs[i].size();\n\t\t}\n\t\treturn retval;\n\t}","id":34774,"modified_method":"public int[] runningJobs() {\n\t\tint[] retval;\n\t\tsynchronized(jobs) {\n\t\t\tretval = jobCount.clone();\n\t\t}\n\t\treturn retval;\n\t}","commit_id":"cb30e61edb632f792dd38bb89c994fee22ffe654","url":"https://github.com/freenet/fred"},{"original_method":"public void executeNoDupes(Runnable job, int prio, String jobName) {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(jobs) {\n\t\t\tif(logMINOR) \n\t\t\t\tLogger.minor(this, \"Running \"+jobName+\" : \"+job+\" priority \"+prio+\" running=\"+running+\" waiting=\"+waiting);\n\t\t\tif(jobs[prio].contains(job)) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Not adding duplicate job \"+job);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tjobs[prio].addLast(job);\n\t\t\tjobs.notifyAll();\n\t\t\tif(!running && realExecutor != null) {\n\t\t\t\treallyStart(logMINOR);\n\t\t\t}\n\t\t}\n\t}","id":34775,"modified_method":"public void executeNoDupes(Runnable job, int prio, String jobName) {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(jobs) {\n\t\t\tif(logMINOR) \n\t\t\t\tLogger.minor(this, \"Running \"+jobName+\" : \"+job+\" priority \"+prio+\" running=\"+running+\" waiting=\"+waiting);\n\t\t\tif(jobs[prio].contains(job)) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Not adding duplicate job \"+job);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tjobs[prio].addLast(job);\n\t\t\tjobCount[prio]++;\n\t\t\tjobs.notifyAll();\n\t\t\tif(!running && realExecutor != null) {\n\t\t\t\treallyStart(logMINOR);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cb30e61edb632f792dd38bb89c994fee22ffe654","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * \n\t * @param priority\n\t * @param internalPriorityCount\n\t * @param defaultPriority\n\t * @param invertOrder Set if the priorities are thread priorities. Unset if they are request priorities. D'oh!\n\t */\n\tpublic PrioritizedSerialExecutor(int priority, int internalPriorityCount, int defaultPriority, boolean invertOrder) {\n\t\tjobs = new LinkedList[internalPriorityCount];\n\t\tfor(int i=0;i<jobs.length;i++)\n\t\t\tjobs[i] = new LinkedList<Runnable>();\n\t\tthis.priority = priority;\n\t\tthis.defaultPriority = defaultPriority;\n\t\tthis.invertOrder = invertOrder;\n\t}","id":34776,"modified_method":"/**\n\t * \n\t * @param priority\n\t * @param internalPriorityCount\n\t * @param defaultPriority\n\t * @param invertOrder Set if the priorities are thread priorities. Unset if they are request priorities. D'oh!\n\t */\n\tpublic PrioritizedSerialExecutor(int priority, int internalPriorityCount, int defaultPriority, boolean invertOrder) {\n\t\tjobs = new LinkedList[internalPriorityCount];\n\t\tfor(int i=0;i<jobs.length;i++)\n\t\t\tjobs[i] = new LinkedList<Runnable>();\n\t\tjobCount = new int[internalPriorityCount];\n\t\tthis.priority = priority;\n\t\tthis.defaultPriority = defaultPriority;\n\t\tthis.invertOrder = invertOrder;\n\t}","commit_id":"cb30e61edb632f792dd38bb89c994fee22ffe654","url":"https://github.com/freenet/fred"},{"original_method":"public int getQueueSize(int priority) {\n\t\tsynchronized(jobs) {\n\t\t\treturn jobs[priority].size();\n\t\t}\n\t}","id":34777,"modified_method":"public int getQueueSize(int priority) {\n\t\tsynchronized(jobs) {\n\t\t\treturn jobCount[priority];\n\t\t}\n\t}","commit_id":"cb30e61edb632f792dd38bb89c994fee22ffe654","url":"https://github.com/freenet/fred"},{"original_method":"private Runnable checkQueue() {\n\t\t\tif(!invertOrder) {\n\t\t\t\tfor(int i=0;i<jobs.length;i++) {\n\t\t\t\t\tif(!jobs[i].isEmpty()) {\n\t\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\t\tLogger.minor(this, \"Chosen job at priority \"+i);\n\t\t\t\t\t\treturn (Runnable) jobs[i].removeFirst();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i=jobs.length-1;i>=0;i--) {\n\t\t\t\t\tif(!jobs[i].isEmpty()) {\n\t\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\t\tLogger.minor(this, \"Chosen job at priority \"+i);\n\t\t\t\t\t\treturn (Runnable) jobs[i].removeFirst();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","id":34778,"modified_method":"private Runnable checkQueue() {\n\t\t\tif(!invertOrder) {\n\t\t\t\tfor(int i=0;i<jobs.length;i++) {\n\t\t\t\t\tif(!jobs[i].isEmpty()) {\n\t\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\t\tLogger.minor(this, \"Chosen job at priority \"+i);\n\t\t\t\t\t\tsynchronized (jobs) {\n\t\t\t\t\t\t\tRunnable r = jobs[i].removeFirst();\n\t\t\t\t\t\t\tjobCount[i]--;\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i=jobs.length-1;i>=0;i--) {\n\t\t\t\t\tif(!jobs[i].isEmpty()) {\n\t\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\t\tLogger.minor(this, \"Chosen job at priority \"+i);\n\t\t\t\t\t\tsynchronized (jobs) {\n\t\t\t\t\t\t\tRunnable r = jobs[i].removeFirst();\n\t\t\t\t\t\t\tjobCount[i]--;\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","commit_id":"cb30e61edb632f792dd38bb89c994fee22ffe654","url":"https://github.com/freenet/fred"},{"original_method":"public void execute(Runnable job, int prio, String jobName) {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(jobs) {\n\t\t\tif(logMINOR) \n\t\t\t\tLogger.minor(this, \"Running \"+jobName+\" : \"+job+\" priority \"+prio+\" running=\"+running+\" waiting=\"+waiting);\n\t\t\tjobs[prio].addLast(job);\n\t\t\tjobs.notifyAll();\n\t\t\tif(!running && realExecutor != null) {\n\t\t\t\treallyStart(logMINOR);\n\t\t\t}\n\t\t}\n\t}","id":34779,"modified_method":"public void execute(Runnable job, int prio, String jobName) {\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(jobs) {\n\t\t\tif(logMINOR) \n\t\t\t\tLogger.minor(this, \"Running \"+jobName+\" : \"+job+\" priority \"+prio+\" running=\"+running+\" waiting=\"+waiting);\n\t\t\tjobs[prio].addLast(job);\n\t\t\tjobCount[prio]++;\n\t\t\tjobs.notifyAll();\n\t\t\tif(!running && realExecutor != null) {\n\t\t\t\treallyStart(logMINOR);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cb30e61edb632f792dd38bb89c994fee22ffe654","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Record that fact that the current thread has finished process operations\n     * for its current assignement\n     */\n    private synchronized void completeAssignment() {\n        // remove any existing reservation of the current thread\n        String previousAssignment = (String) fileAssignments.remove(Thread.currentThread());\n        if (previousAssignment != null)\n            reservedFiles.remove(previousAssignment);\n    }","id":34780,"modified_method":"/**\n     * Record that fact that the current thread has finished process operations\n     * for its current assignement\n     */\n    private synchronized void completeAssignment() {\n        // remove any existing reservation of the current thread\n        String previousAssignment = fileAssignments.remove(Thread.currentThread());\n        if (previousAssignment != null)\n            reservedFiles.remove(previousAssignment);\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void logLapTime(String message) {\n        log(message + \" \" + getLapTime());\n    }","id":34781,"modified_method":"void logLapTime(String message) {\n        log().debug(message + \" \" + getLapTime());\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the name of the next file with available work\n     */\n    private String selectNewAssignment() {\n        for (Iterator it = filesWithSignificantWork.iterator(); it.hasNext();) {\n            String fn = (String) it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        for (Iterator it = filesWithInsignificantWork.iterator(); it.hasNext();) {\n            String fn = (String) it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        return null;\n    }","id":34782,"modified_method":"/**\n     * Return the name of the next file with available work\n     */\n    private String selectNewAssignment() {\n        for (Iterator<String> it = filesWithSignificantWork.iterator(); it.hasNext();) {\n            String fn = it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        for (Iterator<String> it = filesWithInsignificantWork.iterator(); it.hasNext();) {\n            String fn = it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        return null;\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Actually process the operations be calling the underlying delegate\n     * strategy\n     */\n    private void processPendingOperations() {\n        Object rrd = null;\n        String fileName = null;\n\n        try {\n            LinkedList ops = getNext();\n            if (ops == null)\n                return;\n            // update stats correctly we update them even if an exception occurs\n            // while we are processing\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                if (op.isSignificant()) {\n                    significantOpsCompleted++;\n                }\n\n            }\n            // now we actually process the events\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                fileName = op.getFileName();\n                rrd = op.process(rrd);\n            }\n        } catch (Exception e) {\n            errors++;\n            logLapTime(\"Error updating file \" + fileName + \": \" + e.getMessage());\n            log(\"Error upading file \" + fileName + \": \" + e.getMessage(), e);\n        } finally {\n            processClose(rrd);\n        }\n    }","id":34783,"modified_method":"/**\n     * Actually process the operations be calling the underlying delegate\n     * strategy\n     */\n    private void processPendingOperations() {\n        Object rrd = null;\n        String fileName = null;\n\n        try {\n            LinkedList ops = getNext();\n            if (ops == null)\n                return;\n            // update stats correctly we update them even if an exception occurs\n            // while we are processing\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                if (op.isSignificant()) {\n                    significantOpsCompleted++;\n                }\n\n            }\n            // now we actually process the events\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                fileName = op.getFileName();\n                rrd = op.process(rrd);\n            }\n        } catch (Exception e) {\n            errors++;\n            logLapTime(\"Error updating file \" + fileName + \": \" + e.getMessage());\n            log().debug(\"Error upading file \" + fileName + \": \" + e.getMessage(), e);\n        } finally {\n            processClose(rrd);\n        }\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Category log() {\n        return Category.getInstance(LOG4J_CATEGORY);\n    }","id":34784,"modified_method":"private Category log() {\n        return Logger.getLogger(LOG4J_CATEGORY);\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"Object process(Object rrd) throws Exception {\n            // if the rrd is already open we are confused\n            if (rrd != null) {\n                log(\"WHAT! rrd open but not created?\");\n                m_delegate.closeFile(rrd);\n                rrd = null;\n            }\n\n            // create the file\n            m_delegate.createFile(getData());\n\n            // keep stats\n            ++createsCompleted;\n\n            // return the file\n            return rrd;\n\n        }","id":34785,"modified_method":"Object process(Object rrd) throws Exception {\n            // if the rrd is already open we are confused\n            if (rrd != null) {\n                log().debug(\"WHAT! rrd open but not created?\");\n                m_delegate.closeFile(rrd);\n                rrd = null;\n            }\n\n            // create the file\n            m_delegate.createFile(getData());\n\n            // keep stats\n            ++createsCompleted;\n\n            // return the file\n            return rrd;\n\n        }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void addToPendingList(LinkedList pendingOperations) {\n            if (pendingOperations.size() > 0 && pendingOperations.getLast() instanceof ZeroUpdateOperation) {\n                ZeroUpdateOperation zeroOp = (ZeroUpdateOperation) pendingOperations.getLast();\n                try {\n                    zeroOp.mergeUpdates(this);\n                } catch (IllegalArgumentException e) {\n                    log(e.getMessage());\n                    super.addToPendingList(pendingOperations);\n                }\n            } else {\n                super.addToPendingList(pendingOperations);\n            }\n        }","id":34786,"modified_method":"void addToPendingList(LinkedList<Operation> pendingOperations) {\n            if (pendingOperations.size() > 0 && pendingOperations.getLast() instanceof ZeroUpdateOperation) {\n                ZeroUpdateOperation zeroOp = (ZeroUpdateOperation) pendingOperations.getLast();\n                try {\n                    zeroOp.mergeUpdates(this);\n                } catch (IllegalArgumentException e) {\n                    log().debug(e.getMessage());\n                    super.addToPendingList(pendingOperations);\n                }\n            } else {\n                super.addToPendingList(pendingOperations);\n            }\n        }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * We need to track which files are being processed by which threads so that\n     * we don't try to process updates for the same file on more than one\n     * thread.\n     */\n    private synchronized void storeAssignment(Operation op) {\n        // look and see if there a pending ops list for this file\n        LinkedList pendingOperations = (LinkedList) pendingFileOperations.get(op.getFileName());\n\n        // if not then we create an ops list for the file and add the file to\n        // the work items list\n        if (pendingOperations == null) {\n            pendingOperations = new LinkedList();\n            pendingFileOperations.put(op.getFileName(), pendingOperations);\n\n            // add the file to the correct list based on what type of work we\n            // are adding.  (if we aren't prioritizing then every file is counted as\n            // signficant\n            if (!PRIORITIZE_SIGS || op.isSignificant())\n                filesWithSignificantWork.addLast(op.getFileName());\n            else\n                filesWithInsignificantWork.addLast(op.getFileName());\n        } else if (PRIORITIZE_SIGS && op.isSignificant() && hasOnlyInsignificant(pendingOperations)) {\n            // only do this when we are prioritizing as this bumps files from inSig\n            // up to insig\n            // promote the file to the significant list if this is the first\n            // significant\n            filesWithSignificantWork.addLast(op.getFileName());\n        }\n\n        promoteAgedFiles();\n\n        op.addToPendingList(pendingOperations);\n    }","id":34787,"modified_method":"/**\n     * We need to track which files are being processed by which threads so that\n     * we don't try to process updates for the same file on more than one\n     * thread.\n     */\n    private synchronized void storeAssignment(Operation op) {\n        // look and see if there a pending ops list for this file\n        LinkedList<Operation> pendingOperations = pendingFileOperations.get(op.getFileName());\n\n        // if not then we create an ops list for the file and add the file to\n        // the work items list\n        if (pendingOperations == null) {\n            pendingOperations = new LinkedList<Operation>();\n            pendingFileOperations.put(op.getFileName(), pendingOperations);\n\n            // add the file to the correct list based on what type of work we\n            // are adding.  (if we aren't prioritizing then every file is counted as\n            // signficant\n            if (!PRIORITIZE_SIGS || op.isSignificant())\n                filesWithSignificantWork.addLast(op.getFileName());\n            else\n                filesWithInsignificantWork.addLast(op.getFileName());\n        } else if (PRIORITIZE_SIGS && op.isSignificant() && hasOnlyInsignificant(pendingOperations)) {\n            // only do this when we are prioritizing as this bumps files from inSig\n            // up to insig\n            // promote the file to the significant list if this is the first\n            // significant\n            filesWithSignificantWork.addLast(op.getFileName());\n        }\n\n        promoteAgedFiles();\n\n        op.addToPendingList(pendingOperations);\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return true if and only if all the operations in the list are\n     * insignificant\n     */\n    private boolean hasOnlyInsignificant(LinkedList pendingOps) {\n        for (Iterator it = pendingOps.iterator(); it.hasNext();) {\n            Operation op = (Operation) it.next();\n            if (op.isSignificant()) {\n                return false;\n            }\n        }\n        return true;\n    }","id":34788,"modified_method":"/**\n     * Return true if and only if all the operations in the list are\n     * insignificant\n     */\n    private boolean hasOnlyInsignificant(LinkedList<Operation> pendingOps) {\n        for (Iterator<Operation> it = pendingOps.iterator(); it.hasNext();) {\n            Operation op = it.next();\n            if (op.isSignificant()) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Operation makeUpdateOperation(String fileName, String owner, String update) {\n        try {\n            int colon = update.indexOf(':');\n            if ((colon >= 0) && (Double.parseDouble(update.substring(colon + 1)) == 0.0)) {\n                long initialTimeStamp = Long.parseLong(update.substring(0, colon));\n                if (initialTimeStamp == 0)\n                    log(\"ZERO ERROR: created a zero update with ts=0 for file: \" + fileName + \" data: \" + update);\n\n                return new ZeroUpdateOperation(fileName, initialTimeStamp);\n            }\n        } catch (NumberFormatException e) {\n\n        }\n        return new UpdateOperation(fileName, update);\n    }","id":34789,"modified_method":"public Operation makeUpdateOperation(String fileName, String owner, String update) {\n        try {\n            int colon = update.indexOf(':');\n            if ((colon >= 0) && (Double.parseDouble(update.substring(colon + 1)) == 0.0)) {\n                long initialTimeStamp = Long.parseLong(update.substring(0, colon));\n                if (initialTimeStamp == 0)\n                    log().debug(\"ZERO ERROR: created a zero update with ts=0 for file: \" + fileName + \" data: \" + update);\n\n                return new ZeroUpdateOperation(fileName, initialTimeStamp);\n            }\n        } catch (NumberFormatException e) {\n\n        }\n        return new UpdateOperation(fileName, update);\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void addToPendingList(LinkedList pendingOperations) {\n            pendingOperations.add(this);\n        }","id":34790,"modified_method":"void addToPendingList(LinkedList<Operation> pendingOperations) {\n            pendingOperations.add(this);\n        }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Ensure that files with insignificant changes are getting promoted if\n     * necessary\n     * \n     */\n    private synchronized void promoteAgedFiles() {\n        \n        // no need to do this is we aren't prioritizing\n        if (!PRIORITIZE_SIGS) return;\n\n        // the num seconds to update files is 0 then use unfair prioritization\n        if (MAX_INSIG_UPDATE_SECONDS == 0 || filesWithInsignificantWork.isEmpty())\n            return;\n\n        // calculate the elapsed time we first queued updates\n        long now = System.currentTimeMillis();\n        long elapsedMillis = Math.max(now - updateStart, 1);\n\n        // calculate the milliseconds between promotions necessary to age\n        // insignificant files into\n        // the significant queue\n        double millisPerPromotion = ((MAX_INSIG_UPDATE_SECONDS * 1000.0) / filesWithInsignificantWork.size());\n\n        // calculate the number of millis since start until the next file needs\n        // to be promotoed\n        long nextPromotionMillis = (long) (millisPerPromotion * promotionCount);\n\n        // if more time has elapsed than the next promotion time then promote a\n        // file\n        if (elapsedMillis > nextPromotionMillis) {\n            String file = (String) filesWithInsignificantWork.removeFirst();\n            filesWithSignificantWork.addFirst(file);\n            promotionCount++;\n        }\n\n    }","id":34791,"modified_method":"/**\n     * Ensure that files with insignificant changes are getting promoted if\n     * necessary\n     * \n     */\n    private synchronized void promoteAgedFiles() {\n        \n        // no need to do this is we aren't prioritizing\n        if (!PRIORITIZE_SIGS) return;\n\n        // the num seconds to update files is 0 then use unfair prioritization\n        if (MAX_INSIG_UPDATE_SECONDS == 0 || filesWithInsignificantWork.isEmpty())\n            return;\n\n        // calculate the elapsed time we first queued updates\n        long now = System.currentTimeMillis();\n        long elapsedMillis = Math.max(now - updateStart, 1);\n\n        // calculate the milliseconds between promotions necessary to age\n        // insignificant files into\n        // the significant queue\n        double millisPerPromotion = ((MAX_INSIG_UPDATE_SECONDS * 1000.0) / filesWithInsignificantWork.size());\n\n        // calculate the number of millis since start until the next file needs\n        // to be promotoed\n        long nextPromotionMillis = (long) (millisPerPromotion * promotionCount);\n\n        // if more time has elapsed than the next promotion time then promote a\n        // file\n        if (elapsedMillis > nextPromotionMillis) {\n            String file = filesWithInsignificantWork.removeFirst();\n            filesWithSignificantWork.addFirst(file);\n            promotionCount++;\n        }\n\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void logLapTime(String message, Throwable t) {\n        log(message + \" \" + getLapTime(), t);\n    }","id":34792,"modified_method":"void logLapTime(String message, Throwable t) {\n        log().debug(message + \" \" + getLapTime(), t);\n    }","commit_id":"7286df238d33c158a970bbb51af5cec2ae2f72c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns a session for the given workspace from the pool of sessions or\n     * <code>null<\/code> if the pool is empty or has no sessions for the\n     * given workspace.\n     * <p>\n     * Any sessions checked while looking for a valid - live session for the\n     * correct workspace - session, which is not live or is attached to another\n     * than the requested workspace is logged out and removed from the pool.\n     * <p>\n     * This is of course only a poor man's clean up mechanism which has at least\n     * two flaws: (1) Sessions may remain in the pool for ever and (2) sessions\n     * are removed from the pool which just do not qulaify for the desired\n     * workspace but would qualify later. The reason for the second issue being\n     * no problem at the moment, is that the JCR adapter is attached to a single\n     * workspace and only during startup will the workspace name be different.\n     *\n     * @param workSpaceName The name of the workspace to which the sesion\n     *          retrieved from the pool must be attached.\n     *\n     * @return A live session for the given workspace from the pool or\n     *          <code>null<\/code> if no session for the workspace is available\n     *          from the pool.\n     */\n    private Session getFromPool(String workSpaceName) {\n        // check with pool\n        for (;;) {\n\n            // get a session from the, return if empty\n            Session session;\n            synchronized (this.idleSessions) {\n                if (this.idleSessions.isEmpty()) {\n                    log.debug(\"getFromPool: No idle session in pool\");\n                    this.poolMissCounter++;\n                    return null;\n                }\n\n                // get the first entry from the pool\n                session = (Session) this.idleSessions.removeFirst();\n            }\n\n            // check the session and the session's workspace\n            if (session.isLive()\n                    && session.getWorkspace().getName().equals(workSpaceName)) {\n                this.poolHitCounter++;\n                return this.createPooledSession(session);\n            }\n\n            // session is not alive anymore or has the wrong workspace name,\n            // logout and try next from pool\n            this.poolDropCounter++;\n            session.logout();\n        }\n    }","id":34793,"modified_method":"/**\n     * Returns a session for the given workspace from the pool of sessions or\n     * <code>null<\/code> if the pool is empty or has no sessions for the\n     * given workspace.\n     * <p>\n     * Any sessions checked while looking for a valid - live session for the\n     * correct workspace - session, which is not live or is attached to another\n     * than the requested workspace is logged out and removed from the pool.\n     * <p>\n     * This is of course only a poor man's clean up mechanism which has at least\n     * two flaws: (1) Sessions may remain in the pool for ever and (2) sessions\n     * are removed from the pool which just do not qulaify for the desired\n     * workspace but would qualify later. The reason for the second issue being\n     * no problem at the moment, is that the JCR adapter is attached to a single\n     * workspace and only during startup will the workspace name be different.\n     *\n     * @param workSpaceName The name of the workspace to which the sesion\n     *          retrieved from the pool must be attached.\n     *\n     * @return A live session for the given workspace from the pool or\n     *          <code>null<\/code> if no session for the workspace is available\n     *          from the pool.\n     */\n    private Session getFromPool(String workSpaceName) {\n        // check with pool\n        for (;;) {\n\n            // get a session from the, return if empty\n            Session session;\n            synchronized (this.idleSessions) {\n                if (this.idleSessions.isEmpty()) {\n                    log.debug(\"getFromPool: No idle session in pool\");\n                    this.poolMissCounter++;\n                    return null;\n                }\n\n                // get the first entry from the pool\n                session = this.idleSessions.removeFirst();\n            }\n\n            // check the session and the session's workspace\n            if (session.isLive()\n                    && session.getWorkspace().getName().equals(workSpaceName)) {\n                this.poolHitCounter++;\n                return this.createPooledSession(session);\n            }\n\n            // session is not alive anymore or has the wrong workspace name,\n            // logout and try next from pool\n            this.poolDropCounter++;\n            session.logout();\n        }\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Creates a new instance of this class presetting internal counters\n     * and data structures.\n     *\n     * @param repository The <code>Repository<\/code> to login to.\n     */\n    SessionPool(SessionPoolManager poolManager, SimpleCredentials credentials) {\n        this.poolManager = poolManager;\n        this.userName = credentials.getUserID();\n        this.passData = this.getPassData(credentials);\n        this.idleSessions = new LinkedList();\n        this.activeSessions = new IdentityHashMap();\n        this.activeSessionLock = new Object();\n        this.clearCounters();\n\n        // explicitly set the default value here, as the setConfig\n        // will not set the default if the configured value is <= 0\n        this.setMaxActiveSessionsWait(DEFAULT_MAX_ACTIVE_SESSIONS_WAIT);\n    }","id":34794,"modified_method":"/**\n     * Creates a new instance of this class presetting internal counters\n     * and data structures.\n     *\n     * @param repository The <code>Repository<\/code> to login to.\n     */\n    SessionPool(SessionPoolManager poolManager, SimpleCredentials credentials) {\n        this.poolManager = poolManager;\n        this.userName = credentials.getUserID();\n        this.passData = this.getPassData(credentials);\n        this.idleSessions = new LinkedList<Session>();\n        this.activeSessions = new IdentityHashMap<PooledSession, Session>();\n        this.activeSessionLock = new Object();\n        this.clearCounters();\n\n        // explicitly set the default value here, as the setConfig\n        // will not set the default if the configured value is <= 0\n        this.setMaxActiveSessionsWait(DEFAULT_MAX_ACTIVE_SESSIONS_WAIT);\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Releases the repository session encapsulated by the {@link PooledSession}\n     * to the pool or logs the session out if it is not live any more or the\n     * maximum number of idle sessions in this pool has been reached.\n     * <p>\n     * This method also notifies any threads waiting for the number active\n     * sessions to drop below the maximum number of sessions.\n     * <p>\n     * This method is called by the {@link PooledSession#logout()} method to\n     * release the session.\n     *\n     * @param pooledSession The {@link PooledSession} to release.\n     */\n    void release(PooledSession pooledSession) {\n        // remove the pooled session. If it is not in the activeSessions\n        // map, it has been removed by one of the acquireSession methods\n        // due to changed passwords. In this case, the delegate session\n        // is not idled but immediately logged out\n        boolean forcedLogout;\n        synchronized (this.activeSessions) {\n            forcedLogout = this.activeSessions.remove(pooledSession) == null;\n        }\n\n        synchronized (this.activeSessionLock) {\n            this.activeSessionLock.notifyAll();\n        }\n\n        // unwrap the repository session\n        Session session = pooledSession.getSession();\n\n        // cache the session owner for messages and more\n        String userId = session.getUserID();\n\n        // if the session is to be logged out forcibly\n        if (forcedLogout) {\n            log.debug(\"Logging out session {}; password has changed\", userId);\n            session.logout();\n            return;\n        }\n\n        // if the pool has been disposed off, the session will be logged out\n        if (this.isDisposed()) {\n            log.debug(\"Logging out session {}; pool has been disposed off\",\n                userId);\n            session.logout();\n            return;\n        }\n\n        // if the pool is full or the session is already dead, logout and return\n        // this results in the session not being added to the pool\n        if (this.idleSessions.size() >= this.getMaxIdleSessions() || !session.isLive()) {\n            log.debug(\"Logging out session {}; pool is full or session is not alive\",\n                userId);\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n        // if the session has locks, we logout the session and drop it,\n        // as there is no easy way of finding the temporary locks and\n        // unlocking them, we could use the search, however ???\n        try {\n            QueryManager qm = session.getWorkspace().getQueryManager();\n            Query q = qm.createQuery(\n                \"/jcr:root//element(*,mix:lockable)[@jcr:lockOwner='\"\n                    + session.getUserID() + \"']\", Query.XPATH);\n            NodeIterator ni = q.execute().getNodes();\n            while (ni.hasNext()) {\n                Node node = ni.nextNode();\n                String path = node.getPath();\n                Lock lock = node.getLock();\n                if (lock.getLockToken() == null) {\n                    log.debug(\"Ignoring lock on {} held by {}, not held by this session\",\n                        path, userId);\n                } else if (lock.isSessionScoped()) {\n                    log.info(\"Unlocking session-scoped lock on {} held by {}\",\n                        path, userId);\n                    node.unlock();\n                } else {\n                    log.warn(\"Dropping lock token of permanent lock on {} held by {}\",\n                        path, userId);\n                    session.removeLockToken(lock.getLockToken());\n                }\n            }\n\n            String[] lockTokens = session.getLockTokens();\n            if (lockTokens != null && lockTokens.length > 0) {\n                log.warn(\"Session still has lock tokens !\");\n                for (int i=0; i < lockTokens.length; i++) {\n                    log.warn(\"Dropping lock token {} held by {}\",\n                        lockTokens[i], userId);\n                    session.removeLockToken(lockTokens[i]);\n                }\n            }\n        } catch (RepositoryException re) {\n            log.info(\"Cannot cleanup lockes of session {}, logging out\", userId);\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n\n        // make sure the session has no more registered event listeners which\n        // may be notified on changes, and - worse - prevent the objects from\n        // being collected\n        try {\n            ObservationManager om = session.getWorkspace().getObservationManager();\n            EventListenerIterator eli = om.getRegisteredEventListeners();\n            if (eli.hasNext()) {\n                log.debug(\"Unregistering remaining EventListeners of {}\", userId);\n                while (eli.hasNext()) {\n                    EventListener el = (EventListener) eli.next();\n                    om.removeEventListener(el);\n                }\n            }\n        } catch (RepositoryException re) {\n            log.info(\"Cannot check or unregister event listeners of session \" +\n                \"{}, logging out\", userId);\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n        // Otherwise clean up the session if there are any pending changes.\n        // Those changes are not persisted, but dropped. If this fails, the\n        // session is logged out and not returned/added to the pool\n        try {\n            if (session.hasPendingChanges()) {\n                session.refresh(false);\n            }\n        } catch (RepositoryException re) {\n            log.info(\"Cannot check or drop pending changes of session \" +\n                \"{}, logging out\", userId);\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n        // now the session is \"clean\" and may be added to the pool\n        log.debug(\"Returning session {} to the pool, now with {} entries\",\n            userId, new Integer(this.idleSessions.size()));\n\n        // add to the pool and notify waiting session acquiry\n        //    ==> checkActiveSessions()\n        synchronized (this.idleSessions) {\n            this.idleSessions.add(session);\n        }\n    }","id":34795,"modified_method":"/**\n     * Releases the repository session encapsulated by the {@link PooledSession}\n     * to the pool or logs the session out if it is not live any more or the\n     * maximum number of idle sessions in this pool has been reached.\n     * <p>\n     * This method also notifies any threads waiting for the number active\n     * sessions to drop below the maximum number of sessions.\n     * <p>\n     * This method is called by the {@link PooledSession#logout()} method to\n     * release the session.\n     *\n     * @param pooledSession The {@link PooledSession} to release.\n     */\n    void release(PooledSession pooledSession) {\n        // remove the pooled session. If it is not in the activeSessions\n        // map, it has been removed by one of the acquireSession methods\n        // due to changed passwords. In this case, the delegate session\n        // is not idled but immediately logged out\n        boolean forcedLogout;\n        synchronized (this.activeSessions) {\n            forcedLogout = this.activeSessions.remove(pooledSession) == null;\n        }\n\n        synchronized (this.activeSessionLock) {\n            this.activeSessionLock.notifyAll();\n        }\n\n        // unwrap the repository session\n        Session session = pooledSession.getSession();\n\n        // cache the session owner for messages and more\n        String userId = session.getUserID();\n\n        // if the session is to be logged out forcibly\n        if (forcedLogout) {\n            log.debug(\"Logging out session {}; password has changed\", userId);\n            session.logout();\n            return;\n        }\n\n        // if the pool has been disposed off, the session will be logged out\n        if (this.isDisposed()) {\n            log.debug(\"Logging out session {}; pool has been disposed off\",\n                userId);\n            session.logout();\n            return;\n        }\n\n        // if the pool is full or the session is already dead, logout and return\n        // this results in the session not being added to the pool\n        if (this.idleSessions.size() >= this.getMaxIdleSessions() || !session.isLive()) {\n            log.debug(\"Logging out session {}; pool is full or session is not alive\",\n                userId);\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n        // if the session has locks, we logout the session and drop it,\n        // as there is no easy way of finding the temporary locks and\n        // unlocking them, we could use the search, however ???\n        try {\n            QueryManager qm = session.getWorkspace().getQueryManager();\n            Query q = qm.createQuery(\n                \"/jcr:root//element(*,mix:lockable)[@jcr:lockOwner='\"\n                    + session.getUserID() + \"']\", Query.XPATH);\n            NodeIterator ni = q.execute().getNodes();\n            while (ni.hasNext()) {\n                Node node = ni.nextNode();\n                String path = node.getPath();\n                Lock lock = node.getLock();\n                if (lock.getLockToken() == null) {\n                    log.debug(\"Ignoring lock on {} held by {}, not held by this session\",\n                        path, userId);\n                } else if (lock.isSessionScoped()) {\n                    log.info(\"Unlocking session-scoped lock on {} held by {}\",\n                        path, userId);\n                    node.unlock();\n                } else {\n                    log.warn(\"Dropping lock token of permanent lock on {} held by {}\",\n                        path, userId);\n                    session.removeLockToken(lock.getLockToken());\n                }\n            }\n\n            String[] lockTokens = session.getLockTokens();\n            if (lockTokens != null && lockTokens.length > 0) {\n                log.warn(\"Session still has lock tokens !\");\n                for (int i=0; i < lockTokens.length; i++) {\n                    log.warn(\"Dropping lock token {} held by {}\",\n                        lockTokens[i], userId);\n                    session.removeLockToken(lockTokens[i]);\n                }\n            }\n        } catch (RepositoryException re) {\n            if ( log.isDebugEnabled() ) {\n                log.debug(\"Cannot cleanup lockes of session \" + userId + \", logging out\", re);\n            } else {\n                log.info(\"Cannot cleanup lockes of session {}, logging out\", userId);\n            }\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n\n        // make sure the session has no more registered event listeners which\n        // may be notified on changes, and - worse - prevent the objects from\n        // being collected\n        try {\n            ObservationManager om = session.getWorkspace().getObservationManager();\n            EventListenerIterator eli = om.getRegisteredEventListeners();\n            if (eli.hasNext()) {\n                log.debug(\"Unregistering remaining EventListeners of {}\", userId);\n                while (eli.hasNext()) {\n                    EventListener el = (EventListener) eli.next();\n                    om.removeEventListener(el);\n                }\n            }\n        } catch (RepositoryException re) {\n            log.info(\"Cannot check or unregister event listeners of session \" +\n                \"{}, logging out\", userId);\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n        // Otherwise clean up the session if there are any pending changes.\n        // Those changes are not persisted, but dropped. If this fails, the\n        // session is logged out and not returned/added to the pool\n        try {\n            if (session.hasPendingChanges()) {\n                session.refresh(false);\n            }\n        } catch (RepositoryException re) {\n            log.info(\"Cannot check or drop pending changes of session \" +\n                \"{}, logging out\", userId);\n            this.poolDropCounter++;\n            session.logout();\n            return;\n        }\n\n        // now the session is \"clean\" and may be added to the pool\n        log.debug(\"Returning session {} to the pool, now with {} entries\",\n            userId, new Integer(this.idleSessions.size()));\n\n        // add to the pool and notify waiting session acquiry\n        //    ==> checkActiveSessions()\n        synchronized (this.idleSessions) {\n            this.idleSessions.add(session);\n        }\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"private void logoutSessions(Iterator sessions) {\n        // logout all sessions in the pool\n        while (sessions.hasNext()) {\n            Session session = (Session) sessions.next();\n            try {\n                if (session.isLive()) {\n                    session.logout();\n                }\n            } catch (Exception e) {\n                log.warn(\"Unexpected problem logging out session \"\n                    + session.getUserID(), e);\n            }\n        }\n    }","id":34796,"modified_method":"private void logoutSessions(Iterator<Session> sessions) {\n        // logout all sessions in the pool\n        while (sessions.hasNext()) {\n            Session session = sessions.next();\n            try {\n                if (session.isLive()) {\n                    session.logout();\n                }\n            } catch (Exception e) {\n                log.warn(\"Unexpected problem logging out session \"\n                    + session.getUserID(), e);\n            }\n        }\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"public void dispose() {\n        if (sessionPools != null) {\n            for (Iterator si = sessionPools.values().iterator(); si.hasNext();) {\n                SessionPool pool = (SessionPool) si.next();\n                pool.dispose();\n            }\n            sessionPools.clear();\n        }\n    }","id":34797,"modified_method":"public void dispose() {\n        if (this.sessionPools != null) {\n            for (Iterator<SessionPool> si = this.sessionPools.values().iterator(); si.hasNext();) {\n                SessionPool pool = si.next();\n                pool.dispose();\n            }\n            this.sessionPools.clear();\n        }\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"public Session login(Credentials credentials, String workspace)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // get the session pool for the credentials\n        if (credentials instanceof SimpleCredentials) {\n            SimpleCredentials simple = (SimpleCredentials) credentials;\n            SessionPool pool = getPool(simple);\n            if (pool != null) {\n                return pool.acquireSession(simple, workspace);\n            }\n        }\n\n        // direct session, if no pool is available for the credentials\n        return getRepository().login(credentials, workspace);\n    }","id":34798,"modified_method":"public Session login(Credentials credentials, String workspace)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // get the session pool for the credentials\n        if (credentials instanceof SimpleCredentials) {\n            SimpleCredentials simple = (SimpleCredentials) credentials;\n            SessionPool pool = this.getPool(simple);\n            if (pool != null) {\n                return pool.acquireSession(simple, workspace);\n            }\n        }\n\n        // direct session, if no pool is available for the credentials\n        return this.getRepository().login(credentials, workspace);\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"Repository getRepository() {\n        return repository;\n    }","id":34799,"modified_method":"Repository getRepository() {\n        return this.repository;\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"private SessionPool getPool(SimpleCredentials credentials) {\n        String userName = credentials.getUserID();\n        SessionPool pool = (SessionPool) sessionPools.get(userName);\n        if (pool == null) {\n            // create and configure the new pool\n            pool = new SessionPool(this, credentials);\n            pool.setMaxActiveSessions(poolMaxActiveSessions);\n            pool.setMaxActiveSessionsWait(poolMaxActiveSessionsWait);\n            pool.setMaxIdleSessions(poolMaxIdleSessions);\n            sessionPools.put(userName, pool);\n        }\n\n        return pool;\n    }","id":34800,"modified_method":"private SessionPool getPool(SimpleCredentials credentials) {\n        String userName = credentials.getUserID();\n        SessionPool pool = this.sessionPools.get(userName);\n        if (pool == null) {\n            // create and configure the new pool\n            pool = new SessionPool(this, credentials);\n            pool.setMaxActiveSessions(this.poolMaxActiveSessions);\n            pool.setMaxActiveSessionsWait(this.poolMaxActiveSessionsWait);\n            pool.setMaxIdleSessions(this.poolMaxIdleSessions);\n            this.sessionPools.put(userName, pool);\n        }\n\n        return pool;\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"public SessionPoolManager(Repository repository, int maxActiveSessions,\n            int maxActiveSessionsWait, int maxIdleSessions) {\n\n        this.repository = repository;\n        this.sessionPools = new HashMap();\n\n        // default session pool configuration (actual values will be checked\n        // for validity by the SessionPool instances themselves when\n        // configuring)\n        poolMaxActiveSessions = maxActiveSessions;\n        poolMaxActiveSessionsWait = maxActiveSessionsWait;\n        poolMaxIdleSessions = maxIdleSessions;\n    }","id":34801,"modified_method":"public SessionPoolManager(Repository repository, int maxActiveSessions,\n            int maxActiveSessionsWait, int maxIdleSessions) {\n\n        this.repository = repository;\n        this.sessionPools = new HashMap<String, SessionPool>();\n\n        // default session pool configuration (actual values will be checked\n        // for validity by the SessionPool instances themselves when\n        // configuring)\n        this.poolMaxActiveSessions = maxActiveSessions;\n        this.poolMaxActiveSessionsWait = maxActiveSessionsWait;\n        this.poolMaxIdleSessions = maxIdleSessions;\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"Session impersonate(Session baseSession, Credentials credentials)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // assert base session is live\n        if (!baseSession.isLive()) {\n            throw new RepositoryException(\n                \"Base Session is not alive, cannot impersonate\");\n        }\n\n        if (credentials instanceof SimpleCredentials) {\n            SessionPool pool = getPool((SimpleCredentials) credentials);\n            if (pool != null) {\n                return pool.acquireSession(baseSession, credentials);\n            }\n        }\n\n        // no pool available for the credentials, use direct session\n        return baseSession.impersonate(credentials);\n    }","id":34802,"modified_method":"Session impersonate(Session baseSession, Credentials credentials)\n            throws LoginException, NoSuchWorkspaceException,\n            RepositoryException {\n\n        // assert base session is live\n        if (!baseSession.isLive()) {\n            throw new RepositoryException(\n                \"Base Session is not alive, cannot impersonate\");\n        }\n\n        if (credentials instanceof SimpleCredentials) {\n            SessionPool pool = this.getPool((SimpleCredentials) credentials);\n            if (pool != null) {\n                return pool.acquireSession(baseSession, credentials);\n            }\n        }\n\n        // no pool available for the credentials, use direct session\n        return baseSession.impersonate(credentials);\n    }","commit_id":"f22c375fde0e141fc59eb62bdba7c0ce05170146","url":"https://github.com/apache/sling"},{"original_method":"private void clear(LinkedList<UndoableGroup> stack) {\n    for (Iterator each = stack.iterator(); each.hasNext();) {\n      UndoableGroup undoableGroup = (UndoableGroup)each.next();\n      undoableGroup.dispose();\n    }\n    stack.clear();\n  }","id":34803,"modified_method":"private void clear(LinkedList<UndoableGroup> stack) {\n    for (UndoableGroup undoableGroup : stack) {\n      undoableGroup.dispose();\n    }\n    stack.clear();\n  }","commit_id":"315977d63db7c877bbdadb4c4750a1db1f951d46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Set<DocumentReference> getDocsInGlobalQueue() {\n    HashSet<DocumentReference> result = new HashSet<DocumentReference>();\n    for (Iterator<UndoableGroup> iterator = getGlobalStack().iterator(); iterator.hasNext();) {\n      UndoableGroup group = iterator.next();\n      result.addAll(group.getAffectedDocuments());\n    }\n    return result;\n  }","id":34804,"modified_method":"public Set<DocumentReference> getDocsInGlobalQueue() {\n    HashSet<DocumentReference> result = new HashSet<DocumentReference>();\n    for (UndoableGroup group : getGlobalStack()) {\n      result.addAll(group.getAffectedDocuments());\n    }\n    return result;\n  }","commit_id":"315977d63db7c877bbdadb4c4750a1db1f951d46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void clearEditorStack(FileEditor editor) {\n    Document[] documents = TextEditorProvider.getDocuments(editor);\n    for (int i = 0; i < documents.length; i++) {\n      clear(getStack(DocumentReferenceByDocument.createDocumentReference(documents[i])));\n    }\n\n  }","id":34805,"modified_method":"public void clearEditorStack(FileEditor editor) {\n    Document[] documents = TextEditorProvider.getDocuments(editor);\n    for (Document document : documents) {\n      clear(getStack(DocumentReferenceByDocument.createDocumentReference(document)));\n    }\n\n  }","commit_id":"315977d63db7c877bbdadb4c4750a1db1f951d46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addToStack(LinkedList stack, UndoableGroup commandInfo, int limit) {\n    stack.addLast(commandInfo);\n    while (stack.size() > limit) {\n      UndoableGroup undoableGroup = (UndoableGroup)stack.removeFirst();\n      undoableGroup.dispose();\n    }\n  }","id":34806,"modified_method":"private void addToStack(LinkedList<UndoableGroup> stack, UndoableGroup commandInfo, int limit) {\n    stack.addLast(commandInfo);\n    while (stack.size() > limit) {\n      UndoableGroup undoableGroup = stack.removeFirst();\n      undoableGroup.dispose();\n    }\n  }","commit_id":"315977d63db7c877bbdadb4c4750a1db1f951d46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection<DocumentReference> getGlobalStackAffectedDocuments() {\n    Collection<DocumentReference> result = new HashSet<DocumentReference>();\n    for (Iterator each = myGlobalStack.iterator(); each.hasNext();) {\n      UndoableGroup undoableGroup = (UndoableGroup)each.next();\n      result.addAll(undoableGroup.getAffectedDocuments());\n    }\n    return result;\n  }","id":34807,"modified_method":"public Collection<DocumentReference> getGlobalStackAffectedDocuments() {\n    Collection<DocumentReference> result = new HashSet<DocumentReference>();\n    for (UndoableGroup undoableGroup : myGlobalStack) {\n      result.addAll(undoableGroup.getAffectedDocuments());\n    }\n    return result;\n  }","commit_id":"315977d63db7c877bbdadb4c4750a1db1f951d46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Handle an unmatched FNPSwapComplete\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapComplete(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n        if(logMINOR) Logger.minor(this, \"handleSwapComplete(\"+uid+ ')');\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(uid);\n        if(item == null) {\n        \tif(logMINOR) Logger.minor(this, \"Item not found: \"+uid+\": \"+m);\n            return false;\n        }\n        if(item.requestSender == null) {\n        \tif(logMINOR) Logger.minor(this, \"Not matched \"+uid+\": \"+m);\n            return false;\n        }\n        if(item.routedTo == null) {\n            Logger.error(this, \"Got SwapComplete on \"+uid+\" but routedTo == null! (meaning we accepted it, presumably)\");\n            return false;\n        }\n        if(source != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapComplete \"+uid+\" from \"+source+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        try {\n            item.requestSender.sendAsync(m, null, this);\n        } catch (NotConnectedException e) {\n            Logger.normal(this, \"Lost connection forwarding SwapComplete \"+uid+\" to \"+item.requestSender);\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        removeRecentlyForwardedItem(item);\n        spyOnLocations(m, false);\n        return true;\n    }","id":34808,"modified_method":"/**\n     * Handle an unmatched FNPSwapComplete\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapComplete(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n        if(logMINOR) Logger.minor(this, \"handleSwapComplete(\"+uid+ ')');\n        RecentlyForwardedItem item = recentlyForwardedIDs.get(uid);\n        if(item == null) {\n        \tif(logMINOR) Logger.minor(this, \"Item not found: \"+uid+\": \"+m);\n            return false;\n        }\n        if(item.requestSender == null) {\n        \tif(logMINOR) Logger.minor(this, \"Not matched \"+uid+\": \"+m);\n            return false;\n        }\n        if(item.routedTo == null) {\n            Logger.error(this, \"Got SwapComplete on \"+uid+\" but routedTo == null! (meaning we accepted it, presumably)\");\n            return false;\n        }\n        if(source != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapComplete \"+uid+\" from \"+source+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        try {\n            item.requestSender.sendAsync(m, null, this);\n        } catch (NotConnectedException e) {\n            Logger.normal(this, \"Lost connection forwarding SwapComplete \"+uid+\" to \"+item.requestSender);\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        removeRecentlyForwardedItem(item);\n        spyOnLocations(m, false);\n        return true;\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Unlock the node for swapping.\n     * @param logSwapTime If true, log the swap time. */\n    void unlock(boolean logSwapTime) {\n    \tMessage nextMessage;\n    \tsynchronized(this) {\n        if(!locked)\n            throw new IllegalStateException(\"Unlocking when not locked!\");\n        long lockTime = System.currentTimeMillis() - lockedTime;\n        if(logMINOR) {\n        \tLogger.minor(this, \"Unlocking on port \"+node.getDarknetPortNumber());\n        \tLogger.minor(this, \"lockTime: \"+lockTime);\n        }\n        averageSwapTime.report(lockTime);\n        \n        if(incomingMessageQueue.isEmpty()) {\n        \tlocked = false;\n        \treturn;\n        }\n        \n        // Otherwise, stay locked, and start the next one from the queue.\n        \n        nextMessage = (Message) incomingMessageQueue.removeFirst();\n        lockedTime = System.currentTimeMillis();\n        \n    \t}\n    \t\n        long oldID = nextMessage.getLong(DMT.UID);\n        long newID = oldID+1;\n        PeerNode pn = (PeerNode) nextMessage.getSource();\n\n    \tinnerHandleSwapRequest(oldID, newID, pn, nextMessage);\n    }","id":34809,"modified_method":"/**\n     * Unlock the node for swapping.\n     * @param logSwapTime If true, log the swap time. */\n    void unlock(boolean logSwapTime) {\n    \tMessage nextMessage;\n    \tsynchronized(this) {\n        if(!locked)\n            throw new IllegalStateException(\"Unlocking when not locked!\");\n        long lockTime = System.currentTimeMillis() - lockedTime;\n        if(logMINOR) {\n        \tLogger.minor(this, \"Unlocking on port \"+node.getDarknetPortNumber());\n        \tLogger.minor(this, \"lockTime: \"+lockTime);\n        }\n        averageSwapTime.report(lockTime);\n        \n        if(incomingMessageQueue.isEmpty()) {\n        \tlocked = false;\n        \treturn;\n        }\n        \n        // Otherwise, stay locked, and start the next one from the queue.\n        \n        nextMessage = incomingMessageQueue.removeFirst();\n        lockedTime = System.currentTimeMillis();\n        \n    \t}\n    \t\n        long oldID = nextMessage.getLong(DMT.UID);\n        long newID = oldID+1;\n        PeerNode pn = (PeerNode) nextMessage.getSource();\n\n    \tinnerHandleSwapRequest(oldID, newID, pn, nextMessage);\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"void removeTooOldQueuedItems() {\n    \twhile(true) {\n    \t\tMessage first;\n    \t\tsynchronized(this) {\n    \t\t\tif(incomingMessageQueue.isEmpty()) return;\n    \t\t\tfirst = (Message) incomingMessageQueue.getFirst();\n    \t\t\tif(first.age() < MAX_TIME_ON_INCOMING_QUEUE) return;\n    \t\t\tincomingMessageQueue.removeFirst();\n    \t\t\tif(logMINOR) Logger.minor(this, \"Cancelling queued item: \"+first+\" - too long on queue, maybe circular waiting?\");\n    \t\t\tswapsRejectedAlreadyLocked++;\n    \t\t}\n            long oldID = first.getLong(DMT.UID);\n            PeerNode pn = (PeerNode) first.getSource();\n            \n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e1) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection rejecting SwapRequest (locked) from \"+pn);\n            }\n    \t}\n    }","id":34810,"modified_method":"void removeTooOldQueuedItems() {\n    \twhile(true) {\n    \t\tMessage first;\n    \t\tsynchronized(this) {\n    \t\t\tif(incomingMessageQueue.isEmpty()) return;\n    \t\t\tfirst = incomingMessageQueue.getFirst();\n    \t\t\tif(first.age() < MAX_TIME_ON_INCOMING_QUEUE) return;\n    \t\t\tincomingMessageQueue.removeFirst();\n    \t\t\tif(logMINOR) Logger.minor(this, \"Cancelling queued item: \"+first+\" - too long on queue, maybe circular waiting?\");\n    \t\t\tswapsRejectedAlreadyLocked++;\n    \t\t}\n            long oldID = first.getLong(DMT.UID);\n            PeerNode pn = (PeerNode) first.getSource();\n            \n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e1) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection rejecting SwapRequest (locked) from \"+pn);\n            }\n    \t}\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"public void clearOldSwapChains() {\n        long now = System.currentTimeMillis();\n        synchronized(recentlyForwardedIDs) {\n            RecentlyForwardedItem[] items = new RecentlyForwardedItem[recentlyForwardedIDs.size()];\n            if(items.length < 1)\n            \treturn;\n            items = (RecentlyForwardedItem[]) recentlyForwardedIDs.values().toArray(items);\n            for(int i=0;i<items.length;i++) {\n                if(now - items[i].lastMessageTime > (TIMEOUT*2)) {\n                    removeRecentlyForwardedItem(items[i]);\n                }\n            }\n        }\n    }","id":34811,"modified_method":"public void clearOldSwapChains() {\n        long now = System.currentTimeMillis();\n        synchronized(recentlyForwardedIDs) {\n            RecentlyForwardedItem[] items = new RecentlyForwardedItem[recentlyForwardedIDs.size()];\n            if(items.length < 1)\n            \treturn;\n            items = recentlyForwardedIDs.values().toArray(items);\n            for(int i=0;i<items.length;i++) {\n                if(now - items[i].lastMessageTime > (TIMEOUT*2)) {\n                    removeRecentlyForwardedItem(items[i]);\n                }\n            }\n        }\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * We lost the connection to a node, or it was restarted.\n     */\n    public void lostOrRestartedNode(PeerNode pn) {\n        Vector v = new Vector();\n        synchronized(recentlyForwardedIDs) {\n        \tSet entrySet = recentlyForwardedIDs.entrySet();\n\t\t\tIterator it = entrySet.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tMap.Entry entry = (Map.Entry) it.next();\n\t\t\t\tLong l = (Long) entry.getKey();\n\n\t\t\t\tRecentlyForwardedItem item = (RecentlyForwardedItem) entry.getValue();\n\t\t\t\t\n                if(item == null) {\n                \tLogger.error(this, \"Key is \"+l+\" but no value on recentlyForwardedIDs - shouldn't be possible\");\n                \tcontinue;\n                }\n                if(item.routedTo != pn) continue;\n                if(item.successfullyForwarded) {\n                    v.add(item);\n                }\n            }\n\t\t\t\n\t\t\t// remove them\n\t\t\tIterator it2 = v.iterator();\n\t\t\twhile (it2.hasNext())\n\t\t\t\tremoveRecentlyForwardedItem((RecentlyForwardedItem) it2.next());\n        }\n\t\tint dumped=v.size();\n\t\tif (dumped!=0 && logMINOR)\n\t\t\tLogger.minor(this, \"lostOrRestartedNode dumping \"+dumped+\" swap requests for \"+pn.getPeer());\n        for(int i=0;i<dumped;i++) {\n            RecentlyForwardedItem item = (RecentlyForwardedItem) v.get(i);\n            // Just reject it to avoid locking problems etc\n            Message msg = DMT.createFNPSwapRejected(item.incomingID);\n            if(logMINOR) Logger.minor(this, \"Rejecting in lostOrRestartedNode: \"+item.incomingID+ \" from \"+item.requestSender);\n            try {\n                item.requestSender.sendAsync(msg, null, this);\n            } catch (NotConnectedException e1) {\n                Logger.normal(this, \"Both sender and receiver disconnected for \"+item);\n            }\n        }\n    }","id":34812,"modified_method":"/**\n     * We lost the connection to a node, or it was restarted.\n     */\n    public void lostOrRestartedNode(PeerNode pn) {\n        List<RecentlyForwardedItem> v = new ArrayList<RecentlyForwardedItem>();\n        synchronized(recentlyForwardedIDs) {\n        \tSet<Map.Entry<Long, RecentlyForwardedItem>> entrySet = recentlyForwardedIDs.entrySet();\n\t\t\tfor (Map.Entry<Long, RecentlyForwardedItem> entry : entrySet) {\n\t\t\t\tLong l = entry.getKey();\n\t\t\t\tRecentlyForwardedItem item = entry.getValue();\n\t\t\t\t\n                if(item == null) {\n                \tLogger.error(this, \"Key is \"+l+\" but no value on recentlyForwardedIDs - shouldn't be possible\");\n                \tcontinue;\n                }\n                if(item.routedTo != pn) continue;\n                if(item.successfullyForwarded) {\n                    v.add(item);\n                }\n            }\n\t\t\t\n\t\t\t// remove them\n\t\t\tfor (RecentlyForwardedItem item : v)\n\t\t\t\tremoveRecentlyForwardedItem(item);\n        }\n\t\tint dumped=v.size();\n\t\tif (dumped!=0 && logMINOR)\n\t\t\tLogger.minor(this, \"lostOrRestartedNode dumping \"+dumped+\" swap requests for \"+pn.getPeer());\n        for(RecentlyForwardedItem item : v) {\n            // Just reject it to avoid locking problems etc\n            Message msg = DMT.createFNPSwapRejected(item.incomingID);\n            if(logMINOR) Logger.minor(this, \"Rejecting in lostOrRestartedNode: \"+item.incomingID+ \" from \"+item.requestSender);\n            try {\n                item.requestSender.sendAsync(msg, null, this);\n            } catch (NotConnectedException e1) {\n                Logger.normal(this, \"Both sender and receiver disconnected for \"+item);\n            }\n        }\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an unmatched FNPSwapReply\n     * @return True if we recognized and forwarded this reply.\n     */\n    public boolean handleSwapReply(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n\t\tRecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(uid);\n        if(item == null) {\n            Logger.error(this, \"Unrecognized SwapReply: ID \"+uid);\n            return false;\n        }\n        if(item.requestSender == null) {\n        \tif(logMINOR) Logger.minor(this, \"SwapReply from \"+source+\" on chain originated locally \"+uid);\n            return false;\n        }\n        if(item.routedTo == null) {\n            Logger.error(this, \"Got SwapReply on \"+uid+\" but routedTo is null!\");\n            return false;\n        }\n        if(source != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapReply \"+uid+\" from \"+source+\" to \"+item.requestSender);\n        try {\n            item.requestSender.sendAsync(m, null, this);\n        } catch (NotConnectedException e) {\n        \tif(logMINOR) Logger.minor(this, \"Lost connection forwarding SwapReply \"+uid+\" to \"+item.requestSender);\n        }\n        return true;\n    }","id":34813,"modified_method":"/**\n     * Handle an unmatched FNPSwapReply\n     * @return True if we recognized and forwarded this reply.\n     */\n    public boolean handleSwapReply(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n\t\tRecentlyForwardedItem item = recentlyForwardedIDs.get(uid);\n        if(item == null) {\n            Logger.error(this, \"Unrecognized SwapReply: ID \"+uid);\n            return false;\n        }\n        if(item.requestSender == null) {\n        \tif(logMINOR) Logger.minor(this, \"SwapReply from \"+source+\" on chain originated locally \"+uid);\n            return false;\n        }\n        if(item.routedTo == null) {\n            Logger.error(this, \"Got SwapReply on \"+uid+\" but routedTo is null!\");\n            return false;\n        }\n        if(source != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapReply \"+uid+\" from \"+source+\" to \"+item.requestSender);\n        try {\n            item.requestSender.sendAsync(m, null, this);\n        } catch (NotConnectedException e) {\n        \tif(logMINOR) Logger.minor(this, \"Lost connection forwarding SwapReply \"+uid+\" to \"+item.requestSender);\n        }\n        return true;\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an incoming SwapRequest\n     * @return True if we have handled the message, false if it needs\n     * to be handled otherwise.\n     */\n    public boolean handleSwapRequest(Message m, PeerNode pn) {\n        final long oldID = m.getLong(DMT.UID);\n        final long newID = oldID + 1;\n        /**\n         * UID is used to record the state i.e. UID x, came in from node a, forwarded to node b.\n         * We increment it on each hop, because in order for the node selection to be as random as\n         * possible we *must allow loops*! I.e. the same swap chain may pass over the same node \n         * twice or more. However, if we get a request with either the incoming or the outgoing \n         * UID, we can safely kill it as it's clearly the result of a bug.\n         */\n        RecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(oldID);\n        if(item != null) {\n        \tif(logMINOR) Logger.minor(this, \"Rejecting - same ID as previous request\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection to \"+pn+\" rejecting SwapRequest\");\n            }\n            swapsRejectedRecognizedID++;\n            return true;\n        }\n        if(pn.shouldRejectSwapRequest()) {\n        \tif(logMINOR) Logger.minor(this, \"Advised to reject SwapRequest by PeerNode - rate limit\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection rejecting SwapRequest from \"+pn);\n            }\n            swapsRejectedRateLimit++;\n            return true;\n        }\n        if(logMINOR) Logger.minor(this, \"SwapRequest from \"+pn+\" - uid=\"+oldID);\n        int htl = m.getInt(DMT.HTL);\n        if(htl > SWAP_MAX_HTL) {\n        \tLogger.error(this, \"Bogus swap HTL: \"+htl+\" from \"+pn+\" uid=\"+oldID);\n        \thtl = SWAP_MAX_HTL;\n        }\n        htl--;\n        if(!node.enableSwapping || htl <= 0 && swappingDisabled()) {\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e1) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection rejecting SwapRequest (locked) from \"+pn);\n            }\n            return true;\n        }\n        // Either forward it or handle it\n        if(htl <= 0) {\n        \tif(logMINOR) Logger.minor(this, \"Accepting?... \"+oldID);\n            // Accept - handle locally\n        \tlockOrQueue(m, oldID, newID, pn);\n        \treturn true;\n        } else {\n            m.set(DMT.HTL, htl);\n            m.set(DMT.UID, newID);\n            if(logMINOR) Logger.minor(this, \"Forwarding... \"+oldID);\n            while(true) {\n                // Forward\n                PeerNode randomPeer = node.peers.getRandomPeerInSwappingNetworkOf(pn);\n                if(randomPeer == null) {\n                \tif(logMINOR) Logger.minor(this, \"Late reject \"+oldID);\n                    Message reject = DMT.createFNPSwapRejected(oldID);\n                    try {\n                        pn.sendAsync(reject, null, this);\n                    } catch (NotConnectedException e1) {\n                        Logger.normal(this, \"Late reject but disconnected from sender: \"+pn);\n                    }\n                    swapsRejectedNowhereToGo++;\n                    return true;\n                }\n                if(logMINOR) Logger.minor(this, \"Forwarding \"+oldID+\" to \"+randomPeer);\n                item = addForwardedItem(oldID, newID, pn, randomPeer);\n                item.successfullyForwarded = false;\n                try {\n                    // Forward the request.\n                    // Note that we MUST NOT send this blocking as we are on the\n                    // receiver thread.\n                    randomPeer.sendAsync(m, new MyCallback(DMT.createFNPSwapRejected(oldID), pn, item), LocationManager.this);\n                } catch (NotConnectedException e) {\n                \tif(logMINOR) Logger.minor(this, \"Not connected\");\n                    // Try a different node\n                    continue;\n                }\n                return true;\n            }\n        }\n    }","id":34814,"modified_method":"/**\n     * Handle an incoming SwapRequest\n     * @return True if we have handled the message, false if it needs\n     * to be handled otherwise.\n     */\n    public boolean handleSwapRequest(Message m, PeerNode pn) {\n        final long oldID = m.getLong(DMT.UID);\n        final long newID = oldID + 1;\n        /**\n         * UID is used to record the state i.e. UID x, came in from node a, forwarded to node b.\n         * We increment it on each hop, because in order for the node selection to be as random as\n         * possible we *must allow loops*! I.e. the same swap chain may pass over the same node \n         * twice or more. However, if we get a request with either the incoming or the outgoing \n         * UID, we can safely kill it as it's clearly the result of a bug.\n         */\n        RecentlyForwardedItem item = recentlyForwardedIDs.get(oldID);\n        if(item != null) {\n        \tif(logMINOR) Logger.minor(this, \"Rejecting - same ID as previous request\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection to \"+pn+\" rejecting SwapRequest\");\n            }\n            swapsRejectedRecognizedID++;\n            return true;\n        }\n        if(pn.shouldRejectSwapRequest()) {\n        \tif(logMINOR) Logger.minor(this, \"Advised to reject SwapRequest by PeerNode - rate limit\");\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection rejecting SwapRequest from \"+pn);\n            }\n            swapsRejectedRateLimit++;\n            return true;\n        }\n        if(logMINOR) Logger.minor(this, \"SwapRequest from \"+pn+\" - uid=\"+oldID);\n        int htl = m.getInt(DMT.HTL);\n        if(htl > SWAP_MAX_HTL) {\n        \tLogger.error(this, \"Bogus swap HTL: \"+htl+\" from \"+pn+\" uid=\"+oldID);\n        \thtl = SWAP_MAX_HTL;\n        }\n        htl--;\n        if(!node.enableSwapping || htl <= 0 && swappingDisabled()) {\n            // Reject\n            Message reject = DMT.createFNPSwapRejected(oldID);\n            try {\n                pn.sendAsync(reject, null, this);\n            } catch (NotConnectedException e1) {\n            \tif(logMINOR) Logger.minor(this, \"Lost connection rejecting SwapRequest (locked) from \"+pn);\n            }\n            return true;\n        }\n        // Either forward it or handle it\n        if(htl <= 0) {\n        \tif(logMINOR) Logger.minor(this, \"Accepting?... \"+oldID);\n            // Accept - handle locally\n        \tlockOrQueue(m, oldID, newID, pn);\n        \treturn true;\n        } else {\n            m.set(DMT.HTL, htl);\n            m.set(DMT.UID, newID);\n            if(logMINOR) Logger.minor(this, \"Forwarding... \"+oldID);\n            while(true) {\n                // Forward\n                PeerNode randomPeer = node.peers.getRandomPeerInSwappingNetworkOf(pn);\n                if(randomPeer == null) {\n                \tif(logMINOR) Logger.minor(this, \"Late reject \"+oldID);\n                    Message reject = DMT.createFNPSwapRejected(oldID);\n                    try {\n                        pn.sendAsync(reject, null, this);\n                    } catch (NotConnectedException e1) {\n                        Logger.normal(this, \"Late reject but disconnected from sender: \"+pn);\n                    }\n                    swapsRejectedNowhereToGo++;\n                    return true;\n                }\n                if(logMINOR) Logger.minor(this, \"Forwarding \"+oldID+\" to \"+randomPeer);\n                item = addForwardedItem(oldID, newID, pn, randomPeer);\n                item.successfullyForwarded = false;\n                try {\n                    // Forward the request.\n                    // Note that we MUST NOT send this blocking as we are on the\n                    // receiver thread.\n                    randomPeer.sendAsync(m, new MyCallback(DMT.createFNPSwapRejected(oldID), pn, item), LocationManager.this);\n                } catch (NotConnectedException e) {\n                \tif(logMINOR) Logger.minor(this, \"Not connected\");\n                    // Try a different node\n                    continue;\n                }\n                return true;\n            }\n        }\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an unmatched FNPSwapRejected\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapRejected(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n\t\tRecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(uid);\n        if(item == null) return false;\n        if(item.requestSender == null){\n        \tif(logMINOR) Logger.minor(this, \"Got a FNPSwapRejected without any requestSender set! we can't and won't claim it! UID=\"+uid);\n        \treturn false;\n        }\n        if(item.routedTo == null) {\n            Logger.error(this, \"Got SwapRejected on \"+uid+\" but routedTo is null!\");\n            return false;\n        }\n        if(source != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }        \n        removeRecentlyForwardedItem(item);\n        item.lastMessageTime = System.currentTimeMillis();\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapRejected \"+uid+\" from \"+source+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        try {\n            item.requestSender.sendAsync(m, null, this);\n        } catch (NotConnectedException e) {\n        \tif(logMINOR) Logger.minor(this, \"Lost connection forwarding SwapRejected \"+uid+\" to \"+item.requestSender);\n        }\n        return true;\n    }","id":34815,"modified_method":"/**\n     * Handle an unmatched FNPSwapRejected\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapRejected(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n\t\tRecentlyForwardedItem item = recentlyForwardedIDs.get(uid);\n        if(item == null) return false;\n        if(item.requestSender == null){\n        \tif(logMINOR) Logger.minor(this, \"Got a FNPSwapRejected without any requestSender set! we can't and won't claim it! UID=\"+uid);\n        \treturn false;\n        }\n        if(item.routedTo == null) {\n            Logger.error(this, \"Got SwapRejected on \"+uid+\" but routedTo is null!\");\n            return false;\n        }\n        if(source != item.routedTo) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.routedTo+\" to \"+item.requestSender);\n            return true;\n        }        \n        removeRecentlyForwardedItem(item);\n        item.lastMessageTime = System.currentTimeMillis();\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapRejected \"+uid+\" from \"+source+\" to \"+item.requestSender);\n        // Returning to source - use incomingID\n        m.set(DMT.UID, item.incomingID);\n        try {\n            item.requestSender.sendAsync(m, null, this);\n        } catch (NotConnectedException e) {\n        \tif(logMINOR) Logger.minor(this, \"Lost connection forwarding SwapRejected \"+uid+\" to \"+item.requestSender);\n        }\n        return true;\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle an unmatched FNPSwapCommit\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapCommit(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n\t\tRecentlyForwardedItem item = (RecentlyForwardedItem) recentlyForwardedIDs.get(uid);\n        if(item == null) return false;\n        if(item.routedTo == null) return false;\n        if(source != item.requestSender) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.requestSender+\" to \"+item.routedTo);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapCommit \"+uid+ ',' +item.outgoingID+\" from \"+source+\" to \"+item.routedTo);\n        // Sending onwards - use outgoing ID\n        m.set(DMT.UID, item.outgoingID);\n        try {\n            item.routedTo.sendAsync(m, new SendMessageOnErrorCallback(DMT.createFNPSwapRejected(item.incomingID), item.requestSender, this), this);\n        } catch (NotConnectedException e) {\n        \tif(logMINOR) Logger.minor(this, \"Lost connection forwarding SwapCommit \"+uid+\" to \"+item.routedTo);\n        }\n        spyOnLocations(m, false);\n        return true;\n    }","id":34816,"modified_method":"/**\n     * Handle an unmatched FNPSwapCommit\n     * @return True if we recognized and forwarded this message.\n     */\n    public boolean handleSwapCommit(Message m, PeerNode source) {\n        final long uid = m.getLong(DMT.UID);\n\t\tRecentlyForwardedItem item = recentlyForwardedIDs.get(uid);\n        if(item == null) return false;\n        if(item.routedTo == null) return false;\n        if(source != item.requestSender) {\n            Logger.error(this, \"Unmatched swapreply \"+uid+\" from wrong source: From \"+source+\n                    \" should be \"+item.requestSender+\" to \"+item.routedTo);\n            return true;\n        }\n        item.lastMessageTime = System.currentTimeMillis();\n        if(logMINOR) Logger.minor(this, \"Forwarding SwapCommit \"+uid+ ',' +item.outgoingID+\" from \"+source+\" to \"+item.routedTo);\n        // Sending onwards - use outgoing ID\n        m.set(DMT.UID, item.outgoingID);\n        try {\n            item.routedTo.sendAsync(m, new SendMessageOnErrorCallback(DMT.createFNPSwapRejected(item.incomingID), item.requestSender, this), this);\n        } catch (NotConnectedException e) {\n        \tif(logMINOR) Logger.minor(this, \"Lost connection forwarding SwapCommit \"+uid+\" to \"+item.routedTo);\n        }\n        spyOnLocations(m, false);\n        return true;\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"public LocationManager(RandomSource r, Node node) {\n        loc = r.nextDouble();\n        sender = new SwapRequestSender();\n        this.r = r;\n        this.node = node;\n        recentlyForwardedIDs = new Hashtable();\n        // FIXME persist to disk!\n        averageSwapTime = new BootstrappingDecayingRunningAverage(SEND_SWAP_INTERVAL, 0, Integer.MAX_VALUE, 20, null);\n        timeLocSet = System.currentTimeMillis();\n        \n        logMINOR = Logger.shouldLog(Logger.MINOR, this);\n    }","id":34817,"modified_method":"public LocationManager(RandomSource r, Node node) {\n        loc = r.nextDouble();\n        sender = new SwapRequestSender();\n        this.r = r;\n        this.node = node;\n        recentlyForwardedIDs = new Hashtable<Long, RecentlyForwardedItem>();\n        // FIXME persist to disk!\n        averageSwapTime = new BootstrappingDecayingRunningAverage(SEND_SWAP_INTERVAL, 0, Integer.MAX_VALUE, 20, null);\n        timeLocSet = System.currentTimeMillis();\n        \n        logMINOR = Logger.shouldLog(Logger.MINOR, this);\n    }","commit_id":"eb647f5600aea4cbb3a918a90f5aaa68803b6137","url":"https://github.com/freenet/fred"},{"original_method":"private void setLogFormat(String fmt) {\n\t\tif ((fmt == null) || (fmt.length() == 0))\n\t\t\tfmt = \"d:c:h:t:p:m\";\n\t\tchar[] f = fmt.toCharArray();\n\n\t\tVector fmtVec = new Vector(), strVec = new Vector();\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tboolean comment = false;\n\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\tint type = numberOf(f[i]);\n\t\t\tif(type == UNAME)\n\t\t\t\tgetUName();\n\t\t\tif (!comment && (type != 0)) {\n\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\tstrVec.addElement(sb.toString());\n\t\t\t\t\tfmtVec.addElement((int) 0);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tfmtVec.addElement(new Integer(type));\n\t\t\t} else if (f[i] == '\\\\') {\n\t\t\t\tcomment = true;\n\t\t\t} else {\n\t\t\t\tcomment = false;\n\t\t\t\tsb.append(f[i]);\n\t\t\t}\n\t\t}\n\t\tif (sb.length() > 0) {\n\t\t\tstrVec.addElement(sb.toString());\n\t\t\tfmtVec.addElement(new Integer(0));\n\t\t}\n\n\t\tthis.fmt = new int[fmtVec.size()];\n\t\tint size = fmtVec.size();\n\t\tfor (int i = 0; i < size; ++i)\n\t\t\tthis.fmt[i] = ((Integer) fmtVec.elementAt(i)).intValue();\n\n\t\tthis.str = new String[strVec.size()];\n\t\tstr = (String[]) strVec.toArray(str);\n\t}","id":34818,"modified_method":"private void setLogFormat(String fmt) {\n\t\tif ((fmt == null) || (fmt.length() == 0))\n\t\t\tfmt = \"d:c:h:t:p:m\";\n\t\tchar[] f = fmt.toCharArray();\n\n\t\tArrayList<Integer> fmtVec = new ArrayList<Integer>();\n\t\tArrayList<String> strVec = new ArrayList<String>();\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tboolean comment = false;\n\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\tint type = numberOf(f[i]);\n\t\t\tif(type == UNAME)\n\t\t\t\tgetUName();\n\t\t\tif (!comment && (type != 0)) {\n\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\tstrVec.add(sb.toString());\n\t\t\t\t\tfmtVec.add(0);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tfmtVec.add(type);\n\t\t\t} else if (f[i] == '\\\\') {\n\t\t\t\tcomment = true;\n\t\t\t} else {\n\t\t\t\tcomment = false;\n\t\t\t\tsb.append(f[i]);\n\t\t\t}\n\t\t}\n\t\tif (sb.length() > 0) {\n\t\t\tstrVec.add(sb.toString());\n\t\t\tfmtVec.add(0);\n\t\t}\n\n\t\tthis.fmt = new int[fmtVec.size()];\n\t\tint size = fmtVec.size();\n\t\tfor (int i = 0; i < size; ++i)\n\t\t\tthis.fmt[i] = fmtVec.get(i);\n\n\t\tthis.str = new String[strVec.size()];\n\t\tstr = strVec.toArray(str);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public void logString(byte[] b) {\n\t\tint noElementCount = 0;\n\t\tsynchronized (list) {\n\t\t\tint sz = list.size();\n\t\t\tlist.add(b);\n\t\t\tlistBytes += (b.length + LINE_OVERHEAD); /* total guess */\n\t\t\tint x = 0;\n\t\t\tif ((list.size() > MAX_LIST_SIZE) || (listBytes > MAX_LIST_BYTES)) {\n\t\t\t\twhile ((list.size() > (MAX_LIST_SIZE * 0.9F))\n\t\t\t\t\t|| (listBytes > (MAX_LIST_BYTES * 0.9F))) {\n\t\t\t\t\tbyte[] ss;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tss = (byte[]) (list.removeFirst());\n\t\t\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\t\t\t// Yes I know this is impossible but it happens with 1.6 with heap profiling enabled\n\t\t\t\t\t\tnoElementCount++;\n\t\t\t\t\t\tif(noElementCount > 1000) {\n\t\t\t\t\t\t\tSystem.err.println(\"Lost log line because of constant NoSuchElementException's\");\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlistBytes -= (ss.length + LINE_OVERHEAD);\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tString err =\n\t\t\t\t\t\"GRRR: ERROR: Logging too fast, chopped \"\n\t\t\t\t\t\t+ x\n\t\t\t\t\t\t+ \" lines, \"\n\t\t\t\t\t\t+ listBytes\n\t\t\t\t\t\t+ \" bytes in memory\\n\";\n\t\t\t\tbyte[] buf = err.getBytes();\n\t\t\t\tlist.add(0, buf);\n\t\t\t\tlistBytes += (buf.length + LINE_OVERHEAD);\n\t\t\t}\n\t\t\tif (sz == 0)\n\t\t\t\tlist.notifyAll();\n\t\t}\n\t}","id":34819,"modified_method":"public void logString(byte[] b) {\n\t\tint noElementCount = 0;\n\t\tsynchronized (list) {\n\t\t\tint sz = list.size();\n\t\t\tlist.add(b);\n\t\t\tlistBytes += (b.length + LINE_OVERHEAD); /* total guess */\n\t\t\tint x = 0;\n\t\t\tif ((list.size() > MAX_LIST_SIZE) || (listBytes > MAX_LIST_BYTES)) {\n\t\t\t\twhile ((list.size() > (MAX_LIST_SIZE * 0.9F))\n\t\t\t\t\t|| (listBytes > (MAX_LIST_BYTES * 0.9F))) {\n\t\t\t\t\tbyte[] ss;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tss = list.removeFirst();\n\t\t\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\t\t\t// Yes I know this is impossible but it happens with 1.6 with heap profiling enabled\n\t\t\t\t\t\tnoElementCount++;\n\t\t\t\t\t\tif(noElementCount > 1000) {\n\t\t\t\t\t\t\tSystem.err.println(\"Lost log line because of constant NoSuchElementException's\");\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlistBytes -= (ss.length + LINE_OVERHEAD);\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tString err =\n\t\t\t\t\t\"GRRR: ERROR: Logging too fast, chopped \"\n\t\t\t\t\t\t+ x\n\t\t\t\t\t\t+ \" lines, \"\n\t\t\t\t\t\t+ listBytes\n\t\t\t\t\t\t+ \" bytes in memory\\n\";\n\t\t\t\tbyte[] buf = err.getBytes();\n\t\t\t\tlist.add(0, buf);\n\t\t\t\tlistBytes += (buf.length + LINE_OVERHEAD);\n\t\t\t}\n\t\t\tif (sz == 0)\n\t\t\t\tlist.notifyAll();\n\t\t}\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public void sendLogByContainedDate(long time, OutputStream os) throws IOException {\n\t\tOldLogFile toReturn = null;\n\t\tsynchronized(logFiles) {\n\t\t\tIterator i = logFiles.iterator();\n\t\t\twhile(i.hasNext()) {\n\t\t\t\tOldLogFile olf = (OldLogFile) i.next();\n\t\t    \tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t    \tif(logMINOR)\n\t\t    \t\tLogger.minor(this, \"Checking \"+time+\" against \"+olf.filename+\" : start=\"+olf.start+\", end=\"+olf.end);\n\t\t\t\tif((time >= olf.start) && (time < olf.end)) {\n\t\t\t\t\ttoReturn = olf;\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Found \"+olf);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(toReturn == null)\n\t\t\t\treturn; // couldn't find it\n\t\t}\n\t\tFileInputStream fis = new FileInputStream(toReturn.filename);\n\t\tDataInputStream dis = new DataInputStream(fis);\n\t\tlong written = 0;\n\t\tlong size = toReturn.size;\n\t\tbyte[] buf = new byte[4096];\n\t\twhile(written < size) {\n\t\t\tint toRead = (int) Math.min(buf.length, (size - written));\n\t\t\ttry {\n\t\t\t\tdis.readFully(buf, 0, toRead);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Could not read bytes \"+written+\" to \"+(written + toRead)+\" from file \"+toReturn.filename+\" which is supposed to be \"+size+\" bytes (\"+toReturn.filename.length()+ ')');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tos.write(buf, 0, toRead);\n\t\t\twritten += toRead;\n\t\t}\n\t\tdis.close();\n\t\tfis.close();\n\t}","id":34820,"modified_method":"public void sendLogByContainedDate(long time, OutputStream os) throws IOException {\n\t\tOldLogFile toReturn = null;\n\t\tsynchronized(logFiles) {\n\t\t\tIterator<OldLogFile> i = logFiles.iterator();\n\t\t\twhile(i.hasNext()) {\n\t\t\t\tOldLogFile olf = i.next();\n\t\t    \tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t    \tif(logMINOR)\n\t\t    \t\tLogger.minor(this, \"Checking \"+time+\" against \"+olf.filename+\" : start=\"+olf.start+\", end=\"+olf.end);\n\t\t\t\tif((time >= olf.start) && (time < olf.end)) {\n\t\t\t\t\ttoReturn = olf;\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Found \"+olf);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(toReturn == null)\n\t\t\t\treturn; // couldn't find it\n\t\t}\n\t\tFileInputStream fis = new FileInputStream(toReturn.filename);\n\t\tDataInputStream dis = new DataInputStream(fis);\n\t\tlong written = 0;\n\t\tlong size = toReturn.size;\n\t\tbyte[] buf = new byte[4096];\n\t\twhile(written < size) {\n\t\t\tint toRead = (int) Math.min(buf.length, (size - written));\n\t\t\ttry {\n\t\t\t\tdis.readFully(buf, 0, toRead);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Could not read bytes \"+written+\" to \"+(written + toRead)+\" from file \"+toReturn.filename+\" which is supposed to be \"+size+\" bytes (\"+toReturn.filename.length()+ ')');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tos.write(buf, 0, toRead);\n\t\t\twritten += toRead;\n\t\t}\n\t\tdis.close();\n\t\tfis.close();\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Print a human- and script- readable list of available log files.\n\t * @throws IOException \n\t */\n\tpublic void listAvailableLogs(OutputStreamWriter writer) throws IOException {\n\t\tOldLogFile[] oldLogFiles;\n\t\tsynchronized(logFiles) {\n\t\t\toldLogFiles = (OldLogFile[]) logFiles.toArray(new OldLogFile[logFiles.size()]);\n\t\t}\n\t\tDateFormat tempDF = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, Locale.ENGLISH);\n\t\ttempDF.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\tfor(int i=0;i<oldLogFiles.length;i++) {\n\t\t\tOldLogFile olf = oldLogFiles[i];\n\t\t\twriter.write(olf.filename.getName()+\" : \"+tempDF.format(new Date(olf.start))+\" to \"+tempDF.format(new Date(olf.end))+ \" - \"+olf.size+\" bytes\\n\");\n\t\t}\n\t}","id":34821,"modified_method":"/**\n\t * Print a human- and script- readable list of available log files.\n\t * @throws IOException \n\t */\n\tpublic void listAvailableLogs(OutputStreamWriter writer) throws IOException {\n\t\tOldLogFile[] oldLogFiles;\n\t\tsynchronized(logFiles) {\n\t\t\toldLogFiles = logFiles.toArray(new OldLogFile[logFiles.size()]);\n\t\t}\n\t\tDateFormat tempDF = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, Locale.ENGLISH);\n\t\ttempDF.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\tfor(int i=0;i<oldLogFiles.length;i++) {\n\t\t\tOldLogFile olf = oldLogFiles[i];\n\t\t\twriter.write(olf.filename.getName()+\" : \"+tempDF.format(new Date(olf.start))+\" to \"+tempDF.format(new Date(olf.end))+ \" - \"+olf.size+\" bytes\\n\");\n\t\t}\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public void deleteAllOldLogFiles() {\n\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\twhile(true) {\n\t\t\t\tOldLogFile olf;\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif(logFiles.isEmpty()) return;\n\t\t\t\t\tolf = (OldLogFile) logFiles.removeFirst();\n\t\t\t\t}\n\t\t\t\tolf.filename.delete();\n\t\t\t\toldLogFilesDiskSpaceUsage -= olf.size;\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Deleting \"+olf.filename+\" - saving \"+olf.size+\n\t\t\t\t\t\t\t\" bytes, disk usage now: \"+oldLogFilesDiskSpaceUsage+\" of \"+maxOldLogfilesDiskUsage);\n\t\t\t}\n\t\t}\n\t}","id":34822,"modified_method":"public void deleteAllOldLogFiles() {\n\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\twhile(true) {\n\t\t\t\tOldLogFile olf;\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif(logFiles.isEmpty()) return;\n\t\t\t\t\tolf = logFiles.removeFirst();\n\t\t\t\t}\n\t\t\t\tolf.filename.delete();\n\t\t\t\toldLogFilesDiskSpaceUsage -= olf.size;\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Deleting \"+olf.filename+\" - saving \"+olf.size+\n\t\t\t\t\t\t\t\" bytes, disk usage now: \"+oldLogFilesDiskSpaceUsage+\" of \"+maxOldLogfilesDiskUsage);\n\t\t\t}\n\t\t}\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n\t\t\tFile currentFilename = null;\n\t\t\tObject o = null;\n\t\t\tlong thisTime;\n\t\t\tlong lastTime = -1;\n\t\t\tlong startTime;\n\t\t\tlong nextHour = -1;\n\t\t\tGregorianCalendar gc = null;\n\t\t\tString filename = null;\n\t\t\tif (baseFilename != null) {\n\t\t\t\tlatestFile = new File(baseFilename+\"-latest.log\");\n\t\t\t\tpreviousFile = new File(baseFilename+\"-previous.log\");\n\t\t\t\tfindOldLogFiles();\n\t\t\t\tgc = new GregorianCalendar();\n\t\t\t\tswitch (INTERVAL) {\n\t\t\t\t\tcase Calendar.YEAR :\n\t\t\t\t\t\tgc.set(Calendar.MONTH, 0);\n\t\t\t\t\tcase Calendar.MONTH :\n\t\t\t\t\t\tgc.set(Calendar.DAY_OF_MONTH, 0);\n\t\t\t\t\tcase Calendar.WEEK_OF_YEAR :\n\t\t\t\t\t\tif (INTERVAL == Calendar.WEEK_OF_YEAR)\n\t\t\t\t\t\t\tgc.set(Calendar.DAY_OF_WEEK, 0);\n\t\t\t\t\tcase Calendar.DAY_OF_MONTH :\n\t\t\t\t\t\tgc.set(Calendar.HOUR, 0);\n\t\t\t\t\tcase Calendar.HOUR :\n\t\t\t\t\t\tgc.set(Calendar.MINUTE, 0);\n\t\t\t\t\tcase Calendar.MINUTE :\n\t\t\t\t\t\tgc.set(Calendar.SECOND, 0);\n\t\t\t\t\t\tgc.set(Calendar.MILLISECOND, 0);\n\t\t\t\t}\n\t\t\t\tif(INTERVAL_MULTIPLIER > 1) {\n\t\t\t\t\tint x = gc.get(INTERVAL);\n\t\t\t\t\tgc.set(INTERVAL, (x / INTERVAL_MULTIPLIER) * INTERVAL_MULTIPLIER);\n\t\t\t\t}\n\t\t\t\tfilename = getHourLogName(gc, true);\n\t\t\t\tcurrentFilename = new File(filename);\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif((!logFiles.isEmpty()) && ((OldLogFile)logFiles.getLast()).filename.equals(currentFilename)) {\n\t\t\t\t\t\tlogFiles.removeLast();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogStream = openNewLogFile(currentFilename, true);\n\t\t\t\tif(latestFile != null) {\n\t\t\t\t\taltLogStream = openNewLogFile(latestFile, false);\n\t\t\t\t}\n\t\t\t\tSystem.err.println(\"Created log files\");\n\t\t\t\tstartTime = gc.getTimeInMillis();\n\t\t    \tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t    \t\tLogger.minor(this, \"Start time: \"+gc+\" -> \"+startTime);\n\t\t\t\tlastTime = startTime;\n\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\tnextHour = gc.getTimeInMillis();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tthisTime = System.currentTimeMillis();\n\t\t\t\t\tif (baseFilename != null) {\n\t\t\t\t\t\tif ((thisTime > nextHour) || switchedBaseFilename) {\n\t\t\t\t\t\t\t// Switch logs\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogStream.flush();\n\t\t\t\t\t\t\t\tif(altLogStream != null) altLogStream.flush();\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tSystem.err.println(\n\t\t\t\t\t\t\t\t\t\"Flushing on change caught \" + e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogStream.close();\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tSystem.err.println(\n\t\t\t\t\t\t\t\t\t\t\"Closing on change caught \" + e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong length = currentFilename.length();\n\t\t\t\t\t\t\tOldLogFile olf = new OldLogFile(currentFilename, lastTime, nextHour, length);\n\t\t\t\t\t\t\tlastTime = nextHour;\n\t\t\t\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\t\t\t\tlogFiles.addLast(olf);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toldLogFilesDiskSpaceUsage += length;\n\t\t\t\t\t\t\ttrimOldLogFiles();\n\t\t\t\t\t\t\t// Rotate primary log stream\n\t\t\t\t\t\t\tfilename = getHourLogName(gc, true);\n\t\t\t\t\t\t\tcurrentFilename = new File(filename);\n\t\t\t\t\t\t\tlogStream = openNewLogFile(new File(filename), true);\n\t\t\t\t\t\t\tif(latestFile != null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\taltLogStream.close();\n\t\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t\tSystem.err.println(\n\t\t\t\t\t\t\t\t\t\t\t\"Closing alt on change caught \" + e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(previousFile != null && previousFile.exists())\n\t\t\t\t\t\t\t\t\tFileUtil.renameTo(latestFile, previousFile);\n\t\t\t\t\t\t\t\tlatestFile.delete();\n\t\t\t\t\t\t\t\taltLogStream = openNewLogFile(latestFile, false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//System.err.println(\"Rotated log files: \"+filename);\n\t\t\t\t\t\t\t//System.err.println(\"Almost rotated\");\n\t\t\t\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\t\t\t\tnextHour = gc.getTimeInMillis();\n\t\t\t\t\t\t\t//System.err.println(\"Rotated\");\n\t\t\t\t\t\t\tif(switchedBaseFilename) {\n\t\t\t\t\t\t\t\tsynchronized(FileLoggerHook.class) {\n\t\t\t\t\t\t\t\t\tswitchedBaseFilename = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(list.size() == 0) {\n\t\t\t\t\t\tif(currentFilename == null)\n\t\t\t\t\t\t\tmyWrite(logStream, null);\n\t\t\t\t        if(altLogStream != null)\n\t\t\t\t        \tmyWrite(altLogStream, null);\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized (list) {\n\t\t\t\t\t\twhile (list.size() == 0) {\n\t\t\t\t\t\t\tif (closed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.wait(500);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t// Ignored.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\to = list.removeFirst();\n\t\t\t\t\t\tlistBytes -= (((byte[]) o).length + LINE_OVERHEAD);\n\t\t\t\t\t}\n\t\t\t\t\tmyWrite(logStream, ((byte[]) o));\n\t\t\t        if(altLogStream != null)\n\t\t\t        \tmyWrite(altLogStream, (byte[]) o);\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tSystem.err.println(e.getClass());\n\t\t\t\t\tSystem.err.println(e.getMessage());\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t    // FIXME\n\t\t\t\t\t//freenet.node.Main.dumpInterestingObjects();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tSystem.err.println(\"FileLoggerHook log writer caught \" + t);\n\t\t\t\t\tt.printStackTrace(System.err);\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":34823,"modified_method":"@SuppressWarnings(\"fallthrough\")\n\t\tpublic void run() {\n\t\t\tFile currentFilename = null;\n\t\t\tbyte[] o = null;\n\t\t\tlong thisTime;\n\t\t\tlong lastTime = -1;\n\t\t\tlong startTime;\n\t\t\tlong nextHour = -1;\n\t\t\tGregorianCalendar gc = null;\n\t\t\tString filename = null;\n\t\t\tif (baseFilename != null) {\n\t\t\t\tlatestFile = new File(baseFilename+\"-latest.log\");\n\t\t\t\tpreviousFile = new File(baseFilename+\"-previous.log\");\n\t\t\t\tfindOldLogFiles();\n\t\t\t\tgc = new GregorianCalendar();\n\t\t\t\tswitch (INTERVAL) {\n\t\t\t\t\tcase Calendar.YEAR :\n\t\t\t\t\t\tgc.set(Calendar.MONTH, 0);\n\t\t\t\t\tcase Calendar.MONTH :\n\t\t\t\t\t\tgc.set(Calendar.DAY_OF_MONTH, 0);\n\t\t\t\t\tcase Calendar.WEEK_OF_YEAR :\n\t\t\t\t\t\tif (INTERVAL == Calendar.WEEK_OF_YEAR)\n\t\t\t\t\t\t\tgc.set(Calendar.DAY_OF_WEEK, 0);\n\t\t\t\t\tcase Calendar.DAY_OF_MONTH :\n\t\t\t\t\t\tgc.set(Calendar.HOUR, 0);\n\t\t\t\t\tcase Calendar.HOUR :\n\t\t\t\t\t\tgc.set(Calendar.MINUTE, 0);\n\t\t\t\t\tcase Calendar.MINUTE :\n\t\t\t\t\t\tgc.set(Calendar.SECOND, 0);\n\t\t\t\t\t\tgc.set(Calendar.MILLISECOND, 0);\n\t\t\t\t}\n\t\t\t\tif(INTERVAL_MULTIPLIER > 1) {\n\t\t\t\t\tint x = gc.get(INTERVAL);\n\t\t\t\t\tgc.set(INTERVAL, (x / INTERVAL_MULTIPLIER) * INTERVAL_MULTIPLIER);\n\t\t\t\t}\n\t\t\t\tfilename = getHourLogName(gc, true);\n\t\t\t\tcurrentFilename = new File(filename);\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif ((!logFiles.isEmpty()) && logFiles.getLast().filename.equals(currentFilename)) {\n\t\t\t\t\t\tlogFiles.removeLast();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogStream = openNewLogFile(currentFilename, true);\n\t\t\t\tif(latestFile != null) {\n\t\t\t\t\taltLogStream = openNewLogFile(latestFile, false);\n\t\t\t\t}\n\t\t\t\tSystem.err.println(\"Created log files\");\n\t\t\t\tstartTime = gc.getTimeInMillis();\n\t\t    \tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t    \t\tLogger.minor(this, \"Start time: \"+gc+\" -> \"+startTime);\n\t\t\t\tlastTime = startTime;\n\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\tnextHour = gc.getTimeInMillis();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tthisTime = System.currentTimeMillis();\n\t\t\t\t\tif (baseFilename != null) {\n\t\t\t\t\t\tif ((thisTime > nextHour) || switchedBaseFilename) {\n\t\t\t\t\t\t\t// Switch logs\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogStream.flush();\n\t\t\t\t\t\t\t\tif(altLogStream != null) altLogStream.flush();\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tSystem.err.println(\n\t\t\t\t\t\t\t\t\t\"Flushing on change caught \" + e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogStream.close();\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tSystem.err.println(\n\t\t\t\t\t\t\t\t\t\t\"Closing on change caught \" + e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong length = currentFilename.length();\n\t\t\t\t\t\t\tOldLogFile olf = new OldLogFile(currentFilename, lastTime, nextHour, length);\n\t\t\t\t\t\t\tlastTime = nextHour;\n\t\t\t\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\t\t\t\tlogFiles.addLast(olf);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toldLogFilesDiskSpaceUsage += length;\n\t\t\t\t\t\t\ttrimOldLogFiles();\n\t\t\t\t\t\t\t// Rotate primary log stream\n\t\t\t\t\t\t\tfilename = getHourLogName(gc, true);\n\t\t\t\t\t\t\tcurrentFilename = new File(filename);\n\t\t\t\t\t\t\tlogStream = openNewLogFile(new File(filename), true);\n\t\t\t\t\t\t\tif(latestFile != null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\taltLogStream.close();\n\t\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t\tSystem.err.println(\n\t\t\t\t\t\t\t\t\t\t\t\"Closing alt on change caught \" + e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(previousFile != null && previousFile.exists())\n\t\t\t\t\t\t\t\t\tFileUtil.renameTo(latestFile, previousFile);\n\t\t\t\t\t\t\t\tlatestFile.delete();\n\t\t\t\t\t\t\t\taltLogStream = openNewLogFile(latestFile, false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//System.err.println(\"Rotated log files: \"+filename);\n\t\t\t\t\t\t\t//System.err.println(\"Almost rotated\");\n\t\t\t\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\t\t\t\tnextHour = gc.getTimeInMillis();\n\t\t\t\t\t\t\t//System.err.println(\"Rotated\");\n\t\t\t\t\t\t\tif(switchedBaseFilename) {\n\t\t\t\t\t\t\t\tsynchronized(FileLoggerHook.class) {\n\t\t\t\t\t\t\t\t\tswitchedBaseFilename = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(list.size() == 0) {\n\t\t\t\t\t\tif(currentFilename == null)\n\t\t\t\t\t\t\tmyWrite(logStream, null);\n\t\t\t\t        if(altLogStream != null)\n\t\t\t\t        \tmyWrite(altLogStream, null);\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized (list) {\n\t\t\t\t\t\twhile (list.size() == 0) {\n\t\t\t\t\t\t\tif (closed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.wait(500);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t// Ignored.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\to = list.removeFirst();\n\t\t\t\t\t\tlistBytes -= o.length + LINE_OVERHEAD;\n\t\t\t\t\t}\n\t\t\t\t\tmyWrite(logStream,  o);\n\t\t\t        if(altLogStream != null)\n\t\t\t        \tmyWrite(altLogStream, o);\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tSystem.err.println(e.getClass());\n\t\t\t\t\tSystem.err.println(e.getMessage());\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t    // FIXME\n\t\t\t\t\t//freenet.node.Main.dumpInterestingObjects();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tSystem.err.println(\"FileLoggerHook log writer caught \" + t);\n\t\t\t\t\tt.printStackTrace(System.err);\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public void trimOldLogFiles() {\n\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\twhile(oldLogFilesDiskSpaceUsage > maxOldLogfilesDiskUsage) {\n\t\t\t\tOldLogFile olf;\n\t\t\t\t// TODO: creates a double lock situation, but only here. I think this is okay because the inner lock is only used for trivial things.\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif(logFiles.isEmpty()) {\n\t\t\t\t\t\tSystem.err.println(\"ERROR: INCONSISTENT LOGGER TOTALS: Log file list is empty but still used \"+oldLogFilesDiskSpaceUsage+\" bytes!\");\n\t\t\t\t\t}\n\t\t\t\t\tolf = (OldLogFile) logFiles.removeFirst();\n\t\t\t\t}\n\t\t\t\tolf.filename.delete();\n\t\t\t\toldLogFilesDiskSpaceUsage -= olf.size;\n\t\t    \tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t    \t\tLogger.minor(this, \"Deleting \"+olf.filename+\" - saving \"+olf.size+\n\t\t\t\t\t\t\" bytes, disk usage now: \"+oldLogFilesDiskSpaceUsage+\" of \"+maxOldLogfilesDiskUsage);\n\t\t\t}\n\t\t}\n\t}","id":34824,"modified_method":"public void trimOldLogFiles() {\n\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\twhile(oldLogFilesDiskSpaceUsage > maxOldLogfilesDiskUsage) {\n\t\t\t\tOldLogFile olf;\n\t\t\t\t// TODO: creates a double lock situation, but only here. I think this is okay because the inner lock is only used for trivial things.\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif(logFiles.isEmpty()) {\n\t\t\t\t\t\tSystem.err.println(\"ERROR: INCONSISTENT LOGGER TOTALS: Log file list is empty but still used \"+oldLogFilesDiskSpaceUsage+\" bytes!\");\n\t\t\t\t\t}\n\t\t\t\t\tolf = logFiles.removeFirst();\n\t\t\t\t}\n\t\t\t\tolf.filename.delete();\n\t\t\t\toldLogFilesDiskSpaceUsage -= olf.size;\n\t\t    \tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t    \t\tLogger.minor(this, \"Deleting \"+olf.filename+\" - saving \"+olf.size+\n\t\t\t\t\t\t\" bytes, disk usage now: \"+oldLogFilesDiskSpaceUsage+\" of \"+maxOldLogfilesDiskUsage);\n\t\t\t}\n\t\t}\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public void log(Object o, Class c, String msg, Throwable e, int priority) {\n\t\tif (!instanceShouldLog(priority, c))\n\t\t\treturn;\n\n\t\tif (closed)\n\t\t\treturn;\n\t\t\n\t\tStringBuilder sb = new StringBuilder( e == null ? 512 : 1024 );\n\t\tint sctr = 0;\n\n\t\tfor (int i = 0; i < fmt.length; ++i) {\n\t\t\tswitch (fmt[i]) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tsb.append(str[sctr++]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE :\n\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tmyDate.setTime(now);\n\t\t\t\t\t\tsb.append(df.format(myDate));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CLASS :\n\t\t\t\t\tsb.append(c == null ? \"<none>\" : c.getName());\n\t\t\t\t\tbreak;\n\t\t\t\tcase HASHCODE :\n\t\t\t\t\tsb.append(\n\t\t\t\t\t\to == null\n\t\t\t\t\t\t\t? \"<none>\"\n\t\t\t\t\t\t\t: Integer.toHexString(o.hashCode()));\n\t\t\t\t\tbreak;\n\t\t\t\tcase THREAD :\n\t\t\t\t\tsb.append(Thread.currentThread().getName());\n\t\t\t\t\tbreak;\n\t\t\t\tcase PRIORITY :\n\t\t\t\t\tsb.append(LoggerHook.priorityOf(priority));\n\t\t\t\t\tbreak;\n\t\t\t\tcase MESSAGE :\n\t\t\t\t\tsb.append(msg);\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNAME :\n\t\t\t\t\tsb.append(uname);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsb.append('\\n');\n\n\t\tfor(int j=0;j<20 && e != null;j++) {\n\n\t\t\tsb.append(e.toString());\n\t\t\t\n\t\t\tStackTraceElement[] trace = e.getStackTrace();\n\t\t\t\n\t\t\tif(trace == null)\n\t\t\t\tsb.append(\"(null)\\n\");\n\t\t\telse if(trace.length == 0)\n\t\t\t\tsb.append(\"(no stack trace)\\n\");\n\t\t\telse {\n\t\t\t\tsb.append('\\n');\n\t\t\t\tfor(int i=0;i<trace.length;i++) {\n\t\t\t\t\tsb.append(\"\\tat \");\n\t\t\t\t\tsb.append(trace[i].toString());\n\t\t\t\t\tsb.append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tThrowable cause = e.getCause();\n\t\t\tif(cause != e) e = cause;\n\t\t\telse break;\n\t\t}\n\n\t\tlogString(sb.toString().getBytes());\n\t}","id":34825,"modified_method":"public void log(Object o, Class<?> c, String msg, Throwable e, int priority) {\n\t\tif (!instanceShouldLog(priority, c))\n\t\t\treturn;\n\n\t\tif (closed)\n\t\t\treturn;\n\t\t\n\t\tStringBuilder sb = new StringBuilder( e == null ? 512 : 1024 );\n\t\tint sctr = 0;\n\n\t\tfor (int i = 0; i < fmt.length; ++i) {\n\t\t\tswitch (fmt[i]) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tsb.append(str[sctr++]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE :\n\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tmyDate.setTime(now);\n\t\t\t\t\t\tsb.append(df.format(myDate));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CLASS :\n\t\t\t\t\tsb.append(c == null ? \"<none>\" : c.getName());\n\t\t\t\t\tbreak;\n\t\t\t\tcase HASHCODE :\n\t\t\t\t\tsb.append(\n\t\t\t\t\t\to == null\n\t\t\t\t\t\t\t? \"<none>\"\n\t\t\t\t\t\t\t: Integer.toHexString(o.hashCode()));\n\t\t\t\t\tbreak;\n\t\t\t\tcase THREAD :\n\t\t\t\t\tsb.append(Thread.currentThread().getName());\n\t\t\t\t\tbreak;\n\t\t\t\tcase PRIORITY :\n\t\t\t\t\tsb.append(LoggerHook.priorityOf(priority));\n\t\t\t\t\tbreak;\n\t\t\t\tcase MESSAGE :\n\t\t\t\t\tsb.append(msg);\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNAME :\n\t\t\t\t\tsb.append(uname);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsb.append('\\n');\n\n\t\tfor(int j=0;j<20 && e != null;j++) {\n\n\t\t\tsb.append(e.toString());\n\t\t\t\n\t\t\tStackTraceElement[] trace = e.getStackTrace();\n\t\t\t\n\t\t\tif(trace == null)\n\t\t\t\tsb.append(\"(null)\\n\");\n\t\t\telse if(trace.length == 0)\n\t\t\t\tsb.append(\"(no stack trace)\\n\");\n\t\t\telse {\n\t\t\t\tsb.append('\\n');\n\t\t\t\tfor(int i=0;i<trace.length;i++) {\n\t\t\t\t\tsb.append(\"\\tat \");\n\t\t\t\t\tsb.append(trace[i].toString());\n\t\t\t\t\tsb.append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tThrowable cause = e.getCause();\n\t\t\tif(cause != e) e = cause;\n\t\t\telse break;\n\t\t}\n\n\t\tlogString(sb.toString().getBytes());\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized static void normal(Class c, String s) {\n\t\tlogger.log(c, s, NORMAL);\n\t}","id":34826,"modified_method":"public synchronized static void normal(Class<?> c, String s) {\n\t\tlogger.log(c, s, NORMAL);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Log a message from static code.\n\t * @param c     The class where this message was generated.\n\t * @param message A clear and verbose message describing the event\n\t * @param e        Logs this exception with the message.\n\t * @param priority The priority of the mesage, one of Logger.ERROR,\n\t *                 Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(Class c, String message, Throwable e,\n\t\t\tint priority);","id":34827,"modified_method":"/**\n\t * Log a message from static code.\n\t * @param c     The class where this message was generated.\n\t * @param message A clear and verbose message describing the event\n\t * @param e        Logs this exception with the message.\n\t * @param priority The priority of the mesage, one of Logger.ERROR,\n\t *                 Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(Class<?> c, String message, Throwable e,\n\t\t\tint priority);","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized static void minor(Class class1, String string, Throwable t) {\n\t\tlogger.log(class1, string, t, MINOR);\n\t}","id":34828,"modified_method":"public synchronized static void minor(Class<?> class1, String string, Throwable t) {\n\t\tlogger.log(class1, string, t, MINOR);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Log a message from static code.\n\t * @param c        The class where this message was generated.\n\t * @param message  A clear and verbose message describing the event\n\t * @param priority The priority of the mesage, one of Logger.ERROR,\n\t *                 Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(Class c, String message, int priority);","id":34829,"modified_method":"/**\n\t * Log a message from static code.\n\t * @param c        The class where this message was generated.\n\t * @param message  A clear and verbose message describing the event\n\t * @param priority The priority of the mesage, one of Logger.ERROR,\n\t *                 Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(Class<?> c, String message, int priority);","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public static boolean shouldLog(int priority, Class c) {\n\t\treturn logger.instanceShouldLog(priority, c);\n\t}","id":34830,"modified_method":"public static boolean shouldLog(int priority, Class<?> c) {\n\t\treturn logger.instanceShouldLog(priority, c);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized static void error(Class c, String s) {\n\t\tlogger.log(c, s, ERROR);\n\t}","id":34831,"modified_method":"public synchronized static void error(Class<?> c, String s) {\n\t\tlogger.log(c, s, ERROR);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public abstract boolean instanceShouldLog(int priority, Class c);","id":34832,"modified_method":"public abstract boolean instanceShouldLog(int priority, Class<?> c);","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Log a message\n\t * \n\t * @param o\n\t *            The object where this message was generated.\n\t * @param source\n\t *            The class where this message was generated.\n\t * @param message\n\t *            A clear and verbose message describing the event\n\t * @param e\n\t *            Logs this exception with the message.\n\t * @param priority\n\t *            The priority of the mesage, one of Logger.ERROR,\n\t *            Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(\n\t\t\tObject o,\n\t\t\tClass source,\n\t\t\tString message,\n\t\t\tThrowable e,\n\t\t\tint priority);","id":34833,"modified_method":"/**\n\t * Log a message\n\t * \n\t * @param o\n\t *            The object where this message was generated.\n\t * @param source\n\t *            The class where this message was generated.\n\t * @param message\n\t *            A clear and verbose message describing the event\n\t * @param e\n\t *            Logs this exception with the message.\n\t * @param priority\n\t *            The priority of the mesage, one of Logger.ERROR,\n\t *            Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(\n\t\t\tObject o,\n\t\t\tClass<?> source,\n\t\t\tString message,\n\t\t\tThrowable e,\n\t\t\tint priority);","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized static void minor(Class c, String s) {\n\t\tlogger.log(c, s, MINOR);\n\t}","id":34834,"modified_method":"public synchronized static void minor(Class<?> c, String s) {\n\t\tlogger.log(c, s, MINOR);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public boolean instanceShouldLog(int priority, Class c) {\n\t\tint thresh = threshold;\n\t\tif ((c != null) && (detailedThresholds.size() > 0)) {\n\t\t\tString cname = c.getName();\n\t\t\tsynchronized(this) {\n\t\t\t\tIterator<DetailedThreshold> it = detailedThresholds.iterator();\n\t\t\t\twhile(it.hasNext()) {\n\t\t\t\t\tDetailedThreshold dt = it.next();\n\t\t\t\t\tif(cname.startsWith(dt.section))\n\t\t\t\t\t\tthresh = dt.dThreshold;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn priority >= thresh;\n\t}","id":34835,"modified_method":"public boolean instanceShouldLog(int priority, Class<?> c) {\n\t\tint thresh = threshold;\n\t\tif ((c != null) && (detailedThresholds.size() > 0)) {\n\t\t\tString cname = c.getName();\n\t\t\tsynchronized(this) {\n\t\t\t\tIterator<DetailedThreshold> it = detailedThresholds.iterator();\n\t\t\t\twhile(it.hasNext()) {\n\t\t\t\t\tDetailedThreshold dt = it.next();\n\t\t\t\t\tif(cname.startsWith(dt.section))\n\t\t\t\t\t\tthresh = dt.dThreshold;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn priority >= thresh;\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Log a message\n\t * \n\t * @param o\n\t *            The object where this message was generated.\n\t * @param source\n\t *            The class where this message was generated.\n\t * @param message\n\t *            A clear and verbose message describing the event\n\t * @param e\n\t *            Logs this exception with the message.\n\t * @param priority\n\t *            The priority of the mesage, one of Logger.ERROR,\n\t *            Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(\n\t\t\tObject o,\n\t\t\tClass source,\n\t\t\tString message,\n\t\t\tThrowable e,\n\t\t\tint priority);","id":34836,"modified_method":"/**\n\t * Log a message\n\t * \n\t * @param o\n\t *            The object where this message was generated.\n\t * @param source\n\t *            The class where this message was generated.\n\t * @param message\n\t *            A clear and verbose message describing the event\n\t * @param e\n\t *            Logs this exception with the message.\n\t * @param priority\n\t *            The priority of the mesage, one of Logger.ERROR,\n\t *            Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic abstract void log(\n\t\t\tObject o,\n\t\t\tClass<?> source,\n\t\t\tString message,\n\t\t\tThrowable e,\n\t\t\tint priority);","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"public void log(Class c, String message, Throwable e, int priority) {\n\t\tif (!instanceShouldLog(priority, c))\n\t\t\treturn;\n\t\tlog(null, c, message, e, priority);\n\t}","id":34837,"modified_method":"public void log(Class<?> c, String message, Throwable e, int priority) {\n\t\tif (!instanceShouldLog(priority, c))\n\t\t\treturn;\n\t\tlog(null, c, message, e, priority);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Log a message from static code.\n\t * @param c        The class where this message was generated.\n\t * @param message  A clear and verbose message describing the event\n\t * @param priority The priority of the mesage, one of Logger.ERROR,\n\t *                 Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic void log(Class c, String message, int priority) {\n\t\tif (!instanceShouldLog(priority,c)) return;\n\t\tlog(null, c, message, null, priority);\n\t}","id":34838,"modified_method":"/**\n\t * Log a message from static code.\n\t * @param c        The class where this message was generated.\n\t * @param message  A clear and verbose message describing the event\n\t * @param priority The priority of the mesage, one of Logger.ERROR,\n\t *                 Logger.NORMAL, Logger.MINOR, or Logger.DEBUG.\n\t */\n\tpublic void log(Class<?> c, String message, int priority) {\n\t\tif (!instanceShouldLog(priority,c)) return;\n\t\tlog(null, c, message, null, priority);\n\t}","commit_id":"7873847fce845a1edee356dff82b7ad954060ca0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Return the name of the next file with available work\n     */\n    private String selectNewAssignment() {\n        for (Iterator it = filesWithSignificantWork.iterator(); it.hasNext();) {\n            String fn = (String) it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        for (Iterator it = filesWithInsignificantWork.iterator(); it.hasNext();) {\n            String fn = (String) it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        return null;\n    }","id":34839,"modified_method":"/**\n     * Return the name of the next file with available work\n     */\n    private String selectNewAssignment() {\n        for (Iterator<String> it = filesWithSignificantWork.iterator(); it.hasNext();) {\n            String fn = it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        for (Iterator<String> it = filesWithInsignificantWork.iterator(); it.hasNext();) {\n            String fn = it.next();\n            if (!reservedFiles.contains(fn)) {\n                it.remove();\n                return fn;\n            }\n        }\n        return null;\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void addToPendingList(LinkedList pendingOperations) {\n            pendingOperations.add(this);\n        }","id":34840,"modified_method":"void addToPendingList(LinkedList<Operation> pendingOperations) {\n            pendingOperations.add(this);\n        }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"Object process(Object rrd) throws Exception {\n            // if the rrd is already open we are confused\n            if (rrd != null) {\n                log(\"WHAT! rrd open but not created?\");\n                m_delegate.closeFile(rrd);\n                rrd = null;\n            }\n\n            // create the file\n            m_delegate.createFile(getData());\n\n            // keep stats\n            ++createsCompleted;\n\n            // return the file\n            return rrd;\n\n        }","id":34841,"modified_method":"Object process(Object rrd) throws Exception {\n            // if the rrd is already open we are confused\n            if (rrd != null) {\n                log().debug(\"WHAT! rrd open but not created?\");\n                m_delegate.closeFile(rrd);\n                rrd = null;\n            }\n\n            // create the file\n            m_delegate.createFile(getData());\n\n            // keep stats\n            ++createsCompleted;\n\n            // return the file\n            return rrd;\n\n        }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void addToPendingList(LinkedList pendingOperations) {\n            if (pendingOperations.size() > 0 && pendingOperations.getLast() instanceof ZeroUpdateOperation) {\n                ZeroUpdateOperation zeroOp = (ZeroUpdateOperation) pendingOperations.getLast();\n                try {\n                    zeroOp.mergeUpdates(this);\n                } catch (IllegalArgumentException e) {\n                    log(e.getMessage());\n                    super.addToPendingList(pendingOperations);\n                }\n            } else {\n                super.addToPendingList(pendingOperations);\n            }\n        }","id":34842,"modified_method":"void addToPendingList(LinkedList<Operation> pendingOperations) {\n            if (pendingOperations.size() > 0 && pendingOperations.getLast() instanceof ZeroUpdateOperation) {\n                ZeroUpdateOperation zeroOp = (ZeroUpdateOperation) pendingOperations.getLast();\n                try {\n                    zeroOp.mergeUpdates(this);\n                } catch (IllegalArgumentException e) {\n                    log().debug(e.getMessage());\n                    super.addToPendingList(pendingOperations);\n                }\n            } else {\n                super.addToPendingList(pendingOperations);\n            }\n        }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Ensure that files with insignificant changes are getting promoted if\n     * necessary\n     * \n     */\n    private synchronized void promoteAgedFiles() {\n        \n        // no need to do this is we aren't prioritizing\n        if (!PRIORITIZE_SIGS) return;\n\n        // the num seconds to update files is 0 then use unfair prioritization\n        if (MAX_INSIG_UPDATE_SECONDS == 0 || filesWithInsignificantWork.isEmpty())\n            return;\n\n        // calculate the elapsed time we first queued updates\n        long now = System.currentTimeMillis();\n        long elapsedMillis = Math.max(now - updateStart, 1);\n\n        // calculate the milliseconds between promotions necessary to age\n        // insignificant files into\n        // the significant queue\n        double millisPerPromotion = ((MAX_INSIG_UPDATE_SECONDS * 1000.0) / filesWithInsignificantWork.size());\n\n        // calculate the number of millis since start until the next file needs\n        // to be promotoed\n        long nextPromotionMillis = (long) (millisPerPromotion * promotionCount);\n\n        // if more time has elapsed than the next promotion time then promote a\n        // file\n        if (elapsedMillis > nextPromotionMillis) {\n            String file = (String) filesWithInsignificantWork.removeFirst();\n            filesWithSignificantWork.addFirst(file);\n            promotionCount++;\n        }\n\n    }","id":34843,"modified_method":"/**\n     * Ensure that files with insignificant changes are getting promoted if\n     * necessary\n     * \n     */\n    private synchronized void promoteAgedFiles() {\n        \n        // no need to do this is we aren't prioritizing\n        if (!PRIORITIZE_SIGS) return;\n\n        // the num seconds to update files is 0 then use unfair prioritization\n        if (MAX_INSIG_UPDATE_SECONDS == 0 || filesWithInsignificantWork.isEmpty())\n            return;\n\n        // calculate the elapsed time we first queued updates\n        long now = System.currentTimeMillis();\n        long elapsedMillis = Math.max(now - updateStart, 1);\n\n        // calculate the milliseconds between promotions necessary to age\n        // insignificant files into\n        // the significant queue\n        double millisPerPromotion = ((MAX_INSIG_UPDATE_SECONDS * 1000.0) / filesWithInsignificantWork.size());\n\n        // calculate the number of millis since start until the next file needs\n        // to be promotoed\n        long nextPromotionMillis = (long) (millisPerPromotion * promotionCount);\n\n        // if more time has elapsed than the next promotion time then promote a\n        // file\n        if (elapsedMillis > nextPromotionMillis) {\n            String file = filesWithInsignificantWork.removeFirst();\n            filesWithSignificantWork.addFirst(file);\n            promotionCount++;\n        }\n\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Record that fact that the current thread has finished process operations\n     * for its current assignement\n     */\n    private synchronized void completeAssignment() {\n        // remove any existing reservation of the current thread\n        String previousAssignment = (String) fileAssignments.remove(Thread.currentThread());\n        if (previousAssignment != null)\n            reservedFiles.remove(previousAssignment);\n    }","id":34844,"modified_method":"/**\n     * Record that fact that the current thread has finished process operations\n     * for its current assignement\n     */\n    private synchronized void completeAssignment() {\n        // remove any existing reservation of the current thread\n        String previousAssignment = fileAssignments.remove(Thread.currentThread());\n        if (previousAssignment != null)\n            reservedFiles.remove(previousAssignment);\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * We need to track which files are being processed by which threads so that\n     * we don't try to process updates for the same file on more than one\n     * thread.\n     */\n    private synchronized void storeAssignment(Operation op) {\n        // look and see if there a pending ops list for this file\n        LinkedList pendingOperations = (LinkedList) pendingFileOperations.get(op.getFileName());\n\n        // if not then we create an ops list for the file and add the file to\n        // the work items list\n        if (pendingOperations == null) {\n            pendingOperations = new LinkedList();\n            pendingFileOperations.put(op.getFileName(), pendingOperations);\n\n            // add the file to the correct list based on what type of work we\n            // are adding.  (if we aren't prioritizing then every file is counted as\n            // signficant\n            if (!PRIORITIZE_SIGS || op.isSignificant())\n                filesWithSignificantWork.addLast(op.getFileName());\n            else\n                filesWithInsignificantWork.addLast(op.getFileName());\n        } else if (PRIORITIZE_SIGS && op.isSignificant() && hasOnlyInsignificant(pendingOperations)) {\n            // only do this when we are prioritizing as this bumps files from inSig\n            // up to insig\n            // promote the file to the significant list if this is the first\n            // significant\n            filesWithSignificantWork.addLast(op.getFileName());\n        }\n\n        promoteAgedFiles();\n\n        op.addToPendingList(pendingOperations);\n    }","id":34845,"modified_method":"/**\n     * We need to track which files are being processed by which threads so that\n     * we don't try to process updates for the same file on more than one\n     * thread.\n     */\n    private synchronized void storeAssignment(Operation op) {\n        // look and see if there a pending ops list for this file\n        LinkedList<Operation> pendingOperations = pendingFileOperations.get(op.getFileName());\n\n        // if not then we create an ops list for the file and add the file to\n        // the work items list\n        if (pendingOperations == null) {\n            pendingOperations = new LinkedList<Operation>();\n            pendingFileOperations.put(op.getFileName(), pendingOperations);\n\n            // add the file to the correct list based on what type of work we\n            // are adding.  (if we aren't prioritizing then every file is counted as\n            // signficant\n            if (!PRIORITIZE_SIGS || op.isSignificant())\n                filesWithSignificantWork.addLast(op.getFileName());\n            else\n                filesWithInsignificantWork.addLast(op.getFileName());\n        } else if (PRIORITIZE_SIGS && op.isSignificant() && hasOnlyInsignificant(pendingOperations)) {\n            // only do this when we are prioritizing as this bumps files from inSig\n            // up to insig\n            // promote the file to the significant list if this is the first\n            // significant\n            filesWithSignificantWork.addLast(op.getFileName());\n        }\n\n        promoteAgedFiles();\n\n        op.addToPendingList(pendingOperations);\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Operation makeUpdateOperation(String fileName, String owner, String update) {\n        try {\n            int colon = update.indexOf(':');\n            if ((colon >= 0) && (Double.parseDouble(update.substring(colon + 1)) == 0.0)) {\n                long initialTimeStamp = Long.parseLong(update.substring(0, colon));\n                if (initialTimeStamp == 0)\n                    log(\"ZERO ERROR: created a zero update with ts=0 for file: \" + fileName + \" data: \" + update);\n\n                return new ZeroUpdateOperation(fileName, initialTimeStamp);\n            }\n        } catch (NumberFormatException e) {\n\n        }\n        return new UpdateOperation(fileName, update);\n    }","id":34846,"modified_method":"public Operation makeUpdateOperation(String fileName, String owner, String update) {\n        try {\n            int colon = update.indexOf(':');\n            if ((colon >= 0) && (Double.parseDouble(update.substring(colon + 1)) == 0.0)) {\n                long initialTimeStamp = Long.parseLong(update.substring(0, colon));\n                if (initialTimeStamp == 0)\n                    log().debug(\"ZERO ERROR: created a zero update with ts=0 for file: \" + fileName + \" data: \" + update);\n\n                return new ZeroUpdateOperation(fileName, initialTimeStamp);\n            }\n        } catch (NumberFormatException e) {\n\n        }\n        return new UpdateOperation(fileName, update);\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void logLapTime(String message, Throwable t) {\n        log(message + \" \" + getLapTime(), t);\n    }","id":34847,"modified_method":"void logLapTime(String message, Throwable t) {\n        log().debug(message + \" \" + getLapTime(), t);\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Actually process the operations be calling the underlying delegate\n     * strategy\n     */\n    private void processPendingOperations() {\n        Object rrd = null;\n        String fileName = null;\n\n        try {\n            LinkedList ops = getNext();\n            if (ops == null)\n                return;\n            // update stats correctly we update them even if an exception occurs\n            // while we are processing\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                if (op.isSignificant()) {\n                    significantOpsCompleted++;\n                }\n\n            }\n            // now we actually process the events\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                fileName = op.getFileName();\n                rrd = op.process(rrd);\n            }\n        } catch (Exception e) {\n            errors++;\n            logLapTime(\"Error updating file \" + fileName + \": \" + e.getMessage());\n            log(\"Error upading file \" + fileName + \": \" + e.getMessage(), e);\n        } finally {\n            processClose(rrd);\n        }\n    }","id":34848,"modified_method":"/**\n     * Actually process the operations be calling the underlying delegate\n     * strategy\n     */\n    private void processPendingOperations() {\n        Object rrd = null;\n        String fileName = null;\n\n        try {\n            LinkedList ops = getNext();\n            if (ops == null)\n                return;\n            // update stats correctly we update them even if an exception occurs\n            // while we are processing\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                if (op.isSignificant()) {\n                    significantOpsCompleted++;\n                }\n\n            }\n            // now we actually process the events\n            for (Iterator it = ops.iterator(); it.hasNext();) {\n                Operation op = (Operation) it.next();\n                fileName = op.getFileName();\n                rrd = op.process(rrd);\n            }\n        } catch (Exception e) {\n            errors++;\n            logLapTime(\"Error updating file \" + fileName + \": \" + e.getMessage());\n            log().debug(\"Error upading file \" + fileName + \": \" + e.getMessage(), e);\n        } finally {\n            processClose(rrd);\n        }\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Category log() {\n        return Category.getInstance(LOG4J_CATEGORY);\n    }","id":34849,"modified_method":"private Category log() {\n        return Logger.getLogger(LOG4J_CATEGORY);\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return true if and only if all the operations in the list are\n     * insignificant\n     */\n    private boolean hasOnlyInsignificant(LinkedList pendingOps) {\n        for (Iterator it = pendingOps.iterator(); it.hasNext();) {\n            Operation op = (Operation) it.next();\n            if (op.isSignificant()) {\n                return false;\n            }\n        }\n        return true;\n    }","id":34850,"modified_method":"/**\n     * Return true if and only if all the operations in the list are\n     * insignificant\n     */\n    private boolean hasOnlyInsignificant(LinkedList<Operation> pendingOps) {\n        for (Iterator<Operation> it = pendingOps.iterator(); it.hasNext();) {\n            Operation op = it.next();\n            if (op.isSignificant()) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void logLapTime(String message) {\n        log(message + \" \" + getLapTime());\n    }","id":34851,"modified_method":"void logLapTime(String message) {\n        log().debug(message + \" \" + getLapTime());\n    }","commit_id":"3b05ce92aaaac296bf230627f42f0275e35e8cc5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void socketTimeouts() {\n        long now = System.currentTimeMillis();\n        if ( (now-lastCheck) < getSelectorTimeout() ) return;\n        //timeout\n        Selector tmpsel = selector;\n        Set keys =  (isListening()&&tmpsel!=null)?tmpsel.keys():null;\n        if ( keys == null ) return;\n        for (Iterator iter = keys.iterator(); iter.hasNext(); ) {\n            SelectionKey key = (SelectionKey) iter.next();\n            try {\n//                if (key.interestOps() == SelectionKey.OP_READ) {\n//                    //only timeout sockets that we are waiting for a read from\n//                    ObjectReader ka = (ObjectReader) key.attachment();\n//                    long delta = now - ka.getLastAccess();\n//                    if (delta > (long) getTimeout()) {\n//                        cancelledKey(key);\n//                    }\n//                }\n//                else\n                if ( key.interestOps() == 0 ) {\n                    //check for keys that didn't make it in.\n                    ObjectReader ka = (ObjectReader) key.attachment();\n                    if ( ka != null ) {\n                        long delta = now - ka.getLastAccess();\n                        if (delta > (long) getTimeout() && (!ka.isAccessed())) {\n                            if (log.isWarnEnabled())\n                                log.warn(\"Channel key is registered, but has had no interest ops for the last \"+getTimeout()+\" ms. (cancelled:\"+ka.isCancelled()+\"):\"+key+\" last access:\"+new java.sql.Timestamp(ka.getLastAccess())+\" Possible cause: all threads used, perform thread dump\");\n                            ka.setLastAccess(now);\n                            //key.interestOps(SelectionKey.OP_READ);\n                        }//end if\n                    } else {\n                        cancelledKey(key);\n                    }//end if\n                }//end if\n            }catch ( CancelledKeyException ckx ) {\n                cancelledKey(key);\n            }\n        }\n        lastCheck = System.currentTimeMillis();\n    }","id":34852,"modified_method":"protected void socketTimeouts() {\n        long now = System.currentTimeMillis();\n        if ( (now-lastCheck) < getSelectorTimeout() ) return;\n        //timeout\n        Selector tmpsel = selector;\n        Set<SelectionKey> keys =  (isListening()&&tmpsel!=null)?tmpsel.keys():null;\n        if ( keys == null ) return;\n        for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext(); ) {\n            SelectionKey key = iter.next();\n            try {\n//                if (key.interestOps() == SelectionKey.OP_READ) {\n//                    //only timeout sockets that we are waiting for a read from\n//                    ObjectReader ka = (ObjectReader) key.attachment();\n//                    long delta = now - ka.getLastAccess();\n//                    if (delta > (long) getTimeout()) {\n//                        cancelledKey(key);\n//                    }\n//                }\n//                else\n                if ( key.interestOps() == 0 ) {\n                    //check for keys that didn't make it in.\n                    ObjectReader ka = (ObjectReader) key.attachment();\n                    if ( ka != null ) {\n                        long delta = now - ka.getLastAccess();\n                        if (delta > getTimeout() && (!ka.isAccessed())) {\n                            if (log.isWarnEnabled())\n                                log.warn(\"Channel key is registered, but has had no interest ops for the last \"+getTimeout()+\" ms. (cancelled:\"+ka.isCancelled()+\"):\"+key+\" last access:\"+new java.sql.Timestamp(ka.getLastAccess())+\" Possible cause: all threads used, perform thread dump\");\n                            ka.setLastAccess(now);\n                            //key.interestOps(SelectionKey.OP_READ);\n                        }//end if\n                    } else {\n                        cancelledKey(key);\n                    }//end if\n                }//end if\n            }catch ( CancelledKeyException ckx ) {\n                cancelledKey(key);\n            }\n        }\n        lastCheck = System.currentTimeMillis();\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"private void closeSelector() throws IOException {\n        Selector selector = this.selector;\n        this.selector = null;\n        if (selector==null) return;\n        try {\n            Iterator it = selector.keys().iterator();\n            // look at each key in the selected set\n            while (it.hasNext()) {\n                SelectionKey key = (SelectionKey)it.next();\n                key.channel().close();\n                key.attach(null);\n                key.cancel();\n            }\n        }catch ( IOException ignore ){\n            if (log.isWarnEnabled()) {\n                log.warn(\"Unable to cleanup on selector close.\",ignore);\n            }\n        }catch ( ClosedSelectorException ignore){}\n        selector.close();\n    }","id":34853,"modified_method":"private void closeSelector() throws IOException {\n        Selector selector = this.selector;\n        this.selector = null;\n        if (selector==null) return;\n        try {\n            Iterator<SelectionKey> it = selector.keys().iterator();\n            // look at each key in the selected set\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                key.channel().close();\n                key.attach(null);\n                key.cancel();\n            }\n        }catch ( IOException ignore ){\n            if (log.isWarnEnabled()) {\n                log.warn(\"Unable to cleanup on selector close.\",ignore);\n            }\n        }catch ( ClosedSelectorException ignore){}\n        selector.close();\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"protected void bind() throws IOException {\n        // allocate an unbound server socket channel\n        serverChannel = ServerSocketChannel.open();\n        // Get the associated ServerSocket to bind it with\n        ServerSocket serverSocket = serverChannel.socket();\n        // create a new Selector for use below\n        selector = Selector.open();\n        // set the port the server channel will listen to\n        //serverSocket.bind(new InetSocketAddress(getBind(), getTcpListenPort()));\n        bind(serverSocket,getTcpListenPort(),getAutoBind());\n        // set non-blocking mode for the listening socket\n        serverChannel.configureBlocking(false);\n        // register the ServerSocketChannel with the Selector\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        //set up the datagram channel\n        if (this.getUdpPort()>0) {\n            datagramChannel = DatagramChannel.open();\n            datagramChannel.configureBlocking(false);\n            //bind to the address to avoid security checks\n            bindUdp(datagramChannel.socket(),getUdpPort(),getAutoBind());\n        }\n\n\n\n    }","id":34854,"modified_method":"protected void bind() throws IOException {\n        // allocate an unbound server socket channel\n        serverChannel = ServerSocketChannel.open();\n        // Get the associated ServerSocket to bind it with\n        ServerSocket serverSocket = serverChannel.socket();\n        // create a new Selector for use below\n        selector = Selector.open();\n        // set the port the server channel will listen to\n        //serverSocket.bind(new InetSocketAddress(getBind(), getTcpListenPort()));\n        bind(serverSocket,getPort(),getAutoBind());\n        // set non-blocking mode for the listening socket\n        serverChannel.configureBlocking(false);\n        // register the ServerSocketChannel with the Selector\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        //set up the datagram channel\n        if (this.getUdpPort()>0) {\n            datagramChannel = DatagramChannel.open();\n            datagramChannel.configureBlocking(false);\n            //bind to the address to avoid security checks\n            bindUdp(datagramChannel.socket(),getUdpPort(),getAutoBind());\n        }\n\n\n\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"public void events() {\n        if ( events.size() == 0 ) return;\n        synchronized (events) {\n            Runnable r = null;\n            while ( (events.size() > 0) && (r = (Runnable)events.removeFirst()) != null ) {\n                try {\n                    if ( log.isTraceEnabled() ) log.trace(\"Processing event in selector:\"+r);\n                    r.run();\n                } catch ( Exception x ) {\n                    log.error(\"\",x);\n                }\n            }\n            events.clear();\n        }\n    }","id":34855,"modified_method":"public void events() {\n        if ( events.size() == 0 ) return;\n        synchronized (events) {\n            Runnable r = null;\n            while ( (events.size() > 0) && (r = events.removeFirst()) != null ) {\n                try {\n                    if ( log.isTraceEnabled() ) log.trace(\"Processing event in selector:\"+r);\n                    r.run();\n                } catch ( Exception x ) {\n                    log.error(\"\",x);\n                }\n            }\n            events.clear();\n        }\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * get data from channel and store in byte array\n     * send it to cluster\n     * @throws IOException\n     * @throws java.nio.channels.ClosedChannelException\n     */\n    protected void listen() throws Exception {\n        if (doListen()) {\n            log.warn(\"ServerSocketChannel already started\");\n            return;\n        }\n\n        setListen(true);\n        if (selector!=null && datagramChannel!=null) {\n            ObjectReader oreader = new ObjectReader(MAX_UDP_SIZE); //max size for a datagram packet\n            datagramChannel.socket().setSendBufferSize(getUdpTxBufSize());\n            datagramChannel.socket().setReceiveBufferSize(getUdpRxBufSize());\n            datagramChannel.socket().setReuseAddress(getSoReuseAddress());\n            datagramChannel.socket().setSoTimeout(getTimeout());\n            datagramChannel.socket().setTrafficClass(getSoTrafficClass());\n            registerChannel(selector,datagramChannel,SelectionKey.OP_READ,oreader);\n        }\n\n        while (doListen() && selector != null) {\n            // this may block for a long time, upon return the\n            // selected set contains keys of the ready channels\n            try {\n                events();\n                socketTimeouts();\n                int n = selector.select(getTcpSelectorTimeout());\n                if (n == 0) {\n                    //there is a good chance that we got here\n                    //because the TcpReplicationThread called\n                    //selector wakeup().\n                    //if that happens, we must ensure that that\n                    //thread has enough time to call interestOps\n//                    synchronized (interestOpsMutex) {\n                        //if we got the lock, means there are no\n                        //keys trying to register for the\n                        //interestOps method\n//                    }\n                    continue; // nothing to do\n                }\n                // get an iterator over the set of selected keys\n                Iterator it = (selector!=null)?selector.selectedKeys().iterator():null;\n                // look at each key in the selected set\n                while (selector!=null && it.hasNext()) {\n                    SelectionKey key = (SelectionKey) it.next();\n                    // Is a new connection coming in?\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n                        SocketChannel channel = server.accept();\n                        channel.socket().setReceiveBufferSize(getRxBufSize());\n                        channel.socket().setSendBufferSize(getTxBufSize());\n                        channel.socket().setTcpNoDelay(getTcpNoDelay());\n                        channel.socket().setKeepAlive(getSoKeepAlive());\n                        channel.socket().setOOBInline(getOoBInline());\n                        channel.socket().setReuseAddress(getSoReuseAddress());\n                        channel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());\n                        channel.socket().setTrafficClass(getSoTrafficClass());\n                        channel.socket().setSoTimeout(getTimeout());\n                        Object attach = new ObjectReader(channel);\n                        registerChannel(selector,\n                                        channel,\n                                        SelectionKey.OP_READ,\n                                        attach);\n                    }\n                    // is there data to read on this channel?\n                    if (key.isReadable()) {\n                        readDataFromSocket(key);\n                    } else {\n                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));\n                    }\n\n                    // remove key from selected set, it's been handled\n                    if (selector!=null) it.remove();\n                }\n            } catch (java.nio.channels.ClosedSelectorException cse) {\n                // ignore is normal at shutdown or stop listen socket\n            } catch (java.nio.channels.CancelledKeyException nx) {\n                log.warn(\"Replication client disconnected, error when polling key. Ignoring client.\");\n            } catch (Throwable x) {\n                try {\n                    log.error(\"Unable to process request in NioReceiver\", x);\n                }catch ( Throwable tx ) {\n                    //in case an out of memory error, will affect the logging framework as well\n                    tx.printStackTrace();\n                }\n            }\n\n        }\n        serverChannel.close();\n        if (datagramChannel!=null) {\n            try {\n                datagramChannel.close();\n            }catch (Exception iox) {\n                if (log.isDebugEnabled()) log.debug(\"Unable to close datagram channel.\",iox);\n            }\n            datagramChannel=null;\n        }\n        closeSelector();\n    }","id":34856,"modified_method":"/**\n     * get data from channel and store in byte array\n     * send it to cluster\n     * @throws IOException\n     * @throws java.nio.channels.ClosedChannelException\n     */\n    protected void listen() throws Exception {\n        if (doListen()) {\n            log.warn(\"ServerSocketChannel already started\");\n            return;\n        }\n\n        setListen(true);\n        if (selector!=null && datagramChannel!=null) {\n            ObjectReader oreader = new ObjectReader(MAX_UDP_SIZE); //max size for a datagram packet\n            datagramChannel.socket().setSendBufferSize(getUdpTxBufSize());\n            datagramChannel.socket().setReceiveBufferSize(getUdpRxBufSize());\n            datagramChannel.socket().setReuseAddress(getSoReuseAddress());\n            datagramChannel.socket().setSoTimeout(getTimeout());\n            datagramChannel.socket().setTrafficClass(getSoTrafficClass());\n            registerChannel(selector,datagramChannel,SelectionKey.OP_READ,oreader);\n        }\n\n        while (doListen() && selector != null) {\n            // this may block for a long time, upon return the\n            // selected set contains keys of the ready channels\n            try {\n                events();\n                socketTimeouts();\n                int n = selector.select(getSelectorTimeout());\n                if (n == 0) {\n                    //there is a good chance that we got here\n                    //because the TcpReplicationThread called\n                    //selector wakeup().\n                    //if that happens, we must ensure that that\n                    //thread has enough time to call interestOps\n//                    synchronized (interestOpsMutex) {\n                        //if we got the lock, means there are no\n                        //keys trying to register for the\n                        //interestOps method\n//                    }\n                    continue; // nothing to do\n                }\n                // get an iterator over the set of selected keys\n                Iterator<SelectionKey> it = (selector!=null)?selector.selectedKeys().iterator():null;\n                // look at each key in the selected set\n                while (selector!=null && it.hasNext()) {\n                    SelectionKey key = it.next();\n                    // Is a new connection coming in?\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n                        SocketChannel channel = server.accept();\n                        channel.socket().setReceiveBufferSize(getRxBufSize());\n                        channel.socket().setSendBufferSize(getTxBufSize());\n                        channel.socket().setTcpNoDelay(getTcpNoDelay());\n                        channel.socket().setKeepAlive(getSoKeepAlive());\n                        channel.socket().setOOBInline(getOoBInline());\n                        channel.socket().setReuseAddress(getSoReuseAddress());\n                        channel.socket().setSoLinger(getSoLingerOn(),getSoLingerTime());\n                        channel.socket().setTrafficClass(getSoTrafficClass());\n                        channel.socket().setSoTimeout(getTimeout());\n                        Object attach = new ObjectReader(channel);\n                        registerChannel(selector,\n                                        channel,\n                                        SelectionKey.OP_READ,\n                                        attach);\n                    }\n                    // is there data to read on this channel?\n                    if (key.isReadable()) {\n                        readDataFromSocket(key);\n                    } else {\n                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));\n                    }\n\n                    // remove key from selected set, it's been handled\n                    if (selector!=null) it.remove();\n                }\n            } catch (java.nio.channels.ClosedSelectorException cse) {\n                // ignore is normal at shutdown or stop listen socket\n            } catch (java.nio.channels.CancelledKeyException nx) {\n                log.warn(\"Replication client disconnected, error when polling key. Ignoring client.\");\n            } catch (Throwable x) {\n                try {\n                    log.error(\"Unable to process request in NioReceiver\", x);\n                }catch ( Throwable tx ) {\n                    //in case an out of memory error, will affect the logging framework as well\n                    tx.printStackTrace();\n                }\n            }\n\n        }\n        serverChannel.close();\n        if (datagramChannel!=null) {\n            try {\n                datagramChannel.close();\n            }catch (Exception iox) {\n                if (log.isDebugEnabled()) log.debug(\"Unable to close datagram channel.\",iox);\n            }\n            datagramChannel=null;\n        }\n        closeSelector();\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"public boolean keepalive() {\n        boolean result = false;\n        for ( Iterator i = nioSenders.entrySet().iterator(); i.hasNext();  ) {\n            Map.Entry entry = (Map.Entry)i.next();\n            NioSender sender = (NioSender)entry.getValue();\n            if ( sender.keepalive() ) {\n                //nioSenders.remove(entry.getKey());\n                i.remove();\n                result = true;\n            } else {\n                try {\n                    sender.read(null);\n                }catch ( IOException x ) {\n                    sender.disconnect();\n                    sender.reset();\n                    //nioSenders.remove(entry.getKey());\n                    i.remove();\n                    result = true;\n                }catch ( Exception x ) {\n                    log.warn(\"Error during keepalive test for sender:\"+sender,x);\n                }\n            }\n        }\n        //clean up any cancelled keys\n        if ( result ) try { selector.selectNow(); }catch (Exception ignore){}\n        return result;\n    }","id":34857,"modified_method":"public boolean keepalive() {\n        boolean result = false;\n        for ( Iterator<Entry<Member, NioSender>> i = nioSenders.entrySet().iterator(); i.hasNext();  ) {\n            Map.Entry<Member, NioSender> entry = i.next();\n            NioSender sender = entry.getValue();\n            if ( sender.keepalive() ) {\n                //nioSenders.remove(entry.getKey());\n                i.remove();\n                result = true;\n            } else {\n                try {\n                    sender.read(null);\n                }catch ( IOException x ) {\n                    sender.disconnect();\n                    sender.reset();\n                    //nioSenders.remove(entry.getKey());\n                    i.remove();\n                    result = true;\n                }catch ( Exception x ) {\n                    log.warn(\"Error during keepalive test for sender:\"+sender,x);\n                }\n            }\n        }\n        //clean up any cancelled keys\n        if ( result ) try { selector.selectNow(); }catch (Exception ignore){}\n        return result;\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"public void remove(Member member) {\n        //disconnect senders\n        NioSender sender = (NioSender)nioSenders.remove(member);\n        if ( sender != null ) sender.disconnect();\n    }","id":34858,"modified_method":"public void remove(Member member) {\n        //disconnect senders\n        NioSender sender = nioSenders.remove(member);\n        if ( sender != null ) sender.disconnect();\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"private synchronized void close() throws ChannelException  {\n        ChannelException x = null;\n        Object[] members = nioSenders.keySet().toArray();\n        for (int i=0; i<members.length; i++ ) {\n            Member mbr = (Member)members[i];\n            try {\n                NioSender sender = (NioSender)nioSenders.get(mbr);\n                sender.disconnect();\n            }catch ( Exception e ) {\n                if ( x == null ) x = new ChannelException(e);\n                x.addFaultyMember(mbr,e);\n            }\n            nioSenders.remove(mbr);\n        }\n        if ( x != null ) throw x;\n    }","id":34859,"modified_method":"private synchronized void close() throws ChannelException  {\n        ChannelException x = null;\n        Object[] members = nioSenders.keySet().toArray();\n        for (int i=0; i<members.length; i++ ) {\n            Member mbr = (Member)members[i];\n            try {\n                NioSender sender = nioSenders.get(mbr);\n                sender.disconnect();\n            }catch ( Exception e ) {\n                if ( x == null ) x = new ChannelException(e);\n                x.addFaultyMember(mbr,e);\n            }\n            nioSenders.remove(mbr);\n        }\n        if ( x != null ) throw x;\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"private NioSender[] setupForSend(Member[] destination) throws ChannelException {\n        ChannelException cx = null;\n        NioSender[] result = new NioSender[destination.length];\n        for ( int i=0; i<destination.length; i++ ) {\n            NioSender sender = (NioSender)nioSenders.get(destination[i]);\n            try {\n\n                if (sender == null) {\n                    sender = new NioSender();\n                    sender.transferProperties(this, sender);\n                    nioSenders.put(destination[i], sender);\n                }\n                if (sender != null) {\n                    sender.reset();\n                    sender.setDestination(destination[i]);\n                    sender.setSelector(selector);\n                    sender.setUdpBased(isUdpBased());\n                    result[i] = sender;\n                }\n            }catch ( UnknownHostException x ) {\n                if (cx == null) cx = new ChannelException(\"Unable to setup NioSender.\", x);\n                cx.addFaultyMember(destination[i], x);\n            }\n        }\n        if ( cx != null ) throw cx;\n        else return result;\n    }","id":34860,"modified_method":"private NioSender[] setupForSend(Member[] destination) throws ChannelException {\n        ChannelException cx = null;\n        NioSender[] result = new NioSender[destination.length];\n        for ( int i=0; i<destination.length; i++ ) {\n            NioSender sender = nioSenders.get(destination[i]);\n            try {\n\n                if (sender == null) {\n                    sender = new NioSender();\n                    AbstractSender.transferProperties(this, sender);\n                    nioSenders.put(destination[i], sender);\n                }\n                sender.reset();\n                sender.setDestination(destination[i]);\n                sender.setSelector(selector);\n                sender.setUdpBased(isUdpBased());\n                result[i] = sender;\n            }catch ( UnknownHostException x ) {\n                if (cx == null) cx = new ChannelException(\"Unable to setup NioSender.\", x);\n                cx.addFaultyMember(destination[i], x);\n            }\n        }\n        if ( cx != null ) throw cx;\n        else return result;\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {\n        int completed = 0;\n        int selectedKeys = selector.select(selectTimeOut);\n\n        if (selectedKeys == 0) {\n            return 0;\n        }\n\n        Iterator it = selector.selectedKeys().iterator();\n        while (it.hasNext()) {\n            SelectionKey sk = (SelectionKey) it.next();\n            it.remove();\n            int readyOps = sk.readyOps();\n            sk.interestOps(sk.interestOps() & ~readyOps);\n            NioSender sender = (NioSender) sk.attachment();\n            try {\n                if (sender.process(sk,waitForAck)) {\n                    completed++;\n                    sender.setComplete(true);\n                    if ( Logs.MESSAGES.isTraceEnabled() ) {\n                        Logs.MESSAGES.trace(\"ParallelNioSender - Sent msg:\" + new UniqueId(msg.getUniqueId()) + \" at \" +new java.sql.Timestamp(System.currentTimeMillis())+ \" to \"+sender.getDestination().getName());\n                    }\n                    SenderState.getSenderState(sender.getDestination()).setReady();\n                }//end if\n            } catch (Exception x) {\n                SenderState state = SenderState.getSenderState(sender.getDestination());\n                int attempt = sender.getAttempt()+1;\n                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);\n                synchronized (state) {\n\n                    //sk.cancel();\n                    if (state.isSuspect()) state.setFailing();\n                    if (state.isReady()) {\n                        state.setSuspect();\n                        if ( retry )\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect and retrying.\");\n                        else\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect.\", x);\n                    }\n                }\n                if ( !isConnected() ) {\n                    log.warn(\"Not retrying send for:\" + sender.getDestination().getName() + \"; Sender is disconnected.\");\n                    ChannelException cx = new ChannelException(\"Send failed, and sender is disconnected. Not retrying.\",x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }\n\n                byte[] data = sender.getMessage();\n                if ( retry ) {\n                    try {\n                        sender.disconnect();\n                        sender.connect();\n                        sender.setAttempt(attempt);\n                        sender.setMessage(data);\n                    }catch ( Exception ignore){\n                        state.setFailing();\n                    }\n                } else {\n                    ChannelException cx = new ChannelException(\"Send failed, attempt:\"+sender.getAttempt()+\" max:\"+maxAttempts,x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }//end if\n            }\n        }\n        return completed;\n\n    }","id":34861,"modified_method":"private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {\n        int completed = 0;\n        int selectedKeys = selector.select(selectTimeOut);\n\n        if (selectedKeys == 0) {\n            return 0;\n        }\n\n        Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n        while (it.hasNext()) {\n            SelectionKey sk = it.next();\n            it.remove();\n            int readyOps = sk.readyOps();\n            sk.interestOps(sk.interestOps() & ~readyOps);\n            NioSender sender = (NioSender) sk.attachment();\n            try {\n                if (sender.process(sk,waitForAck)) {\n                    completed++;\n                    sender.setComplete(true);\n                    if ( Logs.MESSAGES.isTraceEnabled() ) {\n                        Logs.MESSAGES.trace(\"ParallelNioSender - Sent msg:\" + new UniqueId(msg.getUniqueId()) + \" at \" +new java.sql.Timestamp(System.currentTimeMillis())+ \" to \"+sender.getDestination().getName());\n                    }\n                    SenderState.getSenderState(sender.getDestination()).setReady();\n                }//end if\n            } catch (Exception x) {\n                SenderState state = SenderState.getSenderState(sender.getDestination());\n                int attempt = sender.getAttempt()+1;\n                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);\n                synchronized (state) {\n\n                    //sk.cancel();\n                    if (state.isSuspect()) state.setFailing();\n                    if (state.isReady()) {\n                        state.setSuspect();\n                        if ( retry )\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect and retrying.\");\n                        else\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect.\", x);\n                    }\n                }\n                if ( !isConnected() ) {\n                    log.warn(\"Not retrying send for:\" + sender.getDestination().getName() + \"; Sender is disconnected.\");\n                    ChannelException cx = new ChannelException(\"Send failed, and sender is disconnected. Not retrying.\",x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }\n\n                byte[] data = sender.getMessage();\n                if ( retry ) {\n                    try {\n                        sender.disconnect();\n                        sender.connect();\n                        sender.setAttempt(attempt);\n                        sender.setMessage(data);\n                    }catch ( Exception ignore){\n                        state.setFailing();\n                    }\n                } else {\n                    ChannelException cx = new ChannelException(\"Send failed, attempt:\"+sender.getAttempt()+\" max:\"+maxAttempts,x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }//end if\n            }\n        }\n        return completed;\n\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"public DataSender getNewDataSender() {\n        try {\n            ParallelNioSender sender = new ParallelNioSender();\n            sender.transferProperties(this,sender);\n            return sender;\n        } catch ( IOException x ) {\n            throw new RuntimeException(\"Unable to open NIO selector.\",x);\n        }\n    }","id":34862,"modified_method":"public DataSender getNewDataSender() {\n        try {\n            ParallelNioSender sender = new ParallelNioSender();\n            AbstractSender.transferProperties(this,sender);\n            return sender;\n        } catch ( IOException x ) {\n            throw new RuntimeException(\"Unable to open NIO selector.\",x);\n        }\n    }","commit_id":"bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<span>\");\n\n\t\tString documentLink = wrapLink(\n\t\t\tgetLinkURL(\n\t\t\t\tactivity.getClassName(), activity.getClassPK(), serviceContext),\n\t\t\tserviceContext.translate(\"view-document\"));\n\n\t\tsb.append(documentLink);\n\n\t\tsb.append(\"<\/span><span>\");\n\n\t\tStringBundler downloadLink = new StringBundler(8);\n\n\t\tdownloadLink.append(serviceContext.getPortalURL());\n\t\tdownloadLink.append(serviceContext.getPathMain());\n\t\tdownloadLink.append(\"/document_library/get_file?groupId=\");\n\n\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tdownloadLink.append(fileEntry.getRepositoryId());\n\n\t\tdownloadLink.append(\"&folderId=\");\n\t\tdownloadLink.append(fileEntry.getFolderId());\n\t\tdownloadLink.append(\"&title=\");\n\t\tdownloadLink.append(HttpUtil.encodeURL(fileEntry.getTitle()));\n\n\t\tsb.append(\n\t\t\twrapLink(\n\t\t\t\tdownloadLink.toString(), serviceContext.translate(\"download\")));\n\n\t\tsb.append(\"<\/span>\");\n\n\t\treturn sb.toString();\n\t}","id":34863,"modified_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(serviceContext.getPortalURL());\n\t\tsb.append(serviceContext.getPathMain());\n\t\tsb.append(\"/document_library/get_file?groupId=\");\n\n\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tsb.append(fileEntry.getRepositoryId());\n\n\t\tsb.append(\"&folderId=\");\n\t\tsb.append(fileEntry.getFolderId());\n\t\tsb.append(\"&title=\");\n\t\tsb.append(HttpUtil.encodeURL(fileEntry.getTitle()));\n\n\t\tString downloadLink = wrapLink(\n\t\t\tsb.toString(), serviceContext.translate(\"download\"));\n\n\t\treturn \"<span>\" + downloadLink + \"<\/span>\";\n\t}","commit_id":"84512fe67a1d97262e5af22c9d04269a0f94b96f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivitySet activitySet, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tif (activitySet.getType() == _ACTIVITY_KEY_UPDATE_PAGE) {\n\t\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivitySet.getExtraData());\n\n\t\t\tString sourceVersion = extraDataJSONObject.getString(\n\t\t\t\t\"sourceVersion\");\n\t\t\tString targetVersion = extraDataJSONObject.getString(\n\t\t\t\t\"targetVersion\");\n\n\t\t\treturn getLink(\n\t\t\t\tactivitySet.getGroupId(), activitySet.getClassName(),\n\t\t\t\tactivitySet.getClassPK(), activitySet.getType(), sourceVersion,\n\t\t\t\ttargetVersion, serviceContext);\n\t\t}\n\n\t\treturn null;\n\t}","id":34864,"modified_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivitySet activitySet, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tif (activitySet.getType() != _ACTIVITY_KEY_UPDATE_PAGE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\tactivitySet.getExtraData());\n\n\t\tString sourceVersion = extraDataJSONObject.getString(\"sourceVersion\");\n\t\tString targetVersion = extraDataJSONObject.getString(\"targetVersion\");\n\n\t\treturn getLink(\n\t\t\tactivitySet.getGroupId(), activitySet.getClassPK(), sourceVersion,\n\t\t\ttargetVersion, serviceContext);\n\t}","commit_id":"84512fe67a1d97262e5af22c9d04269a0f94b96f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString sourceVersion = null;\n\t\tString targetVersion = null;\n\n\t\tif (activity.getType() == _ACTIVITY_KEY_UPDATE_PAGE) {\n\t\t\tSocialActivity socialActivity =\n\t\t\t\tSocialActivityLocalServiceUtil.fetchSocialActivity(\n\t\t\t\t\tactivity.getActivityId());\n\n\t\t\tSocialActivitySet activitySet =\n\t\t\t\tSocialActivitySetLocalServiceUtil.fetchSocialActivitySet(\n\t\t\t\t\tsocialActivity.getActivitySetId());\n\n\t\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivitySet.getExtraData());\n\n\t\t\tsourceVersion = extraDataJSONObject.getString(\"sourceVersion\");\n\t\t\ttargetVersion = extraDataJSONObject.getString(\"targetVersion\");\n\t\t}\n\n\t\treturn getLink(\n\t\t\tactivity.getGroupId(), activity.getClassName(),\n\t\t\tactivity.getClassPK(), activity.getType(), sourceVersion,\n\t\t\ttargetVersion, serviceContext);\n\t}","id":34865,"modified_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tif (activity.getType() != _ACTIVITY_KEY_UPDATE_PAGE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivity socialActivity =\n\t\t\tSocialActivityLocalServiceUtil.fetchSocialActivity(\n\t\t\t\tactivity.getActivityId());\n\n\t\tSocialActivitySet activitySet =\n\t\t\tSocialActivitySetLocalServiceUtil.fetchSocialActivitySet(\n\t\t\t\tsocialActivity.getActivitySetId());\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\tactivitySet.getExtraData());\n\n\t\tString sourceVersion = extraDataJSONObject.getString(\"sourceVersion\");\n\t\tString targetVersion = extraDataJSONObject.getString(\"targetVersion\");\n\n\t\treturn getLink(\n\t\t\tactivity.getGroupId(), activity.getClassPK(), sourceVersion,\n\t\t\ttargetVersion, serviceContext);\n\t}","commit_id":"84512fe67a1d97262e5af22c9d04269a0f94b96f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getLink(\n\t\t\tlong groupId, String className, long classPK, int type,\n\t\t\tString sourceVersion, String targetVersion,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(3);\n\n\t\tsb.append(\"<span>\");\n\t\tsb.append(\n\t\t\twrapLink(\n\t\t\t\tgetLinkURL(className, classPK, serviceContext),\n\t\t\t\tserviceContext.translate(\"view-wiki\")));\n\t\tsb.append(\"<\/span>\");\n\n\t\tif (type == _ACTIVITY_KEY_UPDATE_PAGE) {\n\t\t\tsb.append(\"<span>\");\n\t\t\tsb.append(\n\t\t\t\twrapLink(\n\t\t\t\t\tgetDiffsURL(\n\t\t\t\t\t\tclassPK, groupId, sourceVersion, targetVersion,\n\t\t\t\t\t\tserviceContext),\n\t\t\t\t\tserviceContext.translate(\"view-changes\")));\n\t\t\tsb.append(\"<\/span>\");\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":34866,"modified_method":"protected String getLink(\n\t\t\tlong groupId, long classPK, String sourceVersion,\n\t\t\tString targetVersion, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString diffsURL = wrapLink(\n\t\t\tgetDiffsURL(\n\t\t\t\tclassPK, groupId, sourceVersion, targetVersion, serviceContext),\n\t\t\tserviceContext.translate(\"view-changes\"));\n\n\t\treturn \"<span>\" + diffsURL + \"<\/span>\";\n\t}","commit_id":"84512fe67a1d97262e5af22c9d04269a0f94b96f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected String getTitlePattern(String groupName, SocialActivity activity)\n\t\tthrows Exception {\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tint activityType = activity.getType();\n\n\t\tif ((activityType == BlogsActivityKeys.ADD_COMMENT) ||\n\t\t\t(activityType == SocialActivityConstants.TYPE_ADD_COMMENT)) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-add-comment\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-add-comment-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\tif (entry.getStatus() == WorkflowConstants.STATUS_SCHEDULED) {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\treturn \"activity-blogs-scheduled-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn \"activity-blogs-scheduled-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\treturn \"activity-blogs-add-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn \"activity-blogs-add-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (activityType == SocialActivityConstants.TYPE_MOVE_TO_TRASH) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-move-to-trash\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-move-to-trash-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType ==\n\t\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-restore-from-trash\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-restore-from-trash-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.UPDATE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-update-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-update-entry-in\";\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":34867,"modified_method":"@Override\n\tprotected String getTitlePattern(String groupName, SocialActivity activity)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tif ((activityType == BlogsActivityKeys.ADD_COMMENT) ||\n\t\t\t(activityType == SocialActivityConstants.TYPE_ADD_COMMENT)) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-add-comment\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-add-comment-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\t\tactivity.getClassPK());\n\n\t\t\tif (entry.getStatus() == WorkflowConstants.STATUS_SCHEDULED) {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\treturn \"activity-blogs-scheduled-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn \"activity-blogs-scheduled-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\t\treturn \"activity-blogs-add-entry\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn \"activity-blogs-add-entry-in\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (activityType == SocialActivityConstants.TYPE_MOVE_TO_TRASH) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-move-to-trash\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-move-to-trash-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType ==\n\t\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH) {\n\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-restore-from-trash\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-restore-from-trash-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.UPDATE_ENTRY) {\n\t\t\tif (Validator.isNull(groupName)) {\n\t\t\t\treturn \"activity-blogs-update-entry\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"activity-blogs-update-entry-in\";\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString displayTitle = wrapLink(link, entry.getTitle());\n\t\tString displayDate = StringPool.BLANK;\n\n\t\tif ((activity.getType() == BlogsActivityKeys.ADD_ENTRY) &&\n\t\t\t(entry.getStatus() == WorkflowConstants.STATUS_SCHEDULED)) {\n\n\t\t\tdisplayTitle = entry.getTitle();\n\n\t\t\tFormat dateFormatDate =\n\t\t\t\tFastDateFormatFactoryUtil.getSimpleDateFormat(\n\t\t\t\t\t\"MMMM d\", themeDisplay.getLocale(),\n\t\t\t\t\tthemeDisplay.getTimeZone());\n\n\t\t\tdisplayDate = dateFormatDate.format(entry.getDisplayDate());\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, displayTitle,\n\t\t\tdisplayDate\n\t\t};\n\n\t\treturn titleArguments;\n\t}","id":34868,"modified_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString displayTitle = wrapLink(link, entry.getTitle());\n\t\tString displayDate = StringPool.BLANK;\n\n\t\tif ((activity.getType() == BlogsActivityKeys.ADD_ENTRY) &&\n\t\t\t(entry.getStatus() == WorkflowConstants.STATUS_SCHEDULED)) {\n\n\t\t\tdisplayTitle = entry.getTitle();\n\n\t\t\tFormat dateFormatDate =\n\t\t\t\tFastDateFormatFactoryUtil.getSimpleDateFormat(\n\t\t\t\t\t\"MMMM d\", themeDisplay.getLocale(),\n\t\t\t\t\tthemeDisplay.getTimeZone());\n\n\t\t\tdisplayDate = dateFormatDate.format(entry.getDisplayDate());\n\t\t}\n\n\t\treturn new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, displayTitle,\n\t\t\tdisplayDate\n\t\t};\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getLink(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tJournalArticle article =\n\t\t\tJournalArticleLocalServiceUtil.getJournalArticle(\n\t\t\t\tactivity.getClassPK());\n\n\t\tif (TrashUtil.isInTrash(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey())) {\n\n\t\t\treturn TrashUtil.getViewContentURL(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\t\tthemeDisplay);\n\t\t}\n\n\t\tString link = null;\n\n\t\tJournalArticle lastestArticle =\n\t\t\tJournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tarticle.getGroupId(), article.getArticleId());\n\n\t\tif (Validator.isNotNull(lastestArticle.getLayoutUuid()) &&\n\t\t\t!article.isInTrash()) {\n\n\t\t\tString groupFriendlyURL = PortalUtil.getGroupFriendlyURL(\n\t\t\t\tthemeDisplay.getScopeGroup(), false, themeDisplay);\n\n\t\t\tlink =\n\t\t\t\tgroupFriendlyURL.concat(\n\t\t\t\t\tJournalArticleConstants.CANONICAL_URL_SEPARATOR).concat(\n\t\t\t\t\t\tlastestArticle.getUrlTitle());\n\t\t}\n\n\t\treturn link;\n\t}","id":34869,"modified_method":"@Override\n\tprotected String getLink(SocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tJournalArticle article = JournalArticleLocalServiceUtil.getArticle(\n\t\t\tactivity.getClassPK());\n\n\t\tif (TrashUtil.isInTrash(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey())) {\n\n\t\t\treturn TrashUtil.getViewContentURL(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\t\tthemeDisplay);\n\t\t}\n\n\t\tJournalArticle lastestArticle =\n\t\t\tJournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tarticle.getGroupId(), article.getArticleId());\n\n\t\tif (Validator.isNotNull(lastestArticle.getLayoutUuid()) &&\n\t\t\t!article.isInTrash()) {\n\n\t\t\tString groupFriendlyURL = PortalUtil.getGroupFriendlyURL(\n\t\t\t\tthemeDisplay.getScopeGroup(), false, themeDisplay);\n\n\t\t\treturn groupFriendlyURL.concat(\n\t\t\t\tJournalArticleConstants.CANONICAL_URL_SEPARATOR).concat(\n\t\t\t\t\tlastestArticle.getUrlTitle());\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected boolean hasPermissions(\n\t\t\tPermissionChecker permissionChecker, SocialActivity activity,\n\t\t\tString actionId, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tJournalArticle article =\n\t\t\tJournalArticleLocalServiceUtil.getJournalArticle(\n\t\t\t\tactivity.getClassPK());\n\n\t\tint activityType = activity.getType();\n\n\t\tif ((activityType == JournalActivityKeys.ADD_ARTICLE) &&\n\t\t\t!JournalPermission.contains(\n\t\t\t\tpermissionChecker, activity.getGroupId(),\n\t\t\t\tActionKeys.ADD_ARTICLE)) {\n\n\t\t\treturn false;\n\t\t}\n\t\telse if ((activityType == JournalActivityKeys.UPDATE_ARTICLE) &&\n\t\t\t!JournalArticlePermission.contains(\n\t\t\t\tpermissionChecker, article, ActionKeys.UPDATE)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":34870,"modified_method":"@Override\n\tprotected boolean hasPermissions(\n\t\t\tPermissionChecker permissionChecker, SocialActivity activity,\n\t\t\tString actionId, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tif ((activityType == JournalActivityKeys.ADD_ARTICLE) &&\n\t\t\t!JournalPermission.contains(\n\t\t\t\tpermissionChecker, activity.getGroupId(),\n\t\t\t\tActionKeys.ADD_ARTICLE)) {\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (activityType == JournalActivityKeys.UPDATE_ARTICLE) {\n\t\t\tJournalArticle article = JournalArticleLocalServiceUtil.getArticle(\n\t\t\t\tactivity.getClassPK());\n\n\t\t\tif (!JournalArticlePermission.contains(\n\t\t\t\t\tpermissionChecker, article, ActionKeys.UPDATE)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getTitle(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tJournalArticle article =\n\t\t\tJournalArticleLocalServiceUtil.getJournalArticle(\n\t\t\t\tactivity.getClassPK());\n\n\t\treturn article.getTitle(themeDisplay.getLocale());\n\t}","id":34871,"modified_method":"@Override\n\tprotected String getTitle(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tJournalArticle article = JournalArticleLocalServiceUtil.getArticle(\n\t\t\tactivity.getClassPK());\n\n\t\treturn article.getTitle(themeDisplay.getLocale());\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getViewContentURL(\n\t\t\tString className, long classPK, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!themeDisplay.isSignedIn() ||\n\t\t\t!isTrashEnabled(themeDisplay.getScopeGroupId()) ||\n\t\t\t!PortletPermissionUtil.hasControlPanelAccessPermission(\n\t\t\t\tthemeDisplay.getPermissionChecker(),\n\t\t\t\tthemeDisplay.getScopeGroupId(), PortletKeys.TRASH)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tif (trashHandler.isInTrashContainer(classPK)) {\n\t\t\tContainerModel containerModel = trashHandler.getTrashContainer(\n\t\t\t\tclassPK);\n\n\t\t\tclassName = containerModel.getModelClassName();\n\t\t\tclassPK = containerModel.getContainerModelId();\n\n\t\t\ttrashHandler = TrashHandlerRegistryUtil.getTrashHandler(className);\n\t\t}\n\n\t\tTrashRenderer trashRenderer = trashHandler.getTrashRenderer(classPK);\n\n\t\tif (trashRenderer == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tTrashEntry trashEntry = TrashEntryLocalServiceUtil.getEntry(\n\t\t\tclassName, classPK);\n\n\t\tString namespace = PortalUtil.getPortletNamespace(PortletKeys.TRASH);\n\n\t\tMap<String, String[]> params = new HashMap<String, String[]>();\n\n\t\tparams.put(\n\t\t\tnamespace + \"struts_action\", new String[] {\"/trash/view_content\"});\n\t\tparams.put(\n\t\t\tnamespace + \"redirect\", new String[] {themeDisplay.getURLCurrent()});\n\n\t\tif (trashEntry.getRootEntry() != null) {\n\t\t\tparams.put(namespace + \"className\", new String[] {className});\n\t\t\tparams.put(\n\t\t\t\tnamespace + \"classPK\", new String[] {String.valueOf(classPK)});\n\t\t}\n\t\telse {\n\t\t\tparams.put(\n\t\t\t\tnamespace + \"trashEntryId\",\n\t\t\t\tnew String[] {String.valueOf(trashEntry.getEntryId())});\n\t\t}\n\n\t\tparams.put(namespace + \"type\", new String[] {trashRenderer.getType()});\n\t\tparams.put(\n\t\t\tnamespace + \"showActions\", new String[] {Boolean.FALSE.toString()});\n\t\tparams.put(\n\t\t\tnamespace + \"showAssetMetadata\",\n\t\t\tnew String[] {Boolean.TRUE.toString()});\n\t\tparams.put(\n\t\t\tnamespace + \"showEditURL\", new String[] {Boolean.FALSE.toString()});\n\n\t\treturn PortalUtil.getControlPanelFullURL(\n\t\t\tthemeDisplay.getScopeGroupId(), PortletKeys.TRASH, params);\n\t}","id":34872,"modified_method":"public String getViewContentURL(\n\t\t\tString className, long classPK, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!themeDisplay.isSignedIn() ||\n\t\t\t!isTrashEnabled(themeDisplay.getScopeGroupId()) ||\n\t\t\t!PortletPermissionUtil.hasControlPanelAccessPermission(\n\t\t\t\tthemeDisplay.getPermissionChecker(),\n\t\t\t\tthemeDisplay.getScopeGroupId(), PortletKeys.TRASH)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tif (trashHandler.isInTrashContainer(classPK)) {\n\t\t\tContainerModel containerModel = trashHandler.getTrashContainer(\n\t\t\t\tclassPK);\n\n\t\t\tclassName = containerModel.getModelClassName();\n\t\t\tclassPK = containerModel.getContainerModelId();\n\n\t\t\ttrashHandler = TrashHandlerRegistryUtil.getTrashHandler(className);\n\t\t}\n\n\t\tTrashRenderer trashRenderer = trashHandler.getTrashRenderer(classPK);\n\n\t\tif (trashRenderer == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString namespace = PortalUtil.getPortletNamespace(PortletKeys.TRASH);\n\n\t\tMap<String, String[]> params = new HashMap<String, String[]>();\n\n\t\tparams.put(\n\t\t\tnamespace + \"struts_action\", new String[] {\"/trash/view_content\"});\n\t\tparams.put(\n\t\t\tnamespace + \"redirect\", new String[] {themeDisplay.getURLCurrent()});\n\n\t\tTrashEntry trashEntry = TrashEntryLocalServiceUtil.getEntry(\n\t\t\tclassName, classPK);\n\n\t\tif (trashEntry.getRootEntry() != null) {\n\t\t\tparams.put(namespace + \"className\", new String[] {className});\n\t\t\tparams.put(\n\t\t\t\tnamespace + \"classPK\", new String[] {String.valueOf(classPK)});\n\t\t}\n\t\telse {\n\t\t\tparams.put(\n\t\t\t\tnamespace + \"trashEntryId\",\n\t\t\t\tnew String[] {String.valueOf(trashEntry.getEntryId())});\n\t\t}\n\n\t\tparams.put(namespace + \"type\", new String[] {trashRenderer.getType()});\n\t\tparams.put(\n\t\t\tnamespace + \"showActions\", new String[] {Boolean.FALSE.toString()});\n\t\tparams.put(\n\t\t\tnamespace + \"showAssetMetadata\",\n\t\t\tnew String[] {Boolean.TRUE.toString()});\n\t\tparams.put(\n\t\t\tnamespace + \"showEditURL\", new String[] {Boolean.FALSE.toString()});\n\n\t\treturn PortalUtil.getControlPanelFullURL(\n\t\t\tthemeDisplay.getScopeGroupId(), PortletKeys.TRASH, params);\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\tactivity.getClassPK());\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\ttitle = HtmlUtil.escape(title);\n\n\t\tif (Validator.isNotNull(link)) {\n\t\t\ttitle = wrapLink(link, title);\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, title,\n\t\t\tgetAttachmentTitle(activity, pageResource, themeDisplay)\n\t\t};\n\n\t\treturn titleArguments;\n\t}","id":34873,"modified_method":"@Override\n\tprotected Object[] getTitleArguments(\n\t\t\tString groupName, SocialActivity activity, String link,\n\t\t\tString title, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\tactivity.getClassPK());\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\ttitle = HtmlUtil.escape(title);\n\n\t\tif (Validator.isNotNull(link)) {\n\t\t\ttitle = wrapLink(link, title);\n\t\t}\n\n\t\treturn new Object[] {\n\t\t\tgroupName, creatorUserName, title,\n\t\t\tgetAttachmentTitle(activity, pageResource, themeDisplay)\n\t\t};\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected boolean hasPermissions(\n\t\t\tPermissionChecker permissionChecker, SocialActivity activity,\n\t\t\tString actionId, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tif (!WikiPagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\tactivity.getClassPK());\n\n\t\tint activityType = activity.getType();\n\n\t\tif (activityType == WikiActivityKeys.UPDATE_PAGE) {\n\t\t\tdouble version = GetterUtil.getDouble(\n\t\t\t\tactivity.getExtraDataValue(\"version\"));\n\n\t\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t\tpageResource.getNodeId(), pageResource.getTitle(), version);\n\n\t\t\tif (!page.isApproved() &&\n\t\t\t\t!WikiPagePermission.contains(\n\t\t\t\t\tpermissionChecker, activity.getClassPK(),\n\t\t\t\t\tActionKeys.UPDATE)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","id":34874,"modified_method":"@Override\n\tprotected boolean hasPermissions(\n\t\t\tPermissionChecker permissionChecker, SocialActivity activity,\n\t\t\tString actionId, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tif (!WikiPagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tint activityType = activity.getType();\n\n\t\tif (activityType == WikiActivityKeys.UPDATE_PAGE) {\n\t\t\tWikiPageResource pageResource =\n\t\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\t\tactivity.getClassPK());\n\n\t\t\tdouble version = GetterUtil.getDouble(\n\t\t\t\tactivity.getExtraDataValue(\"version\"));\n\n\t\t\tWikiPage page = WikiPageLocalServiceUtil.getPage(\n\t\t\t\tpageResource.getNodeId(), pageResource.getTitle(), version);\n\n\t\t\tif (!page.isApproved() &&\n\t\t\t\t!WikiPagePermission.contains(\n\t\t\t\t\tpermissionChecker, activity.getClassPK(),\n\t\t\t\t\tActionKeys.UPDATE)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getAttachmentTitle(\n\t\t\tSocialActivity activity, WikiPageResource pageResource,\n\t\t\tThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tString attachmentTitle = StringPool.BLANK;\n\n\t\tint activityType = activity.getType();\n\n\t\tif ((activityType == SocialActivityConstants.TYPE_ADD_ATTACHMENT) ||\n\t\t\t(activityType ==\n\t\t\t\tSocialActivityConstants.TYPE_MOVE_ATTACHMENT_TO_TRASH) ||\n\t\t\t(activityType ==\n\t\t\t\tSocialActivityConstants.TYPE_RESTORE_ATTACHMENT_FROM_TRASH)) {\n\n\t\t\tFileEntry fileEntry = null;\n\n\t\t\ttry {\n\t\t\t\tlong fileEntryId = GetterUtil.getLong(\n\t\t\t\t\tactivity.getExtraDataValue(\"fileEntryId\"));\n\n\t\t\t\tfileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\tfileEntryId);\n\t\t\t}\n\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t}\n\n\t\t\tFileVersion fileVersion = null;\n\n\t\t\tif (fileEntry != null) {\n\t\t\t\tfileVersion = fileEntry.getFileVersion();\n\t\t\t}\n\n\t\t\tString fileEntryTitle = activity.getExtraDataValue(\"title\");\n\n\t\t\tif ((fileVersion != null) && !fileVersion.isInTrash()) {\n\t\t\t\tStringBundler sb = new StringBundler(9);\n\n\t\t\t\tsb.append(themeDisplay.getPathMain());\n\t\t\t\tsb.append(\"/wiki/get_page_attachment?p_l_id=\");\n\t\t\t\tsb.append(themeDisplay.getPlid());\n\t\t\t\tsb.append(\"&nodeId=\");\n\t\t\t\tsb.append(pageResource.getNodeId());\n\t\t\t\tsb.append(\"&title=\");\n\t\t\t\tsb.append(HttpUtil.encodeURL(pageResource.getTitle()));\n\t\t\t\tsb.append(\"&fileName=\");\n\t\t\t\tsb.append(fileEntryTitle);\n\n\t\t\t\tattachmentTitle = wrapLink(\n\t\t\t\t\tsb.toString(), HtmlUtil.escape(fileEntryTitle));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattachmentTitle = HtmlUtil.escape(fileEntryTitle);\n\t\t\t}\n\t\t}\n\n\t\treturn attachmentTitle;\n\t}","id":34875,"modified_method":"protected String getAttachmentTitle(\n\t\t\tSocialActivity activity, WikiPageResource pageResource,\n\t\t\tThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tint activityType = activity.getType();\n\n\t\tif ((activityType == SocialActivityConstants.TYPE_ADD_ATTACHMENT) ||\n\t\t\t(activityType ==\n\t\t\t\tSocialActivityConstants.TYPE_MOVE_ATTACHMENT_TO_TRASH) ||\n\t\t\t(activityType ==\n\t\t\t\tSocialActivityConstants.TYPE_RESTORE_ATTACHMENT_FROM_TRASH)) {\n\n\t\t\tFileEntry fileEntry = null;\n\n\t\t\ttry {\n\t\t\t\tlong fileEntryId = GetterUtil.getLong(\n\t\t\t\t\tactivity.getExtraDataValue(\"fileEntryId\"));\n\n\t\t\t\tfileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\tfileEntryId);\n\t\t\t}\n\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t}\n\n\t\t\tFileVersion fileVersion = null;\n\n\t\t\tif (fileEntry != null) {\n\t\t\t\tfileVersion = fileEntry.getFileVersion();\n\t\t\t}\n\n\t\t\tString fileEntryTitle = activity.getExtraDataValue(\"title\");\n\n\t\t\tif ((fileVersion != null) && !fileVersion.isInTrash()) {\n\t\t\t\tStringBundler sb = new StringBundler(9);\n\n\t\t\t\tsb.append(themeDisplay.getPathMain());\n\t\t\t\tsb.append(\"/wiki/get_page_attachment?p_l_id=\");\n\t\t\t\tsb.append(themeDisplay.getPlid());\n\t\t\t\tsb.append(\"&nodeId=\");\n\t\t\t\tsb.append(pageResource.getNodeId());\n\t\t\t\tsb.append(\"&title=\");\n\t\t\t\tsb.append(HttpUtil.encodeURL(pageResource.getTitle()));\n\t\t\t\tsb.append(\"&fileName=\");\n\t\t\t\tsb.append(fileEntryTitle);\n\n\t\t\t\treturn wrapLink(sb.toString(), HtmlUtil.escape(fileEntryTitle));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn HtmlUtil.escape(fileEntryTitle);\n\t\t\t}\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","commit_id":"a6085b69190d49a193b15e69f9825b7375184618","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void showDialogToDownloadMaps(Collection<String> maps) {\n\t\tint count = 0;\n\t\tint sz = 0;\n\t\tString s = \"\";\n\t\tfor (IndexItem i : downloadListIndexThread.getCachedIndexFiles()) {\n\t\t\tfor (String map : maps) {\n\t\t\t\tif (i.getFileName().equals(map + \".obf.zip\") && i.getType() == DownloadActivityType.NORMAL_FILE) {\n\t\t\t\t\tfinal List<DownloadEntry> de = i.createDownloadEntry(getMyApplication(), i.getType(), new ArrayList<DownloadEntry>(1));\n\t\t\t\t\tfor(DownloadEntry d : de ) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tsz += d.sizeMB;\n\t\t\t\t\t}\n\t\t\t\t\tif(s.length() > 0) {\n\t\t\t\t\t\ts +=\", \";\n\t\t\t\t\t}\n\t\t\t\t\ts += i.getVisibleName(getMyApplication(), getMyApplication().getResourceManager().getOsmandRegions());\n\t\t\t\t\tgetEntriesToDownload().put(i, de);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count > 0){\n\t\t\tBuilder builder = new AlertDialog.Builder(this);\n\t\t\tbuilder.setMessage(getString(R.string.download_additional_maps, s, sz));\n\t\t\tbuilder.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tdownloadFilesCheckInternet();\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuilder.setNegativeButton(R.string.default_buttons_no, null);\n\t\t\tbuilder.show();\n\t\t\t\n\t\t}\n\t}","id":34876,"modified_method":"public void showDialogToDownloadMaps(Collection<String> maps) {\n\t\tint count = 0;\n\t\tint sz = 0;\n\t\tString s = \"\";\n\t\tfor (IndexItem i : downloadListIndexThread.getCachedIndexFiles()) {\n\t\t\tfor (String map : maps) {\n\t\t\t\tif (i.getFileName().equals(map + \".obf.zip\") && i.getType() == DownloadActivityType.NORMAL_FILE) {\n\t\t\t\t\tfinal List<DownloadEntry> de = i.createDownloadEntry(getMyApplication(), i.getType(), new ArrayList<DownloadEntry>(1));\n\t\t\t\t\tfor(DownloadEntry d : de ) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tsz += d.sizeMB;\n\t\t\t\t\t}\n\t\t\t\t\tif(s.length() > 0) {\n\t\t\t\t\t\ts +=\", \";\n\t\t\t\t\t}\n\t\t\t\t\ts += i.getVisibleName(getMyApplication(), getMyApplication().getResourceManager().getOsmandRegions());\n\t\t\t\t\tgetEntriesToDownload().put(i, de);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count > 0){\n\t\t\tBuilder builder = new AlertDialog.Builder(this);\n\t\t\tbuilder.setMessage(getString(R.string.download_additional_maps, s, sz));\n\t\t\tbuilder.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tdownloadFilesCheckInternet();\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuilder.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tgetEntriesToDownload().clear();\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuilder.setOnCancelListener(new DialogInterface.OnCancelListener() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onCancel(DialogInterface dialog) {\n\t\t\t\t\tgetEntriesToDownload().clear();\t\t\t\t\t\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuilder.show();\n\t\t\t\n\t\t}\n\t}","commit_id":"a69872e08e2ecaf12d3b670d1eb06b13d57288fa","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static List<IndexItemCategory> categorizeIndexItems(final OsmandApplication ctx, \n\t\t\tCollection<IndexItem> indexItems) {\n\t\tboolean skipWiki = Version.isFreeVersion(ctx);\n\t\tfinal Map<String, IndexItemCategory> cats = new TreeMap<String, IndexItemCategory>();\n\t\tfor (IndexItem i : indexItems) {\n\t\t\tint nameId = R.string.index_name_other;\n\t\t\tint order = 0;\n\t\t\tString lc = i.getFileName().toLowerCase();\n\t\t\tif (lc.endsWith(\".voice.zip\")) {\n\t\t\t\tnameId = R.string.index_name_voice;\n\t\t\t\torder = 1;\n\t\t\t} else if (lc.contains(\".ttsvoice.zip\")) {\n\t\t\t\tnameId = R.string.index_name_tts_voice;\n\t\t\t\torder = 2;\n\t\t\t} else if (lc.contains(\"_wiki_\")) {\n\t\t\t\tif(skipWiki) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnameId = R.string.index_name_wiki;\n\t\t\t\torder = 10;\n\t\t\t} else if (lc.startsWith(\"us\") || \n\t\t\t\t\t(lc.contains(\"united states\") && lc.startsWith(\"north-america\")) ) {\n\t\t\t\tnameId = R.string.index_name_us;\n\t\t\t\torder = 31;\n\t\t\t} else if (lc.startsWith(\"canada\")) {\n\t\t\t\tnameId = R.string.index_name_canada;\n\t\t\t\torder = 32;\n\t\t\t} else if (lc.contains(\"openmaps\")) {\n\t\t\t\tnameId = R.string.index_name_openmaps;\n\t\t\t\torder = 90;\n\t\t\t} else if (lc.contains(\"northamerica\") || lc.contains(\"north-america\")) {\n\t\t\t\tnameId = R.string.index_name_north_america;\n\t\t\t\torder = 30;\n\t\t\t} else if (lc.contains(\"centralamerica\") || lc.contains(\"central-america\")\n\t\t\t\t\t|| lc.contains(\"caribbean\")) {\n\t\t\t\tnameId = R.string.index_name_central_america;\n\t\t\t\torder = 40;\n\t\t\t} else if (lc.contains(\"southamerica\") || lc.contains(\"south-america\")) {\n\t\t\t\tnameId = R.string.index_name_south_america;\n\t\t\t\torder = 45;\n\t\t\t} else if ( lc.contains(\"germany\")) {\n\t\t\t\tnameId = R.string.index_name_germany;\n\t\t\t\torder = 16;\n\t\t\t} else if (lc.startsWith(\"france_\")) {\n\t\t\t\tnameId = R.string.index_name_france;\n\t\t\t\torder = 17;\n\t\t\t} else if (lc.startsWith(\"italy_\")) {\n\t\t\t\tnameId = R.string.index_name_italy;\n\t\t\t\torder = 18;\n\t\t\t} else if (lc.startsWith(\"gb_\") || lc.startsWith(\"british\")) {\n\t\t\t\tnameId = R.string.index_name_gb;\n\t\t\t\torder = 19;\n\t\t\t} else if (lc.contains(\"russia\")) {\n\t\t\t\tnameId = R.string.index_name_russia;\n\t\t\t\torder = 25;\n\t\t\t} else if (lc.contains(\"europe\")) {\n\t\t\t\tnameId = R.string.index_name_europe;\n\t\t\t\torder = 15;\n\t\t\t} else if (lc.contains(\"africa\") && !lc.contains(\"_wiki_\")) {\n\t\t\t\tnameId = R.string.index_name_africa;\n\t\t\t\torder = 80;\n\t\t\t} else if (lc.contains(\"_asia\")|| lc.startsWith(\"asia\")) {\n\t\t\t\tnameId = R.string.index_name_asia;\n\t\t\t\torder = 50;\n\t\t\t} else if (lc.contains(\"oceania\") || lc.contains(\"australia\")) {\n\t\t\t\tnameId = R.string.index_name_oceania;\n\t\t\t\torder = 70;\n\t\t\t}\n\n\t\t\tString name = ctx.getString(nameId);\n\t\t\tif (!cats.containsKey(name)) {\n\t\t\t\tcats.put(name, new IndexItemCategory(name, order));\n\t\t\t}\n\t\t\tcats.get(name).items.add(i);\n\t\t}\n\t\tArrayList<IndexItemCategory> r = new ArrayList<IndexItemCategory>(cats.values());\n\t\tfinal Collator collator = OsmAndCollator.primaryCollator();\n\t\tfor(IndexItemCategory ct : r) {\n\t\t\tfinal OsmandRegions osmandRegions = ctx.getResourceManager().getOsmandRegions();\n\t\t\tCollections.sort(ct.items, new Comparator<IndexItem>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(IndexItem lhs, IndexItem rhs) {\n\t\t\t\t\treturn collator.compare(lhs.getVisibleName(ctx, osmandRegions),\n\t\t\t\t\t\t\trhs.getVisibleName(ctx, osmandRegions));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tCollections.sort(r);\n\t\treturn r;\n\t}","id":34877,"modified_method":"public static List<IndexItemCategory> categorizeIndexItems(final OsmandApplication ctx, \n\t\t\tCollection<IndexItem> indexItems) {\n\t\tboolean skipWiki = Version.isFreeVersion(ctx);\n\t\tfinal Map<String, IndexItemCategory> cats = new TreeMap<String, IndexItemCategory>();\n\t\tfor (IndexItem i : indexItems) {\n\t\t\tint nameId = R.string.index_name_other;\n\t\t\tint order = 0;\n\t\t\tString lc = i.getFileName().toLowerCase();\n\t\t\tif (lc.endsWith(\".voice.zip\")) {\n\t\t\t\tnameId = R.string.index_name_voice;\n\t\t\t\torder = 1;\n\t\t\t} else if (lc.contains(\".ttsvoice.zip\")) {\n\t\t\t\tnameId = R.string.index_name_tts_voice;\n\t\t\t\torder = 2;\n\t\t\t} else if (lc.contains(\"_wiki_\")) {\n\t\t\t\tif(skipWiki) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnameId = R.string.index_name_wiki;\n\t\t\t\torder = 10;\n\t\t\t} else if (lc.startsWith(\"us\") || \n\t\t\t\t\t(lc.contains(\"united states\") && lc.startsWith(\"north-america\")) ) {\n\t\t\t\tnameId = R.string.index_name_us;\n\t\t\t\torder = 31;\n\t\t\t} else if (lc.startsWith(\"canada\")) {\n\t\t\t\tnameId = R.string.index_name_canada;\n\t\t\t\torder = 32;\n\t\t\t} else if (lc.contains(\"openmaps\")) {\n\t\t\t\tnameId = R.string.index_name_openmaps;\n\t\t\t\torder = 90;\n\t\t\t} else if (lc.contains(\"northamerica\") || lc.contains(\"north-america\")) {\n\t\t\t\tnameId = R.string.index_name_north_america;\n\t\t\t\torder = 30;\n\t\t\t} else if (lc.contains(\"centralamerica\") || lc.contains(\"central-america\")\n\t\t\t\t\t|| lc.contains(\"caribbean\")) {\n\t\t\t\tnameId = R.string.index_name_central_america;\n\t\t\t\torder = 40;\n\t\t\t} else if (lc.contains(\"southamerica\") || lc.contains(\"south-america\")) {\n\t\t\t\tnameId = R.string.index_name_south_america;\n\t\t\t\torder = 45;\n\t\t\t} else if ( lc.contains(\"germany\")) {\n\t\t\t\tnameId = R.string.index_name_germany;\n\t\t\t\torder = 16;\n\t\t\t} else if (lc.startsWith(\"france_\")) {\n\t\t\t\tnameId = R.string.index_name_france;\n\t\t\t\torder = 17;\n\t\t\t} else if (lc.startsWith(\"italy_\")) {\n\t\t\t\tnameId = R.string.index_name_italy;\n\t\t\t\torder = 18;\n\t\t\t} else if (lc.startsWith(\"gb_\") || lc.startsWith(\"british\")) {\n\t\t\t\tnameId = R.string.index_name_gb;\n\t\t\t\torder = 19;\n\t\t\t} else if (lc.contains(\"russia\")) {\n\t\t\t\tnameId = R.string.index_name_russia;\n\t\t\t\torder = 25;\n\t\t\t} else if (lc.contains(\"europe\")) {\n\t\t\t\tnameId = R.string.index_name_europe;\n\t\t\t\torder = 15;\n\t\t\t} else if (lc.contains(\"africa\") && !lc.contains(\"_wiki_\")) {\n\t\t\t\tnameId = R.string.index_name_africa;\n\t\t\t\torder = 80;\n\t\t\t} else if (lc.contains(\"_asia\")|| lc.startsWith(\"asia\")) {\n\t\t\t\tnameId = R.string.index_name_asia;\n\t\t\t\torder = 50;\n\t\t\t} else if (lc.contains(\"oceania\") || lc.contains(\"australia\")) {\n\t\t\t\tnameId = R.string.index_name_oceania;\n\t\t\t\torder = 70;\n\t\t\t} else if (lc.contains(\"tour\")) {\n\t\t\t\tnameId = R.string.index_tours;\n\t\t\t}\n\n\t\t\tString name = ctx.getString(nameId);\n\t\t\tif (!cats.containsKey(name)) {\n\t\t\t\tcats.put(name, new IndexItemCategory(name, order));\n\t\t\t}\n\t\t\tcats.get(name).items.add(i);\n\t\t}\n\t\tArrayList<IndexItemCategory> r = new ArrayList<IndexItemCategory>(cats.values());\n\t\tfinal Collator collator = OsmAndCollator.primaryCollator();\n\t\tfor(IndexItemCategory ct : r) {\n\t\t\tfinal OsmandRegions osmandRegions = ctx.getResourceManager().getOsmandRegions();\n\t\t\tCollections.sort(ct.items, new Comparator<IndexItem>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(IndexItem lhs, IndexItem rhs) {\n\t\t\t\t\treturn collator.compare(lhs.getVisibleName(ctx, osmandRegions),\n\t\t\t\t\t\t\trhs.getVisibleName(ctx, osmandRegions));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tCollections.sort(r);\n\t\treturn r;\n\t}","commit_id":"a69872e08e2ecaf12d3b670d1eb06b13d57288fa","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public DeleteKeyPairResponseType delete( DeleteKeyPairType request ) throws EucalyptusCloudException {\n    DeleteKeyPairResponseType reply = ( DeleteKeyPairResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    try {\n      SshKeyPair key = KeyPairUtil.deleteUserKeyPair( ctx.getUserFullName( ), request.getKeyName( ) );\n      if ( ! RestrictedTypes.filterPrivileged( ).apply( key ) ) {\n        throw new EucalyptusCloudException( \"Permission denied while trying to delete keypair \" + key.getName( ) + \" by \" + ctx.getUser( ) );\n      }\n      reply.set_return( true );\n    } catch ( Exception e1 ) {\n      LOG.error( e1 );\n      reply.set_return( false );\n    }\n    return reply;\n  }","id":34878,"modified_method":"public DeleteKeyPairResponseType delete( DeleteKeyPairType request ) throws EucalyptusCloudException {\n    DeleteKeyPairResponseType reply = ( DeleteKeyPairResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    try {\n      SshKeyPair key = KeyPairs.lookup( ctx.getUserFullName( ).asAccountFullName( ), request.getKeyName( ) );\n      if ( ! RestrictedTypes.filterPrivileged( ).apply( key ) ) {\n        throw new EucalyptusCloudException( \"Permission denied while trying to delete keypair \" + key.getName( ) + \" by \" + ctx.getUser( ) );\n      }\n      KeyPairs.delete( ctx.getUserFullName( ).asAccountFullName( ), request.getKeyName( ) );\n      reply.set_return( true );\n    } catch ( Exception e1 ) {\n      LOG.error( e1 );\n      reply.set_return( false );\n    }\n    return reply;\n  }","commit_id":"3a1fe9c0d0d9fba980fa657f0451e2c3d5635bfc","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static NetworkGroup create( final OwnerFullName ownerFullName, final String groupName, final String groupDescription ) throws MetadataException {\n    final EntityTransaction db = Entities.get( NetworkGroup.class );\n    try {\n      NetworkGroup net = Entities.uniqueResult( new NetworkGroup( AccountFullName.getInstance( ownerFullName.getAccountNumber( ) ), NETWORK_DEFAULT_NAME ) );\n      if ( net == null ) {\n        final NetworkGroup entity = Entities.persist( new NetworkGroup( ownerFullName, groupName, groupDescription ) );\n        db.commit( );\n        return entity;\n      } else {\n        db.rollback( );\n        throw new DuplicateMetadataException( \"Failed to create group: \" + groupName + \" for \" + ownerFullName.toString( ) );\n      }\n    } catch ( final NoSuchElementException ex ) {\n      final NetworkGroup entity = Entities.persist( new NetworkGroup( ownerFullName, groupName, groupDescription ) );\n      db.commit( );\n      return entity;\n    } catch ( final ConstraintViolationException ex ) {\n      Logs.exhaust( ).error( ex );\n      db.rollback( );\n      throw new DuplicateMetadataException( \"Failed to create group: \" + groupName + \" for \" + ownerFullName.toString( ), ex );\n    } catch ( final Exception ex ) {\n      Logs.exhaust( ).error( ex, ex );\n      db.rollback( );\n      throw new MetadataException( \"Failed to create group: \" + groupName + \" for \" + ownerFullName.toString( ), PersistenceExceptions.transform( ex ) );\n    }\n  }","id":34879,"modified_method":"public static NetworkGroup create( final OwnerFullName ownerFullName, final String groupName, final String groupDescription ) throws MetadataException {\n    final EntityTransaction db = Entities.get( NetworkGroup.class );\n    try {\n      NetworkGroup net = Entities.uniqueResult( new NetworkGroup( AccountFullName.getInstance( ownerFullName.getAccountNumber( ) ), groupName ) );\n      if ( net == null ) {\n        final NetworkGroup entity = Entities.persist( new NetworkGroup( ownerFullName, groupName, groupDescription ) );\n        db.commit( );\n        return entity;\n      } else {\n        db.rollback( );\n        throw new DuplicateMetadataException( \"Failed to create group: \" + groupName + \" for \" + ownerFullName.toString( ) );\n      }\n    } catch ( final NoSuchElementException ex ) {\n      final NetworkGroup entity = Entities.persist( new NetworkGroup( ownerFullName, groupName, groupDescription ) );\n      db.commit( );\n      return entity;\n    } catch ( final ConstraintViolationException ex ) {\n      Logs.exhaust( ).error( ex );\n      db.rollback( );\n      throw new DuplicateMetadataException( \"Failed to create group: \" + groupName + \" for \" + ownerFullName.toString( ), ex );\n    } catch ( final Exception ex ) {\n      Logs.exhaust( ).error( ex, ex );\n      db.rollback( );\n      throw new MetadataException( \"Failed to create group: \" + groupName + \" for \" + ownerFullName.toString( ), PersistenceExceptions.transform( ex ) );\n    }\n  }","commit_id":"3a1fe9c0d0d9fba980fa657f0451e2c3d5635bfc","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteSnapshotResponseType delete( final DeleteSnapshotType request ) throws EucalyptusCloudException {\n    final DeleteSnapshotResponseType reply = ( DeleteSnapshotResponseType ) request.getReply( );\n    final Context ctx = Contexts.lookup( );\n    boolean result = false;\n    try {\n      result = Transactions.delete( Snapshot.named( ctx.getUserFullName( ), request.getSnapshotId( ) ), new Predicate<Snapshot>( ) {\n        \n        @Override\n        public boolean apply( Snapshot snap ) {\n          if ( !State.EXTANT.equals( snap.getState( ) ) ) {\n            return false;\n          } else if ( !RestrictedTypes.filterPrivileged( ).apply( snap ) ) {\n            throw Exceptions.toUndeclared( \"Not authorized to delete snapshot \" + request.getSnapshotId( ) + \" by \" + ctx.getUser( ).getName( ),\n                                           new EucalyptusCloudException( ) );\n          } else {\n            ServiceConfiguration sc = Partitions.lookupService( Storage.class, snap.getVolumePartition( ) );\n            try {\n              DeleteStorageSnapshotResponseType scReply = ServiceDispatcher.lookup( sc ).send( new DeleteStorageSnapshotType( snap.getDisplayName( ) ) );\n              if ( scReply.get_return( ) ) {\n                final DeleteStorageSnapshotType deleteMsg = new DeleteStorageSnapshotType( snap.getDisplayName( ) );\n                Iterables.any( Topology.enabledServices( Storage.class ), new Predicate<ServiceConfiguration>() {\n\n                  @Override\n                  public boolean apply( ServiceConfiguration arg0 ) {\n                    ServiceDispatcher.lookup( arg0 ).dispatch( deleteMsg );\n                    return true;\n                  }} );\n                try {\n                  ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsSnapshot, false, snap.getVolumeSize( ),\n                                                                               snap.getOwnerUserId( ), snap.getOwnerUserName( ),\n                                                                               snap.getOwnerAccountNumber( ), snap.getOwnerAccountName( ),\n                                                                               snap.getVolumeCluster( ), snap.getVolumePartition( ) ) );\n                } catch ( EventFailedException ex ) {\n                  LOG.error( ex, ex );\n                }\n              } else {\n                throw Exceptions.toUndeclared( \"Unable to delete snapshot: \" + snap, new EucalyptusCloudException( ) );\n              }\n            } catch ( EucalyptusCloudException ex1 ) {\n              throw Exceptions.toUndeclared( ex1.getMessage( ), ex1 );\n            }\n            return true;\n          }\n        }\n      } );\n    } catch ( ExecutionException ex1 ) {\n      throw new EucalyptusCloudException( ex1.getCause( ) );\n    }\n    reply.set_return( result );\n    return reply;\n  }","id":34880,"modified_method":"public DeleteSnapshotResponseType delete( final DeleteSnapshotType request ) throws EucalyptusCloudException {\n    final DeleteSnapshotResponseType reply = ( DeleteSnapshotResponseType ) request.getReply( );\n    final Context ctx = Contexts.lookup( );\n    boolean result = false;\n    try {\n      result = Transactions.delete( Snapshot.named( ctx.getUserFullName( ).asAccountFullName( ), request.getSnapshotId( ) ), new Predicate<Snapshot>( ) {\n        \n        @Override\n        public boolean apply( Snapshot snap ) {\n          if ( !State.EXTANT.equals( snap.getState( ) ) ) {\n            return false;\n          } else if ( !RestrictedTypes.filterPrivileged( ).apply( snap ) ) {\n            throw Exceptions.toUndeclared( \"Not authorized to delete snapshot \" + request.getSnapshotId( ) + \" by \" + ctx.getUser( ).getName( ),\n                                           new EucalyptusCloudException( ) );\n          } else {\n            ServiceConfiguration sc = Partitions.lookupService( Storage.class, snap.getVolumePartition( ) );\n            try {\n              DeleteStorageSnapshotResponseType scReply = ServiceDispatcher.lookup( sc ).send( new DeleteStorageSnapshotType( snap.getDisplayName( ) ) );\n              if ( scReply.get_return( ) ) {\n                final DeleteStorageSnapshotType deleteMsg = new DeleteStorageSnapshotType( snap.getDisplayName( ) );\n                Iterables.any( Topology.enabledServices( Storage.class ), new Predicate<ServiceConfiguration>() {\n\n                  @Override\n                  public boolean apply( ServiceConfiguration arg0 ) {\n                    ServiceDispatcher.lookup( arg0 ).dispatch( deleteMsg );\n                    return true;\n                  }} );\n                try {\n                  ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsSnapshot, false, snap.getVolumeSize( ),\n                                                                               snap.getOwnerUserId( ), snap.getOwnerUserName( ),\n                                                                               snap.getOwnerAccountNumber( ), snap.getOwnerAccountName( ),\n                                                                               snap.getVolumeCluster( ), snap.getVolumePartition( ) ) );\n                } catch ( EventFailedException ex ) {\n                  LOG.error( ex, ex );\n                }\n              } else {\n                throw Exceptions.toUndeclared( \"Unable to delete snapshot: \" + snap, new EucalyptusCloudException( ) );\n              }\n            } catch ( EucalyptusCloudException ex1 ) {\n              throw Exceptions.toUndeclared( ex1.getMessage( ), ex1 );\n            }\n            return true;\n          }\n        }\n      } );\n    } catch ( ExecutionException ex1 ) {\n      throw new EucalyptusCloudException( ex1.getCause( ) );\n    }\n    reply.set_return( result );\n    return reply;\n  }","commit_id":"aef1bcbbd1973ed2a2718c1c858361a42fd56423","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DetachVolumeResponseType detach( DetachVolumeType request ) throws EucalyptusCloudException {\n    DetachVolumeResponseType reply = ( DetachVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    \n    Volume vol = null;\n    EntityWrapper<Volume> db = EntityWrapper.get( Volume.class );\n    try {\n      vol = db.getUnique( Volume.named( ctx.getUserFullName( ), request.getVolumeId( ) ) );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId( ) );\n    }\n    db.commit( );\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vol ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume \" + request.getVolumeId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    \n    VmInstance vm = null;\n    AttachedVolume volume = null;\n    for ( VmInstance iter : VmInstances.list( Predicates.not( VmState.TERMINATED ) ) ) {\n      try {\n        volume = iter.lookupVolumeAttachment( request.getVolumeId( ) );\n        vm = iter;\n      } catch ( NoSuchElementException ex ) {\n        /** no such attachment **/\n      }\n    }\n    if ( volume == null ) {\n      throw new EucalyptusCloudException( \"Volume is not attached: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vm ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume from instance \" + request.getInstanceId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    if ( !vm.getInstanceId( ).equals( request.getInstanceId( ) ) && request.getInstanceId( ) != null && !request.getInstanceId( ).equals( \"\" ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to instance: \" + request.getInstanceId( ) );\n    }\n    if ( request.getDevice( ) != null && !request.getDevice( ).equals( \"\" ) && !volume.getDevice( ).equals( request.getDevice( ) ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to device: \" + request.getDevice( ) );\n    }\n    \n    Cluster cluster = null;\n    try {\n      cluster = Clusters.getInstance( ).lookup( vm.lookupPartition( ) );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + Topology.lookup( ClusterController.class, vm.lookupPartition( ) ) );\n    }\n    ServiceConfiguration scVm;\n    try {\n      scVm = Partitions.lookupService( Storage.class, cluster.getConfiguration( ).getPartition( ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      throw new EucalyptusCloudException( \"Failed to lookup SC for cluster: \" + cluster, ex );\n    }\n    try {\n      ServiceDispatcher.lookup( scVm ).send( new DetachStorageVolumeType( cluster.getNode( vm.getServiceTag( ) ).getIqn( ), volume.getVolumeId( ) ) );\n    } catch ( Exception e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( e.getMessage( ) );\n    }\n    request.setVolumeId( volume.getVolumeId( ) );\n    request.setRemoteDevice( volume.getRemoteDevice( ) );\n    request.setDevice( volume.getDevice( ).replaceAll( \"unknown,requested:\", \"\" ) );\n    request.setInstanceId( vm.getInstanceId( ) );\n    AsyncRequests.newRequest( new VolumeDetachCallback( request ) ).dispatch( cluster.getConfiguration( ) );\n    EventRecord.here( VolumeManager.class, EventClass.VOLUME, EventType.VOLUME_DETACH )\n               .withDetails( vm.getOwner( ).toString( ), volume.getVolumeId( ), \"instance\", vm.getInstanceId( ) ).withDetails( \"cluster\",\n                                                                                                                               Topology.lookup( ClusterController.class, vm.lookupPartition( ) ).toString( ) ).info( );\n    volume.setStatus( \"detaching\" );\n    reply.setDetachedVolume( volume );\n    return reply;\n  }","id":34881,"modified_method":"public DetachVolumeResponseType detach( DetachVolumeType request ) throws EucalyptusCloudException {\n    DetachVolumeResponseType reply = ( DetachVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    \n    Volume vol = null;\n    EntityWrapper<Volume> db = EntityWrapper.get( Volume.class );\n    try {\n      vol = db.getUnique( Volume.named( ctx.getUserFullName( ).asAccountFullName( ), request.getVolumeId( ) ) );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId( ) );\n    }\n    db.commit( );\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vol ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume \" + request.getVolumeId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    \n    VmInstance vm = null;\n    AttachedVolume volume = null;\n    for ( VmInstance iter : VmInstances.list( Predicates.not( VmState.TERMINATED ) ) ) {\n      try {\n        volume = iter.lookupVolumeAttachment( request.getVolumeId( ) );\n        vm = iter;\n      } catch ( NoSuchElementException ex ) {\n        /** no such attachment **/\n      }\n    }\n    if ( volume == null ) {\n      throw new EucalyptusCloudException( \"Volume is not attached: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vm ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume from instance \" + request.getInstanceId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    if ( !vm.getInstanceId( ).equals( request.getInstanceId( ) ) && request.getInstanceId( ) != null && !request.getInstanceId( ).equals( \"\" ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to instance: \" + request.getInstanceId( ) );\n    }\n    if ( request.getDevice( ) != null && !request.getDevice( ).equals( \"\" ) && !volume.getDevice( ).equals( request.getDevice( ) ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to device: \" + request.getDevice( ) );\n    }\n    \n    Cluster cluster = null;\n    try {\n      cluster = Clusters.getInstance( ).lookup( vm.lookupPartition( ) );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + Topology.lookup( ClusterController.class, vm.lookupPartition( ) ) );\n    }\n    ServiceConfiguration scVm;\n    try {\n      scVm = Partitions.lookupService( Storage.class, cluster.getConfiguration( ).getPartition( ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      throw new EucalyptusCloudException( \"Failed to lookup SC for cluster: \" + cluster, ex );\n    }\n    try {\n      ServiceDispatcher.lookup( scVm ).send( new DetachStorageVolumeType( cluster.getNode( vm.getServiceTag( ) ).getIqn( ), volume.getVolumeId( ) ) );\n    } catch ( Exception e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( e.getMessage( ) );\n    }\n    request.setVolumeId( volume.getVolumeId( ) );\n    request.setRemoteDevice( volume.getRemoteDevice( ) );\n    request.setDevice( volume.getDevice( ).replaceAll( \"unknown,requested:\", \"\" ) );\n    request.setInstanceId( vm.getInstanceId( ) );\n    AsyncRequests.newRequest( new VolumeDetachCallback( request ) ).dispatch( cluster.getConfiguration( ) );\n    EventRecord.here( VolumeManager.class, EventClass.VOLUME, EventType.VOLUME_DETACH )\n               .withDetails( vm.getOwner( ).toString( ), volume.getVolumeId( ), \"instance\", vm.getInstanceId( ) ).withDetails( \"cluster\",\n                                                                                                                               Topology.lookup( ClusterController.class, vm.lookupPartition( ) ).toString( ) ).info( );\n    volume.setStatus( \"detaching\" );\n    reply.setDetachedVolume( volume );\n    return reply;\n  }","commit_id":"aef1bcbbd1973ed2a2718c1c858361a42fd56423","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public AttachVolumeResponseType AttachVolume( AttachVolumeType request ) throws EucalyptusCloudException {\n    AttachVolumeResponseType reply = ( AttachVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    \n    if ( request.getDevice( ) == null || request.getDevice( ).endsWith( \"sda\" ) || request.getDevice( ).endsWith( \"sdb\" ) ) {\n      throw new EucalyptusCloudException( \"Invalid device name specified: \" + request.getDevice( ) );\n    }\n    VmInstance vm = null;\n    try {\n      vm = RestrictedTypes.doPrivileged( request.getInstanceId( ), VmInstance.class );\n    } catch ( NoSuchElementException ex ) {\n      LOG.debug( ex, ex );\n      throw new EucalyptusCloudException( \"Instance does not exist: \" + request.getInstanceId( ), ex );\n    } catch ( Exception ex ) {\n      LOG.debug( ex, ex );\n      throw new EucalyptusCloudException( ex.getMessage( ), ex );\n    }\n    Cluster cluster = null;\n    try {\n      cluster = Clusters.lookup( vm.lookupPartition( ) );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + Topology.lookup( ClusterController.class, vm.lookupPartition( ) ) );\n    }\n    final String deviceName = request.getDevice( );\n    final String volumeId = request.getVolumeId( );\n    try {\n      vm.lookupVolumeAttachmentByDevice( deviceName );\n      throw new EucalyptusCloudException( \"Already have a device attached to: \" + request.getDevice( ) );\n    } catch ( NoSuchElementException ex1 ) {\n      /** no attachment **/\n    }\n    for ( VmInstance iter : VmInstances.list( Predicates.not( VmState.TERMINATED ) ) ) {\n      try {\n        iter.lookupVolumeAttachment( volumeId );\n        throw new EucalyptusCloudException( \"Volume already attached: \" + request.getVolumeId( ) );\n      } catch ( NoSuchElementException ex ) {\n        /** no attachment **/\n      }\n    }\n    \n    EntityWrapper<Volume> db = EntityWrapper.get( Volume.class );\n    Volume volume = null;\n    try {\n      volume = db.getUnique( Volume.named( ctx.getUserFullName( ), request.getVolumeId( ) ) );\n      if ( volume.getRemoteDevice( ) == null ) {\n        StorageUtil.getVolumeReply( new HashMap<String, AttachedVolume>( ), Lists.newArrayList( volume ) );\n      }\n      db.commit( );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( volume ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to attach volume \" + request.getVolumeId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    ServiceConfiguration sc = Partitions.lookupService( Storage.class, volume.getPartition( ) );\n    ServiceConfiguration scVm = Partitions.lookupService( Storage.class, cluster.getConfiguration( ).getPartition( ) );\n    if ( !sc.equals( scVm ) ) {\n      throw new EucalyptusCloudException( \"Can only attach volumes in the same cluster: \" + request.getVolumeId( ) );\n    } else if ( \"invalid\".equals( volume.getRemoteDevice( ) ) ) {\n      throw new EucalyptusCloudException( \"Volume is not yet available: \" + request.getVolumeId( ) );\n    }\n    \n    AttachStorageVolumeResponseType scAttachResponse;\n    try {\n      scAttachResponse = ServiceDispatcher.lookup( sc ).send( new AttachStorageVolumeType( cluster.getNode( vm.getServiceTag( ) ).getIqn( ),\n                                                                                           volume.getDisplayName( ) ) );\n    } catch ( Exception e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( e.getMessage( ) );\n    }\n    request.setRemoteDevice( scAttachResponse.getRemoteDeviceString( ) );\n\n    AttachedVolume attachVol = new AttachedVolume( volume.getDisplayName( ), vm.getInstanceId( ), request.getDevice( ), request.getRemoteDevice( ) );\n    volume.setState( State.BUSY );\n    attachVol.setStatus( \"attaching\" );\n    vm.addVolumeAttachment( attachVol );\n    AsyncRequests.newRequest( new VolumeAttachCallback( request, attachVol ) ).dispatch( cluster.getConfiguration( ) );\n    \n    EventRecord.here( VolumeManager.class, EventClass.VOLUME, EventType.VOLUME_ATTACH )\n               .withDetails( volume.getOwner( ).toString( ), volume.getDisplayName( ), \"instance\", vm.getInstanceId( ) )\n               .withDetails( \"partition\", vm.lookupPartition( ).toString( ) ).info( );\n    reply.setAttachedVolume( attachVol );\n    return reply;\n  }","id":34882,"modified_method":"public AttachVolumeResponseType AttachVolume( AttachVolumeType request ) throws EucalyptusCloudException {\n    AttachVolumeResponseType reply = ( AttachVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    \n    if ( request.getDevice( ) == null || request.getDevice( ).endsWith( \"sda\" ) || request.getDevice( ).endsWith( \"sdb\" ) ) {\n      throw new EucalyptusCloudException( \"Invalid device name specified: \" + request.getDevice( ) );\n    }\n    VmInstance vm = null;\n    try {\n      vm = RestrictedTypes.doPrivileged( request.getInstanceId( ), VmInstance.class );\n    } catch ( NoSuchElementException ex ) {\n      LOG.debug( ex, ex );\n      throw new EucalyptusCloudException( \"Instance does not exist: \" + request.getInstanceId( ), ex );\n    } catch ( Exception ex ) {\n      LOG.debug( ex, ex );\n      throw new EucalyptusCloudException( ex.getMessage( ), ex );\n    }\n    Cluster cluster = null;\n    try {\n      cluster = Clusters.lookup( vm.lookupPartition( ) );\n    } catch ( NoSuchElementException e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( \"Cluster does not exist: \" + Topology.lookup( ClusterController.class, vm.lookupPartition( ) ) );\n    }\n    final String deviceName = request.getDevice( );\n    final String volumeId = request.getVolumeId( );\n    try {\n      vm.lookupVolumeAttachmentByDevice( deviceName );\n      throw new EucalyptusCloudException( \"Already have a device attached to: \" + request.getDevice( ) );\n    } catch ( NoSuchElementException ex1 ) {\n      /** no attachment **/\n    }\n    for ( VmInstance iter : VmInstances.list( Predicates.not( VmState.TERMINATED ) ) ) {\n      try {\n        iter.lookupVolumeAttachment( volumeId );\n        throw new EucalyptusCloudException( \"Volume already attached: \" + request.getVolumeId( ) );\n      } catch ( NoSuchElementException ex ) {\n        /** no attachment **/\n      }\n    }\n    \n    EntityWrapper<Volume> db = EntityWrapper.get( Volume.class );\n    Volume volume = null;\n    try {\n      volume = db.getUnique( Volume.named( ctx.getUserFullName( ).asAccountFullName( ), request.getVolumeId( ) ) );\n      if ( volume.getRemoteDevice( ) == null ) {\n        StorageUtil.getVolumeReply( new HashMap<String, AttachedVolume>( ), Lists.newArrayList( volume ) );\n      }\n      db.commit( );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( volume ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to attach volume \" + request.getVolumeId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    ServiceConfiguration sc = Partitions.lookupService( Storage.class, volume.getPartition( ) );\n    ServiceConfiguration scVm = Partitions.lookupService( Storage.class, cluster.getConfiguration( ).getPartition( ) );\n    if ( !sc.equals( scVm ) ) {\n      throw new EucalyptusCloudException( \"Can only attach volumes in the same cluster: \" + request.getVolumeId( ) );\n    } else if ( \"invalid\".equals( volume.getRemoteDevice( ) ) ) {\n      throw new EucalyptusCloudException( \"Volume is not yet available: \" + request.getVolumeId( ) );\n    }\n    \n    AttachStorageVolumeResponseType scAttachResponse;\n    try {\n      scAttachResponse = ServiceDispatcher.lookup( sc ).send( new AttachStorageVolumeType( cluster.getNode( vm.getServiceTag( ) ).getIqn( ),\n                                                                                           volume.getDisplayName( ) ) );\n    } catch ( Exception e ) {\n      LOG.debug( e, e );\n      throw new EucalyptusCloudException( e.getMessage( ) );\n    }\n    request.setRemoteDevice( scAttachResponse.getRemoteDeviceString( ) );\n\n    AttachedVolume attachVol = new AttachedVolume( volume.getDisplayName( ), vm.getInstanceId( ), request.getDevice( ), request.getRemoteDevice( ) );\n    volume.setState( State.BUSY );\n    attachVol.setStatus( \"attaching\" );\n    vm.addVolumeAttachment( attachVol );\n    AsyncRequests.newRequest( new VolumeAttachCallback( request, attachVol ) ).dispatch( cluster.getConfiguration( ) );\n    \n    EventRecord.here( VolumeManager.class, EventClass.VOLUME, EventType.VOLUME_ATTACH )\n               .withDetails( volume.getOwner( ).toString( ), volume.getDisplayName( ), \"instance\", vm.getInstanceId( ) )\n               .withDetails( \"partition\", vm.lookupPartition( ).toString( ) ).info( );\n    reply.setAttachedVolume( attachVol );\n    return reply;\n  }","commit_id":"aef1bcbbd1973ed2a2718c1c858361a42fd56423","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteVolumeResponseType DeleteVolume( DeleteVolumeType request ) throws EucalyptusCloudException {\n    DeleteVolumeResponseType reply = ( DeleteVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    reply.set_return( false );\n    \n    EntityWrapper<Volume> db = EntityWrapper.get( Volume.class );\n    boolean reallyFailed = false;\n    try {\n      Volume vol = db.getUnique( Volume.named( ctx.getUserFullName( ), request.getVolumeId( ) ) );\n      if ( !RestrictedTypes.filterPrivileged( ).apply( vol ) ) {\n        throw new EucalyptusCloudException( \"Not authorized to delete volume by \" + ctx.getUser( ).getName( ) );\n      }\n      for ( VmInstance vm : VmInstances.list( Predicates.not( VmState.TERMINATED ) ) ) {\n        try {\n          vm.lookupVolumeAttachment( request.getVolumeId( ) );\n          db.rollback( );\n          return reply;\n        } catch ( NoSuchElementException ex ) {\n          /** no such volume attached, move along... **/\n        }\n      }\n      if ( State.FAIL.equals( vol.getState( ) ) ) {\n        db.delete( vol );\n        db.commit( );\n        return reply;\n      }\n      ServiceConfiguration sc = Partitions.lookupService( Storage.class, vol.getPartition( ) );\n      DeleteStorageVolumeResponseType scReply = ServiceDispatcher.lookup( sc ).send( new DeleteStorageVolumeType( vol.getDisplayName( ) ) );\n      if ( scReply.get_return( ) ) {\n        vol.setState( State.ANNIHILATING );\n        db.commit( );\n        try {\n          ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsVolume, false, vol.getSize( ),\n                                                                       vol.getOwnerUserId( ), vol.getOwnerUserName( ),\n                                                                       vol.getOwnerAccountNumber( ), vol.getOwnerAccountName( ),\n                                                                       vol.getScName( ), vol.getPartition( ) ) );\n        } catch ( EventFailedException ex ) {\n          LOG.error( ex, ex );\n        }\n      } else {\n        reallyFailed = true;\n        throw new EucalyptusCloudException( \"Storage Controller returned false:  Contact the administrator to report the problem.\" );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback( );\n      if ( reallyFailed ) {\n        throw e;\n      } else {\n        return reply;\n      }\n    }\n    reply.set_return( true );\n    return reply;\n  }","id":34883,"modified_method":"public DeleteVolumeResponseType DeleteVolume( DeleteVolumeType request ) throws EucalyptusCloudException {\n    DeleteVolumeResponseType reply = ( DeleteVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    reply.set_return( false );\n    \n    EntityWrapper<Volume> db = EntityWrapper.get( Volume.class );\n    boolean reallyFailed = false;\n    try {\n      Volume vol = db.getUnique( Volume.named( ctx.getUserFullName( ).asAccountFullName( ), request.getVolumeId( ) ) );\n      if ( !RestrictedTypes.filterPrivileged( ).apply( vol ) ) {\n        throw new EucalyptusCloudException( \"Not authorized to delete volume by \" + ctx.getUser( ).getName( ) );\n      }\n      for ( VmInstance vm : VmInstances.list( Predicates.not( VmState.TERMINATED ) ) ) {\n        try {\n          vm.lookupVolumeAttachment( request.getVolumeId( ) );\n          db.rollback( );\n          return reply;\n        } catch ( NoSuchElementException ex ) {\n          /** no such volume attached, move along... **/\n        }\n      }\n      if ( State.FAIL.equals( vol.getState( ) ) ) {\n        db.delete( vol );\n        db.commit( );\n        return reply;\n      }\n      ServiceConfiguration sc = Partitions.lookupService( Storage.class, vol.getPartition( ) );\n      DeleteStorageVolumeResponseType scReply = ServiceDispatcher.lookup( sc ).send( new DeleteStorageVolumeType( vol.getDisplayName( ) ) );\n      if ( scReply.get_return( ) ) {\n        vol.setState( State.ANNIHILATING );\n        db.commit( );\n        try {\n          ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsVolume, false, vol.getSize( ),\n                                                                       vol.getOwnerUserId( ), vol.getOwnerUserName( ),\n                                                                       vol.getOwnerAccountNumber( ), vol.getOwnerAccountName( ),\n                                                                       vol.getScName( ), vol.getPartition( ) ) );\n        } catch ( EventFailedException ex ) {\n          LOG.error( ex, ex );\n        }\n      } else {\n        reallyFailed = true;\n        throw new EucalyptusCloudException( \"Storage Controller returned false:  Contact the administrator to report the problem.\" );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback( );\n      if ( reallyFailed ) {\n        throw e;\n      } else {\n        return reply;\n      }\n    }\n    reply.set_return( true );\n    return reply;\n  }","commit_id":"aef1bcbbd1973ed2a2718c1c858361a42fd56423","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeKeyPairsResponseType describe( DescribeKeyPairsType request ) throws Exception {\n    DescribeKeyPairsResponseType reply = request.getReply( );\n    for ( SshKeyPair kp : Iterables.filter( KeyPairUtil.getUserKeyPairs( Contexts.lookup( ).getUserFullName( ) ), RestrictedTypes.filterPrivileged( ) ) ) {\n      if ( request.getKeySet( ).isEmpty( ) || request.getKeySet( ).contains( kp.getDisplayName( ) ) ) {\n        reply.getKeySet( ).add( new DescribeKeyPairsResponseItemType( kp.getDisplayName( ), kp.getFingerPrint( ) ) );\n      }\n    }\n    return reply;\n  }","id":34884,"modified_method":"public DescribeKeyPairsResponseType describe( DescribeKeyPairsType request ) throws Exception {\n    DescribeKeyPairsResponseType reply = request.getReply( );\n    for ( SshKeyPair kp : Iterables.filter( KeyPairs.list( Contexts.lookup( ).getUserFullName( ).asAccountFullName( ) ), RestrictedTypes.filterPrivileged( ) ) ) {\n      if ( request.getKeySet( ).isEmpty( ) || request.getKeySet( ).contains( kp.getDisplayName( ) ) ) {\n        reply.getKeySet( ).add( new DescribeKeyPairsResponseItemType( kp.getDisplayName( ), kp.getFingerPrint( ) ) );\n      }\n    }\n    return reply;\n  }","commit_id":"40b8dc862cc7afffb2b5374809fe390f5d4a1ffd","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static List<SshKeyPair> getUserKeyPairs( UserFullName userFullName ) {\n    EntityWrapper<SshKeyPair> db = EntityWrapper.get( SshKeyPair.class );;\n    List<SshKeyPair> keys = Lists.newArrayList( );\n    try {\n      keys = db.query( new SshKeyPair( userFullName ) );\n      db.commit( );\n    } catch ( Exception e ) {\n      db.rollback( );\n    }\n    return keys;\n  }","id":34885,"modified_method":"public static List<SshKeyPair> getUserKeyPairs( OwnerFullName ownerFullName ) {\n    EntityWrapper<SshKeyPair> db = EntityWrapper.get( SshKeyPair.class );;\n    List<SshKeyPair> keys = Lists.newArrayList( );\n    try {\n      keys = db.query( SshKeyPair.named( ownerFullName, null ) );\n      db.commit( );\n    } catch ( Exception e ) {\n      db.rollback( );\n    }\n    return keys;\n  }","commit_id":"40b8dc862cc7afffb2b5374809fe390f5d4a1ffd","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static PrivateKey create( UserFullName userName, String keyName ) throws MetadataException, TransactionException {\n    SshKeyPair newKey = new SshKeyPair( userName, keyName );\n    KeyPair newKeys = null;\n    try {\n      newKeys = Certs.generateKeyPair( );\n      String authKeyString = KeyPairs.getAuthKeyString( userName, newKeys );\n      newKey.setPublicKey( authKeyString );\n      newKey.setFingerPrint( Certs.getFingerPrint( newKeys.getPrivate( ) ) );\n    } catch ( Exception e ) {\n      throw new MetadataCreationException( \"KeyPair generation error: Key pair creation failed.\", e );\n    }\n    try {\n      Transactions.save( newKey );\n    } catch ( ConstraintViolationException ex ) {\n      throw new DuplicateMetadataException( \"Keypair already exists: \" + keyName + \": \" + ex.getMessage( ), ex );\n    }\n    return newKeys.getPrivate( );\n  }","id":34886,"modified_method":"public static PrivateKey create( UserFullName userName, String keyName ) throws MetadataException, TransactionException {\n    SshKeyPair newKey = SshKeyPair.create( userName, keyName );\n    KeyPair newKeys = null;\n    try {\n      newKeys = Certs.generateKeyPair( );\n      String authKeyString = KeyPairs.getAuthKeyString( userName, newKeys );\n      newKey.setPublicKey( authKeyString );\n      newKey.setFingerPrint( Certs.getFingerPrint( newKeys.getPrivate( ) ) );\n    } catch ( Exception e ) {\n      throw new MetadataCreationException( \"KeyPair generation error: Key pair creation failed.\", e );\n    }\n    try {\n      Transactions.save( newKey );\n    } catch ( ConstraintViolationException ex ) {\n      throw new DuplicateMetadataException( \"Keypair already exists: \" + keyName + \": \" + ex.getMessage( ), ex );\n    }\n    return newKeys.getPrivate( );\n  }","commit_id":"40b8dc862cc7afffb2b5374809fe390f5d4a1ffd","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static SshKeyPair fromPublicKey( OwnerFullName ownerFullName, String keyValue ) throws NoSuchMetadataException {\n    try {\n      return Transactions.find( new SshKeyPair( ownerFullName, keyValue ) );\n    } catch ( Exception e ) {\n      throw new NoSuchMetadataException( \"Failed to find key pair with public key: \" + keyValue + \" for \" + ownerFullName, e );\n    }\n    \n  }","id":34887,"modified_method":"public static SshKeyPair fromPublicKey( OwnerFullName ownerFullName, String keyValue ) throws NoSuchMetadataException {\n    try {\n      return Transactions.find( SshKeyPair.withPublicKey( ownerFullName, keyValue ) );\n    } catch ( Exception e ) {\n      throw new NoSuchMetadataException( \"Failed to find key pair with public key: \" + keyValue + \" for \" + ownerFullName, e );\n    }\n    \n  }","commit_id":"40b8dc862cc7afffb2b5374809fe390f5d4a1ffd","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Option eventadmin() {\n        return mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.eventadmin\").version(versionResolver);\n    }","id":34888,"modified_method":"public static Option eventadmin() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.eventadmin\").version(versionResolver),\n            config()\n        );\n    }","commit_id":"d65e610761fd2c3b26fc1f080a3591d7cfd8f5f0","url":"https://github.com/apache/sling"},{"original_method":"public static Option scr() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.metatype\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.scr\").version(versionResolver)\n        );\n    }","id":34889,"modified_method":"public static Option scr() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.metatype\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.scr\").version(versionResolver),\n            config()\n        );\n    }","commit_id":"d65e610761fd2c3b26fc1f080a3591d7cfd8f5f0","url":"https://github.com/apache/sling"},{"original_method":"public static Option httpWhiteboard() {\n        return mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.http.whiteboard\").version(versionResolver);\n    }","id":34890,"modified_method":"public static Option httpWhiteboard() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.http.whiteboard\").version(versionResolver),\n            http()\n        );\n    }","commit_id":"d65e610761fd2c3b26fc1f080a3591d7cfd8f5f0","url":"https://github.com/apache/sling"},{"original_method":"public static Option management() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.aries\").artifactId(\"org.apache.aries.util\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.aries.jmx\").artifactId(\"org.apache.aries.jmx.api\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.aries.jmx\").artifactId(\"org.apache.aries.jmx.core\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.aries.jmx\").artifactId(\"org.apache.aries.jmx.whiteboard\").version(versionResolver)\n        );\n    }","id":34891,"modified_method":"public static Option management() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.aries\").artifactId(\"org.apache.aries.util\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.aries.jmx\").artifactId(\"org.apache.aries.jmx.api\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.aries.jmx\").artifactId(\"org.apache.aries.jmx.core\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.aries.jmx\").artifactId(\"org.apache.aries.jmx.whiteboard\").version(versionResolver),\n            config()\n        );\n    }","commit_id":"d65e610761fd2c3b26fc1f080a3591d7cfd8f5f0","url":"https://github.com/apache/sling"},{"original_method":"public static Option webconsole() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.webconsole\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.inventory\").version(versionResolver)\n        );\n    }","id":34892,"modified_method":"public static Option webconsole() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.webconsole\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.inventory\").version(versionResolver),\n            mavenBundle().groupId(\"commons-fileupload\").artifactId(\"commons-fileupload\").version(versionResolver),\n            mavenBundle().groupId(\"commons-io\").artifactId(\"commons-io\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.geronimo.bundles\").artifactId(\"json\").version(versionResolver),\n            http()\n        );\n    }","commit_id":"d65e610761fd2c3b26fc1f080a3591d7cfd8f5f0","url":"https://github.com/apache/sling"},{"original_method":"public static Option http() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.http.jetty\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.http.servlet-api\").version(versionResolver)\n        );\n    }","id":34893,"modified_method":"public static Option http() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.http.jetty\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.http.servlet-api\").version(versionResolver),\n            config()\n        );\n    }","commit_id":"d65e610761fd2c3b26fc1f080a3591d7cfd8f5f0","url":"https://github.com/apache/sling"},{"original_method":"public static Option webconsole() {\n        return mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.webconsole\").version(versionResolver);\n    }","id":34894,"modified_method":"public static Option webconsole() {\n        return composite(\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.webconsole\").version(versionResolver),\n            mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.inventory\").version(versionResolver)\n        );\n    }","commit_id":"c9ff2e6b7e5b49d7c7bc9ece0d2d74e434979512","url":"https://github.com/apache/sling"},{"original_method":"public SlingVersionResolver() {\n        versions.put(\"org.apache.felix:org.apache.felix.configadmin\", \"1.8.8\");\n        versions.put(\"org.apache.felix:org.apache.felix.eventadmin\", \"1.4.6\");\n        versions.put(\"org.apache.felix:org.apache.felix.http.jetty\", \"3.2.0\");\n        versions.put(\"org.apache.felix:org.apache.felix.http.servlet-api\", \"1.1.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.http.whiteboard\", \"3.0.0\");\n        versions.put(\"org.apache.aries:org.apache.aries.util\", \"1.1.1\");\n        versions.put(\"org.apache.aries.jmx:org.apache.aries.jmx.api\", \"1.1.5\");\n        versions.put(\"org.apache.aries.jmx:org.apache.aries.jmx.core\", \"1.1.6\");\n        versions.put(\"org.apache.aries.jmx:org.apache.aries.jmx.whiteboard\", \"1.1.5\");\n        versions.put(\"org.apache.felix:org.apache.felix.metatype\", \"1.1.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.scr\", \"2.0.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.webconsole\", \"4.2.16\");\n        versions.put(\"com.composum.sling.core:composum-sling-core-commons\", \"1.5.3\");\n        versions.put(\"com.composum.sling.core:composum-sling-core-console\", \"1.5.3\");\n        versions.put(\"com.composum.sling.core:composum-sling-core-jslibs\", \"1.5.3\");\n        versions.put(\"com.google.guava:guava\", \"15.0\");\n        versions.put(\"com.sun.mail:javax.mail\", \"1.5.5\");\n        versions.put(\"commons-codec:commons-codec\", \"1.10\");\n        versions.put(\"commons-collections:commons-collections\", \"3.2.2\");\n        versions.put(\"commons-fileupload:commons-fileupload\", \"1.3.2\");\n        versions.put(\"commons-io:commons-io\", \"2.5\");\n        versions.put(\"commons-lang:commons-lang\", \"2.6\");\n        versions.put(\"io.dropwizard.metrics:metrics-core\", \"3.1.2\");\n        versions.put(\"io.wcm.osgi.wrapper:io.wcm.osgi.wrapper.rxjava\", \"1.0.14-0000\");\n        versions.put(\"javax.jcr:jcr\", \"2.0\");\n        versions.put(\"javax.mail:javax.mail-api\", \"1.5.5\");\n        versions.put(\"org.apache.commons:commons-email\", \"1.4\");\n        versions.put(\"org.apache.commons:commons-lang3\", \"3.4\");\n        versions.put(\"org.apache.commons:commons-math\", \"2.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.inventory\", \"1.0.4\");\n        versions.put(\"org.apache.felix:org.apache.felix.jaas\", \"0.0.4\");\n        versions.put(\"org.apache.felix:org.apache.felix.prefs\", \"1.0.6\");\n        versions.put(\"org.apache.felix:org.apache.felix.webconsole.plugins.memoryusage\", \"1.0.6\");\n        versions.put(\"org.apache.felix:org.apache.felix.webconsole.plugins.packageadmin\", \"1.0.2\");\n        versions.put(\"org.apache.geronimo.bundles:commons-httpclient\", \"3.1_2\");\n        versions.put(\"org.apache.geronimo.bundles:json\", \"20090211_1\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-atinject_1.0_spec\", \"1.0\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-el_2.2_spec\", \"1.0.4\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-interceptor_1.1_spec\", \"1.0\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-jcdi_1.0_spec\", \"1.0\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-jta_1.1_spec\", \"1.1.1\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-servlet_3.0_spec\", \"1.0\");\n        versions.put(\"org.apache.httpcomponents:httpclient-osgi\", \"4.5.2\");\n        versions.put(\"org.apache.httpcomponents:httpcore-osgi\", \"4.4.5\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-api\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-data\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-jcr-commons\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-jcr-rmi\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-spi\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-spi-commons\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-webdav\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:oak-blob\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-commons\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-core\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-jcr\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-lucene\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-segment\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit.vault:org.apache.jackrabbit.vault\", \"3.1.26\");\n        versions.put(\"org.apache.servicemix.bundles:org.apache.servicemix.bundles.rhino\", \"1.7.7.1_1\");\n        versions.put(\"org.apache.servicemix.bundles:org.apache.servicemix.bundles.urlrewritefilter\", \"4.0.4_1\");\n        versions.put(\"org.apache.sling:org.apache.sling.adapter\", \"2.1.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.api\", \"2.11.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.core\", \"1.3.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.form\", \"1.0.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.openid\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.selector\", \"1.0.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.bundleresource.impl\", \"2.2.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.classloader\", \"1.3.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.compiler\", \"2.3.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.fsclassloader\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.html\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.json\", \"2.0.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.messaging\", \"0.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.messaging.mail\", \"0.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.metrics\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.mime\", \"2.1.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.osgi\", \"2.4.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.scheduler\", \"2.4.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.threads\", \"3.2.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.api\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.base\", \"1.1.3-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.commons\", \"1.0.12\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.impl\", \"1.2.7-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.oak\", \"1.2.7-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.standalone\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.support\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.distribution.api\", \"0.3.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.distribution.core\", \"0.1.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.engine\", \"2.4.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.event\", \"4.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.event.dea\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.extensions.explorer\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.extensions.threaddump\", \"0.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.featureflags\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.fsresource\", \"1.1.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.core\", \"1.2.5-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.jmx\", \"1.0.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.support\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.webconsole\", \"1.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.i18n\", \"2.4.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.console\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.core\", \"3.6.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.factory.configuration\", \"1.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.provider.file\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.provider.jcr\", \"3.1.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.api\", \"2.3.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.base\", \"2.3.3-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.classloader\", \"3.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.compiler\", \"2.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.contentloader\", \"2.1.10\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.davex\", \"1.3.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.jackrabbit.accessmanager\", \"2.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.jackrabbit.usermanager\", \"2.2.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.oak.server\", \"1.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.registration\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.resource\", \"2.8.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.webconsole\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.webdav\", \"2.3.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.jmx.provider\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.launchpad.content\", \"2.0.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.models.api\", \"1.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.models.impl\", \"1.2.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.couchbase-client\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.couchbase-resourceprovider\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.generic\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.mongodb-resourceprovider\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.query\", \"3.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.resource.inventory\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.resourcemerger\", \"1.3.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.resourceresolver\", \"1.4.12\");\n        versions.put(\"org.apache.sling:org.apache.sling.rewriter\", \"1.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.api\", \"2.1.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.core\", \"2.0.37-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.freemarker\", \"1.0.0-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.groovy\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.java\", \"2.0.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.javascript\", \"2.0.30\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.jsp\", \"2.1.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.jsp.taglib\", \"2.2.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.sightly\", \"1.0.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.sightly.js.provider\", \"1.0.10\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.thymeleaf\", \"0.1.7-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.security\", \"1.0.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.serviceusermapper\", \"1.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.servlets.get\", \"2.1.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.servlets.post\", \"2.3.12\");\n        versions.put(\"org.apache.sling:org.apache.sling.servlets.resolver\", \"2.4.3-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.settings\", \"1.3.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.urlrewriter\", \"0.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.validation.api\", \"1.0.0-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.validation.core\", \"1.0.0-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.xss\", \"1.0.8\");\n        versions.put(\"org.apache.sling.samples:org.apache.sling.samples.fling\", \"0.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.tika:tika-bundle\", \"1.13\");\n        versions.put(\"org.apache.tika:tika-core\", \"1.13\");\n        versions.put(\"org.codehaus.groovy:groovy\", \"2.4.7\");\n        versions.put(\"org.codehaus.groovy:groovy-json\", \"2.4.7\");\n        versions.put(\"org.codehaus.groovy:groovy-templates\", \"2.4.7\");\n        versions.put(\"org.javassist:javassist\", \"3.20.0-GA\");\n        versions.put(\"org.mongodb:mongo-java-driver\", \"2.14.2\");\n    }","id":34895,"modified_method":"public SlingVersionResolver() {\n        versions.put(\"org.apache.felix:org.apache.felix.configadmin\", \"1.8.8\");\n        versions.put(\"org.apache.felix:org.apache.felix.eventadmin\", \"1.4.6\");\n        versions.put(\"org.apache.felix:org.apache.felix.http.jetty\", \"3.2.0\");\n        versions.put(\"org.apache.felix:org.apache.felix.http.servlet-api\", \"1.1.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.http.whiteboard\", \"3.0.0\");\n        versions.put(\"org.apache.aries:org.apache.aries.util\", \"1.1.1\");\n        versions.put(\"org.apache.aries.jmx:org.apache.aries.jmx.api\", \"1.1.5\");\n        versions.put(\"org.apache.aries.jmx:org.apache.aries.jmx.core\", \"1.1.6\");\n        versions.put(\"org.apache.aries.jmx:org.apache.aries.jmx.whiteboard\", \"1.1.5\");\n        versions.put(\"org.apache.felix:org.apache.felix.inventory\", \"1.0.4\");\n        versions.put(\"org.apache.felix:org.apache.felix.metatype\", \"1.1.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.scr\", \"2.0.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.webconsole\", \"4.2.16\");\n        versions.put(\"com.composum.sling.core:composum-sling-core-commons\", \"1.5.3\");\n        versions.put(\"com.composum.sling.core:composum-sling-core-console\", \"1.5.3\");\n        versions.put(\"com.composum.sling.core:composum-sling-core-jslibs\", \"1.5.3\");\n        versions.put(\"com.google.guava:guava\", \"15.0\");\n        versions.put(\"com.sun.mail:javax.mail\", \"1.5.5\");\n        versions.put(\"commons-codec:commons-codec\", \"1.10\");\n        versions.put(\"commons-collections:commons-collections\", \"3.2.2\");\n        versions.put(\"commons-fileupload:commons-fileupload\", \"1.3.2\");\n        versions.put(\"commons-io:commons-io\", \"2.5\");\n        versions.put(\"commons-lang:commons-lang\", \"2.6\");\n        versions.put(\"io.dropwizard.metrics:metrics-core\", \"3.1.2\");\n        versions.put(\"io.wcm.osgi.wrapper:io.wcm.osgi.wrapper.rxjava\", \"1.0.14-0000\");\n        versions.put(\"javax.jcr:jcr\", \"2.0\");\n        versions.put(\"javax.mail:javax.mail-api\", \"1.5.5\");\n        versions.put(\"org.apache.commons:commons-email\", \"1.4\");\n        versions.put(\"org.apache.commons:commons-lang3\", \"3.4\");\n        versions.put(\"org.apache.commons:commons-math\", \"2.2\");\n        versions.put(\"org.apache.felix:org.apache.felix.inventory\", \"1.0.4\");\n        versions.put(\"org.apache.felix:org.apache.felix.jaas\", \"0.0.4\");\n        versions.put(\"org.apache.felix:org.apache.felix.prefs\", \"1.0.6\");\n        versions.put(\"org.apache.felix:org.apache.felix.webconsole.plugins.memoryusage\", \"1.0.6\");\n        versions.put(\"org.apache.felix:org.apache.felix.webconsole.plugins.packageadmin\", \"1.0.2\");\n        versions.put(\"org.apache.geronimo.bundles:commons-httpclient\", \"3.1_2\");\n        versions.put(\"org.apache.geronimo.bundles:json\", \"20090211_1\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-atinject_1.0_spec\", \"1.0\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-el_2.2_spec\", \"1.0.4\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-interceptor_1.1_spec\", \"1.0\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-jcdi_1.0_spec\", \"1.0\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-jta_1.1_spec\", \"1.1.1\");\n        versions.put(\"org.apache.geronimo.specs:geronimo-servlet_3.0_spec\", \"1.0\");\n        versions.put(\"org.apache.httpcomponents:httpclient-osgi\", \"4.5.2\");\n        versions.put(\"org.apache.httpcomponents:httpcore-osgi\", \"4.4.5\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-api\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-data\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-jcr-commons\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-jcr-rmi\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-spi\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-spi-commons\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:jackrabbit-webdav\", \"2.12.1\");\n        versions.put(\"org.apache.jackrabbit:oak-blob\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-commons\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-core\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-jcr\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-lucene\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit:oak-segment\", \"1.5.3\");\n        versions.put(\"org.apache.jackrabbit.vault:org.apache.jackrabbit.vault\", \"3.1.26\");\n        versions.put(\"org.apache.servicemix.bundles:org.apache.servicemix.bundles.rhino\", \"1.7.7.1_1\");\n        versions.put(\"org.apache.servicemix.bundles:org.apache.servicemix.bundles.urlrewritefilter\", \"4.0.4_1\");\n        versions.put(\"org.apache.sling:org.apache.sling.adapter\", \"2.1.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.api\", \"2.11.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.core\", \"1.3.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.form\", \"1.0.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.openid\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.auth.selector\", \"1.0.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.bundleresource.impl\", \"2.2.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.classloader\", \"1.3.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.compiler\", \"2.3.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.fsclassloader\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.html\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.json\", \"2.0.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.messaging\", \"0.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.messaging.mail\", \"0.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.metrics\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.mime\", \"2.1.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.osgi\", \"2.4.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.scheduler\", \"2.4.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.commons.threads\", \"3.2.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.api\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.base\", \"1.1.3-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.commons\", \"1.0.12\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.impl\", \"1.2.7-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.oak\", \"1.2.7-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.standalone\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.discovery.support\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.distribution.api\", \"0.3.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.distribution.core\", \"0.1.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.engine\", \"2.4.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.event\", \"4.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.event.dea\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.extensions.explorer\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.extensions.threaddump\", \"0.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.featureflags\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.fsresource\", \"1.1.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.core\", \"1.2.5-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.jmx\", \"1.0.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.support\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.hc.webconsole\", \"1.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.i18n\", \"2.4.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.console\", \"1.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.core\", \"3.6.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.factory.configuration\", \"1.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.provider.file\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.installer.provider.jcr\", \"3.1.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.api\", \"2.3.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.base\", \"2.3.3-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.classloader\", \"3.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.compiler\", \"2.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.contentloader\", \"2.1.10\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.davex\", \"1.3.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.jackrabbit.accessmanager\", \"2.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.jackrabbit.usermanager\", \"2.2.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.oak.server\", \"1.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.registration\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.resource\", \"2.8.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.webconsole\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.jcr.webdav\", \"2.3.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.jmx.provider\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.launchpad.content\", \"2.0.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.models.api\", \"1.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.models.impl\", \"1.2.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.couchbase-client\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.couchbase-resourceprovider\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.generic\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.nosql.mongodb-resourceprovider\", \"1.1.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.query\", \"3.0.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.resource.inventory\", \"1.0.4\");\n        versions.put(\"org.apache.sling:org.apache.sling.resourcemerger\", \"1.3.0\");\n        versions.put(\"org.apache.sling:org.apache.sling.resourceresolver\", \"1.4.12\");\n        versions.put(\"org.apache.sling:org.apache.sling.rewriter\", \"1.1.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.api\", \"2.1.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.core\", \"2.0.37-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.freemarker\", \"1.0.0-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.groovy\", \"1.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.java\", \"2.0.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.javascript\", \"2.0.30\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.jsp\", \"2.1.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.jsp.taglib\", \"2.2.6\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.sightly\", \"1.0.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.sightly.js.provider\", \"1.0.10\");\n        versions.put(\"org.apache.sling:org.apache.sling.scripting.thymeleaf\", \"0.1.7-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.security\", \"1.0.18\");\n        versions.put(\"org.apache.sling:org.apache.sling.serviceusermapper\", \"1.2.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.servlets.get\", \"2.1.14\");\n        versions.put(\"org.apache.sling:org.apache.sling.servlets.post\", \"2.3.12\");\n        versions.put(\"org.apache.sling:org.apache.sling.servlets.resolver\", \"2.4.3-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.settings\", \"1.3.8\");\n        versions.put(\"org.apache.sling:org.apache.sling.urlrewriter\", \"0.0.2\");\n        versions.put(\"org.apache.sling:org.apache.sling.validation.api\", \"1.0.0-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.validation.core\", \"1.0.0-SNAPSHOT\");\n        versions.put(\"org.apache.sling:org.apache.sling.xss\", \"1.0.8\");\n        versions.put(\"org.apache.sling.samples:org.apache.sling.samples.fling\", \"0.0.1-SNAPSHOT\");\n        versions.put(\"org.apache.tika:tika-bundle\", \"1.13\");\n        versions.put(\"org.apache.tika:tika-core\", \"1.13\");\n        versions.put(\"org.codehaus.groovy:groovy\", \"2.4.7\");\n        versions.put(\"org.codehaus.groovy:groovy-json\", \"2.4.7\");\n        versions.put(\"org.codehaus.groovy:groovy-templates\", \"2.4.7\");\n        versions.put(\"org.javassist:javassist\", \"3.20.0-GA\");\n        versions.put(\"org.mongodb:mongo-java-driver\", \"2.14.2\");\n    }","commit_id":"c9ff2e6b7e5b49d7c7bc9ece0d2d74e434979512","url":"https://github.com/apache/sling"},{"original_method":"private String createRunnableBean(String ref, String method, Element taskElement, ParserContext parserContext) {\n\t\tBeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(\n\t\t\t\t\"org.springframework.scheduling.support.MethodInvokingRunnable\");\n\t\tbuilder.addPropertyReference(\"targetObject\", ref);\n\t\tbuilder.addPropertyValue(\"targetMethod\", method);\n\t\t// Extract the source of the current task\n\t\tbuilder.getRawBeanDefinition().setSource(parserContext.extractSource(taskElement));\n\t\treturn parserContext.getReaderContext().registerWithGeneratedName(builder.getBeanDefinition());\n\t}","id":34896,"modified_method":"private String createRunnableBean(String ref, String method, Element taskElement, ParserContext parserContext) {\n\t\tBeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(\n\t\t\t\t\"org.springframework.scheduling.support.MethodInvokingRunnable\");\n\t\tbuilder.addPropertyReference(\"targetObject\", ref);\n\t\tbuilder.addPropertyValue(\"targetMethod\", method);\n\t\t// Extract the source of the current task\n\t\tbuilder.getRawBeanDefinition().setSource(parserContext.extractSource(taskElement));\n\t\tString generatedName = parserContext.getReaderContext().generateBeanName(builder.getRawBeanDefinition());\n\t\tparserContext.registerBeanComponent(new BeanComponentDefinition(builder.getBeanDefinition(), generatedName));\n\t\treturn generatedName;\n\t}","commit_id":"33de330b0e1faeb1373ca74dcba63775b0657d98","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\r\n\t * Registers a new service with the specified application context\r\n\t * \r\n\t * @param grailsServiceClass The service class to register\r\n\t * @param context The app context to register with\r\n\t */\r\n\tpublic void registerService(GrailsServiceClass grailsServiceClass, GrailsWebApplicationContext context) {\r\n\t\tRuntimeSpringConfiguration springConfig = new DefaultRuntimeSpringConfiguration();\r\n\t\t\r\n\t\tBeanConfiguration serviceClassBean = springConfig\r\n\t\t\t\t\t\t\t\t\t\t\t\t.createSingletonBean(MethodInvokingFactoryBean.class)\r\n\t\t\t\t\t\t\t\t\t\t\t\t.addProperty(\"targetObject\", new RuntimeBeanReference(GrailsApplication.APPLICATION_ID,true))\r\n\t\t\t\t\t\t\t\t\t\t\t\t.addProperty(\"targetMethod\", \"getGrailsServiceClass\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t.addProperty(\"arguments\", grailsServiceClass.getFullName());\r\n\t\tcontext.registerBeanDefinition(grailsServiceClass.getFullName() + \"Class\",serviceClassBean.getBeanDefinition());\r\n\t\t\r\n\t\t\r\n\t\tBeanConfiguration serviceInstance = springConfig\r\n\t\t\t\t\t\t\t\t\t\t\t\t.createSingletonBean(grailsServiceClass.getFullName() + \"Instance\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryBean( grailsServiceClass.getFullName() + \"Class\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryMethod(\"newInstance\");\r\n\t\t\t\t\r\n\t\tif (grailsServiceClass.byName()) {\r\n\t\t\tserviceInstance.setAutowire(BeanConfiguration.AUTOWIRE_BY_NAME);\r\n\t\t} else if (grailsServiceClass.byType()) {\r\n\t\t\tserviceInstance.setAutowire(BeanConfiguration.AUTOWIRE_BY_TYPE);\r\n\t\t}\r\n        else {\r\n            serviceInstance.setAutowire(BeanConfiguration.AUTOWIRE_BY_TYPE);\r\n        }\r\n\r\n        context.registerBeanDefinition(grailsServiceClass.getFullName() + \"Instance\",serviceInstance.getBeanDefinition());\r\n\t\t\r\n\t    // configure the service instance as a hotswappable target source\r\n\t\r\n\t    // if its transactional configure transactional proxy\r\n\t    if (grailsServiceClass.isTransactional()) {\r\n\t\t\tProperties transactionAttributes = new Properties();\r\n\t\t\ttransactionAttributes.put(\"*\", \"PROPAGATION_REQUIRED\");\r\n\t\t\t\r\n\t\t\tBeanConfiguration transactionalProxyBean = springConfig\r\n\t\t\t\t\t\t\t\t.createSingletonBean(TransactionProxyFactoryBean.class)\r\n\t\t\t\t\t\t\t\t.addProperty(\"target\", new RuntimeBeanReference(grailsServiceClass.getFullName() + \"Instance\"))\r\n\t\t\t\t\t\t\t\t.addProperty(\"proxyTargetClass\", Boolean.TRUE)\r\n\t\t\t\t\t\t\t\t.addProperty(\"transactionAttributes\", transactionAttributes)\r\n\t\t\t\t\t\t\t\t.addProperty(TRANSACTION_MANAGER_BEAN, new RuntimeBeanReference(TRANSACTION_MANAGER_BEAN));\r\n\t\t\tcontext.registerBeanDefinition(grailsServiceClass.getPropertyName(),transactionalProxyBean.getBeanDefinition());\r\n\t\t\t\r\n\t\t} else {\r\n\t        // otherwise configure a standard proxy\r\n\t\t\tBeanConfiguration instanceRef = springConfig\r\n\t\t\t\t\t\t\t\t\t\t\t\t.createSingletonBean(BeanReferenceFactoryBean.class)\r\n\t\t\t\t\t\t\t\t\t\t\t\t.addProperty(\"targetBeanName\",grailsServiceClass.getFullName() + \"Instance\" );\r\n\t\t\t\r\n\t\t\tcontext.registerBeanDefinition(grailsServiceClass.getName() + \"Service\",instanceRef.getBeanDefinition());\r\n\t\t}\t\t\r\n\t}","id":34897,"modified_method":"/**\r\n\t * Registers a new service with the specified application context\r\n\t * \r\n\t * @param grailsServiceClass The service class to register\r\n\t * @param context The app context to register with\r\n\t */\r\n\tpublic void registerService(GrailsServiceClass grailsServiceClass, GrailsWebApplicationContext context) {\r\n\t\tRuntimeSpringConfiguration springConfig = new DefaultRuntimeSpringConfiguration();\r\n\t\t\r\n\t\tBeanConfiguration serviceClassBean = springConfig\r\n\t\t\t\t\t\t\t\t\t\t\t\t.createSingletonBean(MethodInvokingFactoryBean.class)\r\n\t\t\t\t\t\t\t\t\t\t\t\t.addProperty(\"targetObject\", new RuntimeBeanReference(GrailsApplication.APPLICATION_ID,true))\r\n\t\t\t\t\t\t\t\t\t\t\t\t.addProperty(\"targetMethod\", \"getGrailsServiceClass\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t.addProperty(\"arguments\", grailsServiceClass.getFullName());\r\n\t\tcontext.registerBeanDefinition(grailsServiceClass.getFullName() + \"Class\",serviceClassBean.getBeanDefinition());\r\n\t\t\r\n\t\t\r\n\t\tBeanConfiguration serviceInstance = springConfig\r\n\t\t\t\t\t\t\t\t\t\t\t\t.createSingletonBean(grailsServiceClass.getFullName() + \"Instance\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryBean( grailsServiceClass.getFullName() + \"Class\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryMethod(\"newInstance\");\r\n\t\t\t\t\r\n\t\tif (grailsServiceClass.byName()) {\r\n\t\t\tserviceInstance.setAutowire(BeanConfiguration.AUTOWIRE_BY_NAME);\r\n\t\t} else if (grailsServiceClass.byType()) {\r\n\t\t\tserviceInstance.setAutowire(BeanConfiguration.AUTOWIRE_BY_TYPE);\r\n\t\t}\r\n        else {\r\n            serviceInstance.setAutowire(BeanConfiguration.AUTOWIRE_BY_TYPE);\r\n        }\r\n\r\n        //context.registerBeanDefinition(grailsServiceClass.getFullName() + \"Instance\",serviceInstance.getBeanDefinition());\r\n\t\t\r\n\t    // configure the service instance as a hotswappable target source\r\n\t\r\n\t    // if its transactional configure transactional proxy\r\n\t    if (grailsServiceClass.isTransactional()) {\r\n\t\t\tProperties transactionAttributes = new Properties();\r\n\t\t\ttransactionAttributes.put(\"*\", \"PROPAGATION_REQUIRED\");\r\n\t\t\t\r\n\t\t\tBeanConfiguration transactionalProxyBean = springConfig\r\n\t\t\t\t\t\t\t\t.createSingletonBean(TransactionProxyFactoryBean.class)\r\n\t\t\t\t\t\t\t\t.addProperty(\"target\", serviceInstance.getBeanDefinition())\r\n\t\t\t\t\t\t\t\t.addProperty(\"proxyTargetClass\", Boolean.TRUE)\r\n\t\t\t\t\t\t\t\t.addProperty(\"transactionAttributes\", transactionAttributes)\r\n\t\t\t\t\t\t\t\t.addProperty(TRANSACTION_MANAGER_BEAN, new RuntimeBeanReference(TRANSACTION_MANAGER_BEAN));\r\n\t\t\tcontext.registerBeanDefinition(grailsServiceClass.getPropertyName(),transactionalProxyBean.getBeanDefinition());\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\tcontext.registerBeanDefinition(grailsServiceClass.getPropertyName(),serviceInstance.getBeanDefinition());\r\n\t\t}\t\t\r\n\t}","commit_id":"075145e116446e23fd77adcfc25dab01feb4a27e","url":"https://github.com/grails/grails-core"},{"original_method":"private void populateServiceClassReferences(RuntimeSpringConfiguration springConfig) {\r\n\t\tGrailsServiceClass[] serviceClasses = application.getGrailsServiceClasses();\r\n\t\tfor (int i = 0; i <serviceClasses.length; i++) {\r\n\t\t\tGrailsServiceClass grailsServiceClass = serviceClasses[i];\r\n\t\t\t\r\n\t\t\tspringConfig\r\n\t\t\t\t.addSingletonBean(grailsServiceClass.getFullName() + \"Class\", MethodInvokingFactoryBean.class)\r\n\t\t\t\t.addProperty(\"targetObject\", new RuntimeBeanReference(GrailsApplication.APPLICATION_ID,true))\r\n\t\t\t\t.addProperty(\"targetMethod\", \"getGrailsServiceClass\")\r\n\t\t\t\t.addProperty(\"arguments\", grailsServiceClass.getFullName());\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tBeanConfiguration serviceInstance = springConfig\r\n                                                    .createSingletonBean(grailsServiceClass.getFullName() + \"Instance\" )\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryBean( grailsServiceClass.getFullName() + \"Class\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryMethod(\"newInstance\");\r\n\t\t\t\r\n\t\t\tif (grailsServiceClass.byName()) {\r\n\t\t\t\tserviceInstance.setAutowire(\"byName\");\r\n\t\t\t} else if (grailsServiceClass.byType()) {\r\n\t\t\t\tserviceInstance.setAutowire(\"byType\");\r\n\t\t\t}\r\n            // configure the service instance as a hotswappable target source\r\n\r\n            // if its transactional configure transactional proxy\r\n            if (grailsServiceClass.isTransactional()) {\r\n\t\t\t\tProperties transactionAttributes = new Properties();\r\n\t\t\t\ttransactionAttributes.put(\"*\", \"PROPAGATION_REQUIRED\");\r\n\t\t\t\t\r\n\t\t\t\tspringConfig\r\n\t\t\t\t\t.addSingletonBean(grailsServiceClass.getPropertyName(),TransactionProxyFactoryBean.class)\r\n\t\t\t\t\t.addProperty(\"target\", serviceInstance.getBeanDefinition())\r\n\t\t\t\t\t.addProperty(\"proxyTargetClass\", Boolean.TRUE)\r\n\t\t\t\t\t.addProperty(\"transactionAttributes\", transactionAttributes)\r\n\t\t\t\t\t.addProperty(TRANSACTION_MANAGER_BEAN, new RuntimeBeanReference(TRANSACTION_MANAGER_BEAN));\r\n\t\t\t\t\r\n\t\t\t} else {\r\n                // otherwise configure a standard proxy\r\n                springConfig\r\n                        .addBeanConfiguration(grailsServiceClass.getName() + \"Service\", serviceInstance);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":34898,"modified_method":"private void populateServiceClassReferences(RuntimeSpringConfiguration springConfig) {\r\n\t\tGrailsServiceClass[] serviceClasses = application.getGrailsServiceClasses();\r\n\t\tfor (int i = 0; i <serviceClasses.length; i++) {\r\n\t\t\tGrailsServiceClass grailsServiceClass = serviceClasses[i];\r\n\t\t\t\r\n\t\t\tspringConfig\r\n\t\t\t\t.addSingletonBean(grailsServiceClass.getFullName() + \"Class\", MethodInvokingFactoryBean.class)\r\n\t\t\t\t.addProperty(\"targetObject\", new RuntimeBeanReference(GrailsApplication.APPLICATION_ID,true))\r\n\t\t\t\t.addProperty(\"targetMethod\", \"getGrailsServiceClass\")\r\n\t\t\t\t.addProperty(\"arguments\", grailsServiceClass.getFullName());\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tBeanConfiguration serviceInstance = springConfig\r\n                                                    .createSingletonBean(grailsServiceClass.getFullName() + \"Instance\" )\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryBean( grailsServiceClass.getFullName() + \"Class\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setFactoryMethod(\"newInstance\");\r\n\t\t\t\r\n\t\t\tif (grailsServiceClass.byName()) {\r\n\t\t\t\tserviceInstance.setAutowire(\"byName\");\r\n\t\t\t} else if (grailsServiceClass.byType()) {\r\n\t\t\t\tserviceInstance.setAutowire(\"byType\");\r\n\t\t\t}\r\n            // configure the service instance as a hotswappable target source\r\n\r\n            // if its transactional configure transactional proxy\r\n            if (grailsServiceClass.isTransactional()) {\r\n\t\t\t\tProperties transactionAttributes = new Properties();\r\n\t\t\t\ttransactionAttributes.put(\"*\", \"PROPAGATION_REQUIRED\");\r\n\t\t\t\t\r\n\t\t\t\tspringConfig\r\n\t\t\t\t\t.addSingletonBean(grailsServiceClass.getPropertyName(),TransactionProxyFactoryBean.class)\r\n\t\t\t\t\t.addProperty(\"target\", serviceInstance.getBeanDefinition())\r\n\t\t\t\t\t.addProperty(\"proxyTargetClass\", Boolean.TRUE)\r\n\t\t\t\t\t.addProperty(\"transactionAttributes\", transactionAttributes)\r\n\t\t\t\t\t.addProperty(TRANSACTION_MANAGER_BEAN, new RuntimeBeanReference(TRANSACTION_MANAGER_BEAN));\r\n\t\t\t\t\r\n\t\t\t} else {\r\n                // otherwise configure a standard proxy\r\n\r\n                springConfig\r\n                        .addBeanConfiguration(grailsServiceClass.getPropertyName(), serviceInstance);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"075145e116446e23fd77adcfc25dab01feb4a27e","url":"https://github.com/grails/grails-core"},{"original_method":"public void testRegisterService() throws Exception {\r\n\t\tGroovyClassLoader gcl = new GroovyClassLoader();\r\n\t\t\r\n\t\tGrailsApplication app = new DefaultGrailsApplication(new Class[0], gcl );\r\n\t\tMockApplicationContext parent = new MockApplicationContext();\r\n\t\tparent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\t\t\r\n\t\tGrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n\t\tGrailsWebApplicationContext ctx = (GrailsWebApplicationContext)conf.configure(new MockServletContext());\r\n\t\tassertNotNull(ctx);\r\n\t\t\r\n\t\tClass service = gcl.parseClass(\"class TestService { boolean transactional = true;def serviceMethod() { 'hello' } }\");\r\n\t\tGrailsServiceClass serviceClass = app.addServiceClass(service);\r\n\t\tconf.registerService(serviceClass,ctx);\r\n\t\t\r\n\t\tassertTrue(ctx.containsBean(\"TestServiceClass\"));\r\n\t\tassertTrue(ctx.containsBean(\"TestServiceInstance\"));\r\n\t\tGroovyObject serviceInstance = (GroovyObject)ctx.getBean(\"testService\");\t\t\r\n\t\t\r\n\t\tassertEquals(\"hello\",serviceInstance.invokeMethod(\"serviceMethod\",null));\r\n\t}","id":34899,"modified_method":"public void testRegisterService() throws Exception {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[0], gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        GrailsWebApplicationContext ctx = (GrailsWebApplicationContext)conf.configure(new MockServletContext());\r\n        assertNotNull(ctx);\r\n\r\n        Class service = gcl.parseClass(\"class TestService { boolean transactional = true;def serviceMethod() { 'hello' } }\");\r\n        GrailsServiceClass serviceClass = app.addServiceClass(service);\r\n        conf.registerService(serviceClass,ctx);\r\n\r\n        assertTrue(ctx.containsBean(\"TestServiceClass\"));\r\n        GroovyObject serviceInstance = (GroovyObject)ctx.getBean(\"testService\");\r\n\r\n        assertEquals(\"hello\",serviceInstance.invokeMethod(\"serviceMethod\",null));\r\n    }","commit_id":"075145e116446e23fd77adcfc25dab01feb4a27e","url":"https://github.com/grails/grails-core"},{"original_method":"protected void postProcess(BeanDefinitionBuilder builder, Element element)\n    {\n        String name = generateChildBeanName(element);\n        element.setAttribute(ATTRIBUTE_NAME, name);\n\n        //Some objects may or may not have a parent.  We need to check if\n        //If this bean has a property name (that will be set on the parent)\n        //If not, we can skip the post processing here\n        if(getPropertyName(element)==null)\n        {\n            return;\n        }\n        PropertyValue pv;\n        try\n        {\n            pv = getParentPropertyValue(element);\n        }\n        catch (Exception e)\n        {\n            // MULE-1737 - remove this once fixed.\n            //RM*: I think we should still leave this in here for the time being, JIC\n            logger.warn(\"Skipping process for \" + element, e);\n            return;\n        }\n\n        if (isMap(element))\n        {\n            if (pv == null)\n            {\n                pv = newParentPropertyValue(element, new ManagedMap());\n            }\n            MapEntryDefinitionParser.KeyValuePair pair =\n                    (MapEntryDefinitionParser.KeyValuePair) builder.getBeanDefinition().getSource();\n            ((Map) pv.getValue()).put(pair.getKey(), pair.getValue());\n\n        }\n        else if (isCollection(element))\n        {\n            if (pv == null)\n            {\n                pv = newParentPropertyValue(element, new ManagedList());\n            }\n            ((List) pv.getValue()).add(builder.getBeanDefinition());\n        }\n        else\n        {\n            pv = newParentPropertyValue(element, builder.getBeanDefinition());\n        }\n        addParentPropertyValue(element, pv);\n    }","id":34900,"modified_method":"protected void postProcess(BeanDefinitionBuilder builder, Element element)\n    {\n        String name = generateChildBeanName(element);\n        element.setAttribute(ATTRIBUTE_NAME, name);\n\n        //Some objects may or may not have a parent.  We need to check if\n        //If this bean has a property name (that will be set on the parent)\n        //If not, we can skip the post processing here\n        if(getPropertyName(element)==null)\n        {\n            return;\n        }\n        PropertyValue pv;\n        try\n        {\n            pv = getParentPropertyValue(element);\n        }\n        catch (Exception e)\n        {\n            // MULE-1737 - remove this once fixed.\n            //RM*: I think we should still leave this in here for the time being, JIC\n            logger.warn(\"Skipping process for \" + element, e);\n            return;\n        }\n\n        if (isMap(element))\n        {\n            if (pv == null)\n            {\n                pv = newParentPropertyValue(element, new ManagedMap());\n            }\n            MapEntryDefinitionParser.KeyValuePair pair =\n                    (MapEntryDefinitionParser.KeyValuePair) builder.getBeanDefinition().getSource();\n            ((Map) pv.getValue()).put(pair.getKey(), pair.getValue());\n\n        }\n        else if (isCollection(element))\n        {\n            if (pv == null)\n            {\n                pv = newParentPropertyValue(element, new ManagedList());\n            }\n            \n            List list = (List) pv.getValue();\n            Object source = builder.getBeanDefinition().getSource();\n            if (source instanceof ListEntryDefinitionParser.ListEntry)\n            {\n                ListEntryDefinitionParser.ListEntry listEntry = \n                    (ListEntryDefinitionParser.ListEntry)source;\n                list.add(listEntry.getProxiedObject());\n            }\n            else\n            {\n                list.add(builder.getBeanDefinition());\n            }\n        }\n        else\n        {\n            pv = newParentPropertyValue(element, builder.getBeanDefinition());\n        }\n        addParentPropertyValue(element, pv);\n    }","commit_id":"880e06d53582be6439bf2a9e78b4bd12cbb6bbea","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerTransportTypes() throws ClassNotFoundException\n    {\n        // Register Transport handlers\n        // By default these will alll be handled by Mule, however some companies may\n        // have\n        // their own they wish to use\n        for (Iterator iterator = getAxisTransportProtocols().keySet().iterator(); iterator.hasNext();)\n        {\n            String protocol = (String)iterator.next();\n            Object temp = getAxisTransportProtocols().get(protocol);\n            Class clazz = null;\n            if (temp instanceof String)\n            {\n                clazz = ClassUtils.loadClass(temp.toString(), getClass());\n            }\n            else\n            {\n                clazz = (Class)temp;\n            }\n            Call.setTransportForProtocol(protocol, clazz);\n        }\n    }","id":34901,"modified_method":"protected void registerTransportTypes() throws ClassNotFoundException\n    {\n        // Register Transport handlers\n        // By default these will alll be handled by Mule, however some companies may\n        // have their own they wish to use\n        Map transportProtocols = this.getAxisTransportProtocols();\n        for (Iterator iterator = transportProtocols.keySet().iterator(); iterator.hasNext();)\n        {\n            String protocol = (String)iterator.next();\n            Object temp = transportProtocols.get(protocol);\n            Class clazz = null;\n            if (temp instanceof String)\n            {\n                clazz = ClassUtils.loadClass(temp.toString(), getClass());\n            }\n            else\n            {\n                clazz = (Class)temp;\n            }\n            Call.setTransportForProtocol(protocol, clazz);\n        }\n    }","commit_id":"880e06d53582be6439bf2a9e78b4bd12cbb6bbea","url":"https://github.com/mulesoft/mule"},{"original_method":"public AxisConnector()\n    {\n        super();\n        registerProtocols();\n\n    }","id":34902,"modified_method":"public AxisConnector()\n    {\n        super();\n    }","commit_id":"880e06d53582be6439bf2a9e78b4bd12cbb6bbea","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doInitialise() throws InitialisationException\n    {\n        if (axisTransportProtocols == null)\n        {\n            axisTransportProtocols = new HashMap();\n            try\n            {\n                for (Iterator iterator = supportedSchemes.iterator(); iterator.hasNext();)\n                {\n                    String s = (String)iterator.next();\n                    axisTransportProtocols.put(s, MuleTransport.getTransportClass(s));\n                    registerSupportedProtocol(s);\n                }\n                managementContext.registerListener(this);\n            }\n            catch (Exception e)\n            {\n                throw new InitialisationException(e, this);\n            }\n        }\n        // TODO DO: call registerSupportedProtocol if axisTransportProtocols are set from external?\n            \n        if (clientProvider == null)\n        {\n            clientProvider = createAxisProvider(clientConfig);\n        }\n        else\n        {\n            if (clientConfig.equals(DEFAULT_MULE_AXIS_CLIENT_CONFIG) == false)\n            {\n                logger.warn(AxisMessages.clientProviderAndClientConfigConfigured());\n            }\n        }\n\n        if (axisServer == null)\n        {\n            if (serverProvider == null)\n            {\n                serverProvider = this.createAxisProvider(serverConfig);\n            }\n            else\n            {\n                if (serverConfig.equals(DEFAULT_MULE_AXIS_SERVER_CONFIG) == false)\n                {\n                    logger.warn(AxisMessages.serverProviderAndServerConfigConfigured());\n                }\n            }\n\n            // Create the AxisServer\n            axisServer = new AxisServer(serverProvider);\n            // principle of least surprise: doAutoTypes only has effect on our self-configured AxisServer\n            axisServer.setOption(\"axis.doAutoTypes\", Boolean.valueOf(doAutoTypes));\n        }\n        \n        // Register the Mule service serverProvider\n        WSDDProvider.registerProvider(QNAME_MULE_PROVIDER, new WSDDJavaMuleProvider(this));\n\n        try\n        {\n            registerTransportTypes();\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new InitialisationException(\n                CoreMessages.cannotLoadFromClasspath(e.getMessage()), e, this);\n        }\n\n        // Overload the UrlHandlers provided by Axis so Mule can use its transports\n        // to move\n        // Soap messages around\n        String handlerPkgs = System.getProperty(\"java.protocol.handler.pkgs\", null);\n        if (handlerPkgs != null)\n        {\n            if (!handlerPkgs.endsWith(\"|\"))\n            {\n                handlerPkgs += \"|\";\n            }\n            handlerPkgs = \"org.mule.providers.soap.axis.transport|\" + handlerPkgs;\n            System.setProperty(\"java.protocol.handler.pkgs\", handlerPkgs);\n            logger.debug(\"Setting java.protocol.handler.pkgs to: \" + handlerPkgs);\n        }\n\n        try\n        {\n            registerTypes((TypeMappingRegistryImpl)axisServer.getTypeMappingRegistry(), beanTypes);\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new InitialisationException(e, this);\n        }\n   }","id":34903,"modified_method":"protected void doInitialise() throws InitialisationException\n    {\n        this.registerProtocols();\n        \n        if (axisTransportProtocols == null)\n        {\n            axisTransportProtocols = new HashMap();\n            try\n            {\n                for (Iterator iterator = supportedSchemes.iterator(); iterator.hasNext();)\n                {\n                    String s = (String)iterator.next();\n                    axisTransportProtocols.put(s, MuleTransport.getTransportClass(s));\n                    registerSupportedProtocol(s);\n                }\n                managementContext.registerListener(this);\n            }\n            catch (Exception e)\n            {\n                throw new InitialisationException(e, this);\n            }\n        }\n        // TODO DO: call registerSupportedProtocol if axisTransportProtocols are set from external?\n            \n        if (clientProvider == null)\n        {\n            clientProvider = createAxisProvider(clientConfig);\n        }\n        else\n        {\n            if (clientConfig.equals(DEFAULT_MULE_AXIS_CLIENT_CONFIG) == false)\n            {\n                logger.warn(AxisMessages.clientProviderAndClientConfigConfigured());\n            }\n        }\n\n        if (axisServer == null)\n        {\n            if (serverProvider == null)\n            {\n                serverProvider = this.createAxisProvider(serverConfig);\n            }\n            else\n            {\n                if (serverConfig.equals(DEFAULT_MULE_AXIS_SERVER_CONFIG) == false)\n                {\n                    logger.warn(AxisMessages.serverProviderAndServerConfigConfigured());\n                }\n            }\n\n            // Create the AxisServer\n            axisServer = new AxisServer(serverProvider);\n            // principle of least surprise: doAutoTypes only has effect on our self-configured AxisServer\n            axisServer.setOption(\"axis.doAutoTypes\", Boolean.valueOf(doAutoTypes));\n        }\n        \n        // Register the Mule service serverProvider\n        WSDDProvider.registerProvider(QNAME_MULE_PROVIDER, new WSDDJavaMuleProvider(this));\n\n        try\n        {\n            registerTransportTypes();\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new InitialisationException(\n                CoreMessages.cannotLoadFromClasspath(e.getMessage()), e, this);\n        }\n\n        // Overload the UrlHandlers provided by Axis so Mule can use its transports\n        // to move\n        // Soap messages around\n        String handlerPkgs = System.getProperty(\"java.protocol.handler.pkgs\", null);\n        if (handlerPkgs != null)\n        {\n            if (!handlerPkgs.endsWith(\"|\"))\n            {\n                handlerPkgs += \"|\";\n            }\n            handlerPkgs = \"org.mule.providers.soap.axis.transport|\" + handlerPkgs;\n            System.setProperty(\"java.protocol.handler.pkgs\", handlerPkgs);\n            logger.debug(\"Setting java.protocol.handler.pkgs to: \" + handlerPkgs);\n        }\n\n        try\n        {\n            registerTypes((TypeMappingRegistryImpl)axisServer.getTypeMappingRegistry(), beanTypes);\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new InitialisationException(e, this);\n        }\n   }","commit_id":"880e06d53582be6439bf2a9e78b4bd12cbb6bbea","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        this.registerBeanDefinitionParser(\"connector\", \n            new SingleElementDefinitionParser(AxisConnector.class, true));\n    }","id":34904,"modified_method":"public void init()\n    {\n        this.registerBeanDefinitionParser(\"connector\", \n            new SingleElementDefinitionParser(AxisConnector.class, true));\n        this.registerBeanDefinitionParser(\"beanType\", new ListEntryDefinitionParser(\"beanTypes\"));\n        this.registerBeanDefinitionParser(\"supportedScheme\", new ListEntryDefinitionParser(\"supportedSchemes\"));\n    }","commit_id":"880e06d53582be6439bf2a9e78b4bd12cbb6bbea","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testInjectedObjects()\n    {\n        AxisConnector connector = \n            (AxisConnector)managementContext.getRegistry().lookupConnector(\"axisConnector2\");\n\n        Assert.assertNotNull(connector);\n        Assert.assertEquals(MockAxisServer.class, connector.getAxisServer().getClass());\n        Assert.assertEquals(MockProvider.class, connector.getClientProvider().getClass());\n        Assert.assertFalse(connector.isDoAutoTypes());\n    }","id":34905,"modified_method":"public void testInjectedObjects()\n    {\n        AxisConnector connector = \n            (AxisConnector)managementContext.getRegistry().lookupConnector(\"axisConnector2\");\n\n        Assert.assertNotNull(connector);\n        Assert.assertEquals(MockAxisServer.class, connector.getAxisServer().getClass());\n        Assert.assertEquals(MockProvider.class, connector.getClientProvider().getClass());\n    }","commit_id":"880e06d53582be6439bf2a9e78b4bd12cbb6bbea","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testConfig()\n    {\n        AxisConnector connector = \n            (AxisConnector)managementContext.getRegistry().lookupConnector(\"axisConnector\");\n        \n        Assert.assertNotNull(connector);\n        Assert.assertEquals(\"test-axis-config.wsdd\", connector.getServerConfig());\n        Assert.assertEquals(\"test-axis-config.wsdd\", connector.getClientConfig());\n        Assert.assertFalse(connector.isTreatMapAsNamedParams());\n    }","id":34906,"modified_method":"public void testConfig()\n    {\n        AxisConnector connector = \n            (AxisConnector)managementContext.getRegistry().lookupConnector(\"axisConnector\");\n        \n        Assert.assertNotNull(connector);\n        Assert.assertEquals(\"test-axis-config.wsdd\", connector.getServerConfig());\n        Assert.assertEquals(\"test-axis-config.wsdd\", connector.getClientConfig());\n        Assert.assertFalse(connector.isTreatMapAsNamedParams());\n        Assert.assertFalse(connector.isDoAutoTypes());\n        Assert.assertEquals(2, connector.getBeanTypes().size());\n        Assert.assertTrue(connector.getBeanTypes().contains(\"org.mule.tck.testmodels.fruit.Apple\"));\n        Assert.assertTrue(connector.getBeanTypes().contains(\"org.mule.tck.testmodels.fruit.Banana\"));\n        Assert.assertEquals(1, connector.getSupportedSchemes().size());\n        Assert.assertEquals(\"http\", connector.getSupportedSchemes().get(0));\n    }","commit_id":"880e06d53582be6439bf2a9e78b4bd12cbb6bbea","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\tView row = convertView;\n\t\t\tif (row == null){\n\t\t\t\trow = inflater.inflate(R.layout.dash_audio_video_notes_item, parent, false);\n\t\t\t\trow.findViewById(R.id.divider).setVisibility(View.GONE);\n\t\t\t}\n\t\t\tboolean light = ((OsmandApplication)getApplication()).getSettings().isLightContent();\n\t\t\tif (light) {\n\t\t\t\trow.setBackgroundColor(getResources().getColor(R.color.expandable_list_item_light));\n\t\t\t} else {\n\t\t\t\trow.setBackgroundColor(getResources().getColor(R.color.expandable_list_item_dark));\n\t\t\t}\n\t\t\tfinal AudioVideoNotesPlugin.Recording recording = getItem(position);\n\t\t\tDashAudioVideoNotesFragment.getNoteView(recording, row, DashAudioVideoNotesActivity.this, plugin);\n\t\t\trow.setOnLongClickListener(new View.OnLongClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onLongClick(View v) {\n\t\t\t\t\tshowContextMenu(recording);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn row;\n\t\t}","id":34907,"modified_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\tView row = convertView;\n\t\t\tif (row == null){\n\t\t\t\trow = inflater.inflate(R.layout.dash_audio_video_notes_item, parent, false);\n\t\t\t\trow.findViewById(R.id.divider).setVisibility(View.GONE);\n\t\t\t}\n\t\t\tboolean light = ((OsmandApplication)getApplication()).getSettings().isLightContent();\n\t\t\tif (light) {\n\t\t\t\trow.setBackgroundColor(getResources().getColor(R.color.expandable_list_item_light));\n\t\t\t} else {\n\t\t\t\trow.setBackgroundColor(getResources().getColor(R.color.list_item_background_dark));\n\t\t\t}\n\t\t\tfinal AudioVideoNotesPlugin.Recording recording = getItem(position);\n\t\t\tDashAudioVideoNotesFragment.getNoteView(recording, row, DashAudioVideoNotesActivity.this, plugin);\n\t\t\trow.setOnLongClickListener(new View.OnLongClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onLongClick(View v) {\n\t\t\t\t\tshowContextMenu(recording);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn row;\n\t\t}","commit_id":"4a2f288d50a5d9dba8ae51831b7c2e57371b9924","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void draw(Canvas canvas) {\n\t\tif (resourceId != -1) {\n\t\t\tcanvas.rotate(angle, canvas.getHeight()/2, canvas.getWidth()/2);\n\t\t\tBitmap arrow = BitmapFactory.decodeResource(ctx.getResources(), resourceId);\n\t\t\tcanvas.drawBitmap(arrow, null, new Rect(0,0,arrow.getHeight(), arrow.getWidth()), null);\n\t\t} else {\n\t\t\tcanvas.rotate(angle, canvas.getHeight()/2, canvas.getWidth() / 2);\n\t\t\tPath directionPath = createDirectionPath();\n\t\t\tcanvas.drawPath(directionPath, paintRouteDirection);\n\t\t}\n\t}","id":34908,"modified_method":"@Override\n\tpublic void draw(Canvas canvas) {\n\t\tif (resourceId != -1) {\n\t\t\tcanvas.rotate(angle, canvas.getHeight() / 2, canvas.getWidth() / 2);\n\n\t\t\tDrawable arrowImage = ctx.getResources().getDrawable(resourceId);\n\t\t\tBitmap arrow = Bitmap.createBitmap(canvas.getWidth(), canvas.getHeight(), Bitmap.Config.ARGB_8888);\n\t\t\tCanvas canv = new Canvas(arrow);\n\t\t\tarrowImage.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n\t\t\tarrowImage.draw(canv);\n\t\t\tcanvas.drawBitmap(arrow, null, new Rect(0, 0, arrow.getHeight(), arrow.getWidth()), null);\n\t\t} else {\n\t\t\tcanvas.rotate(angle, canvas.getHeight()/2, canvas.getWidth() / 2);\n\t\t\tPath directionPath = createDirectionPath();\n\t\t\tcanvas.drawPath(directionPath, paintRouteDirection);\n\t\t}\n\t}","commit_id":"4a2f288d50a5d9dba8ae51831b7c2e57371b9924","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tboolean checkBox = row != null && row.findViewById(R.id.check_item) instanceof CheckBox;\n\t\t\tboolean same = (selectionMode && checkBox) || (!selectionMode && !checkBox);\n\t\t\tif (row == null || !same) {\n\t\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\t\trow = inflater.inflate(\n\t\t\t\t\t\tselectionMode ? R.layout.expandable_list_item_category :\n\t\t\t\t\t\t\tR.layout.expandable_list_item_category_btn, parent, false);\n\t\t\t\tfixBackgroundRepeat(row);\n\t\t\t}\n\t\t\tadjustIndicator(groupPosition, isExpanded, row, getMyApplication().getSettings().isLightContent());\n\t\t\tTextView label = (TextView) row.findViewById(R.id.category_name);\n\t\t\tfinal FavoriteGroup model = getGroup(groupPosition);\n\t\t\tlabel.setText(model.name.length() == 0? getString(R.string.favourites_activity) : model.name);\n\n\t\t\tif (selectionMode) {\n\t\t\t\tfinal CheckBox ch = (CheckBox) row.findViewById(R.id.check_item);\n\t\t\t\tch.setVisibility(View.VISIBLE);\n\t\t\t\tch.setChecked(groupsToDelete.contains(model));\n\n\t\t\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tif (ch.isChecked()) {\n\t\t\t\t\t\t\tgroupsToDelete.add(model);\n\t\t\t\t\t\t\tList<FavouritePoint> fvs = model.points;\n\t\t\t\t\t\t\tif (fvs != null) {\n\t\t\t\t\t\t\t\tfavoritesSelected.addAll(fvs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfavouritesAdapter.notifyDataSetInvalidated();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgroupsToDelete.remove(model);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdateSelectionMode(actionMode);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfinal ImageView ch = (ImageView) row.findViewById(R.id.check_item);\n\t\t\t\tch.setVisibility(View.VISIBLE);\n\t\t\t\tch.setImageDrawable(getActivity().getResources().getDrawable(\n\t\t\t\t\t\tgetMyApplication().getSettings().isLightContent() ? R.drawable.ic_action_settings_enabled_light\n\t\t\t\t\t\t\t\t: R.drawable.ic_action_settings_enabled_dark));\n\t\t\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\topenChangeGroupDialog(model);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn row;\n\t\t}","id":34909,"modified_method":"@Override\n\t\tpublic View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tboolean checkBox = row != null && row.findViewById(R.id.check_item) instanceof CheckBox;\n\t\t\tboolean same = (selectionMode && checkBox) || (!selectionMode && !checkBox);\n\t\t\tif (row == null || !same) {\n\t\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\t\trow = inflater.inflate(\n\t\t\t\t\t\tselectionMode ? R.layout.expandable_list_item_category :\n\t\t\t\t\t\t\tR.layout.expandable_list_item_category_btn, parent, false);\n\t\t\t\tfixBackgroundRepeat(row);\n\t\t\t}\n\t\t\tadjustIndicator(groupPosition, isExpanded, row, getMyApplication().getSettings().isLightContent());\n\t\t\tTextView label = (TextView) row.findViewById(R.id.category_name);\n\t\t\tfinal FavoriteGroup model = getGroup(groupPosition);\n\t\t\tlabel.setText(model.name.length() == 0? getString(R.string.favourites_activity) : model.name);\n\n\t\t\tif (selectionMode) {\n\t\t\t\tfinal CheckBox ch = (CheckBox) row.findViewById(R.id.check_item);\n\t\t\t\tch.setVisibility(View.VISIBLE);\n\t\t\t\tch.setChecked(groupsToDelete.contains(model));\n\n\t\t\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tif (ch.isChecked()) {\n\t\t\t\t\t\t\tgroupsToDelete.add(model);\n\t\t\t\t\t\t\tList<FavouritePoint> fvs = model.points;\n\t\t\t\t\t\t\tif (fvs != null) {\n\t\t\t\t\t\t\t\tfavoritesSelected.addAll(fvs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfavouritesAdapter.notifyDataSetInvalidated();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgroupsToDelete.remove(model);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdateSelectionMode(actionMode);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfinal ImageView ch = (ImageView) row.findViewById(R.id.check_item);\n\t\t\t\tch.setVisibility(View.VISIBLE);\n\t\t\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\topenChangeGroupDialog(model);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn row;\n\t\t}","commit_id":"4a2f288d50a5d9dba8ae51831b7c2e57371b9924","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\trow = inflater.inflate(R.layout.searchpoi_list, parent, false);\n\t\t\t}\n\t\t\tfloat[] mes = null;\n\t\t\tTextView label = (TextView) row.findViewById(R.id.poi_label);\n\t\t\tImageView direction = (ImageView) row.findViewById(R.id.poi_direction);\n\t\t\tImageView icon = (ImageView) row.findViewById(R.id.poi_icon);\n\t\t\tAmenity amenity = getItem(position);\n\t\t\tnet.osmand.Location loc = location;\n\t\t\tif(loc != null){\n\t\t\t\tmes = new float[2];\n\t\t\t\tLatLon l = amenity.getLocation();\n\t\t\t\tnet.osmand.Location.distanceBetween(l.getLatitude(), l.getLongitude(), loc.getLatitude(), loc.getLongitude(), mes);\n\t\t\t}\n\t\t\tint opened = -1;\n\t\t\tif (amenity.getOpeningHours() != null) {\n\t\t\t\tOpeningHours rs = OpeningHoursParser.parseOpenedHours(amenity.getOpeningHours());\n\t\t\t\tif (rs != null) {\n\t\t\t\t\tCalendar inst = Calendar.getInstance();\n\t\t\t\t\tinst.setTimeInMillis(System.currentTimeMillis());\n\t\t\t\t\tboolean work = false;\n\t\t\t\t\twork = rs.isOpenedForTime(inst);\n\t\t\t\t\tif (work) {\n\t\t\t\t\t\topened = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topened = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(loc != null){\n\t\t\t\tDirectionDrawable draw = new DirectionDrawable(SearchPOIActivity.this, width, height);\n\t\t\t\tFloat h = heading;\n\t\t\t\tfloat a = h != null ? h : 0;\n\n\t\t\t\t//Hardy: getRotation() is the correction if device's screen orientation != the default display's standard orientation\n\t\t\t\tint screenOrientation = 0;\n\t\t\t\tscreenOrientation = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();\n\t\t\t\tswitch (screenOrientation)\n\t\t\t\t{\n\t\t\t\tcase ORIENTATION_0:   // Device default (normally portrait)\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_90:  // Landscape right\n\t\t\t\t\tscreenOrientation = 90;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_270: // Landscape left\n\t\t\t\t\tscreenOrientation = 270;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_180: // Upside down\n\t\t\t\t\tscreenOrientation = 180;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Looks like screenOrientation correction must not be applied for devices without compass?\n\t\t\t\tSensor compass  = ((SensorManager) getSystemService(Context.SENSOR_SERVICE)).getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\n\t\t\t\tif (compass == null) {\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t}\n\n\t\t\t\tdraw.setAngle(mes[1] - a + 180 + screenOrientation);\n\n\t\t\t\tdraw.setOpenedColor(opened);\n\t\t\t\tdirection.setImageDrawable(draw);\n\t\t\t} else {\n\t\t\t\tif(opened == -1){\n\t\t\t\t\tdirection.setImageResource(R.drawable.poi);\n\t\t\t\t} else if(opened == 0){\n\t\t\t\t\tdirection.setImageResource(R.drawable.opened_poi);\n\t\t\t\t} else {\n\t\t\t\t\tdirection.setImageResource(R.drawable.closed_poi);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder tag = new StringBuilder();\n\t\t\tStringBuilder value = new StringBuilder();\n\t\t\tMapRenderingTypes.getDefault().getAmenityTagValue(amenity.getType(), amenity.getSubType(),\n\t\t\t\t\ttag, value);\n\t\t\tif(RenderingIcons.containsBigIcon(tag + \"_\" + value)) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(tag + \"_\" + value));\n\t\t\t} else if(RenderingIcons.containsBigIcon(value.toString())) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(value.toString()));\n\t\t\t} else {\n\t\t\t\ticon.setImageDrawable(null);\n\t\t\t}\n\n\t\t\tString distance = \"  \";\n\t\t\tif(mes != null){\n\t\t\t\tdistance = \" \" + OsmAndFormatter.getFormattedDistance((int) mes[0], getMyApplication()) + \"  \"; //$NON-NLS-1$\n\t\t\t}\n\t\t\tString poiType = OsmAndFormatter.getPoiStringWithoutType(amenity, settings.usingEnglishNames());\n\t\t\tlabel.setText(distance + poiType, TextView.BufferType.SPANNABLE);\n\t\t\t((Spannable) label.getText()).setSpan(new ForegroundColorSpan(getResources().getColor(R.color.color_distance)), 0, distance.length() - 1, 0);\n\t\t\treturn (row);\n\t\t}","id":34910,"modified_method":"@Override\n\t\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\trow = inflater.inflate(R.layout.searchpoi_list, parent, false);\n\t\t\t}\n\t\t\tfloat[] mes = null;\n\t\t\tTextView label = (TextView) row.findViewById(R.id.poi_label);\n\t\t\tTextView distanceText = (TextView) row.findViewById(R.id.distance);\n\t\t\tImageView direction = (ImageView) row.findViewById(R.id.poi_direction);\n\t\t\tImageView icon = (ImageView) row.findViewById(R.id.poi_icon);\n\t\t\tAmenity amenity = getItem(position);\n\t\t\tnet.osmand.Location loc = location;\n\t\t\tif(loc != null){\n\t\t\t\tmes = new float[2];\n\t\t\t\tLatLon l = amenity.getLocation();\n\t\t\t\tnet.osmand.Location.distanceBetween(l.getLatitude(), l.getLongitude(), loc.getLatitude(), loc.getLongitude(), mes);\n\t\t\t}\n\t\t\tint opened = -1;\n\t\t\tif (amenity.getOpeningHours() != null) {\n\t\t\t\tOpeningHours rs = OpeningHoursParser.parseOpenedHours(amenity.getOpeningHours());\n\t\t\t\tif (rs != null) {\n\t\t\t\t\tCalendar inst = Calendar.getInstance();\n\t\t\t\t\tinst.setTimeInMillis(System.currentTimeMillis());\n\t\t\t\t\tboolean work = false;\n\t\t\t\t\twork = rs.isOpenedForTime(inst);\n\t\t\t\t\tif (work) {\n\t\t\t\t\t\topened = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topened = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(loc != null){\n\t\t\t\tDirectionDrawable draw = new DirectionDrawable(SearchPOIActivity.this, width, height, R.drawable.ic_destination_arrow);\n\t\t\t\tFloat h = heading;\n\t\t\t\tfloat a = h != null ? h : 0;\n\n\t\t\t\t//Hardy: getRotation() is the correction if device's screen orientation != the default display's standard orientation\n\t\t\t\tint screenOrientation = 0;\n\t\t\t\tscreenOrientation = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();\n\t\t\t\tswitch (screenOrientation)\n\t\t\t\t{\n\t\t\t\tcase ORIENTATION_0:   // Device default (normally portrait)\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_90:  // Landscape right\n\t\t\t\t\tscreenOrientation = 90;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_270: // Landscape left\n\t\t\t\t\tscreenOrientation = 270;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_180: // Upside down\n\t\t\t\t\tscreenOrientation = 180;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Looks like screenOrientation correction must not be applied for devices without compass?\n\t\t\t\tSensor compass  = ((SensorManager) getSystemService(Context.SENSOR_SERVICE)).getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\n\t\t\t\tif (compass == null) {\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t}\n\n\t\t\t\tdraw.setAngle(mes[1] - a + 180 + screenOrientation);\n\n\t\t\t\tdraw.setOpenedColor(opened);\n\t\t\t\tdirection.setImageDrawable(draw);\n\t\t\t} else {\n\t\t\t\tif(opened == -1){\n\t\t\t\t\tdirection.setImageResource(R.drawable.poi);\n\t\t\t\t} else if(opened == 0){\n\t\t\t\t\tdirection.setImageResource(R.drawable.opened_poi);\n\t\t\t\t} else {\n\t\t\t\t\tdirection.setImageResource(R.drawable.closed_poi);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder tag = new StringBuilder();\n\t\t\tStringBuilder value = new StringBuilder();\n\t\t\tMapRenderingTypes.getDefault().getAmenityTagValue(amenity.getType(), amenity.getSubType(),\n\t\t\t\t\ttag, value);\n\t\t\tif(RenderingIcons.containsBigIcon(tag + \"_\" + value)) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(tag + \"_\" + value));\n\t\t\t} else if(RenderingIcons.containsBigIcon(value.toString())) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(value.toString()));\n\t\t\t} else {\n\t\t\t\ticon.setImageDrawable(null);\n\t\t\t}\n\n\t\t\tString distance = \"  \";\n\t\t\tif(mes != null){\n\t\t\t\tdistance = \" \" + OsmAndFormatter.getFormattedDistance((int) mes[0], getMyApplication()) + \"  \"; //$NON-NLS-1$\n\t\t\t}\n\t\t\tString poiType = OsmAndFormatter.getPoiStringWithoutType(amenity, settings.usingEnglishNames());\n\t\t\tlabel.setText(poiType);\n\t\t\tdistanceText.setText(distance);\n\t\t\treturn (row);\n\t\t}","commit_id":"4a2f288d50a5d9dba8ae51831b7c2e57371b9924","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.searchpoi);\n\t\t\n\t\tgetSupportActionBar().setTitle(R.string.searchpoi_activity);\n\t\tgetSupportActionBar().setIcon(R.drawable.tab_search_poi_icon);\n\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\n\t\tapp = (OsmandApplication)getApplication();\n\t\t\n\t\tuiHandler = new Handler();\n\t\tsearchFilter = (EditText) findViewById(R.id.SearchFilter);\n\t\tsearchFilterLayout = findViewById(R.id.SearchFilterLayout);\n\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\t\n\t\tsearchFilter.addTextChangedListener(new TextWatcher(){\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif(!isNameFinderFilter() && !isSearchByNameFilter()){\n\t\t\t\t\tamenityAdapter.getFilter().filter(s);\n\t\t\t\t} else {\n\t\t\t\t\tif(searchPOILevel != null)  {\n\t\t\t\t\t\tsearchPOILevel.setEnabled(true);\n\t\t\t\t\t\tsearchPOILevel.setTitle(R.string.search_button);\n\t\t\t\t\t}\n\t\t\t\t\tsearchFooterButton.setEnabled(true);\n\t\t\t\t\tsearchFooterButton.setText(R.string.search_button);\n\t\t\t\t\t// Cancel current search request here?\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\t\t});\n\t\tsearchFilter.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onFocusChange(View v, boolean hasFocus) {\n\t\t\t\tif (hasFocus) {\n\t\t\t\t\tgetWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\taddFooterView();\n\t\tamenityAdapter = new AmenityAdapter(new ArrayList<Amenity>());\n\t\tsetListAdapter(amenityAdapter);\n\t\t\n\t\t\n\t\t\n\t}","id":34911,"modified_method":"@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.searchpoi);\n\t\t\n\t\tgetSupportActionBar().setTitle(R.string.searchpoi_activity);\n\t\tgetSupportActionBar().setIcon(R.drawable.tab_search_poi_icon);\n\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\n\t\tapp = (OsmandApplication)getApplication();\n\t\t\n\t\tuiHandler = new Handler();\n\t\tsearchFilter = (EditText) findViewById(R.id.SearchFilter);\n\t\tsearchFilterLayout = findViewById(R.id.SearchFilterLayout);\n\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\t\n\t\tsearchFilter.addTextChangedListener(new TextWatcher(){\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif(!isNameFinderFilter() && !isSearchByNameFilter()){\n\t\t\t\t\tamenityAdapter.getFilter().filter(s);\n\t\t\t\t} else {\n\t\t\t\t\tif(searchPOILevel != null)  {\n\t\t\t\t\t\tsearchPOILevel.setEnabled(true);\n\t\t\t\t\t\tsearchPOILevel.setTitle(R.string.search_button);\n\t\t\t\t\t}\n\t\t\t\t\tsearchFooterButton.setEnabled(true);\n\t\t\t\t\tsearchFooterButton.setText(R.string.search_button);\n\t\t\t\t\t// Cancel current search request here?\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\t\t});\n\t\tsearchFilter.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onFocusChange(View v, boolean hasFocus) {\n\t\t\t\tif (hasFocus) {\n\t\t\t\t\tgetWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\taddFooterView();\n\t\tamenityAdapter = new AmenityAdapter(new ArrayList<Amenity>());\n\t\tsetListAdapter(amenityAdapter);\n\n\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\tDrawable arrowImage = getResources().getDrawable(R.drawable.ic_destination_arrow);\n\t\tif (light) {\n\t\t\tarrowImage.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t} else {\n\t\t\tarrowImage.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}","commit_id":"4a2f288d50a5d9dba8ae51831b7c2e57371b9924","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void updateLocationView(boolean useCenter, LatLon fromLoc, Float h,\n\t\t\t\t\t\t\t\t\t\t  ImageView arrow, int arrowResId, TextView txt, double toLat, double toLon,\n\t\t\t\t\t\t\t\t\t\t  int screenOrientation, OsmandApplication app, Context ctx, boolean paint) {\n\t\tfloat[] mes = new float[2];\n\t\tif (fromLoc != null) {\n\t\t\tLocation.distanceBetween(toLat, toLon, fromLoc.getLatitude(), fromLoc.getLongitude(), mes);\n\t\t}\n\t\tif (arrow != null) {\n\t\t\tif (!(arrow.getDrawable() instanceof DirectionDrawable)) {\n\t\t\t\tDirectionDrawable dd = new DirectionDrawable(ctx, 10, 10);\n\t\t\t\tarrow.setImageDrawable(dd);\n\t\t\t}\n\t\t\tif (arrowResId == 0) {\n\t\t\t\tarrowResId = R.drawable.ic_destination_arrow_white;\n\t\t\t}\n\t\t\tDirectionDrawable dd = (DirectionDrawable) arrow.getDrawable();\n\t\t\tif (paint) {\n\t\t\t\tdd.setImage(arrowResId, useCenter ? R.color.color_distance : R.color.color_myloc_distance);\n\t\t\t} else {\n\t\t\t\tdd.setImage(arrowResId, useCenter ? R.color.color_distance : R.color.color_white);\n\t\t\t}\n\t\t\tif (fromLoc == null || h == null) {\n\t\t\t\tdd.setAngle(0);\n\t\t\t} else {\n\t\t\t\tdd.setAngle(mes[1] - h + 180 + screenOrientation);\n\t\t\t}\n\t\t\tarrow.invalidate();\n\t\t}\n\t\tif (txt != null) {\n\t\t\tif (fromLoc != null) {\n\t\t\t\tif (paint) {\n\t\t\t\t\ttxt.setTextColor(app.getResources().getColor(\n\t\t\t\t\t\t\tuseCenter ? R.color.color_distance : R.color.color_myloc_distance));\n\t\t\t\t}\n\t\t\t\ttxt.setText(OsmAndFormatter.getFormattedDistance(mes[0], app));\n\t\t\t} else {\n\t\t\t\ttxt.setText(\"\");\n\t\t\t}\n\t\t}\n\t}","id":34912,"modified_method":"public static void updateLocationView(boolean useCenter, LatLon fromLoc, Float h,\n\t\t\t\t\t\t\t\t\t\t  ImageView arrow, int arrowResId, TextView txt, double toLat, double toLon,\n\t\t\t\t\t\t\t\t\t\t  int screenOrientation, OsmandApplication app, Context ctx, boolean paint) {\n\t\tfloat[] mes = new float[2];\n\t\tif (fromLoc != null) {\n\t\t\tLocation.distanceBetween(toLat, toLon, fromLoc.getLatitude(), fromLoc.getLongitude(), mes);\n\t\t}\n\t\tif (arrow != null) {\n\t\t\tif (!(arrow.getDrawable() instanceof DirectionDrawable)) {\n\t\t\t\tDirectionDrawable dd = new DirectionDrawable(ctx, 10, 10);\n\t\t\t\tarrow.setImageDrawable(dd);\n\t\t\t}\n\t\t\tif (arrowResId == 0) {\n\t\t\t\tarrowResId = R.drawable.ic_destination_arrow_white;\n\t\t\t}\n\t\t\tDirectionDrawable dd = (DirectionDrawable) arrow.getDrawable();\n\t\t\tdd.setImage(arrowResId, useCenter ? R.color.color_distance : R.color.color_myloc_distance);\n\t\t\tif (fromLoc == null || h == null) {\n\t\t\t\tdd.setAngle(0);\n\t\t\t} else {\n\t\t\t\tdd.setAngle(mes[1] - h + 180 + screenOrientation);\n\t\t\t}\n\t\t\tarrow.invalidate();\n\t\t}\n\t\tif (txt != null) {\n\t\t\tif (fromLoc != null) {\n\t\t\t\tif (paint) {\n\t\t\t\t\ttxt.setTextColor(app.getResources().getColor(\n\t\t\t\t\t\t\tuseCenter ? R.color.color_distance : R.color.color_myloc_distance));\n\t\t\t\t}\n\t\t\t\ttxt.setText(OsmAndFormatter.getFormattedDistance(mes[0], app));\n\t\t\t} else {\n\t\t\t\ttxt.setText(\"\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"d6cbfa18f869d0c49a293c75c40e1b37723191c6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void draw(Canvas canvas) {\n\t\tif (arrowImage != null) {\n\t\t\tcanvas.rotate(angle, canvas.getHeight() / 2, canvas.getWidth() / 2);\n\t\t\tarrowImage.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n\t\t\tarrowImage.draw(canvas);\n\t\t\t// TODO delete?\n//\t\t\tBitmap arrow = Bitmap.createBitmap(canvas.getWidth(), canvas.getHeight(), Bitmap.Config.ARGB_8888);\n//\t\t\tCanvas canv = new Canvas(arrow);\n//\t\t\tarrowImage.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n//\t\t\tarrowImage.draw(canv);\n//\t\t\tcanvas.drawBitmap(arrow, null, new Rect(0, 0, arrow.getHeight(), arrow.getWidth()), null);\n\t\t} else {\n\t\t\tcanvas.rotate(angle, canvas.getHeight()/2, canvas.getWidth() / 2);\n\t\t\tPath directionPath = createDirectionPath();\n\t\t\tcanvas.drawPath(directionPath, paintRouteDirection);\n\t\t}\n\t}","id":34913,"modified_method":"@Override\n\tpublic void draw(Canvas canvas) {\n\t\tcanvas.save();\n\t\t\n\t\tif (arrowImage != null) {\n\t\t\tint w = arrowImage.getIntrinsicWidth();\n\t\t\tint h = arrowImage.getIntrinsicHeight();\n\t\t\tint dx = canvas.getWidth() - w;\n\t\t\tint dy = canvas.getHeight() - h;\n\t\t\tarrowImage.setBounds(0, 0, w, h);\n\t\t\tcanvas.rotate(angle, canvas.getWidth() / 2, canvas.getHeight() / 2);\n\t\t\tcanvas.translate(dx/2, dy/2);\n\t\t\tarrowImage.draw(canvas);\n\t\t} else {\n\t\t\tcanvas.rotate(angle, canvas.getWidth() / 2, canvas.getHeight() / 2);\n\t\t\tPath directionPath = createDirectionPath();\n\t\t\tcanvas.drawPath(directionPath, paintRouteDirection);\n\t\t}\n\t\tcanvas.restore();\n\t}","commit_id":"d6cbfa18f869d0c49a293c75c40e1b37723191c6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n     * Returns an iterator of hosts to be used for a request call.\n     * Ideally, the first host is retrieved from the iterator and used successfully for the request.\n     * Otherwise, after each failure the next host should be retrieved from the iterator so that the request can be retried until\n     * the iterator is exhausted. The maximum total of attempts is equal to the number of hosts that are available in the iterator.\n     * The iterator returned will never be empty, rather an {@link IllegalStateException} in case there are no hosts.\n     * In case there are no healthy hosts available, or dead ones to be be retried, one dead host gets returned.\n     */\n    private Iterable<HttpHost> nextHost() {\n        Set<HttpHost> filteredHosts = new HashSet<>(hosts);\n        for (Map.Entry<HttpHost, DeadHostState> entry : blacklist.entrySet()) {\n            if (System.nanoTime() - entry.getValue().getDeadUntilNanos() < 0) {\n                filteredHosts.remove(entry.getKey());\n            }\n        }\n\n        if (filteredHosts.isEmpty()) {\n            //last resort: if there are no good hosts to use, return a single dead one, the one that's closest to being retried\n            List<Map.Entry<HttpHost, DeadHostState>> sortedHosts = new ArrayList<>(blacklist.entrySet());\n            Collections.sort(sortedHosts, new Comparator<Map.Entry<HttpHost, DeadHostState>>() {\n                @Override\n                public int compare(Map.Entry<HttpHost, DeadHostState> o1, Map.Entry<HttpHost, DeadHostState> o2) {\n                    return Long.compare(o1.getValue().getDeadUntilNanos(), o2.getValue().getDeadUntilNanos());\n                }\n            });\n            HttpHost deadHost = sortedHosts.get(0).getKey();\n            logger.trace(\"resurrecting host [\" + deadHost + \"]\");\n            return Collections.singleton(deadHost);\n        }\n\n        List<HttpHost> rotatedHosts = new ArrayList<>(filteredHosts);\n        Collections.rotate(rotatedHosts, rotatedHosts.size() - lastHostIndex.getAndIncrement());\n        return rotatedHosts;\n    }","id":34914,"modified_method":"/**\n     * Returns an iterator of hosts to be used for a request call.\n     * Ideally, the first host is retrieved from the iterator and used successfully for the request.\n     * Otherwise, after each failure the next host should be retrieved from the iterator so that the request can be retried until\n     * the iterator is exhausted. The maximum total of attempts is equal to the number of hosts that are available in the iterator.\n     * The iterator returned will never be empty, rather an {@link IllegalStateException} in case there are no hosts.\n     * In case there are no healthy hosts available, or dead ones to be be retried, one dead host gets returned.\n     */\n    private Iterable<HttpHost> nextHost() {\n        Collection<HttpHost> nextHosts = Collections.emptySet();\n        do {\n            Set<HttpHost> filteredHosts = new HashSet<>(hosts);\n            for (Map.Entry<HttpHost, DeadHostState> entry : blacklist.entrySet()) {\n                if (System.nanoTime() - entry.getValue().getDeadUntilNanos() < 0) {\n                    filteredHosts.remove(entry.getKey());\n                }\n            }\n            if (filteredHosts.isEmpty()) {\n                //last resort: if there are no good hosts to use, return a single dead one, the one that's closest to being retried\n                List<Map.Entry<HttpHost, DeadHostState>> sortedHosts = new ArrayList<>(blacklist.entrySet());\n                if (sortedHosts.size() > 0) {\n                    Collections.sort(sortedHosts, new Comparator<Map.Entry<HttpHost, DeadHostState>>() {\n                        @Override\n                        public int compare(Map.Entry<HttpHost, DeadHostState> o1, Map.Entry<HttpHost, DeadHostState> o2) {\n                            return Long.compare(o1.getValue().getDeadUntilNanos(), o2.getValue().getDeadUntilNanos());\n                        }\n                    });\n                    HttpHost deadHost = sortedHosts.get(0).getKey();\n                    logger.trace(\"resurrecting host [\" + deadHost + \"]\");\n                    nextHosts = Collections.singleton(deadHost);\n                }\n            } else {\n                List<HttpHost> rotatedHosts = new ArrayList<>(filteredHosts);\n                Collections.rotate(rotatedHosts, rotatedHosts.size() - lastHostIndex.getAndIncrement());\n                nextHosts = rotatedHosts;\n            }\n        } while(nextHosts.isEmpty());\n        return nextHosts;\n    }","commit_id":"46cb3f36ffa9b94353ed70c2c14b2a107d342f9e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n   * Return the name of the image file that is uploaded by periodic\n   * checkpointing\n   *\n   * @return List of filenames to save checkpoints to.\n   */\n  public File[] getFsImageNameCheckpoint(long txid) {\n    ArrayList<File> list = new ArrayList<File>();\n    for (Iterator<StorageDirectory> it =\n                 dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {\n      list.add(getStorageFile(it.next(), NameNodeFile.IMAGE_NEW, txid));\n    }\n    return list.toArray(new File[list.size()]);\n  }","id":34915,"modified_method":"/**\n   * Return the name of the image file that is uploaded by periodic\n   * checkpointing.\n   *\n   * @return List of filenames to save checkpoints to.\n   */\n  public File[] getFsImageNameCheckpoint(long txid) {\n    ArrayList<File> list = new ArrayList<>();\n    for (Iterator<StorageDirectory> it =\n                 dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {\n      list.add(getStorageFile(it.next(), NameNodeFile.IMAGE_NEW, txid));\n    }\n    return list.toArray(new File[list.size()]);\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Generate new blockpoolID.\n   * \n   * @return new blockpoolID\n   */ \n  static String newBlockPoolID() throws UnknownHostException{\n    String ip = \"unknownIP\";\n    try {\n      ip = DNS.getDefaultIP(\"default\");\n    } catch (UnknownHostException e) {\n      LOG.warn(\"Could not find ip address of \\\"default\\\" inteface.\");\n      throw e;\n    }\n    \n    int rand = DFSUtil.getSecureRandom().nextInt(Integer.MAX_VALUE);\n    String bpid = \"BP-\" + rand + \"-\"+ ip + \"-\" + Time.now();\n    return bpid;\n  }","id":34916,"modified_method":"/**\n   * Generate new blockpoolID.\n   * \n   * @return new blockpoolID\n   */ \n  static String newBlockPoolID() throws UnknownHostException{\n    String ip;\n    try {\n      ip = DNS.getDefaultIP(\"default\");\n    } catch (UnknownHostException e) {\n      LOG.warn(\"Could not find ip address of \\\"default\\\" inteface.\");\n      throw e;\n    }\n    \n    int rand = DFSUtil.getSecureRandom().nextInt(Integer.MAX_VALUE);\n    return \"BP-\" + rand + \"-\"+ ip + \"-\" + Time.now();\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Return the list of locations being used for a specific purpose.\n   * i.e. Image or edit log storage.\n   *\n   * @param dirType Purpose of locations requested.\n   * @throws IOException\n   */\n  Collection<URI> getDirectories(NameNodeDirType dirType)\n      throws IOException {\n    ArrayList<URI> list = new ArrayList<URI>();\n    Iterator<StorageDirectory> it = (dirType == null) ? dirIterator() :\n                                    dirIterator(dirType);\n    for ( ;it.hasNext(); ) {\n      StorageDirectory sd = it.next();\n      try {\n        list.add(Util.fileAsURI(sd.getRoot()));\n      } catch (IOException e) {\n        throw new IOException(\"Exception while processing \" +\n            \"StorageDirectory \" + sd.getRoot(), e);\n      }\n    }\n    return list;\n  }","id":34917,"modified_method":"/**\n   * Return the list of locations being used for a specific purpose.\n   * i.e. Image or edit log storage.\n   *\n   * @param dirType Purpose of locations requested.\n   * @throws IOException\n   */\n  Collection<URI> getDirectories(NameNodeDirType dirType)\n      throws IOException {\n    ArrayList<URI> list = new ArrayList<>();\n    Iterator<StorageDirectory> it = (dirType == null) ? dirIterator() :\n                                    dirIterator(dirType);\n    for ( ; it.hasNext();) {\n      StorageDirectory sd = it.next();\n      try {\n        list.add(Util.fileAsURI(sd.getRoot()));\n      } catch (IOException e) {\n        throw new IOException(\"Exception while processing \" +\n            \"StorageDirectory \" + sd.getRoot(), e);\n      }\n    }\n    return list;\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Return the storage directory corresponding to the passed URI\n   * @param uri URI of a storage directory\n   * @return The matching storage directory or null if none found\n   */\n  StorageDirectory getStorageDirectory(URI uri) {\n    try {\n      uri = Util.fileAsURI(new File(uri));\n      Iterator<StorageDirectory> it = dirIterator();\n      for (; it.hasNext(); ) {\n        StorageDirectory sd = it.next();\n        if (Util.fileAsURI(sd.getRoot()).equals(uri)) {\n          return sd;\n        }\n      }\n    } catch (IOException ioe) {\n      LOG.warn(\"Error converting file to URI\", ioe);\n    }\n    return null;\n  }","id":34918,"modified_method":"/**\n   * Return the storage directory corresponding to the passed URI.\n   * @param uri URI of a storage directory\n   * @return The matching storage directory or null if none found\n   */\n  StorageDirectory getStorageDirectory(URI uri) {\n    try {\n      uri = Util.fileAsURI(new File(uri));\n      Iterator<StorageDirectory> it = dirIterator();\n      while (it.hasNext()) {\n        StorageDirectory sd = it.next();\n        if (Util.fileAsURI(sd.getRoot()).equals(uri)) {\n          return sd;\n        }\n      }\n    } catch (IOException ioe) {\n      LOG.warn(\"Error converting file to URI\", ioe);\n    }\n    return null;\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Pull any properties out of the VERSION file that are from older\n   * versions of HDFS and only necessary during upgrade.\n   */\n  private void setDeprecatedPropertiesForUpgrade(Properties props) {\n    deprecatedProperties = new HashMap<String, String>();\n    String md5 = props.getProperty(DEPRECATED_MESSAGE_DIGEST_PROPERTY);\n    if (md5 != null) {\n      deprecatedProperties.put(DEPRECATED_MESSAGE_DIGEST_PROPERTY, md5);\n    }\n  }","id":34919,"modified_method":"/**\n   * Pull any properties out of the VERSION file that are from older\n   * versions of HDFS and only necessary during upgrade.\n   */\n  private void setDeprecatedPropertiesForUpgrade(Properties props) {\n    deprecatedProperties = new HashMap<>();\n    String md5 = props.getProperty(DEPRECATED_MESSAGE_DIGEST_PROPERTY);\n    if (md5 != null) {\n      deprecatedProperties.put(DEPRECATED_MESSAGE_DIGEST_PROPERTY, md5);\n    }\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * See if any of removed storages is \"writable\" again, and can be returned\n   * into service.\n   */\n  void attemptRestoreRemovedStorage() {\n    // if directory is \"alive\" - copy the images there...\n    if(!restoreFailedStorage || removedStorageDirs.size() == 0)\n      return; //nothing to restore\n\n    /* We don't want more than one thread trying to restore at a time */\n    synchronized (this.restorationLock) {\n      LOG.info(\"NNStorage.attemptRestoreRemovedStorage: check removed(failed) \"+\n               \"storarge. removedStorages size = \" + removedStorageDirs.size());\n      for(Iterator<StorageDirectory> it\n            = this.removedStorageDirs.iterator(); it.hasNext();) {\n        StorageDirectory sd = it.next();\n        File root = sd.getRoot();\n        LOG.info(\"currently disabled dir \" + root.getAbsolutePath() +\n                 \"; type=\"+sd.getStorageDirType() \n                 + \";canwrite=\"+FileUtil.canWrite(root));\n        if(root.exists() && FileUtil.canWrite(root)) {\n          LOG.info(\"restoring dir \" + sd.getRoot().getAbsolutePath());\n          this.addStorageDir(sd); // restore\n          this.removedStorageDirs.remove(sd);\n        }\n      }\n    }\n  }","id":34920,"modified_method":"/**\n   * See if any of removed storages is \"writable\" again, and can be returned\n   * into service.\n   */\n  void attemptRestoreRemovedStorage() {\n    // if directory is \"alive\" - copy the images there...\n    if(!restoreFailedStorage || removedStorageDirs.size() == 0) {\n      return; //nothing to restore\n    }\n    /* We don't want more than one thread trying to restore at a time */\n    synchronized (this.restorationLock) {\n      LOG.info(\"NNStorage.attemptRestoreRemovedStorage: check removed(failed) \"+\n               \"storarge. removedStorages size = \" + removedStorageDirs.size());\n      for (StorageDirectory sd : this.removedStorageDirs) {\n        File root = sd.getRoot();\n        LOG.info(\"currently disabled dir \" + root.getAbsolutePath() +\n            \"; type=\" + sd.getStorageDirType()\n            + \";canwrite=\" + FileUtil.canWrite(root));\n        if (root.exists() && FileUtil.canWrite(root)) {\n          LOG.info(\"restoring dir \" + sd.getRoot().getAbsolutePath());\n          this.addStorageDir(sd); // restore\n          this.removedStorageDirs.remove(sd);\n        }\n      }\n    }\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Iterate over all of the storage dirs, reading their contents to determine\n   * their layout versions. Returns an FSImageStorageInspector which has\n   * inspected each directory.\n   * \n   * <b>Note:<\/b> this can mutate the storage info fields (ctime, version, etc).\n   * @throws IOException if no valid storage dirs are found or no valid layout version\n   */\n  FSImageStorageInspector readAndInspectDirs(EnumSet<NameNodeFile> fileTypes,\n      StartupOption startupOption) throws IOException {\n    Integer layoutVersion = null;\n    boolean multipleLV = false;\n    StringBuilder layoutVersions = new StringBuilder();\n\n    // First determine what range of layout versions we're going to inspect\n    for (Iterator<StorageDirectory> it = dirIterator(false);\n         it.hasNext();) {\n      StorageDirectory sd = it.next();\n      if (!sd.getVersionFile().exists()) {\n        FSImage.LOG.warn(\"Storage directory \" + sd + \" contains no VERSION file. Skipping...\");\n        continue;\n      }\n      readProperties(sd, startupOption); // sets layoutVersion\n      int lv = getLayoutVersion();\n      if (layoutVersion == null) {\n        layoutVersion = Integer.valueOf(lv);\n      } else if (!layoutVersion.equals(lv)) {\n        multipleLV = true;\n      }\n      layoutVersions.append(\"(\").append(sd.getRoot()).append(\", \").append(lv).append(\") \");\n    }\n    \n    if (layoutVersion == null) {\n      throw new IOException(\"No storage directories contained VERSION information\");\n    }\n    if (multipleLV) {            \n      throw new IOException(\n          \"Storage directories contain multiple layout versions: \"\n              + layoutVersions);\n    }\n    // If the storage directories are with the new layout version\n    // (ie edits_<txnid>) then use the new inspector, which will ignore\n    // the old format dirs.\n    FSImageStorageInspector inspector;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      inspector = new FSImageTransactionalStorageInspector(fileTypes);\n    } else {\n      inspector = new FSImagePreTransactionalStorageInspector();\n    }\n    \n    inspectStorageDirs(inspector);\n    return inspector;\n  }","id":34921,"modified_method":"/**\n   * Iterate over all of the storage dirs, reading their contents to determine\n   * their layout versions. Returns an FSImageStorageInspector which has\n   * inspected each directory.\n   * \n   * <b>Note:<\/b> this can mutate the storage info fields (ctime, version, etc).\n   * @throws IOException if no valid storage dirs are found or no valid layout\n   * version\n   */\n  FSImageStorageInspector readAndInspectDirs(EnumSet<NameNodeFile> fileTypes,\n      StartupOption startupOption) throws IOException {\n    Integer layoutVersion = null;\n    boolean multipleLV = false;\n    StringBuilder layoutVersions = new StringBuilder();\n\n    // First determine what range of layout versions we're going to inspect\n    for (Iterator<StorageDirectory> it = dirIterator(false);\n         it.hasNext();) {\n      StorageDirectory sd = it.next();\n      if (!sd.getVersionFile().exists()) {\n        FSImage.LOG.warn(\"Storage directory \" + sd +\n            \" contains no VERSION file. Skipping...\");\n        continue;\n      }\n      readProperties(sd, startupOption); // sets layoutVersion\n      int lv = getLayoutVersion();\n      if (layoutVersion == null) {\n        layoutVersion = lv;\n      } else if (!layoutVersion.equals(lv)) {\n        multipleLV = true;\n      }\n      layoutVersions.append(\"(\").append(sd.getRoot()).append(\", \").append(lv)\n          .append(\") \");\n    }\n    \n    if (layoutVersion == null) {\n      throw new IOException(\"No storage directories contained VERSION\" +\n          \" information\");\n    }\n    if (multipleLV) {            \n      throw new IOException(\n          \"Storage directories contain multiple layout versions: \"\n              + layoutVersions);\n    }\n    // If the storage directories are with the new layout version\n    // (ie edits_<txnid>) then use the new inspector, which will ignore\n    // the old format dirs.\n    FSImageStorageInspector inspector;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      inspector = new FSImageTransactionalStorageInspector(fileTypes);\n    } else {\n      inspector = new FSImagePreTransactionalStorageInspector();\n    }\n    \n    inspectStorageDirs(inspector);\n    return inspector;\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Construct the NNStorage.\n   * @param conf Namenode configuration.\n   * @param imageDirs Directories the image can be stored in.\n   * @param editsDirs Directories the editlog can be stored in.\n   * @throws IOException if any directories are inaccessible.\n   */\n  public NNStorage(Configuration conf, \n                   Collection<URI> imageDirs, Collection<URI> editsDirs) \n      throws IOException {\n    super(NodeType.NAME_NODE);\n\n    storageDirs = new CopyOnWriteArrayList<StorageDirectory>();\n    \n    // this may modify the editsDirs, so copy before passing in\n    setStorageDirectories(imageDirs, \n                          Lists.newArrayList(editsDirs),\n                          FSNamesystem.getSharedEditsDirs(conf));\n    //Update NameDirSize metric value after NN start\n    updateNameDirSize();\n  }","id":34922,"modified_method":"/**\n   * Construct the NNStorage.\n   * @param conf Namenode configuration.\n   * @param imageDirs Directories the image can be stored in.\n   * @param editsDirs Directories the editlog can be stored in.\n   * @throws IOException if any directories are inaccessible.\n   */\n  public NNStorage(Configuration conf, \n                   Collection<URI> imageDirs, Collection<URI> editsDirs) \n      throws IOException {\n    super(NodeType.NAME_NODE);\n\n    storageDirs = new CopyOnWriteArrayList<>();\n    \n    // this may modify the editsDirs, so copy before passing in\n    setStorageDirectories(imageDirs, \n                          Lists.newArrayList(editsDirs),\n                          FSNamesystem.getSharedEditsDirs(conf));\n    //Update NameDirSize metric value after NN start\n    updateNameDirSize();\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * See {@link NNStorage#setStorageDirectories(Collection, Collection, Collection)}\n   */\n  @VisibleForTesting\n  synchronized void setStorageDirectories(Collection<URI> fsNameDirs,\n                                          Collection<URI> fsEditsDirs)\n      throws IOException {\n    setStorageDirectories(fsNameDirs, fsEditsDirs, new ArrayList<URI>());\n  }","id":34923,"modified_method":"/**\n   * See {@link NNStorage#setStorageDirectories(Collection, Collection, Collection)}.\n   */\n  @VisibleForTesting\n  synchronized void setStorageDirectories(Collection<URI> fsNameDirs,\n                                          Collection<URI> fsEditsDirs)\n      throws IOException {\n    setStorageDirectories(fsNameDirs, fsEditsDirs, new ArrayList<>());\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * try to find current cluster id in the VERSION files\n   * returns first cluster id found in any VERSION file\n   * null in case none found\n   * @return clusterId or null in case no cluster id found\n   */\n  public String determineClusterId() {\n    String cid = null;\n    Iterator<StorageDirectory> sdit = dirIterator(NameNodeDirType.IMAGE);\n    while(sdit.hasNext()) {\n      StorageDirectory sd = sdit.next();\n      try {\n        Properties props = readPropertiesFile(sd.getVersionFile());\n        cid = props.getProperty(\"clusterID\");\n        LOG.info(\"current cluster id for sd=\"+sd.getCurrentDir() + \n            \";lv=\" + layoutVersion + \";cid=\" + cid);\n        \n        if(cid != null && !cid.equals(\"\"))\n          return cid;\n      } catch (Exception e) {\n        LOG.warn(\"this sd not available: \" + e.getLocalizedMessage());\n      } //ignore\n    }\n    LOG.warn(\"couldn't find any VERSION file containing valid ClusterId\");\n    return null;\n  }","id":34924,"modified_method":"/**\n   * Try to find current cluster id in the VERSION files.\n   * returns first cluster id found in any VERSION file\n   * null in case none found\n   * @return clusterId or null in case no cluster id found\n   */\n  public String determineClusterId() {\n    String cid;\n    Iterator<StorageDirectory> sdit = dirIterator(NameNodeDirType.IMAGE);\n    while(sdit.hasNext()) {\n      StorageDirectory sd = sdit.next();\n      try {\n        Properties props = readPropertiesFile(sd.getVersionFile());\n        cid = props.getProperty(\"clusterID\");\n        LOG.info(\"current cluster id for sd=\"+sd.getCurrentDir() + \n            \";lv=\" + layoutVersion + \";cid=\" + cid);\n        \n        if(cid != null && !cid.equals(\"\")) {\n          return cid;\n        }\n      } catch (Exception e) {\n        LOG.warn(\"this sd not available: \" + e.getLocalizedMessage());\n      } //ignore\n    }\n    LOG.warn(\"couldn't find any VERSION file containing valid ClusterId\");\n    return null;\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"@Test (timeout=30000)\n  public void testSaveNamespaceWithDanglingLease() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new Configuration())\n        .numDataNodes(1).build();\n    cluster.waitActive();\n    DistributedFileSystem fs = cluster.getFileSystem();\n    try {\n      cluster.getNamesystem().leaseManager.addLease(\"me\",\n              INodeId.ROOT_INODE_ID + 1);\n      fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      cluster.getNameNodeRpc().saveNamespace(0, 0);\n      fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);\n    } finally {\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n    }\n  }","id":34925,"modified_method":"@Test (timeout=30000)\n  public void testSaveNamespaceWithDanglingLease() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new Configuration())\n        .numDataNodes(1).build();\n    cluster.waitActive();\n    DistributedFileSystem fs = cluster.getFileSystem();\n    try {\n      cluster.getNamesystem().leaseManager.addLease(\"me\",\n              INodeId.ROOT_INODE_ID + 1);\n      fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      cluster.getNameNodeRpc().saveNamespace(0, 0);\n      fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);\n    } finally {\n      cluster.shutdown();\n    }\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Injects a failure on all storage directories while saving namespace.\n   *\n   * @param restoreStorageAfterFailure if true, will try to save again after\n   *   clearing the failure injection\n   */\n  public void doTestFailedSaveNamespace(boolean restoreStorageAfterFailure)\n  throws Exception {\n    Configuration conf = getConf();\n    NameNode.initMetrics(conf, NamenodeRole.NAMENODE);\n    DFSTestUtil.formatNameNode(conf);\n    FSNamesystem fsn = FSNamesystem.loadFromDisk(conf);\n\n    // Replace the FSImage with a spy\n    final FSImage originalImage = fsn.getFSImage();\n    NNStorage storage = originalImage.getStorage();\n    storage.close(); // unlock any directories that FSNamesystem's initialization may have locked\n\n    NNStorage spyStorage = spy(storage);\n    originalImage.storage = spyStorage;\n    FSImage spyImage = spy(originalImage);\n    Whitebox.setInternalState(fsn, \"fsImage\", spyImage);\n\n    spyImage.storage.setStorageDirectories(\n        FSNamesystem.getNamespaceDirs(conf), \n        FSNamesystem.getNamespaceEditsDirs(conf));\n\n    doThrow(new IOException(\"Injected fault: saveFSImage\")).\n        when(spyImage).saveFSImage(\n            (SaveNamespaceContext)anyObject(),\n            (StorageDirectory)anyObject(), (NameNodeFile) anyObject());\n\n    try {\n      doAnEdit(fsn, 1);\n\n      // Save namespace\n      fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      try {\n        fsn.saveNamespace(0, 0);\n        fail(\"saveNamespace did not fail even when all directories failed!\");\n      } catch (IOException ioe) {\n        LOG.info(\"Got expected exception\", ioe);\n      }\n      \n      // Ensure that, if storage dirs come back online, things work again.\n      if (restoreStorageAfterFailure) {\n        Mockito.reset(spyImage);\n        spyStorage.setRestoreFailedStorage(true);\n        fsn.saveNamespace(0, 0);\n        checkEditExists(fsn, 1);\n      }\n\n      // Now shut down and restart the NN\n      originalImage.close();\n      fsn.close();\n      fsn = null;\n\n      // Start a new namesystem, which should be able to recover\n      // the namespace from the previous incarnation.\n      fsn = FSNamesystem.loadFromDisk(conf);\n\n      // Make sure the image loaded including our edits.\n      checkEditExists(fsn, 1);\n    } finally {\n      if (fsn != null) {\n        fsn.close();\n      }\n    }\n  }","id":34926,"modified_method":"/**\n   * Injects a failure on all storage directories while saving namespace.\n   *\n   * @param restoreStorageAfterFailure if true, will try to save again after\n   *   clearing the failure injection\n   */\n  public void doTestFailedSaveNamespace(boolean restoreStorageAfterFailure)\n  throws Exception {\n    Configuration conf = getConf();\n    NameNode.initMetrics(conf, NamenodeRole.NAMENODE);\n    DFSTestUtil.formatNameNode(conf);\n    FSNamesystem fsn = FSNamesystem.loadFromDisk(conf);\n\n    // Replace the FSImage with a spy\n    final FSImage originalImage = fsn.getFSImage();\n    NNStorage storage = originalImage.getStorage();\n    // unlock any directories that\n    // FSNamesystem's initialization may have locked\n    storage.close();\n\n    NNStorage spyStorage = spy(storage);\n    originalImage.storage = spyStorage;\n    FSImage spyImage = spy(originalImage);\n    Whitebox.setInternalState(fsn, \"fsImage\", spyImage);\n\n    spyImage.storage.setStorageDirectories(FSNamesystem.getNamespaceDirs(conf),\n        FSNamesystem.getNamespaceEditsDirs(conf));\n\n    doThrow(new IOException(\"Injected fault: saveFSImage\")).\n        when(spyImage).saveFSImage(anyObject(), anyObject(), anyObject());\n\n    try {\n      doAnEdit(fsn, 1);\n\n      // Save namespace\n      fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      try {\n        fsn.saveNamespace(0, 0);\n        fail(\"saveNamespace did not fail even when all directories failed!\");\n      } catch (IOException ioe) {\n        LOG.info(\"Got expected exception\", ioe);\n      }\n      \n      // Ensure that, if storage dirs come back online, things work again.\n      if (restoreStorageAfterFailure) {\n        Mockito.reset(spyImage);\n        spyStorage.setRestoreFailedStorage(true);\n        fsn.saveNamespace(0, 0);\n        checkEditExists(fsn, 1);\n      }\n\n      // Now shut down and restart the NN\n      originalImage.close();\n      fsn.close();\n      fsn = null;\n\n      // Start a new namesystem, which should be able to recover\n      // the namespace from the previous incarnation.\n      fsn = FSNamesystem.loadFromDisk(conf);\n\n      // Make sure the image loaded including our edits.\n      checkEditExists(fsn, 1);\n    } finally {\n      if (fsn != null) {\n        fsn.close();\n      }\n    }\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"private void saveNamespaceWithInjectedFault(Fault fault) throws Exception {\n    Configuration conf = getConf();\n    NameNode.initMetrics(conf, NamenodeRole.NAMENODE);\n    DFSTestUtil.formatNameNode(conf);\n    FSNamesystem fsn = FSNamesystem.loadFromDisk(conf);\n\n    // Replace the FSImage with a spy\n    FSImage originalImage = fsn.getFSImage();\n    NNStorage storage = originalImage.getStorage();\n\n    NNStorage spyStorage = spy(storage);\n    originalImage.storage = spyStorage;\n\n    FSImage spyImage = spy(originalImage);\n    Whitebox.setInternalState(fsn, \"fsImage\", spyImage);\n\n    boolean shouldFail = false; // should we expect the save operation to fail\n    // inject fault\n    switch(fault) {\n    case SAVE_SECOND_FSIMAGE_RTE:\n      // The spy throws a RuntimeException when writing to the second directory\n      doAnswer(new FaultySaveImage(true)).\n        when(spyImage).saveFSImage(\n            (SaveNamespaceContext)anyObject(),\n            (StorageDirectory)anyObject(), (NameNodeFile) anyObject());\n      shouldFail = false;\n      break;\n    case SAVE_SECOND_FSIMAGE_IOE:\n      // The spy throws an IOException when writing to the second directory\n      doAnswer(new FaultySaveImage(false)).\n        when(spyImage).saveFSImage(\n            (SaveNamespaceContext)anyObject(),\n            (StorageDirectory)anyObject(), (NameNodeFile) anyObject());\n      shouldFail = false;\n      break;\n    case SAVE_ALL_FSIMAGES:\n      // The spy throws IOException in all directories\n      doThrow(new RuntimeException(\"Injected\")).\n      when(spyImage).saveFSImage(\n          (SaveNamespaceContext)anyObject(),\n          (StorageDirectory)anyObject(), (NameNodeFile) anyObject());\n      shouldFail = true;\n      break;\n    case WRITE_STORAGE_ALL:\n      // The spy throws an exception before writing any VERSION files\n      doAnswer(new FaultyWriteProperties(Fault.WRITE_STORAGE_ALL))\n          .when(spyStorage).writeProperties((StorageDirectory)anyObject());\n      shouldFail = true;\n      break;\n    case WRITE_STORAGE_ONE:\n      // The spy throws on exception on one particular storage directory\n      doAnswer(new FaultyWriteProperties(Fault.WRITE_STORAGE_ONE))\n        .when(spyStorage).writeProperties((StorageDirectory)anyObject());\n      shouldFail = false;\n      break;\n    }\n\n    try {\n      doAnEdit(fsn, 1);\n\n      // Save namespace - this may fail, depending on fault injected\n      fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      try {\n        fsn.saveNamespace(0, 0);\n        if (shouldFail) {\n          fail(\"Did not fail!\");\n        }\n      } catch (Exception e) {\n        if (! shouldFail) {\n          throw e;\n        } else {\n          LOG.info(\"Test caught expected exception\", e);\n        }\n      }\n      \n      fsn.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);\n      // Should still be able to perform edits\n      doAnEdit(fsn, 2);\n\n      // Now shut down and restart the namesystem\n      originalImage.close();\n      fsn.close();      \n      fsn = null;\n\n      // Start a new namesystem, which should be able to recover\n      // the namespace from the previous incarnation.\n      fsn = FSNamesystem.loadFromDisk(conf);\n\n      // Make sure the image loaded including our edits.\n      checkEditExists(fsn, 1);\n      checkEditExists(fsn, 2);\n    } finally {\n      if (fsn != null) {\n        fsn.close();\n      }\n    }\n  }","id":34927,"modified_method":"private void saveNamespaceWithInjectedFault(Fault fault) throws Exception {\n    Configuration conf = getConf();\n    NameNode.initMetrics(conf, NamenodeRole.NAMENODE);\n    DFSTestUtil.formatNameNode(conf);\n    FSNamesystem fsn = FSNamesystem.loadFromDisk(conf);\n\n    // Replace the FSImage with a spy\n    FSImage originalImage = fsn.getFSImage();\n    NNStorage storage = originalImage.getStorage();\n\n    NNStorage spyStorage = spy(storage);\n    originalImage.storage = spyStorage;\n\n    FSImage spyImage = spy(originalImage);\n    Whitebox.setInternalState(fsn, \"fsImage\", spyImage);\n\n    boolean shouldFail = false; // should we expect the save operation to fail\n    // inject fault\n    switch(fault) {\n    case SAVE_SECOND_FSIMAGE_RTE:\n      // The spy throws a RuntimeException when writing to the second directory\n      doAnswer(new FaultySaveImage(true)).\n          when(spyImage).saveFSImage(\n          anyObject(),\n          anyObject(), anyObject());\n      shouldFail = false;\n      break;\n    case SAVE_SECOND_FSIMAGE_IOE:\n      // The spy throws an IOException when writing to the second directory\n      doAnswer(new FaultySaveImage(false)).\n          when(spyImage).saveFSImage(\n          anyObject(),\n          anyObject(), anyObject());\n      shouldFail = false;\n      break;\n    case SAVE_ALL_FSIMAGES:\n      // The spy throws IOException in all directories\n      doThrow(new RuntimeException(\"Injected\")).\n          when(spyImage).saveFSImage(\n          anyObject(),\n          anyObject(), anyObject());\n      shouldFail = true;\n      break;\n    case WRITE_STORAGE_ALL:\n      // The spy throws an exception before writing any VERSION files\n      doAnswer(new FaultyWriteProperties(Fault.WRITE_STORAGE_ALL))\n          .when(spyStorage).writeProperties(anyObject());\n      shouldFail = true;\n      break;\n    case WRITE_STORAGE_ONE:\n      // The spy throws on exception on one particular storage directory\n      doAnswer(new FaultyWriteProperties(Fault.WRITE_STORAGE_ONE))\n        .when(spyStorage).writeProperties(anyObject());\n      shouldFail = false;\n      break;\n    default: fail(\"Unknown fail type\");\n      break;\n    }\n\n    try {\n      doAnEdit(fsn, 1);\n\n      // Save namespace - this may fail, depending on fault injected\n      fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      try {\n        fsn.saveNamespace(0, 0);\n        if (shouldFail) {\n          fail(\"Did not fail!\");\n        }\n      } catch (Exception e) {\n        if (!shouldFail) {\n          throw e;\n        } else {\n          LOG.info(\"Test caught expected exception\", e);\n        }\n      }\n      \n      fsn.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);\n      // Should still be able to perform edits\n      doAnEdit(fsn, 2);\n\n      // Now shut down and restart the namesystem\n      originalImage.close();\n      fsn.close();      \n      fsn = null;\n\n      // Start a new namesystem, which should be able to recover\n      // the namespace from the previous incarnation.\n      fsn = FSNamesystem.loadFromDisk(conf);\n\n      // Make sure the image loaded including our edits.\n      checkEditExists(fsn, 1);\n      checkEditExists(fsn, 2);\n    } finally {\n      if (fsn != null) {\n        fsn.close();\n      }\n    }\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Test for save namespace should succeed when parent directory renamed with\n   * open lease and destination directory exist. \n   * This test is a regression for HDFS-2827\n   */\n  @Test (timeout=30000)\n  public void testSaveNamespaceWithRenamedLease() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new Configuration())\n        .numDataNodes(1).build();\n    cluster.waitActive();\n    DistributedFileSystem fs = cluster.getFileSystem();\n    OutputStream out = null;\n    try {\n      fs.mkdirs(new Path(\"/test-target\"));\n      out = fs.create(new Path(\"/test-source/foo\")); // don't close\n      fs.rename(new Path(\"/test-source/\"), new Path(\"/test-target/\"));\n\n      fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      cluster.getNameNodeRpc().saveNamespace(0, 0);\n      fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);\n    } finally {\n      IOUtils.cleanup(LOG, out, fs);\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n    }\n  }","id":34928,"modified_method":"/**\n   * Test for save namespace should succeed when parent directory renamed with\n   * open lease and destination directory exist. \n   * This test is a regression for HDFS-2827\n   */\n  @Test (timeout=30000)\n  public void testSaveNamespaceWithRenamedLease() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(new Configuration())\n        .numDataNodes(1).build();\n    cluster.waitActive();\n    DistributedFileSystem fs = cluster.getFileSystem();\n    OutputStream out = null;\n    try {\n      fs.mkdirs(new Path(\"/test-target\"));\n      out = fs.create(new Path(\"/test-source/foo\")); // don't close\n      fs.rename(new Path(\"/test-source/\"), new Path(\"/test-target/\"));\n\n      fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);\n      cluster.getNameNodeRpc().saveNamespace(0, 0);\n      fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);\n    } finally {\n      IOUtils.cleanup(LOG, out, fs);\n      cluster.shutdown();\n    }\n  }","commit_id":"38128baff40ee137376968f025e75827a4227ee7","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n\t * Returns {@code true} if the parameter is annotated with {@link ModelAttribute}\n\t * or in default resolution mode, and also if it is not a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.annotationNotRequired) {\n\t\t\treturn !BeanUtils.isSimpleProperty(parameter.getParameterType());\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":34929,"modified_method":"/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or if it is a non-simple type when {@code annotationNotRequired=true}.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\tif (returnType.getMethodAnnotation(ModelAttribute.class) != null) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.annotationNotRequired) {\n\t\t\treturn !BeanUtils.isSimpleProperty(returnType.getParameterType());\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":34930,"modified_method":"/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.getMethodAnnotation(ModelAttribute.class) != null ||\n\t\t\t\tthis.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType()));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resovleArgumentFromModel() throws Exception {\n\t\tgetAttributeFromModel(\"attrName\", paramNamedValidModelAttr);\n\t\tgetAttributeFromModel(\"testBean\", paramModelAttr);\n\t\tgetAttributeFromModel(\"testBean\", paramNonSimpleType);\n\t}","id":34931,"modified_method":"@Test\n\tpublic void resolveArgumentFromModel() throws Exception {\n\t\ttestGetAttributeFromModel(\"attrName\", this.paramNamedValidModelAttr);\n\t\ttestGetAttributeFromModel(\"testBean\", this.paramModelAttr);\n\t\ttestGetAttributeFromModel(\"testBean\", this.paramNonSimpleType);\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tprocessor = new ModelAttributeMethodProcessor(false);\n\n\t\tMethod method = ModelAttributeHandler.class.getDeclaredMethod(\"modelAttribute\",\n\t\t\t\tTestBean.class, Errors.class, int.class, TestBean.class, TestBean.class);\n\n\t\tparamNamedValidModelAttr = new MethodParameter(method, 0);\n\t\tparamErrors = new MethodParameter(method, 1);\n\t\tparamInt = new MethodParameter(method, 2);\n\t\tparamModelAttr = new MethodParameter(method, 3);\n\t\tparamNonSimpleType = new MethodParameter(method, 4);\n\n\t\treturnParamNamedModelAttr = new MethodParameter(getClass().getDeclaredMethod(\"annotatedReturnValue\"), -1);\n\t\treturnParamNonSimpleType = new MethodParameter(getClass().getDeclaredMethod(\"notAnnotatedReturnValue\"), -1);\n\n\t\tmavContainer = new ModelAndViewContainer();\n\n\t\twebRequest = new ServletWebRequest(new MockHttpServletRequest());\n\t}","id":34932,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.request = new ServletWebRequest(new MockHttpServletRequest());\n\t\tthis.container = new ModelAndViewContainer();\n\t\tthis.processor = new ModelAttributeMethodProcessor(false);\n\n\t\tMethod method = ModelAttributeHandler.class.getDeclaredMethod(\"modelAttribute\",\n\t\t\t\tTestBean.class, Errors.class, int.class, TestBean.class, TestBean.class);\n\n\t\tthis.paramNamedValidModelAttr = new SynthesizingMethodParameter(method, 0);\n\t\tthis.paramErrors = new SynthesizingMethodParameter(method, 1);\n\t\tthis.paramInt = new SynthesizingMethodParameter(method, 2);\n\t\tthis.paramModelAttr = new SynthesizingMethodParameter(method, 3);\n\t\tthis.paramNonSimpleType = new SynthesizingMethodParameter(method, 4);\n\n\t\tmethod = getClass().getDeclaredMethod(\"annotatedReturnValue\");\n\t\tthis.returnParamNamedModelAttr = new MethodParameter(method, -1);\n\n\t\tmethod = getClass().getDeclaredMethod(\"notAnnotatedReturnValue\");\n\t\tthis.returnParamNonSimpleType = new MethodParameter(method, -1);\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test  // SPR-9378\n\tpublic void resolveArgumentOrdering() throws Exception {\n\t\tString name = \"testBean\";\n\t\tObject testBean = new TestBean(name);\n\t\tmavContainer.addAttribute(name, testBean);\n\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, testBean);\n\n\t\tObject anotherTestBean = new TestBean();\n\t\tmavContainer.addAttribute(\"anotherTestBean\", anotherTestBean);\n\n\t\tStubRequestDataBinder dataBinder = new StubRequestDataBinder(testBean, name);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(webRequest, testBean, name)).willReturn(dataBinder);\n\n\t\tprocessor.resolveArgument(paramModelAttr, mavContainer, webRequest, binderFactory);\n\n\t\tassertSame(\"Resolved attribute should be updated to be last in the order\",\n\t\t\t\ttestBean, mavContainer.getModel().values().toArray()[1]);\n\t\tassertSame(\"BindingResult of resolved attribute should be last in the order\",\n\t\t\t\tdataBinder.getBindingResult(), mavContainer.getModel().values().toArray()[2]);\n\t}","id":34933,"modified_method":"@Test  // SPR-9378\n\tpublic void resolveArgumentOrdering() throws Exception {\n\t\tString name = \"testBean\";\n\t\tObject testBean = new TestBean(name);\n\t\tthis.container.addAttribute(name, testBean);\n\t\tthis.container.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, testBean);\n\n\t\tObject anotherTestBean = new TestBean();\n\t\tthis.container.addAttribute(\"anotherTestBean\", anotherTestBean);\n\n\t\tStubRequestDataBinder dataBinder = new StubRequestDataBinder(testBean, name);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.request, testBean, name)).willReturn(dataBinder);\n\n\t\tthis.processor.resolveArgument(this.paramModelAttr, this.container, this.request, binderFactory);\n\n\t\tObject[] values = this.container.getModel().values().toArray();\n\t\tassertSame(\"Resolved attribute should be updated to be last\", testBean, values[1]);\n\t\tassertSame(\"BindingResult of resolved attr should be last\", dataBinder.getBindingResult(), values[2]);\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supportedReturnTypesInDefaultResolutionMode() throws Exception {\n\t\tprocessor = new ModelAttributeMethodProcessor(true);\n\t\tassertTrue(processor.supportsReturnType(returnParamNamedModelAttr));\n\t\tassertTrue(processor.supportsReturnType(returnParamNonSimpleType));\n\t}","id":34934,"modified_method":"@Test\n\tpublic void supportedReturnTypesInDefaultResolutionMode() throws Exception {\n\t\tprocessor = new ModelAttributeMethodProcessor(true);\n\t\tassertTrue(this.processor.supportsReturnType(returnParamNamedModelAttr));\n\t\tassertTrue(this.processor.supportsReturnType(returnParamNonSimpleType));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resovleArgumentViaDefaultConstructor() throws Exception {\n\t\tWebDataBinder dataBinder = new WebRequestDataBinder(null);\n\n\t\tWebDataBinderFactory factory = mock(WebDataBinderFactory.class);\n\t\tgiven(factory.createBinder((NativeWebRequest) anyObject(), notNull(), eq(\"attrName\"))).willReturn(dataBinder);\n\n\t\tprocessor.resolveArgument(paramNamedValidModelAttr, mavContainer, webRequest, factory);\n\n\t\tverify(factory).createBinder((NativeWebRequest) anyObject(), notNull(), eq(\"attrName\"));\n\t}","id":34935,"modified_method":"@Test\n\tpublic void resovleArgumentViaDefaultConstructor() throws Exception {\n\t\tWebDataBinder dataBinder = new WebRequestDataBinder(null);\n\t\tWebDataBinderFactory factory = mock(WebDataBinderFactory.class);\n\t\tgiven(factory.createBinder(anyObject(), notNull(), eq(\"attrName\"))).willReturn(dataBinder);\n\n\t\tthis.processor.resolveArgument(this.paramNamedValidModelAttr, this.container, this.request, factory);\n\t\tverify(factory).createBinder(anyObject(), notNull(), eq(\"attrName\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void bindExceptionRequired() throws Exception {\n\t\tassertTrue(processor.isBindExceptionRequired(null, paramNonSimpleType));\n\t}","id":34936,"modified_method":"@Test\n\tpublic void bindExceptionRequired() throws Exception {\n\t\tassertTrue(this.processor.isBindExceptionRequired(null, this.paramNonSimpleType));\n\t\tassertFalse(this.processor.isBindExceptionRequired(null, this.paramNamedValidModelAttr));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supportedParameters() throws Exception {\n\t\t// Only @ModelAttribute arguments\n\t\tassertTrue(processor.supportsParameter(paramNamedValidModelAttr));\n\t\tassertTrue(processor.supportsParameter(paramModelAttr));\n\n\t\tassertFalse(processor.supportsParameter(paramErrors));\n\t\tassertFalse(processor.supportsParameter(paramInt));\n\t\tassertFalse(processor.supportsParameter(paramNonSimpleType));\n\t}","id":34937,"modified_method":"@Test\n\tpublic void supportedParameters() throws Exception {\n\t\tassertTrue(this.processor.supportsParameter(this.paramNamedValidModelAttr));\n\t\tassertTrue(this.processor.supportsParameter(this.paramModelAttr));\n\n\t\tassertFalse(this.processor.supportsParameter(this.paramErrors));\n\t\tassertFalse(this.processor.supportsParameter(this.paramInt));\n\t\tassertFalse(this.processor.supportsParameter(this.paramNonSimpleType));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supportedParametersInDefaultResolutionMode() throws Exception {\n\t\tprocessor = new ModelAttributeMethodProcessor(true);\n\n\t\t// Only non-simple types, even if not annotated\n\t\tassertTrue(processor.supportsParameter(paramNamedValidModelAttr));\n\t\tassertTrue(processor.supportsParameter(paramErrors));\n\t\tassertTrue(processor.supportsParameter(paramModelAttr));\n\t\tassertTrue(processor.supportsParameter(paramNonSimpleType));\n\n\t\tassertFalse(processor.supportsParameter(paramInt));\n\t}","id":34938,"modified_method":"@Test\n\tpublic void supportedParametersInDefaultResolutionMode() throws Exception {\n\t\tprocessor = new ModelAttributeMethodProcessor(true);\n\n\t\t// Only non-simple types, even if not annotated\n\t\tassertTrue(this.processor.supportsParameter(this.paramNamedValidModelAttr));\n\t\tassertTrue(this.processor.supportsParameter(this.paramErrors));\n\t\tassertTrue(this.processor.supportsParameter(this.paramModelAttr));\n\t\tassertTrue(this.processor.supportsParameter(this.paramNonSimpleType));\n\n\t\tassertFalse(this.processor.supportsParameter(this.paramInt));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveArgumentValidation() throws Exception {\n\t\tString name = \"attrName\";\n\t\tObject target = new TestBean();\n\t\tmavContainer.addAttribute(name, target);\n\n\t\tStubRequestDataBinder dataBinder = new StubRequestDataBinder(target, name);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(webRequest, target, name)).willReturn(dataBinder);\n\n\t\tprocessor.resolveArgument(paramNamedValidModelAttr, mavContainer, webRequest, binderFactory);\n\n\t\tassertTrue(dataBinder.isBindInvoked());\n\t\tassertTrue(dataBinder.isValidateInvoked());\n\t}","id":34939,"modified_method":"@Test\n\tpublic void resolveArgumentValidation() throws Exception {\n\t\tString name = \"attrName\";\n\t\tObject target = new TestBean();\n\t\tthis.container.addAttribute(name, target);\n\n\t\tStubRequestDataBinder dataBinder = new StubRequestDataBinder(target, name);\n\t\tWebDataBinderFactory factory = mock(WebDataBinderFactory.class);\n\t\tgiven(factory.createBinder(this.request, target, name)).willReturn(dataBinder);\n\n\t\tthis.processor.resolveArgument(this.paramNamedValidModelAttr, this.container, this.request, factory);\n\n\t\tassertTrue(dataBinder.isBindInvoked());\n\t\tassertTrue(dataBinder.isValidateInvoked());\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supportedReturnTypes() throws Exception {\n\t\tprocessor = new ModelAttributeMethodProcessor(false);\n\t\tassertTrue(processor.supportsReturnType(returnParamNamedModelAttr));\n\t\tassertFalse(processor.supportsReturnType(returnParamNonSimpleType));\n\t}","id":34940,"modified_method":"@Test\n\tpublic void supportedReturnTypes() throws Exception {\n\t\tprocessor = new ModelAttributeMethodProcessor(false);\n\t\tassertTrue(this.processor.supportsReturnType(returnParamNamedModelAttr));\n\t\tassertFalse(this.processor.supportsReturnType(returnParamNonSimpleType));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleAnnotatedReturnValue() throws Exception {\n\t\tprocessor.handleReturnValue(\"expected\", returnParamNamedModelAttr, mavContainer, webRequest);\n\t\tassertEquals(\"expected\", mavContainer.getModel().get(\"modelAttrName\"));\n\t}","id":34941,"modified_method":"@Test\n\tpublic void handleAnnotatedReturnValue() throws Exception {\n\t\tthis.processor.handleReturnValue(\"expected\", this.returnParamNamedModelAttr, this.container, this.request);\n\t\tassertEquals(\"expected\", this.container.getModel().get(\"modelAttrName\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleNotAnnotatedReturnValue() throws Exception {\n\t\tTestBean testBean = new TestBean(\"expected\");\n\t\tprocessor.handleReturnValue(testBean, returnParamNonSimpleType, mavContainer, webRequest);\n\n\t\tassertSame(testBean, mavContainer.getModel().get(\"testBean\"));\n\t}","id":34942,"modified_method":"@Test\n\tpublic void handleNotAnnotatedReturnValue() throws Exception {\n\t\tTestBean testBean = new TestBean(\"expected\");\n\t\tthis.processor.handleReturnValue(testBean, this.returnParamNonSimpleType, this.container, this.request);\n\t\tassertSame(testBean, this.container.getModel().get(\"testBean\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void getAttributeFromModel(String expectedAttributeName, MethodParameter param) throws Exception {\n\t\tObject target = new TestBean();\n\t\tmavContainer.addAttribute(expectedAttributeName, target);\n\n\t\tWebDataBinder dataBinder = new WebRequestDataBinder(target);\n\t\tWebDataBinderFactory factory = mock(WebDataBinderFactory.class);\n\t\tgiven(factory.createBinder(webRequest, target, expectedAttributeName)).willReturn(dataBinder);\n\n\t\tprocessor.resolveArgument(param, mavContainer, webRequest, factory);\n\t\tverify(factory).createBinder(webRequest, target, expectedAttributeName);\n\t}","id":34943,"modified_method":"private void testGetAttributeFromModel(String expectedAttrName, MethodParameter param) throws Exception {\n\t\tObject target = new TestBean();\n\t\tthis.container.addAttribute(expectedAttrName, target);\n\n\t\tWebDataBinder dataBinder = new WebRequestDataBinder(target);\n\t\tWebDataBinderFactory factory = mock(WebDataBinderFactory.class);\n\t\tgiven(factory.createBinder(this.request, target, expectedAttrName)).willReturn(dataBinder);\n\n\t\tthis.processor.resolveArgument(param, this.container, this.request, factory);\n\t\tverify(factory).createBinder(this.request, target, expectedAttrName);\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test(expected = BindException.class)\n\tpublic void resovleArgumentBindException() throws Exception {\n\t\tString name = \"testBean\";\n\t\tObject target = new TestBean();\n\t\tmavContainer.getModel().addAttribute(target);\n\n\t\tStubRequestDataBinder dataBinder = new StubRequestDataBinder(target, name);\n\t\tdataBinder.getBindingResult().reject(\"error\");\n\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(webRequest, target, name)).willReturn(dataBinder);\n\n\t\tprocessor.resolveArgument(paramNonSimpleType, mavContainer, webRequest, binderFactory);\n\t\tverify(binderFactory).createBinder(webRequest, target, name);\n\t}","id":34944,"modified_method":"@Test(expected = BindException.class)\n\tpublic void resolveArgumentBindException() throws Exception {\n\t\tString name = \"testBean\";\n\t\tObject target = new TestBean();\n\t\tthis.container.getModel().addAttribute(target);\n\n\t\tStubRequestDataBinder dataBinder = new StubRequestDataBinder(target, name);\n\t\tdataBinder.getBindingResult().reject(\"error\");\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.request, target, name)).willReturn(dataBinder);\n\n\t\tthis.processor.resolveArgument(this.paramNonSimpleType, this.container, this.request, binderFactory);\n\t\tverify(binderFactory).createBinder(this.request, target, name);\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Invoke model attribute methods to populate the model.\n\t * Attributes are added only if not already present in the model.\n\t */\n\tprivate void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)\n\t\t\tthrows Exception {\n\n\t\twhile (!this.modelMethods.isEmpty()) {\n\t\t\tInvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();\n\t\t\tString modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();\n\t\t\tif (mavContainer.containsAttribute(modelName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tObject returnValue = attrMethod.invokeForRequest(request, mavContainer);\n\n\t\t\tif (!attrMethod.isVoid()){\n\t\t\t\tString returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());\n\t\t\t\tif (!mavContainer.containsAttribute(returnValueName)) {\n\t\t\t\t\tmavContainer.addAttribute(returnValueName, returnValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":34945,"modified_method":"/**\n\t * Invoke model attribute methods to populate the model.\n\t * Attributes are added only if not already present in the model.\n\t */\n\tprivate void invokeModelAttributeMethods(NativeWebRequest request,\n\t\t\tModelAndViewContainer container) throws Exception {\n\n\t\twhile (!this.modelMethods.isEmpty()) {\n\t\t\tInvocableHandlerMethod modelMethod = getNextModelMethod(container).getHandlerMethod();\n\t\t\tModelAttribute annot = modelMethod.getMethodAnnotation(ModelAttribute.class);\n\t\t\tString modelName = annot.value();\n\t\t\tif (container.containsAttribute(modelName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tObject returnValue = modelMethod.invokeForRequest(request, container);\n\n\t\t\tif (!modelMethod.isVoid()){\n\t\t\t\tString returnValueName = getNameForReturnValue(returnValue, modelMethod.getReturnType());\n\t\t\t\tif (!container.containsAttribute(returnValueName)) {\n\t\t\t\t\tcontainer.addAttribute(returnValueName, returnValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private ModelMethod getNextModelMethod(ModelAndViewContainer mavContainer) {\n\t\tfor (ModelMethod modelMethod : this.modelMethods) {\n\t\t\tif (modelMethod.checkDependencies(mavContainer)) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Selected @ModelAttribute method \" + modelMethod);\n\t\t\t\t}\n\t\t\t\tthis.modelMethods.remove(modelMethod);\n\t\t\t\treturn modelMethod;\n\t\t\t}\n\t\t}\n\t\tModelMethod modelMethod = this.modelMethods.get(0);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Selected @ModelAttribute method (not present: \" +\n\t\t\t\t\tmodelMethod.getUnresolvedDependencies(mavContainer)+ \") \" + modelMethod);\n\t\t}\n\t\tthis.modelMethods.remove(modelMethod);\n\t\treturn modelMethod;\n\t}","id":34946,"modified_method":"private ModelMethod getNextModelMethod(ModelAndViewContainer container) {\n\t\tfor (ModelMethod modelMethod : this.modelMethods) {\n\t\t\tif (modelMethod.checkDependencies(container)) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Selected @ModelAttribute method \" + modelMethod);\n\t\t\t\t}\n\t\t\t\tthis.modelMethods.remove(modelMethod);\n\t\t\t\treturn modelMethod;\n\t\t\t}\n\t\t}\n\t\tModelMethod modelMethod = this.modelMethods.get(0);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Selected @ModelAttribute method (not present: \" +\n\t\t\t\t\tmodelMethod.getUnresolvedDependencies(container)+ \") \" + modelMethod);\n\t\t}\n\t\tthis.modelMethods.remove(modelMethod);\n\t\treturn modelMethod;\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create a new instance with the given {@code @ModelAttribute} methods.\n\t * @param invocableMethods the {@code @ModelAttribute} methods to invoke\n\t * @param dataBinderFactory for preparation of {@link BindingResult} attributes\n\t * @param sessionAttributesHandler for access to session attributes\n\t */\n\tpublic ModelFactory(List<InvocableHandlerMethod> invocableMethods, WebDataBinderFactory dataBinderFactory,\n\t\t\tSessionAttributesHandler sessionAttributesHandler) {\n\n\t\tif (invocableMethods != null) {\n\t\t\tfor (InvocableHandlerMethod method : invocableMethods) {\n\t\t\t\tthis.modelMethods.add(new ModelMethod(method));\n\t\t\t}\n\t\t}\n\t\tthis.dataBinderFactory = dataBinderFactory;\n\t\tthis.sessionAttributesHandler = sessionAttributesHandler;\n\t}","id":34947,"modified_method":"/**\n\t * Create a new instance with the given {@code @ModelAttribute} methods.\n\t * @param handlerMethods the {@code @ModelAttribute} methods to invoke\n\t * @param binderFactory for preparation of {@link BindingResult} attributes\n\t * @param attributeHandler for access to session attributes\n\t */\n\tpublic ModelFactory(List<InvocableHandlerMethod> handlerMethods,\n\t\t\tWebDataBinderFactory binderFactory, SessionAttributesHandler attributeHandler) {\n\n\t\tif (handlerMethods != null) {\n\t\t\tfor (InvocableHandlerMethod handlerMethod : handlerMethods) {\n\t\t\t\tthis.modelMethods.add(new ModelMethod(handlerMethod));\n\t\t\t}\n\t\t}\n\t\tthis.dataBinderFactory = binderFactory;\n\t\tthis.sessionAttributesHandler = attributeHandler;\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Find {@code @ModelAttribute} arguments also listed as {@code @SessionAttributes}.\n\t */\n\tprivate List<String> findSessionAttributeArguments(HandlerMethod handlerMethod) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tfor (MethodParameter parameter : handlerMethod.getMethodParameters()) {\n\t\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\t\tString name = getNameForParameter(parameter);\n\t\t\t\tif (this.sessionAttributesHandler.isHandlerSessionAttribute(name, parameter.getParameterType())) {\n\t\t\t\t\tresult.add(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":34948,"modified_method":"/**\n\t * Find {@code @ModelAttribute} arguments also listed as {@code @SessionAttributes}.\n\t */\n\tprivate List<String> findSessionAttributeArguments(HandlerMethod handlerMethod) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tfor (MethodParameter parameter : handlerMethod.getMethodParameters()) {\n\t\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\t\tString name = getNameForParameter(parameter);\n\t\t\t\tClass<?> paramType = parameter.getParameterType();\n\t\t\t\tif (this.sessionAttributesHandler.isHandlerSessionAttribute(name, paramType)) {\n\t\t\t\t\tresult.add(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Populate the model in the following order:\n\t * <ol>\n\t * \t<li>Retrieve \"known\" session attributes listed as {@code @SessionAttributes}.\n\t * \t<li>Invoke {@code @ModelAttribute} methods\n\t * \t<li>Find {@code @ModelAttribute} method arguments also listed as\n\t * \t{@code @SessionAttributes} and ensure they're present in the model raising\n\t * \tan exception if necessary.\n\t * <\/ol>\n\t * @param request the current request\n\t * @param mavContainer a container with the model to be initialized\n\t * @param handlerMethod the method for which the model is initialized\n\t * @throws Exception may arise from {@code @ModelAttribute} methods\n\t */\n\tpublic void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)\n\t\t\tthrows Exception {\n\n\t\tMap<String, ?> sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);\n\t\tmavContainer.mergeAttributes(sessionAttributes);\n\n\t\tinvokeModelAttributeMethods(request, mavContainer);\n\n\t\tfor (String name : findSessionAttributeArguments(handlerMethod)) {\n\t\t\tif (!mavContainer.containsAttribute(name)) {\n\t\t\t\tObject value = this.sessionAttributesHandler.retrieveAttribute(request, name);\n\t\t\t\tif (value == null) {\n\t\t\t\t\tthrow new HttpSessionRequiredException(\"Expected session attribute '\" + name + \"'\");\n\t\t\t\t}\n\t\t\t\tmavContainer.addAttribute(name, value);\n\t\t\t}\n\t\t}\n\t}","id":34949,"modified_method":"/**\n\t * Populate the model in the following order:\n\t * <ol>\n\t * \t<li>Retrieve \"known\" session attributes listed as {@code @SessionAttributes}.\n\t * \t<li>Invoke {@code @ModelAttribute} methods\n\t * \t<li>Find {@code @ModelAttribute} method arguments also listed as\n\t * \t{@code @SessionAttributes} and ensure they're present in the model raising\n\t * \tan exception if necessary.\n\t * <\/ol>\n\t * @param request the current request\n\t * @param container a container with the model to be initialized\n\t * @param handlerMethod the method for which the model is initialized\n\t * @throws Exception may arise from {@code @ModelAttribute} methods\n\t */\n\tpublic void initModel(NativeWebRequest request, ModelAndViewContainer container,\n\t\t\tHandlerMethod handlerMethod) throws Exception {\n\n\t\tMap<String, ?> sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);\n\t\tcontainer.mergeAttributes(sessionAttributes);\n\n\t\tinvokeModelAttributeMethods(request, container);\n\n\t\tfor (String name : findSessionAttributeArguments(handlerMethod)) {\n\t\t\tif (!container.containsAttribute(name)) {\n\t\t\t\tObject value = this.sessionAttributesHandler.retrieveAttribute(request, name);\n\t\t\t\tif (value == null) {\n\t\t\t\t\tthrow new HttpSessionRequiredException(\n\t\t\t\t\t\t\t\"Expected session attribute '\" + name + \"'\");\n\t\t\t\t}\n\t\t\t\tcontainer.addAttribute(name, value);\n\t\t\t}\n\t\t}\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Derive the model attribute name for the given return value using one of:\n\t * <ol>\n\t * \t<li>The method {@code ModelAttribute} annotation value\n\t * \t<li>The declared return type if it is more specific than {@code Object}\n\t * \t<li>The actual return value type\n\t * <\/ol>\n\t * @param returnValue the value returned from a method invocation\n\t * @param returnType the return type of the method\n\t * @return the model name, never {@code null} nor empty\n\t */\n\tpublic static String getNameForReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tModelAttribute annotation = returnType.getMethodAnnotation(ModelAttribute.class);\n\t\tif (annotation != null && StringUtils.hasText(annotation.value())) {\n\t\t\treturn annotation.value();\n\t\t}\n\t\telse {\n\t\t\tMethod method = returnType.getMethod();\n\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, returnType.getContainingClass());\n\t\t\treturn Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);\n\t\t}\n\t}","id":34950,"modified_method":"/**\n\t * Derive the model attribute name for the given return value using one of:\n\t * <ol>\n\t * \t<li>The method {@code ModelAttribute} annotation value\n\t * \t<li>The declared return type if it is more specific than {@code Object}\n\t * \t<li>The actual return value type\n\t * <\/ol>\n\t * @param returnValue the value returned from a method invocation\n\t * @param returnType the return type of the method\n\t * @return the model name, never {@code null} nor empty\n\t */\n\tpublic static String getNameForReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tModelAttribute annotation = returnType.getMethodAnnotation(ModelAttribute.class);\n\t\tif (annotation != null && StringUtils.hasText(annotation.value())) {\n\t\t\treturn annotation.value();\n\t\t}\n\t\telse {\n\t\t\tMethod method = returnType.getMethod();\n\t\t\tClass<?> containingClass = returnType.getContainingClass();\n\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\treturn Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);\n\t\t}\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Derives the model attribute name for a method parameter based on:\n\t * <ol>\n\t * \t<li>The parameter {@code @ModelAttribute} annotation value\n\t * \t<li>The parameter type\n\t * <\/ol>\n\t * @return the derived name; never {@code null} or an empty string\n\t */\n\tpublic static String getNameForParameter(MethodParameter parameter) {\n\t\tModelAttribute annot = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tString attrName = (annot != null) ? annot.value() : null;\n\t\treturn StringUtils.hasText(attrName) ? attrName :  Conventions.getVariableNameForParameter(parameter);\n\t}","id":34951,"modified_method":"/**\n\t * Derives the model attribute name for a method parameter based on:\n\t * <ol>\n\t * \t<li>The parameter {@code @ModelAttribute} annotation value\n\t * \t<li>The parameter type\n\t * <\/ol>\n\t * @return the derived name; never {@code null} or an empty string\n\t */\n\tpublic static String getNameForParameter(MethodParameter parameter) {\n\t\tModelAttribute annot = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tString name = (annot != null) ? annot.value() : null;\n\t\treturn StringUtils.hasText(name) ? name : Conventions.getVariableNameForParameter(parameter);\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Add {@link BindingResult} attributes to the model for attributes that require it.\n\t */\n\tprivate void updateBindingResult(NativeWebRequest request, ModelMap model) throws Exception {\n\t\tList<String> keyNames = new ArrayList<String>(model.keySet());\n\t\tfor (String name : keyNames) {\n\t\t\tObject value = model.get(name);\n\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tString bindingResultKey = BindingResult.MODEL_KEY_PREFIX + name;\n\n\t\t\t\tif (!model.containsAttribute(bindingResultKey)) {\n\t\t\t\t\tWebDataBinder dataBinder = dataBinderFactory.createBinder(request, value, name);\n\t\t\t\t\tmodel.put(bindingResultKey, dataBinder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":34952,"modified_method":"/**\n\t * Add {@link BindingResult} attributes to the model for attributes that require it.\n\t */\n\tprivate void updateBindingResult(NativeWebRequest request, ModelMap model) throws Exception {\n\t\tList<String> keyNames = new ArrayList<String>(model.keySet());\n\t\tfor (String name : keyNames) {\n\t\t\tObject value = model.get(name);\n\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tString bindingResultKey = BindingResult.MODEL_KEY_PREFIX + name;\n\n\t\t\t\tif (!model.containsAttribute(bindingResultKey)) {\n\t\t\t\t\tWebDataBinder dataBinder = this.dataBinderFactory.createBinder(request, value, name);\n\t\t\t\t\tmodel.put(bindingResultKey, dataBinder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Promote model attributes listed as {@code @SessionAttributes} to the session.\n\t * Add {@link BindingResult} attributes where necessary.\n\t * @param request the current request\n\t * @param mavContainer contains the model to update\n\t * @throws Exception if creating BindingResult attributes fails\n\t */\n\tpublic void updateModel(NativeWebRequest request, ModelAndViewContainer mavContainer) throws Exception {\n\t\tModelMap defaultModel = mavContainer.getDefaultModel();\n\t\tif (mavContainer.getSessionStatus().isComplete()){\n\t\t\tthis.sessionAttributesHandler.cleanupAttributes(request);\n\t\t}\n\t\telse {\n\t\t\tthis.sessionAttributesHandler.storeAttributes(request, defaultModel);\n\t\t}\n\t\tif (!mavContainer.isRequestHandled() && mavContainer.getModel() == defaultModel) {\n\t\t\tupdateBindingResult(request, defaultModel);\n\t\t}\n\t}","id":34953,"modified_method":"/**\n\t * Promote model attributes listed as {@code @SessionAttributes} to the session.\n\t * Add {@link BindingResult} attributes where necessary.\n\t * @param request the current request\n\t * @param container contains the model to update\n\t * @throws Exception if creating BindingResult attributes fails\n\t */\n\tpublic void updateModel(NativeWebRequest request, ModelAndViewContainer container) throws Exception {\n\t\tModelMap defaultModel = container.getDefaultModel();\n\t\tif (container.getSessionStatus().isComplete()){\n\t\t\tthis.sessionAttributesHandler.cleanupAttributes(request);\n\t\t}\n\t\telse {\n\t\t\tthis.sessionAttributesHandler.storeAttributes(request, defaultModel);\n\t\t}\n\t\tif (!container.isRequestHandled() && container.getModel() == defaultModel) {\n\t\t\tupdateBindingResult(request, defaultModel);\n\t\t}\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void updateModelSessionAttributesRemoved() throws Exception {\n\t\tString attributeName = \"sessionAttr\";\n\t\tString attribute = \"value\";\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(attributeName, attribute);\n\n\t\t// Store and resolve once (to be \"remembered\")\n\t\tthis.sessionAttributeStore.storeAttribute(this.webRequest, attributeName, attribute);\n\t\tthis.sessionAttrsHandler.isHandlerSessionAttribute(attributeName, null);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(attribute, attributeName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, attribute, attributeName)).willReturn(dataBinder);\n\n\t\tcontainer.getSessionStatus().setComplete();\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.sessionAttrsHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(attribute, container.getModel().get(attributeName));\n\t\tassertNull(this.sessionAttributeStore.retrieveAttribute(this.webRequest, attributeName));\n\t}","id":34954,"modified_method":"@Test\n\tpublic void updateModelSessionAttributesRemoved() throws Exception {\n\t\tString attributeName = \"sessionAttr\";\n\t\tString attribute = \"value\";\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(attributeName, attribute);\n\n\t\tthis.attributeStore.storeAttribute(this.webRequest, attributeName, attribute);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(attribute, attributeName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, attribute, attributeName)).willReturn(dataBinder);\n\n\t\tcontainer.getSessionStatus().setComplete();\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.attributeHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(attribute, container.getModel().get(attributeName));\n\t\tassertNull(this.attributeStore.retrieveAttribute(this.webRequest, attributeName));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void modelAttributeMethodWithExplicitName() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttrWithName\");\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmodelFactory.initModel(this.webRequest, mavContainer, this.handleMethod);\n\n\t\tassertEquals(Boolean.TRUE, mavContainer.getModel().get(\"name\"));\n\t}","id":34955,"modified_method":"@Test\n\tpublic void modelAttributeMethodWithExplicitName() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttrWithName\");\n\t\tHandlerMethod handlerMethod = createHandlerMethod(\"handle\");\n\t\tmodelFactory.initModel(this.webRequest, this.mavContainer, handlerMethod);\n\n\t\tassertEquals(Boolean.TRUE, this.mavContainer.getModel().get(\"name\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void updateModelBindingResult() throws Exception {\n\t\tString commandName = \"attr1\";\n\t\tObject command = new Object();\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(commandName, command);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(command, commandName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, command, commandName)).willReturn(dataBinder);\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.sessionAttrsHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(command, container.getModel().get(commandName));\n\t\tassertSame(dataBinder.getBindingResult(), container.getModel().get(bindingResultKey(commandName)));\n\t\tassertEquals(2, container.getModel().size());\n\t}","id":34956,"modified_method":"@Test\n\tpublic void updateModelBindingResult() throws Exception {\n\t\tString commandName = \"attr1\";\n\t\tObject command = new Object();\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(commandName, command);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(command, commandName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, command, commandName)).willReturn(dataBinder);\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.attributeHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(command, container.getModel().get(commandName));\n\t\tString bindingResultKey = BindingResult.MODEL_KEY_PREFIX + commandName;\n\t\tassertSame(dataBinder.getBindingResult(), container.getModel().get(bindingResultKey));\n\t\tassertEquals(2, container.getModel().size());\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void updateModelWhenRedirecting() throws Exception {\n\t\tString attributeName = \"sessionAttr\";\n\t\tString attribute = \"value\";\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(attributeName, attribute);\n\n\t\tString queryParam = \"123\";\n\t\tString queryParamName = \"q\";\n\t\tcontainer.setRedirectModel(new ModelMap(queryParamName, queryParam));\n\t\tcontainer.setRedirectModelScenario(true);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(attribute, attributeName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, attribute, attributeName)).willReturn(dataBinder);\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.sessionAttrsHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(queryParam, container.getModel().get(queryParamName));\n\t\tassertEquals(1, container.getModel().size());\n\t\tassertEquals(attribute, this.sessionAttributeStore.retrieveAttribute(this.webRequest, attributeName));\n\t}","id":34957,"modified_method":"@Test\n\tpublic void updateModelWhenRedirecting() throws Exception {\n\t\tString attributeName = \"sessionAttr\";\n\t\tString attribute = \"value\";\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(attributeName, attribute);\n\n\t\tString queryParam = \"123\";\n\t\tString queryParamName = \"q\";\n\t\tcontainer.setRedirectModel(new ModelMap(queryParamName, queryParam));\n\t\tcontainer.setRedirectModelScenario(true);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(attribute, attributeName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, attribute, attributeName)).willReturn(dataBinder);\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.attributeHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(queryParam, container.getModel().get(queryParamName));\n\t\tassertEquals(1, container.getModel().size());\n\t\tassertEquals(attribute, this.attributeStore.retrieveAttribute(this.webRequest, attributeName));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void modelAttributeMethodWithNullReturnValue() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"nullModelAttr\");\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmodelFactory.initModel(this.webRequest, mavContainer, this.handleMethod);\n\n\t\tassertTrue(mavContainer.containsAttribute(\"name\"));\n\t\tassertNull(mavContainer.getModel().get(\"name\"));\n\t}","id":34958,"modified_method":"@Test\n\tpublic void modelAttributeMethodWithNullReturnValue() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"nullModelAttr\");\n\t\tHandlerMethod handlerMethod = createHandlerMethod(\"handle\");\n\t\tmodelFactory.initModel(this.webRequest, this.mavContainer, handlerMethod);\n\n\t\tassertTrue(this.mavContainer.containsAttribute(\"name\"));\n\t\tassertNull(this.mavContainer.getModel().get(\"name\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void modelAttributeMethod() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttr\", Model.class);\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmodelFactory.initModel(this.webRequest, mavContainer, this.handleMethod);\n\n\t\tassertEquals(Boolean.TRUE, mavContainer.getModel().get(\"modelAttr\"));\n\t}","id":34959,"modified_method":"@Test\n\tpublic void modelAttributeMethod() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttr\", Model.class);\n\t\tHandlerMethod handlerMethod = createHandlerMethod(\"handle\");\n\t\tmodelFactory.initModel(this.webRequest, this.mavContainer, handlerMethod);\n\n\t\tassertEquals(Boolean.TRUE, this.mavContainer.getModel().get(\"modelAttr\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sessionAttribute() throws Exception {\n\t\tthis.sessionAttributeStore.storeAttribute(this.webRequest, \"sessionAttr\", \"sessionAttrValue\");\n\n\t\t// Resolve successfully handler session attribute once\n\t\tassertTrue(sessionAttrsHandler.isHandlerSessionAttribute(\"sessionAttr\", null));\n\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttr\", Model.class);\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmodelFactory.initModel(this.webRequest, mavContainer, this.handleMethod);\n\n\t\tassertEquals(\"sessionAttrValue\", mavContainer.getModel().get(\"sessionAttr\"));\n\t}","id":34960,"modified_method":"@Test\n\tpublic void sessionAttribute() throws Exception {\n\t\tthis.attributeStore.storeAttribute(this.webRequest, \"sessionAttr\", \"sessionAttrValue\");\n\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttr\", Model.class);\n\t\tHandlerMethod handlerMethod = createHandlerMethod(\"handle\");\n\t\tmodelFactory.initModel(this.webRequest, this.mavContainer, handlerMethod);\n\n\t\tassertEquals(\"sessionAttrValue\", this.mavContainer.getModel().get(\"sessionAttr\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.controller = new TestController();\n\n\t\tMethod method = TestController.class.getDeclaredMethod(\"handle\");\n\t\tthis.handleMethod = new InvocableHandlerMethod(this.controller, method);\n\n\t\tmethod = TestController.class.getDeclaredMethod(\"handleSessionAttr\", String.class);\n\t\tthis.handleSessionAttrMethod = new InvocableHandlerMethod(this.controller, method);\n\n\t\tthis.sessionAttributeStore = new DefaultSessionAttributeStore();\n\t\tthis.sessionAttrsHandler = new SessionAttributesHandler(TestController.class, this.sessionAttributeStore);\n\t\tthis.webRequest = new ServletWebRequest(new MockHttpServletRequest());\n\t}","id":34961,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.webRequest = new ServletWebRequest(new MockHttpServletRequest());\n\t\tthis.attributeStore = new DefaultSessionAttributeStore();\n\t\tthis.attributeHandler = new SessionAttributesHandler(TestController.class, this.attributeStore);\n\t\tthis.controller = new TestController();\n\t\tthis.mavContainer = new ModelAndViewContainer();\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void updateModelSessionAttributesSaved() throws Exception {\n\t\tString attributeName = \"sessionAttr\";\n\t\tString attribute = \"value\";\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(attributeName, attribute);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(attribute, attributeName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, attribute, attributeName)).willReturn(dataBinder);\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.sessionAttrsHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(attribute, container.getModel().get(attributeName));\n\t\tassertEquals(attribute, this.sessionAttributeStore.retrieveAttribute(this.webRequest, attributeName));\n\t}","id":34962,"modified_method":"@Test\n\tpublic void updateModelSessionAttributesSaved() throws Exception {\n\t\tString attributeName = \"sessionAttr\";\n\t\tString attribute = \"value\";\n\t\tModelAndViewContainer container = new ModelAndViewContainer();\n\t\tcontainer.addAttribute(attributeName, attribute);\n\n\t\tWebDataBinder dataBinder = new WebDataBinder(attribute, attributeName);\n\t\tWebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);\n\t\tgiven(binderFactory.createBinder(this.webRequest, attribute, attributeName)).willReturn(dataBinder);\n\n\t\tModelFactory modelFactory = new ModelFactory(null, binderFactory, this.attributeHandler);\n\t\tmodelFactory.updateModel(this.webRequest, container);\n\n\t\tassertEquals(attribute, container.getModel().get(attributeName));\n\t\tassertEquals(attribute, this.attributeStore.retrieveAttribute(this.webRequest, attributeName));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void modelAttributeMethodWithNameByConvention() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttrConvention\");\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmodelFactory.initModel(this.webRequest, mavContainer, this.handleMethod);\n\n\t\tassertEquals(Boolean.TRUE, mavContainer.getModel().get(\"boolean\"));\n\t}","id":34963,"modified_method":"@Test\n\tpublic void modelAttributeMethodWithNameByConvention() throws Exception {\n\t\tModelFactory modelFactory = createModelFactory(\"modelAttrConvention\");\n\t\tHandlerMethod handlerMethod = createHandlerMethod(\"handle\");\n\t\tmodelFactory.initModel(this.webRequest, this.mavContainer, handlerMethod);\n\n\t\tassertEquals(Boolean.TRUE, this.mavContainer.getModel().get(\"boolean\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private ModelFactory createModelFactory(String methodName, Class<?>... parameterTypes) throws Exception{\n\t\tMethod method = TestController.class.getMethod(methodName, parameterTypes);\n\n\t\tHandlerMethodArgumentResolverComposite argResolvers = new HandlerMethodArgumentResolverComposite();\n\t\targResolvers.addResolver(new ModelMethodProcessor());\n\n\t\tInvocableHandlerMethod handlerMethod = new InvocableHandlerMethod(this.controller, method);\n\t\thandlerMethod.setHandlerMethodArgumentResolvers(argResolvers);\n\t\thandlerMethod.setDataBinderFactory(null);\n\t\thandlerMethod.setParameterNameDiscoverer(new LocalVariableTableParameterNameDiscoverer());\n\n\t\treturn new ModelFactory(Arrays.asList(handlerMethod), null, this.sessionAttrsHandler);\n\t}","id":34964,"modified_method":"private ModelFactory createModelFactory(String methodName, Class<?>... parameterTypes) throws Exception {\n\t\tHandlerMethodArgumentResolverComposite resolvers = new HandlerMethodArgumentResolverComposite();\n\t\tresolvers.addResolver(new ModelMethodProcessor());\n\n\t\tInvocableHandlerMethod modelMethod = createHandlerMethod(methodName, parameterTypes);\n\t\tmodelMethod.setHandlerMethodArgumentResolvers(resolvers);\n\t\tmodelMethod.setDataBinderFactory(null);\n\t\tmodelMethod.setParameterNameDiscoverer(new LocalVariableTableParameterNameDiscoverer());\n\n\t\treturn new ModelFactory(Collections.singletonList(modelMethod), null, this.attributeHandler);\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sessionAttributeNotPresent() throws Exception {\n\t\tModelFactory modelFactory = new ModelFactory(null, null, this.sessionAttrsHandler);\n\n\t\ttry {\n\t\t\tmodelFactory.initModel(this.webRequest, new ModelAndViewContainer(), this.handleSessionAttrMethod);\n\t\t\tfail(\"Expected HttpSessionRequiredException\");\n\t\t}\n\t\tcatch (HttpSessionRequiredException e) {\n\t\t\t// expected\n\t\t}\n\n\t\tthis.sessionAttributeStore.storeAttribute(this.webRequest, \"sessionAttr\", \"sessionAttrValue\");\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmodelFactory.initModel(this.webRequest, mavContainer, this.handleSessionAttrMethod);\n\n\t\tassertEquals(\"sessionAttrValue\", mavContainer.getModel().get(\"sessionAttr\"));\n\t}","id":34965,"modified_method":"@Test\n\tpublic void sessionAttributeNotPresent() throws Exception {\n\t\tModelFactory modelFactory = new ModelFactory(null, null, this.attributeHandler);\n\t\tHandlerMethod handlerMethod = createHandlerMethod(\"handleSessionAttr\", String.class);\n\t\ttry {\n\t\t\tmodelFactory.initModel(this.webRequest, this.mavContainer, handlerMethod);\n\t\t\tfail(\"Expected HttpSessionRequiredException\");\n\t\t}\n\t\tcatch (HttpSessionRequiredException e) {\n\t\t\t// expected\n\t\t}\n\n\t\t// Now add attribute and try again\n\t\tthis.attributeStore.storeAttribute(this.webRequest, \"sessionAttr\", \"sessionAttrValue\");\n\n\t\tmodelFactory.initModel(this.webRequest, this.mavContainer, handlerMethod);\n\t\tassertEquals(\"sessionAttrValue\", this.mavContainer.getModel().get(\"sessionAttr\"));\n\t}","commit_id":"806e79b14bcd4b3deb76d1a87d28b23f956b6fb7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected PortletPreferences doImportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences, String data)\n\t\tthrows Exception {\n\n\t\tportletDataContext.importPermissions(\n\t\t\t\"com.liferay.portlet.journal\",\n\t\t\tportletDataContext.getSourceGroupId(),\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tif (Validator.isNull(data)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(data);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tJournalPortletDataHandlerImpl.importReferencedData(\n\t\t\tportletDataContext, rootElement);\n\n\t\tElement structureElement = rootElement.element(\"structure\");\n\n\t\tif (structureElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importStructure(\n\t\t\t\tportletDataContext, structureElement, rootElement);\n\t\t}\n\n\t\tElement templateElement = rootElement.element(\"template\");\n\n\t\tif (templateElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importTemplate(\n\t\t\t\tportletDataContext, templateElement);\n\t\t}\n\n\t\tElement articleElement = rootElement.element(\"article\");\n\n\t\tif (articleElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\tportletDataContext, articleElement);\n\t\t}\n\n\t\tString articleId = portletPreferences.getValue(\"articleId\", null);\n\n\t\tif (Validator.isNotNull(articleId)) {\n\t\t\tMap<String, String> articleIds =\n\t\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tJournalArticle.class);\n\n\t\t\tarticleId = MapUtil.getString(articleIds, articleId, articleId);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\t\"groupId\",\n\t\t\t\tString.valueOf(portletDataContext.getScopeGroupId()));\n\t\t\tportletPreferences.setValue(\"articleId\", articleId);\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\tportletDataContext.getPlid());\n\n\t\t\tJournalContentSearchLocalServiceUtil.updateContentSearch(\n\t\t\t\tportletDataContext.getScopeGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), portletId, articleId, true);\n\t\t}\n\n\t\tString templateId = portletPreferences.getValue(\"templateId\", null);\n\n\t\tif (Validator.isNotNull(templateId)) {\n\t\t\tMap<String, String> templateIds =\n\t\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tJournalTemplate.class);\n\n\t\t\ttemplateId = MapUtil.getString(templateIds, templateId, templateId);\n\n\t\t\tportletPreferences.setValue(\"templateId\", templateId);\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","id":34966,"modified_method":"protected PortletPreferences doImportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences, String data)\n\t\tthrows Exception {\n\n\t\tportletDataContext.importPermissions(\n\t\t\t\"com.liferay.portlet.journal\",\n\t\t\tportletDataContext.getSourceGroupId(),\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tif (Validator.isNull(data)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(data);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tJournalPortletDataHandlerImpl.importReferencedData(\n\t\t\tportletDataContext, rootElement);\n\n\t\tElement structureElement = rootElement.element(\"structure\");\n\n\t\tif (structureElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importStructure(\n\t\t\t\tportletDataContext, structureElement);\n\t\t}\n\n\t\tElement templateElement = rootElement.element(\"template\");\n\n\t\tif (templateElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importTemplate(\n\t\t\t\tportletDataContext, templateElement);\n\t\t}\n\n\t\tElement articleElement = rootElement.element(\"article\");\n\n\t\tif (articleElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\tportletDataContext, articleElement);\n\t\t}\n\n\t\tString articleId = portletPreferences.getValue(\"articleId\", null);\n\n\t\tif (Validator.isNotNull(articleId)) {\n\t\t\tMap<String, String> articleIds =\n\t\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tJournalArticle.class);\n\n\t\t\tarticleId = MapUtil.getString(articleIds, articleId, articleId);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\t\"groupId\",\n\t\t\t\tString.valueOf(portletDataContext.getScopeGroupId()));\n\t\t\tportletPreferences.setValue(\"articleId\", articleId);\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\tportletDataContext.getPlid());\n\n\t\t\tJournalContentSearchLocalServiceUtil.updateContentSearch(\n\t\t\t\tportletDataContext.getScopeGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), portletId, articleId, true);\n\t\t}\n\n\t\tString templateId = portletPreferences.getValue(\"templateId\", null);\n\n\t\tif (Validator.isNotNull(templateId)) {\n\t\t\tMap<String, String> templateIds =\n\t\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tJournalTemplate.class);\n\n\t\t\ttemplateId = MapUtil.getString(templateIds, templateId, templateId);\n\n\t\t\tportletPreferences.setValue(\"templateId\", templateId);\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","commit_id":"d5b19bf43606241d80a2ed29828ee6d28a1314aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected PortletPreferences doImportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences, String data)\n\t\tthrows Exception {\n\n\t\tportletDataContext.importPermissions(\n\t\t\t\"com.liferay.portlet.journal\",\n\t\t\tportletDataContext.getSourceGroupId(),\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tDocument document = SAXReaderUtil.read(data);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\timportReferencedData(portletDataContext, rootElement);\n\n\t\tElement structuresElement = rootElement.element(\"structures\");\n\n\t\tList<Element> structureElements = structuresElement.elements(\n\t\t\t\"structure\");\n\n\t\tfor (Element structureElement : structureElements) {\n\t\t\timportStructure(portletDataContext, structureElement, rootElement);\n\t\t}\n\n\t\tElement templatesElement = rootElement.element(\"templates\");\n\n\t\tList<Element> templateElements = templatesElement.elements(\"template\");\n\n\t\tfor (Element templateElement : templateElements) {\n\t\t\timportTemplate(portletDataContext, templateElement);\n\t\t}\n\n\t\tElement feedsElement = rootElement.element(\"feeds\");\n\n\t\tList<Element> feedElements = feedsElement.elements(\"feed\");\n\n\t\tfor (Element feedElement : feedElements) {\n\t\t\timportFeed(portletDataContext, feedElement);\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"articles\")) {\n\t\t\tElement articlesElement = rootElement.element(\"articles\");\n\n\t\t\tList<Element> articleElements = articlesElement.elements(\"article\");\n\n\t\t\tfor (Element articleElement : articleElements) {\n\t\t\t\timportArticle(portletDataContext, articleElement);\n\t\t\t}\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","id":34967,"modified_method":"protected PortletPreferences doImportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences, String data)\n\t\tthrows Exception {\n\n\t\tportletDataContext.importPermissions(\n\t\t\t\"com.liferay.portlet.journal\",\n\t\t\tportletDataContext.getSourceGroupId(),\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tDocument document = SAXReaderUtil.read(data);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\timportReferencedData(portletDataContext, rootElement);\n\n\t\tElement structuresElement = rootElement.element(\"structures\");\n\n\t\tList<Element> structureElements = structuresElement.elements(\n\t\t\t\"structure\");\n\n\t\tfor (Element structureElement : structureElements) {\n\t\t\timportStructure(portletDataContext, structureElement);\n\t\t}\n\n\t\tElement templatesElement = rootElement.element(\"templates\");\n\n\t\tList<Element> templateElements = templatesElement.elements(\"template\");\n\n\t\tfor (Element templateElement : templateElements) {\n\t\t\timportTemplate(portletDataContext, templateElement);\n\t\t}\n\n\t\tElement feedsElement = rootElement.element(\"feeds\");\n\n\t\tList<Element> feedElements = feedsElement.elements(\"feed\");\n\n\t\tfor (Element feedElement : feedElements) {\n\t\t\timportFeed(portletDataContext, feedElement);\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"articles\")) {\n\t\t\tElement articlesElement = rootElement.element(\"articles\");\n\n\t\t\tList<Element> articleElements = articlesElement.elements(\"article\");\n\n\t\t\tfor (Element articleElement : articleElements) {\n\t\t\t\timportArticle(portletDataContext, articleElement);\n\t\t\t}\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","commit_id":"d5b19bf43606241d80a2ed29828ee6d28a1314aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importStructure(\n\t\t\tPortletDataContext portletDataContext, Element structureElement,\n\t\t\tElement rootElement)\n\t\tthrows Exception {\n\n\t\tlong groupId = portletDataContext.getGroupId();\n\n\t\tString path = structureElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalStructure structure =\n\t\t\t(JournalStructure)portletDataContext.getZipEntryAsObject(path);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(\n\t\t\tportletDataContext, structure);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tString structureId = structure.getStructureId();\n\t\tboolean autoStructureId = false;\n\n\t\tif ((Validator.isNumber(structureId)) ||\n\t\t\t(JournalStructureUtil.fetchByG_S(\n\t\t\t\tportletDataContext.getScopeGroupId(), structureId) != null)) {\n\n\t\t\tautoStructureId = true;\n\t\t}\n\n\t\tMap<String, String> structureIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, structure.getParentStructureId(),\n\t\t\tstructure.getParentStructureId());\n\n\t\tNode parentStructureNode = rootElement.selectSingleNode(\n\t\t\t\"./structures/structure[@structure-id='\" + parentStructureId +\n\t\t\t\t\"']\");\n\n\t\tString parentStructureUuid = GetterUtil.getString(\n\t\t\tstructureElement.attributeValue(\"parent-structure-uuid\"));\n\n\t\tif (Validator.isNotNull(parentStructureId) &&\n\t\t\t(parentStructureNode != null)) {\n\n\t\t\timportStructure(portletDataContext, (Element)parentStructureNode,\n\t\t\t\trootElement);\n\n\t\t\tparentStructureId = structureIds.get(parentStructureId);\n\t\t}\n\t\telse if (Validator.isNotNull(parentStructureUuid)) {\n\t\t\tJournalStructure parentStructure =\n\t\t\t\tJournalStructureLocalServiceUtil.\n\t\t\t\t\tgetJournalStructureByUuidAndGroupId(\n\t\t\t\t\t\tparentStructureUuid, groupId);\n\n\t\t\tparentStructureId = parentStructure.getStructureId();\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(\n\t\t\t\tportletDataContext, structure);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tportletDataContext, structure);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(addCommunityPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setCreateDate(structure.getCreateDate());\n\t\tserviceContext.setModifiedDate(structure.getModifiedDate());\n\n\t\tJournalStructure existingStructure = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\texistingStructure = JournalStructureUtil.fetchByUUID_G(\n\t\t\t\tstructure.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tstructureId, autoStructureId, parentStructureId,\n\t\t\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getGroupId(),\n\t\t\t\t\t\texistingStructure.getStructureId(), parentStructureId,\n\t\t\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingStructure = JournalStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), structureId,\n\t\t\t\tautoStructureId, parentStructureId, structure.getName(),\n\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\tstructureIds.put(structureId, existingStructure.getStructureId());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tJournalStructure.class, structure.getId(),\n\t\t\texistingStructure.getId());\n\n\t\tif (!structureId.equals(existingStructure.getStructureId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A structure with the ID \" + structureId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingStructure.getStructureId());\n\t\t\t}\n\t\t}\n\t}","id":34968,"modified_method":"protected static void importStructure(\n\t\t\tPortletDataContext portletDataContext, Element structureElement)\n\t\tthrows Exception {\n\n\t\tString path = structureElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalStructure structure =\n\t\t\t(JournalStructure)portletDataContext.getZipEntryAsObject(path);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(\n\t\t\tportletDataContext, structure);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tString structureId = structure.getStructureId();\n\t\tboolean autoStructureId = false;\n\n\t\tif ((Validator.isNumber(structureId)) ||\n\t\t\t(JournalStructureUtil.fetchByG_S(\n\t\t\t\tportletDataContext.getScopeGroupId(), structureId) != null)) {\n\n\t\t\tautoStructureId = true;\n\t\t}\n\n\t\tMap<String, String> structureIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, structure.getParentStructureId(),\n\t\t\tstructure.getParentStructureId());\n\n\t\tDocument document = structureElement.getDocument();\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tNode parentStructureNode = rootElement.selectSingleNode(\n\t\t\t\"./structures/structure[@structure-id='\" + parentStructureId +\n\t\t\t\t\"']\");\n\n\t\tString parentStructureUuid = GetterUtil.getString(\n\t\t\tstructureElement.attributeValue(\"parent-structure-uuid\"));\n\n\t\tif ((parentStructureNode != null) &&\n\t\t\tValidator.isNotNull(parentStructureId)) {\n\n\t\t\timportStructure(portletDataContext, (Element)parentStructureNode);\n\n\t\t\tparentStructureId = structureIds.get(parentStructureId);\n\t\t}\n\t\telse if (Validator.isNotNull(parentStructureUuid)) {\n\t\t\tJournalStructure parentStructure =\n\t\t\t\tJournalStructureLocalServiceUtil.\n\t\t\t\t\tgetJournalStructureByUuidAndGroupId(\n\t\t\t\t\t\tparentStructureUuid, portletDataContext.getGroupId());\n\n\t\t\tparentStructureId = parentStructure.getStructureId();\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(\n\t\t\t\tportletDataContext, structure);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tportletDataContext, structure);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(addCommunityPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setCreateDate(structure.getCreateDate());\n\t\tserviceContext.setModifiedDate(structure.getModifiedDate());\n\n\t\tJournalStructure existingStructure = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\texistingStructure = JournalStructureUtil.fetchByUUID_G(\n\t\t\t\tstructure.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tstructureId, autoStructureId, parentStructureId,\n\t\t\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getGroupId(),\n\t\t\t\t\t\texistingStructure.getStructureId(), parentStructureId,\n\t\t\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingStructure = JournalStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), structureId,\n\t\t\t\tautoStructureId, parentStructureId, structure.getName(),\n\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\tstructureIds.put(structureId, existingStructure.getStructureId());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tJournalStructure.class, structure.getId(),\n\t\t\texistingStructure.getId());\n\n\t\tif (!structureId.equals(existingStructure.getStructureId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A structure with the ID \" + structureId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingStructure.getStructureId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"d5b19bf43606241d80a2ed29828ee6d28a1314aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void exportStructure(\n\t\t\tPortletDataContext portletDataContext, Element structuresElement,\n\t\t\tJournalStructure structure)\n\t\tthrows Exception {\n\n\t\tString path = getStructurePath(portletDataContext, structure);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement structureElement = structuresElement.addElement(\"structure\");\n\n\t\tstructureElement.addAttribute(\"path\", path);\n\n\t\tstructureElement.addAttribute(\n\t\t\t\"structure-id\", String.valueOf(structure.getStructureId()));\n\n\t\tString parentStructureId = structure.getParentStructureId();\n\n\t\tif (Validator.isNotNull(parentStructureId)) {\n\t\t\tJournalStructure parentStructure =\n\t\t\t\tJournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tstructure.getGroupId(), parentStructureId);\n\n\t\t\tif (parentStructure != null) {\n\t\t\t\tstructureElement.addAttribute(\n\t\t\t\t\t\"parent-structure-uuid\", parentStructure.getUuid());\n\n\t\t\t\texportStructure(portletDataContext, structuresElement,\n\t\t\t\t\tparentStructure);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.addPermissions(\n\t\t\tJournalStructure.class, structure.getId());\n\n\t\tportletDataContext.addZipEntry(path, structure);\n\t}","id":34969,"modified_method":"protected static void exportStructure(\n\t\t\tPortletDataContext portletDataContext, Element structuresElement,\n\t\t\tJournalStructure structure)\n\t\tthrows Exception {\n\n\t\tString path = getStructurePath(portletDataContext, structure);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement structureElement = structuresElement.addElement(\"structure\");\n\n\t\tstructureElement.addAttribute(\"path\", path);\n\n\t\tstructureElement.addAttribute(\n\t\t\t\"structure-id\", structure.getStructureId());\n\n\t\tString parentStructureId = structure.getParentStructureId();\n\n\t\tif (Validator.isNotNull(parentStructureId)) {\n\t\t\ttry {\n\t\t\t\tJournalStructure parentStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\t\tstructure.getGroupId(), parentStructureId);\n\n\t\t\t\tstructureElement.addAttribute(\n\t\t\t\t\t\"parent-structure-uuid\", parentStructure.getUuid());\n\n\t\t\t\texportStructure(\n\t\t\t\t\tportletDataContext, structuresElement, parentStructure);\n\t\t\t}\n\t\t\tcatch (NoSuchStructureException nsse) {\n\t\t\t}\n\t\t}\n\n\t\tstructure.setUserUuid(structure.getUserUuid());\n\n\t\tportletDataContext.addPermissions(\n\t\t\tJournalStructure.class, structure.getId());\n\n\t\tportletDataContext.addZipEntry(path, structure);\n\t}","commit_id":"d5b19bf43606241d80a2ed29828ee6d28a1314aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected PortletPreferences doImportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences, String data)\n\t\tthrows Exception {\n\n\t\tif (Validator.isNull(data)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(data);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tJournalPortletDataHandlerImpl.importReferencedData(\n\t\t\tportletDataContext, rootElement);\n\n\t\tList<Element> structureElements = rootElement.elements(\"structure\");\n\n\t\tfor (Element structureElement : structureElements) {\n\t\t\tJournalPortletDataHandlerImpl.importStructure(\n\t\t\t\tportletDataContext, structureElement, rootElement);\n\t\t}\n\n\t\tList<Element> templateElements = rootElement.elements(\"template\");\n\n\t\tfor (Element templateElement : templateElements) {\n\t\t\tJournalPortletDataHandlerImpl.importTemplate(\n\t\t\t\tportletDataContext, templateElement);\n\t\t}\n\n\t\tMap<String, String> articleIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\tLayout layout = LayoutLocalServiceUtil.getLayout(\n\t\t\tportletDataContext.getPlid());\n\n\t\tElement footerArticleElement = rootElement.element(\"footer-article\");\n\n\t\tif (footerArticleElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\tportletDataContext, footerArticleElement);\n\t\t}\n\n\t\tString[] footerArticleValues = portletPreferences.getValues(\n\t\t\t\"footerArticleValues\", new String[] {\"0\", \"\"});\n\n\t\tString footerArticleId = footerArticleValues[1];\n\n\t\tif (Validator.isNotNull(footerArticleId)) {\n\t\t\tfooterArticleId = MapUtil.getString(\n\t\t\t\tarticleIds, footerArticleId, footerArticleId);\n\n\t\t\tportletPreferences.setValues(\n\t\t\t\t\"footerArticleValues\",\n\t\t\t\tnew String[] {\n\t\t\t\t\tString.valueOf(portletDataContext.getScopeGroupId()),\n\t\t\t\t\tfooterArticleId\n\t\t\t\t});\n\n\t\t\tJournalContentSearchLocalServiceUtil.updateContentSearch(\n\t\t\t\tportletDataContext.getScopeGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), portletId, footerArticleId, true);\n\t\t}\n\n\t\tElement headerArticleElement = rootElement.element(\"header-article\");\n\n\t\tif (headerArticleElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\tportletDataContext, headerArticleElement);\n\t\t}\n\n\t\tString[] headerArticleValues = portletPreferences.getValues(\n\t\t\t\"headerArticleValues\", new String[] {\"0\", \"\"});\n\n\t\tString headerArticleId = headerArticleValues[1];\n\n\t\tif (Validator.isNotNull(headerArticleId)) {\n\t\t\theaderArticleId = MapUtil.getString(\n\t\t\t\tarticleIds, headerArticleId, headerArticleId);\n\n\t\t\tportletPreferences.setValues(\n\t\t\t\t\"headerArticleValues\",\n\t\t\t\tnew String[] {\n\t\t\t\t\tString.valueOf(portletDataContext.getScopeGroupId()),\n\t\t\t\t\theaderArticleId\n\t\t\t\t});\n\n\t\t\tJournalContentSearchLocalServiceUtil.updateContentSearch(\n\t\t\t\tportletDataContext.getScopeGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), portletId, headerArticleId, true);\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","id":34970,"modified_method":"protected PortletPreferences doImportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences, String data)\n\t\tthrows Exception {\n\n\t\tif (Validator.isNull(data)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(data);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tJournalPortletDataHandlerImpl.importReferencedData(\n\t\t\tportletDataContext, rootElement);\n\n\t\tList<Element> structureElements = rootElement.elements(\"structure\");\n\n\t\tfor (Element structureElement : structureElements) {\n\t\t\tJournalPortletDataHandlerImpl.importStructure(\n\t\t\t\tportletDataContext, structureElement);\n\t\t}\n\n\t\tList<Element> templateElements = rootElement.elements(\"template\");\n\n\t\tfor (Element templateElement : templateElements) {\n\t\t\tJournalPortletDataHandlerImpl.importTemplate(\n\t\t\t\tportletDataContext, templateElement);\n\t\t}\n\n\t\tMap<String, String> articleIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\tLayout layout = LayoutLocalServiceUtil.getLayout(\n\t\t\tportletDataContext.getPlid());\n\n\t\tElement footerArticleElement = rootElement.element(\"footer-article\");\n\n\t\tif (footerArticleElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\tportletDataContext, footerArticleElement);\n\t\t}\n\n\t\tString[] footerArticleValues = portletPreferences.getValues(\n\t\t\t\"footerArticleValues\", new String[] {\"0\", \"\"});\n\n\t\tString footerArticleId = footerArticleValues[1];\n\n\t\tif (Validator.isNotNull(footerArticleId)) {\n\t\t\tfooterArticleId = MapUtil.getString(\n\t\t\t\tarticleIds, footerArticleId, footerArticleId);\n\n\t\t\tportletPreferences.setValues(\n\t\t\t\t\"footerArticleValues\",\n\t\t\t\tnew String[] {\n\t\t\t\t\tString.valueOf(portletDataContext.getScopeGroupId()),\n\t\t\t\t\tfooterArticleId\n\t\t\t\t});\n\n\t\t\tJournalContentSearchLocalServiceUtil.updateContentSearch(\n\t\t\t\tportletDataContext.getScopeGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), portletId, footerArticleId, true);\n\t\t}\n\n\t\tElement headerArticleElement = rootElement.element(\"header-article\");\n\n\t\tif (headerArticleElement != null) {\n\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\tportletDataContext, headerArticleElement);\n\t\t}\n\n\t\tString[] headerArticleValues = portletPreferences.getValues(\n\t\t\t\"headerArticleValues\", new String[] {\"0\", \"\"});\n\n\t\tString headerArticleId = headerArticleValues[1];\n\n\t\tif (Validator.isNotNull(headerArticleId)) {\n\t\t\theaderArticleId = MapUtil.getString(\n\t\t\t\tarticleIds, headerArticleId, headerArticleId);\n\n\t\t\tportletPreferences.setValues(\n\t\t\t\t\"headerArticleValues\",\n\t\t\t\tnew String[] {\n\t\t\t\t\tString.valueOf(portletDataContext.getScopeGroupId()),\n\t\t\t\t\theaderArticleId\n\t\t\t\t});\n\n\t\t\tJournalContentSearchLocalServiceUtil.updateContentSearch(\n\t\t\t\tportletDataContext.getScopeGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), portletId, headerArticleId, true);\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","commit_id":"d5b19bf43606241d80a2ed29828ee6d28a1314aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String doExportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tportletDataContext.addPermissions(\n\t\t\t\"com.liferay.portlet.journal\",\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tString articleId = portletPreferences.getValue(\"article-id\", null);\n\n\t\tif (articleId == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No article id found in preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tlong articleGroupId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"group-id\", StringPool.BLANK));\n\n\t\tif (articleGroupId <= 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No group id found in preferences of portlet \" + portletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tJournalArticle article = null;\n\n\t\ttry {\n\t\t\tarticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tarticleGroupId, articleId, WorkflowConstants.STATUS_APPROVED);\n\t\t}\n\t\tcatch (NoSuchArticleException nsae) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No approved article found with group id \" +\n\t\t\t\t\t\tarticleGroupId + \" and article id \" + articleId);\n\t\t\t}\n\t\t}\n\n\t\tif (article == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"journal-content-data\");\n\n\t\tString path = JournalPortletDataHandlerImpl.getArticlePath(\n\t\t\tportletDataContext, article);\n\n\t\tElement articleElement = rootElement.addElement(\"article\");\n\n\t\tarticleElement.addAttribute(\"path\", path);\n\n\t\tElement dlFoldersElement = rootElement.addElement(\"dl-folders\");\n\t\tElement dlFilesElement = rootElement.addElement(\"dl-file-entries\");\n\t\tElement dlFileRanksElement = rootElement.addElement(\"dl-file-ranks\");\n\t\tElement igFoldersElement = rootElement.addElement(\"ig-folders\");\n\t\tElement igImagesElement = rootElement.addElement(\"ig-images\");\n\n\t\tJournalPortletDataHandlerImpl.exportArticle(\n\t\t\tportletDataContext, rootElement, rootElement, rootElement,\n\t\t\tdlFoldersElement, dlFilesElement, dlFileRanksElement,\n\t\t\tigFoldersElement, igImagesElement, article, false);\n\n\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\tarticle.getCompanyId());\n\n\t\tString structureId = article.getStructureId();\n\n\t\tif (Validator.isNotNull(structureId)) {\n\t\t\tJournalStructure structure = null;\n\n\t\t\ttry {\n\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tarticle.getGroupId(), structureId);\n\t\t\t}\n\t\t\tcatch (NoSuchStructureException nsse) {\n\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tcompanyGroup.getGroupId(), structureId);\n\t\t\t}\n\n\t\t\tJournalPortletDataHandlerImpl.exportStructure(\n\t\t\t\tportletDataContext, rootElement, structure);\n\t\t}\n\n\t\tString templateId = article.getTemplateId();\n\n\t\tif (Validator.isNotNull(templateId)) {\n\t\t\tJournalTemplate template = null;\n\n\t\t\ttry {\n\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), templateId);\n\t\t\t}\n\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\tcompanyGroup.getGroupId(), templateId);\n\t\t\t}\n\n\t\t\tJournalPortletDataHandlerImpl.exportTemplate(\n\t\t\t\tportletDataContext, rootElement, dlFoldersElement,\n\t\t\t\tdlFilesElement, dlFileRanksElement, igFoldersElement,\n\t\t\t\tigImagesElement, template, false);\n\t\t}\n\n\t\treturn document.formattedString();\n\t}","id":34971,"modified_method":"protected String doExportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tportletDataContext.addPermissions(\n\t\t\t\"com.liferay.portlet.journal\",\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tString articleId = portletPreferences.getValue(\"article-id\", null);\n\n\t\tif (articleId == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No article id found in preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tlong articleGroupId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"group-id\", StringPool.BLANK));\n\n\t\tif (articleGroupId <= 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No group id found in preferences of portlet \" + portletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tJournalArticle article = null;\n\n\t\ttry {\n\t\t\tarticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tarticleGroupId, articleId, WorkflowConstants.STATUS_APPROVED);\n\t\t}\n\t\tcatch (NoSuchArticleException nsae) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No approved article found with group id \" +\n\t\t\t\t\t\tarticleGroupId + \" and article id \" + articleId);\n\t\t\t}\n\t\t}\n\n\t\tif (article == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"journal-content-data\");\n\n\t\tString path = JournalPortletDataHandlerImpl.getArticlePath(\n\t\t\tportletDataContext, article);\n\n\t\tElement articleElement = rootElement.addElement(\"article\");\n\n\t\tarticleElement.addAttribute(\"path\", path);\n\n\t\tElement dlFoldersElement = rootElement.addElement(\"dl-folders\");\n\t\tElement dlFilesElement = rootElement.addElement(\"dl-file-entries\");\n\t\tElement dlFileRanksElement = rootElement.addElement(\"dl-file-ranks\");\n\t\tElement igFoldersElement = rootElement.addElement(\"ig-folders\");\n\t\tElement igImagesElement = rootElement.addElement(\"ig-images\");\n\n\t\tJournalPortletDataHandlerImpl.exportArticle(\n\t\t\tportletDataContext, rootElement, rootElement, rootElement,\n\t\t\tdlFoldersElement, dlFilesElement, dlFileRanksElement,\n\t\t\tigFoldersElement, igImagesElement, article, false);\n\n\t\treturn document.formattedString();\n\t}","commit_id":"356d7aaa010bb78fc59a93d75022db136f9c7ac4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void exportArticle(\n\t\t\tPortletDataContext portletDataContext, Element articlesElement,\n\t\t\tElement structuresElement, Element templatesElement,\n\t\t\tElement dlFoldersElement, Element dlFileEntriesElement,\n\t\t\tElement dlFileRanksElement, Element igFoldersElement,\n\t\t\tElement igImagesElement, JournalArticle article,\n\t\t\tboolean checkDateRange)\n\t\tthrows Exception {\n\n\t\tif (checkDateRange &&\n\t\t\t!portletDataContext.isWithinDateRange(article.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ((article.getStatus() != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(article.getStatus() != WorkflowConstants.STATUS_EXPIRED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tString path = getArticlePath(portletDataContext, article);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clone this article to make sure changes to its content are never\n\t\t// persisted\n\n\t\tarticle = (JournalArticle)article.clone();\n\n\t\tElement articleElement = (Element)articlesElement.selectSingleNode(\n\t\t\t\"//article[@path='\".concat(path).concat(\"']\"));\n\n\t\tif (articleElement == null) {\n\t\t\tarticleElement = articlesElement.addElement(\"article\");\n\t\t}\n\n\t\tarticleElement.addAttribute(\"path\", path);\n\t\tarticleElement.addAttribute(\n\t\t\t\"article-resource-uuid\", article.getArticleResourceUuid());\n\n\t\tarticle.setUserUuid(article.getUserUuid());\n\n\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\tarticle.getCompanyId());\n\n\t\tif (Validator.isNotNull(article.getStructureId())) {\n\t\t\tJournalStructure structure = null;\n\n\t\t\ttry {\n\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tarticle.getGroupId(), article.getStructureId());\n\t\t\t}\n\t\t\tcatch (NoSuchStructureException nsse) {\n\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tcompanyGroup.getGroupId(), article.getStructureId());\n\t\t\t}\n\n\t\t\tarticleElement.addAttribute(\"structure-uuid\", structure.getUuid());\n\n\t\t\tif (structure.getGroupId() == companyGroup.getGroupId()) {\n\t\t\t\texportStructure(\n\t\t\t\t\tportletDataContext, structuresElement, structure);\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(article.getTemplateId())) {\n\t\t\tJournalTemplate template = null;\n\n\t\t\ttry {\n\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tarticle.getTemplateId());\n\t\t\t}\n\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\tcompanyGroup.getGroupId(), article.getTemplateId());\n\t\t\t}\n\n\t\t\tarticleElement.addAttribute(\"template-uuid\", template.getUuid());\n\n\t\t\tif (template.getGroupId() == companyGroup.getGroupId()) {\n\t\t\t\texportTemplate(\n\t\t\t\t\tportletDataContext, templatesElement, dlFoldersElement,\n\t\t\t\t\tdlFileEntriesElement, dlFileRanksElement, igFoldersElement,\n\t\t\t\t\tigImagesElement, template, checkDateRange);\n\t\t\t}\n\t\t}\n\n\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\tarticle.getSmallImageId());\n\n\t\tif (article.isSmallImage() && (smallImage != null)) {\n\t\t\tString smallImagePath = getArticleSmallImagePath(\n\t\t\t\tportletDataContext, article);\n\n\t\t\tarticleElement.addAttribute(\"small-image-path\", smallImagePath);\n\n\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\tportletDataContext.addZipEntry(\n\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tString imagePath = getArticleImagePath(portletDataContext, article);\n\n\t\t\tarticleElement.addAttribute(\"image-path\", imagePath);\n\n\t\t\tList<JournalArticleImage> articleImages =\n\t\t\t\tJournalArticleImageUtil.findByG_A_V(\n\t\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\t\tarticle.getVersion());\n\n\t\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\t\tImage image = null;\n\n\t\t\t\ttry {\n\t\t\t\t\timage = ImageUtil.findByPrimaryKey(\n\t\t\t\t\t\tarticleImage.getArticleImageId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString articleImagePath = getArticleImagePath(\n\t\t\t\t\tportletDataContext, article, articleImage, image);\n\n\t\t\t\tif (!portletDataContext.isPathNotProcessed(articleImagePath)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tarticleImagePath, image.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tarticle.setStatusByUserUuid(article.getStatusByUserUuid());\n\n\t\tportletDataContext.addPermissions(\n\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tportletDataContext.addComments(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tportletDataContext.addAssetTags(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t_NAMESPACE, \"embedded-assets\")) {\n\n\t\t\tString content = article.getContent();\n\n\t\t\tcontent = exportDLFileEntries(\n\t\t\t\tportletDataContext, dlFoldersElement, dlFileEntriesElement,\n\t\t\t\tdlFileRanksElement, articleElement, content, checkDateRange);\n\t\t\tcontent = exportIGImages(\n\t\t\t\tportletDataContext, igFoldersElement, igImagesElement,\n\t\t\t\tarticleElement, content, checkDateRange);\n\t\t\tcontent = exportLayoutFriendlyURLs(portletDataContext, content);\n\t\t\tcontent = exportLinksToLayout(portletDataContext, content);\n\n\t\t\tarticle.setContent(content);\n\t\t}\n\n\t\tportletDataContext.addZipEntry(path, article);\n\t}","id":34972,"modified_method":"protected static void exportArticle(\n\t\t\tPortletDataContext portletDataContext, Element articlesElement,\n\t\t\tElement structuresElement, Element templatesElement,\n\t\t\tElement dlFoldersElement, Element dlFileEntriesElement,\n\t\t\tElement dlFileRanksElement, Element igFoldersElement,\n\t\t\tElement igImagesElement, JournalArticle article,\n\t\t\tboolean checkDateRange)\n\t\tthrows Exception {\n\n\t\tif (checkDateRange &&\n\t\t\t!portletDataContext.isWithinDateRange(article.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ((article.getStatus() != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(article.getStatus() != WorkflowConstants.STATUS_EXPIRED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tString path = getArticlePath(portletDataContext, article);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clone this article to make sure changes to its content are never\n\t\t// persisted\n\n\t\tarticle = (JournalArticle)article.clone();\n\n\t\tElement articleElement = (Element)articlesElement.selectSingleNode(\n\t\t\t\"//article[@path='\".concat(path).concat(\"']\"));\n\n\t\tif (articleElement == null) {\n\t\t\tarticleElement = articlesElement.addElement(\"article\");\n\t\t}\n\n\t\tarticleElement.addAttribute(\"path\", path);\n\t\tarticleElement.addAttribute(\n\t\t\t\"article-resource-uuid\", article.getArticleResourceUuid());\n\n\t\tarticle.setUserUuid(article.getUserUuid());\n\n\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\tarticle.getCompanyId());\n\n\t\tif (Validator.isNotNull(article.getStructureId())) {\n\t\t\tJournalStructure structure = null;\n\n\t\t\ttry {\n\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tarticle.getGroupId(), article.getStructureId());\n\t\t\t}\n\t\t\tcatch (NoSuchStructureException nsse) {\n\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tcompanyGroup.getGroupId(), article.getStructureId());\n\t\t\t}\n\n\t\t\tarticleElement.addAttribute(\"structure-uuid\", structure.getUuid());\n\n\t\t\texportStructure(portletDataContext, structuresElement, structure);\n\t\t}\n\n\t\tif (Validator.isNotNull(article.getTemplateId())) {\n\t\t\tJournalTemplate template = null;\n\n\t\t\ttry {\n\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tarticle.getTemplateId());\n\t\t\t}\n\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\tcompanyGroup.getGroupId(), article.getTemplateId());\n\t\t\t}\n\n\t\t\tarticleElement.addAttribute(\"template-uuid\", template.getUuid());\n\n\t\t\texportTemplate(\n\t\t\t\tportletDataContext, templatesElement, dlFoldersElement,\n\t\t\t\tdlFileEntriesElement, dlFileRanksElement, igFoldersElement,\n\t\t\t\tigImagesElement, template, checkDateRange);\n\t\t}\n\n\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\tarticle.getSmallImageId());\n\n\t\tif (article.isSmallImage() && (smallImage != null)) {\n\t\t\tString smallImagePath = getArticleSmallImagePath(\n\t\t\t\tportletDataContext, article);\n\n\t\t\tarticleElement.addAttribute(\"small-image-path\", smallImagePath);\n\n\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\tportletDataContext.addZipEntry(\n\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tString imagePath = getArticleImagePath(portletDataContext, article);\n\n\t\t\tarticleElement.addAttribute(\"image-path\", imagePath);\n\n\t\t\tList<JournalArticleImage> articleImages =\n\t\t\t\tJournalArticleImageUtil.findByG_A_V(\n\t\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\t\tarticle.getVersion());\n\n\t\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\t\tImage image = null;\n\n\t\t\t\ttry {\n\t\t\t\t\timage = ImageUtil.findByPrimaryKey(\n\t\t\t\t\t\tarticleImage.getArticleImageId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString articleImagePath = getArticleImagePath(\n\t\t\t\t\tportletDataContext, article, articleImage, image);\n\n\t\t\t\tif (!portletDataContext.isPathNotProcessed(articleImagePath)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tarticleImagePath, image.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tarticle.setStatusByUserUuid(article.getStatusByUserUuid());\n\n\t\tportletDataContext.addPermissions(\n\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tportletDataContext.addComments(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tportletDataContext.addAssetTags(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t_NAMESPACE, \"embedded-assets\")) {\n\n\t\t\tString content = article.getContent();\n\n\t\t\tcontent = exportDLFileEntries(\n\t\t\t\tportletDataContext, dlFoldersElement, dlFileEntriesElement,\n\t\t\t\tdlFileRanksElement, articleElement, content, checkDateRange);\n\t\t\tcontent = exportIGImages(\n\t\t\t\tportletDataContext, igFoldersElement, igImagesElement,\n\t\t\t\tarticleElement, content, checkDateRange);\n\t\t\tcontent = exportLayoutFriendlyURLs(portletDataContext, content);\n\t\t\tcontent = exportLinksToLayout(portletDataContext, content);\n\n\t\t\tarticle.setContent(content);\n\t\t}\n\n\t\tportletDataContext.addZipEntry(path, article);\n\t}","commit_id":"356d7aaa010bb78fc59a93d75022db136f9c7ac4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String doExportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tString[] footerArticleValues = portletPreferences.getValues(\n\t\t\t\"footer-article-values\", new String[] {\"0\", \"\"});\n\t\tString[] headerArticleValues = portletPreferences.getValues(\n\t\t\t\"header-article-values\", new String[] {\"0\", \"\"});\n\n\t\tString footerArticleId = footerArticleValues[1];\n\t\tString headerArticleId = headerArticleValues[1];\n\n\t\tif (Validator.isNull(footerArticleId) &&\n\t\t\tValidator.isNull(headerArticleId)) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No article ids found in preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tlong footerArticleGroupId = GetterUtil.getLong(footerArticleValues[0]);\n\t\tlong headerArticleGroupId = GetterUtil.getLong(headerArticleValues[0]);\n\n\t\tif ((footerArticleGroupId <= 0) && (headerArticleGroupId <= 0)) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No group ids found in preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tList<JournalArticle> articles = new ArrayList<JournalArticle>(2);\n\n\t\tJournalArticle footerArticle = null;\n\n\t\ttry {\n\t\t\tfooterArticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tfooterArticleGroupId, footerArticleId,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tarticles.add(footerArticle);\n\t\t}\n\t\tcatch (NoSuchArticleException nsae) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No approved article found with group id \" +\n\t\t\t\t\t\tfooterArticleGroupId + \" and article id \" +\n\t\t\t\t\t\t\tfooterArticleId);\n\t\t\t}\n\t\t}\n\n\t\tJournalArticle headerArticle = null;\n\n\t\ttry {\n\t\t\theaderArticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\theaderArticleGroupId, headerArticleId,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tarticles.add(headerArticle);\n\t\t}\n\t\tcatch (NoSuchArticleException nsae) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No approved article found with group id \" +\n\t\t\t\t\t\theaderArticleGroupId + \" and article id \" +\n\t\t\t\t\t\t\theaderArticleId);\n\t\t\t}\n\t\t}\n\n\t\tif ((footerArticle == null) && (headerArticle == null)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"journal-content-data\");\n\n\t\tElement dlFoldersElement = rootElement.addElement(\"dl-folders\");\n\t\tElement dlFilesElement = rootElement.addElement(\"dl-file-entries\");\n\t\tElement dlFileRanksElement = rootElement.addElement(\"dl-file-ranks\");\n\t\tElement igFoldersElement = rootElement.addElement(\"ig-folders\");\n\t\tElement igImagesElement = rootElement.addElement(\"ig-images\");\n\n\t\tfor (JournalArticle article : articles) {\n\t\t\tString path = JournalPortletDataHandlerImpl.getArticlePath(\n\t\t\t\tportletDataContext, article);\n\n\t\t\tElement articleElement = null;\n\n\t\t\tif (article == footerArticle) {\n\t\t\t\tarticleElement = rootElement.addElement(\"footer-article\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarticleElement = rootElement.addElement(\"header-article\");\n\t\t\t}\n\n\t\t\tarticleElement.addAttribute(\"path\", path);\n\n\t\t\tJournalPortletDataHandlerImpl.exportArticle(\n\t\t\t\tportletDataContext, rootElement, rootElement, rootElement,\n\t\t\t\tdlFoldersElement, dlFilesElement, dlFileRanksElement,\n\t\t\t\tigFoldersElement, igImagesElement, article, false);\n\n\t\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\tarticle.getCompanyId());\n\n\t\t\tString structureId = article.getStructureId();\n\n\t\t\tif (Validator.isNotNull(structureId)) {\n\t\t\t\tJournalStructure structure = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\t\tarticle.getGroupId(), structureId);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchStructureException nsse) {\n\t\t\t\t\tstructure = JournalStructureLocalServiceUtil.getStructure(\n\t\t\t\t\t\tcompanyGroup.getGroupId(), structureId);\n\t\t\t\t}\n\n\t\t\t\tJournalPortletDataHandlerImpl.exportStructure(\n\t\t\t\t\tportletDataContext, rootElement, structure);\n\t\t\t}\n\n\t\t\tString templateId = article.getTemplateId();\n\n\t\t\tif (Validator.isNotNull(templateId)) {\n\t\t\t\tJournalTemplate template = null;\n\n\t\t\t\ttry {\n\t\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), templateId);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\t\ttemplate = JournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\t\tcompanyGroup.getGroupId(), templateId);\n\t\t\t\t}\n\n\t\t\t\tJournalPortletDataHandlerImpl.exportTemplate(\n\t\t\t\t\tportletDataContext, rootElement, dlFoldersElement,\n\t\t\t\t\tdlFilesElement, dlFileRanksElement, igFoldersElement,\n\t\t\t\t\tigImagesElement, template, false);\n\t\t\t}\n\t\t}\n\n\t\treturn document.formattedString();\n\t}","id":34973,"modified_method":"protected String doExportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tString[] footerArticleValues = portletPreferences.getValues(\n\t\t\t\"footer-article-values\", new String[] {\"0\", \"\"});\n\t\tString[] headerArticleValues = portletPreferences.getValues(\n\t\t\t\"header-article-values\", new String[] {\"0\", \"\"});\n\n\t\tString footerArticleId = footerArticleValues[1];\n\t\tString headerArticleId = headerArticleValues[1];\n\n\t\tif (Validator.isNull(footerArticleId) &&\n\t\t\tValidator.isNull(headerArticleId)) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No article ids found in preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tlong footerArticleGroupId = GetterUtil.getLong(footerArticleValues[0]);\n\t\tlong headerArticleGroupId = GetterUtil.getLong(headerArticleValues[0]);\n\n\t\tif ((footerArticleGroupId <= 0) && (headerArticleGroupId <= 0)) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No group ids found in preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tList<JournalArticle> articles = new ArrayList<JournalArticle>(2);\n\n\t\tJournalArticle footerArticle = null;\n\n\t\ttry {\n\t\t\tfooterArticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tfooterArticleGroupId, footerArticleId,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tarticles.add(footerArticle);\n\t\t}\n\t\tcatch (NoSuchArticleException nsae) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No approved article found with group id \" +\n\t\t\t\t\t\tfooterArticleGroupId + \" and article id \" +\n\t\t\t\t\t\t\tfooterArticleId);\n\t\t\t}\n\t\t}\n\n\t\tJournalArticle headerArticle = null;\n\n\t\ttry {\n\t\t\theaderArticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\theaderArticleGroupId, headerArticleId,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tarticles.add(headerArticle);\n\t\t}\n\t\tcatch (NoSuchArticleException nsae) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No approved article found with group id \" +\n\t\t\t\t\t\theaderArticleGroupId + \" and article id \" +\n\t\t\t\t\t\t\theaderArticleId);\n\t\t\t}\n\t\t}\n\n\t\tif ((footerArticle == null) && (headerArticle == null)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"journal-content-data\");\n\n\t\tElement dlFoldersElement = rootElement.addElement(\"dl-folders\");\n\t\tElement dlFilesElement = rootElement.addElement(\"dl-file-entries\");\n\t\tElement dlFileRanksElement = rootElement.addElement(\"dl-file-ranks\");\n\t\tElement igFoldersElement = rootElement.addElement(\"ig-folders\");\n\t\tElement igImagesElement = rootElement.addElement(\"ig-images\");\n\n\t\tfor (JournalArticle article : articles) {\n\t\t\tString path = JournalPortletDataHandlerImpl.getArticlePath(\n\t\t\t\tportletDataContext, article);\n\n\t\t\tElement articleElement = null;\n\n\t\t\tif (article == footerArticle) {\n\t\t\t\tarticleElement = rootElement.addElement(\"footer-article\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarticleElement = rootElement.addElement(\"header-article\");\n\t\t\t}\n\n\t\t\tarticleElement.addAttribute(\"path\", path);\n\n\t\t\tJournalPortletDataHandlerImpl.exportArticle(\n\t\t\t\tportletDataContext, rootElement, rootElement, rootElement,\n\t\t\t\tdlFoldersElement, dlFilesElement, dlFileRanksElement,\n\t\t\t\tigFoldersElement, igImagesElement, article, false);\n\t\t}\n\n\t\treturn document.formattedString();\n\t}","commit_id":"356d7aaa010bb78fc59a93d75022db136f9c7ac4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tString articleId = prefs.getValue(\"article-id\", null);\n\n\t\t\tif (articleId == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No article id found in preferences of portlet \" +\n\t\t\t\t\t\t\tportletId);\n\t\t\t\t}\n\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tlong articleGroupId = GetterUtil.getLong(\n\t\t\t\tprefs.getValue(\"group-id\", StringPool.BLANK));\n\n\t\t\tif (articleGroupId <= 0) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No group id found in preferences of portlet \" +\n\t\t\t\t\t\t\tportletId);\n\t\t\t\t}\n\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tJournalArticle article = null;\n\n\t\t\ttry {\n\t\t\t\tarticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\t\tarticleGroupId, articleId);\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(nsae);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (article == null) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"journal-content\");\n\n\t\t\tList<Element> content = root.content();\n\n\t\t\tif (!context.addPrimaryKey(\n\t\t\t\t\tJournalArticle.class, article.getPrimaryKeyObj())) {\n\n\t\t\t\tJournalPortletDataHandlerImpl.exportArticle(context, article);\n\n\t\t\t\tString xml = xStream.toXML(article);\n\n\t\t\t\tDocument tempDoc = DocumentUtil.readDocumentFromXML(xml);\n\n\t\t\t\tcontent.add(tempDoc.getRootElement().createCopy());\n\t\t\t}\n\n\t\t\tString structureId = article.getStructureId();\n\n\t\t\tif (Validator.isNotNull(structureId)) {\n\t\t\t\tJournalStructure structure = JournalStructureUtil.findByG_S(\n\t\t\t\t\tarticle.getGroupId(), structureId);\n\n\t\t\t\tif (!context.addPrimaryKey(\n\t\t\t\t\t\tJournalStructure.class, structure.getPrimaryKeyObj())) {\n\n\t\t\t\t\tJournalPortletDataHandlerImpl.exportStructure(structure);\n\n\t\t\t\t\tString xml = xStream.toXML(structure);\n\n\t\t\t\t\tDocument tempDoc = DocumentUtil.readDocumentFromXML(xml);\n\n\t\t\t\t\tcontent.add(tempDoc.getRootElement().createCopy());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString templateId = article.getTemplateId();\n\n\t\t\tif (Validator.isNotNull(templateId)) {\n\t\t\t\tJournalTemplate template = JournalTemplateUtil.findByG_T(\n\t\t\t\t\tarticle.getGroupId(), templateId);\n\n\t\t\t\tif (!context.addPrimaryKey(\n\t\t\t\t\t\tJournalTemplate.class, template.getPrimaryKeyObj())) {\n\n\t\t\t\t\tJournalPortletDataHandlerImpl.exportTemplate(\n\t\t\t\t\t\tcontext, template);\n\n\t\t\t\t\tString xml = xStream.toXML(template);\n\n\t\t\t\t\tDocument tempDoc = DocumentUtil.readDocumentFromXML(xml);\n\n\t\t\t\t\tcontent.add(tempDoc.getRootElement().createCopy());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn doc.asXML();\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":34974,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tString articleId = prefs.getValue(\"article-id\", null);\n\n\t\t\tif (articleId == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No article id found in preferences of portlet \" +\n\t\t\t\t\t\t\tportletId);\n\t\t\t\t}\n\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tlong articleGroupId = GetterUtil.getLong(\n\t\t\t\tprefs.getValue(\"group-id\", StringPool.BLANK));\n\n\t\t\tif (articleGroupId <= 0) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No group id found in preferences of portlet \" +\n\t\t\t\t\t\t\tportletId);\n\t\t\t\t}\n\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tJournalArticle article = null;\n\n\t\t\ttry {\n\t\t\t\tarticle = JournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\t\tarticleGroupId, articleId);\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(nsae);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (article == null) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"journal-content\");\n\n\t\t\tJournalPortletDataHandlerImpl.exportArticle(context, root, article);\n\n\t\t\tString structureId = article.getStructureId();\n\n\t\t\tif (Validator.isNotNull(structureId)) {\n\t\t\t\tJournalStructure structure = JournalStructureUtil.findByG_S(\n\t\t\t\t\tarticle.getGroupId(), structureId);\n\n\t\t\t\tJournalPortletDataHandlerImpl.exportStructure(\n\t\t\t\t\tcontext, root, structure);\n\t\t\t}\n\n\t\t\tString templateId = article.getTemplateId();\n\n\t\t\tif (Validator.isNotNull(templateId)) {\n\t\t\t\tJournalTemplate template = JournalTemplateUtil.findByG_T(\n\t\t\t\t\tarticle.getGroupId(), templateId);\n\n\t\t\t\tJournalPortletDataHandlerImpl.exportTemplate(\n\t\t\t\t\tcontext, root, template);\n\t\t\t}\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tif (Validator.isNull(data)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentUtil.readDocumentFromXML(data);\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\tElement el = root.element(JournalStructureImpl.class.getName());\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\tMap<String, String> structureIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\t\tif (el != null) {\n\t\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\t\tJournalStructure structure = (JournalStructure)xStream.fromXML(\n\t\t\t\t\ttempDoc.asXML());\n\n\t\t\t\tJournalPortletDataHandlerImpl.importStructure(\n\t\t\t\t\tcontext, structureIds, structure);\n\t\t\t}\n\n\t\t\tel = root.element(JournalTemplateImpl.class.getName());\n\n\t\t\tMap<String, String> templateIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalTemplate.class);\n\n\t\t\tif (el != null) {\n\t\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\t\tJournalTemplate template = (JournalTemplate)xStream.fromXML(\n\t\t\t\t\ttempDoc.asXML());\n\n\t\t\t\tJournalPortletDataHandlerImpl.importTemplate(\n\t\t\t\t\tcontext, structureIds, templateIds, template);\n\t\t\t}\n\n\t\t\tel = root.element(JournalArticleImpl.class.getName());\n\n\t\t\tMap<String, String> articleIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\t\tif (el != null) {\n\t\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\t\tJournalArticle article = (JournalArticle)xStream.fromXML(\n\t\t\t\t\ttempDoc.asXML());\n\n\t\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\t\tcontext, structureIds, templateIds, articleIds, article);\n\t\t\t}\n\n\t\t\tString articleId = prefs.getValue(\"article-id\", StringPool.BLANK);\n\n\t\t\tif (Validator.isNotNull(articleId)) {\n\t\t\t\tarticleId = MapUtil.getString(articleIds, articleId, articleId);\n\n\t\t\t\tprefs.setValue(\n\t\t\t\t\t\"group-id\", String.valueOf(context.getGroupId()));\n\t\t\t\tprefs.setValue(\"article-id\", articleId);\n\t\t\t}\n\n\t\t\treturn prefs;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":34975,"modified_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tif (Validator.isNull(data)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tDocument doc = DocumentUtil.readDocumentFromXML(data);\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\tElement el = root.element(\"structure\");\n\n\t\t\tMap<String, String> structureIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\t\tif (el != null) {\n\t\t\t\tJournalPortletDataHandlerImpl.importStructure(\n\t\t\t\t\tcontext, structureIds, el);\n\t\t\t}\n\n\t\t\tel = root.element(\"template\");\n\n\t\t\tMap<String, String> templateIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalTemplate.class);\n\n\t\t\tif (el != null) {\n\t\t\t\tJournalPortletDataHandlerImpl.importTemplate(\n\t\t\t\t\tcontext, structureIds, templateIds, el);\n\t\t\t}\n\n\t\t\tel = root.element(\"article\");\n\n\t\t\tMap<String, String> articleIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\t\tif (el != null) {\n\t\t\t\tJournalPortletDataHandlerImpl.importArticle(\n\t\t\t\t\tcontext, structureIds, templateIds, articleIds, el);\n\t\t\t}\n\n\t\t\tString articleId = prefs.getValue(\"article-id\", StringPool.BLANK);\n\n\t\t\tif (Validator.isNotNull(articleId)) {\n\t\t\t\tarticleId = MapUtil.getString(articleIds, articleId, articleId);\n\n\t\t\t\tprefs.setValue(\n\t\t\t\t\t\"group-id\", String.valueOf(context.getGroupId()));\n\t\t\t\tprefs.setValue(\"article-id\", articleId);\n\t\t\t}\n\n\t\t\treturn prefs;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void exportArticle(\n\t\t\tPortletDataContext context, JournalArticle article)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tarticle.setUserUuid(article.getUserUuid());\n\t\tarticle.setApprovedByUserUuid(article.getApprovedByUserUuid());\n\n\t\tif (article.isSmallImage()) {\n\t\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\tarticle.getSmallImageId());\n\n\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\tcontext.getZipWriter().addEntry(\n\t\t\t\tgetSmallImageDir(article), smallImage.getTextObj());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tList<JournalArticleImage> articleImages =\n\t\t\t\tJournalArticleImageUtil.findByG_A_V(\n\t\t\t\t\tcontext.getGroupId(), article.getArticleId(),\n\t\t\t\t\tarticle.getVersion());\n\n\t\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\t\ttry {\n\t\t\t\t\tImage image = ImageUtil.findByPrimaryKey(\n\t\t\t\t\t\tarticleImage.getArticleImageId());\n\n\t\t\t\t\tString fileName =\n\t\t\t\t\t\tarticleImage.getElName() +\n\t\t\t\t\t\t\tarticleImage.getLanguageId() + \".\" +\n\t\t\t\t\t\t\t\timage.getType();\n\n\t\t\t\t\tcontext.getZipWriter().addEntry(\n\t\t\t\t\t\tgetArticleImageDir(article) + fileName,\n\t\t\t\t\t\timage.getTextObj());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.addComments(\n\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()));\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.addRatingsEntries(\n\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()));\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tcontext.addTagsEntries(\n\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()));\n\t\t}\n\t}","id":34976,"modified_method":"public static void exportArticle(\n\t\t\tPortletDataContext context, Element el, JournalArticle article)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tif (context.isWithinDateRange(article.getModifiedDate())) {\n\t\t\tString path = getArticlePath(context, article);\n\n\t\t\tel.addElement(\"article\").addAttribute(\"path\", path);\n\n\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\tif (article.isSmallImage()) {\n\t\t\t\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\t\t\tarticle.getSmallImageId());\n\n\t\t\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\t\t\tcontext.addZipEntry(\n\t\t\t\t\t\tgetSmallImagePath(context, article),\n\t\t\t\t\t\tsmallImage.getTextObj());\n\t\t\t\t}\n\n\t\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\t\t\tList<JournalArticleImage> articleImages =\n\t\t\t\t\t\tJournalArticleImageUtil.findByG_A_V(\n\t\t\t\t\t\t\tcontext.getGroupId(), article.getArticleId(),\n\t\t\t\t\t\t\tarticle.getVersion());\n\n\t\t\t\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tImage image = ImageUtil.findByPrimaryKey(\n\t\t\t\t\t\t\t\tarticleImage.getArticleImageId());\n\n\t\t\t\t\t\t\tString imagePath = getArticleImagePath(\n\t\t\t\t\t\t\t\tcontext, article, articleImage, image);\n\n\t\t\t\t\t\t\tcontext.addZipEntry(\n\t\t\t\t\t\t\t\timagePath, image.getTextObj());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\t\tcontext.addComments(\n\t\t\t\t\t\tJournalArticle.class,\n\t\t\t\t\t\tnew Long(article.getResourcePrimKey()));\n\t\t\t\t}\n\n\t\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\t\tcontext.addRatingsEntries(\n\t\t\t\t\t\tJournalArticle.class,\n\t\t\t\t\t\tnew Long(article.getResourcePrimKey()));\n\t\t\t\t}\n\n\t\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\t\tcontext.addTagsEntries(\n\t\t\t\t\t\tJournalArticle.class,\n\t\t\t\t\t\tnew Long(article.getResourcePrimKey()));\n\t\t\t\t}\n\n\t\t\t\tarticle.setUserUuid(article.getUserUuid());\n\t\t\t\tarticle.setApprovedByUserUuid(article.getApprovedByUserUuid());\n\n\t\t\t\tcontext.addZipEntry(path, article);\n\t\t\t}\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"journal-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Structures\n\n\t\t\tList<JournalStructure> structures =\n\t\t\t\tJournalStructureUtil.findByGroupId(\n\t\t\t\t\tcontext.getGroupId());\n\n\t\t\tIterator<JournalStructure> structuresItr = structures.iterator();\n\n\t\t\twhile (structuresItr.hasNext()) {\n\t\t\t\tJournalStructure structure = structuresItr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tJournalStructure.class, structure.getPrimaryKeyObj())) {\n\n\t\t\t\t\tstructuresItr.remove();\n\t\t\t\t}\n\t\t\t\telse if (!context.isWithinDateRange(\n\t\t\t\t\t\t\tstructure.getModifiedDate())) {\n\n\t\t\t\t\tstructuresItr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texportStructure(structure);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(structures);\n\n\t\t\tDocument tempDoc = DocumentUtil.readDocumentFromXML(xml);\n\n\t\t\tElement el = root.addElement(\"journal-structures\");\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Templates\n\n\t\t\tList<JournalTemplate> templates =\n\t\t\t\tJournalTemplateUtil.findByGroupId(context.getGroupId());\n\n\t\t\tIterator<JournalTemplate> templatesItr = templates.iterator();\n\n\t\t\twhile (templatesItr.hasNext()) {\n\t\t\t\tJournalTemplate template = templatesItr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tJournalTemplate.class, template.getPrimaryKeyObj())) {\n\n\t\t\t\t\ttemplatesItr.remove();\n\t\t\t\t}\n\t\t\t\telse if (!context.isWithinDateRange(\n\t\t\t\t\t\t\ttemplate.getModifiedDate())) {\n\n\t\t\t\t\ttemplatesItr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texportTemplate(context, template);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(templates);\n\n\t\t\tel = root.addElement(\"journal-templates\");\n\n\t\t\ttempDoc = DocumentUtil.readDocumentFromXML(xml);\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\t// Articles\n\n\t\t\tList<JournalArticle> articles = JournalArticleUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tIterator<JournalArticle> articlesItr = articles.iterator();\n\n\t\t\twhile (articlesItr.hasNext()) {\n\t\t\t\tJournalArticle article = articlesItr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tJournalArticle.class, article.getPrimaryKeyObj())) {\n\n\t\t\t\t\tarticlesItr.remove();\n\t\t\t\t}\n\t\t\t\telse if (!context.isWithinDateRange(\n\t\t\t\t\t\t\tarticle.getModifiedDate())) {\n\n\t\t\t\t\tarticlesItr.remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texportArticle(context, article);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txml = xStream.toXML(articles);\n\n\t\t\tel = root.addElement(\"journal-articles\");\n\n\t\t\ttempDoc = DocumentUtil.readDocumentFromXML(xml);\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn doc.asXML();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":34977,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"journal-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Structures\n\n\t\t\tElement el = root.addElement(\"journal-structures\");\n\n\t\t\tList<JournalStructure> structures =\n\t\t\t\tJournalStructureUtil.findByGroupId(\n\t\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (JournalStructure structure : structures) {\n\t\t\t\texportStructure(context, el, structure);\n\t\t\t}\n\n\t\t\t// Templates\n\n\t\t\tel = root.addElement(\"journal-templates\");\n\n\t\t\tList<JournalTemplate> templates =\n\t\t\t\tJournalTemplateUtil.findByGroupId(context.getGroupId());\n\n\t\t\tfor (JournalTemplate template : templates) {\n\t\t\t\texportTemplate(context, el, template);\n\t\t\t}\n\n\t\t\t// Articles\n\n\t\t\tel = root.addElement(\"journal-articles\");\n\n\t\t\tList<JournalArticle> articles = JournalArticleUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (JournalArticle article : articles) {\n\t\t\t\tif (context.isWithinDateRange(article.getModifiedDate())) {\n\t\t\t\t\texportArticle(context, el, article);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void exportTemplate(\n\t\t\tPortletDataContext context, JournalTemplate template)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\ttemplate.setUserUuid(template.getUserUuid());\n\n\t\tif (template.isSmallImage()) {\n\t\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\tcontext.getZipWriter().addEntry(\n\t\t\t\tgetSmallImageDir(template), smallImage.getTextObj());\n\t\t}\n\t}","id":34978,"modified_method":"public static void exportTemplate(\n\t\t\tPortletDataContext context, Element el, JournalTemplate template)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (context.isWithinDateRange(template.getModifiedDate())) {\n\t\t\tString path = getTemplatePath(context, template);\n\n\t\t\tel.addElement(\"template\").addAttribute(\"path\", path);\n\n\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\tif (template.isSmallImage()) {\n\t\t\t\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\t\t\tcontext.addZipEntry(\n\t\t\t\t\t\tgetSmallImagePath(context, template),\n\t\t\t\t\t\tsmallImage.getTextObj());\n\t\t\t\t}\n\n\t\t\t\ttemplate.setUserUuid(template.getUserUuid());\n\n\t\t\t\tcontext.addZipEntry(path, template);\n\t\t\t}\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences deleteData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tif (!context.addPrimaryKey(\n\t\t\t\t\tJournalPortletDataHandlerImpl.class, \"deleteData\")) {\n\n\t\t\t\tList<JournalArticle> articles =\n\t\t\t\t\tJournalArticleUtil.findByGroupId(\n\t\t\t\t\t\tcontext.getGroupId());\n\n\t\t\t\tfor (JournalArticle article : articles) {\n\n\t\t\t\t\t// Templates\n\n\t\t\t\t\tJournalTemplateLocalServiceUtil.deleteTemplate(\n\t\t\t\t\t\tcontext.getGroupId(), article.getTemplateId());\n\n\t\t\t\t\t// Structures\n\n\t\t\t\t\tJournalStructureLocalServiceUtil.deleteStructure(\n\t\t\t\t\t\tcontext.getGroupId(), article.getStructureId());\n\t\t\t\t}\n\n\t\t\t\t// Articles\n\n\t\t\t\tJournalArticleLocalServiceUtil.deleteArticles(\n\t\t\t\t\tcontext.getGroupId());\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":34979,"modified_method":"public PortletPreferences deleteData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tif (!context.addPrimaryKey(\n\t\t\t\t\tJournalPortletDataHandlerImpl.class, \"deleteData\")) {\n\n\t\t\t\t// Articles\n\n\t\t\t\tJournalArticleLocalServiceUtil.deleteArticles(\n\t\t\t\t\tcontext.getGroupId());\n\n\t\t\t\t// Templates\n\n\t\t\t\tJournalTemplateLocalServiceUtil.deleteTemplates(\n\t\t\t\t\tcontext.getGroupId());\n\n\t\t\t\t// Structures\n\n\t\t\t\tJournalStructureLocalServiceUtil.deleteStructures(\n\t\t\t\t\tcontext.getGroupId());\n\t\t\t}\n\n\t\t\treturn prefs;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importStructure(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tJournalStructure structure)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(structure.getUserUuid());\n\t\tlong plid = context.getPlid();\n\n\t\tString structureId = structure.getStructureId();\n\t\tboolean autoStructureId = false;\n\n\t\tif ((Validator.isNumber(structureId)) ||\n\t\t\t(JournalStructureUtil.fetchByG_S(\n\t\t\t\tcontext.getGroupId(), structureId) != null)) {\n\n\t\t\tautoStructureId = true;\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(context, structure);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(context, structure);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tcontext, structure);\n\n\t\tJournalStructure existingStructure = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingStructure = JournalStructureUtil.fetchByUUID_G(\n\t\t\t\tstructure.getUuid(), context.getGroupId());\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\t\tstructure.getUuid(), userId, structureId,\n\t\t\t\t\t\tautoStructureId, plid, structure.getName(),\n\t\t\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getGroupId(),\n\t\t\t\t\t\texistingStructure.getStructureId(), structure.getName(),\n\t\t\t\t\t\tstructure.getDescription(), structure.getXsd());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingStructure =\n\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\tuserId, structureId, autoStructureId, plid,\n\t\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\t\tstructure.getXsd(), addCommunityPermissions,\n\t\t\t\t\taddGuestPermissions);\n\t\t}\n\n\t\tstructureIds.put(\n\t\t\tstructure.getStructureId(), existingStructure.getStructureId());\n\n\t\tif (!structureId.equals(existingStructure.getStructureId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A structure with the ID \" + structureId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingStructure.getStructureId());\n\t\t\t}\n\t\t}\n\t}","id":34980,"modified_method":"public static void importStructure(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tElement el)\n\t\tthrows Exception {\n\n\t\tString path = el.attributeValue(\"path\");\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tJournalStructure structure =\n\t\t\t\t(JournalStructure)context.getZipEntryAsObject(path);\n\n\t\t\tlong userId = context.getUserId(structure.getUserUuid());\n\t\t\tlong plid = context.getPlid();\n\n\t\t\tString structureId = structure.getStructureId();\n\t\t\tboolean autoStructureId = false;\n\n\t\t\tif ((Validator.isNumber(structureId)) ||\n\t\t\t\t(JournalStructureUtil.fetchByG_S(\n\t\t\t\t\tcontext.getGroupId(), structureId) != null)) {\n\n\t\t\t\tautoStructureId = true;\n\t\t\t}\n\n\t\t\tJournalCreationStrategy creationStrategy =\n\t\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\t\tlong authorId = creationStrategy.getAuthorUserId(context, structure);\n\n\t\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\t\tuserId = authorId;\n\t\t\t}\n\n\t\t\tboolean addCommunityPermissions =\n\t\t\t\tcreationStrategy.addCommunityPermissions(context, structure);\n\t\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\t\tcontext, structure);\n\n\t\t\tJournalStructure existingStructure = null;\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\texistingStructure = JournalStructureUtil.fetchByUUID_G(\n\t\t\t\t\tstructure.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingStructure == null) {\n\t\t\t\t\texistingStructure =\n\t\t\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\t\t\tstructure.getUuid(), userId, structureId,\n\t\t\t\t\t\t\tautoStructureId, plid, structure.getName(),\n\t\t\t\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingStructure =\n\t\t\t\t\t\tJournalStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\t\texistingStructure.getGroupId(),\n\t\t\t\t\t\t\texistingStructure.getStructureId(), structure.getName(),\n\t\t\t\t\t\t\tstructure.getDescription(), structure.getXsd());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\t\tuserId, structureId, autoStructureId, plid,\n\t\t\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\t\t\tstructure.getXsd(), addCommunityPermissions,\n\t\t\t\t\t\taddGuestPermissions);\n\t\t\t}\n\n\t\t\tstructureIds.put(structureId, existingStructure.getStructureId());\n\n\t\t\tif (!structureId.equals(existingStructure.getStructureId())) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"A structure with the ID \" + structureId + \" already \" +\n\t\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\t\texistingStructure.getStructureId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importTemplate(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, JournalTemplate template)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(template.getUserUuid());\n\t\tlong plid = context.getPlid();\n\n\t\tString templateId = template.getTemplateId();\n\t\tboolean autoTemplateId = false;\n\n\t\tif ((Validator.isNumber(templateId)) ||\n\t\t\t(JournalTemplateUtil.fetchByG_T(\n\t\t\t\tcontext.getGroupId(), templateId) != null)) {\n\n\t\t\tautoTemplateId = true;\n\t\t}\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, template.getStructureId(), template.getStructureId());\n\n\t\tboolean formatXsl = false;\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(context, template);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(context, template);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tcontext, template);\n\n\t\tFile smallFile = null;\n\n\t\tif (template.isSmallImage()) {\n\t\t\tbyte[] byteArray = context.getZipReader().getEntryAsByteArray(\n\t\t\t\tgetSmallImageDir(template));\n\n\t\t\tsmallFile = File.createTempFile(\n\t\t\t\tString.valueOf(template.getSmallImageId()),\n\t\t\t\tStringPool.PERIOD + template.getSmallImageType());\n\n\t\t\tFileUtil.write(smallFile, byteArray);\n\t\t}\n\n\t\tJournalTemplate existingTemplate = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingTemplate = JournalTemplateUtil.fetchByUUID_G(\n\t\t\t\ttemplate.getUuid(), context.getGroupId());\n\n\t\t\tif (existingTemplate == null) {\n\t\t\t\texistingTemplate =\n\t\t\t\t\tJournalTemplateLocalServiceUtil.addTemplate(\n\t\t\t\t\t\ttemplate.getUuid(), userId, templateId, autoTemplateId,\n\t\t\t\t\t\tplid, parentStructureId, template.getName(),\n\t\t\t\t\t\ttemplate.getDescription(), template.getXsl(), formatXsl,\n\t\t\t\t\t\ttemplate.getLangType(), template.getCacheable(),\n\t\t\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(),\n\t\t\t\t\t\tsmallFile, addCommunityPermissions,\n\t\t\t\t\t\taddGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingTemplate =\n\t\t\t\t\tJournalTemplateLocalServiceUtil.updateTemplate(\n\t\t\t\t\t\texistingTemplate.getGroupId(),\n\t\t\t\t\t\texistingTemplate.getTemplateId(),\n\t\t\t\t\t\texistingTemplate.getStructureId(), template.getName(),\n\t\t\t\t\t\ttemplate.getDescription(), template.getXsl(), formatXsl,\n\t\t\t\t\t\ttemplate.getLangType(), template.getCacheable(),\n\t\t\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(),\n\t\t\t\t\t\tsmallFile);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingTemplate =\n\t\t\t\tJournalTemplateLocalServiceUtil.addTemplate(\n\t\t\t\t\tuserId, templateId, autoTemplateId, plid, parentStructureId,\n\t\t\t\t\ttemplate.getName(), template.getDescription(),\n\t\t\t\t\ttemplate.getXsl(), formatXsl, template.getLangType(),\n\t\t\t\t\ttemplate.getCacheable(), template.isSmallImage(),\n\t\t\t\t\ttemplate.getSmallImageURL(), smallFile,\n\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t}\n\n\t\ttemplateIds.put(\n\t\t\ttemplate.getTemplateId(), existingTemplate.getTemplateId());\n\n\t\tif (!templateId.equals(existingTemplate.getTemplateId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A template with the ID \" + templateId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingTemplate.getTemplateId());\n\t\t\t}\n\t\t}\n\t}","id":34981,"modified_method":"public static void importTemplate(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, Element el)\n\t\tthrows Exception {\n\n\t\tString path = el.attributeValue(\"path\");\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tJournalTemplate template =\n\t\t\t\t(JournalTemplate)context.getZipEntryAsObject(path);\n\n\t\t\tlong userId = context.getUserId(template.getUserUuid());\n\t\t\tlong plid = context.getPlid();\n\n\t\t\tString templateId = template.getTemplateId();\n\t\t\tboolean autoTemplateId = false;\n\n\t\t\tif ((Validator.isNumber(templateId)) ||\n\t\t\t\t(JournalTemplateUtil.fetchByG_T(\n\t\t\t\t\tcontext.getGroupId(), templateId) != null)) {\n\n\t\t\t\tautoTemplateId = true;\n\t\t\t}\n\n\t\t\tString parentStructureId = MapUtil.getString(\n\t\t\t\tstructureIds, template.getStructureId(), template.getStructureId());\n\n\t\t\tboolean formatXsl = false;\n\n\t\t\tJournalCreationStrategy creationStrategy =\n\t\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\t\tlong authorId = creationStrategy.getAuthorUserId(context, template);\n\n\t\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\t\tuserId = authorId;\n\t\t\t}\n\n\t\t\tboolean addCommunityPermissions =\n\t\t\t\tcreationStrategy.addCommunityPermissions(context, template);\n\t\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\t\tcontext, template);\n\n\t\t\tFile smallFile = null;\n\n\t\t\tif (template.isSmallImage()) {\n\t\t\t\tbyte[] byteArray = context.getZipEntryAsByteArray(\n\t\t\t\t\tgetSmallImagePath(context, template));\n\n\t\t\t\tsmallFile = File.createTempFile(\n\t\t\t\t\tString.valueOf(template.getSmallImageId()),\n\t\t\t\t\tStringPool.PERIOD + template.getSmallImageType());\n\n\t\t\t\tFileUtil.write(smallFile, byteArray);\n\t\t\t}\n\n\t\t\tJournalTemplate existingTemplate = null;\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\texistingTemplate = JournalTemplateUtil.fetchByUUID_G(\n\t\t\t\t\ttemplate.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingTemplate == null) {\n\t\t\t\t\texistingTemplate =\n\t\t\t\t\t\tJournalTemplateLocalServiceUtil.addTemplate(\n\t\t\t\t\t\t\ttemplate.getUuid(), userId, templateId, autoTemplateId,\n\t\t\t\t\t\t\tplid, parentStructureId, template.getName(),\n\t\t\t\t\t\t\ttemplate.getDescription(), template.getXsl(), formatXsl,\n\t\t\t\t\t\t\ttemplate.getLangType(), template.getCacheable(),\n\t\t\t\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(),\n\t\t\t\t\t\t\tsmallFile, addCommunityPermissions,\n\t\t\t\t\t\t\taddGuestPermissions);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingTemplate =\n\t\t\t\t\t\tJournalTemplateLocalServiceUtil.updateTemplate(\n\t\t\t\t\t\t\texistingTemplate.getGroupId(),\n\t\t\t\t\t\t\texistingTemplate.getTemplateId(),\n\t\t\t\t\t\t\texistingTemplate.getStructureId(), template.getName(),\n\t\t\t\t\t\t\ttemplate.getDescription(), template.getXsl(), formatXsl,\n\t\t\t\t\t\t\ttemplate.getLangType(), template.getCacheable(),\n\t\t\t\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(),\n\t\t\t\t\t\t\tsmallFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingTemplate =\n\t\t\t\t\tJournalTemplateLocalServiceUtil.addTemplate(\n\t\t\t\t\t\tuserId, templateId, autoTemplateId, plid, parentStructureId,\n\t\t\t\t\t\ttemplate.getName(), template.getDescription(),\n\t\t\t\t\t\ttemplate.getXsl(), formatXsl, template.getLangType(),\n\t\t\t\t\t\ttemplate.getCacheable(), template.isSmallImage(),\n\t\t\t\t\t\ttemplate.getSmallImageURL(), smallFile,\n\t\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\n\t\t\ttemplateIds.put(templateId, existingTemplate.getTemplateId());\n\n\t\t\tif (!templateId.equals(existingTemplate.getTemplateId())) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"A template with the ID \" + templateId + \" already \" +\n\t\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\t\texistingTemplate.getTemplateId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importArticle(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, Map<String, String> articleIds,\n\t\t\tJournalArticle article)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(article.getUserUuid());\n\t\tlong plid = context.getPlid();\n\n\t\tString articleId = article.getArticleId();\n\t\tboolean autoArticleId = false;\n\n\t\tif ((Validator.isNumber(articleId)) ||\n\t\t\t(JournalArticleUtil.fetchByG_A_V(\n\t\t\t\tcontext.getGroupId(), articleId,\n\t\t\t\t\tJournalArticleImpl.DEFAULT_VERSION) != null)) {\n\n\t\t\tautoArticleId = true;\n\t\t}\n\n\t\tboolean incrementVersion = false;\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, article.getStructureId(), article.getStructureId());\n\t\tString parentTemplateId = MapUtil.getString(\n\t\t\ttemplateIds, article.getTemplateId(), article.getTemplateId());\n\n\t\tDate displayDate = article.getDisplayDate();\n\n\t\tint displayDateMonth = 0;\n\t\tint displayDateDay = 0;\n\t\tint displayDateYear = 0;\n\t\tint displayDateHour = 0;\n\t\tint displayDateMinute = 0;\n\n\t\tif (displayDate != null) {\n\t\t\tCalendar displayCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tdisplayCal.setTime(displayDate);\n\n\t\t\tdisplayDateMonth = displayCal.get(Calendar.MONTH);\n\t\t\tdisplayDateDay = displayCal.get(Calendar.DATE);\n\t\t\tdisplayDateYear = displayCal.get(Calendar.YEAR);\n\t\t\tdisplayDateHour = displayCal.get(Calendar.HOUR);\n\t\t\tdisplayDateMinute = displayCal.get(Calendar.MINUTE);\n\n\t\t\tif (displayCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\tdisplayDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate expirationDate = article.getExpirationDate();\n\n\t\tint expirationDateMonth = 0;\n\t\tint expirationDateDay = 0;\n\t\tint expirationDateYear = 0;\n\t\tint expirationDateHour = 0;\n\t\tint expirationDateMinute = 0;\n\t\tboolean neverExpire = true;\n\n\t\tif (expirationDate != null) {\n\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\texpirationDateMonth = expirationCal.get(Calendar.MONTH);\n\t\t\texpirationDateDay = expirationCal.get(Calendar.DATE);\n\t\t\texpirationDateYear = expirationCal.get(Calendar.YEAR);\n\t\t\texpirationDateHour = expirationCal.get(Calendar.HOUR);\n\t\t\texpirationDateMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\tneverExpire = false;\n\n\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\texpirationDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate reviewDate = article.getReviewDate();\n\n\t\tint reviewDateMonth = 0;\n\t\tint reviewDateDay = 0;\n\t\tint reviewDateYear = 0;\n\t\tint reviewDateHour = 0;\n\t\tint reviewDateMinute = 0;\n\t\tboolean neverReview = true;\n\n\t\tif (reviewDate != null) {\n\t\t\tCalendar reviewCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\treviewCal.setTime(reviewDate);\n\n\t\t\treviewDateMonth = reviewCal.get(Calendar.MONTH);\n\t\t\treviewDateDay = reviewCal.get(Calendar.DATE);\n\t\t\treviewDateYear = reviewCal.get(Calendar.YEAR);\n\t\t\treviewDateHour = reviewCal.get(Calendar.HOUR);\n\t\t\treviewDateMinute = reviewCal.get(Calendar.MINUTE);\n\t\t\tneverReview = false;\n\n\t\t\tif (reviewCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\treviewDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tFile smallFile = null;\n\n\t\tif (article.isSmallImage()) {\n\t\t\tbyte[] byteArray = context.getZipReader().getEntryAsByteArray(\n\t\t\t\tgetSmallImageDir(article));\n\n\t\t\tsmallFile = File.createTempFile(\n\t\t\t\tString.valueOf(article.getSmallImageId()),\n\t\t\t\tStringPool.PERIOD + article.getSmallImageType());\n\n\t\t\tFileUtil.write(smallFile, byteArray);\n\t\t}\n\n\t\tMap<String, byte[]> images = new HashMap<String, byte[]>();\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tList<ObjectValuePair<String, byte[]>> imageFiles =\n\t\t\t\tcontext.getZipReader().getFolderEntries().get(\n\t\t\t\t\tgetArticleImageDir(article));\n\n\t\t\tif (imageFiles != null) {\n\t\t\t\tfor (ObjectValuePair<String, byte[]> imageFile : imageFiles) {\n\t\t\t\t\tString fileName = imageFile.getKey();\n\n\t\t\t\t\tint pos = fileName.lastIndexOf(\".\");\n\n\t\t\t\t\tif (pos != -1) {\n\t\t\t\t\t\tfileName = fileName.substring(0, pos);\n\t\t\t\t\t}\n\n\t\t\t\t\timages.put(fileName, imageFile.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString articleURL = null;\n\n\t\tPortletPreferences prefs = null;\n\n\t\tString[] tagsEntries = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\ttagsEntries = context.getTagsEntries(\n\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()));\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(context, article);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tString newContent = creationStrategy.getTransformedContent(\n\t\t\tcontext, article);\n\n\t\tif (newContent != JournalCreationStrategy.ARTICLE_CONTENT_UNCHANGED) {\n\t\t\tarticle.setContent(newContent);\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(context, article);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tcontext, article);\n\n\t\tJournalArticle existingArticle = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingArticle = JournalArticleUtil.fetchByUUID_G(\n\t\t\t\tarticle.getUuid(), context.getGroupId());\n\n\t\t\tif (existingArticle == null) {\n\t\t\t\texistingArticle =  JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\t\tarticle.getUuid(), userId, articleId, autoArticleId, plid,\n\t\t\t\t\tarticle.getVersion(), article.getTitle(),\n\t\t\t\t\tarticle.getDescription(), article.getContent(),\n\t\t\t\t\tarticle.getType(), parentStructureId, parentTemplateId,\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, expirationDateMonth,\n\t\t\t\t\texpirationDateDay, expirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, prefs, tagsEntries,\n\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingArticle =  JournalArticleLocalServiceUtil.updateArticle(\n\t\t\t\t\tuserId, existingArticle.getGroupId(),\n\t\t\t\t\texistingArticle.getArticleId(),\n\t\t\t\t\texistingArticle.getVersion(), incrementVersion,\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\texistingArticle.getStructureId(),\n\t\t\t\t\texistingArticle.getTemplateId(), displayDateMonth,\n\t\t\t\t\tdisplayDateDay, displayDateYear, displayDateHour,\n\t\t\t\t\tdisplayDateMinute, expirationDateMonth,\n\t\t\t\t\texpirationDateDay, expirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, prefs, tagsEntries);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\tuserId, articleId, autoArticleId, plid, article.getVersion(),\n\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\tarticle.getContent(), article.getType(), parentStructureId,\n\t\t\t\tparentTemplateId, displayDateMonth, displayDateDay,\n\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(), smallFile,\n\t\t\t\timages, articleURL, prefs, tagsEntries, addCommunityPermissions,\n\t\t\t\taddGuestPermissions);\n\t\t}\n\n\t\tlong strategyApprovalUserId = creationStrategy.getApprovalUserId(\n\t\t\tcontext, article);\n\n\t\tif ((strategyApprovalUserId !=\n\t\t\t\tJournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) ||\n\t\t\t(article.isApproved() && !existingArticle.isApproved())) {\n\n\t\t\tlong approvedByUserId = strategyApprovalUserId;\n\n\t\t\tif (approvedByUserId == 0) {\n\t\t\t\tapprovedByUserId = context.getUserId(\n\t\t\t\t\tarticle.getApprovedByUserUuid());\n\t\t\t}\n\n\t\t\tJournalArticleLocalServiceUtil.approveArticle(\n\t\t\t\tapprovedByUserId, context.getGroupId(),\n\t\t\t\texistingArticle.getArticleId(), existingArticle.getVersion(),\n\t\t\t\tarticleURL, prefs);\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.importComments(\n\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()),\n\t\t\t\tnew Long(existingArticle.getResourcePrimKey()),\n\t\t\t\tcontext.getGroupId());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.importRatingsEntries(\n\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()),\n\t\t\t\tnew Long(existingArticle.getResourcePrimKey()));\n\t\t}\n\n\t\tarticleIds.put(\n\t\t\tarticle.getArticleId(), existingArticle.getArticleId());\n\n\t\tif (!articleId.equals(existingArticle.getArticleId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"An article with the ID \" + articleId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingArticle.getArticleId());\n\t\t\t}\n\t\t}\n\t}","id":34982,"modified_method":"public static void importArticle(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, Map<String, String> articleIds,\n\t\t\tElement el)\n\t\tthrows Exception {\n\n\t\tString path = el.attributeValue(\"path\");\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tJournalArticle article =\n\t\t\t\t(JournalArticle)context.getZipEntryAsObject(path);\n\n\t\t\tlong userId = context.getUserId(article.getUserUuid());\n\t\t\tlong plid = context.getPlid();\n\n\t\t\tString articleId = article.getArticleId();\n\t\t\tboolean autoArticleId = false;\n\n\t\t\tif ((Validator.isNumber(articleId)) ||\n\t\t\t\t(JournalArticleUtil.fetchByG_A_V(\n\t\t\t\t\tcontext.getGroupId(), articleId,\n\t\t\t\t\t\tJournalArticleImpl.DEFAULT_VERSION) != null)) {\n\n\t\t\t\tautoArticleId = true;\n\t\t\t}\n\n\t\t\tString newArticleId = articleIds.get(articleId);\n\n\t\t\tif (Validator.isNotNull(newArticleId)) {\n\t\t\t\t// This means a sibling of a different version already was\n\t\t\t\t// assigned a new articleId, we need to use it.\n\n\t\t\t\tarticleId = newArticleId;\n\t\t\t\tautoArticleId = false;\n\t\t\t}\n\n\t\t\tboolean incrementVersion = false;\n\n\t\t\tString parentStructureId = MapUtil.getString(\n\t\t\t\tstructureIds, article.getStructureId(),\n\t\t\t\tarticle.getStructureId());\n\t\t\tString parentTemplateId = MapUtil.getString(\n\t\t\t\ttemplateIds, article.getTemplateId(),\n\t\t\t\tarticle.getTemplateId());\n\n\t\t\tDate displayDate = article.getDisplayDate();\n\n\t\t\tint displayDateMonth = 0;\n\t\t\tint displayDateDay = 0;\n\t\t\tint displayDateYear = 0;\n\t\t\tint displayDateHour = 0;\n\t\t\tint displayDateMinute = 0;\n\n\t\t\tif (displayDate != null) {\n\t\t\t\tCalendar displayCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\t\tdisplayCal.setTime(displayDate);\n\n\t\t\t\tdisplayDateMonth = displayCal.get(Calendar.MONTH);\n\t\t\t\tdisplayDateDay = displayCal.get(Calendar.DATE);\n\t\t\t\tdisplayDateYear = displayCal.get(Calendar.YEAR);\n\t\t\t\tdisplayDateHour = displayCal.get(Calendar.HOUR);\n\t\t\t\tdisplayDateMinute = displayCal.get(Calendar.MINUTE);\n\n\t\t\t\tif (displayCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\t\tdisplayDateHour += 12;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDate expirationDate = article.getExpirationDate();\n\n\t\t\tint expirationDateMonth = 0;\n\t\t\tint expirationDateDay = 0;\n\t\t\tint expirationDateYear = 0;\n\t\t\tint expirationDateHour = 0;\n\t\t\tint expirationDateMinute = 0;\n\t\t\tboolean neverExpire = true;\n\n\t\t\tif (expirationDate != null) {\n\t\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\t\texpirationDateMonth = expirationCal.get(Calendar.MONTH);\n\t\t\t\texpirationDateDay = expirationCal.get(Calendar.DATE);\n\t\t\t\texpirationDateYear = expirationCal.get(Calendar.YEAR);\n\t\t\t\texpirationDateHour = expirationCal.get(Calendar.HOUR);\n\t\t\t\texpirationDateMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\t\tneverExpire = false;\n\n\t\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\t\texpirationDateHour += 12;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDate reviewDate = article.getReviewDate();\n\n\t\t\tint reviewDateMonth = 0;\n\t\t\tint reviewDateDay = 0;\n\t\t\tint reviewDateYear = 0;\n\t\t\tint reviewDateHour = 0;\n\t\t\tint reviewDateMinute = 0;\n\t\t\tboolean neverReview = true;\n\n\t\t\tif (reviewDate != null) {\n\t\t\t\tCalendar reviewCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\t\treviewCal.setTime(reviewDate);\n\n\t\t\t\treviewDateMonth = reviewCal.get(Calendar.MONTH);\n\t\t\t\treviewDateDay = reviewCal.get(Calendar.DATE);\n\t\t\t\treviewDateYear = reviewCal.get(Calendar.YEAR);\n\t\t\t\treviewDateHour = reviewCal.get(Calendar.HOUR);\n\t\t\t\treviewDateMinute = reviewCal.get(Calendar.MINUTE);\n\t\t\t\tneverReview = false;\n\n\t\t\t\tif (reviewCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\t\treviewDateHour += 12;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tFile smallFile = null;\n\n\t\t\tif (article.isSmallImage()) {\n\t\t\t\tbyte[] byteArray = context.getZipEntryAsByteArray(\n\t\t\t\t\tgetSmallImagePath(context, article));\n\n\t\t\t\tsmallFile = File.createTempFile(\n\t\t\t\t\tString.valueOf(article.getSmallImageId()),\n\t\t\t\t\tStringPool.PERIOD + article.getSmallImageType());\n\n\t\t\t\tFileUtil.write(smallFile, byteArray);\n\t\t\t}\n\n\t\t\tMap<String, byte[]> images = new HashMap<String, byte[]>();\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\t\tList<ObjectValuePair<String, byte[]>> imageFiles =\n\t\t\t\t\tcontext.getZipFolderEntries(\n\t\t\t\t\t\tgetArticleImagePath(context, article));\n\n\t\t\t\tif (imageFiles != null) {\n\t\t\t\t\tfor (ObjectValuePair<String, byte[]> imageFile :\n\t\t\t\t\t\t\timageFiles) {\n\t\t\t\t\t\tString fileName = imageFile.getKey();\n\n\t\t\t\t\t\tif (!fileName.endsWith(\".xml\")) {\n\t\t\t\t\t\t\tint pos = fileName.lastIndexOf(\".\");\n\n\t\t\t\t\t\t\tif (pos != -1) {\n\t\t\t\t\t\t\t\tfileName = fileName.substring(0, pos);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\timages.put(fileName, imageFile.getValue());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString articleURL = null;\n\n\t\t\tPortletPreferences prefs = null;\n\n\t\t\tString[] tagsEntries = null;\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\ttagsEntries = context.getTagsEntries(\n\t\t\t\t\tJournalArticle.class,\n\t\t\t\t\tnew Long(article.getResourcePrimKey()));\n\t\t\t}\n\n\t\t\tJournalCreationStrategy creationStrategy =\n\t\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\t\tlong authorId = creationStrategy.getAuthorUserId(context, article);\n\n\t\t\tif (authorId !=\n\t\t\t\t\tJournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\t\tuserId = authorId;\n\t\t\t}\n\n\t\t\tString newContent = creationStrategy.getTransformedContent(\n\t\t\t\tcontext, article);\n\n\t\t\tif (newContent !=\n\t\t\t\t\tJournalCreationStrategy.ARTICLE_CONTENT_UNCHANGED) {\n\t\t\t\tarticle.setContent(newContent);\n\t\t\t}\n\n\t\t\tboolean addCommunityPermissions =\n\t\t\t\tcreationStrategy.addCommunityPermissions(context, article);\n\t\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\t\tcontext, article);\n\n\t\t\tJournalArticle existingArticle = null;\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\texistingArticle = JournalArticleUtil.fetchByUUID_G(\n\t\t\t\t\tarticle.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingArticle == null) {\n\t\t\t\t\texistingArticle =  JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\t\t\tarticle.getUuid(), userId, articleId, autoArticleId,\n\t\t\t\t\t\tplid, article.getVersion(), article.getTitle(),\n\t\t\t\t\t\tarticle.getDescription(), article.getContent(),\n\t\t\t\t\t\tarticle.getType(), parentStructureId, parentTemplateId,\n\t\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\t\tdisplayDateHour, displayDateMinute, expirationDateMonth,\n\t\t\t\t\t\texpirationDateDay, expirationDateYear,\n\t\t\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear,\n\t\t\t\t\t\treviewDateHour, reviewDateMinute, neverReview,\n\t\t\t\t\t\tarticle.getIndexable(), article.getSmallImage(),\n\t\t\t\t\t\tarticle.getSmallImageURL(), smallFile, images,\n\t\t\t\t\t\tarticleURL, prefs, tagsEntries, addCommunityPermissions,\n\t\t\t\t\t\taddGuestPermissions);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingArticle =  JournalArticleLocalServiceUtil.updateArticle(\n\t\t\t\t\t\tuserId, existingArticle.getGroupId(),\n\t\t\t\t\t\texistingArticle.getArticleId(),\n\t\t\t\t\t\texistingArticle.getVersion(), incrementVersion,\n\t\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\t\texistingArticle.getStructureId(),\n\t\t\t\t\t\texistingArticle.getTemplateId(), displayDateMonth,\n\t\t\t\t\t\tdisplayDateDay, displayDateYear, displayDateHour,\n\t\t\t\t\t\tdisplayDateMinute, expirationDateMonth,\n\t\t\t\t\t\texpirationDateDay, expirationDateYear,\n\t\t\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear,\n\t\t\t\t\t\treviewDateHour, reviewDateMinute, neverReview,\n\t\t\t\t\t\tarticle.getIndexable(), article.getSmallImage(),\n\t\t\t\t\t\tarticle.getSmallImageURL(), smallFile, images,\n\t\t\t\t\t\tarticleURL, prefs, tagsEntries);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\t\tuserId, articleId, autoArticleId, plid,\n\t\t\t\t\tarticle.getVersion(), article.getTitle(),\n\t\t\t\t\tarticle.getDescription(), article.getContent(),\n\t\t\t\t\tarticle.getType(), parentStructureId, parentTemplateId,\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, expirationDateMonth,\n\t\t\t\t\texpirationDateDay, expirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.getIndexable(),\n\t\t\t\t\tarticle.getSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, prefs, tagsEntries,\n\t\t\t\t\taddCommunityPermissions, addGuestPermissions);\n\t\t\t}\n\n\t\t\tlong strategyApprovalUserId = creationStrategy.getApprovalUserId(\n\t\t\t\tcontext, article);\n\n\t\t\tif ((strategyApprovalUserId !=\n\t\t\t\t\tJournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) ||\n\t\t\t\t(article.isApproved() && !existingArticle.isApproved())) {\n\n\t\t\t\tlong approvedByUserId = strategyApprovalUserId;\n\n\t\t\t\tif (approvedByUserId == 0) {\n\t\t\t\t\tapprovedByUserId = context.getUserId(\n\t\t\t\t\t\tarticle.getApprovedByUserUuid());\n\t\t\t\t}\n\n\t\t\t\tJournalArticleLocalServiceUtil.approveArticle(\n\t\t\t\t\tapprovedByUserId, context.getGroupId(),\n\t\t\t\t\texistingArticle.getArticleId(),\n\t\t\t\t\texistingArticle.getVersion(), articleURL, prefs);\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.importComments(\n\t\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()),\n\t\t\t\t\tnew Long(existingArticle.getResourcePrimKey()),\n\t\t\t\t\tcontext.getGroupId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tJournalArticle.class, new Long(article.getResourcePrimKey()),\n\t\t\t\t\tnew Long(existingArticle.getResourcePrimKey()));\n\t\t\t}\n\n\t\t\tarticleIds.put(articleId, existingArticle.getArticleId());\n\n\t\t\tif (!articleId.equals(existingArticle.getArticleId())) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"An article with the ID \" + articleId + \" already \" +\n\t\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\t\texistingArticle.getArticleId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void exportStructure(JournalStructure structure)\n\t\tthrows SystemException {\n\n\t\tstructure.setUserUuid(structure.getUserUuid());\n\t}","id":34983,"modified_method":"public static void exportStructure(\n\t\t\tPortletDataContext context, Element el, JournalStructure structure)\n\t\tthrows SystemException {\n\n\t\tif (context.isWithinDateRange(structure.getModifiedDate())) {\n\t\t\tString path = getStructurePath(context, structure);\n\n\t\t\tel.addElement(\"structure\").addAttribute(\"path\", path);\n\n\t\t\tif (context.isPathNotProcessed(path)) {\n\t\t\t\tstructure.setUserUuid(structure.getUserUuid());\n\n\t\t\t\tcontext.addZipEntry(path, structure);\n\t\t\t}\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String getArticleImageDir(JournalArticle article) {\n\t\treturn _ARTICLE_IMAGES_FOLDER + article.getArticleId() + \"/\" +\n\t\t\tarticle.getVersion() + \"/\";\n\t}","id":34984,"modified_method":"protected static String getArticleImagePath(\n\t\t\tPortletDataContext context, JournalArticle article) {\n\n\t\tStringMaker sm = new StringMaker();\n\t\tsm.append(context.getPortletPath(PortletKeys.JOURNAL));\n\t\tsm.append(_ARTICLE_FOLDER);\n\t\tsm.append(article.getArticleId());\n\t\tsm.append(CharPool.FORWARD_SLASH);\n\t\tsm.append(article.getVersion());\n\t\tsm.append(CharPool.FORWARD_SLASH);\n\n\t\treturn sm.toString();\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentUtil.readDocumentFromXML(data);\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Structures\n\n\t\t\tElement el = root.element(\"journal-structures\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap<String, String> structureIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\t\tList<JournalStructure> structures =\n\t\t\t\t(List<JournalStructure>)xStream.fromXML(tempDoc.asXML());\n\n\t\t\tfor (JournalStructure structure : structures) {\n\t\t\t\timportStructure(context, structureIds, structure);\n\t\t\t}\n\n\t\t\t// Templates\n\n\t\t\tel = root.element(\"journal-templates\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap<String, String> templateIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalTemplate.class);\n\n\t\t\tList<JournalTemplate> templates =\n\t\t\t\t(List<JournalTemplate>)xStream.fromXML(tempDoc.asXML());\n\n\t\t\tfor (JournalTemplate template : templates) {\n\t\t\t\timportTemplate(context, structureIds, templateIds, template);\n\t\t\t}\n\n\t\t\t// Articles\n\n\t\t\tel = root.element(\"journal-articles\").element(\"list\");\n\n\t\t\ttempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tMap<String, String> articleIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\t\tList<JournalArticle> articles =\n\t\t\t\t(List<JournalArticle>)xStream.fromXML(tempDoc.asXML());\n\n\t\t\tfor (JournalArticle article : articles) {\n\t\t\t\timportArticle(\n\t\t\t\t\tcontext, structureIds, templateIds, articleIds, article);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":34985,"modified_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = DocumentUtil.readDocumentFromXML(data);\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Structures\n\n\t\t\tList<Element> structures =\n\t\t\t\troot.element(\"journal-structures\").elements(\"structure\");\n\n\t\t\tMap<String, String> structureIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\t\tfor (Element el : structures) {\n\t\t\t\timportStructure(context, structureIds, el);\n\t\t\t}\n\n\t\t\t// Templates\n\n\t\t\tList<Element> templates =\n\t\t\t\troot.element(\"journal-templates\").elements(\"template\");\n\n\t\t\tMap<String, String> templateIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalTemplate.class);\n\n\t\t\tfor (Element el : templates) {\n\t\t\t\timportTemplate(context, structureIds, templateIds, el);\n\t\t\t}\n\n\t\t\t// Articles\n\n\t\t\tList<Element> articles =\n\t\t\t\troot.element(\"journal-articles\").elements(\"article\");\n\n\t\t\tMap<String, String> articleIds = context.getNewPrimaryKeysMap(\n\t\t\t\tJournalArticle.class);\n\n\t\t\tfor (Element el : articles) {\n\t\t\t\timportArticle(\n\t\t\t\t\tcontext, structureIds, templateIds, articleIds, el);\n\t\t\t}\n\n\t\t\treturn prefs;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String getSmallImageDir(JournalTemplate template)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn _TEMPLATE_SMALL_IMAGES_FOLDER + template.getSmallImageId() +\n\t\t\t\".\" + template.getSmallImageType();\n\t}","id":34986,"modified_method":"protected static String getSmallImagePath(\n\t\t\tPortletDataContext context, JournalTemplate template)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn context.getPortletPath(PortletKeys.JOURNAL) +\n\t\t\t_TEMPLATE_FOLDER + \"thumbnail\" + CharPool.PERIOD +\n\t\t\t\ttemplate.getSmallImageType();\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String getSmallImageDir(JournalArticle article)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn _ARTICLE_SMALL_IMAGES_FOLDER + article.getSmallImageId() + \".\" +\n\t\t\tarticle.getSmallImageType();\n\t}","id":34987,"modified_method":"protected static String getSmallImagePath(\n\t\t\tPortletDataContext context, JournalArticle article)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn context.getPortletPath(PortletKeys.JOURNAL) +\n\t\t\t_ARTICLE_FOLDER + \"thumbnail\" + CharPool.PERIOD +\n\t\t\t\tarticle.getSmallImageType();\n\t}","commit_id":"12bf21ddbe6786728d1eea92180b593fe7b47a6d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Responds by sending the contents of the resource stream.\n\t * \n\t * @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n\t */\n\tpublic void respond(IRequestCycle requestCycle)\n\t{\n\t\tAttributes attributes = new Attributes(requestCycle.getRequest(),\n\t\t\trequestCycle.getResponse());\n\n\t\tResourceStreamResource resource = new ResourceStreamResource(resourceStream);\n\t\tresource.setFileName(fileName);\n\t\tresource.setContentDisposition(contentDisposition);\n\t\tresource.respond(attributes);\n\t}","id":34988,"modified_method":"/**\n\t * Responds by sending the contents of the resource stream.\n\t * \n\t * @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n\t */\n\tpublic void respond(IRequestCycle requestCycle)\n\t{\n\t\tAttributes attributes = new Attributes(requestCycle.getRequest(),\n\t\t\trequestCycle.getResponse());\n\n\t\tResourceStreamResource resource = new ResourceStreamResource(resourceStream);\n\t\tresource.setFileName(fileName);\n\t\tif (contentDisposition != null)\n\t\t\tresource.setContentDisposition(contentDisposition);\n\t\telse\n\t\t\tresource.setContentDisposition(Strings.isEmpty(fileName) ? ContentDisposition.INLINE\n\t\t\t\t: ContentDisposition.ATTACHMENT);\n\n\t\tresource.respond(attributes);\n\t}","commit_id":"893d490da1450677f4d5fdb986d91961f8eb7023","url":"https://github.com/apache/wicket"},{"original_method":"private void transferPendingSnapshots() throws EucalyptusCloudException {\n        EntityWrapper<SnapshotInfo> db = StorageController.getEntityWrapper();\n        SnapshotInfo snapshotInfo = new SnapshotInfo();\n        snapshotInfo.setShouldTransfer(true);\n        List<SnapshotInfo> snapshotInfos = db.query(snapshotInfo);\n        if(snapshotInfos.size() > 0) {\n            SnapshotInfo snapInfo = snapshotInfos.get(0);\n            String snapshotId = snapInfo.getSnapshotId();\n\t\t\tList<String> returnValues = blockManager.prepareForTransfer(snapshotId);\n\t\t\tString snapshotFileName = returnValues.get(0);\n\t\t\tFile snapshotFile = new File(snapshotFileName);\n\t\t\tMap<String, String> httpParamaters = new HashMap<String, String>();\n\t\t\tHttpWriter httpWriter;\n\t\t\tSnapshotProgressCallback callback = new SnapshotProgressCallback(snapshotId, snapshotFile.length(), StorageProperties.TRANSFER_CHUNK_SIZE);\n\t\t\thttpWriter = new HttpWriter(\"PUT\", snapshotFile, callback, \"snapset\", snapshotId, \"StoreSnapshot\", null, httpParamaters);\n\t\t\ttry {\n\t\t\t\thttpWriter.run();\n\t\t\t} catch(Exception ex) {\n\t\t\t\tLOG.error(ex, ex);\n\t\t\t\tthis.cleanFailedSnapshot(snapshotId);\n\t\t\t}\n        }\n        db.commit();\n    }","id":34989,"modified_method":"private void transferPendingSnapshots() throws EucalyptusCloudException {\n        EntityWrapper<SnapshotInfo> db = StorageController.getEntityWrapper();\n        SnapshotInfo snapshotInfo = new SnapshotInfo();\n        snapshotInfo.setShouldTransfer(true);\n        List<SnapshotInfo> snapshotInfos = db.query(snapshotInfo);\n        if(snapshotInfos.size() > 0) {\n            SnapshotInfo snapInfo = snapshotInfos.get(0);\n            String snapshotId = snapInfo.getSnapshotId();\n\t\t\tList<String> returnValues = blockManager.prepareForTransfer(snapshotId);\n\t\t\tString snapshotFileName = returnValues.get(0);\n\t\t\tFile snapshotFile = new File(snapshotFileName);\n\t\t\tMap<String, String> httpParamaters = new HashMap<String, String>();\n\t\t\tHttpWriter httpWriter;\n\t\t\tSnapshotProgressCallback callback = new SnapshotProgressCallback(snapshotId, snapshotFile.length(), StorageProperties.TRANSFER_CHUNK_SIZE);\n\t\t\thttpWriter = new HttpWriter(\"PUT\", snapshotFile, callback, \"snapset\", snapshotId, \"StoreSnapshot\", null, httpParamaters);\n\t\t\tsnapInfo.setShouldTransfer(false);\n\t\t\ttry {\n\t\t\t\thttpWriter.run();\n\t\t\t} catch(Exception ex) {\n\t\t\t\tLOG.error(ex, ex);\n\t\t\t\tthis.cleanFailedSnapshot(snapshotId);\n\t\t\t}\n        }\n        db.commit();\n    }","commit_id":"a335bea4c5480e6a0a1ba846e15920004017f23d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif (bucket.canWrite(userId)) {\n\n\t\t\t\tObjectInfo foundObject = null;\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObject);\n\t\t\t\tfor (ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\tif (objectInfo.getObjectKey().equals(objectKey)) {\n\t\t\t\t\t\t//key (object) exists. check perms\n\t\t\t\t\t\tif (!objectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\toldBucketSize = -foundObject.getSize();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//write object to bucket\n\t\t\t\tString objectName;\n\t\t\t\tif (foundObject == null) {\n\t\t\t\t\t//not found. create an object info\n\t\t\t\t\tfoundObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tfoundObject.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4);\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t} else {\n\t\t\t\t\t//object already exists. see if we can modify acl\n\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t}\n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoundObject.setObjectKey(objectKey);\n\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t//writes are unconditional\n\t\t\t\tLinkedBlockingQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take())!=null) {\n\t\t\t\t\t\tif(WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = objectName + \".\" + Hashes.getRandom(12);\n\t\t\t\t\t\t\tdigest = Hashes.Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t//commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize + size;\n\t\t\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\t//restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if(WalrusDataMessage.isInterrupted(dataMessage)) {\n\n\t\t\t\t\t\t\t//there was a write after this one started\n\t\t\t\t\t\t\t//abort writing but wait until the other (last) writer has completed\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert(WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t//start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","id":34990,"modified_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif (bucket.canWrite(userId)) {\n\n\t\t\t\tObjectInfo foundObject = null;\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObject);\n\t\t\t\tfor (ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\tif (objectInfo.getObjectKey().equals(objectKey)) {\n\t\t\t\t\t\t//key (object) exists. check perms\n\t\t\t\t\t\tif (!objectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\toldBucketSize = -foundObject.getSize();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//write object to bucket\n\t\t\t\tString objectName;\n\t\t\t\tif (foundObject == null) {\n\t\t\t\t\t//not found. create an object info\n\t\t\t\t\tfoundObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tfoundObject.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4);\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t} else {\n\t\t\t\t\t//object already exists. see if we can modify acl\n\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t}\n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoundObject.setObjectKey(objectKey);\n\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\tdb.commit();\n\t\t\t\t//writes are unconditional\n\t\t\t\tLinkedBlockingQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take())!=null) {\n\t\t\t\t\t\tif(WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = objectName + \".\" + Hashes.getRandom(12);\n\t\t\t\t\t\t\tdigest = Hashes.Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t//commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tdbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\tobjectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize + size;\n\t\t\t\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\tthrow new EntityNotFoundException(\"Could not find object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if(WalrusDataMessage.isInterrupted(dataMessage)) {\n\n\t\t\t\t\t\t\t//there was a write after this one started\n\t\t\t\t\t\t\t//abort writing but wait until the other (last) writer has completed\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert(WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t//start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","commit_id":"a335bea4c5480e6a0a1ba846e15920004017f23d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\tif(logData != null)\n\t\t\t\t\treply.setLogData(logData);\n\n\t\t\t\tObjectInfo foundObject = null;\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObject);\n\t\t\t\tfor (ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\tif (objectInfo.getObjectKey().equals(objectKey)) {\n\t\t\t\t\t\t//key (object) exists. check perms\n\t\t\t\t\t\tif (!objectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\toldBucketSize = -foundObject.getSize();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//write object to bucket\n\t\t\t\tString objectName;\n\t\t\t\tif (foundObject == null) {\n\t\t\t\t\t//not found. create an object info\n\t\t\t\t\tfoundObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tfoundObject.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4);\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\tfoundObject.setSize(0L);\n\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t} else {\n\t\t\t\t\t//object already exists. see if we can modify acl\n\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t}\n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoundObject.setObjectKey(objectKey);\n\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\tdb.commit();\n\t\t\t\t//writes are unconditional\n\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take())!=null) {\n\t\t\t\t\t\tif(putQueue.getInterrupted()) {                                         \n\n\t\t\t\t\t\t\tif(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\tif(monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = objectName + \".\" + Hashes.getRandom(12);\n\t\t\t\t\t\t\tdigest = Hashes.Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t//commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tdbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\tobjectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize + size;\n\t\t\t\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long.parseLong(new String(dataMessage.getPayload())));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\tthrow new NoSuchEntityException(\"Could not find object: \" + bucketName + \"/\" + objectKey, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert(WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t//start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \" + key + \".\" + randomKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","id":34991,"modified_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\tif(logData != null)\n\t\t\t\t\treply.setLogData(logData);\n\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tString objectName;\n\t\t\t\tObjectInfo objectInfo = null;\n\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\ttry {\n\t\t\t\t\tObjectInfo foundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\tif (!foundObject.canWrite(userId)) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t} \n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t}\n\t\t\t\tdb.commit();\n\t\t\t\t//writes are unconditional\n\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take())!=null) {\n\t\t\t\t\t\tif(putQueue.getInterrupted()) {                                         \n\n\t\t\t\t\t\t\tif(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\tif(monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = objectName + \".\" + Hashes.getRandom(12);\n\t\t\t\t\t\t\tdigest = Hashes.Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t//commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tlong oldObjectSize = 0L;\n\t\t\t\t\t\t\tdbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\tsearchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tObjectInfo foundObject;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfoundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos,\n\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\toldObjectSize = foundObject.getSize();\n\t\t\t\t\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tif(objectInfo != null) {\n\t\t\t\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to update object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\tlong newSize = bucketSize - oldObjectSize + size;\n\t\t\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(objectInfo != null)\n\t\t\t\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long.parseLong(new String(dataMessage.getPayload())));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert(WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t//start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \" + key + \".\" + randomKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","commit_id":"6ea7f5d26b622c0cd2ff31a2cfb2effd331ebafe","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CopyObjectResponseType copyObject(CopyObjectType request) throws EucalyptusCloudException {\n\t\tCopyObjectResponseType reply = (CopyObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tString sourceBucket = request.getSourceBucket();\n\t\tString sourceKey = request.getSourceObject();\n\t\tString destinationBucket = request.getDestinationBucket();\n\t\tString destinationKey = request.getDestinationObject();\n\t\tString metadataDirective = request.getMetadataDirective();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\n\t\tString copyIfMatch = request.getCopySourceIfMatch();\n\t\tString copyIfNoneMatch = request.getCopySourceIfNoneMatch();\n\t\tDate copyIfUnmodifiedSince = request.getCopySourceIfUnmodifiedSince();\n\t\tDate copyIfModifiedSince = request.getCopySourceIfModifiedSince();\n\n\t\tif(metadataDirective == null)\n\t\t\tmetadataDirective = \"COPY\";\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(sourceBucket);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(sourceBucket, sourceKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tObjectInfo sourceObjectInfo = objectInfos.get(0);\n\t\t\t\tif(sourceObjectInfo.canRead(userId)) {\n\t\t\t\t\tif(copyIfMatch != null) {\n\t\t\t\t\t\tif(!copyIfMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfMatch: \" + copyIfMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(copyIfNoneMatch != null) {\n\t\t\t\t\t\tif(copyIfNoneMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfNoneMatch: \" + copyIfNoneMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(copyIfUnmodifiedSince != null) {\n\t\t\t\t\t\tlong unmodifiedTime = copyIfUnmodifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif(unmodifiedTime < objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfUnmodifiedSince: \" + copyIfUnmodifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(copyIfModifiedSince != null) {\n\t\t\t\t\t\tlong modifiedTime = copyIfModifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif(modifiedTime > objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfModifiedSince: \" + copyIfModifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBucketInfo destinationBucketInfo = new BucketInfo(destinationBucket);\n\t\t\t\t\tList<BucketInfo> destinationBuckets = db.query(destinationBucketInfo);\n\t\t\t\t\tif(destinationBuckets.size() > 0) {\n\t\t\t\t\t\tBucketInfo foundDestinationBucketInfo = destinationBuckets.get(0);\n\t\t\t\t\t\tif(foundDestinationBucketInfo.canWrite(userId)) {\n\t\t\t\t\t\t\t//all ok\n\t\t\t\t\t\t\tObjectInfo destinationObjectInfo = null;\n\t\t\t\t\t\t\tString destinationObjectName;\n\t\t\t\t\t\t\tObjectInfo destSearchObjectInfo = new ObjectInfo(destinationBucket, destinationKey);\n\t\t\t\t\t\t\tList<ObjectInfo> destinationObjectInfos = dbObject.query(destSearchObjectInfo);\n\t\t\t\t\t\t\tif(destinationObjectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo = destinationObjectInfos.get(0);\n\t\t\t\t\t\t\t\tif(!destinationObjectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", destinationKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(destinationObjectInfo == null) {\n\t\t\t\t\t\t\t\t//not found. create a new one\n\t\t\t\t\t\t\t\tdestinationObjectInfo = new ObjectInfo();\n\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setBucketName(destinationBucket);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectKey(destinationKey);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectName(destinationKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4));\n\t\t\t\t\t\t\t\tdbObject.add(destinationObjectInfo);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (destinationObjectInfo.canWriteACP(userId)) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestinationObjectInfo.setSize(sourceObjectInfo.getSize());\n\t\t\t\t\t\t\tdestinationObjectInfo.setStorageClass(sourceObjectInfo.getStorageClass());\n\t\t\t\t\t\t\tdestinationObjectInfo.setOwnerId(sourceObjectInfo.getOwnerId());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentType(sourceObjectInfo.getContentType());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentDisposition(sourceObjectInfo.getContentDisposition());\n\t\t\t\t\t\t\tString etag = sourceObjectInfo.getEtag();\n\t\t\t\t\t\t\tDate lastModified = sourceObjectInfo.getLastModified();\n\t\t\t\t\t\t\tdestinationObjectInfo.setEtag(etag);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLastModified(lastModified);\n\t\t\t\t\t\t\tif(!metadataDirective.equals(\"REPLACE\")) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setMetaData(sourceObjectInfo.cloneMetaData());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tList<MetaDataEntry> metaData = request.getMetaData();\n\t\t\t\t\t\t\t\tif(metaData != null)\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.replaceMetaData(metaData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tString sourceObjectName = sourceObjectInfo.getObjectName();\n\t\t\t\t\t\t\tdestinationObjectName = destinationObjectInfo.getObjectName();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstorageManager.copyObject(sourceBucket, sourceObjectName, destinationBucket, destinationObjectName);\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics)\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(sourceObjectInfo.getSize());\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Could not rename \" + sourceObjectName + \" to \" + destinationObjectName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", destinationBucket);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(destinationBucket);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", sourceKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(sourceKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(sourceBucket);\n\t\t}\n\t}","id":34992,"modified_method":"public CopyObjectResponseType copyObject(CopyObjectType request) throws EucalyptusCloudException {\n\t\tCopyObjectResponseType reply = (CopyObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tString sourceBucket = request.getSourceBucket();\n\t\tString sourceKey = request.getSourceObject();\n\t\tString destinationBucket = request.getDestinationBucket();\n\t\tString destinationKey = request.getDestinationObject();\n\t\tString metadataDirective = request.getMetadataDirective();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\n\t\tString copyIfMatch = request.getCopySourceIfMatch();\n\t\tString copyIfNoneMatch = request.getCopySourceIfNoneMatch();\n\t\tDate copyIfUnmodifiedSince = request.getCopySourceIfUnmodifiedSince();\n\t\tDate copyIfModifiedSince = request.getCopySourceIfModifiedSince();\n\n\t\tif(metadataDirective == null)\n\t\t\tmetadataDirective = \"COPY\";\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(sourceBucket);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(sourceBucket, sourceKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tObjectInfo sourceObjectInfo = objectInfos.get(0);\n\t\t\t\tif(sourceObjectInfo.canRead(userId)) {\n\t\t\t\t\tif(copyIfMatch != null) {\n\t\t\t\t\t\tif(!copyIfMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfMatch: \" + copyIfMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(copyIfNoneMatch != null) {\n\t\t\t\t\t\tif(copyIfNoneMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfNoneMatch: \" + copyIfNoneMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(copyIfUnmodifiedSince != null) {\n\t\t\t\t\t\tlong unmodifiedTime = copyIfUnmodifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif(unmodifiedTime < objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfUnmodifiedSince: \" + copyIfUnmodifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(copyIfModifiedSince != null) {\n\t\t\t\t\t\tlong modifiedTime = copyIfModifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif(modifiedTime > objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfModifiedSince: \" + copyIfModifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBucketInfo destinationBucketInfo = new BucketInfo(destinationBucket);\n\t\t\t\t\tList<BucketInfo> destinationBuckets = db.query(destinationBucketInfo);\n\t\t\t\t\tif(destinationBuckets.size() > 0) {\n\t\t\t\t\t\tBucketInfo foundDestinationBucketInfo = destinationBuckets.get(0);\n\t\t\t\t\t\tif(foundDestinationBucketInfo.canWrite(userId)) {\n\t\t\t\t\t\t\t//all ok\n\t\t\t\t\t\t\tObjectInfo destinationObjectInfo = null;\n\t\t\t\t\t\t\tString destinationObjectName;\n\t\t\t\t\t\t\tObjectInfo destSearchObjectInfo = new ObjectInfo(destinationBucket, destinationKey);\n\t\t\t\t\t\t\tList<ObjectInfo> destinationObjectInfos = dbObject.query(destSearchObjectInfo);\n\t\t\t\t\t\t\tif(destinationObjectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo = destinationObjectInfos.get(0);\n\t\t\t\t\t\t\t\tif(!destinationObjectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", destinationKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tboolean addNew = false;\n\t\t\t\t\t\t\tif(destinationObjectInfo == null) {\n\t\t\t\t\t\t\t\t//not found. create a new one\n\t\t\t\t\t\t\t\tdestinationObjectInfo = new ObjectInfo();\n\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setBucketName(destinationBucket);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectKey(destinationKey);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectName(destinationKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4));\n\t\t\t\t\t\t\t\taddNew = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (destinationObjectInfo.canWriteACP(userId)) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestinationObjectInfo.setSize(sourceObjectInfo.getSize());\n\t\t\t\t\t\t\tdestinationObjectInfo.setStorageClass(sourceObjectInfo.getStorageClass());\n\t\t\t\t\t\t\tdestinationObjectInfo.setOwnerId(sourceObjectInfo.getOwnerId());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentType(sourceObjectInfo.getContentType());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentDisposition(sourceObjectInfo.getContentDisposition());\n\t\t\t\t\t\t\tString etag = sourceObjectInfo.getEtag();\n\t\t\t\t\t\t\tDate lastModified = sourceObjectInfo.getLastModified();\n\t\t\t\t\t\t\tdestinationObjectInfo.setEtag(etag);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLastModified(lastModified);\n\t\t\t\t\t\t\tif(!metadataDirective.equals(\"REPLACE\")) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setMetaData(sourceObjectInfo.cloneMetaData());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tList<MetaDataEntry> metaData = request.getMetaData();\n\t\t\t\t\t\t\t\tif(metaData != null)\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.replaceMetaData(metaData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tString sourceObjectName = sourceObjectInfo.getObjectName();\n\t\t\t\t\t\t\tdestinationObjectName = destinationObjectInfo.getObjectName();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstorageManager.copyObject(sourceBucket, sourceObjectName, destinationBucket, destinationObjectName);\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics)\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(sourceObjectInfo.getSize());\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Could not rename \" + sourceObjectName + \" to \" + destinationObjectName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\t\t\t\tif(addNew)\n\t\t\t\t\t\t\t\tdbObject.add(destinationObjectInfo);\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", destinationBucket);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(destinationBucket);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", sourceKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(sourceKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(sourceBucket);\n\t\t}\n\t}","commit_id":"6ea7f5d26b622c0cd2ff31a2cfb2effd331ebafe","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public PermissionCheckerBag getUserBag(long userId, long groupId)\n\t\tthrows Exception {\n\n\t\tPermissionCheckerBag bag = PermissionCacheUtil.getBag(userId, groupId);\n\n\t\tif (bag != null) {\n\t\t\treturn bag;\n\t\t}\n\n\t\ttry {\n\n\t\t\tGroup group = null;\n\n\t\t\tif (groupId > 0) {\n\t\t\t\tgroup = GroupLocalServiceUtil.getGroup(groupId);\n\t\t\t}\n\n\t\t\t// If we are checking permissions on an object that belongs to a\n\t\t\t// community, then it's only necessary to check the group that\n\t\t\t// represents the community and not all the groups that the user\n\t\t\t// belongs to. This is so because an object cannot belong to\n\t\t\t// more than one community.\n\n\t\t\tList<Group> userGroups = new ArrayList<Group>();\n\t\t\t//List<Group> userGroups = UserUtil.getGroups(userId);\n\n\t\t\tif (GroupLocalServiceUtil.hasUserGroup(userId, groupId)) {\n\t\t\t\tuserGroups.add(group);\n\t\t\t}\n\n\t\t\tList<Organization> userOrgs = getUserOrgs(userId);\n\n\t\t\tList<Group> userOrgGroups =\n\t\t\t\tGroupLocalServiceUtil.getOrganizationsGroups(userOrgs);\n\n\t\t\tList<UserGroup> userUserGroups =\n\t\t\t\tUserGroupLocalServiceUtil.getUserUserGroups(userId);\n\n\t\t\tList<Group> userUserGroupGroups =\n\t\t\t\tGroupLocalServiceUtil.getUserGroupsGroups(userUserGroups);\n\n\t\t\tList<Group> groups = new ArrayList<Group>(\n\t\t\t\tuserGroups.size() + userOrgGroups.size() +\n\t\t\t\t\tuserUserGroupGroups.size());\n\n\t\t\tgroups.addAll(userGroups);\n\t\t\tgroups.addAll(userOrgGroups);\n\t\t\tgroups.addAll(userUserGroupGroups);\n\n\t\t\tList<Role> roles = new UniqueList<Role>();\n\n\t\t\tif ((PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 3) ||\n\t\t\t\t(PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 4) ||\n\t\t\t\t(PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) ||\n\t\t\t\t(PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 6)) {\n\n\t\t\t\tif (groups.size() > 0) {\n\t\t\t\t\tList<Role> userRelatedRoles=\n\t\t\t\t\t\tRoleLocalServiceUtil.getUserRelatedRoles(\n\t\t\t\t\t\t\tuserId, groups);\n\n\t\t\t\t\troles.addAll(userRelatedRoles);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troles.addAll(RoleLocalServiceUtil.getUserRoles(userId));\n\t\t\t\t}\n\n\t\t\t\tList<Role> userGroupRoles =\n\t\t\t\t\tRoleLocalServiceUtil.getUserGroupRoles(userId, groupId);\n\n\t\t\t\troles.addAll(userGroupRoles);\n\n\t\t\t\tList<Role> userGroupGroupRoles =\n\t\t\t\t\tRoleLocalServiceUtil.getUserGroupGroupRoles(\n\t\t\t\t\t\tuserId, groupId);\n\n\t\t\t\troles.addAll(userGroupGroupRoles);\n\n\t\t\t\tif ((group != null) &&\n\t\t\t\t\t(group.isCommunity() || group.isOrganization())) {\n\n\t\t\t\t\taddRequiredMemberRole(group, roles);\n\t\t\t\t\taddTeamRoles(userId, group, roles);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\troles = new ArrayList<Role>();\n\t\t\t}\n\n\t\t\tbag = new PermissionCheckerBagImpl(\n\t\t\t\tuserId, userGroups, userOrgs, userOrgGroups,\n\t\t\t\tuserUserGroupGroups, groups, roles);\n\n\t\t\treturn bag;\n\t\t}\n\t\tfinally {\n\t\t\tif (bag == null) {\n\t\t\t\tbag = new PermissionCheckerBagImpl(\n\t\t\t\t\tuserId, new ArrayList<Group>(),\n\t\t\t\t\tnew ArrayList<Organization>(), new ArrayList<Group>(),\n\t\t\t\t\tnew ArrayList<Group>(), new ArrayList<Group>(),\n\t\t\t\t\tnew ArrayList<Role>());\n\t\t\t}\n\n\t\t\tPermissionCacheUtil.putBag(userId, groupId, bag);\n\t\t}\n\t}","id":34993,"modified_method":"public PermissionCheckerBag getUserBag(long userId, long groupId)\n\t\tthrows Exception {\n\n\t\tPermissionCheckerBag bag = PermissionCacheUtil.getBag(userId, groupId);\n\n\t\tif (bag != null) {\n\t\t\treturn bag;\n\t\t}\n\n\t\ttry {\n\n\t\t\tGroup group = null;\n\n\t\t\tif (groupId > 0) {\n\t\t\t\tgroup = GroupLocalServiceUtil.getGroup(groupId);\n\t\t\t}\n\n\t\t\t// If we are checking permissions on an object that belongs to a\n\t\t\t// community, then it's only necessary to check the group that\n\t\t\t// represents the community and not all the groups that the user\n\t\t\t// belongs to. This is so because an object cannot belong to\n\t\t\t// more than one community.\n\n\t\t\tList<Group> userGroups = new ArrayList<Group>();\n\t\t\t//List<Group> userGroups = UserUtil.getGroups(userId);\n\n\t\t\tif (group.isCommunity() &&\n\t\t\t\tGroupLocalServiceUtil.hasUserGroup(userId, groupId)) {\n\n\t\t\t\tuserGroups.add(group);\n\t\t\t}\n\n\t\t\tList<Organization> userOrgs = getUserOrgs(userId);\n\n\t\t\tList<Group> userOrgGroups =\n\t\t\t\tGroupLocalServiceUtil.getOrganizationsGroups(userOrgs);\n\n\t\t\tList<UserGroup> userUserGroups =\n\t\t\t\tUserGroupLocalServiceUtil.getUserUserGroups(userId);\n\n\t\t\tList<Group> userUserGroupGroups =\n\t\t\t\tGroupLocalServiceUtil.getUserGroupsGroups(userUserGroups);\n\n\t\t\tList<Group> groups = new ArrayList<Group>(\n\t\t\t\tuserGroups.size() + userOrgGroups.size() +\n\t\t\t\t\tuserUserGroupGroups.size());\n\n\t\t\tgroups.addAll(userGroups);\n\t\t\tgroups.addAll(userOrgGroups);\n\t\t\tgroups.addAll(userUserGroupGroups);\n\n\t\t\tList<Role> roles = new UniqueList<Role>();\n\n\t\t\tif ((PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 3) ||\n\t\t\t\t(PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 4) ||\n\t\t\t\t(PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) ||\n\t\t\t\t(PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 6)) {\n\n\t\t\t\tif (groups.size() > 0) {\n\t\t\t\t\tList<Role> userRelatedRoles=\n\t\t\t\t\t\tRoleLocalServiceUtil.getUserRelatedRoles(\n\t\t\t\t\t\t\tuserId, groups);\n\n\t\t\t\t\troles.addAll(userRelatedRoles);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troles.addAll(RoleLocalServiceUtil.getUserRoles(userId));\n\t\t\t\t}\n\n\t\t\t\tList<Role> userGroupRoles =\n\t\t\t\t\tRoleLocalServiceUtil.getUserGroupRoles(userId, groupId);\n\n\t\t\t\troles.addAll(userGroupRoles);\n\n\t\t\t\tList<Role> userGroupGroupRoles =\n\t\t\t\t\tRoleLocalServiceUtil.getUserGroupGroupRoles(\n\t\t\t\t\t\tuserId, groupId);\n\n\t\t\t\troles.addAll(userGroupGroupRoles);\n\n\t\t\t\tif ((group != null) &&\n\t\t\t\t\t((group.isCommunity() && userGroups.contains(group)) ||\n\t\t\t\t\t (group.isOrganization() &&\n\t\t\t\t\t\tuserOrgGroups.contains(group)))) {\n\n\t\t\t\t\taddRequiredMemberRole(group, roles);\n\t\t\t\t\taddTeamRoles(userId, group, roles);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\troles = new ArrayList<Role>();\n\t\t\t}\n\n\t\t\tbag = new PermissionCheckerBagImpl(\n\t\t\t\tuserId, userGroups, userOrgs, userOrgGroups,\n\t\t\t\tuserUserGroupGroups, groups, roles);\n\n\t\t\treturn bag;\n\t\t}\n\t\tfinally {\n\t\t\tif (bag == null) {\n\t\t\t\tbag = new PermissionCheckerBagImpl(\n\t\t\t\t\tuserId, new ArrayList<Group>(),\n\t\t\t\t\tnew ArrayList<Organization>(), new ArrayList<Group>(),\n\t\t\t\t\tnew ArrayList<Group>(), new ArrayList<Group>(),\n\t\t\t\t\tnew ArrayList<Role>());\n\t\t\t}\n\n\t\t\tPermissionCacheUtil.putBag(userId, groupId, bag);\n\t\t}\n\t}","commit_id":"0b455799531ba2ba84f07c3e2017350467de084c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<Role> getRoles(\n\t\t\tlong companyId, Group group, String modelResource)\n\t\tthrows SystemException {\n\n\t\tList<Role> allRoles = RoleLocalServiceUtil.getRoles(companyId);\n\n\t\tint[] types = new int[] {\n\t\t\tRoleConstants.TYPE_REGULAR, RoleConstants.TYPE_COMMUNITY\n\t\t};\n\n\t\tif (isPortalModelResource(modelResource)) {\n\t\t\tif (modelResource.equals(Organization.class.getName()) ||\n\t\t\t\tmodelResource.equals(User.class.getName())) {\n\n\t\t\t\ttypes = new int[] {\n\t\t\t\t\tRoleConstants.TYPE_REGULAR,\n\t\t\t\t\tRoleConstants.TYPE_ORGANIZATION\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttypes = new int[] {RoleConstants.TYPE_REGULAR};\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (group != null) {\n\t\t\t\tif (group.isOrganization()) {\n\t\t\t\t\ttypes = new int[] {\n\t\t\t\t\t\tRoleConstants.TYPE_REGULAR,\n\t\t\t\t\t\tRoleConstants.TYPE_ORGANIZATION\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (group.isUser()) {\n\t\t\t\t\ttypes = new int[] {RoleConstants.TYPE_REGULAR};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Role> roles = new ArrayList<Role>();\n\n\t\tfor (int type : types) {\n\t\t\tfor (Role role : allRoles) {\n\t\t\t\tif (role.getType() == type) {\n\t\t\t\t\troles.add(role);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn roles;\n\t}","id":34994,"modified_method":"public static List<Role> getRoles(\n\t\t\tlong companyId, Group group, String modelResource)\n\t\tthrows SystemException {\n\n\t\tList<Role> allRoles = RoleLocalServiceUtil.getRoles(companyId);\n\n\t\tint[] types = new int[] {\n\t\t\tRoleConstants.TYPE_REGULAR, RoleConstants.TYPE_COMMUNITY\n\t\t};\n\n\t\tif (isPortalModelResource(modelResource)) {\n\t\t\tif (modelResource.equals(Organization.class.getName()) ||\n\t\t\t\tmodelResource.equals(User.class.getName())) {\n\n\t\t\t\ttypes = new int[] {\n\t\t\t\t\tRoleConstants.TYPE_REGULAR,\n\t\t\t\t\tRoleConstants.TYPE_ORGANIZATION\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttypes = new int[] {RoleConstants.TYPE_REGULAR};\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (group != null) {\n\t\t\t\tif (group.isOrganization() ||\n\t\t\t\t\t(group.isStagingGroup() &&\n\t\t\t\t\t\tgroup.getLiveGroup().isOrganization())) {\n\n\t\t\t\t\ttypes = new int[] {\n\t\t\t\t\t\tRoleConstants.TYPE_REGULAR,\n\t\t\t\t\t\tRoleConstants.TYPE_ORGANIZATION\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (group.isUser()) {\n\t\t\t\t\ttypes = new int[] {RoleConstants.TYPE_REGULAR};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Role> roles = new ArrayList<Role>();\n\n\t\tfor (int type : types) {\n\t\t\tfor (Role role : allRoles) {\n\t\t\t\tif (role.getType() == type) {\n\t\t\t\t\troles.add(role);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn roles;\n\t}","commit_id":"e9b33a886f5b3840f947934b21c10ff6d15a8347","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, SideMenuPresenter.Display sideMenuView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n      initWidget(uiBinder.createAndBindUi(this));\n\n      readOnlyLabel.setText(\"[\" + messages.readOnly() + \"]\");\n\n      keyShortcuts.setTitle(messages.availableKeyShortcutsTitle());\n      searchAndReplace.setTitle(messages.projectWideSearchAndReplace());\n      documentList.setTitle(messages.documentListTitle());\n\n      resize.setTitle(messages.maximize());\n      resize.addStyleName(STYLE_MAXIMIZE);\n\n      this.documentListView = documentListView.asWidget();\n      this.editorContainer.add(this.documentListView);\n\n      this.translationView = translationView.asWidget();\n      this.editorContainer.add(this.translationView);\n\n      this.searchResultsView = searchResultsView.asWidget();\n      this.editorContainer.add(this.searchResultsView);\n      \n      sideMenuContainer.add(sideMenuView.asWidget());\n      \n      Window.enableScrolling(false);\n   }","id":34995,"modified_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, SideMenuPresenter.Display sideMenuView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n      initWidget(uiBinder.createAndBindUi(this));\n\n      readOnlyLabel.setText(\"[\" + messages.readOnly() + \"]\");\n\n      keyShortcuts.setTitle(messages.availableKeyShortcutsTitle());\n      searchAndReplace.setTitle(messages.projectWideSearchAndReplace());\n      documentList.setTitle(messages.documentListTitle());\n\n      resize.setTitle(messages.maximize());\n      resize.addStyleName(STYLE_MAXIMIZE);\n\n      this.searchResultsView = searchResultsView.asWidget();\n      this.editorContainer.add(this.searchResultsView);\n\n      this.translationView = translationView.asWidget();\n      this.editorContainer.add(this.translationView);\n\n      this.documentListView = documentListView.asWidget();\n      this.editorContainer.add(this.documentListView);\n\n      sideMenuContainer.add(sideMenuView.asWidget());\n\n      setWidgetVisible(this.documentListView, false);\n      setWidgetVisible(this.searchResultsView, false);\n      setWidgetVisible(this.translationView, false);\n      \n      Window.enableScrolling(false);\n   }","commit_id":"a178e38b999d7aa4be185b69613073237042cfbd","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void createGlossaryRequestForTransUnit(TransUnit transUnit)\n   {\n      StringBuilder sources = new StringBuilder();\n      for (String source : transUnit.getSources())\n      {\n         sources.append(source);\n         sources.append(\" \");\n      }\n      SearchType searchType = GetGlossary.SearchType.FUZZY;\n      display.getGlossaryTextBox().setText(\"\");\n      createGlossaryRequest(sources.toString(), searchType);\n   }","id":34996,"modified_method":"public void createGlossaryRequestForTransUnit(TransUnit transUnit)\n   {\n      StringBuilder sources = new StringBuilder();\n      for (String source : transUnit.getSources())\n      {\n         sources.append(source);\n         sources.append(\" \");\n      }\n      SearchType searchType = GetGlossary.SearchType.FUZZY;\n      createGlossaryRequest(sources.toString(), searchType);\n   }","commit_id":"a178e38b999d7aa4be185b69613073237042cfbd","url":"https://github.com/zanata/zanata-server"},{"original_method":"public LoadingPanel(String text, final Resources resources)\n   {\n      super(false, true);\n      HorizontalPanel hp = new HorizontalPanel();\n      hp.setSpacing(5);\n      hp.setSize(\"100%\", \"100%\");\n      hp.add(new Label(text));\n      hp.add(new Image(resources.loader()));\n      setStyleName(\"loadingPanel\");\n      add(hp);\n   }","id":34997,"modified_method":"public LoadingPanel(String text, final Resources resources)\n   {\n      super(false, true);\n      HorizontalPanel hp = new HorizontalPanel();\n      hp.setSpacing(5);\n      hp.setSize(\"100%\", \"100%\");\n      Label loadingLabel = new Label(text);\n      loadingLabel.setStyleName(\"loadingLabel\");\n      hp.add(loadingLabel);\n      hp.add(new Image(resources.loader()));\n      setStyleName(\"loadingPanel\");\n      add(hp);\n   }","commit_id":"a178e38b999d7aa4be185b69613073237042cfbd","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void renderTable(ArrayList<TransMemoryResultItem> memories, List<String> queries)\n   {\n      for (int i = 0; i < memories.size(); i++)\n      {\n         final TransMemoryResultItem item = memories.get(i);\n\n         resultTable.setWidget(i + 1, SOURCE_COL, getSourcePanel(item, queries));\n         resultTable.setWidget(i + 1, TARGET_COL, getTargetPanel(item));\n\n         Label countLabel = new Label(String.valueOf(item.getMatchCount()));\n         countLabel.setTitle(messages.matchCountTooltip(item.getMatchCount()));\n\n         resultTable.setWidget(i + 1, NUM_TRANS_COL, countLabel);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, NUM_TRANS_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, NUM_TRANS_COL, \"numTransCol\");\n         \n         if(i % 2 == 1)\n         {\n            resultTable.getRowFormatter().setStyleName(i + 1, \"oddRow\");\n         }\n\n         Button copyButton = new Button(messages.copy());\n         copyButton.setTitle(messages.copyTooltip());\n\n         copyButton.addClickHandler(new ClickHandler()\n         {\n            @Override\n            public void onClick(ClickEvent event)\n            {\n               listener.fireCopyEvent(item);\n            }\n         });\n\n         resultTable.setWidget(i + 1, ACTION_COL, copyButton);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, ACTION_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, ACTION_COL, \"actionCol\");\n\n         Label similarityLabel = new Label(item.getSimilarityPercent() + \"%\");\n         resultTable.setWidget(i + 1, SIMILARITY_COL, similarityLabel);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, SIMILARITY_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, SIMILARITY_COL, \"similarityCol\");\n         \n         InlineLabel infoCell = new InlineLabel();\n         infoCell.setStyleName(\"icon-info-circle-2 details\");\n         infoCell.addClickHandler(new ClickHandler()\n         {\n            @Override\n            public void onClick(ClickEvent event)\n            {\n               listener.showTMDetails(item);\n            }\n         });\n\n         resultTable.setWidget(i + 1, DETAILS_COL, infoCell);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, DETAILS_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, DETAILS_COL, \"detailCol\");\n      }\n      container.clear();\n      container.add(resultTable);\n   }","id":34998,"modified_method":"@Override\n   public void renderTable(ArrayList<TransMemoryResultItem> memories, List<String> queries)\n   {\n      for (int i = 0; i < memories.size(); i++)\n      {\n         final TransMemoryResultItem item = memories.get(i);\n\n         resultTable.setWidget(i + 1, SOURCE_COL, getSourcePanel(item, queries));\n         resultTable.setWidget(i + 1, TARGET_COL, getTargetPanel(item));\n\n         Label countLabel = new Label(String.valueOf(item.getMatchCount()));\n         countLabel.setTitle(messages.matchCountTooltip(item.getMatchCount()));\n\n         resultTable.setWidget(i + 1, NUM_TRANS_COL, countLabel);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, NUM_TRANS_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, NUM_TRANS_COL, \"numTransCol\");\n         \n         if(i % 2 == 1)\n         {\n            resultTable.getRowFormatter().setStyleName(i + 1, \"oddRow\");\n         }\n\n         Button copyButton = new Button(messages.copy());\n         copyButton.setTitle(messages.copyTooltip());\n\n         copyButton.addClickHandler(new ClickHandler()\n         {\n            @Override\n            public void onClick(ClickEvent event)\n            {\n               listener.fireCopyEvent(item);\n            }\n         });\n\n         resultTable.setWidget(i + 1, ACTION_COL, copyButton);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, ACTION_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, ACTION_COL, \"actionCol\");\n\n         Label similarityLabel = new Label((int) item.getSimilarityPercent() + \"%\");\n         resultTable.setWidget(i + 1, SIMILARITY_COL, similarityLabel);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, SIMILARITY_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, SIMILARITY_COL, \"similarityCol\");\n         \n         InlineLabel infoCell = new InlineLabel();\n         infoCell.setStyleName(\"icon-info-circle-2 details\");\n         infoCell.addClickHandler(new ClickHandler()\n         {\n            @Override\n            public void onClick(ClickEvent event)\n            {\n               listener.showTMDetails(item);\n            }\n         });\n\n         resultTable.setWidget(i + 1, DETAILS_COL, infoCell);\n         resultTable.getFlexCellFormatter().setStyleName(i + 1, DETAILS_COL, \"centered\");\n         resultTable.getFlexCellFormatter().addStyleName(i + 1, DETAILS_COL, \"detailCol\");\n      }\n      container.clear();\n      container.add(resultTable);\n   }","commit_id":"a178e38b999d7aa4be185b69613073237042cfbd","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public TMMergeForm(MergeOptionRenderer mergeOptionRenderer, MergeStatusRenderer mergeStatusRenderer)\n   {\n      this.mergeStatusRenderer = mergeStatusRenderer;\n      initWidget(uiBinder.createAndBindUi(this));\n\n      projectOptionGroup = new EnumRadioButtonGroup<MergeOption>(OptionType.PROJECT_MISMATCH.name(), MergeOption.class, mergeOptionRenderer);\n      projectOptionGroup.setSelectionChangeListener(this);\n      projectOptionGroup.addToContainer(differentProject).setDefaultSelected(MergeOption.FUZZY);\n\n      docIdOptionGroup = new EnumRadioButtonGroup<MergeOption>(OptionType.DOC_ID_MISMATCH.name(), MergeOption.class, mergeOptionRenderer);\n      docIdOptionGroup.setSelectionChangeListener(this);\n      docIdOptionGroup.addToContainer(differentDocument).setDefaultSelected(MergeOption.FUZZY);\n\n      contextOptionGroup = new EnumRadioButtonGroup<MergeOption>(OptionType.CTX_MISMATCH.name(), MergeOption.class, mergeOptionRenderer);\n      contextOptionGroup.setSelectionChangeListener(this);\n      contextOptionGroup.addToContainer(differentContext).setDefaultSelected(MergeOption.FUZZY);\n   }","id":34999,"modified_method":"@Inject\n   public TMMergeForm(MergeOptionRenderer mergeOptionRenderer, MergeStatusRenderer mergeStatusRenderer)\n   {\n      this.mergeStatusRenderer = mergeStatusRenderer;\n      initWidget(uiBinder.createAndBindUi(this));\n\n      matchThreshold.setItemText(0, messages.identical());\n\n      projectOptionGroup = new EnumRadioButtonGroup<MergeOption>(OptionType.PROJECT_MISMATCH.name(), MergeOption.class, mergeOptionRenderer);\n      projectOptionGroup.setSelectionChangeListener(this);\n      projectOptionGroup.addToContainer(differentProject).setDefaultSelected(MergeOption.FUZZY);\n\n      docIdOptionGroup = new EnumRadioButtonGroup<MergeOption>(OptionType.DOC_ID_MISMATCH.name(), MergeOption.class, mergeOptionRenderer);\n      docIdOptionGroup.setSelectionChangeListener(this);\n      docIdOptionGroup.addToContainer(differentDocument).setDefaultSelected(MergeOption.FUZZY);\n\n      contextOptionGroup = new EnumRadioButtonGroup<MergeOption>(OptionType.CTX_MISMATCH.name(), MergeOption.class, mergeOptionRenderer);\n      contextOptionGroup.setSelectionChangeListener(this);\n      contextOptionGroup.addToContainer(differentContext).setDefaultSelected(MergeOption.FUZZY);\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"}]