[{"original_method":"/**\n   * Returns a geometric object that represents the\n   * Point set symmetric difference of two geometries.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return symmetric difference geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value symDifference(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : gmlWriter(geom1.symDifference(geom2));\n  }","id":95000,"modified_method":"/**\n   * Returns a geometric object that represents the\n   * Point set symmetric difference of two geometries.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return symmetric difference geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value symDifference(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return gmlWriter(geo1.symDifference(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a geometric object that represents the Point set union of two geometries.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return union geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value union(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : gmlWriter(geom1.union(geom2));\n  }","id":95001,"modified_method":"/**\n   * Returns a geometric object that represents the Point set union of two geometries.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return union geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value union(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return gmlWriter(geo1.union(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the name of the geometry type in the GML namespace, or the empty sequence.\n   * @param node xml element containing gml object(s)\n   * @return geometry type\n   * @throws QueryException query exception\n   */\n  public QNm geometryType(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : new QNm(\"gml:\" + geom.getGeometryType());\n  }","id":95002,"modified_method":"/**\n   * Returns the name of the geometry type in the GML namespace, or the empty sequence.\n   * @param node xml element containing gml object(s)\n   * @return geometry type\n   * @throws QueryException query exception\n   */\n  public QNm geometryType(final ANode node) throws QueryException {\n    return new QNm(\"gml:\" + checkGeo(node).getGeometryType());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the name of the geometry type in the GML namespace, or the empty sequence.\n   * @param node xml element containing gml object(s)\n   * @return integer value of CRS of the geometry\n   * @throws QueryException query exception\n   */\n  public Int getSRID(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : Int.get(geom.getSRID());\n  }","id":95003,"modified_method":"/**\n   * Returns the name of the geometry type in the GML namespace, or the empty sequence.\n   * @param node xml element containing gml object(s)\n   * @return integer value of CRS of the geometry\n   * @throws QueryException query exception\n   */\n  public Int getSRID(final ANode node) throws QueryException {\n    return Int.get(checkGeo(node).getSRID());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a boolean value that shows if this geometry crosses the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln crosses(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : Bln.get(geom1.crosses(geom2));\n  }","id":95004,"modified_method":"/**\n   * Returns a boolean value that shows if this geometry crosses the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln crosses(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return Bln.get(geo1.crosses(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the number of interior rings in a polygon.\n   * @param node xml element containing gml object(s)\n   * @return integer number of interior rings\n   * @throws QueryException query exception\n   */\n  public Int numInteriorRing(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_POLYGON);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.polygonNeeded(node.qname().local());\n\n    return Int.get(((Polygon) geom).getNumInteriorRing());\n  }","id":95005,"modified_method":"/**\n   * Returns the number of interior rings in a polygon.\n   * @param node xml element containing gml object(s)\n   * @return integer number of interior rings\n   * @throws QueryException query exception\n   */\n  public Int numInteriorRing(final ANode node) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_POLYGON);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.polygonNeeded(node.qname().local());\n\n    return Int.get(((Polygon) geo).getNumInteriorRing());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a gml:Point that is interior of this geometry.\n   * If it cannot be inside the geometry, then it will be on the boundary.\n   * @param node xml element containing gml object(s)\n   * @return a point as a gml element\n   * @throws QueryException query exception\n   */\n  public Value pointOnSurface(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : gmlWriter(geom.getInteriorPoint());\n  }","id":95006,"modified_method":"/**\n   * Returns a gml:Point that is interior of this geometry.\n   * If it cannot be inside the geometry, then it will be on the boundary.\n   * @param node xml element containing gml object(s)\n   * @return a point as a gml element\n   * @throws QueryException query exception\n   */\n  public Value pointOnSurface(final ANode node) throws QueryException {\n    final Geometry geo = checkGeo(node);\n    return gmlWriter(geo.getInteriorPoint());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a boolean value that shows if this geometry intersects another geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln intersects(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : Bln.get(geom1.intersects(geom2));\n  }","id":95007,"modified_method":"/**\n   * Returns a boolean value that shows if this geometry intersects another geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln intersects(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return Bln.get(geo1.intersects(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the gml:Envelope of the specified geometry.\n   * The envelope is the minimum bounding box of this geometry.\n   * @param node xml element containing gml object(s)\n   * @return envelop element\n   * @throws QueryException query exception\n   */\n  public Value envelope(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : gmlWriter(geom.getEnvelope());\n  }","id":95008,"modified_method":"/**\n   * Returns the gml:Envelope of the specified geometry.\n   * The envelope is the minimum bounding box of this geometry.\n   * @param node xml element containing gml object(s)\n   * @return envelop element\n   * @throws QueryException query exception\n   */\n  public Value envelope(final ANode node) throws QueryException {\n    return gmlWriter(checkGeo(node).getEnvelope());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the nth geometry of a geometry collection,\n   * or the geometry if the input is not a collection.\n   * @param node xml element containing gml object(s)\n   * @param geoNumber integer number as the index of nth geometry\n   * @return geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value geometryN(final ANode node, final Int geoNumber) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    if(geom == null) return null;\n\n    final long n = geoNumber.itr();\n    if(n < 1 || n > geom.getNumGeometries()) throw GeoErrors.outOfRangeIdx(geoNumber);\n    return gmlWriter(geom.getGeometryN((int) n - 1));\n  }","id":95009,"modified_method":"/**\n   * Returns the nth geometry of a geometry collection,\n   * or the geometry if the input is not a collection.\n   * @param node xml element containing gml object(s)\n   * @param number integer number as the index of nth geometry\n   * @return geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value geometryN(final ANode node, final Int number) throws QueryException {\n    final Geometry geo = checkGeo(node);\n    final long n = number.itr();\n    if(n < 1 || n > geo.getNumGeometries()) throw GeoErrors.outOfRangeIdx(number);\n    return gmlWriter(geo.getGeometryN((int) n - 1));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the dimension of an item.\n   * @param node xml element containing gml object(s)\n   * @return dimension\n   * @throws QueryException query exception\n   */\n  public Int dimension(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : Int.get(geom.getDimension());\n  }","id":95010,"modified_method":"/**\n   * Returns the dimension of an item.\n   * @param node xml element containing gml object(s)\n   * @return dimension\n   * @throws QueryException query exception\n   */\n  public Int dimension(final ANode node) throws QueryException {\n    return Int.get(checkGeo(node).getDimension());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a boolean value that shows if this geometry touches the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln touches(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : Bln.get(geom1.touches(geom2));\n  }","id":95011,"modified_method":"/**\n   * Returns a boolean value that shows if this geometry touches the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln touches(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return Bln.get(geo1.touches(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the boundary of the geometry, in GML.\n   * The return value is a sequence of either gml:Point or gml:LinearRing elements.\n   * @param node xml element containing gml object(s)\n   * @return boundary element (geometry)\n   * @throws QueryException query exception\n   */\n  public Value boundary(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : gmlWriter(geom.getBoundary());\n  }","id":95012,"modified_method":"/**\n   * Returns the boundary of the geometry, in GML.\n   * The return value is a sequence of either gml:Point or gml:LinearRing elements.\n   * @param node xml element containing gml object(s)\n   * @return boundary element (geometry)\n   * @throws QueryException query exception\n   */\n  public Value boundary(final ANode node) throws QueryException {\n    return gmlWriter(checkGeo(node).getBoundary());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the area of a Geometry. Areal Geometries have a non-zero area.\n   * Returns zero for Point and Lines.\n   * @param node xml element containing gml object(s)\n   * @return geometry area as a double vaue\n   * @throws QueryException query exception\n   */\n  public Dbl area(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : Dbl.get(geom.getArea());\n  }","id":95013,"modified_method":"/**\n   * Returns the area of a Geometry. Areal Geometries have a non-zero area.\n   * Returns zero for Point and Lines.\n   * @param node xml element containing gml object(s)\n   * @return geometry area as a double vaue\n   * @throws QueryException query exception\n   */\n  public Dbl area(final ANode node) throws QueryException {\n    final Geometry geo = checkGeo(node);\n    return Dbl.get(geo.getArea());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the nth geometry of a geometry collection.\n   * @param node xml element containing gml object(s)\n   * @param ringNumber index of i-th interior ring\n   * @return n-th interior ring geometry (LineString) as a gml element\n   * @throws QueryException query exception\n   */\n  public Value interiorRingN(final ANode node, final Int ringNumber)\n      throws QueryException {\n\n    final Geometry geom = gmlReader(node, Q_GML_POLYGON);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.polygonNeeded(node.qname().local());\n\n    final long n = ringNumber.itr();\n    final int max = ((Polygon) geom).getNumInteriorRing();\n    if(n < 1 || n > max) throw GeoErrors.outOfRangeIdx(ringNumber);\n    return gmlWriter(((Polygon) geom).getInteriorRingN((int) n - 1));\n  }","id":95014,"modified_method":"/**\n   * Returns the nth geometry of a geometry collection.\n   * @param node xml element containing gml object(s)\n   * @param number index of i-th interior ring\n   * @return n-th interior ring geometry (LineString) as a gml element\n   * @throws QueryException query exception\n   */\n  public Value interiorRingN(final ANode node, final Int number) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_POLYGON);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.polygonNeeded(node.qname().local());\n\n    final long n = number.itr();\n    final int max = ((Polygon) geo).getNumInteriorRing();\n    if(n < 1 || n > max) throw GeoErrors.outOfRangeIdx(number);\n    return gmlWriter(((Polygon) geo).getInteriorRingN((int) n - 1));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a boolean value that shows if this geometry is disjoint to another geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln disjoint(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : Bln.get(geom1.disjoint(geom2));\n  }","id":95015,"modified_method":"/**\n   * Returns a boolean value that shows if this geometry is disjoint to another geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln disjoint(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return Bln.get(geo1.disjoint(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the end point of a line.\n   * @param node xml element containing gml object(s)\n   * @return end point geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value endPoint(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    return gmlWriter(geom instanceof LineString ?\n       ((LineString) geom).getEndPoint() :\n       ((LinearRing) geom).getEndPoint());\n  }","id":95016,"modified_method":"/**\n   * Returns the end point of a line.\n   * @param node xml element containing gml object(s)\n   * @return end point geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value endPoint(final ANode node) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    return gmlWriter(geo instanceof LineString ?\n       ((LineString) geo).getEndPoint() :\n       ((LinearRing) geo).getEndPoint());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Writes an geometry and returns a string representation of the geometry.\n   * @param geometry geometry\n   * @return string output written string\n   * @throws QueryException exception\n   */\n  private DBNode gmlWriter(final Geometry geometry) throws QueryException {\n    if(geometry.isEmpty()) return null;\n\n    String geom;\n    try {\n      geom = new GMLWriter().write(geometry);\n    } catch(final IOException ex) {\n      throw GeoErrors.gmlWriterErr(ex);\n    }\n\n    try {\n      final IO io = new IOContent(geom);\n      return new DBNode(MemBuilder.build(new XMLParser(io, context.context.prop)));\n    } catch(final IOException ex) {\n      throw Err.IOERR.thrw(null, ex);\n    }\n  }","id":95017,"modified_method":"/**\n   * Writes an geometry and returns a string representation of the geometry.\n   * @param geometry geometry\n   * @return string output written string\n   * @throws QueryException exception\n   */\n  private DBNode gmlWriter(final Geometry geometry) throws QueryException {\n    if(geometry.isEmpty()) return null;\n\n    String geo;\n    try {\n      geo = new GMLWriter().write(geometry);\n    } catch(final IOException ex) {\n      throw GeoErrors.gmlWriterErr(ex);\n    }\n\n    try {\n      final IO io = new IOContent(geo);\n      return new DBNode(MemBuilder.build(new XMLParser(io, context.context.prop)));\n    } catch(final IOException ex) {\n      throw Err.IOERR.thrw(null, ex);\n    }\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks if the node is an element with a valid QName.\n   * @param  node xml element containing gml object(s)\n   * @param geoName the geometry type to be used to validate the node qname.\n   * @return boolean value\n   * @throws QueryException exception\n   */\n  private boolean checkNode(final ANode node, final QNm... geoName)\n      throws QueryException {\n\n    if(node.type != NodeType.ELM)\n      Err.FUNCMP.thrw(null, this, NodeType.ELM, node.type);\n\n    final QNm qname = node.qname();\n    if(geoName.length != 0) {\n      // check limited set of types\n      for(final QNm geo : geoName) if(qname.eq(geo)) return true;\n      return false;\n    }\n    // check all supported types\n    for(final QNm geo : QNAMES) if(qname.eq(geo)) return true;\n    throw GeoErrors.unrecognizedGeo(qname.local());\n  }","id":95018,"modified_method":"/**\n   * Reads an element as a gml node. Returns a geometry element\n   * or {@code null} if the element does not match one of the specified types.\n   * @param node xml node containing gml object(s)\n   * @param names allowed geometry types\n   * @return geometry, or {@code null}\n   * @throws QueryException query exception\n   */\n  private Geometry geo(final ANode node, final QNm... names)\n      throws QueryException {\n\n    if(node.type != NodeType.ELM)\n      Err.FUNCMP.thrw(null, this, NodeType.ELM, node.type);\n\n    final QNm qname = node.qname();\n    for(final QNm geo : names) {\n      if(!qname.eq(geo)) continue;\n      // type found... create reader and geometry element\n      try {\n        final String input = node.serialize().toString();\n        final GMLReader gmlReader = new GMLReader();\n        final GeometryFactory geoFactory = new GeometryFactory();\n        return gmlReader.read(input, geoFactory);\n      } catch (final Throwable e) {\n        throw GeoErrors.gmlReaderErr(e);\n      }\n    }\n    return null;\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the number of points in a geometry.\n   * @param node xml element containing gml object(s)\n   * @return number of points int value\n   * @throws QueryException query exception\n   */\n  public Int numPoints(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : Int.get(geom.getNumPoints());\n  }","id":95019,"modified_method":"/**\n   * Returns the number of points in a geometry.\n   * @param node xml element containing gml object(s)\n   * @return number of points int value\n   * @throws QueryException query exception\n   */\n  public Int numPoints(final ANode node) throws QueryException {\n    final Geometry geo = checkGeo(node);\n    return Int.get(geo.getNumPoints());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the nth point of a line.\n   * @param node xml element containing gml object(s)\n   * @param pointNumber index of i-th point\n   * @return n-th point as a gml element\n   * @throws QueryException query exception\n   */\n  public Value pointN(final ANode node, final Int pointNumber) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    final int max = geom.getNumPoints();\n    final long n = pointNumber.itr();\n    if(n < 1 || n > max) throw GeoErrors.outOfRangeIdx(pointNumber);\n\n    return gmlWriter(geom instanceof LineString ?\n       ((LineString) geom).getPointN((int) n - 1) :\n       ((LinearRing) geom).getPointN((int) n - 1));\n  }","id":95020,"modified_method":"/**\n   * Returns the nth point of a line.\n   * @param node xml element containing gml object(s)\n   * @param number index of i-th point\n   * @return n-th point as a gml element\n   * @throws QueryException query exception\n   */\n  public Value pointN(final ANode node, final Int number) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    final int max = geo.getNumPoints();\n    final long n = number.itr();\n    if(n < 1 || n > max) throw GeoErrors.outOfRangeIdx(number);\n\n    return gmlWriter(geo instanceof LineString ?\n       ((LineString) geo).getPointN((int) n - 1) :\n       ((LinearRing) geo).getPointN((int) n - 1));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a geometric object representing the Point set intersection of two geometries.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return intersection geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value intersection(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : gmlWriter(geom1.intersection(geom2));\n  }","id":95021,"modified_method":"/**\n   * Returns a geometric object representing the Point set intersection of two geometries.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return intersection geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value intersection(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return gmlWriter(geo1.intersection(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the z-coordinate value for point.\n   * @param node xml element containing gml object(s)\n   * @return z double value\n   * @throws QueryException query exception\n   */\n  public Dbl z(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_POINT);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.pointNeeded(node.qname().local());\n\n    return Dbl.get(geom.getCoordinate().z);\n  }","id":95022,"modified_method":"/**\n   * Returns the z-coordinate value for point.\n   * @param node xml element containing gml object(s)\n   * @return z double value\n   * @throws QueryException query exception\n   */\n  public Dbl z(final ANode node) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_POINT);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.pointNeeded(node.qname().local());\n\n    return Dbl.get(geo.getCoordinate().z);\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Return a boolean value that shows weather the line is a ring or not.\n   * A line is a ring if it is closed and simple.\n   * @param node xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln isRing(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    return Bln.get(geom instanceof LineString ?\n       ((LineString) geom).isRing() :\n       ((LinearRing) geom).isRing());\n  }","id":95023,"modified_method":"/**\n   * Return a boolean value that shows weather the line is a ring or not.\n   * A line is a ring if it is closed and simple.\n   * @param node xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln isRing(final ANode node) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    return Bln.get(geo instanceof LineString ?\n       ((LineString) geo).isRing() :\n       ((LinearRing) geo).isRing());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the WKB format of a geometry.\n   * @param node xml element containing gml object(s)\n   * @return Well-Known Binary geometry representation\n   * @throws QueryException query exception\n   */\n  public B64 asBinary(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : new B64(new WKBWriter().write(geom));\n  }","id":95024,"modified_method":"/**\n   * Returns the WKB format of a geometry.\n   * @param node xml element containing gml object(s)\n   * @return Well-Known Binary geometry representation\n   * @throws QueryException query exception\n   */\n  public B64 asBinary(final ANode node) throws QueryException {\n    return new B64(new WKBWriter().write(checkGeo(node)));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the x-coordinate value for point.\n   * @param node xml element containing gml object(s)\n   * @return x double value\n   * @throws QueryException query exception\n   */\n  public Dbl x(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_POINT);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.pointNeeded(node.qname().local());\n\n    return Dbl.get(geom.getCoordinate().x);\n  }","id":95025,"modified_method":"/**\n   * Returns the x-coordinate value for point.\n   * @param node xml element containing gml object(s)\n   * @return x double value\n   * @throws QueryException query exception\n   */\n  public Dbl x(final ANode node) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_POINT);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.pointNeeded(node.qname().local());\n\n    return Dbl.get(geo.getCoordinate().x);\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the length of this Geometry. Linear geometries return their length.\n   * Areal geometries return their parameter. Others return 0.0\n   * @param node xml element containing gml object(s)\n   * @return length double value\n   * @throws QueryException query exception\n   */\n  public Dbl length(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : Dbl.get(geom.getLength());\n  }","id":95026,"modified_method":"/**\n   * Returns the length of this Geometry. Linear geometries return their length.\n   * Areal geometries return their parameter. Others return 0.0\n   * @param node xml element containing gml object(s)\n   * @return length double value\n   * @throws QueryException query exception\n   */\n  public Dbl length(final ANode node) throws QueryException {\n    final Geometry geo = checkGeo(node);\n    return Dbl.get(geo.getLength());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the WKT format of a geometry.\n   * @param node xml element containing gml object(s)\n   * @return Well-Known Text geometry representation\n   * @throws QueryException query exception\n   */\n  public Str asText(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node);\n    return geom == null ? null : Str.get(new WKTWriter().write(geom));\n  }","id":95027,"modified_method":"/**\n   * Returns the WKT format of a geometry.\n   * @param node xml element containing gml object(s)\n   * @return Well-Known Text geometry representation\n   * @throws QueryException query exception\n   */\n  public Str asText(final ANode node) throws QueryException {\n    return Str.get(new WKTWriter().write(checkGeo(node)));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the y-coordinate value for point.\n   * @param node xml element containing gml object(s)\n   * @return y double value\n   * @throws QueryException query exception\n   */\n  public Dbl y(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_POINT);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.pointNeeded(node.qname().local());\n\n    return Dbl.get(geom.getCoordinate().y);\n  }","id":95028,"modified_method":"/**\n   * Returns the y-coordinate value for point.\n   * @param node xml element containing gml object(s)\n   * @return y double value\n   * @throws QueryException query exception\n   */\n  public Dbl y(final ANode node) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_POINT);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.pointNeeded(node.qname().local());\n\n    return Dbl.get(geo.getCoordinate().y);\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a boolean value that shows if this geometry overlaps the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln overlaps(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : Bln.get(geom1.overlaps(geom2));\n  }","id":95029,"modified_method":"/**\n   * Returns a boolean value that shows if this geometry overlaps the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln overlaps(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return Bln.get(geo1.overlaps(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the start point of a line.\n   * @param node xml element containing gml object(s)\n   * @return start point geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value startPoint(final ANode node) throws QueryException {\n    final Geometry geom = gmlReader(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geom == null && gmlReader(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    return gmlWriter(geom instanceof LineString ?\n       ((LineString) geom).getStartPoint() :\n       ((LinearRing) geom).getStartPoint());\n  }","id":95030,"modified_method":"/**\n   * Returns the start point of a line.\n   * @param node xml element containing gml object(s)\n   * @return start point geometry as a gml element\n   * @throws QueryException query exception\n   */\n  public Value startPoint(final ANode node) throws QueryException {\n    final Geometry geo = geo(node, Q_GML_LINEARRING, Q_GML_LINESTRING);\n    if(geo == null && checkGeo(node) != null)\n      throw GeoErrors.lineNeeded(node.qname().local());\n\n    return gmlWriter(geo instanceof LineString ?\n       ((LineString) geo).getStartPoint() :\n       ((LinearRing) geo).getStartPoint());\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a boolean value that shows if this geometry is within the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln within(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geom1 = gmlReader(node1);\n    final Geometry geom2 = gmlReader(node2);\n    return geom1 == null || geom2 == null ? null : Bln.get(geom1.within(geom2));\n  }","id":95031,"modified_method":"/**\n   * Returns a boolean value that shows if this geometry is within the specified geometry.\n   * @param node1 xml element containing gml object(s)\n   * @param node2 xml element containing gml object(s)\n   * @return boolean value\n   * @throws QueryException query exception\n   */\n  public Bln within(final ANode node1, final ANode node2) throws QueryException {\n    final Geometry geo1 = checkGeo(node1);\n    final Geometry geo2 = checkGeo(node2);\n    return Bln.get(geo1.within(geo2));\n  }","commit_id":"003763b6ab59cb5fee5d1f059c1f20abcdb67a74","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public FileCollectionSnapshot snapshot(FileCollection input, boolean allowReuse, TaskFilePropertyCompareType compareType) {\n        final List<VisitedTree> fileTreeElements = Lists.newLinkedList();\n        final List<File> missingFiles = Lists.newArrayList();\n        visitFiles(input, fileTreeElements, missingFiles, allowReuse);\n\n        if (fileTreeElements.isEmpty() && missingFiles.isEmpty()) {\n            return emptySnapshot();\n        }\n\n        final List<TreeSnapshot> treeSnapshots = new ArrayList<TreeSnapshot>();\n        cacheAccess.useCache(\"Create file snapshot\", new Runnable() {\n            public void run() {\n                final List<VisitedTree> nonShareableTrees = new ArrayList<VisitedTree>();\n                for (VisitedTree tree : fileTreeElements) {\n                    if (tree.isShareable()) {\n                        treeSnapshots.add(tree.maybeCreateSnapshot(snapshotter, stringInterner));\n                    } else {\n                        nonShareableTrees.add(tree);\n                    }\n                }\n                if (!nonShareableTrees.isEmpty() || !missingFiles.isEmpty()) {\n                    VisitedTree nonShareableTree = createJoinedTree(nonShareableTrees, missingFiles);\n                    treeSnapshots.add(nonShareableTree.maybeCreateSnapshot(snapshotter, stringInterner));\n                }\n            }\n        });\n        return new FileCollectionSnapshotImpl(treeSnapshots, compareType);\n    }","id":95032,"modified_method":"@Override\n    public FileCollectionSnapshot snapshot(FileCollection input, TaskFilePropertyCompareType compareType) {\n        final List<FileTreeElement> fileTreeElements = Lists.newLinkedList();\n        final List<File> missingFiles = Lists.newArrayList();\n        visitFiles(input, fileTreeElements, missingFiles);\n\n        if (fileTreeElements.isEmpty() && missingFiles.isEmpty()) {\n            return emptySnapshot();\n        }\n\n        final Map<String, IncrementalFileSnapshot> snapshots = new HashMap<String, IncrementalFileSnapshot>();\n\n        cacheAccess.useCache(\"Create file snapshot\", new Runnable() {\n            public void run() {\n                for (FileTreeElement fileDetails : fileTreeElements) {\n                    String absolutePath = getInternedAbsolutePath(fileDetails.getFile());\n                    if (!snapshots.containsKey(absolutePath)) {\n                        if (fileDetails.isDirectory()) {\n                            snapshots.put(absolutePath, DirSnapshot.getInstance());\n                        } else {\n                            snapshots.put(absolutePath, new FileHashSnapshot(snapshotter.snapshot(fileDetails).getHash(), fileDetails.getLastModified()));\n                        }\n                    }\n                }\n                for (File missingFile : missingFiles) {\n                    String absolutePath = getInternedAbsolutePath(missingFile);\n                    if (!snapshots.containsKey(absolutePath)) {\n                        snapshots.put(absolutePath, MissingFileSnapshot.getInstance());\n                    }\n                }\n            }\n        });\n        return new FileCollectionSnapshotImpl(snapshots, compareType);\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"abstract protected void visitFiles(FileCollection input, List<VisitedTree> visitedTrees, List<File> missingFiles, boolean allowReuse);","id":95033,"modified_method":"abstract protected void visitFiles(FileCollection input, List<FileTreeElement> fileTreeElements, List<File> missingFiles);","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"protected FileCollectionSnapshot createSnapshot(FileCollectionSnapshotter snapshotter, FileCollection fileCollection, TaskFilePropertyCompareType compareType) {\n        try {\n            return snapshotter.snapshot(fileCollection, isAllowSnapshotReuse(), compareType);\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of %s files for task '%s' during up-to-date check.\", getInputFileType().toLowerCase(), taskName), e);\n        }\n    }","id":95034,"modified_method":"protected FileCollectionSnapshot createSnapshot(FileCollectionSnapshotter snapshotter, FileCollection fileCollection, TaskFilePropertyCompareType compareType) {\n        try {\n            return snapshotter.snapshot(fileCollection, compareType);\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of %s files for task '%s' during up-to-date check.\", getInputFileType().toLowerCase(), taskName), e);\n        }\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"protected AbstractNamedFileSnapshotTaskStateChanges(String taskName, TaskExecution previous, TaskExecution current, FileCollectionSnapshotter snapshotter, boolean allowSnapshotReuse, String title, SortedSet<? extends TaskFilePropertySpec> fileProperties) {\n        this.taskName = taskName;\n        this.previous = previous;\n        this.current = current;\n        this.snapshotter = snapshotter;\n        this.allowSnapshotReuse = allowSnapshotReuse;\n        this.title = title;\n        this.fileProperties = fileProperties;\n        this.fileSnapshotsBeforeExecution = buildSnapshots(taskName, snapshotter, title, fileProperties, allowSnapshotReuse);\n    }","id":95035,"modified_method":"protected AbstractNamedFileSnapshotTaskStateChanges(String taskName, TaskExecution previous, TaskExecution current, FileCollectionSnapshotter snapshotter, String title, SortedSet<? extends TaskFilePropertySpec> fileProperties) {\n        this.taskName = taskName;\n        this.previous = previous;\n        this.current = current;\n        this.snapshotter = snapshotter;\n        this.title = title;\n        this.fileProperties = fileProperties;\n        this.fileSnapshotsBeforeExecution = buildSnapshots(taskName, snapshotter, title, fileProperties);\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"protected static Map<String, FileCollectionSnapshot> buildSnapshots(String taskName, FileCollectionSnapshotter snapshotter, String title, SortedSet<? extends TaskFilePropertySpec> fileProperties, boolean allowSnapshotReuse) {\n        ImmutableMap.Builder<String, FileCollectionSnapshot> builder = ImmutableMap.builder();\n        for (TaskFilePropertySpec propertySpec : fileProperties) {\n            FileCollectionSnapshot result;\n            TaskFilePropertyCompareType compareType = propertySpec.getCompareType();\n            try {\n                result = snapshotter.snapshot(propertySpec.getPropertyFiles(), allowSnapshotReuse, compareType);\n            } catch (UncheckedIOException e) {\n                throw new UncheckedIOException(String.format(\"Failed to capture snapshot of %s files for task '%s' property '%s' during up-to-date check.\", title.toLowerCase(), taskName, propertySpec.getPropertyName()), e);\n            }\n            builder.put(propertySpec.getPropertyName(), result);\n        }\n        return builder.build();\n    }","id":95036,"modified_method":"protected static Map<String, FileCollectionSnapshot> buildSnapshots(String taskName, FileCollectionSnapshotter snapshotter, String title, SortedSet<? extends TaskFilePropertySpec> fileProperties) {\n        ImmutableMap.Builder<String, FileCollectionSnapshot> builder = ImmutableMap.builder();\n        for (TaskFilePropertySpec propertySpec : fileProperties) {\n            FileCollectionSnapshot result;\n            TaskFilePropertyCompareType compareType = propertySpec.getCompareType();\n            try {\n                result = snapshotter.snapshot(propertySpec.getPropertyFiles(), compareType);\n            } catch (UncheckedIOException e) {\n                throw new UncheckedIOException(String.format(\"Failed to capture snapshot of %s files for task '%s' property '%s' during up-to-date check.\", title.toLowerCase(), taskName, propertySpec.getPropertyName()), e);\n            }\n            builder.put(propertySpec.getPropertyName(), result);\n        }\n        return builder.build();\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public Long add(FileCollectionSnapshot snapshot) {\n        Long id = idGenerator.generateId();\n        cache.put(id, snapshot);\n        treeSnapshotRepository.addTreeSnapshotUsage(snapshot, id);\n        return id;\n    }","id":95037,"modified_method":"public Long add(FileCollectionSnapshot snapshot) {\n        Long id = idGenerator.generateId();\n        cache.put(id, snapshot);\n        return id;\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public CacheBackedFileSnapshotRepository(TaskArtifactStateCacheAccess cacheAccess, Serializer<FileCollectionSnapshot> serializer, IdGenerator<Long> idGenerator, TreeSnapshotRepository treeSnapshotRepository) {\n        this.idGenerator = idGenerator;\n        this.treeSnapshotRepository = treeSnapshotRepository;\n        cache = cacheAccess.createCache(\"fileSnapshots\", Long.class, serializer);\n    }","id":95038,"modified_method":"public CacheBackedFileSnapshotRepository(TaskArtifactStateCacheAccess cacheAccess, Serializer<FileCollectionSnapshot> serializer, IdGenerator<Long> idGenerator) {\n        this.idGenerator = idGenerator;\n        cache = cacheAccess.createCache(\"fileSnapshots\", Long.class, serializer);\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public void remove(Long id) {\n        cache.remove(id);\n        treeSnapshotRepository.removeTreeSnapshotUsage(id);\n    }","id":95039,"modified_method":"public void remove(Long id) {\n        cache.remove(id);\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void visitFiles(FileCollection input, final List<VisitedTree> visitedTrees, final List<File> missingFiles, boolean allowReuse) {\n        DefaultFileCollectionResolveContext context = new DefaultFileCollectionResolveContext(fileResolver);\n        context.add(input);\n        List<FileTreeInternal> fileTrees = context.resolveAsFileTrees();\n\n        for (FileTreeInternal fileTree : fileTrees) {\n            visitedTrees.add(treeVisitor.visitTreeForSnapshotting(fileTree, allowReuse));\n        }\n    }","id":95040,"modified_method":"@Override\n    protected void visitFiles(FileCollection input, final List<FileTreeElement> fileTreeElements, final List<File> missingFiles) {\n        DefaultFileCollectionResolveContext context = new DefaultFileCollectionResolveContext(fileResolver);\n        context.add(input);\n        List<FileTreeInternal> fileTrees = context.resolveAsFileTrees();\n\n        for (FileTreeInternal fileTree : fileTrees) {\n            fileTreeElements.addAll(visitTreeForSnapshotting(fileTree));\n        }\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultFileCollectionSnapshotter(FileSnapshotter snapshotter, TaskArtifactStateCacheAccess cacheAccess, StringInterner stringInterner, FileResolver fileResolver, CachingTreeVisitor treeVisitor, TreeSnapshotRepository treeSnapshotRepository) {\n        super(snapshotter, cacheAccess, stringInterner, fileResolver);\n        this.treeVisitor = treeVisitor;\n        this.treeSnapshotRepository = treeSnapshotRepository;\n    }","id":95041,"modified_method":"public DefaultFileCollectionSnapshotter(FileSnapshotter snapshotter, TaskArtifactStateCacheAccess cacheAccess, StringInterner stringInterner, FileResolver fileResolver) {\n        super(snapshotter, cacheAccess, stringInterner, fileResolver);\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultFileSnapshotterSerializer(StringInterner stringInterner, TreeSnapshotRepository treeSnapshotRepository) {\n        this.stringInterner = stringInterner;\n        this.treeSnapshotRepository = treeSnapshotRepository;\n    }","id":95042,"modified_method":"public DefaultFileSnapshotterSerializer(StringInterner stringInterner) {\n        this.stringInterner = stringInterner;\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollectionSnapshotImpl read(Decoder decoder) throws Exception {\n        TaskFilePropertyCompareType compareType = TaskFilePropertyCompareType.values()[decoder.readSmallInt()];\n        List<TreeSnapshot> treeSnapshots = new ArrayList<TreeSnapshot>();\n        int sharedTreeCount = decoder.readSmallInt();\n        for (int i = 0; i < sharedTreeCount; i++) {\n            long treeId = decoder.readLong();\n            treeSnapshots.add(treeSnapshotRepository.getTreeSnapshot(treeId));\n        }\n        TreeSnapshot nonShared = TreeSnapshotSerializer.readStoredTreeSnapshot(-1, decoder, incrementalFileSnapshotSerializer, stringInterner);\n        if (!nonShared.getFileSnapshots().isEmpty()) {\n            treeSnapshots.add(nonShared);\n        }\n        return new FileCollectionSnapshotImpl(treeSnapshots, compareType);\n    }","id":95043,"modified_method":"public FileCollectionSnapshotImpl read(Decoder decoder) throws Exception {\n        TaskFilePropertyCompareType compareType = TaskFilePropertyCompareType.values()[decoder.readSmallInt()];\n        Map<String, IncrementalFileSnapshot> snapshots = new HashMap<String, IncrementalFileSnapshot>();\n        int snapshotsCount = decoder.readSmallInt();\n        for (int i = 0; i < snapshotsCount; i++) {\n            String key = stringInterner.intern(decoder.readString());\n            byte fileSnapshotKind = decoder.readByte();\n            if (fileSnapshotKind == 1) {\n                snapshots.put(key, DirSnapshot.getInstance());\n            } else if (fileSnapshotKind == 2) {\n                snapshots.put(key, MissingFileSnapshot.getInstance());\n            } else if (fileSnapshotKind == 3) {\n                snapshots.put(key, new FileHashSnapshot(hashValueSerializer.read(decoder)));\n            } else {\n                throw new RuntimeException(\"Unable to read serialized file collection snapshot. Unrecognized value found in the data stream.\");\n            }\n        }\n        return new FileCollectionSnapshotImpl(snapshots, compareType);\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public void write(Encoder encoder, FileCollectionSnapshotImpl value) throws Exception {\n        encoder.writeSmallInt(value.compareType.ordinal());\n        final List<TreeSnapshot> treeSnapshots = value.treeSnapshots;\n        if (treeSnapshots != null) {\n            TreeSnapshot nonShared = null;\n            for (TreeSnapshot snapshot : treeSnapshots) {\n                if (!snapshot.isShareable()) {\n                    if (nonShared != null) {\n                        throw new RuntimeException(\"Multiple non-shared snapshots aren't supported.\");\n                    }\n                    nonShared = snapshot;\n                }\n            }\n            encoder.writeSmallInt(treeSnapshots.size() - ((nonShared != null) ? 1 : 0));\n            for (TreeSnapshot snapshot : treeSnapshots) {\n                if (snapshot.isShareable()) {\n                    encoder.writeLong(treeSnapshotRepository.maybeStoreTreeSnapshot(snapshot));\n                }\n            }\n            if (nonShared != null) {\n                TreeSnapshotSerializer.writeTreeSnapshot(nonShared, encoder, incrementalFileSnapshotSerializer);\n            } else {\n                encoder.writeSmallInt(0);\n            }\n        } else {\n            encoder.writeSmallInt(0);\n            encoder.writeSmallInt(value.snapshots.size());\n            for (Map.Entry<String, IncrementalFileSnapshot> entry : value.snapshots.entrySet()) {\n                encoder.writeString(entry.getKey());\n                incrementalFileSnapshotSerializer.write(encoder, entry.getValue());\n            }\n        }\n    }","id":95044,"modified_method":"public void write(Encoder encoder, FileCollectionSnapshotImpl value) throws Exception {\n        encoder.writeSmallInt(value.compareType.ordinal());\n        encoder.writeSmallInt(value.snapshots.size());\n        for (String key : value.snapshots.keySet()) {\n            encoder.writeString(key);\n            IncrementalFileSnapshot incrementalFileSnapshot = value.snapshots.get(key);\n            if (incrementalFileSnapshot instanceof DirSnapshot) {\n                encoder.writeByte((byte) 1);\n            } else if (incrementalFileSnapshot instanceof MissingFileSnapshot) {\n                encoder.writeByte((byte) 2);\n            } else if (incrementalFileSnapshot instanceof FileHashSnapshot) {\n                encoder.writeByte((byte) 3);\n                hashValueSerializer.write(encoder, incrementalFileSnapshot.getHash());\n            }\n        }\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollectionSnapshotImpl(Map<String, IncrementalFileSnapshot> snapshots, TaskFilePropertyCompareType compareType) {\n        this(snapshots, null, compareType);\n    }","id":95045,"modified_method":"public FileCollectionSnapshotImpl(Map<String, IncrementalFileSnapshot> snapshots, TaskFilePropertyCompareType compareType) {\n        this.snapshots = snapshots;\n        this.compareType = compareType;\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"BuildExecuter createBuildExecuter() {\n        // initialize TreeVisitorCacheExpirationStrategy so that listeners get registered\n        get(TreeVisitorCacheExpirationStrategy.class);\n        return new DefaultBuildExecuter(\n                asList(new DryRunBuildExecutionAction(),\n                        new SelectedTaskExecutionAction()));\n    }","id":95046,"modified_method":"BuildExecuter createBuildExecuter() {\n        return new DefaultBuildExecuter(\n                asList(new DryRunBuildExecutionAction(),\n                        new SelectedTaskExecutionAction()));\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public int scaleCacheSize(int referenceValue, int granularity) {\n        if (referenceValue < granularity) {\n            throw new IllegalArgumentException(\"reference value must be larger than granularity\");\n        }\n        return (int) ((double) referenceValue * sizingRatio) / granularity * granularity;\n    }","id":95047,"modified_method":"private int scaleCacheSize(int referenceValue, int granularity) {\n        if (referenceValue < granularity) {\n            throw new IllegalArgumentException(\"reference value must be larger than granularity\");\n        }\n        return (int) ((double) referenceValue * sizingRatio) / granularity * granularity;\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public InputFilesTaskStateChanges(TaskExecution previous, TaskExecution current, TaskInternal task, FileCollectionSnapshotter snapshotter) {\n        super(task.getName(), previous, current, snapshotter, true, \"Input\", task.getInputs().getFileProperties());\n        // Inputs are considered to be unchanged during task execution\n        current.setInputFilesSnapshot(getCurrent());\n    }","id":95048,"modified_method":"public InputFilesTaskStateChanges(TaskExecution previous, TaskExecution current, TaskInternal task, FileCollectionSnapshotter snapshotter) {\n        super(task.getName(), previous, current, snapshotter, \"Input\", task.getInputs().getFileProperties());\n        // Inputs are considered to be unchanged during task execution\n        current.setInputFilesSnapshot(getCurrent());\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void visitFiles(FileCollection input, List<VisitedTree> visitedTrees, List<File> missingFiles, boolean allowReuse) {\n        final List<FileTreeElement> fileTreeElements = new ArrayList<FileTreeElement>();\n        for (File file : input.getFiles()) {\n            if (file.exists()) {\n                fileTreeElements.add(new DefaultFileVisitDetails(file, fileSystem, fileSystem));\n            } else {\n                missingFiles.add(file);\n            }\n        }\n        visitedTrees.add(DefaultVisitedTree.of(fileTreeElements));\n    }","id":95049,"modified_method":"@Override\n    protected void visitFiles(FileCollection input, List<FileTreeElement> fileTreeElements, List<File> missingFiles) {\n        for (File file : input.getFiles()) {\n            if (file.exists()) {\n                fileTreeElements.add(new DefaultFileVisitDetails(file, fileSystem, fileSystem));\n            } else {\n                missingFiles.add(file);\n            }\n        }\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public FileCollectionSnapshot snapshot(FileCollection files, boolean allowReuse, TaskFilePropertyCompareType compareType) {\n        return new OutputFilesSnapshot(getRoots(files), snapshotter.snapshot(files, allowReuse, compareType));\n    }","id":95050,"modified_method":"@Override\n    public FileCollectionSnapshot snapshot(FileCollection files, TaskFilePropertyCompareType compareType) {\n        return new OutputFilesSnapshot(getRoots(files), snapshotter.snapshot(files, compareType));\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void saveCurrent() {\n        final Map<String, FileCollectionSnapshot> outputFilesAfter = buildSnapshots(getTaskName(), getSnapshotter(), getTitle(), getFileProperties(), isAllowSnapshotReuse());\n\n        ImmutableMap.Builder<String, FileCollectionSnapshot> builder = ImmutableMap.builder();\n        for (TaskFilePropertySpec propertySpec : fileProperties) {\n            String propertyName = propertySpec.getPropertyName();\n            FileCollection roots = propertySpec.getPropertyFiles();\n            FileCollectionSnapshot beforeExecution = getCurrent().get(propertyName);\n            FileCollectionSnapshot afterExecution = outputFilesAfter.get(propertyName);\n            FileCollectionSnapshot afterPreviousExecution = getSnapshotAfterPreviousExecution(propertyName);\n            FileCollectionSnapshot outputSnapshot = getSnapshotter().createOutputSnapshot(afterPreviousExecution, beforeExecution, afterExecution, roots);\n            builder.put(propertyName, outputSnapshot);\n        }\n\n        current.setOutputFilesSnapshot(builder.build());\n    }","id":95051,"modified_method":"@Override\n    public void saveCurrent() {\n        final Map<String, FileCollectionSnapshot> outputFilesAfter = buildSnapshots(getTaskName(), getSnapshotter(), getTitle(), getFileProperties());\n\n        ImmutableMap.Builder<String, FileCollectionSnapshot> builder = ImmutableMap.builder();\n        for (TaskFilePropertySpec propertySpec : fileProperties) {\n            String propertyName = propertySpec.getPropertyName();\n            FileCollection roots = propertySpec.getPropertyFiles();\n            FileCollectionSnapshot beforeExecution = getCurrent().get(propertyName);\n            FileCollectionSnapshot afterExecution = outputFilesAfter.get(propertyName);\n            FileCollectionSnapshot afterPreviousExecution = getSnapshotAfterPreviousExecution(propertyName);\n            FileCollectionSnapshot outputSnapshot = getSnapshotter().createOutputSnapshot(afterPreviousExecution, beforeExecution, afterExecution, roots);\n            builder.put(propertyName, outputSnapshot);\n        }\n\n        current.setOutputFilesSnapshot(builder.build());\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public OutputFilesTaskStateChanges(TaskExecution previous, TaskExecution current, TaskInternal task, OutputFilesCollectionSnapshotter snapshotter) {\n        super(task.getName(), previous, current, snapshotter, false, \"Output\", task.getOutputs().getFileProperties());\n    }","id":95052,"modified_method":"public OutputFilesTaskStateChanges(TaskExecution previous, TaskExecution current, TaskInternal task, OutputFilesCollectionSnapshotter snapshotter) {\n        super(task.getName(), previous, current, snapshotter, \"Output\", task.getOutputs().getFileProperties());\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"TaskArtifactStateRepository createTaskArtifactStateRepository(Instantiator instantiator, TaskArtifactStateCacheAccess cacheAccess, StartParameter startParameter, FileSnapshotter fileSnapshotter,\n                                                                  StringInterner stringInterner, FileResolver fileResolver, FileSystem fileSystem, FileCollectionFactory fileCollectionFactory,\n                                                                  CachingTreeVisitor treeVisitor, TreeSnapshotRepository treeSnapshotRepository, ClassLoaderHierarchyHasher classLoaderHierarchyHasher) {\n        FileCollectionSnapshotter fileCollectionSnapshotter = new DefaultFileCollectionSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, treeVisitor, treeSnapshotRepository);\n        FileCollectionSnapshotter discoveredFileCollectionSnapshotter = new MinimalFileSetSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, fileSystem);\n\n        OutputFilesCollectionSnapshotter outputFilesSnapshotter = new OutputFilesCollectionSnapshotter(fileCollectionSnapshotter, stringInterner);\n\n        SerializerRegistry serializerRegistry = new DefaultSerializerRegistry();\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n        outputFilesSnapshotter.registerSerializers(serializerRegistry);\n        discoveredFileCollectionSnapshotter.registerSerializers(serializerRegistry);\n\n        TaskHistoryRepository taskHistoryRepository = new CacheBackedTaskHistoryRepository(cacheAccess,\n            new CacheBackedFileSnapshotRepository(cacheAccess,\n                serializerRegistry.build(FileCollectionSnapshot.class),\n                new RandomLongIdGenerator(),\n                treeSnapshotRepository),\n            stringInterner);\n\n        return new ShortCircuitTaskArtifactStateRepository(\n            startParameter,\n            instantiator,\n            new DefaultTaskArtifactStateRepository(\n                taskHistoryRepository,\n                instantiator,\n                outputFilesSnapshotter,\n                fileCollectionSnapshotter,\n                discoveredFileCollectionSnapshotter,\n                fileCollectionFactory,\n                classLoaderHierarchyHasher\n            )\n        );\n    }","id":95053,"modified_method":"TaskArtifactStateRepository createTaskArtifactStateRepository(Instantiator instantiator, TaskArtifactStateCacheAccess cacheAccess, StartParameter startParameter, FileSnapshotter fileSnapshotter,\n                                                                  StringInterner stringInterner, FileResolver fileResolver, FileSystem fileSystem, FileCollectionFactory fileCollectionFactory,\n                                                                  ClassLoaderHierarchyHasher classLoaderHierarchyHasher) {\n        FileCollectionSnapshotter fileCollectionSnapshotter = new DefaultFileCollectionSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver);\n        FileCollectionSnapshotter discoveredFileCollectionSnapshotter = new MinimalFileSetSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, fileSystem);\n\n        OutputFilesCollectionSnapshotter outputFilesSnapshotter = new OutputFilesCollectionSnapshotter(fileCollectionSnapshotter, stringInterner);\n\n        SerializerRegistry serializerRegistry = new DefaultSerializerRegistry();\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n        outputFilesSnapshotter.registerSerializers(serializerRegistry);\n        discoveredFileCollectionSnapshotter.registerSerializers(serializerRegistry);\n\n        TaskHistoryRepository taskHistoryRepository = new CacheBackedTaskHistoryRepository(cacheAccess,\n            new CacheBackedFileSnapshotRepository(cacheAccess,\n                serializerRegistry.build(FileCollectionSnapshot.class),\n                new RandomLongIdGenerator()),\n            stringInterner);\n\n        return new ShortCircuitTaskArtifactStateRepository(\n            startParameter,\n            instantiator,\n            new DefaultTaskArtifactStateRepository(\n                taskHistoryRepository,\n                instantiator,\n                outputFilesSnapshotter,\n                fileCollectionSnapshotter,\n                discoveredFileCollectionSnapshotter,\n                fileCollectionFactory,\n                classLoaderHierarchyHasher\n            )\n        );\n    }","commit_id":"50eeae3466bec7f772c852174850d8afc7514c81","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean maybeSetEnvironment(Map<String, String> source) {\n        Set<String> newKeys = source.keySet();\n        for (Map.Entry<String, String> entry : System.getenv().entrySet()) {\n            if (!newKeys.contains(entry.getKey())) {\n                removeEnvironmentVariable(entry.getKey());\n            }\n        }\n        for (Map.Entry<String, String> entry : source.entrySet()) {\n            setEnvironmentVariable(entry.getKey(), entry.getValue());\n        }\n        return true;\n    }","id":95054,"modified_method":"public boolean maybeSetEnvironment(Map<String, String> source) {\n        // need to take copy to prevent ConcurrentModificationException\n        List<String> keysToRemove = Lists.newArrayList(Sets.difference(System.getenv().keySet(), source.keySet()));\n        for (String key : keysToRemove) {\n            removeEnvironmentVariable(key);\n        }\n        for (Map.Entry<String, String> entry : source.entrySet()) {\n            setEnvironmentVariable(entry.getKey(), entry.getValue());\n        }\n        return true;\n    }","commit_id":"f773989fa72130c4b891283d7a60624cccebc1cf","url":"https://github.com/gradle/gradle"},{"original_method":"public static void viaDesktop(URI u) throws IllegalAccessException, InvocationTargetException, URISyntaxException {\n\t    desktopBrowseMethod.invoke(desktopObject, u);\n    }","id":95055,"modified_method":"public static void viaDesktop(URI u) throws IllegalAccessException, InvocationTargetException, URISyntaxException {\n\t    if (desktopBrowseMethod == null)\n\t    \tthrow new UnsupportedOperationException(\"Launch via desktop not available\");\n\t    desktopBrowseMethod.invoke(desktopObject, u);\n    }","commit_id":"dbd9fdf78b53ca05aac90bb11904ff1e0c4bb348","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static Boolean viaWebStart(URL url) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\treturn (Boolean) jnlpShowMethod.invoke(jnlpShowObject,  url );\n\t}","id":95056,"modified_method":"public static Boolean viaWebStart(URL url) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (jnlpShowMethod == null)\n\t    \tthrow new UnsupportedOperationException(\"Launch via web start not available\");\n\t    return (Boolean) jnlpShowMethod.invoke(jnlpShowObject,  url );\n\t}","commit_id":"dbd9fdf78b53ca05aac90bb11904ff1e0c4bb348","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public TestDesktopIntegration() {\n\t\tsetLayout(new BorderLayout());\n\t\tJPanel top = new JPanel();\n\t\ttop.setLayout(new FlowLayout());\n\t\tadd(top, BorderLayout.NORTH);\n\n\t\tJScrollPane scrollPane = new JScrollPane(console, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n\t\t        JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\t\tconsole.setEditable(false);\n\t\tconsole.setLineWrap(true);\n\t\tadd(scrollPane);\n\t\tJButton desktop = new JButton(\"Launch via Desktop\");\n\t\tdesktop.addActionListener(new ActionListener() {\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttry {\n\n\t\t\t\t\twriter.println(\"Launch via desktop of \" + url);\n\t\t\t\t\tLaunchBrowser.viaDesktop(url.toURI());\n\t\t\t\t} catch (Exception e1) {\n\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t}\n\t\t\t\twriter.println(\"Launch via desktop completed\");\n\t\t\t}\n\t\t});\n\t\ttop.add(desktop);\n\n\t\tJButton jnlp = new JButton(\"Launch via jnlp\");\n\t\tjnlp.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttry {\n\n\t\t\t\t\twriter.println(\"Launch via jnlp of \" + url);\n\t\t\t\t\tLaunchBrowser.viaWebStart(url);\n\t\t\t\t} catch (Exception e1) {\n\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t}\n\t\t\t\twriter.println(\"Launch via jnlp completed\");\n\t\t\t}\n\t\t});\n\t\ttop.add(jnlp);\n\n\t\tJButton exec = new JButton(\"Launch via exec\");\n\t\texec.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttry {\n\t\t\t\t\twriter.println(\"Launch via exec firefox \"+url);\n\t\t\t\t\tProcess p = LaunchBrowser.launchFirefox(url);\n\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t\tint exitValue = p.exitValue();\n\t\t\t\t\twriter.println(\"Exit code: \" + exitValue);\n\t\t\t\t} catch (Exception e1) {\n\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t}\n\t\t\t\twriter.println(\"Launch via exec firefox completed\");\n\t\t\t}\n\t\t});\n\t\ttop.add(exec);\n\n\t\tJButton chooseFile = new JButton(\"Choose file\");\n\t\ttop.add(chooseFile);\n\t\tchooseFile.addActionListener(new ActionListener() {\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tfinal JFileChooser fc = new JFileChooser();\n\t\t\t\tint retvel = fc.showOpenDialog(TestDesktopIntegration.this);\n\t\t\t\tif (retvel == JFileChooser.APPROVE_OPTION) {\n\t\t\t\t\tFile file = fc.getSelectedFile();\n\t\t\t\t\ttry {\n\t\t\t\t\t\twriter.println(\"File choosen:\");\n\t\t\t\t\t\twriter.println(\"File path: \" + file.getAbsolutePath());\n\t\t\t\t\t\twriter.println(\"File canonical path: \" + file.getCanonicalPath());\n\n\t\t\t\t\t\twriter.println(\"File uri: \" + file.toURI());\n\n\t\t\t\t\t\twriter.println(\"File url: \" + file.toURL());\n\t\t\t\t\t} catch (Exception e1) {\n\t\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\twriter.println(\"System properties:\");\n\t\tfor (Map.Entry e : System.getProperties().entrySet()) {\n\t\t\twriter.println((e.getKey() + \"=\" + e.getValue()));\n\t\t}\n\n\t\ttry {\n\t\t\tClass<?> serviceManagerClass = Class.forName(\"javax.jnlp.ServiceManager\");\n\t\t\tMethod getServiceNamesMethod = serviceManagerClass.getMethod(\"getServiceNames\", new Class[] {});\n\t\t\tMethod lookupMethod = serviceManagerClass.getMethod(\"lookup\", new Class[] { String.class });\n\t\t\tString[] serviceNames = (String[]) getServiceNamesMethod.invoke(null, new Object[] {});\n\t\t\twriter.println(\"JNLP service providers:\");\n\t\t\tfor (String s : serviceNames) {\n\t\t\t\tObject o = lookupMethod.invoke(null, new Object[] { s });\n\t\t\t\twriter.println(s + \" = \" + o.getClass().getName());\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\twriter.println(\"unable to get JNLP service provider:\");\n\t\t\te.printStackTrace(writer);\n\n\t\t}\n\n\t}","id":95057,"modified_method":"public TestDesktopIntegration() {\n\t\tsetLayout(new BorderLayout());\n\t\tJPanel top = new JPanel();\n\t\ttop.setLayout(new FlowLayout());\n\t\tadd(top, BorderLayout.NORTH);\n\n\t\tJScrollPane scrollPane = new JScrollPane(console, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n\t\t        JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n\t\tconsole.setEditable(false);\n\t\tconsole.setLineWrap(true);\n\t\tadd(scrollPane);\n\t\tJButton desktop = new JButton(\"Launch via Desktop\");\n\t\tdesktop.addActionListener(new ActionListener() {\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttry {\n\n\t\t\t\t\twriter.println(\"Launch via desktop of \" + url);\n\t\t\t\t\tLaunchBrowser.viaDesktop(url.toURI());\n\t\t\t\t\twriter.println(\"Launch via desktop completed\");\n\t\t\t\t\t\n\t\t\t\t} catch (Throwable e1) {\n\t\t\t\t\twriter.println(\"Launch via desktop failed\");\n\t\t\t\t\t\n\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t}\n\t\t\t\twriter.flush();\n\t\t\t}\n\t\t});\n\t\ttop.add(desktop);\n\n\t\tJButton jnlp = new JButton(\"Launch via jnlp\");\n\t\tjnlp.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttry {\n\n\t\t\t\t\twriter.println(\"Launch via jnlp of \" + url);\n\t\t\t\t\tLaunchBrowser.viaWebStart(url);\n\t\t\t\t\twriter.println(\"Launch via jnlp completed\");\n\t\t\t\t\t\n\t\t\t\t} catch (Throwable e1) {\n\t\t\t\t\twriter.println(\"Launch via jnlp failed\");\n\t\t\t\t\t\n\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t}\n\t\t\t\twriter.flush();\n\t\t\t}\n\t\t});\n\t\ttop.add(jnlp);\n\n\t\tJButton exec = new JButton(\"Launch via exec\");\n\t\texec.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\ttry {\n\t\t\t\t\twriter.println(\"Launch via exec firefox \"+url);\n\t\t\t\t\tProcess p = LaunchBrowser.launchFirefox(url);\n\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t\tint exitValue = p.exitValue();\n\t\t\t\t\twriter.println(\"Exit code: \" + exitValue);\n\t\t\t\t\twriter.println(\"Launch via exec firefox completed\");\n\t\t\t\t\t\n\t\t\t\t} catch (Throwable e1) {\n\t\t\t\t\twriter.println(\"Launch via exec firefox threw exception\");\n\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t}\n\t\t\t\twriter.flush();\n\t\t\t}\n\t\t});\n\t\ttop.add(exec);\n\n\t\tJButton chooseFile = new JButton(\"Choose file\");\n\t\ttop.add(chooseFile);\n\t\tchooseFile.addActionListener(new ActionListener() {\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tfinal JFileChooser fc = new JFileChooser();\n\t\t\t\tint retvel = fc.showOpenDialog(TestDesktopIntegration.this);\n\t\t\t\tif (retvel == JFileChooser.APPROVE_OPTION) {\n\t\t\t\t\tFile file = fc.getSelectedFile();\n\t\t\t\t\ttry {\n\t\t\t\t\t\twriter.println(\"File choosen:\");\n\t\t\t\t\t\twriter.println(\"File path: \" + file.getAbsolutePath());\n\t\t\t\t\t\twriter.println(\"File canonical path: \" + file.getCanonicalPath());\n\n\t\t\t\t\t\twriter.println(\"File uri: \" + file.toURI());\n\n\t\t\t\t\t\twriter.println(\"File url: \" + file.toURL());\n\t\t\t\t\t} catch (Exception e1) {\n\t\t\t\t\t\te1.printStackTrace(writer);\n\t\t\t\t\t}\n\t\t\t\t\twriter.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\twriter.println(\"System properties:\");\n\t\tTreeSet<String> props = new TreeSet<String>();\n\t\tfor(Object o : System.getProperties().keySet()) {\n\t\t\tif (o instanceof String) \n\t\t\t\tprops.add((String) o);\n\t\t}\n\t\tprops.addAll(Arrays.asList(propertyNames));\n\t\t\n\t\tfor (String p  : props) {\n\t\t\ttry {\n\t\t\twriter.println(\"  \" + p+ \"=\" + System.getProperty(p));\n\t\t\t} catch (Throwable e) {\n\t\t\t\twriter.println(\"Unable to get property \" + p);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tClass<?> serviceManagerClass = Class.forName(\"javax.jnlp.ServiceManager\");\n\t\t\tMethod getServiceNamesMethod = serviceManagerClass.getMethod(\"getServiceNames\", new Class[] {});\n\t\t\tMethod lookupMethod = serviceManagerClass.getMethod(\"lookup\", new Class[] { String.class });\n\t\t\tString[] serviceNames = (String[]) getServiceNamesMethod.invoke(null, new Object[] {});\n\t\t\twriter.println(\"JNLP service providers:\");\n\t\t\tfor (String s : serviceNames) {\n\t\t\t\tObject o = lookupMethod.invoke(null, new Object[] { s });\n\t\t\t\twriter.println(\"  \" + s + \" = \" + o.getClass().getName());\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\twriter.println(\"unable to get JNLP service provider:\");\n\t\t\te.printStackTrace(writer);\n\n\t\t}\n\n\t}","commit_id":"dbd9fdf78b53ca05aac90bb11904ff1e0c4bb348","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    @NotNull\n    public PackageFragmentDescriptor createNamespaceDescriptorPathIfNeeded(@NotNull FqName fqName) {\n        for (FqName pathElement : fqName.path()) {\n            if (pathElement.isRoot()) {\n                getOrCreatePackageFragment(FqName.ROOT, null, RedeclarationHandler.DO_NOTHING);\n            }\n            else {\n                getOrCreatePackageFragment(pathElement, null, RedeclarationHandler.DO_NOTHING);\n            }\n\n        }\n        return packageFragmentProvider.getOrCreateFragment(fqName);\n    }","id":95058,"modified_method":"@Override\n    @NotNull\n    public PackageFragmentDescriptor createNamespaceDescriptorPathIfNeeded(@NotNull FqName fqName) {\n        return packageFragmentProvider.getOrCreateFragment(fqName);\n    }","commit_id":"30e668634c263688cd24451ce2566a9ce1c20b6b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void lockScopes() {\n        for (MutableClassDescriptor mutableClassDescriptor : context.getClasses().values()) {\n            mutableClassDescriptor.lockScopes();\n        }\n        for (Map.Entry<JetFile, WritableScope> namespaceScope : context.getNamespaceScopes().entrySet()) {\n            // todo: this is hack in favor of REPL\n            if(!namespaceScope.getKey().isScript())\n                namespaceScope.getValue().changeLockLevel(WritableScope.LockLevel.READING);\n        }\n    }","id":95059,"modified_method":"private void lockScopes() {\n        for (MutableClassDescriptor mutableClassDescriptor : context.getClasses().values()) {\n            mutableClassDescriptor.lockScopes();\n        }\n        Set<FqName> scriptFqNames = Sets.newHashSet();\n        for (JetFile file : context.getNamespaceScopes().keySet()) {\n            if (file.isScript()) {\n                scriptFqNames.add(JetPsiUtil.getFQName(file));\n            }\n        }\n        for (MutablePackageFragmentDescriptor fragment : packageFragmentProvider.getAllFragments()) {\n            // todo: this is hack in favor of REPL\n            if (!scriptFqNames.contains(fragment.getFqName())) {\n                fragment.getMemberScope().changeLockLevel(WritableScope.LockLevel.READING);\n            }\n        }\n    }","commit_id":"30e668634c263688cd24451ce2566a9ce1c20b6b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static IFile getClassesGenFolder(IFile moduleDescriptor) {\n    if (moduleDescriptor == null) {\n      return null;\n    }\n    if (moduleDescriptor.isReadOnly()) {\n      // packaged\n      String filename = FileSystem.getInstance().getBundleHome(moduleDescriptor).getPath() + \"!\";\n      return FileSystem.getInstance().getFileByPath(filename);\n    }\n    IFile parent = moduleDescriptor.getParent();\n    return parent != null ? parent.getDescendant(\"classes_gen\") : null;\n  }","id":95060,"modified_method":"public static IFile getClassesGenFolder(IFile moduleDescriptor) {\n    if (moduleDescriptor == null) {\n      return null;\n    }\n    if (moduleDescriptor.isReadOnly()) {\n      // packaged\n      IFile bundleHome = FileSystem.getInstance().getBundleHome(moduleDescriptor);\n      return bundleHome != null ? FileSystem.getInstance().getFileByPath(bundleHome.getPath() + \"!\") : null;\n    }\n    IFile parent = moduleDescriptor.getParent();\n    return parent != null ? parent.getDescendant(\"classes_gen\") : null;\n  }","commit_id":"afce1ab5a2b5a9d27428affe4e4f6fa1334090e0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void update(ProgressMonitor monitor) {\n    monitor.start(\"Reloading files... Please wait.\", MapSequence.fromMap(dataMap).count() + 1);\n    try {\n      for (FileSystemListener listener : Sequence.fromIterable(sortedListeners())) {\n        FileProcessor.ListenerData data = MapSequence.fromMap(dataMap).get(listener);\n        if (!(listenersContainer.contains(listener))) {\n          monitor.advance(1);\n          continue;\n        }\n\n        listener.update(monitor.subTask(1, SubProgressKind.AS_COMMENT), data);\n        data.isNotified = true;\n      }\n      FileSystemListener listener;\n      while ((listener = QueueSequence.fromQueue(postNotify).removeFirstElement()) != null) {\n        FileProcessor.ListenerData data = MapSequence.fromMap(dataMap).get(listener);\n        if (data.isNotified) {\n          continue;\n        }\n        listener.update(monitor.subTask(0, SubProgressKind.AS_COMMENT), data);\n        data.isNotified = true;\n      }\n    } finally {\n      monitor.done();\n    }\n  }","id":95061,"modified_method":"@Override\n  public void update(ProgressMonitor monitor) {\n    monitor.start(\"Reloading files... Please wait.\", MapSequence.fromMap(dataMap).count() + 1);\n    long updateStartTime = System.currentTimeMillis();\n    try {\n      for (FileSystemListener listener : Sequence.fromIterable(sortedListeners())) {\n        FileProcessor.ListenerData data = MapSequence.fromMap(dataMap).get(listener);\n        if (!(listenersContainer.contains(listener))) {\n          monitor.advance(1);\n          continue;\n        }\n\n        long listenerUpdateStartTime = System.currentTimeMillis();\n        listener.update(monitor.subTask(1, SubProgressKind.AS_COMMENT), data);\n        printStat(\"update:\" + listener, listenerUpdateStartTime);\n        data.isNotified = true;\n      }\n      long postNotifyBeginTime = System.currentTimeMillis();\n      FileSystemListener listener;\n      while ((listener = QueueSequence.fromQueue(postNotify).removeFirstElement()) != null) {\n        FileProcessor.ListenerData data = MapSequence.fromMap(dataMap).get(listener);\n        if (data.isNotified) {\n          continue;\n        }\n        listener.update(monitor.subTask(0, SubProgressKind.AS_COMMENT), data);\n        data.isNotified = true;\n      }\n      printStat(\"post-notify\", postNotifyBeginTime);\n    } finally {\n      printStat(\"update\", updateStartTime);\n      monitor.done();\n    }\n  }","commit_id":"e958c74837dffbf1da98f0deb84dd7cd3ad57dba","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public IFile getFileToListen() {\n    String presentableUrl = myProject.getPresentableUrl();\n    if (presentableUrl == null) return null;\n    return FileSystem.getInstance().getFileByPath(presentableUrl);\n  }","id":95062,"modified_method":"@Override\n  public IFile getFileToListen() {\n    VirtualFile projectFile = myProject.getProjectFile();\n    return projectFile != null ? FileSystem.getInstance().getFileByPath(projectFile.getPath()) : null;\n  }","commit_id":"e958c74837dffbf1da98f0deb84dd7cd3ad57dba","url":"https://github.com/JetBrains/MPS"},{"original_method":"private IFile getModelFile(AbstractTreeNode treeNode) {\n    if (treeNode instanceof MPSPsiModelTreeNode) {\n      MPSPsiModelTreeNode fileNode = (MPSPsiModelTreeNode) treeNode;\n      VirtualFile virtualFile = fileNode.getVirtualFile();\n      if (virtualFile == null || virtualFile.getFileType() != MPSFileTypeFactory.MPS_FILE_TYPE && virtualFile.getFileType() != MPSFileTypeFactory.MPS_HEADER_FILE_TYPE)\n        return null;\n      return FileSystem.getInstance().getFileByPath(virtualFile.getPath());\n\n    } else if (treeNode instanceof PsiDirectoryNode) {\n      IFile ifile = FileSystem.getInstance().getFileByPath(((PsiDirectoryNode) treeNode).getVirtualFile().getPath());\n      SModel model = SModelFileTracker.getInstance().findModel(ifile);\n      if (model != null) return ifile;\n\n    }\n    return null;\n  }","id":95063,"modified_method":"private IFile getModelFile(AbstractTreeNode treeNode) {\n    if (treeNode instanceof MPSPsiModelTreeNode) {\n      MPSPsiModelTreeNode fileNode = (MPSPsiModelTreeNode) treeNode;\n      VirtualFile virtualFile = fileNode.getVirtualFile();\n      if (virtualFile == null || virtualFile.getFileType() != MPSFileTypeFactory.MPS_FILE_TYPE && virtualFile.getFileType() != MPSFileTypeFactory.MPS_HEADER_FILE_TYPE) {\n        return null;\n      }\n      return FileSystem.getInstance().getFileByPath(virtualFile.getPath());\n\n    } else if (treeNode instanceof PsiDirectoryNode) {\n      VirtualFile virtualFile = ((PsiDirectoryNode) treeNode).getVirtualFile();\n      if (virtualFile == null) {\n        return null;\n      }\n      IFile ifile = FileSystem.getInstance().getFileByPath(virtualFile.getPath());\n      SModel model = SModelFileTracker.getInstance().findModel(ifile);\n      if (model != null) return ifile;\n\n    }\n    return null;\n  }","commit_id":"6a6c75736a1365b2017a65a6a7c5897e90ffb058","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n\tpublic void moveDependentsToTrash(\n\t\t\tUser user, List<Object> categoriesAndThreads, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : categoriesAndThreads) {\n\t\t\tif (object instanceof MBThread) {\n\t\t\t\tMBThread thread = (MBThread)object;\n\n\t\t\t\tif ((status == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t\t(thread.getStatus() == WorkflowConstants.STATUS_IN_TRASH)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmbThreadLocalService.updateStatus(\n\t\t\t\t\tuser.getUserId(), thread.getThreadId(), status, status);\n\t\t\t}\n\t\t\telse if (object instanceof MBCategory) {\n\t\t\t\tMBCategory category = (MBCategory)object;\n\n\t\t\t\tif (category.isInTrash()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmoveDependentsToTrash(\n\t\t\t\t\tuser,\n\t\t\t\t\tgetCategoriesAndThreads(\n\t\t\t\t\t\tcategory.getGroupId(), category.getCategoryId()),\n\t\t\t\t\tstatus);\n\t\t\t}\n\t\t}\n\t}","id":95064,"modified_method":"@Override\n\tpublic void moveDependentsToTrash(\n\t\t\tUser user, List<Object> categoriesAndThreads)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : categoriesAndThreads) {\n\t\t\tif (object instanceof MBThread) {\n\t\t\t\tMBThread thread = (MBThread)object;\n\n\t\t\t\tif (thread.getStatus() == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmbThreadLocalService.moveDependentsToTrash(\n\t\t\t\t\tuser.getUserId(), thread.getThreadId());\n\n\t\t\t\t// Indexer\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\tMBThread.class);\n\n\t\t\t\tindexer.reindex(thread);\n\t\t\t}\n\t\t\telse if (object instanceof MBCategory) {\n\t\t\t\tMBCategory category = (MBCategory)object;\n\n\t\t\t\tif (category.isInTrash()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmoveDependentsToTrash(\n\t\t\t\t\tuser,\n\t\t\t\t\tgetCategoriesAndThreads(\n\t\t\t\t\t\tcategory.getGroupId(), category.getCategoryId()));\n\t\t\t}\n\t\t}\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic MBCategory updateStatus(long userId, long categoryId, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\n\t\tcategory.setStatus(status);\n\t\tcategory.setStatusByUserId(user.getUserId());\n\t\tcategory.setStatusByUserName(user.getFullName());\n\t\tcategory.setStatusDate(new Date());\n\n\t\tmbCategoryPersistence.update(category);\n\n\t\t// Categories and threads\n\n\t\tList<Object> categoriesAndThreads = getCategoriesAndThreads(\n\t\t\tcategory.getGroupId(), categoryId);\n\n\t\tupdateDependentStatus(user, categoriesAndThreads, status);\n\n\t\t// Trash\n\n\t\tif (status == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\tuserId, category.getGroupId(), MBCategory.class.getName(),\n\t\t\t\tcategoryId, category.getUuid(), null,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, null, null);\n\t\t}\n\n\t\treturn category;\n\t}","id":95065,"modified_method":"@Override\n\tpublic MBCategory updateStatus(long userId, long categoryId, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\n\t\tcategory.setStatus(status);\n\t\tcategory.setStatusByUserId(user.getUserId());\n\t\tcategory.setStatusByUserName(user.getFullName());\n\t\tcategory.setStatusDate(new Date());\n\n\t\tmbCategoryPersistence.update(category);\n\n\t\treturn category;\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void restoreCategoryFromTrash(long userId, long categoryId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tMBCategory.class.getName(), categoryId);\n\n\t\tupdateStatus(userId, categoryId, WorkflowConstants.STATUS_APPROVED);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(trashEntry.getEntryId());\n\t}","id":95066,"modified_method":"@Override\n\tpublic void restoreCategoryFromTrash(long userId, long categoryId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tMBCategory.class.getName(), categoryId);\n\n\t\tMBCategory category = updateStatus(\n\t\t\tuserId, categoryId, WorkflowConstants.STATUS_APPROVED);\n\n\t\t// Categories and threads\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tList<Object> categoriesAndThreads = getCategoriesAndThreads(\n\t\t\tcategory.getGroupId(), categoryId);\n\n\t\trestoreDependentFromTrash(user, categoriesAndThreads);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(trashEntry.getEntryId());\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void restoreDependentFromTrash(\n\t\t\tUser user, List<Object> categoriesAndThreads, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : categoriesAndThreads) {\n\t\t\tif (object instanceof MBThread) {\n\t\t\t\tMBThread thread = (MBThread)object;\n\n\t\t\t\tif ((status == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t\t(thread.getStatus() == WorkflowConstants.STATUS_IN_TRASH)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmbThreadLocalService.updateStatus(\n\t\t\t\t\tuser.getUserId(), thread.getThreadId(), status, status);\n\t\t\t}\n\t\t\telse if (object instanceof MBCategory) {\n\t\t\t\tMBCategory category = (MBCategory)object;\n\n\t\t\t\tif (category.isInTrash()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trestoreDependentFromTrash(\n\t\t\t\t\tuser,\n\t\t\t\t\tgetCategoriesAndThreads(\n\t\t\t\t\t\tcategory.getGroupId(), category.getCategoryId()),\n\t\t\t\t\tstatus);\n\t\t\t}\n\t\t}\n\t}","id":95067,"modified_method":"@Override\n\tpublic void restoreDependentFromTrash(\n\t\t\tUser user, List<Object> categoriesAndThreads)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : categoriesAndThreads) {\n\t\t\tif (object instanceof MBThread) {\n\t\t\t\tMBThread thread = (MBThread)object;\n\n\t\t\t\tif (thread.getStatus() == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmbThreadLocalService.restoreDependentsFromTrash(\n\t\t\t\t\tuser.getUserId(), thread.getThreadId());\n\n\t\t\t\t// Indexer\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\tMBThread.class);\n\n\t\t\t\tindexer.reindex(thread);\n\t\t\t}\n\t\t\telse if (object instanceof MBCategory) {\n\t\t\t\tMBCategory category = (MBCategory)object;\n\n\t\t\t\tif (category.isInTrash()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trestoreDependentFromTrash(\n\t\t\t\t\tuser,\n\t\t\t\t\tgetCategoriesAndThreads(\n\t\t\t\t\t\tcategory.getGroupId(), category.getCategoryId()));\n\t\t\t}\n\t\t}\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic MBCategory moveCategoryToTrash(long userId, long categoryId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn updateStatus(\n\t\t\tuserId, categoryId, WorkflowConstants.STATUS_IN_TRASH);\n\t}","id":95068,"modified_method":"@Override\n\tpublic MBCategory moveCategoryToTrash(long userId, long categoryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBCategory category = updateStatus(\n\t\t\tuserId, categoryId, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, category.getGroupId(), MBCategory.class.getName(),\n\t\t\tcategoryId, category.getUuid(), null,\n\t\t\tWorkflowConstants.STATUS_APPROVED, null, null);\n\n\t\t// Categories and threads\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tList<Object> categoriesAndThreads = getCategoriesAndThreads(\n\t\t\tcategory.getGroupId(), categoryId);\n\n\t\tmoveDependentsToTrash(user, categoriesAndThreads);\n\n\t\treturn category;\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic MBThread moveThreadFromTrash(\n\t\t\tlong userId, long categoryId, long threadId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(threadId);\n\n\t\tif (thread.isInTrash()) {\n\t\t\trestoreThreadFromTrash(userId, threadId);\n\t\t}\n\t\telse {\n\t\t\tupdateStatus(\n\t\t\t\tuserId, threadId, thread.getStatus(),\n\t\t\t\tWorkflowConstants.STATUS_ANY);\n\t\t}\n\n\t\treturn moveThread(thread.getGroupId(), categoryId, threadId);\n\t}","id":95069,"modified_method":"@Override\n\tpublic MBThread moveThreadFromTrash(\n\t\t\tlong userId, long categoryId, long threadId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(threadId);\n\n\t\tif (thread.isInTrash()) {\n\t\t\trestoreThreadFromTrash(userId, threadId);\n\t\t}\n\t\telse {\n\t\t\tupdateStatus(userId, threadId, thread.getStatus());\n\n\t\t\trestoreDependentsFromTrash(thread.getGroupId(), threadId);\n\t\t}\n\n\t\treturn moveThread(thread.getGroupId(), categoryId, threadId);\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic MBThread moveThreadToTrash(long userId, MBThread thread)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (thread.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID) {\n\n\t\t\treturn thread;\n\t\t}\n\n\t\tint oldStatus = thread.getStatus();\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tthread.setStatus(WorkflowConstants.STATUS_DRAFT);\n\n\t\t\tmbThreadPersistence.update(thread);\n\t\t}\n\n\t\treturn updateStatus(\n\t\t\tuserId, thread.getThreadId(), WorkflowConstants.STATUS_IN_TRASH,\n\t\t\tWorkflowConstants.STATUS_ANY);\n\t}","id":95070,"modified_method":"@Override\n\tpublic MBThread moveThreadToTrash(long userId, MBThread thread)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (thread.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID) {\n\n\t\t\treturn thread;\n\t\t}\n\n\t\tint oldStatus = thread.getStatus();\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tthread.setStatus(WorkflowConstants.STATUS_DRAFT);\n\n\t\t\tmbThreadPersistence.update(thread);\n\t\t}\n\n\t\tthread = updateStatus(\n\t\t\tuserId, thread.getThreadId(), WorkflowConstants.STATUS_IN_TRASH);\n\n\t\tmoveDependentsToTrash(thread.getGroupId(), thread.getThreadId());\n\n\t\t// Social\n\n\t\tMBMessage message = mbMessageLocalService.getMBMessage(\n\t\t\tthread.getRootMessageId());\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"rootMessageId\", thread.getRootMessageId());\n\t\textraDataJSONObject.put(\"title\", message.getSubject());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, thread.getGroupId(), MBThread.class.getName(),\n\t\t\tthread.getThreadId(), SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, thread.getGroupId(), MBThread.class.getName(),\n\t\t\tthread.getThreadId(), thread.getUuid(), null, oldStatus, null,\n\t\t\tnull);\n\n\t\treturn thread;\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void restoreThreadFromTrash(long userId, long threadId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = getThread(threadId);\n\n\t\tif (thread.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tMBThread.class.getName(), threadId);\n\n\t\tupdateStatus(\n\t\t\tuserId, threadId, trashEntry.getStatus(),\n\t\t\tWorkflowConstants.STATUS_ANY);\n\t}","id":95071,"modified_method":"@Override\n\tpublic void restoreThreadFromTrash(long userId, long threadId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = getThread(threadId);\n\n\t\tif (thread.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tMBThread.class.getName(), threadId);\n\n\t\tupdateStatus(userId, threadId, trashEntry.getStatus());\n\n\t\trestoreDependentsFromTrash(thread.getGroupId(), threadId);\n\n\t\t// Social\n\n\t\tMBMessage message = mbMessageLocalService.getMBMessage(\n\t\t\tthread.getRootMessageId());\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"rootMessageId\", thread.getRootMessageId());\n\t\textraDataJSONObject.put(\"title\", message.getSubject());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, thread.getGroupId(), MBThread.class.getName(),\n\t\t\tthread.getThreadId(),\n\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(MBThread.class.getName(), threadId);\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic MBThread updateStatus(\n\t\t\tlong userId, long threadId, int status, int categoryStatus)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(threadId);\n\n\t\tif (categoryStatus != WorkflowConstants.STATUS_IN_TRASH) {\n\n\t\t\t// Thread\n\n\t\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\t\tDate now = new Date();\n\n\t\t\tint oldStatus = thread.getStatus();\n\n\t\t\tthread.setModifiedDate(now);\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(now);\n\n\t\t\tmbThreadPersistence.update(thread);\n\n\t\t\t// Messages\n\n\t\t\tupdateDependentStatus(thread.getGroupId(), threadId, status);\n\n\t\t\tif (thread.getCategoryId() !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\t\t// Category\n\n\t\t\t\tMBCategory category = mbCategoryPersistence.fetchByPrimaryKey(\n\t\t\t\t\tthread.getCategoryId());\n\n\t\t\t\tif (category != null) {\n\t\t\t\t\tMBUtil.updateCategoryStatistics(\n\t\t\t\t\t\tcategory.getCompanyId(), category.getCategoryId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMBMessage message = mbMessageLocalService.getMBMessage(\n\t\t\t\tthread.getRootMessageId());\n\n\t\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\textraDataJSONObject.put(\"rootMessageId\", thread.getRootMessageId());\n\t\t\textraDataJSONObject.put(\"title\", message.getSubject());\n\n\t\t\tif (status == WorkflowConstants.STATUS_IN_TRASH) {\n\n\t\t\t\t// Social\n\n\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\tuserId, thread.getGroupId(), MBThread.class.getName(),\n\t\t\t\t\tthread.getThreadId(),\n\t\t\t\t\tSocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\t\t\textraDataJSONObject.toString(), 0);\n\n\t\t\t\t// Trash\n\n\t\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\t\tuserId, thread.getGroupId(), MBThread.class.getName(),\n\t\t\t\t\tthread.getThreadId(), thread.getUuid(), null, oldStatus,\n\t\t\t\t\tnull, null);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Social\n\n\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\tuserId, thread.getGroupId(), MBThread.class.getName(),\n\t\t\t\t\tthread.getThreadId(),\n\t\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\t\textraDataJSONObject.toString(), 0);\n\n\t\t\t\t// Trash\n\n\t\t\t\ttrashEntryLocalService.deleteEntry(\n\t\t\t\t\tMBThread.class.getName(), thread.getThreadId());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tupdateDependentStatus(thread.getGroupId(), threadId, status);\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tMBThread.class);\n\n\t\tindexer.reindex(thread);\n\n\t\treturn thread;\n\t}","id":95072,"modified_method":"@Override\n\tpublic MBThread updateStatus(long userId, long threadId, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(threadId);\n\n\t\t// Thread\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDate now = new Date();\n\n\t\tthread.setModifiedDate(now);\n\t\tthread.setStatus(status);\n\t\tthread.setStatusByUserId(user.getUserId());\n\t\tthread.setStatusByUserName(user.getFullName());\n\t\tthread.setStatusDate(now);\n\n\t\tmbThreadPersistence.update(thread);\n\n\t\t// Messages\n\n\t\tif (thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.fetchByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\n\t\t\tif (category != null) {\n\t\t\t\tMBUtil.updateCategoryStatistics(\n\t\t\t\t\tcategory.getCompanyId(), category.getCategoryId());\n\t\t\t}\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tMBThread.class);\n\n\t\tindexer.reindex(thread);\n\n\t\treturn thread;\n\t}","commit_id":"ce4c2ffcea7707601d47cacd7ba2d5f2ffb092d9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BookmarksEntry moveEntryToTrash(long userId, BookmarksEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn updateStatus(userId, entry, WorkflowConstants.STATUS_IN_TRASH);\n\t}","id":95073,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BookmarksEntry moveEntryToTrash(long userId, BookmarksEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\tint oldStatus = entry.getStatus();\n\n\t\tentry = updateStatus(userId, entry, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\tentry.getEntryId(), entry.getUuid(), null, oldStatus, null,\n\t\t\tnull);\n\n\t\treturn entry;\n\t}","commit_id":"52e56ef642a2b0307d1b67e6cb25be4f1e716307","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BookmarksEntry restoreEntryFromTrash(long userId, long entryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksEntry entry = bookmarksEntryPersistence.findByPrimaryKey(\n\t\t\tentryId);\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tBookmarksEntry.class.getName(), entryId);\n\n\t\treturn updateStatus(userId, entry, trashEntry.getStatus());\n\t}","id":95074,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BookmarksEntry restoreEntryFromTrash(long userId, long entryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksEntry entry = bookmarksEntryPersistence.findByPrimaryKey(\n\t\t\tentryId);\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tBookmarksEntry.class.getName(), entryId);\n\n\t\tentry = updateStatus(userId, entry, trashEntry.getStatus());\n\n\t\ttrashEntryLocalService.deleteEntry(\n\t\t\tBookmarksEntry.class.getName(), entry.getEntryId());\n\n\t\treturn entry;\n\t}","commit_id":"52e56ef642a2b0307d1b67e6cb25be4f1e716307","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic BookmarksEntry updateStatus(\n\t\t\tlong userId, BookmarksEntry entry, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tint oldStatus = entry.getStatus();\n\n\t\tentry.setStatus(status);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusByUserName(user.getScreenName());\n\t\tentry.setStatusDate(new Date());\n\n\t\tbookmarksEntryPersistence.update(entry);\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", entry.getName());\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksEntry.class.getName(), entry.getEntryId(), true);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\t\tentry.getEntryId(),\n\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksEntry.class.getName(), entry.getEntryId(), false);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\t\tentry.getEntryId(), SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\n\t\t// Trash\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.deleteEntry(\n\t\t\t\tBookmarksEntry.class.getName(), entry.getEntryId());\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\t\tentry.getEntryId(), entry.getUuid(), null, oldStatus, null,\n\t\t\t\tnull);\n\t\t}\n\n\t\treturn entry;\n\t}","id":95075,"modified_method":"@Override\n\tpublic BookmarksEntry updateStatus(\n\t\t\tlong userId, BookmarksEntry entry, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tentry.setStatus(status);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusByUserName(user.getScreenName());\n\t\tentry.setStatusDate(new Date());\n\n\t\tbookmarksEntryPersistence.update(entry);\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", entry.getName());\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksEntry.class.getName(), entry.getEntryId(), true);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\t\tentry.getEntryId(),\n\t\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksEntry.class.getName(), entry.getEntryId(), false);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\t\tentry.getEntryId(), SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\n\t\treturn entry;\n\t}","commit_id":"52e56ef642a2b0307d1b67e6cb25be4f1e716307","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BookmarksFolder moveFolderToTrash(long userId, long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folder\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tupdateStatus(userId, folder, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", folder.getName());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getFolderId(), SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\treturn folder;\n\t}","id":95076,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BookmarksFolder moveFolderToTrash(long userId, long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folder\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tint oldStatus = folder.getStatus();\n\n\t\tfolder = updateStatus(\n\t\t\tuserId, folder, WorkflowConstants.STATUS_IN_TRASH);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getFolderId(), folder.getUuid(), null, oldStatus, null,\n\t\t\tnull);\n\n\t\t// Folders and entries\n\n\t\tList<Object> foldersAndEntries =\n\t\t\tbookmarksFolderLocalService.getFoldersAndEntries(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tmoveDependentToTrash(foldersAndEntries);\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", folder.getName());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getFolderId(), SocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\n\t\treturn folder;\n\t}","commit_id":"52e56ef642a2b0307d1b67e6cb25be4f1e716307","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic BookmarksFolder moveFolderFromTrash(\n\t\t\tlong userId, long folderId, long parentFolderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (folder.isInTrash()) {\n\t\t\trestoreFolderFromTrash(userId, folderId);\n\t\t}\n\t\telse {\n\t\t\tupdateStatus(userId, folder, WorkflowConstants.STATUS_APPROVED);\n\t\t}\n\n\t\treturn bookmarksFolderLocalService.moveFolder(folderId, parentFolderId);\n\t}","id":95077,"modified_method":"@Override\n\tpublic BookmarksFolder moveFolderFromTrash(\n\t\t\tlong userId, long folderId, long parentFolderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tif (folder.isInTrash()) {\n\t\t\trestoreFolderFromTrash(userId, folderId);\n\t\t}\n\t\telse {\n\t\t\tupdateStatus(userId, folder, WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t// Folders and entries\n\n\t\t\tList<Object> foldersAndEntries =\n\t\t\t\tbookmarksFolderLocalService.getFoldersAndEntries(\n\t\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\t\trestoreDependentFromTrash(foldersAndEntries);\n\t\t}\n\n\t\treturn bookmarksFolderLocalService.moveFolder(folderId, parentFolderId);\n\t}","commit_id":"52e56ef642a2b0307d1b67e6cb25be4f1e716307","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic void restoreFolderFromTrash(long userId, long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folder\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tBookmarksFolder.class.getName(), folderId);\n\n\t\tupdateStatus(userId, folder, trashEntry.getStatus());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", folder.getName());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getFolderId(),\n\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\t}","id":95078,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic void restoreFolderFromTrash(long userId, long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folder\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tBookmarksFolder.class.getName(), folderId);\n\n\t\tupdateStatus(userId, folder, trashEntry.getStatus());\n\n\t\t// Folders and entries\n\n\t\tList<Object> foldersAndEntries =\n\t\t\tbookmarksFolderLocalService.getFoldersAndEntries(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\trestoreDependentFromTrash(foldersAndEntries);\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(trashEntry.getEntryId());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", folder.getName());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getFolderId(),\n\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\textraDataJSONObject.toString(), 0);\n\t}","commit_id":"52e56ef642a2b0307d1b67e6cb25be4f1e716307","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic BookmarksFolder updateStatus(\n\t\t\tlong userId, BookmarksFolder folder, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folder\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tint oldStatus = folder.getStatus();\n\n\t\tfolder.setStatus(status);\n\t\tfolder.setStatusByUserId(userId);\n\t\tfolder.setStatusByUserName(user.getFullName());\n\t\tfolder.setStatusDate(new Date());\n\n\t\tbookmarksFolderPersistence.update(folder);\n\n\t\t// Folders and entries\n\n\t\tList<Object> foldersAndEntries =\n\t\t\tbookmarksFolderLocalService.getFoldersAndEntries(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tupdateDependentStatus(foldersAndEntries, status);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksFolder.class.getName(), folder.getFolderId(), true);\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksFolder.class.getName(), folder.getFolderId(), false);\n\t\t}\n\n\t\t// Trash\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.deleteEntry(\n\t\t\t\tBookmarksFolder.class.getName(), folder.getFolderId());\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\t\tfolder.getFolderId(), folder.getUuid(), null, oldStatus, null,\n\t\t\t\tnull);\n\t\t}\n\n\t\t// Index\n\n\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tBookmarksFolder.class);\n\n\t\tindexer.reindex(folder);\n\n\t\treturn folder;\n\t}","id":95079,"modified_method":"@Override\n\tpublic BookmarksFolder updateStatus(\n\t\t\tlong userId, BookmarksFolder folder, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folder\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tfolder.setStatus(status);\n\t\tfolder.setStatusByUserId(userId);\n\t\tfolder.setStatusByUserName(user.getFullName());\n\t\tfolder.setStatusDate(new Date());\n\n\t\tbookmarksFolderPersistence.update(folder);\n\n\t\t// Asset\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksFolder.class.getName(), folder.getFolderId(), true);\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tBookmarksFolder.class.getName(), folder.getFolderId(), false);\n\t\t}\n\n\t\t// Index\n\n\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tBookmarksFolder.class);\n\n\t\tindexer.reindex(folder);\n\n\t\treturn folder;\n\t}","commit_id":"52e56ef642a2b0307d1b67e6cb25be4f1e716307","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player opponent = game.getPlayer(source.getFirstTarget());\r\n        if (opponent != null) {\r\n            Cost cost = new SacrificeTargetCost(new TargetControlledCreaturePermanent());\r\n            if (cost.canPay(source.getSourceId(), opponent.getId(), game)\r\n                    && opponent.chooseUse(outcome, \"Sacrifice a creature to prevent the card draw?\", game)) {\r\n                if (cost.pay(source, game, source.getSourceId(), opponent.getId(), false)) {\r\n                    return true;\r\n                }\r\n            }\r\n            cost = new PayLifeCost(3);\r\n            if (cost.canPay(source.getSourceId(), opponent.getId(), game)\r\n                    && opponent.chooseUse(outcome, \"Pay 3 life to prevent the card draw?\", game)) {\r\n                if (cost.pay(source, game, source.getSourceId(), opponent.getId(), false)) {\r\n                    return true;\r\n                }\r\n            }\r\n            game.getPlayer(source.getControllerId()).drawCards(1, game);\r\n        }\r\n        return false;\r\n    }","id":95080,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player opponent = game.getPlayer(source.getFirstTarget());\r\n        if (opponent != null) {\r\n            Cost cost = new SacrificeTargetCost(new TargetControlledCreaturePermanent());\r\n            if (cost.canPay(source.getSourceId(), opponent.getId(), game)\r\n                    && opponent.chooseUse(outcome, \"Sacrifice a creature to prevent the card draw?\", game)) {\r\n                if (cost.pay(source, game, source.getSourceId(), opponent.getId(), false)) {\r\n                    return true;\r\n                }\r\n            }\r\n            cost = new PayLifeCost(3);\r\n            if (cost.canPay(source.getSourceId(), opponent.getId(), game)\r\n                    && opponent.chooseUse(outcome, \"Pay 3 life to prevent the card draw?\", game)) {\r\n                if (cost.pay(source, game, source.getSourceId(), opponent.getId(), false)) {\r\n                    return true;\r\n                }\r\n            }\r\n            game.getPlayer(source.getControllerId()).drawCards(1, game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"9a26a9c50cfe44da7d5e0cfdbf15cbc7c168992f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        game.getPlayer(this.getTargetPointer().getFirst(game, source)).loseLife(10, game);\r\n        return super.apply(game, source);\r\n    }","id":95081,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(this.getTargetPointer().getFirst(game, source));\r\n        if (player != null) {\r\n            player.loseLife(10, game);\r\n        }\r\n        return super.apply(game, source);\r\n    }","commit_id":"9a26a9c50cfe44da7d5e0cfdbf15cbc7c168992f","url":"https://github.com/magefree/mage"},{"original_method":"public AstralCornucopia(UUID ownerId) {\r\n        super(ownerId, 157, \"Astral Cornucopia\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{X}{X}{X}\");\r\n        this.expansionSetCode = \"BNG\";\r\n\r\n        // Astral Cornucopia enters the battlefield with X charge counters on it.\r\n        this.addAbility(new EntersBattlefieldAbility(new AstralCornucopiaEffect(), \"with X charge counters on it\"));\r\n\r\n        // {T}: Choose a color. Add one mana of that color to your mana pool for each charge counter on Astral Cornucopia.\r\n        Ability ability = new AstralCornucopiaManaAbility();\r\n        Choice choice = new ChoiceColor();\r\n        choice.setMessage(\"Choose a color to add mana of that color\");\r\n        ability.addChoice(choice);\r\n        this.addAbility(ability);\r\n    }","id":95082,"modified_method":"public AstralCornucopia(UUID ownerId) {\r\n        super(ownerId, 157, \"Astral Cornucopia\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{X}{X}{X}\");\r\n        this.expansionSetCode = \"BNG\";\r\n\r\n        // Astral Cornucopia enters the battlefield with X charge counters on it.\r\n        this.addAbility(new EntersBattlefieldAbility(new AstralCornucopiaEffect(), \"with X charge counters on it\"));\r\n\r\n        // {T}: Choose a color. Add one mana of that color to your mana pool for each charge counter on Astral Cornucopia.\r\n        this.addAbility(new AstralCornucopiaManaAbility());\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        computeMana(game, source);\r\n        game.getPlayer(source.getControllerId()).getManaPool().addMana(computedMana, game, source);\r\n        return true;\r\n    }","id":95083,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            ChoiceColor choice = new ChoiceColor();\r\n            choice.setMessage(\"Choose a color to add mana of that color\");\r\n            if (controller.choose(outcome, choice, game)) {\r\n                Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n                if (choice.getChoice() != null) {\r\n                    String color = choice.getChoice();\r\n                    int counters = sourcePermanent.getCounters().getCount(CounterType.CHARGE.getName());\r\n                    switch (color) {\r\n                        case \"Red\":\r\n                            computedMana.setRed(counters);\r\n                            break;\r\n                        case \"Blue\":\r\n                            computedMana.setBlue(counters);\r\n                            break;\r\n                        case \"White\":\r\n                            computedMana.setWhite(counters);\r\n                            break;\r\n                        case \"Black\":\r\n                            computedMana.setBlack(counters);\r\n                            break;\r\n                        case \"Green\":\r\n                            computedMana.setGreen(counters);\r\n                            break;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public List<Mana> getNetMana(Game game) {\r\n        List<Mana> newNetMana = new ArrayList<>();\r\n        if (game != null) {\r\n            newNetMana.add(new Mana(((AstralCornucopiaManaEffect)this.getEffects().get(0)).computeMana(game, this)));\r\n        }        \r\n        return newNetMana;  \r\n    }","id":95084,"modified_method":"@Override\r\n    public List<Mana> getNetMana(Game game) {\r\n        netMana.clear();\r\n        Permanent sourcePermanent = game.getPermanent(getSourceId());\r\n        if (sourcePermanent != null) {\r\n            int counters = sourcePermanent.getCounters().getCount(CounterType.CHARGE.getName());\r\n            if (counters > 0) {\r\n                netMana.add(new Mana(0,0,0,0,0,0,counters));\r\n            }\r\n        }\r\n        return netMana;\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"public ExoticOrchard(UUID ownerId) {\r\n        super(ownerId, 142, \"Exotic Orchard\", Rarity.RARE, new CardType[]{CardType.LAND}, \"\");\r\n        this.expansionSetCode = \"CON\";\r\n\r\n        // {T}: Add to your mana pool one mana of any color that a land an opponent controls could produce.\r\n        this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new ExoticOrchardEffect(), new TapSourceCost()));\r\n    }","id":95085,"modified_method":"public ExoticOrchard(UUID ownerId) {\r\n        super(ownerId, 142, \"Exotic Orchard\", Rarity.RARE, new CardType[]{CardType.LAND}, \"\");\r\n        this.expansionSetCode = \"CON\";\r\n\r\n        // {T}: Add to your mana pool one mana of any color that a land an opponent controls could produce.\r\n        this.addAbility(new AnyColorOpponentLandsProduceManaAbility());\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"public FellwarStone(UUID ownerId) {\n        super(ownerId, 297, \"Fellwar Stone\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{2}\");\n        this.expansionSetCode = \"9ED\";\n\n        // {tap}: Add to your mana pool one mana of any color that a land an opponent controls could produce.\n        this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new FellwarStoneEffect(), new TapSourceCost()));\n    }","id":95086,"modified_method":"public FellwarStone(UUID ownerId) {\n        super(ownerId, 297, \"Fellwar Stone\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{2}\");\n        this.expansionSetCode = \"9ED\";\n\n        // {T}: Add to your mana pool one mana of any color that a land an opponent controls could produce.\n        this.addAbility(new AnyColorOpponentLandsProduceManaAbility());\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"public LionsEyeDiamondAbility() {\n        super(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(3), new SacrificeSourceCost());\n        this.addCost(new DiscardHandCost());\n    }","id":95087,"modified_method":"public LionsEyeDiamondAbility() {\n        super(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(3), new SacrificeSourceCost());\n        this.addCost(new DiscardHandCost());\n        this.netMana.add(new Mana(0,0,0,0,0,0,3));\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"public LionsEyeDiamondAbility(Zone zone, Mana mana, Cost cost) {\n        super(zone, new BasicManaEffect(mana), cost);\n        this.netMana.add(mana.copy());\n    }","id":95088,"modified_method":"public LionsEyeDiamondAbility(Zone zone, Mana mana, Cost cost) {\n        super(zone, new BasicManaEffect(mana), cost);\n        \n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"@Test\r\n    public void testLordOfTheVoid2() {\r\n        \r\n        addCard(Zone.BATTLEFIELD, playerA, \"Oracle of Mul Daya\");\r\n        // Whenever Lord of the Void deals combat damage to a player, exile the top seven cards \r\n        // of that player's library, then put a creature card from among them \r\n        // onto the battlefield under your control.\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Island\", 4);\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Lord of the Void\");\r\n        addCard(Zone.HAND, playerB, \"Griptide\");\r\n\r\n        castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Griptide\", \"Oracle of Mul Daya\");\r\n        attack(2, playerB, \"Lord of the Void\");\r\n        setChoice(playerB, \"Oracle of Mul Daya\");\r\n\r\n        setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n        execute();\r\n\r\n        // under control\r\n        assertLife(playerA, 13);\r\n        assertPermanentCount(playerB, \"Oracle of Mul Daya\", 1);\r\n\r\n        Assert.assertTrue(\"Top card of the library of player B should be reveled.\", playerB.isTopCardRevealed());\r\n        Assert.assertFalse(\"Top card of the library of player A should not be reveled.\", playerA.isTopCardRevealed());\r\n    }","id":95089,"modified_method":"@Test\r\n    public void testLordOfTheVoid2() {\r\n        \r\n        addCard(Zone.BATTLEFIELD, playerA, \"Oracle of Mul Daya\");\r\n        // Whenever Lord of the Void deals combat damage to a player, exile the top seven cards \r\n        // of that player's library, then put a creature card from among them \r\n        // onto the battlefield under your control.\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Island\", 4);\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Lord of the Void\");\r\n\r\n        // Put target creature on top of its owner's library.\r\n        addCard(Zone.HAND, playerB, \"Griptide\");\r\n\r\n        castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Griptide\", \"Oracle of Mul Daya\");\r\n        attack(2, playerB, \"Lord of the Void\");\r\n        setChoice(playerB, \"Oracle of Mul Daya\");\r\n\r\n        setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n        execute();\r\n\r\n        // under control\r\n        assertLife(playerA, 13);\r\n        assertPermanentCount(playerB, \"Oracle of Mul Daya\", 1);\r\n\r\n        Assert.assertTrue(\"Top card of the library of player B should be revealed.\", playerB.isTopCardRevealed());\r\n        Assert.assertFalse(\"Top card of the library of player A should not be revealed.\", playerA.isTopCardRevealed());\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"public ReflectingPool(UUID ownerId) {\r\n        super(ownerId, 328, \"Reflecting Pool\", Rarity.RARE, new CardType[]{CardType.LAND}, \"\");\r\n        this.expansionSetCode = \"TMP\";\r\n\r\n        // {T}: Add to your mana pool one mana of any type that a land you control could produce.\r\n        this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new ReflectingPoolEffect(), new TapSourceCost()));\r\n    }","id":95090,"modified_method":"public ReflectingPool(UUID ownerId) {\r\n        super(ownerId, 328, \"Reflecting Pool\", Rarity.RARE, new CardType[]{CardType.LAND}, \"\");\r\n        this.expansionSetCode = \"TMP\";\r\n\r\n        // {T}: Add to your mana pool one mana of any type that a land you control could produce.\r\n        this.addAbility(new ReflectingPoolManaAbility());\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        List<Permanent> lands = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), game);\r\n        Mana types = new Mana();\r\n        for (Permanent land : lands) {\r\n            Abilities<ManaAbility> mana = land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);\r\n            for (ManaAbility ability : mana) {\r\n                for (Mana netMana: ability.getNetMana(game)) {\r\n                    types.add(netMana);\r\n                }                \r\n            }\r\n        }\r\n        Choice choice = new ChoiceImpl(false);\r\n        choice.setMessage(\"Pick a mana color\");\r\n        if (types.getBlack() > 0) {\r\n            choice.getChoices().add(\"Black\");\r\n        }\r\n        if (types.getRed() > 0) {\r\n            choice.getChoices().add(\"Red\");\r\n        }\r\n        if (types.getBlue() > 0) {\r\n            choice.getChoices().add(\"Blue\");\r\n        }\r\n        if (types.getGreen() > 0) {\r\n            choice.getChoices().add(\"Green\");\r\n        }\r\n        if (types.getWhite() > 0) {\r\n            choice.getChoices().add(\"White\");\r\n        }\r\n        if (types.getColorless() > 0) {\r\n            choice.getChoices().add(\"Colorless\");\r\n        }\r\n        if (types.getAny() > 0) {\r\n            choice.getChoices().add(\"Black\");\r\n            choice.getChoices().add(\"Red\");\r\n            choice.getChoices().add(\"Blue\");\r\n            choice.getChoices().add(\"Green\");\r\n            choice.getChoices().add(\"White\");\r\n            choice.getChoices().add(\"Colorless\");\r\n        }\r\n        if (choice.getChoices().size() > 0) {\r\n            Player player = game.getPlayer(source.getControllerId());\r\n            if (choice.getChoices().size() == 1) {\r\n                choice.setChoice(choice.getChoices().iterator().next());\r\n            } else {\r\n                player.choose(outcome, choice, game);\r\n            }\r\n            if (choice.getChoice() != null) {\r\n                switch (choice.getChoice()) {\r\n                    case \"Black\":\r\n                        player.getManaPool().addMana(Mana.BlackMana, game, source);\r\n                        break;\r\n                    case \"Blue\":\r\n                        player.getManaPool().addMana(Mana.BlueMana, game, source);\r\n                        break;\r\n                    case \"Red\":\r\n                        player.getManaPool().addMana(Mana.RedMana, game, source);\r\n                        break;\r\n                    case \"Green\":\r\n                        player.getManaPool().addMana(Mana.GreenMana, game, source);\r\n                        break;\r\n                    case \"White\":\r\n                        player.getManaPool().addMana(Mana.WhiteMana, game, source);\r\n                        break;\r\n                    case \"Colorless\":\r\n                        player.getManaPool().addMana(Mana.ColorlessMana, game, source);\r\n                        break;\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }","id":95091,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Mana types = getManaTypes(game, source);\r\n        Choice choice = new ChoiceImpl(false);\r\n        choice.setMessage(\"Pick a mana color\");\r\n        if (types.getBlack() > 0) {\r\n            choice.getChoices().add(\"Black\");\r\n        }\r\n        if (types.getRed() > 0) {\r\n            choice.getChoices().add(\"Red\");\r\n        }\r\n        if (types.getBlue() > 0) {\r\n            choice.getChoices().add(\"Blue\");\r\n        }\r\n        if (types.getGreen() > 0) {\r\n            choice.getChoices().add(\"Green\");\r\n        }\r\n        if (types.getWhite() > 0) {\r\n            choice.getChoices().add(\"White\");\r\n        }\r\n        if (types.getColorless() > 0) {\r\n            choice.getChoices().add(\"Colorless\");\r\n        }\r\n        if (types.getAny() > 0) {\r\n            choice.getChoices().add(\"Black\");\r\n            choice.getChoices().add(\"Red\");\r\n            choice.getChoices().add(\"Blue\");\r\n            choice.getChoices().add(\"Green\");\r\n            choice.getChoices().add(\"White\");\r\n            choice.getChoices().add(\"Colorless\");\r\n        }\r\n        if (choice.getChoices().size() > 0) {\r\n            Player player = game.getPlayer(source.getControllerId());\r\n            if (choice.getChoices().size() == 1) {\r\n                choice.setChoice(choice.getChoices().iterator().next());\r\n            } else {\r\n                player.choose(outcome, choice, game);\r\n            }\r\n            if (choice.getChoice() != null) {\r\n                switch (choice.getChoice()) {\r\n                    case \"Black\":\r\n                        player.getManaPool().addMana(Mana.BlackMana, game, source);\r\n                        break;\r\n                    case \"Blue\":\r\n                        player.getManaPool().addMana(Mana.BlueMana, game, source);\r\n                        break;\r\n                    case \"Red\":\r\n                        player.getManaPool().addMana(Mana.RedMana, game, source);\r\n                        break;\r\n                    case \"Green\":\r\n                        player.getManaPool().addMana(Mana.GreenMana, game, source);\r\n                        break;\r\n                    case \"White\":\r\n                        player.getManaPool().addMana(Mana.WhiteMana, game, source);\r\n                        break;\r\n                    case \"Colorless\":\r\n                        player.getManaPool().addMana(Mana.ColorlessMana, game, source);\r\n                        break;\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"public SylvokExplorer(UUID ownerId) {\n        super(ownerId, 93, \"Sylvok Explorer\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n        this.expansionSetCode = \"5DN\";\n        this.subtype.add(\"Human\");\n        this.subtype.add(\"Druid\");\n\n        this.color.setGreen(true);\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(1);\n\n        // {tap}: Add to your mana pool one mana of any color that a land an opponent controls could produce.\n        this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new SylvokExplorerEffect(), new TapSourceCost()));\n    }","id":95092,"modified_method":"public SylvokExplorer(UUID ownerId) {\n        super(ownerId, 93, \"Sylvok Explorer\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n        this.expansionSetCode = \"5DN\";\n        this.subtype.add(\"Human\");\n        this.subtype.add(\"Druid\");\n\n        this.color.setGreen(true);\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(1);\n\n        // {T}: Add to your mana pool one mana of any color that a land an opponent controls could produce.\n        this.addAbility(new AnyColorOpponentLandsProduceManaAbility());\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"public TriggeredManaAbility(Zone zone, ManaEffect effect, boolean optional) {\n        super(zone, effect, optional);\n    }","id":95093,"modified_method":"public TriggeredManaAbility(Zone zone, ManaEffect effect, boolean optional) {\n        super(zone, effect, optional);\n        this.usesStack = false;\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent land = game.getPermanent(this.targetPointer.getFirst(game, source));\r\n        Abilities<ManaAbility> mana = land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);\r\n        Mana types = new Mana();\r\n        for (ManaAbility ability : mana) {\r\n            for (Mana netMana: ability.getNetMana(game)) {\r\n                types.add(netMana);\r\n            }                \r\n        }\r\n        Choice choice = new ChoiceImpl(true);\r\n        choice.setMessage(\"Pick a mana color\");\r\n        if (types.getBlack() > 0) {\r\n            choice.getChoices().add(\"Black\");\r\n        }\r\n        if (types.getRed() > 0) {\r\n            choice.getChoices().add(\"Red\");\r\n        }\r\n        if (types.getBlue() > 0) {\r\n            choice.getChoices().add(\"Blue\");\r\n        }\r\n        if (types.getGreen() > 0) {\r\n            choice.getChoices().add(\"Green\");\r\n        }\r\n        if (types.getWhite() > 0) {\r\n            choice.getChoices().add(\"White\");\r\n        }\r\n        if (types.getColorless() > 0) {\r\n            choice.getChoices().add(\"Colorless\");\r\n        }\r\n        if (choice.getChoices().size() > 0) {\r\n            Player player = game.getPlayer(land.getControllerId());\r\n            if (choice.getChoices().size() == 1) {\r\n                choice.setChoice(choice.getChoices().iterator().next());\r\n            } else {\r\n                player.choose(outcome, choice, game);\r\n            }\r\n            if (choice.getChoice().equals(\"Black\")) {\r\n                player.getManaPool().addMana(Mana.BlackMana, game, source);\r\n                return true;\r\n            } else if (choice.getChoice().equals(\"Blue\")) {\r\n                player.getManaPool().addMana(Mana.BlueMana, game, source);\r\n                return true;\r\n            } else if (choice.getChoice().equals(\"Red\")) {\r\n                player.getManaPool().addMana(Mana.RedMana, game, source);\r\n                return true;\r\n            } else if (choice.getChoice().equals(\"Green\")) {\r\n                player.getManaPool().addMana(Mana.GreenMana, game, source);\r\n                return true;\r\n            } else if (choice.getChoice().equals(\"White\")) {\r\n                player.getManaPool().addMana(Mana.WhiteMana, game, source);\r\n                return true;\r\n            } else if (choice.getChoice().equals(\"Colorless\")) {\r\n                player.getManaPool().addMana(Mana.ColorlessMana, game, source);\r\n                return true;\r\n            }\r\n        }\r\n        return true;\r\n    }","id":95094,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent land = game.getPermanent(this.targetPointer.getFirst(game, source));\r\n        Abilities<ManaAbility> mana = land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);\r\n        Mana types = new Mana();\r\n        for (ManaAbility ability : mana) {\r\n            for (Mana netMana: ability.getNetMana(game)) {\r\n                types.add(netMana);\r\n            }                \r\n        }\r\n        Choice choice = new ChoiceImpl(true);\r\n        choice.setMessage(\"Pick a mana color\");\r\n        if (types.getBlack() > 0) {\r\n            choice.getChoices().add(\"Black\");\r\n        }\r\n        if (types.getRed() > 0) {\r\n            choice.getChoices().add(\"Red\");\r\n        }\r\n        if (types.getBlue() > 0) {\r\n            choice.getChoices().add(\"Blue\");\r\n        }\r\n        if (types.getGreen() > 0) {\r\n            choice.getChoices().add(\"Green\");\r\n        }\r\n        if (types.getWhite() > 0) {\r\n            choice.getChoices().add(\"White\");\r\n        }\r\n        if (types.getColorless() > 0) {\r\n            choice.getChoices().add(\"Colorless\");\r\n        }\r\n        if (choice.getChoices().size() > 0) {\r\n            Player player = game.getPlayer(land.getControllerId());\r\n            if (choice.getChoices().size() == 1) {\r\n                choice.setChoice(choice.getChoices().iterator().next());\r\n            } else {\r\n                player.choose(outcome, choice, game);\r\n            }\r\n            switch (choice.getChoice()) {\r\n                case \"Black\":\r\n                    player.getManaPool().addMana(Mana.BlackMana, game, source);\r\n                    return true;\r\n                case \"Blue\":\r\n                    player.getManaPool().addMana(Mana.BlueMana, game, source);\r\n                    return true;\r\n                case \"Red\":\r\n                    player.getManaPool().addMana(Mana.RedMana, game, source);\r\n                    return true;\r\n                case \"Green\":\r\n                    player.getManaPool().addMana(Mana.GreenMana, game, source);\r\n                    return true;\r\n                case \"White\":\r\n                    player.getManaPool().addMana(Mana.WhiteMana, game, source);\r\n                    return true;\r\n                case \"Colorless\":\r\n                    player.getManaPool().addMana(Mana.ColorlessMana, game, source);\r\n                    return true;\r\n            }\r\n        }\r\n        return true;\r\n    }","commit_id":"036095f6ec3f126090cf081b7cf94ede7b1d7efa","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            int damage = 0;\r\n            for (UUID opponentId: game.getOpponents(source.getControllerId())) {\r\n                damage += game.getPlayer(opponentId).damage(1, source.getSourceId(), game, false, true);\r\n            }\r\n            controller.gainLife(damage, game);\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }","id":95095,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            int loseLife = 0;\r\n            for (UUID opponentId: game.getOpponents(source.getControllerId())) {\r\n                Player opponent = game.getPlayer(opponentId);\r\n                if (opponent != null) {\r\n                    loseLife += opponent.loseLife(1, game);\r\n                }\r\n            }\r\n            controller.gainLife(loseLife, game);\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }","commit_id":"d501a38ac477cdc6539e07df21f2cbf317663897","url":"https://github.com/magefree/mage"},{"original_method":"public UrborgSyphonMage(UUID ownerId) {\r\n        super(ownerId, 139, \"Urborg Syphon-Mage\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{2}{B}\");\r\n        this.expansionSetCode = \"TSP\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Spellshaper\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // {2}{B}, {tap}, Discard a card: Each other player loses 2 life. You gain life equal to the life lost this way.\r\n        Ability ability = new SimpleActivatedAbility(Zone.HAND, new UrborgSyphonMageEffect(), new ManaCostsImpl(\"{2}{B}\"));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new DiscardCardCost());\r\n        this.addAbility(ability);\r\n    }","id":95096,"modified_method":"public UrborgSyphonMage(UUID ownerId) {\r\n        super(ownerId, 139, \"Urborg Syphon-Mage\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{2}{B}\");\r\n        this.expansionSetCode = \"TSP\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Spellshaper\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // {2}{B}, {tap}, Discard a card: Each other player loses 2 life. You gain life equal to the life lost this way.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UrborgSyphonMageEffect(), new ManaCostsImpl(\"{2}{B}\"));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new DiscardCardCost());\r\n        this.addAbility(ability);\r\n    }","commit_id":"f3974e61aff03aaa64dc51839c4c33dcccee5b57","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int damage = 0;\r\n        for (UUID playerId: game.getPlayerList() ){\r\n            if(playerId != source.getControllerId()){\r\n                damage += game.getPlayer(playerId).damage(2, source.getSourceId(), game, false, true);\r\n            }\r\n        }\r\n        game.getPlayer(source.getControllerId()).gainLife(damage, game);\r\n        return true;\r\n    }","id":95097,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int damage = 0;\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            for (UUID playerId : controller.getInRange()) {\r\n                if (playerId != source.getControllerId()) {\r\n                    Player player = game.getPlayer(playerId);\r\n                    if (player != null) {\r\n                        damage += player.damage(2, source.getSourceId(), game, false, true);\r\n                    }\r\n                }\r\n            }\r\n            game.getPlayer(source.getControllerId()).gainLife(damage, game);\r\n            return true;\r\n        }\r\n        return false;\r\n\r\n    }","commit_id":"f3974e61aff03aaa64dc51839c4c33dcccee5b57","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        return game.getPlayer(source.getControllerId()).getLibrary().getFromTop(game).getColor().isBlack();\r\n    }","id":95098,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player != null) {\r\n            Card card = player.getLibrary().getFromTop(game);\r\n            if (card != null) {\r\n                return card.getColor().isBlack();\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"1c1daf8bcb1b690f333f9d9b453130123b5817e5","url":"https://github.com/magefree/mage"},{"original_method":"public void qualityDiffVsDinucleotide() {\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            PrintStream ByDinucFile = null;\n            try {\n                ByDinucFile = new PrintStream(OUTPUT_FILEROOT+\".RG_\"+readGroup.getReadGroupId()+\".quality_difference_v_dinucleotide.csv\");\n            } catch (FileNotFoundException e){\n                System.out.println(\"Could not open output files based on OUTPUT_FILEROOT option: \" + OUTPUT_FILEROOT);\n                System.exit(1);\n            }\n            ArrayList<RecalData> ByCycle = new ArrayList<RecalData>();\n            ArrayList<MeanReportedQuality> ByCycleReportedQ = new ArrayList<MeanReportedQuality>();\n            ByDinucFile.printf(\"dinuc,Qemp-obs,Qemp,Qobs,B,N%n\");\n            RecalData All = new RecalData(0,0,readGroup.getReadGroupId(),\"\");\n            MeanReportedQuality AllReported = new MeanReportedQuality();\n            for (int c=0; c < NDINUCS; c++) {\n                ByCycle.add(new RecalData(-1, -1,readGroup.getReadGroupId(),dinucIndex2bases(c)));\n                ByCycleReportedQ.add(new MeanReportedQuality());\n            }\n\n            for ( RecalData datum: flattenData ) {\n                if( !datum.readGroup.equals(readGroup.getReadGroupId()) )\n                    continue;\n                int dinucIndex = string2dinucIndex(datum.dinuc); //bases2dinucIndex(datum.dinuc.charAt(0), datum.dinuc.charAt(1), false);\n                ByCycle.get(dinucIndex).inc(datum.N, datum.B);\n                ByCycleReportedQ.get(dinucIndex).inc(datum.qual, datum.N);\n                All.inc(datum.N, datum.B);\n                AllReported.inc(datum.qual, datum.N);\n            }\n\n            for (int c=0; c < NDINUCS; c++) {\n                double empiricalQual = -10 * Math.log10((double)ByCycle.get(c).B / ByCycle.get(c).N);\n                double reportedQual = ByCycleReportedQ.get(c).result();\n                ByDinucFile.printf(\"%s, %f, %f, %f, %d, %d%n\", ByCycle.get(c).dinuc, empiricalQual-reportedQual, empiricalQual, reportedQual, ByCycle.get(c).B, ByCycle.get(c).N);\n            }\n        }\n        //System.out.printf(\"Dinuc: N=%d, B=%d, Qemp=%.1f, \", All.N, All.B, -10 * Math.log10((double)All.B/All.N));\n        //System.out.printf(\"Qrep=%.1f%n\", AllReported.result());\n    }","id":95099,"modified_method":"public void qualityDiffVsDinucleotide() {\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            PrintStream ByDinucFile = null;\n            try {\n                ByDinucFile = new PrintStream(OUTPUT_FILEROOT+\".RG_\"+readGroup.getReadGroupId()+\".quality_difference_v_dinucleotide.csv\");\n            } catch (FileNotFoundException e){\n                System.out.println(\"Could not open output files based on OUTPUT_FILEROOT option: \" + OUTPUT_FILEROOT);\n                System.exit(1);\n            }\n            ArrayList<RecalData> ByCycle = new ArrayList<RecalData>();\n            ArrayList<MeanReportedQuality> ByCycleReportedQ = new ArrayList<MeanReportedQuality>();\n            ByDinucFile.printf(\"dinuc,Qemp-obs,Qemp,Qobs,B,N%n\");\n            RecalData All = new RecalData(0,0,readGroup.getReadGroupId(),\"\");\n            MeanReportedQuality AllReported = new MeanReportedQuality();\n            for (int c=0; c < NDINUCS; c++) {\n                ByCycle.add(new RecalData(-1, -1,readGroup.getReadGroupId(),RecalData.dinucIndex2bases(c)));\n                ByCycleReportedQ.add(new MeanReportedQuality());\n            }\n\n            for ( RecalData datum: getRecalData(readGroup.getReadGroupId()) ) {\n                int dinucIndex = RecalData.string2dinucIndex(datum.dinuc); //bases2dinucIndex(datum.dinuc.charAt(0), datum.dinuc.charAt(1), false);\n                ByCycle.get(dinucIndex).inc(datum.N, datum.B);\n                ByCycleReportedQ.get(dinucIndex).inc(datum.qual, datum.N);\n                All.inc(datum.N, datum.B);\n                AllReported.inc(datum.qual, datum.N);\n            }\n\n            for (int c=0; c < NDINUCS; c++) {\n                double empiricalQual = -10 * Math.log10((double)ByCycle.get(c).B / ByCycle.get(c).N);\n                double reportedQual = ByCycleReportedQ.get(c).result();\n                ByDinucFile.printf(\"%s, %f, %f, %f, %d, %d%n\", ByCycle.get(c).dinuc, empiricalQual-reportedQual, empiricalQual, reportedQual, ByCycle.get(c).B, ByCycle.get(c).N);\n            }\n        }\n        //System.out.printf(\"Dinuc: N=%d, B=%d, Qemp=%.1f, \", All.N, All.B, -10 * Math.log10((double)All.B/All.N));\n        //System.out.printf(\"Qrep=%.1f%n\", AllReported.result());\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        if( getToolkit().getEngine().getSAMHeader().getReadGroups().size() > MAX_READ_GROUPS )\n            Utils.scareUser(\"Number of read groups in the specified file exceeds the number that can be processed in a reasonable amount of memory.\" +\n                            \"To override this limit, use the --MAX_READ_GROUPS (-mrg) parameter\");\n\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            if( readGroup.getAttribute(\"PL\") == null )\n                Utils.warnUser(String.format(\"PL attribute for read group %s is unset; assuming all reads are supported\",readGroup.getReadGroupId()));\n            if( !isSupportedReadGroup(readGroup) )\n                continue;\n            data.put(readGroup.getReadGroupId(), new RecalData[MAX_READ_LENGTH+1][MAX_QUAL_SCORE+1][NDINUCS]);\n            for ( int i = 0; i < MAX_READ_LENGTH+1; i++) {\n                for ( int j = 0; j < MAX_QUAL_SCORE+1; j++) {\n                    for ( int k = 0; k < NDINUCS; k++) {\n                        String dinuc = dinucIndex2bases(k);\n                        RecalData datum = new RecalData(i, j, readGroup.getReadGroupId(), dinuc);\n                        data.get(readGroup.getReadGroupId())[i][j][k] = datum;\n                        flattenData.add(datum);\n                    }\n                }\n            }\n        }\n    }","id":95100,"modified_method":"public void initialize() {\n        if( getToolkit().getEngine().getSAMHeader().getReadGroups().size() > MAX_READ_GROUPS )\n            Utils.scareUser(\"Number of read groups in the specified file exceeds the number that can be processed in a reasonable amount of memory.\" +\n                            \"To override this limit, use the --MAX_READ_GROUPS (-mrg) parameter\");\n\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            if( readGroup.getAttribute(\"PL\") == null )\n                Utils.warnUser(String.format(\"PL attribute for read group %s is unset; assuming all reads are supported\",readGroup.getReadGroupId()));\n            if( !isSupportedReadGroup(readGroup) )\n                continue;\n            String rg = readGroup.getReadGroupId();\n            RecalDataManager manager = new RecalDataManager(rg, maxReadLen, QualityUtils.MAX_QUAL_SCORE+1, NDINUCS, trackPos, trackDinuc );\n            //data.put(rg, new RecalData[maxReadLen+1][QualityUtils.MAX_QUAL_SCORE+1][NDINUCS]);\n            data.put(rg, manager);\n        }\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void onTraversalDone(Integer result) {\n        PrintStream covars_out;\n        try {\n            covars_out = new PrintStream(OUTPUT_FILEROOT+\".covars.out\");\n            if (flattenData.size() > 0)\n                covars_out.println(flattenData.get(0).headerString());\n            for ( RecalData datum : flattenData ) {\n                covars_out.println(datum);\n            }\n        } catch (FileNotFoundException e) {\n            System.err.println(\"FileNotFoundException: \" + e.getMessage());\n        }\n\n        qualityEmpiricalObserved();\n        qualityDiffVsCycle();\n        qualityDiffVsDinucleotide();\n\n        out.printf(\"Counted sites: %d%n\", counted_sites);\n        out.printf(\"Skipped sites: %d%n\", skipped_sites);\n        out.printf(\"Fraction skipped: 1/%.0f%n\", (double)counted_sites / skipped_sites);\n\n        if (CREATE_TRAINING_DATA) writeTrainingData();\n    }","id":95101,"modified_method":"public void onTraversalDone(Integer result) {\n        PrintStream covars_out;\n        try {\n            covars_out = new PrintStream(OUTPUT_FILEROOT+\".covars.out\");\n            covars_out.println(RecalData.headerString());\n            for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n                for ( RecalData datum : getRecalData(readGroup.getReadGroupId()) ) {\n                    covars_out.println(datum);\n                }\n            }\n        } catch (FileNotFoundException e) {\n            System.err.println(\"FileNotFoundException: \" + e.getMessage());\n        }\n\n        qualityEmpiricalObserved();\n        qualityDiffVsCycle();\n        qualityDiffVsDinucleotide();\n\n        out.printf(\"Counted sites: %d%n\", counted_sites);\n        out.printf(\"Counted bases: %d%n\", counted_bases);\n        out.printf(\"Skipped sites: %d%n\", skipped_sites);\n        out.printf(\"Fraction skipped: 1/%.0f%n\", (double)counted_sites / skipped_sites);\n\n        if (CREATE_TRAINING_DATA) writeTrainingData();\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void qualityDiffVsCycle() {\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            PrintStream ByCycleFile = null;\n            try {\n                ByCycleFile = new PrintStream(OUTPUT_FILEROOT+\".RG_\"+readGroup.getReadGroupId()+\".quality_difference_v_cycle.csv\");\n            } catch (FileNotFoundException e){\n                System.out.println(\"Could not open output files based on OUTPUT_FILEROOT option: \" + OUTPUT_FILEROOT);\n                System.exit(1);\n            }\n            ArrayList<RecalData> ByCycle = new ArrayList<RecalData>();\n            ArrayList<MeanReportedQuality> ByCycleReportedQ = new ArrayList<MeanReportedQuality>();\n            ByCycleFile.printf(\"cycle,Qemp-obs,Qemp,Qobs,B,N%n\");\n            RecalData All = new RecalData(0,0,readGroup.getReadGroupId(),\"\");\n            MeanReportedQuality AllReported = new MeanReportedQuality();\n            for (int c=0; c < MAX_READ_LENGTH+1; c++)  {\n                ByCycle.add(new RecalData(c, -1,readGroup.getReadGroupId(),\"-\"));\n                ByCycleReportedQ.add(new MeanReportedQuality());\n            }\n\n            for ( RecalData datum: flattenData ) {\n                if( !datum.readGroup.equals(readGroup.getReadGroupId()) )\n                    continue;\n                ByCycle.get(datum.pos).inc(datum.N, datum.B);\n                ByCycleReportedQ.get(datum.pos).inc(datum.qual, datum.N);\n                All.inc(datum.N, datum.B);\n                AllReported.inc(datum.qual, datum.N);\n            }\n\n            for (int c=0; c < MAX_READ_LENGTH+1; c++) {\n                double empiricalQual = -10 * Math.log10((double)ByCycle.get(c).B / ByCycle.get(c).N);\n                double reportedQual = ByCycleReportedQ.get(c).result();\n                ByCycleFile.printf(\"%d, %f, %f, %f, %d, %d%n\", c, empiricalQual-reportedQual, empiricalQual, reportedQual, ByCycle.get(c).B, ByCycle.get(c).N);\n            }\n        }\n        //System.out.printf(\"Cycle: N=%d, B=%d, Qemp=%.1f, \", All.N, All.B, -10 * Math.log10((double)All.B/All.N));\n        //System.out.printf(\"Qrep=%.1f%n\", AllReported.result());\n    }","id":95102,"modified_method":"public void qualityDiffVsCycle() {\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            PrintStream ByCycleFile = null;\n            try {\n                ByCycleFile = new PrintStream(OUTPUT_FILEROOT+\".RG_\"+readGroup.getReadGroupId()+\".quality_difference_v_cycle.csv\");\n            } catch (FileNotFoundException e){\n                System.out.println(\"Could not open output files based on OUTPUT_FILEROOT option: \" + OUTPUT_FILEROOT);\n                System.exit(1);\n            }\n            ArrayList<RecalData> ByCycle = new ArrayList<RecalData>();\n            ArrayList<MeanReportedQuality> ByCycleReportedQ = new ArrayList<MeanReportedQuality>();\n            ByCycleFile.printf(\"cycle,Qemp-obs,Qemp,Qobs,B,N%n\");\n            RecalData All = new RecalData(0,0,readGroup.getReadGroupId(),\"\");\n            MeanReportedQuality AllReported = new MeanReportedQuality();\n            for (int c=0; c < maxReadLen+1; c++)  {\n                ByCycle.add(new RecalData(c, -1,readGroup.getReadGroupId(),\"-\"));\n                ByCycleReportedQ.add(new MeanReportedQuality());\n            }\n\n            for ( RecalData datum: getRecalData(readGroup.getReadGroupId()) ) {\n                ByCycle.get(datum.pos).inc(datum.N, datum.B);\n                ByCycleReportedQ.get(datum.pos).inc(datum.qual, datum.N);\n                All.inc(datum.N, datum.B);\n                AllReported.inc(datum.qual, datum.N);\n            }\n\n            for (int c=0; c < maxReadLen+1; c++) {\n                double empiricalQual = -10 * Math.log10((double)ByCycle.get(c).B / ByCycle.get(c).N);\n                double reportedQual = ByCycleReportedQ.get(c).result();\n                ByCycleFile.printf(\"%d, %f, %f, %f, %d, %d%n\", c, empiricalQual-reportedQual, empiricalQual, reportedQual, ByCycle.get(c).B, ByCycle.get(c).N);\n            }\n        }\n        //System.out.printf(\"Cycle: N=%d, B=%d, Qemp=%.1f, \", All.N, All.B, -10 * Math.log10((double)All.B/All.N));\n        //System.out.printf(\"Qrep=%.1f%n\", AllReported.result());\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, char ref, LocusContext context) {\n        rodDbSNP dbsnp = (rodDbSNP)tracker.lookup(\"dbSNP\", null);\n        if ( dbsnp == null || !dbsnp.isSNP() ) {\n            List<SAMRecord> reads = context.getReads();\n            List<Integer> offsets = context.getOffsets();\n            for (int i =0; i < reads.size(); i++ ) {\n                SAMRecord read = reads.get(i);\n                SAMReadGroupRecord readGroup = read.getHeader().getReadGroup((String)read.getAttribute(\"RG\"));\n                if ( isSupportedReadGroup(readGroup) &&\n                    !read.getReadNegativeStrandFlag() &&\n                    (READ_GROUP.equals(\"none\") || read.getAttribute(\"RG\") != null && read.getAttribute(\"RG\").equals(READ_GROUP)) &&\n                    (read.getMappingQuality() >= MIN_MAPPING_QUALITY)) {\n                    //(random_genrator.nextFloat() <= DOWNSAMPLE_FRACTION)\n                    int offset = offsets.get(i);\n                    int numBases = read.getReadLength();\n                    if ( offset > 0 && offset < (numBases-1) ) { // skip first and last bases because they suck and they don't have a dinuc count\n                        int qual = (int)read.getBaseQualities()[offset];\n                        if (qual > 0 && qual <= MAX_QUAL_SCORE) {\n                            // previous base is the next base in terms of machine chemistry if this is a negative strand\n                            char base = (char)read.getReadBases()[offset];\n                            char prevBase = (char)read.getReadBases()[offset -1];\n                            int dinuc_index = bases2dinucIndex(prevBase, base, false);\n                            //char prevBase = (char)read.getReadBases()[offset + (read.getReadNegativeStrandFlag() ? 1 : -1)];\n                            //int dinuc_index = bases2dinucIndex(prevBase, base, read.getReadNegativeStrandFlag());\n\n                            // Convert offset into cycle position which means reversing the position of reads on the negative strand\n                            //int cycle = read.getReadNegativeStrandFlag() ? numBases - offset - 1 : offset;\n                            //data[cycle][qual][dinuc_index].inc(base,ref);\n                            data.get(readGroup.getReadGroupId())[offset][qual][dinuc_index].inc(base,ref);\n                        }\n                    }\n                }\n            }\n            counted_sites += 1;\n        }else{\n            skipped_sites += 1;\n            //System.out.println(dbsnp.toSimpleString()+\" \"+new ReadBackedPileup(ref, context).getPileupString());\n        }\n        return 1;\n    }","id":95103,"modified_method":"public Integer map(RefMetaDataTracker tracker, char ref, LocusContext context) {\n        //System.out.printf(\"%s %c%n\", context.getLocation(), ref);\n        rodDbSNP dbsnp = (rodDbSNP)tracker.lookup(\"dbSNP\", null);\n        if ( dbsnp == null || !dbsnp.isSNP() ) {\n            List<SAMRecord> reads = context.getReads();\n            List<Integer> offsets = context.getOffsets();\n            for (int i =0; i < reads.size(); i++ ) {\n                SAMRecord read = reads.get(i);\n\n                if ( read.getReadLength() > maxReadLen ) {\n                    throw new RuntimeException(\"Expectedly long read, please increase maxium read len with maxReadLen parameter: \" + read.format());\n                }\n\n                SAMReadGroupRecord readGroup = read.getHeader().getReadGroup((String)read.getAttribute(\"RG\"));\n                if ( isSupportedReadGroup(readGroup) &&\n                    //!read.getReadNegativeStrandFlag() &&\n                    (READ_GROUP.equals(\"none\") || read.getAttribute(\"RG\") != null && read.getAttribute(\"RG\").equals(READ_GROUP)) &&\n                    (read.getMappingQuality() >= MIN_MAPPING_QUALITY)) {\n                    int offset = offsets.get(i);\n                    int numBases = read.getReadLength();\n                    if ( offset > 0 && offset < (numBases-1) ) { // skip first and last bases because they suck and they don't have a dinuc count\n                        counted_bases += updateDataFromRead(readGroup.getReadGroupId(), read, offset, ref);\n                    }\n                }\n            }\n            counted_sites += 1;\n        } else {\n            skipped_sites += 1;\n            //System.out.println(dbsnp.toSimpleString()+\" \"+new ReadBackedPileup(ref, context).getPileupString());\n        }\n        return 1;\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void qualityEmpiricalObserved() {\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            PrintStream ByQualFile  = null;\n            try {\n                ByQualFile = new PrintStream(OUTPUT_FILEROOT+\".RG_\"+readGroup.getReadGroupId()+\".empirical_v_reported_quality.csv\");\n            } catch (FileNotFoundException e){\n                System.out.println(\"Could not open output files based on OUTPUT_FILEROOT option: \" + OUTPUT_FILEROOT);\n                System.exit(1);\n            }\n            ArrayList<RecalData> ByQ = new ArrayList<RecalData>();\n            ArrayList<MeanReportedQuality> ByQReportedQ = new ArrayList<MeanReportedQuality>();\n            ByQualFile.printf(\"Qrep,Qemp,Qrep_avg,B,N%n\");\n            RecalData All = new RecalData(0,0,readGroup.getReadGroupId(),\"\");\n            MeanReportedQuality AllReported = new MeanReportedQuality();\n            for (int q=0; q<MAX_QUAL_SCORE+1; q++) {\n                ByQ.add(new RecalData(-1,q,readGroup.getReadGroupId(),\"-\"));\n                ByQReportedQ.add(new MeanReportedQuality());\n            }\n\n            for ( RecalData datum: flattenData ){\n                if( !datum.readGroup.equals(readGroup.getReadGroupId()) )\n                    continue;                \n                ByQ.get(datum.qual).inc(datum.N, datum.B);\n                ByQReportedQ.get(datum.qual).inc(datum.qual, datum.N);\n                All.inc(datum.N, datum.B);\n                AllReported.inc(datum.qual, datum.N);\n                //out.printf(\"%2d%6d%3d %2d %s%n\", datum.qual, datum.N, datum.pos, datum.qual, datum.dinuc);\n            }\n\n            for (int q=0; q<MAX_QUAL_SCORE; q++) {\n                double empiricalQual = -10 * Math.log10((double)ByQ.get(q).B / ByQ.get(q).N);\n                ByQualFile.printf(\"%d, %f, %.0f, %d, %d%n\", q, empiricalQual, ByQReportedQ.get(q).result(), ByQ.get(q).B, ByQ.get(q).N);\n                //out.printf(\"%3d,%s,%3d,%5.1f,%5.1f,%6d,%6d\", pos, dinuc, qual, empiricalQual, qual-empiricalQual, N, B);                                                                                      n\n            }\n        }\n        //System.out.printf(\"Emp-Obs: N=%d, B=%d, Qemp=%.1f, \", All.N, All.B, -10 * Math.log10((double)All.B/All.N));\n        //System.out.printf(\"Qrep=%.1f%n\", AllReported.result());\n    }","id":95104,"modified_method":"public void qualityEmpiricalObserved() {\n        for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n            PrintStream ByQualFile  = null;\n            try {\n                ByQualFile = new PrintStream(OUTPUT_FILEROOT+\".RG_\"+readGroup.getReadGroupId()+\".empirical_v_reported_quality.csv\");\n            } catch (FileNotFoundException e){\n                System.out.println(\"Could not open output files based on OUTPUT_FILEROOT option: \" + OUTPUT_FILEROOT);\n                System.exit(1);\n            }\n            ArrayList<RecalData> ByQ = new ArrayList<RecalData>();\n            ArrayList<MeanReportedQuality> ByQReportedQ = new ArrayList<MeanReportedQuality>();\n            ByQualFile.printf(\"Qrep,Qemp,Qrep_avg,B,N%n\");\n            RecalData All = new RecalData(0,0,readGroup.getReadGroupId(),\"\");\n            MeanReportedQuality AllReported = new MeanReportedQuality();\n            for (int q=0; q<QualityUtils.MAX_QUAL_SCORE+1; q++) {\n                ByQ.add(new RecalData(-1,q,readGroup.getReadGroupId(),\"-\"));\n                ByQReportedQ.add(new MeanReportedQuality());\n            }\n\n            for ( RecalData datum: getRecalData(readGroup.getReadGroupId()) ){\n                ByQ.get(datum.qual).inc(datum.N, datum.B);\n                ByQReportedQ.get(datum.qual).inc(datum.qual, datum.N);\n                All.inc(datum.N, datum.B);\n                AllReported.inc(datum.qual, datum.N);\n                //out.printf(\"%2d%6d%3d %2d %s%n\", datum.qual, datum.N, datum.pos, datum.qual, datum.dinuc);\n            }\n\n            for (int q=0; q<QualityUtils.MAX_QUAL_SCORE; q++) {\n                double empiricalQual = -10 * Math.log10((double)ByQ.get(q).B / ByQ.get(q).N);\n                ByQualFile.printf(\"%d, %f, %.0f, %d, %d%n\", q, empiricalQual, ByQReportedQ.get(q).result(), ByQ.get(q).B, ByQ.get(q).N);\n                //out.printf(\"%3d,%s,%3d,%5.1f,%5.1f,%6d,%6d\", pos, dinuc, qual, empiricalQual, qual-empiricalQual, N, B);                                                                                      n\n            }\n        }\n        //System.out.printf(\"Emp-Obs: N=%d, B=%d, Qemp=%.1f, \", All.N, All.B, -10 * Math.log10((double)All.B/All.N));\n        //System.out.printf(\"Qrep=%.1f%n\", AllReported.result());\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"void writeTrainingData() {\n        PrintStream dinuc_out = null;\n        try {\n            dinuc_out = new PrintStream( OUTPUT_FILEROOT+\".covariate_counts.csv\");\n            dinuc_out.println(\"rg,dn,logitQ,pos,indicator,count\");            \n            for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n                for ( int dinuc_index=0; dinuc_index<NDINUCS; dinuc_index++) {\n                    for ( RecalData datum: flattenData ) {\n                        if (datum.readGroup.equals(readGroup.getReadGroupId()) && string2dinucIndex(datum.dinuc) == dinuc_index) {\n                            if ((datum.N - datum.B) > 0)\n                                dinuc_out.format(\"%s,%s,%d,%d,%d,%d%n\", readGroup.getReadGroupId(), dinucIndex2bases(dinuc_index), datum.qual, datum.pos, 0, datum.N - datum.B);\n                            if (datum.B > 0)\n                                dinuc_out.format(\"%s,%s,%d,%d,%d,%d%n\", readGroup.getReadGroupId(), dinucIndex2bases(dinuc_index), datum.qual, datum.pos, 1, datum.B);\n                        }\n                    }\n                }\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.err.println(\"FileNotFoundException: \" + e.getMessage());\n            return;\n        }\n        finally {\n            if (dinuc_out != null)\n                dinuc_out.close();\n        }\n\n    }","id":95105,"modified_method":"void writeTrainingData() {\n        PrintStream dinuc_out = null;\n        PrintStream table_out = null;\n        try {\n            dinuc_out = new PrintStream( OUTPUT_FILEROOT+\".covariate_counts.csv\");\n            dinuc_out.println(\"rg,dn,logitQ,pos,indicator,count\");\n            for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n                for ( int dinuc_index=0; dinuc_index<NDINUCS; dinuc_index++) {\n                    for ( RecalData datum: getRecalData(readGroup.getReadGroupId()) ) {\n                        if ( RecalData.string2dinucIndex(datum.dinuc) == dinuc_index ) {\n                            if ((datum.N - datum.B) > 0)\n                                dinuc_out.format(\"%s,%s,%d,%d,%d,%d%n\", readGroup.getReadGroupId(), RecalData.dinucIndex2bases(dinuc_index), datum.qual, datum.pos, 0, datum.N - datum.B);\n                            if (datum.B > 0)\n                                dinuc_out.format(\"%s,%s,%d,%d,%d,%d%n\", readGroup.getReadGroupId(), RecalData.dinucIndex2bases(dinuc_index), datum.qual, datum.pos, 1, datum.B);\n                        }\n                    }\n                }\n            }\n\n            if ( outputRawData ) {\n                table_out = new PrintStream( OUTPUT_FILEROOT+\".raw_data.csv\");\n                for (SAMReadGroupRecord readGroup : this.getToolkit().getEngine().getSAMHeader().getReadGroups()) {\n                    for ( RecalData datum: getRecalData(readGroup.getReadGroupId()) ) {\n                        if ( datum.N > 0 )\n                            table_out.format(\"%s%n\", datum.toCSVString());\n                    }\n                }\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.err.println(\"FileNotFoundException: \" + e.getMessage());\n            return;\n        }\n        finally {\n            if (dinuc_out != null) dinuc_out.close();\n            if (table_out != null) table_out.close();\n        }\n\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"private byte cache2newQual(final String readGroup, HashMap<String, byte[][]> RGcache, byte prevBase, byte base, LogisticRegressor regressor, int cycle, byte qual) {\n        //System.out.printf(\"Lookup %s %c %c %d %d%n\", readGroup, prevBase, base, cycle, qual);\n        //String dinuc = String.format(\"%c%c\", (char)prevBase, (char)base);\n        byte[] bp = {prevBase, base};\n        String dinuc = new String(bp);\n\n        //byte newQualCalc = regressor2newQual(regressor, cycle, qual);\n        byte[][] dataTable = RGcache.get(dinuc);\n\n        byte newQualCached = dataTable != null ? dataTable[cycle][qual] : qual;\n        //if ( newQualCached != newQualCalc ) {\n        //    throw new RuntimeException(String.format(\"Inconsistent quals between the cache and calculation for RG=%s: %s %d %d : %d <> %d\",\n        //            readGroup, dinuc, cycle, qual, newQualCalc, newQualCached));\n        //}\n\n        return newQualCached;\n    }","id":95106,"modified_method":"private byte cache2newQual(final String readGroup, HashMap<String, byte[][]> RGcache, byte prevBase, byte base, LogisticRegressor regressor, int cycle, byte qual) {\n        //System.out.printf(\"Lookup %s %c %c %d %d%n\", readGroup, prevBase, base, cycle, qual);\n        //String dinuc = String.format(\"%c%c\", (char)prevBase, (char)base);\n        byte[] bp = {prevBase, base};\n        String dinuc = new String(bp);\n\n        //byte newQualCalc = regressor2newQual(regressor, cycle, qual);\n        byte[][] dataTable = RGcache.get(dinuc);\n\n        if ( dataTable == null && prevBase != 'N' && base != 'N' )\n            throw new RuntimeException(String.format(\"Unmapped data table at %s %s\", readGroup, dinuc));\n        \n        byte newQualCached = dataTable != null ? dataTable[cycle][qual] : qual;\n        //if ( newQualCached != newQualCalc ) {\n        //    throw new RuntimeException(String.format(\"Inconsistent quals between the cache and calculation for RG=%s: %s %d %d : %d <> %d\",\n        //            readGroup, dinuc, cycle, qual, newQualCalc, newQualCached));\n        //}\n\n        return newQualCached;\n    }","commit_id":"86c8c08375b5524aab3d3842de55d3715c8d9914","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Indent getCodeBlockInternalIndent(final ASTNode child) {\n    if (isTopLevelClass() && mySettings.DO_NOT_INDENT_TOP_LEVEL_CLASS_MEMBERS) {\n      return Formatter.getInstance().getNoneIndent();\n    }\n    final int braceStyle = getBraceStyle();\n    Indent indent = braceStyle == CodeStyleSettings.NEXT_LINE_SHIFTED ? Formatter.getInstance().getNoneIndent() : Formatter.getInstance().createNormalIndent();\n\n    if (child.getElementType() == ElementType.IF_STATEMENT && myNode.getElementType() == ElementType.IF_STATEMENT && mySettings.SPECIAL_ELSE_IF_TREATMENT){\n      indent = Formatter.getInstance().getNoneIndent();\n    }\n    return indent;\n  }","id":95107,"modified_method":"private Indent getCodeBlockInternalIndent(final ASTNode child) {\n    if (isTopLevelClass() && mySettings.DO_NOT_INDENT_TOP_LEVEL_CLASS_MEMBERS) {\n      return Formatter.getInstance().getNoneIndent();\n    }\n\n    if (myNode.getTreeParent().getElementType() == ElementType.SWITCH_STATEMENT && !mySettings.INDENT_CASE_FROM_SWITCH) {\n      return Formatter.getInstance().getNoneIndent();\n    }\n\n    if (child.getElementType() == ElementType.IF_STATEMENT && myNode.getElementType() == ElementType.IF_STATEMENT && mySettings.SPECIAL_ELSE_IF_TREATMENT){\n      return Formatter.getInstance().getNoneIndent();\n    }\n\n    final int braceStyle = getBraceStyle();\n    return braceStyle == CodeStyleSettings.NEXT_LINE_SHIFTED ? Formatter.getInstance().getNoneIndent()\n           : Formatter.getInstance().createNormalIndent();\n  }","commit_id":"c8334b38b13aa226b06f015a103f83277a2651e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n\t * Returns wheter the given line segment intersects the given circle.\r\n\t * \r\n\t * @param start The start point of the line segment\r\n\t * @param end The end point of the line segment\r\n\t * @param center The center of the circle\r\n\t * @param squareRadius The squared radius of the circle\r\n\t * @return Wheter the line segment and the circle intersect\r\n\t */\r\n\tpublic static boolean intersectSegmentCircle (Vector2 start, Vector2 end, Vector2 center, float squareRadius) {\r\n\t\tfloat u = (center.x - start.x) * (end.x - start.x) + (center.y - start.y) * (end.y - start.y);\r\n\t\tfloat d = start.dst(end);\r\n\t\tu /= (d * d);\r\n\t\tif (u < 0 || u > 1) return false;\r\n\t\ttmp.set(end.x, end.y, 0).sub(start.x, start.y, 0);\r\n\t\ttmp2.set(start.x, start.y, 0).add(tmp.mul(u));\r\n\t\tif (tmp2.dst2(center.x, center.y, 0) < squareRadius)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}","id":95108,"modified_method":"/**\r\n\t * Returns wheter the given line segment intersects the given circle.\r\n\t * \r\n\t * @param start The start point of the line segment\r\n\t * @param end The end point of the line segment\r\n\t * @param center The center of the circle\r\n\t * @param squareRadius The squared radius of the circle\r\n\t * @return Wheter the line segment and the circle intersect\r\n\t */\t\r\n\tpublic static boolean intersectSegmentCircle (Vector2 start, Vector2 end, Vector2 center, float squareRadius) {\r\n\t\ttmp.set(end.x - start.x, end.y - start.y, 0);\r\n\t\ttmp1.set(center.x - start.x, center.y - start.y, 0);\r\n\t\t\t\r\n\t\tfloat u = tmp1.dot(tmp.nor());\r\n\t\tif (u <= 0) {\r\n\t\t\ttmp2.set(start.x, start.y, 0);\r\n\t\t} else if (u >= tmp.len()) {\r\n\t\t\ttmp2.set(end.x, end.y, 0);\r\n\t\t} else {\r\n\t\t\ttmp3.set(tmp.mul(u)); //remember tmp is already normalized\r\n\t\t\ttmp2.set(tmp3.x + start.x, tmp3.y + start.y, 0);\r\n\t\t}\r\n\r\n\t\tfloat x = center.x - tmp2.x;\r\n\t\tfloat y = center.y - tmp2.y;\r\n\t\t\t\r\n\t\treturn x*x + y*y <= squareRadius;\r\n\t}","commit_id":"e7b20e563b74a65e9958ee1d674dfffc77728470","url":"https://github.com/libgdx/libgdx"},{"original_method":"static public junit.framework.Test suite() {\n\n        VoltServerConfig config = null;\n        MultiConfigSuiteBuilder builder =\n            new MultiConfigSuiteBuilder(TestGeographyValueQueries.class);\n        boolean success;\n\n        VoltProjectBuilder project = new VoltProjectBuilder();\n\n        String literalSchema =\n                \"CREATE TABLE T (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  POLY GEOGRAPHY\\n\"\n                + \");\\n\"\n                + \"CREATE TABLE PT (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  POLY GEOGRAPHY\\n\"\n                + \");\\n\"\n                + \"PARTITION TABLE PT ON COLUMN PK;\\n\"\n                + \"CREATE TABLE T_NOT_NULL (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  POLY GEOGRAPHY NOT NULL\\n\"\n                + \");\\n\"\n                + \"CREATE TABLE PT_NOT_NULL (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  POLY GEOGRAPHY NOT NULL\\n\"\n                + \");\\n\"\n                + \"CREATE PROCEDURE select_in_t AS \\n\"\n                + \"  SELECT pk FROM t WHERE poly IN ? ORDER BY pk ASC;\\n\"\n                + \"CREATE PROCEDURE select_in_pt AS \\n\"\n                + \"  SELECT pk FROM pt WHERE poly IN ? ORDER BY pk ASC;\\n\"\n                + \"\\n\"\n                ;\n        try {\n            project.addLiteralSchema(literalSchema);\n        }\n        catch (Exception e) {\n            fail();\n        }\n\n        config = new LocalCluster(\"geography-value-onesite.jar\", 1, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n        return builder;\n    }","id":95109,"modified_method":"static public junit.framework.Test suite() {\n\n        VoltServerConfig config = null;\n        MultiConfigSuiteBuilder builder =\n            new MultiConfigSuiteBuilder(TestGeographyValueQueries.class);\n        boolean success;\n\n        VoltProjectBuilder project = new VoltProjectBuilder();\n\n        String literalSchema =\n                \"CREATE TABLE T (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(128),\\n\"\n                + \"  POLY GEOGRAPHY\\n\"\n                + \");\\n\"\n                + \"CREATE TABLE LOCATION (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  LOC_POINT GEOGRAPHY_POINT,\\n\"\n                + \");\\n\"\n                + \"CREATE TABLE PT (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  POLY GEOGRAPHY\\n\"\n                + \");\\n\"\n                + \"PARTITION TABLE PT ON COLUMN PK;\\n\"\n                + \"CREATE TABLE T_NOT_NULL (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  POLY GEOGRAPHY NOT NULL\\n\"\n                + \");\\n\"\n                + \"CREATE TABLE PT_NOT_NULL (\\n\"\n                + \"  PK INTEGER NOT NULL PRIMARY KEY,\\n\"\n                + \"  NAME VARCHAR(32),\\n\"\n                + \"  POLY GEOGRAPHY NOT NULL\\n\"\n                + \");\\n\"\n                + \"CREATE PROCEDURE select_in_t AS \\n\"\n                + \"  SELECT pk FROM t WHERE poly IN ? ORDER BY pk ASC;\\n\"\n                + \"CREATE PROCEDURE select_in_pt AS \\n\"\n                + \"  SELECT pk FROM pt WHERE poly IN ? ORDER BY pk ASC;\\n\"\n                + \"\\n\"\n                ;\n        try {\n            project.addLiteralSchema(literalSchema);\n        }\n        catch (Exception e) {\n            fail();\n        }\n\n        config = new LocalCluster(\"geography-value-onesite.jar\", 1, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n        return builder;\n    }","commit_id":"46a1ffb6f52add40978cfc3a408c8b79c6270ea2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create many regular convex polygons.  In returnValue.get(n).get(k) we put an\n     * (n+3)-sided polygon with the given center and start vertex, with hole size\n     * equal to k*0.2.  If k == 0 there is no hole.  Note that k ranges between\n     * 0 and 4, so k*0.2 ranges between 0 and 0.8.\n     *\n     * @return\n     */\n    private static List<List<GeographyValue>> makeRegularConvexPolygons(GeographyPointValue firstCenter,\n                                                                        GeographyPointValue firstFirstVertex,\n                                                                        double xmul,\n                                                                        double ymul) {\n        List<List<GeographyValue>> answer = new ArrayList<List<GeographyValue>>();\n        for (int idx = 0; idx < 10; idx += 1) {\n            List<GeographyValue> oneSize = new ArrayList<GeographyValue>();\n            for (int hidx = 0; hidx < 5; hidx += 1) {\n                GeographyPointValue center = firstCenter.add(x.mul(xmul*idx).add(y.mul(ymul*hidx)));\n                GeographyPointValue firstVertex = firstFirstVertex.add(x.mul(xmul*idx).add(y.mul(ymul*hidx)));\n                oneSize.add(PolygonFactory.CreateRegularConvex(center, firstVertex, idx + 3, hidx*0.2));\n            }\n            answer.add(oneSize);\n        }\n        return answer;\n    }","id":95110,"modified_method":"/**\n     * Create many regular convex polygons.  In returnValue.get(n).get(k) we put an\n     * (n+3)-sided polygon with the given center and start vertex, with hole size\n     * equal to k/numHoleSizes.  If k == 0 there is no hole.  Note that k ranges between\n     * 0 and 4, so k/NumHoleSizes ranges between 0 and (1-1/numHoleSizes).  If k == 0\n     * there is no hole.\n     *\n     * @return\n     */\n    private static List<List<GeographyValue>> makeRegularConvexPolygons(GeographyPointValue firstCenter,\n                                                                 GeographyPointValue firstFirstVertex,\n                                                                 int minNumberVertices,\n                                                                 int maxNumberVertices,\n                                                                 int numHoleSizes,\n                                                                 double xmul,\n                                                                 double ymul) {\n        List<List<GeographyValue>> answer = new ArrayList<List<GeographyValue>>();\n        for (int numVertices = minNumberVertices; numVertices <= maxNumberVertices; numVertices += 1) {\n            int idx = numVertices - minNumberVertices;\n            List<GeographyValue> oneSize = new ArrayList<GeographyValue>();\n            // The x coordinate is humHoleSizes*idx.\n            GeographyPointValue sCenter = firstCenter.add(x.mul(numHoleSizes*idx));\n            for (int hidx = 0; hidx < numHoleSizes; hidx += 1) {\n                // The y coordinate is ymul * hidx.\n                GeographyPointValue offset = sCenter.add(y.mul(ymul*hidx));\n                GeographyPointValue center = firstCenter.add(offset);\n                GeographyPointValue firstVertex = firstFirstVertex.add(offset);\n                oneSize.add(PolygonFactory.CreateRegularConvex(center, firstVertex, numVertices, (hidx+0.0)/numHoleSizes));\n            }\n            answer.add(oneSize);\n        }\n        return answer;\n    }","commit_id":"46a1ffb6f52add40978cfc3a408c8b79c6270ea2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * This main routine is useful for manual testing.  The idea is that one\n     * runs this routine and WKT polygons are printed.  These can be displayed\n     * with qgis.\n     *\n     * It's unfortunate that there are no command line parameters to govern how\n     * this is to be run.\n     *\n     * @param arg\n     */\n    public static void main(String arg[]) {\n        GeographyPointValue center = origin;\n        GeographyPointValue firstVertex = x.mul(0.1).add(y.mul(0.1));\n        List<List<GeographyValue>> polys = makeRegularConvexPolygons(center, firstVertex, 1.0, 1.0);\n        System.out.printf(\":-------------------------------:\\n\");\n        System.out.printf(\":------- Regular Convex --------:\\n\");\n        System.out.printf(\":-------------------------------:\\n\");\n        for (int nsides = 0; nsides < polys.size(); nsides += 1) {\n            for (int holeSize = 0; holeSize < 5; holeSize += 1) {\n                System.out.printf(\"%s\\n\",\n                                  formatWKT(polys.get(nsides).get(holeSize).toString()));\n            }\n        }\n        System.out.printf(\":-------------------------------:\\n\");\n        System.out.printf(\":----------- Stars -------------:\\n\");\n        System.out.printf(\":-------------------------------:\\n\");\n        List<List<List<GeographyValue>>> stars = makeStarPolygons(center, firstVertex, 11, 11, 1, 5, 1.0, 1.0);\n        for (int nsides = 0; nsides < stars.size(); nsides += 1) {\n            List<List<GeographyValue>> oneSize = stars.get(nsides);\n            for (int innerRadiusIdx = 0; innerRadiusIdx < oneSize.size(); innerRadiusIdx += 1) {\n                List<GeographyValue> oneInnerRadius = oneSize.get(innerRadiusIdx);\n                for (int holeSizeIdx = 0; holeSizeIdx < oneInnerRadius.size(); holeSizeIdx += 1) {\n                    GeographyValue oneStar = oneInnerRadius.get(holeSizeIdx);\n                    System.out.printf(\"%s\\n\", formatWKT(oneStar.toString()));\n                }\n            }\n        }\n    }","id":95111,"modified_method":"/**\n     * This main routine is useful for manual testing.  The idea is that one\n     * runs this routine and WKT polygons are printed.  These can be displayed\n     * with qgis or some other display tool.\n     *\n     * @param arg\n     */\n    public static void main(String args[]) {\n        boolean doStars = false;\n        boolean doRegs = false;\n        int minVerts = 3;\n        int maxVerts = 12;\n        int numIRs = 5;\n        int numHoles = 5;\n        double xmul = 3.0;\n        double ymul = 3.0;\n        for (int arg = 0; arg < args.length; arg += 1) {\n            if (args[arg].equals(\"--stars\")) {\n                doStars = true;\n            } else if (args[arg].equals(\"--reg\")) {\n                doRegs = true;\n            } else if (args[arg].equals(\"--minVerts\")) {\n                minVerts = getIntArg(args, ++arg, \"--minVerts expects one integer parameters\");\n            } else if (args[arg].equals(\"--maxVerts\")) {\n                maxVerts = getIntArg(args, ++arg, \"--maxVerts expects one integer parameters\");\n            } else if (args[arg].equals(\"--numHoles\")) {\n                numHoles = getIntArg(args, ++arg, \"--numHoles expects one integer parameter\");\n            } else if (args[arg].equals(\"--numIRs\")) {\n                numIRs = getIntArg(args, ++arg, \"--numIRs expects one integer parameter\");\n            } else if (args[arg].equals(\"--xmul\")) {\n                xmul = getDoubleArg(args, ++arg, \"--xmul expects one double parameter\");\n            } else if (args[arg].equals(\"--ymul\")) {\n                ymul = getDoubleArg(args, ++arg, \"--ymul expects one double parameter\");\n            } else {\n                System.err.printf(\"Unknown command line parameter \\\"%s\\\"\\n\", args[arg]);\n                System.exit(100);\n            }\n        }\n        GeographyPointValue center = origin.add(x.mul(10).add(y.mul(10)));\n        GeographyPointValue firstVertex = center.add(x.mul(CENTER_SHRINK*xmul).add(y.mul(CENTER_SHRINK*ymul)));\n        if (doRegs) {\n            List<List<GeographyValue>> polys = makeRegularConvexPolygons(center, firstVertex, minVerts, maxVerts, numHoles, xmul, ymul);\n            for (int nsides = 0; nsides < polys.size(); nsides += 1) {\n                for (int holeSize = 0; holeSize < 5; holeSize += 1) {\n                    System.out.printf(\"%s\\n\",\n                                      formatWKT(polys.get(nsides).get(holeSize).toString()));\n                }\n            }\n        }\n        if (doStars) {\n            GeographyPointValue scenter = center;\n            GeographyPointValue sfirstVertex = firstVertex;\n            List<List<List<GeographyValue>>> stars = makeStarPolygons(scenter, sfirstVertex, minVerts, maxVerts, numIRs, numHoles, xmul, ymul);\n            for (int nsides = 0; nsides < stars.size(); nsides += 1) {\n                List<List<GeographyValue>> oneSize = stars.get(nsides);\n                for (int innerRadiusIdx = 0; innerRadiusIdx < oneSize.size(); innerRadiusIdx += 1) {\n                    List<GeographyValue> oneInnerRadius = oneSize.get(innerRadiusIdx);\n                    for (int holeSizeIdx = 0; holeSizeIdx < oneInnerRadius.size(); holeSizeIdx += 1) {\n                        GeographyValue oneStar = oneInnerRadius.get(holeSizeIdx);\n                        System.out.printf(\"%s\\n\", formatWKT(oneStar.toString()));\n                    }\n                }\n            }\n        }\n    }","commit_id":"46a1ffb6f52add40978cfc3a408c8b79c6270ea2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create many star-like polygons.  In returnValue.get(n-minNumPoints).get(s).get(k) we put an\n     * n-pointed polygon with the given center and start vertex.  The inner radius is\n     * (numIRLevels-1-s)/numIRLevels.  The hole size is k/numHoleSizeLevels.\n     * If k == 0, there is no hole.\n     *\n     * Note that n ranges between minNumPoints and maxNumPoints, s between 0 and numIRLevels-1\n     * and k between 0 and numHoleSizeLevels-1.  So, the hole size and inner radius must\n     * both be less than 1, and the inner radius must be greater than zero.  The hole size\n     * can be zero.\n     *\n     * @return\n     */\n    private static List<List<List<GeographyValue>>> makeStarPolygons(GeographyPointValue firstCenter,\n                                                                     GeographyPointValue firstFirstVertex,\n                                                                     int minNumPoints,\n                                                                     int maxNumPoints,\n                                                                     int numIRLevels,\n                                                                     int numHoleSizeLevels,\n                                                                     double xmul,\n                                                                     double ymul) {\n        List<List<List<GeographyValue>>> answer = new ArrayList<List<List<GeographyValue>>>();\n        int npoints = maxNumPoints - minNumPoints + 1;\n        for (int idx = 0; idx < npoints; idx += 1) {\n            GeographyPointValue column = x.mul(xmul*idx);\n            List<List<GeographyValue>> oneSize = new ArrayList<List<GeographyValue>>();\n            for (int irdx = 0; irdx < numIRLevels; irdx += 1) {\n                GeographyPointValue irCenter = y.mul(numIRLevels*ymul*irdx);\n                List<GeographyValue> oneRadius = new ArrayList<GeographyValue>();\n                for (int hidx = 0; hidx < numHoleSizeLevels; hidx += 1) {\n                    GeographyPointValue hCenter = irCenter.add(y.mul(ymul*hidx));\n                    GeographyPointValue center = firstCenter.add(column.add(hCenter));\n                    GeographyPointValue firstVertex = firstFirstVertex.add(center);\n                    oneRadius.add(PolygonFactory.CreateStar(center, firstVertex, idx + minNumPoints, (irdx + 1)*0.2, hidx*0.2));\n                }\n                oneSize.add(oneRadius);\n            }\n            answer.add(oneSize);\n        }\n        return answer;\n    }","id":95112,"modified_method":"/**\n     * Create many star-like polygons.  In returnValue.get(n).get(s).get(k) we put an\n     * n-pointed polygon with the given center and start vertex.  The inner radius is\n     * (numIrLevels-s+1)/numIrLevels.  The hole size is k/numHoleSizeLevels.\n     * If k == 0, there is no hole.\n     *\n     * Note that n ranges between minNumPoints and maxNumPoints inclusive,\n     * s between 0 numIrLevels-1, k between 0 and numHoleSizeLevels-1.  Since\n     * the hole size and inner radius must both be less than 1, and the inner radius\n     * must be greater than zero.  The hole size can be zero.\n     *\n     * @return A 3-dimensional list list of polygons.\n     */\n    private static List<List<List<GeographyValue>>> makeStarPolygons(GeographyPointValue firstCenter,\n                                                                     GeographyPointValue firstFirstVertex,\n                                                                     int minNumPoints,\n                                                                     int maxNumPoints,\n                                                                     int numIRLevels,\n                                                                     int numHoleSizeLevels,\n                                                                     double xmul,\n                                                                     double ymul) {\n        List<List<List<GeographyValue>>> answer = new ArrayList<List<List<GeographyValue>>>();\n        for (int numSides = minNumPoints; numSides <= maxNumPoints; numSides += 1) {\n            int idx = numSides - minNumPoints;\n            // The x coordinate is xmul * idx\n            GeographyPointValue column = x.mul(xmul*idx);\n            List<List<GeographyValue>> oneSize = new ArrayList<List<GeographyValue>>();\n            for (int ratioLevel = 0; ratioLevel < numIRLevels; ratioLevel += 1) {\n                GeographyPointValue irCenter = column.add(y.mul(numHoleSizeLevels*ymul*ratioLevel));\n                List<GeographyValue> oneRadius = new ArrayList<GeographyValue>();\n                for (int holeNumber = 0; holeNumber < numHoleSizeLevels; holeNumber += 1) {\n                    GeographyPointValue offset = irCenter.add(y.mul(ymul*holeNumber));\n                    GeographyPointValue center = firstCenter.add(offset);\n                    GeographyPointValue firstVertex = firstFirstVertex.add(offset);\n                    oneRadius.add(PolygonFactory.CreateStar(center, firstVertex, numSides, (ratioLevel + 1.0)/numIRLevels, (holeNumber+0.0)/numHoleSizeLevels));\n                }\n                oneSize.add(oneRadius);\n            }\n            answer.add(oneSize);\n        }\n        return answer;\n    }","commit_id":"46a1ffb6f52add40978cfc3a408c8b79c6270ea2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected static Outage[] rs2Outages(ResultSet rs, boolean includesRegainedTime, boolean includesNotifications) throws SQLException {\n        Outage[] outages = null;\n        Vector vector = new Vector();\n\n        while (rs.next()) {\n            Outage outage = new Outage();\n\n            Object element = new Integer(rs.getInt(\"nodeid\"));\n            outage.nodeId = ((Integer) element).intValue();\n\n            element = rs.getString(\"ipaddr\");\n            outage.ipAddress = (String) element;\n\n            element = new Integer(rs.getInt(\"serviceid\"));\n            outage.serviceId = ((Integer) element).intValue();\n\n            element = rs.getString(\"nodeLabel\");\n            outage.nodeLabel = (String) element;\n\n            element = rs.getString(\"iphostname\");\n            outage.hostname = (String) element;\n\n            element = rs.getString(\"servicename\");\n            outage.serviceName = (String) element;\n\n            outage.outageId = rs.getInt(\"outageid\");\n\n            element = rs.getTimestamp(\"iflostservice\");\n            if (element != null) {\n                outage.lostServiceTime = new Date(((Timestamp) element).getTime());\n            }\n\n            if (includesRegainedTime) {\n                element = rs.getTimestamp(\"ifregainedservice\");\n                if (element != null) {\n                    outage.regainedServiceTime = new Date(((Timestamp) element).getTime());\n                }\n            }\n\n            if (includesNotifications) {\n                int intElement = rs.getInt(\"svclosteventid\");\n                if (intElement != 0) {\n                    outage.lostServiceEventId = new Integer(intElement);\n                }\n\n                intElement = rs.getInt(\"notifyid\");\n                if (intElement != 0) {\n                    outage.lostServiceNotificationId = new Integer(intElement);\n                }\n\n                element = rs.getString(\"answeredby\");\n                outage.lostServiceNotificationAcknowledgedBy = (String) element;\n\n            }\n\n            vector.addElement(outage);\n        }\n\n        outages = (Outage[]) vector.toArray(new Outage[vector.size()]);\n\n        return outages;\n    }","id":95113,"modified_method":"protected static Outage[] rs2Outages(ResultSet rs, boolean includesRegainedTime, boolean includesNotifications) throws SQLException {\n        Outage[] outages = null;\n        List<Outage> list = new ArrayList<Outage>();\n\n        while (rs.next()) {\n            Outage outage = new Outage();\n\n            outage.nodeId = rs.getInt(\"nodeid\");\n            \n            outage.ipAddress = rs.getString(\"ipaddr\");\n\n            outage.serviceId = rs.getInt(\"serviceid\");\n\n            outage.nodeLabel = rs.getString(\"nodeLabel\");\n\n            outage.hostname = rs.getString(\"iphostname\");\n\n            outage.serviceName = rs.getString(\"servicename\");\n\n            outage.outageId = rs.getInt(\"outageid\");\n\n            Timestamp lostService = rs.getTimestamp(\"iflostservice\");\n            if (!rs.wasNull()) {\n                outage.lostServiceTime = new Date(lostService.getTime());\n            }\n\n            if (includesRegainedTime) {\n                Timestamp regainedService = rs.getTimestamp(\"iflostservice\");\n                if (!rs.wasNull()) {\n                    outage.regainedServiceTime = new Date(regainedService.getTime());\n                }\n            }\n\n            if (includesNotifications) {\n                int serviceLostEventId = rs.getInt(\"svclosteventid\");\n                if (!rs.wasNull()) {\n                    outage.lostServiceEventId = new Integer(serviceLostEventId);\n                }\n\n                int notifyId = rs.getInt(\"notifyid\");\n                if (!rs.wasNull()) {\n                    outage.lostServiceNotificationId = new Integer(notifyId);\n                }\n\n                outage.lostServiceNotificationAcknowledgedBy = rs.getString(\"answeredby\");\n            }\n\n            list.add(outage);\n        }\n\n        outages = list.toArray(new Outage[list.size()]);\n\n        return outages;\n    }","commit_id":"981e8c7fc97e065541ea9571fe9917615a84a598","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest. This is a clone of\n     * getCurrentOutageSummaries for Harrah's (special consideration).\n     */\n    public OutageSummary[] getCurrentSDSOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel from outages, node, ipinterface, ifservices, assets \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"and assets.nodeid=node.nodeid and assets.displaycategory != 'SDS-A-Side' and assets.displaycategory != 'SDS-B-Side' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            ArrayList list = new ArrayList();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = (OutageSummary[]) list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","id":95114,"modified_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest. This is a clone of\n     * getCurrentOutageSummaries for Harrah's (special consideration).\n     */\n    public OutageSummary[] getCurrentSDSOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel from outages, node, ipinterface, ifservices, assets \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"and assets.nodeid=node.nodeid and assets.displaycategory != 'SDS-A-Side' and assets.displaycategory != 'SDS-B-Side' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            List<OutageSummary> list = new ArrayList<OutageSummary>();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","commit_id":"981e8c7fc97e065541ea9571fe9917615a84a598","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest.\n     */\n    public OutageSummary[] getCurrentOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel \" + \"from outages, node, ipinterface, ifservices \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            ArrayList list = new ArrayList();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = (OutageSummary[]) list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","id":95115,"modified_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest.\n     */\n    public OutageSummary[] getCurrentOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel \" + \"from outages, node, ipinterface, ifservices \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            List<OutageSummary> list = new ArrayList<OutageSummary>();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","commit_id":"981e8c7fc97e065541ea9571fe9917615a84a598","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection<Integer> getCurrentOutagesIdsForNode(int nodeId) throws SQLException {\n        LinkedList<Integer> outageIds = new LinkedList<Integer>();\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT outageid from outages where nodeid=?  and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            stmt.setInt(1, nodeId);\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                outageIds.add(rs.getInt(1));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return outageIds;\n    }","id":95116,"modified_method":"public Collection<Integer> getCurrentOutagesIdsForNode(int nodeId) throws SQLException {\n        List<Integer> outageIds = new ArrayList<Integer>();\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT outageid from outages where nodeid=?  and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            stmt.setInt(1, nodeId);\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                outageIds.add(rs.getInt(1));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return outageIds;\n    }","commit_id":"981e8c7fc97e065541ea9571fe9917615a84a598","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Node[] filterNodesWithCurrentOutages(Node[] nodes) throws SQLException {\n        HashMap<Integer, Node> nodeMap = new HashMap<Integer, Node>(nodes.length);\n        for (Node n : nodes) {\n            nodeMap.put(n.getNodeId(), n);\n        }\n        \n        String nodeList = StringUtils.collectionToDelimitedString(nodeMap.keySet(), \", \");\n        \n        LinkedList<Node> newNodes = new LinkedList<Node>();\n        \n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT nodeid from outages where nodeid in ( \" + nodeList + \" ) and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                newNodes.add(nodeMap.get(rs.getInt(1)));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return newNodes.toArray(new Node[0]);\n    }","id":95117,"modified_method":"public Node[] filterNodesWithCurrentOutages(Node[] nodes) throws SQLException {\n        HashMap<Integer, Node> nodeMap = new HashMap<Integer, Node>(nodes.length);\n        for (Node n : nodes) {\n            nodeMap.put(n.getNodeId(), n);\n        }\n        \n        String nodeList = StringUtils.collectionToDelimitedString(nodeMap.keySet(), \", \");\n        \n        List<Node> newNodes = new ArrayList<Node>();\n        \n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT nodeid from outages where nodeid in ( \" + nodeList + \" ) and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                newNodes.add(nodeMap.get(rs.getInt(1)));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return newNodes.toArray(new Node[newNodes.size()]);\n    }","commit_id":"981e8c7fc97e065541ea9571fe9917615a84a598","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Node[] filterNodesWithCurrentOutages(Node[] nodes) throws SQLException {\n        HashMap<Integer, Node> nodeMap = new HashMap<Integer, Node>(nodes.length);\n        for (Node n : nodes) {\n            nodeMap.put(n.getNodeId(), n);\n        }\n        \n        String nodeList = StringUtils.collectionToDelimitedString(nodeMap.keySet(), \", \");\n        \n        LinkedList<Node> newNodes = new LinkedList<Node>();\n        \n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT nodeid from outages where nodeid in ( \" + nodeList + \" ) and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                newNodes.add(nodeMap.get(rs.getInt(1)));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return newNodes.toArray(new Node[0]);\n    }","id":95118,"modified_method":"public Node[] filterNodesWithCurrentOutages(Node[] nodes) throws SQLException {\n        HashMap<Integer, Node> nodeMap = new HashMap<Integer, Node>(nodes.length);\n        for (Node n : nodes) {\n            nodeMap.put(n.getNodeId(), n);\n        }\n        \n        String nodeList = StringUtils.collectionToDelimitedString(nodeMap.keySet(), \", \");\n        \n        List<Node> newNodes = new ArrayList<Node>();\n        \n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT nodeid from outages where nodeid in ( \" + nodeList + \" ) and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                newNodes.add(nodeMap.get(rs.getInt(1)));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return newNodes.toArray(new Node[newNodes.size()]);\n    }","commit_id":"6dabef664b9d92d68f6d920c7191695845e0612f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest. This is a clone of\n     * getCurrentOutageSummaries for Harrah's (special consideration).\n     */\n    public OutageSummary[] getCurrentSDSOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel from outages, node, ipinterface, ifservices, assets \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"and assets.nodeid=node.nodeid and assets.displaycategory != 'SDS-A-Side' and assets.displaycategory != 'SDS-B-Side' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            ArrayList list = new ArrayList();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = (OutageSummary[]) list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","id":95119,"modified_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest. This is a clone of\n     * getCurrentOutageSummaries for Harrah's (special consideration).\n     */\n    public OutageSummary[] getCurrentSDSOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel from outages, node, ipinterface, ifservices, assets \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"and assets.nodeid=node.nodeid and assets.displaycategory != 'SDS-A-Side' and assets.displaycategory != 'SDS-B-Side' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            List<OutageSummary> list = new ArrayList<OutageSummary>();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","commit_id":"6dabef664b9d92d68f6d920c7191695845e0612f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection<Integer> getCurrentOutagesIdsForNode(int nodeId) throws SQLException {\n        LinkedList<Integer> outageIds = new LinkedList<Integer>();\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT outageid from outages where nodeid=?  and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            stmt.setInt(1, nodeId);\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                outageIds.add(rs.getInt(1));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return outageIds;\n    }","id":95120,"modified_method":"public Collection<Integer> getCurrentOutagesIdsForNode(int nodeId) throws SQLException {\n        List<Integer> outageIds = new ArrayList<Integer>();\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT outageid from outages where nodeid=?  and ifregainedservice is null and suppresstime is null or suppresstime < now();\");\n            stmt.setInt(1, nodeId);\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                outageIds.add(rs.getInt(1));\n            }\n\n            rs.close();\n            stmt.close();\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return outageIds;\n    }","commit_id":"6dabef664b9d92d68f6d920c7191695845e0612f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected static Outage[] rs2Outages(ResultSet rs, boolean includesRegainedTime, boolean includesNotifications) throws SQLException {\n        Outage[] outages = null;\n        Vector vector = new Vector();\n\n        while (rs.next()) {\n            Outage outage = new Outage();\n\n            Object element = new Integer(rs.getInt(\"nodeid\"));\n            outage.nodeId = ((Integer) element).intValue();\n\n            element = rs.getString(\"ipaddr\");\n            outage.ipAddress = (String) element;\n\n            element = new Integer(rs.getInt(\"serviceid\"));\n            outage.serviceId = ((Integer) element).intValue();\n\n            element = rs.getString(\"nodeLabel\");\n            outage.nodeLabel = (String) element;\n\n            element = rs.getString(\"iphostname\");\n            outage.hostname = (String) element;\n\n            element = rs.getString(\"servicename\");\n            outage.serviceName = (String) element;\n\n            outage.outageId = rs.getInt(\"outageid\");\n\n            element = rs.getTimestamp(\"iflostservice\");\n            if (element != null) {\n                outage.lostServiceTime = new Date(((Timestamp) element).getTime());\n            }\n\n            if (includesRegainedTime) {\n                element = rs.getTimestamp(\"ifregainedservice\");\n                if (element != null) {\n                    outage.regainedServiceTime = new Date(((Timestamp) element).getTime());\n                }\n            }\n\n            if (includesNotifications) {\n                int intElement = rs.getInt(\"svclosteventid\");\n                if (intElement != 0) {\n                    outage.lostServiceEventId = new Integer(intElement);\n                }\n\n                intElement = rs.getInt(\"notifyid\");\n                if (intElement != 0) {\n                    outage.lostServiceNotificationId = new Integer(intElement);\n                }\n\n                element = rs.getString(\"answeredby\");\n                outage.lostServiceNotificationAcknowledgedBy = (String) element;\n\n            }\n\n            vector.addElement(outage);\n        }\n\n        outages = (Outage[]) vector.toArray(new Outage[vector.size()]);\n\n        return outages;\n    }","id":95121,"modified_method":"protected static Outage[] rs2Outages(ResultSet rs, boolean includesRegainedTime, boolean includesNotifications) throws SQLException {\n        Outage[] outages = null;\n        List<Outage> list = new ArrayList<Outage>();\n\n        while (rs.next()) {\n            Outage outage = new Outage();\n\n            outage.nodeId = rs.getInt(\"nodeid\");\n            \n            outage.ipAddress = rs.getString(\"ipaddr\");\n\n            outage.serviceId = rs.getInt(\"serviceid\");\n\n            outage.nodeLabel = rs.getString(\"nodeLabel\");\n\n            outage.hostname = rs.getString(\"iphostname\");\n\n            outage.serviceName = rs.getString(\"servicename\");\n\n            outage.outageId = rs.getInt(\"outageid\");\n\n            Timestamp lostService = rs.getTimestamp(\"iflostservice\");\n            if (!rs.wasNull()) {\n                outage.lostServiceTime = new Date(lostService.getTime());\n            }\n\n            if (includesRegainedTime) {\n                Timestamp regainedService = rs.getTimestamp(\"iflostservice\");\n                if (!rs.wasNull()) {\n                    outage.regainedServiceTime = new Date(regainedService.getTime());\n                }\n            }\n\n            if (includesNotifications) {\n                int serviceLostEventId = rs.getInt(\"svclosteventid\");\n                if (!rs.wasNull()) {\n                    outage.lostServiceEventId = new Integer(serviceLostEventId);\n                }\n\n                int notifyId = rs.getInt(\"notifyid\");\n                if (!rs.wasNull()) {\n                    outage.lostServiceNotificationId = new Integer(notifyId);\n                }\n\n                outage.lostServiceNotificationAcknowledgedBy = rs.getString(\"answeredby\");\n            }\n\n            list.add(outage);\n        }\n\n        outages = list.toArray(new Outage[list.size()]);\n\n        return outages;\n    }","commit_id":"6dabef664b9d92d68f6d920c7191695845e0612f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest.\n     */\n    public OutageSummary[] getCurrentOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel \" + \"from outages, node, ipinterface, ifservices \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            ArrayList list = new ArrayList();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = (OutageSummary[]) list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","id":95122,"modified_method":"/**\n     * Return a list of IP addresses, the number of services down on each IP\n     * address, and the longest time a service has been down for each IP\n     * address. The list will be sorted in ascending order from the service down\n     * longest to the service down shortest.\n     */\n    public OutageSummary[] getCurrentOutageSummaries() throws SQLException {\n        OutageSummary[] summaries = new OutageSummary[0];\n        Connection conn = Vault.getDbConnection();\n\n        try {\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"select distinct outages.nodeid, max(outages.iflostservice) as timeDown, node.nodelabel \" + \"from outages, node, ipinterface, ifservices \" + \"where ifregainedservice is null \" + \"and node.nodeid=outages.nodeid and ipinterface.nodeid = outages.nodeid and ifservices.nodeid=outages.nodeid \" + \"and ipinterface.ipaddr = outages.ipaddr and ifservices.ipaddr = outages.ipaddr \" + \"and ifservices.serviceid = outages.serviceid \" + \"and node.nodeType != 'D' and ipinterface.ismanaged != 'D' and ifservices.status != 'D' \" + \"group by outages.nodeid, node.nodelabel \" + \"order by timeDown desc;\");\n\n            List<OutageSummary> list = new ArrayList<OutageSummary>();\n\n            while (rs.next()) {\n                int nodeId = rs.getInt(\"nodeID\");\n                Timestamp timeDownTS = rs.getTimestamp(\"timeDown\");\n                long timeDown = timeDownTS.getTime();\n                Date downDate = new Date(timeDown);\n                String nodeLabel = rs.getString(\"nodelabel\");\n\n                list.add(new OutageSummary(nodeId, nodeLabel, downDate));\n            }\n\n            rs.close();\n            stmt.close();\n\n            summaries = list.toArray(new OutageSummary[list.size()]);\n        } finally {\n            Vault.releaseDbConnection(conn);\n        }\n\n        return summaries;\n    }","commit_id":"6dabef664b9d92d68f6d920c7191695845e0612f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public PeerNode[] getAnonSetupPeerNodes() {\n\t\tVector v = new Vector();\n\t\tPeerNode[] peers = node.peers.myPeers;\n\t\tfor(int i=0;i<peers.length;i++) {\n\t\t\tPeerNode pn = peers[i];\n\t\t\tif(pn.handshakeUnknownInitiator() && pn.getOutgoingMangler() == packetMangler)\n\t\t\t\tv.add(pn);\n\t\t}\n\t\treturn (PeerNode[]) v.toArray(new PeerNode[v.size()]);\n\t}","id":95123,"modified_method":"public PeerNode[] getAnonSetupPeerNodes() {\n\t\tArrayList<PeerNode> v = new ArrayList<PeerNode>();\n\t\tPeerNode[] peers = node.peers.myPeers;\n\t\tfor(int i=0;i<peers.length;i++) {\n\t\t\tPeerNode pn = peers[i];\n\t\t\tif(pn.handshakeUnknownInitiator() && pn.getOutgoingMangler() == packetMangler)\n\t\t\t\tv.add(pn);\n\t\t}\n\t\treturn v.toArray(new PeerNode[v.size()]);\n\t}","commit_id":"d14bb653ce6f2727337926c8f6986eb758a0c7d5","url":"https://github.com/freenet/fred"},{"original_method":"public UpdateOverMandatoryManager(NodeUpdateManager manager) {\n\t\tthis.updateManager = manager;\n\t\tnodesSayKeyRevoked = new HashSet();\n\t\tnodesSayKeyRevokedFailedTransfer = new HashSet();\n\t\tnodesOfferedMainJar = new HashSet();\n\t\tnodesAskedSendMainJar = new HashSet();\n\t\tnodesSendingMainJar = new HashSet();\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t}","id":95124,"modified_method":"public UpdateOverMandatoryManager(NodeUpdateManager manager) {\n\t\tthis.updateManager = manager;\n\t\tnodesSayKeyRevoked = new HashSet<PeerNode>();\n\t\tnodesSayKeyRevokedFailedTransfer = new HashSet<PeerNode>();\n\t\tnodesOfferedMainJar = new HashSet<PeerNode>();\n\t\tnodesAskedSendMainJar = new HashSet<PeerNode>();\n\t\tnodesSendingMainJar = new HashSet<PeerNode>();\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t}","commit_id":"90bf361bc0fef7a1d7885ec6e798a259127118e3","url":"https://github.com/freenet/fred"},{"original_method":"public PeerNode[][] getNodesSayBlown() {\n\t\tVector nodesConnectedSayRevoked = new Vector();\n\t\tVector nodesDisconnectedSayRevoked = new Vector();\n\t\tVector nodesFailedSayRevoked = new Vector();\n\t\tsynchronized(this) {\n\t\t\tPeerNode[] nodesSayRevoked = (PeerNode[]) nodesSayKeyRevoked.toArray(new PeerNode[nodesSayKeyRevoked.size()]);\n\t\t\tfor(int i=0;i<nodesSayRevoked.length;i++) {\n\t\t\t\tPeerNode pn = nodesSayRevoked[i];\n\t\t\t\tif(nodesSayKeyRevokedFailedTransfer.contains(pn))\n\t\t\t\t\tnodesFailedSayRevoked.add(pn);\n\t\t\t\telse\n\t\t\t\t\tnodesConnectedSayRevoked.add(pn);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<nodesConnectedSayRevoked.size();i++) {\n\t\t\tPeerNode pn = (PeerNode) nodesConnectedSayRevoked.get(i);\n\t\t\tif(!pn.isConnected()) {\n\t\t\t\tnodesDisconnectedSayRevoked.add(pn);\n\t\t\t\tnodesConnectedSayRevoked.remove(i);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn new PeerNode[][] {\n\t\t\t\t(PeerNode[]) nodesConnectedSayRevoked.toArray(new PeerNode[nodesConnectedSayRevoked.size()]),\n\t\t\t\t(PeerNode[]) nodesDisconnectedSayRevoked.toArray(new PeerNode[nodesDisconnectedSayRevoked.size()]),\n\t\t\t\t(PeerNode[]) nodesFailedSayRevoked.toArray(new PeerNode[nodesFailedSayRevoked.size()]),\n\t\t};\n\t}","id":95125,"modified_method":"public PeerNode[][] getNodesSayBlown() {\n\t\tVector<PeerNode> nodesConnectedSayRevoked = new Vector<PeerNode>();\n\t\tVector<PeerNode> nodesDisconnectedSayRevoked = new Vector<PeerNode>();\n\t\tVector<PeerNode> nodesFailedSayRevoked = new Vector<PeerNode>();\n\t\tsynchronized(this) {\n\t\t\tPeerNode[] nodesSayRevoked = nodesSayKeyRevoked.toArray(new PeerNode[nodesSayKeyRevoked.size()]);\n\t\t\tfor(int i=0;i<nodesSayRevoked.length;i++) {\n\t\t\t\tPeerNode pn = nodesSayRevoked[i];\n\t\t\t\tif(nodesSayKeyRevokedFailedTransfer.contains(pn))\n\t\t\t\t\tnodesFailedSayRevoked.add(pn);\n\t\t\t\telse\n\t\t\t\t\tnodesConnectedSayRevoked.add(pn);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<nodesConnectedSayRevoked.size();i++) {\n\t\t\tPeerNode pn = nodesConnectedSayRevoked.get(i);\n\t\t\tif(!pn.isConnected()) {\n\t\t\t\tnodesDisconnectedSayRevoked.add(pn);\n\t\t\t\tnodesConnectedSayRevoked.remove(i);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn new PeerNode[][] {\n\t\t\t\tnodesConnectedSayRevoked.toArray(new PeerNode[nodesConnectedSayRevoked.size()]),\n\t\t        nodesDisconnectedSayRevoked.toArray(new PeerNode[nodesDisconnectedSayRevoked.size()]),\n\t\t        nodesFailedSayRevoked.toArray(new PeerNode[nodesFailedSayRevoked.size()]),\n\t\t};\n\t}","commit_id":"90bf361bc0fef7a1d7885ec6e798a259127118e3","url":"https://github.com/freenet/fred"},{"original_method":"protected void maybeRequestMainJar() {\n\t\t\tPeerNode[] offers;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(nodesAskedSendMainJar.size() + nodesSendingMainJar.size() \n\t\t\t\t\t\t>= MAX_NODES_SENDING_MAIN_JAR)\n\t\t\t\t\treturn;\n\t\t\t\tif(nodesOfferedMainJar.isEmpty()) return;\n\t\t\t\toffers = (PeerNode[]) nodesOfferedMainJar.toArray(new PeerNode[nodesOfferedMainJar.size()]);\n\t\t\t}\n\t\t\tfor(int i=0;i<offers.length;i++) {\n\t\t\t\tif(offers[i].isConnected()) continue;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tif(nodesAskedSendMainJar.size() + nodesSendingMainJar.size() \n\t\t\t\t\t\t\t>= MAX_NODES_SENDING_MAIN_JAR)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif(nodesSendingMainJar.contains(offers[i])) continue;\n\t\t\t\t}\n\t\t\t\tsendUOMRequestMain(offers[i], false);\n\t\t\t}\n\t}","id":95126,"modified_method":"protected void maybeRequestMainJar() {\n\t\t\tPeerNode[] offers;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(nodesAskedSendMainJar.size() + nodesSendingMainJar.size() \n\t\t\t\t\t\t>= MAX_NODES_SENDING_MAIN_JAR)\n\t\t\t\t\treturn;\n\t\t\t\tif(nodesOfferedMainJar.isEmpty()) return;\n\t\t\t\toffers = nodesOfferedMainJar.toArray(new PeerNode[nodesOfferedMainJar.size()]);\n\t\t\t}\n\t\t\tfor(int i=0;i<offers.length;i++) {\n\t\t\t\tif(offers[i].isConnected()) continue;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tif(nodesAskedSendMainJar.size() + nodesSendingMainJar.size() \n\t\t\t\t\t\t\t>= MAX_NODES_SENDING_MAIN_JAR)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif(nodesSendingMainJar.contains(offers[i])) continue;\n\t\t\t\t}\n\t\t\t\tsendUOMRequestMain(offers[i], false);\n\t\t\t}\n\t}","commit_id":"90bf361bc0fef7a1d7885ec6e798a259127118e3","url":"https://github.com/freenet/fred"},{"original_method":"public DefaultClassDirectoryBinarySpec(String name, JavaToolChain toolChain) {\n        this.name = name;\n        this.toolChain = toolChain;\n        this.namingScheme = new ClassDirectoryBinaryNamingScheme(removeClassesSuffix(name));\n    }","id":95127,"modified_method":"public DefaultClassDirectoryBinarySpec(String name, JavaToolChain toolChain, JvmPlatform platform) {\n        this.name = name;\n        this.toolChain = toolChain;\n        this.platform = platform;\n        this.namingScheme = new ClassDirectoryBinaryNamingScheme(removeClassesSuffix(name));\n    }","commit_id":"6839863cadac0553923092e035270f160b20b0b5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultJarBinarySpec(JvmLibrarySpec library, BinaryNamingScheme namingScheme, JavaToolChain toolChain) {\n        this.library = library;\n        this.namingScheme = namingScheme;\n        this.toolChain = toolChain;\n    }","id":95128,"modified_method":"public DefaultJarBinarySpec(JvmLibrarySpec library, BinaryNamingScheme namingScheme, JavaToolChain toolChain, JvmPlatform platform) {\n        this.library = library;\n        this.namingScheme = namingScheme;\n        this.toolChain = toolChain;\n        this.platform = platform;\n    }","commit_id":"6839863cadac0553923092e035270f160b20b0b5","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureCompileDefaults(final Project project, final JavaPluginConvention javaConvention) {\n        project.getTasks().withType(AbstractCompile.class, new Action<AbstractCompile>() {\n            public void execute(final AbstractCompile compile) {\n                ConventionMapping conventionMapping = compile.getConventionMapping();\n                conventionMapping.map(\"sourceCompatibility\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        return javaConvention.getSourceCompatibility().toString();\n                    }\n                });\n                conventionMapping.map(\"targetCompatibility\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        return javaConvention.getTargetCompatibility().toString();\n                    }\n                });\n            }\n        });\n        project.getTasks().withType(JavaCompile.class, new Action<JavaCompile>() {\n            public void execute(final JavaCompile compile) {\n                ConventionMapping conventionMapping = compile.getConventionMapping();\n                conventionMapping.map(\"targetPlatform\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        return new DefaultJvmPlatform(javaConvention.getTargetCompatibility());\n                    }\n                });\n                conventionMapping.map(\"dependencyCacheDir\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        return javaConvention.getDependencyCacheDir();\n                    }\n                });\n            }\n        });\n    }","id":95129,"modified_method":"private void configureCompileDefaults(final Project project, final JavaPluginConvention javaConvention) {\n        project.getTasks().withType(AbstractCompile.class, new Action<AbstractCompile>() {\n            public void execute(final AbstractCompile compile) {\n                ConventionMapping conventionMapping = compile.getConventionMapping();\n                conventionMapping.map(\"sourceCompatibility\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        return javaConvention.getSourceCompatibility().toString();\n                    }\n                });\n                conventionMapping.map(\"targetCompatibility\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        return javaConvention.getTargetCompatibility().toString();\n                    }\n                });\n            }\n        });\n        project.getTasks().withType(JavaCompile.class, new Action<JavaCompile>() {\n            public void execute(final JavaCompile compile) {\n                ConventionMapping conventionMapping = compile.getConventionMapping();\n                conventionMapping.map(\"dependencyCacheDir\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        return javaConvention.getDependencyCacheDir();\n                    }\n                });\n            }\n        });\n    }","commit_id":"6839863cadac0553923092e035270f160b20b0b5","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureSourceSetDefaults(final JavaPluginConvention pluginConvention) {\n        final Project project = pluginConvention.getProject();\n        final ProjectSourceSet projectSourceSet = project.getExtensions().getByType(ProjectSourceSet.class);\n\n        pluginConvention.getSourceSets().all(new Action<SourceSet>() {\n            public void execute(final SourceSet sourceSet) {\n                ConventionMapping outputConventionMapping = ((IConventionAware) sourceSet.getOutput()).getConventionMapping();\n\n                ConfigurationContainer configurations = project.getConfigurations();\n\n                Configuration compileConfiguration = configurations.findByName(sourceSet.getCompileConfigurationName());\n                if (compileConfiguration == null) {\n                    compileConfiguration = configurations.create(sourceSet.getCompileConfigurationName());\n                }\n                compileConfiguration.setVisible(false);\n                compileConfiguration.setDescription(String.format(\"Compile classpath for %s.\", sourceSet));\n\n                Configuration runtimeConfiguration = configurations.findByName(sourceSet.getRuntimeConfigurationName());\n                if (runtimeConfiguration == null) {\n                    runtimeConfiguration = configurations.create(sourceSet.getRuntimeConfigurationName());\n                }\n                runtimeConfiguration.setVisible(false);\n                runtimeConfiguration.extendsFrom(compileConfiguration);\n                runtimeConfiguration.setDescription(String.format(\"Runtime classpath for %s.\", sourceSet));\n\n                sourceSet.setCompileClasspath(compileConfiguration);\n                sourceSet.setRuntimeClasspath(sourceSet.getOutput().plus(runtimeConfiguration));\n\n                outputConventionMapping.map(\"classesDir\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        String classesDirName = String.format(\"classes/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n                outputConventionMapping.map(\"resourcesDir\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        String classesDirName = String.format(\"resources/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n\n                sourceSet.getJava().srcDir(String.format(\"src/%s/java\", sourceSet.getName()));\n                sourceSet.getResources().srcDir(String.format(\"src/%s/resources\", sourceSet.getName()));\n                sourceSet.compiledBy(sourceSet.getClassesTaskName());\n\n                FunctionalSourceSet functionalSourceSet = projectSourceSet.create(sourceSet.getName());\n                Classpath compileClasspath = new SourceSetCompileClasspath(sourceSet);\n                DefaultJavaSourceSet javaSourceSet = instantiator.newInstance(DefaultJavaSourceSet.class, \"java\", sourceSet.getJava(), compileClasspath, functionalSourceSet);\n                functionalSourceSet.add(javaSourceSet);\n                ResourceSet resourceSet = instantiator.newInstance(DefaultResourceSet.class, \"resources\", sourceSet.getResources(), functionalSourceSet);\n                functionalSourceSet.add(resourceSet);\n\n                BinaryContainer binaryContainer = project.getExtensions().getByType(BinaryContainer.class);\n                ClassDirectoryBinarySpec binary = binaryContainer.create(String.format(\"%sClasses\", sourceSet.getName()), ClassDirectoryBinarySpec.class);\n                ConventionMapping conventionMapping = new DslObject(binary).getConventionMapping();\n                conventionMapping.map(\"classesDir\", new Callable<File>() {\n                    public File call() throws Exception {\n                        return sourceSet.getOutput().getClassesDir();\n                    }\n                });\n                conventionMapping.map(\"resourcesDir\", new Callable<File>() {\n                    public File call() throws Exception {\n                        return sourceSet.getOutput().getResourcesDir();\n                    }\n                });\n                binary.setTargetPlatform(new DefaultJvmPlatform(JavaVersion.current()));\n\n                binary.getSource().add(javaSourceSet);\n                binary.getSource().add(resourceSet);\n\n                binary.builtBy(sourceSet.getOutput().getDirs());\n            }\n        });\n    }","id":95130,"modified_method":"private void configureSourceSetDefaults(final JavaPluginConvention pluginConvention) {\n        final Project project = pluginConvention.getProject();\n        final ProjectSourceSet projectSourceSet = project.getExtensions().getByType(ProjectSourceSet.class);\n\n        pluginConvention.getSourceSets().all(new Action<SourceSet>() {\n            public void execute(final SourceSet sourceSet) {\n                ConventionMapping outputConventionMapping = ((IConventionAware) sourceSet.getOutput()).getConventionMapping();\n\n                ConfigurationContainer configurations = project.getConfigurations();\n\n                Configuration compileConfiguration = configurations.findByName(sourceSet.getCompileConfigurationName());\n                if (compileConfiguration == null) {\n                    compileConfiguration = configurations.create(sourceSet.getCompileConfigurationName());\n                }\n                compileConfiguration.setVisible(false);\n                compileConfiguration.setDescription(String.format(\"Compile classpath for %s.\", sourceSet));\n\n                Configuration runtimeConfiguration = configurations.findByName(sourceSet.getRuntimeConfigurationName());\n                if (runtimeConfiguration == null) {\n                    runtimeConfiguration = configurations.create(sourceSet.getRuntimeConfigurationName());\n                }\n                runtimeConfiguration.setVisible(false);\n                runtimeConfiguration.extendsFrom(compileConfiguration);\n                runtimeConfiguration.setDescription(String.format(\"Runtime classpath for %s.\", sourceSet));\n\n                sourceSet.setCompileClasspath(compileConfiguration);\n                sourceSet.setRuntimeClasspath(sourceSet.getOutput().plus(runtimeConfiguration));\n\n                outputConventionMapping.map(\"classesDir\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        String classesDirName = String.format(\"classes/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n                outputConventionMapping.map(\"resourcesDir\", new Callable<Object>() {\n                    public Object call() throws Exception {\n                        String classesDirName = String.format(\"resources/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n\n                sourceSet.getJava().srcDir(String.format(\"src/%s/java\", sourceSet.getName()));\n                sourceSet.getResources().srcDir(String.format(\"src/%s/resources\", sourceSet.getName()));\n                sourceSet.compiledBy(sourceSet.getClassesTaskName());\n\n                FunctionalSourceSet functionalSourceSet = projectSourceSet.create(sourceSet.getName());\n                Classpath compileClasspath = new SourceSetCompileClasspath(sourceSet);\n                DefaultJavaSourceSet javaSourceSet = instantiator.newInstance(DefaultJavaSourceSet.class, \"java\", sourceSet.getJava(), compileClasspath, functionalSourceSet);\n                functionalSourceSet.add(javaSourceSet);\n                ResourceSet resourceSet = instantiator.newInstance(DefaultResourceSet.class, \"resources\", sourceSet.getResources(), functionalSourceSet);\n                functionalSourceSet.add(resourceSet);\n\n                BinaryContainer binaryContainer = project.getExtensions().getByType(BinaryContainer.class);\n                ClassDirectoryBinarySpec binary = binaryContainer.create(String.format(\"%sClasses\", sourceSet.getName()), ClassDirectoryBinarySpec.class);\n                ConventionMapping conventionMapping = new DslObject(binary).getConventionMapping();\n                conventionMapping.map(\"classesDir\", new Callable<File>() {\n                    public File call() throws Exception {\n                        return sourceSet.getOutput().getClassesDir();\n                    }\n                });\n                conventionMapping.map(\"resourcesDir\", new Callable<File>() {\n                    public File call() throws Exception {\n                        return sourceSet.getOutput().getResourcesDir();\n                    }\n                });\n\n                binary.getSource().add(javaSourceSet);\n                binary.getSource().add(resourceSet);\n\n                binary.builtBy(sourceSet.getOutput().getDirs());\n            }\n        });\n    }","commit_id":"6839863cadac0553923092e035270f160b20b0b5","url":"https://github.com/gradle/gradle"},{"original_method":"private DefaultJavaCompileSpec createSpec() {\n        DefaultJavaCompileSpec spec = new DefaultJavaCompileSpec();\n        spec.setSource(getSource());\n        spec.setDestinationDir(getDestinationDir());\n        spec.setWorkingDir(getProject().getProjectDir());\n        spec.setTempDir(getTemporaryDir());\n        spec.setClasspath(getClasspath());\n        spec.setDependencyCacheDir(getDependencyCacheDir());\n        final String targetCompatibility;\n        final String sourceCompatibility;\n        //TODO: freekh This is not right I know. If I do not do this though, we will have to change the way JavaCompile is used from the end-user perspective. Or, we can inject a platform (so a platform is never null). I am uncertain about what we want to inject or not. A platform is something the user decides which is why it felt wrong to inject it, asked around but Daz is the one that should be able to answer that question. In any case the targetCompatibility must be possible to use?\n        if (getTargetPlatform() != null) {\n            targetCompatibility = getTargetPlatform().getTargetCompatibility().toString();\n            if (getSourceCompatibility() != null) { //do not overwrite source compatibility before we find a way to support it\n                sourceCompatibility = getSourceCompatibility();\n            } else {\n                sourceCompatibility = targetCompatibility;\n            }\n        } else {\n            targetCompatibility = getTargetCompatibility();\n            sourceCompatibility = getSourceCompatibility();\n        }\n\n        spec.setTargetCompatibility(targetCompatibility);\n        spec.setSourceCompatibility(sourceCompatibility);\n        spec.setCompileOptions(compileOptions);\n        return spec;\n    }","id":95131,"modified_method":"private DefaultJavaCompileSpec createSpec() {\n        DefaultJavaCompileSpec spec = new DefaultJavaCompileSpec();\n        spec.setSource(getSource());\n        spec.setDestinationDir(getDestinationDir());\n        spec.setWorkingDir(getProject().getProjectDir());\n        spec.setTempDir(getTemporaryDir());\n        spec.setClasspath(getClasspath());\n        spec.setDependencyCacheDir(getDependencyCacheDir());\n        spec.setTargetCompatibility(getTargetCompatibility());\n        spec.setSourceCompatibility(getSourceCompatibility());\n        spec.setCompileOptions(compileOptions);\n        return spec;\n    }","commit_id":"6839863cadac0553923092e035270f160b20b0b5","url":"https://github.com/gradle/gradle"},{"original_method":"public SourceTransformTaskConfig getTransformTask() {\n            return new SourceTransformTaskConfig() {\n                public String getTaskPrefix() {\n                    return \"compile\";\n                }\n\n                public Class<? extends DefaultTask> getTaskType() {\n                    return JavaCompile.class;\n                }\n\n                public void configureTask(Task task, BinarySpec binarySpec, LanguageSourceSet sourceSet) {\n                    JavaCompile compile = (JavaCompile) task;\n                    JavaSourceSet javaSourceSet = (JavaSourceSet) sourceSet;\n                    JvmLibraryBinarySpec binary = (JvmLibraryBinarySpec) binarySpec;\n\n                    compile.setDescription(String.format(\"Compiles %s.\", javaSourceSet));\n                    compile.setDestinationDir(binary.getClassesDir());\n                    compile.setToolChain(binary.getToolChain());\n\n                    compile.setSource(javaSourceSet.getSource());\n                    compile.setClasspath(javaSourceSet.getCompileClasspath().getFiles());\n                    compile.setTargetPlatform(binary.getTargetPlatform());\n\n                    compile.setDependencyCacheDir(new File(compile.getProject().getBuildDir(), \"jvm-dep-cache\"));\n                    compile.dependsOn(javaSourceSet);\n                    binary.getTasks().getJar().dependsOn(compile);\n                }\n            };\n        }","id":95132,"modified_method":"public SourceTransformTaskConfig getTransformTask() {\n            return new SourceTransformTaskConfig() {\n                public String getTaskPrefix() {\n                    return \"compile\";\n                }\n\n                public Class<? extends DefaultTask> getTaskType() {\n                    return JavaCompile.class;\n                }\n\n                public void configureTask(Task task, BinarySpec binarySpec, LanguageSourceSet sourceSet) {\n                    JavaCompile compile = (JavaCompile) task;\n                    JavaSourceSet javaSourceSet = (JavaSourceSet) sourceSet;\n                    JvmLibraryBinarySpec binary = (JvmLibraryBinarySpec) binarySpec;\n\n                    compile.setDescription(String.format(\"Compiles %s.\", javaSourceSet));\n                    compile.setDestinationDir(binary.getClassesDir());\n                    compile.setToolChain(binary.getToolChain());\n\n                    compile.setSource(javaSourceSet.getSource());\n                    compile.setClasspath(javaSourceSet.getCompileClasspath().getFiles());\n                    compile.setTargetCompatibility(binary.getTargetPlatform().getTargetCompatibility().toString());\n                    compile.setSourceCompatibility(binary.getTargetPlatform().getTargetCompatibility().toString()); //TODO: freekh use an actual source compatibility\n\n                    compile.setDependencyCacheDir(new File(compile.getProject().getBuildDir(), \"jvm-dep-cache\"));\n                    compile.dependsOn(javaSourceSet);\n                    binary.getTasks().getJar().dependsOn(compile);\n                }\n            };\n        }","commit_id":"6839863cadac0553923092e035270f160b20b0b5","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(final Project target) {\n\n        target.getPlugins().apply(LanguageBasePlugin.class);\n        BinaryContainer binaryContainer = target.getExtensions().getByType(BinaryContainer.class);\n        binaryContainer.registerFactory(ClassDirectoryBinarySpec.class, new NamedDomainObjectFactory<ClassDirectoryBinarySpec>() {\n            public ClassDirectoryBinarySpec create(String name) {\n                return instantiator.newInstance(DefaultClassDirectoryBinarySpec.class, name, toolChain);\n            }\n        });\n\n        binaryContainer.withType(ClassDirectoryBinarySpecInternal.class).all(new Action<ClassDirectoryBinarySpecInternal>() {\n            public void execute(ClassDirectoryBinarySpecInternal binary) {\n                createBinaryLifecycleTask(binary, target);\n                setClassesDirConvention(binary, target);\n                createProcessResourcesTaskForBinary(binary, target);\n                createCompileJavaTaskForBinary(binary, target);\n            }\n        });\n    }","id":95133,"modified_method":"public void apply(final Project target) {\n\n        target.getPlugins().apply(LanguageBasePlugin.class);\n        BinaryContainer binaryContainer = target.getExtensions().getByType(BinaryContainer.class);\n        binaryContainer.registerFactory(ClassDirectoryBinarySpec.class, new NamedDomainObjectFactory<ClassDirectoryBinarySpec>() {\n            public ClassDirectoryBinarySpec create(String name) {\n                return instantiator.newInstance(DefaultClassDirectoryBinarySpec.class, name, toolChain, new DefaultJvmPlatform(JavaVersion.current()));\n            }\n        });\n\n        binaryContainer.withType(ClassDirectoryBinarySpecInternal.class).all(new Action<ClassDirectoryBinarySpecInternal>() {\n            public void execute(ClassDirectoryBinarySpecInternal binary) {\n                createBinaryLifecycleTask(binary, target);\n                setClassesDirConvention(binary, target);\n                createProcessResourcesTaskForBinary(binary, target);\n                createCompileJavaTaskForBinary(binary, target);\n            }\n        });\n    }","commit_id":"6839863cadac0553923092e035270f160b20b0b5","url":"https://github.com/gradle/gradle"},{"original_method":"@Test public void testDefaults() {\n        Compile compile = getCompile();\n        assertNotNull(compile.getOptions());\n        assertNotNull(compile.antCompile);\n        assertNull(compile.getDestinationDir());\n        assertNull(compile.getSourceCompatibility());\n        assertNull(compile.getTargetCompatibility());\n        assertThat(compile.getSource(), isEmpty());\n    }","id":95134,"modified_method":"@Test public void testDefaults() {\n        Compile compile = getCompile();\n        assertNotNull(compile.getJavaCompiler());\n        assertNull(compile.getDestinationDir());\n        assertNull(compile.getSourceCompatibility());\n        assertNull(compile.getTargetCompatibility());\n        assertThat(compile.getSource(), isEmpty());\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public void setAntCompile(AntJavac antCompile) {\n        this.antCompile = antCompile;\n    }","id":95135,"modified_method":"public void setJavaCompiler(JavaCompiler javaCompiler) {\n        this.javaCompiler = javaCompiler;\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public CompileOptions getOptions() {\n        return options;\n    }","id":95136,"modified_method":"public CompileOptions getOptions() {\n        return javaCompiler.getCompileOptions();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@TaskAction\n    protected void compile() {\n        if (antCompile == null) {\n            throw new InvalidUserDataException(\"The ant compile command must be set!\");\n        }\n        if (!GUtil.isTrue(getSourceCompatibility()) || !GUtil.isTrue(getTargetCompatibility())) {\n            throw new InvalidUserDataException(\"The sourceCompatibility and targetCompatibility must be set!\");\n        }\n\n        antCompile.execute(getSource(), getDestinationDir(), getDependencyCacheDir(), getClasspath(),\n                getSourceCompatibility(), getTargetCompatibility(), options, getProject().getAnt());\n        setDidWork(antCompile.getNumFilesCompiled() > 0);\n    }","id":95137,"modified_method":"@TaskAction\n    protected void compile() {\n        javaCompiler.setSource(getSource());\n        javaCompiler.setDestinationDir(getDestinationDir());\n        javaCompiler.setClasspath(getClasspath());\n        javaCompiler.setDependencyCacheDir(getDependencyCacheDir());\n        javaCompiler.setSourceCompatibility(getSourceCompatibility());\n        javaCompiler.setTargetCompatibility(getTargetCompatibility());\n        WorkResult result = javaCompiler.execute();\n        setDidWork(result.getDidWork());\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public void testExecute(final int numFilesCompiled) {\n        setUpMocksAndAttributes(compile);\n        context.checking(new Expectations() {{\n            one(antCompileMock).execute(\n                    with(hasSameItems(compile.getSource())),\n                    with(equalTo(compile.getDestinationDir())),\n                    with(equalTo(compile.getDependencyCacheDir())),\n                    with(equalTo(compile.getClasspath())),\n                    with(equalTo(compile.getSourceCompatibility())),\n                    with(equalTo(compile.getTargetCompatibility())),\n                    with(equalTo(compile.getOptions())),\n                    with(equalTo(compile.getAnt())));\n            one(antCompileMock).getNumFilesCompiled(); will(returnValue(numFilesCompiled));\n        }});\n        compile.execute();\n    }","id":95138,"modified_method":"public void testExecute(final int numFilesCompiled) {\n        setUpMocksAndAttributes(compile);\n        context.checking(new Expectations() {{\n            WorkResult result = context.mock(WorkResult.class);\n\n            one(compilerMock).setSource(with(hasSameItems(compile.getSource())));\n            one(compilerMock).setClasspath(compile.getClasspath());\n            one(compilerMock).setDestinationDir(compile.getDestinationDir());\n            one(compilerMock).setDependencyCacheDir(compile.getDependencyCacheDir());\n            one(compilerMock).setSourceCompatibility(compile.getSourceCompatibility());\n            one(compilerMock).setTargetCompatibility(compile.getTargetCompatibility());\n            one(compilerMock).execute();\n            will(returnValue(result));\n            allowing(result).getDidWork();\n            will(returnValue(numFilesCompiled > 0));\n        }});\n        compile.execute();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Before public void setUp()  {\n        super.setUp();\n        context.setImposteriser(ClassImposteriser.INSTANCE);\n        compile = createTask(Compile.class);\n        antCompileMock = context.mock(AntJavac.class);\n        compile.antCompile = antCompileMock;\n\n        GFileUtils.touch(new File(srcDir, \"incl/file.java\"));\n    }","id":95139,"modified_method":"@Before public void setUp()  {\n        super.setUp();\n        compile = createTask(Compile.class);\n        compilerMock = context.mock(JavaCompiler.class);\n        compile.setJavaCompiler(compilerMock);\n\n        GFileUtils.touch(new File(srcDir, \"incl/file.java\"));\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public AntGroovyc getAntGroovyCompile() {\n        return antGroovyCompile;\n    }","id":95140,"modified_method":"public GroovyCompiler getGroovyCompiler() {\n        return groovyCompiler;\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"protected void compile() {\n        if (getAntGroovyCompile() == null) {\n            throw new InvalidUserDataException(\"The ant groovy compile command must be set!\");\n        }\n        if (getSourceCompatibility() == null || getTargetCompatibility() == null) {\n            throw new InvalidUserDataException(\"The sourceCompatibility and targetCompatibility must be set!\");\n        }\n\n        List<File> classpath = GUtil.addLists(getClasspath());\n        // todo We need to understand why it is not good enough to put groovy and ant in the task classpath but also Junit. As we don't understand we put the whole testCompile in it right now. It doesn't hurt, but understanding is better :)\n        List<File> taskClasspath = new ArrayList<File>(getGroovyClasspath().getFiles());\n        throwExceptionIfTaskClasspathIsEmpty(taskClasspath);\n        antGroovyCompile.execute(getSource(), getDestinationDir(),\n                classpath, getSourceCompatibility(), getTargetCompatibility(), getGroovyOptions(), getOptions(),\n                taskClasspath);\n        setDidWork(antGroovyCompile.getNumFilesCompiled() > 0);\n    }","id":95141,"modified_method":"protected void compile() {\n        // todo We need to understand why it is not good enough to put groovy and ant in the task classpath but also Junit. As we don't understand we put the whole testCompile in it right now. It doesn't hurt, but understanding is better :)\n        List<File> taskClasspath = new ArrayList<File>(getGroovyClasspath().getFiles());\n        throwExceptionIfTaskClasspathIsEmpty(taskClasspath);\n        groovyCompiler.setSource(getSource());\n        groovyCompiler.setDestinationDir(getDestinationDir());\n        groovyCompiler.setClasspath(getClasspath());\n        groovyCompiler.setSourceCompatibility(getSourceCompatibility());\n        groovyCompiler.setTargetCompatibility(getTargetCompatibility());\n        groovyCompiler.setGroovyClasspath(taskClasspath);\n        WorkResult result = groovyCompiler.execute();\n        setDidWork(result.getDidWork());\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public GroovyCompile() {\n        IsolatedAntBuilder antBuilder = getServices().get(IsolatedAntBuilder.class);\n        ClassPathRegistry classPathRegistry = getServices().get(ClassPathRegistry.class);\n        antGroovyCompile = new AntGroovyc(antBuilder, classPathRegistry);\n    }","id":95142,"modified_method":"public GroovyCompile() {\n        IsolatedAntBuilder antBuilder = getServices().get(IsolatedAntBuilder.class);\n        ClassPathRegistry classPathRegistry = getServices().get(ClassPathRegistry.class);\n        groovyCompiler = new AntGroovyCompiler(antBuilder, classPathRegistry);\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Gets the options for the groovyc compilation. To set specific options for the nested javac compilation,\n     * use {@link #getOptions()}.\n     */\n    public GroovyCompileOptions getGroovyOptions() {\n        return groovyOptions;\n    }","id":95143,"modified_method":"/**\n     * Gets the options for the groovyc compilation. To set specific options for the nested javac compilation,\n     * use {@link #getOptions()}.\n     */\n    public GroovyCompileOptions getGroovyOptions() {\n        return groovyCompiler.getGroovyCompileOptions();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public void setAntGroovyCompile(AntGroovyc antGroovyCompile) {\n        this.antGroovyCompile = antGroovyCompile;\n    }","id":95144,"modified_method":"public void setGroovyCompiler(GroovyCompiler groovyCompiler) {\n        this.groovyCompiler = groovyCompiler;\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public void testExecute(final int numFilesCompiled) {\n        final IsolatedAntBuilder ant = getProject().getServiceRegistryFactory().get(IsolatedAntBuilder.class);\n        setUpMocksAndAttributes(testObj, TEST_GROOVY_CLASSPATH);\n        context.checking(new Expectations(){{\n            one(antGroovycCompileMock).execute(\n                    with(hasSameItems(testObj.getSource())),\n                    with(equalTo(testObj.getDestinationDir())),\n                    with(equalTo(TEST_DEPENDENCY_MANAGER_CLASSPATH)),\n                    with(equalTo(testObj.getSourceCompatibility())),\n                    with(equalTo(testObj.getTargetCompatibility())),\n                    with(equalTo(testObj.getGroovyOptions())),\n                    with(equalTo(testObj.getOptions())),\n                    with(equalTo(TEST_GROOVY_CLASSPATH)));\n            \n            one(antGroovycCompileMock).getNumFilesCompiled();  will(returnValue(numFilesCompiled));\n        }});\n\n        testObj.execute();\n    }","id":95145,"modified_method":"public void testExecute(final int numFilesCompiled) {\n        final IsolatedAntBuilder ant = getProject().getServiceRegistryFactory().get(IsolatedAntBuilder.class);\n        setUpMocksAndAttributes(testObj, TEST_GROOVY_CLASSPATH);\n        context.checking(new Expectations(){{\n            WorkResult result = context.mock(WorkResult.class);\n\n            one(groovyCompilerMock).setSource(with(hasSameItems(testObj.getSource())));\n            one(groovyCompilerMock).setDestinationDir(testObj.getDestinationDir());\n            one(groovyCompilerMock).setClasspath(testObj.getClasspath());\n            one(groovyCompilerMock).setSourceCompatibility(testObj.getSourceCompatibility());\n            one(groovyCompilerMock).setTargetCompatibility(testObj.getTargetCompatibility());\n            one(groovyCompilerMock).setGroovyClasspath(TEST_GROOVY_CLASSPATH);\n            one(groovyCompilerMock).execute();\n            will(returnValue(result));\n            allowing(result).getDidWork();\n            will(returnValue(numFilesCompiled > 0));\n        }});\n\n        testObj.execute();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Before\n    public void setUp() {\n        super.setUp();\n        context.setImposteriser(ClassImposteriser.INSTANCE);\n        testObj = createTask(GroovyCompile.class);\n        antGroovycCompileMock = context.mock(AntGroovyc.class);\n        testObj.setAntGroovyCompile(antGroovycCompileMock);\n        testObj.antCompile = context.mock(AntJavac.class);\n\n        GFileUtils.touch(new File(srcDir, \"incl/file.groovy\"));\n    }","id":95146,"modified_method":"@Before\n    public void setUp() {\n        super.setUp();\n        testObj = createTask(GroovyCompile.class);\n        groovyCompilerMock = context.mock(GroovyCompiler.class);\n        testObj.setGroovyCompiler(groovyCompilerMock);\n        testObj.setJavaCompiler(context.mock(JavaCompiler.class));\n\n        GFileUtils.touch(new File(srcDir, \"incl/file.groovy\"));\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void compile() {\n\n        if (!GUtil.isTrue(getSourceCompatibility()) || !GUtil.isTrue(getTargetCompatibility())) {\n            throw new InvalidUserDataException(\"The sourceCompatibility and targetCompatibility must be set!\");\n        }\n\n        FileTree source = getSource();\n        getAntScalaCompile().execute(source, getDestinationDir(), getClasspath(), getScalaCompileOptions());\n\n        FileTree javaSource = getJavaSrc();\n        List<File> classpath = GUtil.addLists(Collections.singleton(getDestinationDir()), getClasspath());\n        javaSource.stopExecutionIfEmpty();\n        antCompile.execute(javaSource, getDestinationDir(), getDependencyCacheDir(), classpath,\n                getSourceCompatibility(), getTargetCompatibility(), getOptions(), getAnt());\n    }","id":95147,"modified_method":"@Override\n    protected void compile() {\n\n        if (!GUtil.isTrue(getSourceCompatibility()) || !GUtil.isTrue(getTargetCompatibility())) {\n            throw new InvalidUserDataException(\"The sourceCompatibility and targetCompatibility must be set!\");\n        }\n\n        FileTree source = getSource();\n        scalaCompiler.setSource(source);\n        scalaCompiler.setDestinationDir(getDestinationDir());\n        scalaCompiler.setClasspath(getClasspath());\n        scalaCompiler.setScalaClasspath(getScalaClasspath());\n        scalaCompiler.execute();\n\n        FileTree javaSource = getJavaSrc();\n        List<File> classpath = GUtil.addLists(Collections.singleton(getDestinationDir()), getClasspath());\n        javaSource.stopExecutionIfEmpty();\n        JavaCompiler javaCompiler = getJavaCompiler();\n        javaCompiler.setSource(javaSource);\n        javaCompiler.setDestinationDir(getDestinationDir());\n        javaCompiler.setDependencyCacheDir(getDependencyCacheDir());\n        javaCompiler.setClasspath(classpath);\n        javaCompiler.setSourceCompatibility(getSourceCompatibility());\n        javaCompiler.setTargetCompatibility(getTargetCompatibility());\n        javaCompiler.execute();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public ScalaCompileOptions getScalaCompileOptions() {\n        return scalaCompileOptions;\n    }","id":95148,"modified_method":"public ScalaCompileOptions getScalaCompileOptions() {\n        return scalaCompiler.getScalaCompileOptions();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public AntScalaCompile getAntScalaCompile() {\n        if (antScalaCompile == null) {\n            antScalaCompile = new AntScalaCompile(getAnt());\n        }\n        return antScalaCompile;\n    }","id":95149,"modified_method":"public ScalaCompiler getScalaCompiler() {\n        return scalaCompiler;\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"public void setAntScalaCompile(AntScalaCompile antScalaCompile) {\n        this.antScalaCompile = antScalaCompile;\n    }","id":95150,"modified_method":"public void setScalaCompiler(ScalaCompiler scalaCompiler) {\n        this.scalaCompiler = scalaCompiler;\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        context.setImposteriser(ClassImposteriser.INSTANCE);\n        scalaCompile = createTask(ScalaCompile.class);\n        antScalaCompileMock = context.mock(AntScalaCompile.class);\n        antCompileMock = context.mock(AntJavac.class);\n        scalaCompile.setAntScalaCompile(antScalaCompileMock);\n        scalaCompile.setAntCompile(antCompileMock);\n\n        GFileUtils.touch(new File(srcDir, \"incl/file.scala\"));\n        GFileUtils.touch(new File(srcDir, \"incl/file.java\"));\n    }","id":95151,"modified_method":"@Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        scalaCompile = createTask(ScalaCompile.class);\n        scalaCompiler = context.mock(ScalaCompiler.class);\n        javaCompiler = context.mock(JavaCompiler.class);\n        scalaCompile.setScalaCompiler(scalaCompiler);\n        scalaCompile.setJavaCompiler(javaCompiler);\n\n        GFileUtils.touch(new File(srcDir, \"incl/file.scala\"));\n        GFileUtils.touch(new File(srcDir, \"incl/file.java\"));\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"protected void setUpMocksAndAttributes(final ScalaCompile compile) {\n        compile.source(srcDir);\n        compile.setIncludes(TEST_INCLUDES);\n        compile.setExcludes(TEST_EXCLUDES);\n        compile.setSourceCompatibility(\"1.5\");\n        compile.setTargetCompatibility(\"1.5\");\n        compile.setDestinationDir(destDir);\n        compile.setDependencyCacheDir(depCacheDir);\n\n        final FileCollection configuration = context.mock(FileCollection.class);\n        context.checking(new Expectations(){{\n            allowing(configuration).iterator();\n            will(returnIterator(TEST_DEPENDENCY_MANAGER_CLASSPATH));\n        }});\n\n        compile.setClasspath(configuration);\n    }","id":95152,"modified_method":"protected void setUpMocksAndAttributes(final ScalaCompile compile) {\n        compile.source(srcDir);\n        compile.setIncludes(TEST_INCLUDES);\n        compile.setExcludes(TEST_EXCLUDES);\n        compile.setSourceCompatibility(\"1.5\");\n        compile.setTargetCompatibility(\"1.5\");\n        compile.setDestinationDir(destDir);\n        compile.setDependencyCacheDir(depCacheDir);\n        compile.setScalaClasspath(context.mock(FileCollection.class));\n\n        final FileCollection configuration = context.mock(FileCollection.class);\n        context.checking(new Expectations(){{\n            allowing(configuration).iterator();\n            will(returnIterator(TEST_DEPENDENCY_MANAGER_CLASSPATH));\n        }});\n\n        compile.setClasspath(configuration);\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testExecuteDoingWork() {\n        setUpMocksAndAttributes(scalaCompile);\n        context.checking(new Expectations() {{\n            one(antScalaCompileMock).execute(\n                    with(hasSameItems(scalaCompile.getSource())),\n                    with(equalTo(scalaCompile.getDestinationDir())),\n                    with(equalTo(scalaCompile.getClasspath())),\n                    with(equalTo(scalaCompile.getScalaCompileOptions())));\n\n            List<File> expectedClassPath = new ArrayList<File>();\n            expectedClassPath.add(scalaCompile.getDestinationDir());\n            for (File file : scalaCompile.getClasspath()) {\n                expectedClassPath.add(file);\n            }\n\n            FileCollection javaSrc = scalaCompile.getJavaSrc();\n            one(antCompileMock).execute(\n                    with(hasSameItems(javaSrc)),\n                    with(equalTo(scalaCompile.getDestinationDir())),\n                    with(equalTo(scalaCompile.getDependencyCacheDir())),\n                    with(equalTo(expectedClassPath)),\n                    with(equalTo(scalaCompile.getSourceCompatibility())),\n                    with(equalTo(scalaCompile.getTargetCompatibility())),\n                    with(equalTo(scalaCompile.getOptions())),\n                    with(equalTo(scalaCompile.getAnt())));\n        }});\n\n        scalaCompile.compile();\n    }","id":95153,"modified_method":"@Test\n    public void testExecuteDoingWork() {\n        setUpMocksAndAttributes(scalaCompile);\n        context.checking(new Expectations() {{\n            one(scalaCompiler).setSource(with(hasSameItems(scalaCompile.getSource())));\n            one(scalaCompiler).setDestinationDir(scalaCompile.getDestinationDir());\n            one(scalaCompiler).setClasspath(scalaCompile.getClasspath());\n            one(scalaCompiler).setScalaClasspath(scalaCompile.getScalaClasspath());\n            one(scalaCompiler).execute();\n\n            List<File> expectedClassPath = new ArrayList<File>();\n            expectedClassPath.add(scalaCompile.getDestinationDir());\n            for (File file : scalaCompile.getClasspath()) {\n                expectedClassPath.add(file);\n            }\n\n            FileCollection javaSrc = scalaCompile.getJavaSrc();\n            one(javaCompiler).setSource(with(hasSameItems(javaSrc)));\n            one(javaCompiler).setClasspath(expectedClassPath);\n            one(javaCompiler).setDestinationDir(scalaCompile.getDestinationDir());\n            one(javaCompiler).setDependencyCacheDir(scalaCompile.getDependencyCacheDir());\n            one(javaCompiler).setSourceCompatibility(scalaCompile.getSourceCompatibility());\n            one(javaCompiler).setTargetCompatibility(scalaCompile.getTargetCompatibility());\n            one(javaCompiler).execute();\n        }});\n\n        scalaCompile.compile();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@TaskAction\n    protected void generate() {\n        ScalaDocOptions options = getScalaDocOptions();\n        if (!GUtil.isTrue(options.getDocTitle())) {\n            options.setDocTitle(getTitle());\n        }\n        if (!GUtil.isTrue(options.getWindowTitle())) {\n            options.setWindowTitle(getTitle());\n        }\n        getAntScalaDoc().execute(getSource(), getDestinationDir(), getClasspath(), options);\n    }","id":95154,"modified_method":"@TaskAction\n    protected void generate() {\n        ScalaDocOptions options = getScalaDocOptions();\n        if (!GUtil.isTrue(options.getDocTitle())) {\n            options.setDocTitle(getTitle());\n        }\n        if (!GUtil.isTrue(options.getWindowTitle())) {\n            options.setWindowTitle(getTitle());\n        }\n        getAntScalaDoc().execute(getSource(), getDestinationDir(), getClasspath(), getScalaClasspath(), options);\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"private void setUpMocksAndAttributes(final ScalaDoc docTask) {\n        docTask.source(srcDir);\n        docTask.setDestinationDir(destDir);\n\n        final FileCollection classpath = context.mock(FileCollection.class);\n        context.checking(new Expectations(){{\n            allowing(classpath).getFiles();\n            will(returnValue(new LinkedHashSet<File>(TEST_DEPENDENCY_MANAGER_CLASSPATH)));\n        }});\n        docTask.setClasspath(classpath);\n\n        context.checking(new Expectations() {{\n            one(antScalaDocMock).execute(\n                    with(hasSameItems(scalaDoc.getSource())),\n                    with(equalTo(scalaDoc.getDestinationDir())),\n                    with(equalTo(scalaDoc.getClasspath())),\n                    with(sameInstance(scalaDoc.getScalaDocOptions())));\n        }});\n    }","id":95155,"modified_method":"private void setUpMocksAndAttributes(final ScalaDoc docTask) {\n        docTask.source(srcDir);\n        docTask.setDestinationDir(destDir);\n        docTask.setScalaClasspath(context.mock(FileCollection.class));\n        docTask.setClasspath(context.mock(FileCollection.class));\n\n        context.checking(new Expectations() {{\n            one(antScalaDocMock).execute(\n                    with(hasSameItems(scalaDoc.getSource())),\n                    with(equalTo(scalaDoc.getDestinationDir())),\n                    with(equalTo(scalaDoc.getClasspath())),\n                    with(equalTo(scalaDoc.getScalaClasspath())),\n                    with(sameInstance(scalaDoc.getScalaDocOptions())));\n        }});\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        destDir = getProject().file(\"destDir\");\n        srcDir = getProject().file(\"src\");\n        GFileUtils.touch(new File(srcDir, \"file.scala\"));\n        context.setImposteriser(ClassImposteriser.INSTANCE);\n        scalaDoc = createTask(ScalaDoc.class);\n        antScalaDocMock = context.mock(AntScalaDoc.class);\n        scalaDoc.setAntScalaDoc(antScalaDocMock);\n    }","id":95156,"modified_method":"@Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        destDir = getProject().file(\"destDir\");\n        srcDir = getProject().file(\"src\");\n        GFileUtils.touch(new File(srcDir, \"file.scala\"));\n        scalaDoc = createTask(ScalaDoc.class);\n        antScalaDocMock = context.mock(AntScalaDoc.class);\n        scalaDoc.setAntScalaDoc(antScalaDocMock);\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testSetsDocTitleAndWindowTitleIfNotSet() {\n        setUpMocksAndAttributes(scalaDoc);\n        scalaDoc.setTitle(\"title\");\n\n        scalaDoc.execute();\n\n        assertThat(scalaDoc.getScalaDocOptions().getDocTitle(), equalTo(\"title\"));\n        assertThat(scalaDoc.getScalaDocOptions().getWindowTitle(), equalTo(\"title\"));\n    }","id":95157,"modified_method":"@Test\n    public void testSetsDocTitleAndWindowTitleIfNotSet() {\n        setUpMocksAndAttributes(scalaDoc);\n        scalaDoc.setTitle(\"title\");\n\n        scalaDoc.generate();\n\n        assertThat(scalaDoc.getScalaDocOptions().getDocTitle(), equalTo(\"title\"));\n        assertThat(scalaDoc.getScalaDocOptions().getWindowTitle(), equalTo(\"title\"));\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testExecutesAntScalaDoc() {\n        setUpMocksAndAttributes(scalaDoc);\n        scalaDoc.execute();\n    }","id":95158,"modified_method":"@Test\n    public void testExecutesAntScalaDoc() {\n        setUpMocksAndAttributes(scalaDoc);\n        scalaDoc.generate();\n    }","commit_id":"3af9ebbb5c3ae9e0ff8b7b963185ce03836ba0fa","url":"https://github.com/gradle/gradle"},{"original_method":"@Nullable\n  private ArrayList<E> performDFA(boolean timeout) {\n    long msLimit = Registry.intValue(\"ide.dfa.time.limit.online\");\n    WorkingTimeMeasurer measurer = new WorkingTimeMeasurer(msLimit * 1000 * 1000);\n\n    ArrayList<E> info = new ArrayList<E>(myFlow.length);\n    CallEnvironment env = new MyCallEnvironment(myFlow.length);\n    for (int i = 0; i < myFlow.length; i++) {\n      info.add(myDfa.initial());\n    }\n\n    boolean[] visited = new boolean[myFlow.length];\n\n    final boolean forward = myDfa.isForward();\n    int[] order = ControlFlowBuilderUtil.postorder(myFlow); //todo for backward?\n    int count = 0;\n    for (int i = forward ? 0 : myFlow.length - 1; forward ? i < myFlow.length : i >= 0;) {\n      Instruction instr = myFlow[order[i]];\n\n      if (!visited[instr.num()]) {\n        Queue<Instruction> workList = new LinkedList<Instruction>();\n\n        workList.add(instr);\n        visited[instr.num()] = true;\n\n        while (!workList.isEmpty()) {\n          count++;\n          if (timeout && count % 512 == 0 && measurer.isTimeOver()) return null;\n\n          ProgressManager.checkCanceled();\n          final Instruction curr = workList.remove();\n          final int num = curr.num();\n          final E oldE = info.get(num);\n          E newE = join(curr, info, env);\n          myDfa.fun(newE, curr);\n          if (!mySemilattice.eq(newE, oldE)) {\n            info.set(num, newE);\n            for (Instruction next : getNext(curr, env)) {\n              workList.add(next);\n              visited[next.num()] = true;\n            }\n          }\n        }\n      }\n\n      if (forward) i++;\n      else i--;\n    }\n\n\n    return info;\n  }","id":95159,"modified_method":"@Nullable\n  private ArrayList<E> performDFA(boolean timeout) {\n    WorkingTimeMeasurer measurer = null;\n\n    ArrayList<E> info = new ArrayList<E>(Collections.nCopies(myFlow.length, myDfa.initial()));\n    CallEnvironment env = new MyCallEnvironment(myFlow.length);\n    \n    boolean[] visited = new boolean[myFlow.length];\n\n    final boolean forward = myDfa.isForward();\n    int[] order = ControlFlowBuilderUtil.postorder(myFlow); //todo for backward?\n    int count = 0;\n    for (int i = forward ? 0 : myFlow.length - 1; forward ? i < myFlow.length : i >= 0;) {\n      Instruction instr = myFlow[order[i]];\n\n      if (!visited[instr.num()]) {\n        Queue<Instruction> workList = new LinkedList<Instruction>();\n\n        workList.add(instr);\n        visited[instr.num()] = true;\n\n        while (!workList.isEmpty()) {\n          count++;\n          if (timeout && count % 512 == 0) {\n            if (measurer == null) {\n              long msLimit = Registry.intValue(\"ide.dfa.time.limit.online\");\n\n              measurer = new WorkingTimeMeasurer(msLimit * 1000 * 1000);\n            }\n            else if (measurer.isTimeOver()) {\n              return null;\n            }\n          }\n\n          ProgressManager.checkCanceled();\n          final Instruction curr = workList.remove();\n          final int num = curr.num();\n          final E oldE = info.get(num);\n          E newE = join(curr, info, env);\n          myDfa.fun(newE, curr);\n          if (!mySemilattice.eq(newE, oldE)) {\n            info.set(num, newE);\n            for (Instruction next : getNext(curr, env)) {\n              workList.add(next);\n              visited[next.num()] = true;\n            }\n          }\n        }\n      }\n\n      if (forward) i++;\n      else i--;\n    }\n\n\n    return info;\n  }","commit_id":"6bd3410d4867b93a0fe0b6d1cd4ff55558b9b42e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** {@inheritDoc} */\n    @Override public List<List<ClusterNode>> assignPartitions(CacheAffinityFunctionContext ctx) {\n        List<ClusterNode> topSnapshot = ctx.currentTopologySnapshot();\n\n        if (topSnapshot.size() == 1) {\n            ClusterNode primary = topSnapshot.get(0);\n\n            List<List<ClusterNode>> assignments = new ArrayList<>(parts);\n\n            for (int i = 0; i < parts; i++)\n                assignments.add(Collections.singletonList(primary));\n\n            return assignments;\n        }\n\n        IgniteBiTuple<List<List<ClusterNode>>, Map<UUID, PartitionSet>> cp = createCopy(ctx, topSnapshot);\n\n        List<List<ClusterNode>> assignment = cp.get1();\n\n        int tiers = Math.min(ctx.backups() + 1, topSnapshot.size());\n\n        // Per tier pending partitions.\n        Map<Integer, Queue<Integer>> pendingParts = new HashMap<>();\n\n        FullAssignmentMap fullMap = new FullAssignmentMap(tiers, assignment, topSnapshot);\n\n        for (int tier = 0; tier < tiers; tier++) {\n            // Check if this is a new tier and add pending partitions.\n            Queue<Integer> pending = pendingParts.get(tier);\n\n            for (int part = 0; part < parts; part++) {\n                if (fullMap.assignments.get(part).size() < tier + 1) {\n                    if (pending == null) {\n                        pending = new LinkedList<>();\n\n                        pendingParts.put(tier, pending);\n                    }\n\n                    if (!pending.contains(part))\n                        pending.add(part);\n\n                }\n            }\n\n            // Assign pending partitions, if any.\n            assignPending(tier, pendingParts, fullMap, topSnapshot);\n\n            // Balance assignments.\n            balance(tier, pendingParts, fullMap, topSnapshot);\n        }\n\n        return fullMap.assignments;\n    }","id":95160,"modified_method":"/** {@inheritDoc} */\n    @Override public List<List<ClusterNode>> assignPartitions(CacheAffinityFunctionContext ctx) {\n        List<ClusterNode> topSnapshot = ctx.currentTopologySnapshot();\n\n        if (topSnapshot.size() == 1) {\n            ClusterNode primary = topSnapshot.get(0);\n\n            return Collections.nCopies(parts, Collections.singletonList(primary));\n        }\n\n        IgniteBiTuple<List<List<ClusterNode>>, Map<UUID, PartitionSet>> cp = createCopy(ctx, topSnapshot);\n\n        List<List<ClusterNode>> assignment = cp.get1();\n\n        int tiers = Math.min(ctx.backups() + 1, topSnapshot.size());\n\n        // Per tier pending partitions.\n        Map<Integer, Queue<Integer>> pendingParts = new HashMap<>();\n\n        FullAssignmentMap fullMap = new FullAssignmentMap(tiers, assignment, topSnapshot);\n\n        for (int tier = 0; tier < tiers; tier++) {\n            // Check if this is a new tier and add pending partitions.\n            Queue<Integer> pending = pendingParts.get(tier);\n\n            for (int part = 0; part < parts; part++) {\n                if (fullMap.assignments.get(part).size() < tier + 1) {\n                    if (pending == null) {\n                        pending = new LinkedList<>();\n\n                        pendingParts.put(tier, pending);\n                    }\n\n                    if (!pending.contains(part))\n                        pending.add(part);\n\n                }\n            }\n\n            // Assign pending partitions, if any.\n            assignPending(tier, pendingParts, fullMap, topSnapshot);\n\n            // Balance assignments.\n            balance(tier, pendingParts, fullMap, topSnapshot);\n        }\n\n        return fullMap.assignments;\n    }","commit_id":"1108b45715828b3b8485774124653b18ba739cdf","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n    public void start(Collection<? extends Location> locs) {\n        if (isQuarantineEnabled()) {\n            Group quarantineGroup = addChild(EntitySpec.create(BasicGroup.class).displayName(\"quarantine\"));\n            Entities.manage(quarantineGroup);\n            setAttribute(QUARANTINE_GROUP, quarantineGroup);\n        }\n        \n        if (locs==null) throw new IllegalStateException(\"Null location supplied to start \"+this);\n        if (locs.size()!=1) throw new IllegalStateException(\"Wrong number of locations supplied to start \"+this+\": \"+locs);\n        addLocations(locs);\n        setAttribute(SERVICE_STATE, Lifecycle.STARTING);\n        \n        int initialSize = getConfig(INITIAL_SIZE).intValue();\n        int initialQuorumSize = getInitialQuorumSize();\n        \n        resize(initialSize);\n        \n        int currentSize = getCurrentSize().intValue();\n        if (currentSize < initialQuorumSize) {\n            throw new IllegalStateException(\"On start of cluster \"+this+\", failed to get to initial size of \"+initialSize+\"; size is \"+getCurrentSize()+\n                    (initialQuorumSize != initialSize ? \" (initial quorum size is \"+initialQuorumSize+\")\" : \"\"));\n        } else if (currentSize < initialSize) {\n            LOG.warn(\"On start of cluster {}, size {} reached initial minimum quorum size of {} but did not reach desired size {}; continuing\", \n                    new Object[] {this, currentSize, initialQuorumSize, initialSize});\n        }\n        \n        for (Policy it : getPolicies()) { it.resume(); }\n        setAttribute(SERVICE_STATE, Lifecycle.RUNNING);\n        setAttribute(SERVICE_UP, calculateServiceUp());\n    }","id":95161,"modified_method":"@Override\n    public void start(Collection<? extends Location> locs) {\n        checkNotNull(locs, \"Null location supplied to start %s\", this);\n        checkArgument(locs.size() == 1, \"Wrong number of locations supplied to start %s: %s\", this, locs);\n        addLocations(locs);\n\n        if (isAvailabilityZoneEnabled()) {\n            setAttribute(SUB_LOCATIONS, findSubLocations(Iterables.getOnlyElement(locs)));\n        }\n\n        setAttribute(SERVICE_STATE, Lifecycle.STARTING);\n\n        if (isQuarantineEnabled()) {\n            Group quarantineGroup = addChild(EntitySpec.create(BasicGroup.class).displayName(\"quarantine\"));\n            Entities.manage(quarantineGroup);\n            setAttribute(QUARANTINE_GROUP, quarantineGroup);\n        }\n\n        int initialSize = getConfig(INITIAL_SIZE).intValue();\n        int initialQuorumSize = getInitialQuorumSize();\n\n        resize(initialSize);\n\n        int currentSize = getCurrentSize().intValue();\n        if (currentSize < initialQuorumSize) {\n            throw new IllegalStateException(\"On start of cluster \" + this + \", failed to get to initial size of \" + initialSize\n                    + \"; size is \" + getCurrentSize()\n                    + (initialQuorumSize != initialSize ? \" (initial quorum size is \" + initialQuorumSize + \")\" : \"\"));\n        } else if (currentSize < initialSize) {\n            LOG.warn(\n                    \"On start of cluster {}, size {} reached initial minimum quorum size of {} but did not reach desired size {}; continuing\",\n                    new Object[] { this, currentSize, initialQuorumSize, initialSize });\n        }\n\n        for (Policy it : getPolicies()) {\n            it.resume();\n        }\n        setAttribute(SERVICE_STATE, Lifecycle.RUNNING);\n        setAttribute(SERVICE_UP, calculateServiceUp());\n    }","commit_id":"02099f9ece45ae995bf0263cf2228479be6a428f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected Entity pickAndRemoveMember() {\n        \n        // TODO use pluggable strategy; default is to remove newest\n        // TODO inefficient impl\n        Preconditions.checkState(getMembers().size() > 0, \"Attempt to remove a node when members is empty, from cluster \"+this);\n        if (LOG.isDebugEnabled()) LOG.debug(\"Removing a node from {}\", this);\n        \n        Entity entity = getRemovalStrategy().apply(getMembers());\n        Preconditions.checkNotNull(entity, \"No entity chosen for removal from \"+getId());\n        Preconditions.checkState(entity instanceof Startable, \"Chosen entity for removal not stoppable: cluster=\"+this+\"; choice=\"+entity);\n\n        removeMember(entity);\n        return entity;\n    }","id":95162,"modified_method":"/**\n     * @deprecated since 0.6.0; subclasses should instead override {@link #pickAndRemoveMembers(int)} if they really need to!\n     */\n    protected Entity pickAndRemoveMember() {\n        assert !isAvailabilityZoneEnabled() : \"should instead call pickAndRemoveMembers(int) if using availability zones\";\n        \n        // TODO inefficient impl\n        Preconditions.checkState(getMembers().size() > 0, \"Attempt to remove a node when members is empty, from cluster \"+this);\n        if (LOG.isDebugEnabled()) LOG.debug(\"Removing a node from {}\", this);\n        \n        Entity entity = getRemovalStrategy().apply(getMembers());\n        Preconditions.checkNotNull(entity, \"No entity chosen for removal from \"+getId());\n        Preconditions.checkState(entity instanceof Startable, \"Chosen entity for removal not stoppable: cluster=\"+this+\"; choice=\"+entity);\n\n        removeMember(entity);\n        return entity;\n    }","commit_id":"02099f9ece45ae995bf0263cf2228479be6a428f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public String replaceMember(String memberId) {\n        Entity member = getEntityManager().getEntity(memberId);\n        LOG.info(\"In {}, replacing member {} ({})\", new Object[] {this, memberId, member});\n\n        if (member == null) {\n            throw new NoSuchElementException(\"In \"+this+\", entity \"+memberId+\" cannot be resolved, so not replacing\");\n        }\n\n        synchronized (mutex) {\n            if (!getMembers().contains(member)) {\n                throw new NoSuchElementException(\"In \"+this+\", entity \"+member+\" is not a member so not replacing\");\n            }\n            \n            Collection<Entity> addedEntities = grow(1);\n            if (addedEntities.size() < 1) {\n                String msg = String.format(\"In %s, failed to grow, to replace %s; not removing\", this, member);\n                throw new IllegalStateException(msg);\n            }\n            \n            stopAndRemoveNode(member);\n            \n            return Iterables.get(addedEntities, 0).getId();\n        }\n    }","id":95163,"modified_method":"@Override\n    public String replaceMember(String memberId) {\n        Entity member = getEntityManager().getEntity(memberId);\n        LOG.info(\"In {}, replacing member {} ({})\", new Object[] {this, memberId, member});\n\n        if (member == null) {\n            throw new NoSuchElementException(\"In \"+this+\", entity \"+memberId+\" cannot be resolved, so not replacing\");\n        }\n\n        synchronized (mutex) {\n            if (!getMembers().contains(member)) {\n                throw new NoSuchElementException(\"In \"+this+\", entity \"+member+\" is not a member so not replacing\");\n            }\n            \n            Location memberLoc;\n            if (isAvailabilityZoneEnabled()) {\n                memberLoc = checkNotNull(Iterables.getOnlyElement(member.getLocations()), \"member's location (%s)\", member);\n            } else {\n                memberLoc = getLocation();\n            }\n            \n            Collection<Entity> addedEntities = growByOne(memberLoc);\n            if (addedEntities.size() < 1) {\n                String msg = String.format(\"In %s, failed to grow, to replace %s; not removing\", this, member);\n                throw new IllegalStateException(msg);\n            }\n            \n            stopAndRemoveNode(member);\n            \n            return Iterables.get(addedEntities, 0).getId();\n        }\n    }","commit_id":"02099f9ece45ae995bf0263cf2228479be6a428f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Decreases the cluster size by the given number.\n     * Called when synchronized on mutex, so overriders beware!\n     */\n    protected void shrink(int delta) {\n        Collection<Entity> removedEntities = Lists.newArrayList();\n        \n        for (int i = 0; i < (delta*-1); i++) { removedEntities.add(pickAndRemoveMember()); }\n\n        // FIXME symmetry in order of added as child, managed, started, and added to group\n        // FIXME assume stoppable; use logic of grow?\n        Task<?> invoke = Entities.invokeEffector(this, removedEntities, Startable.STOP, Collections.<String,Object>emptyMap());\n        try {\n            invoke.get();\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        } finally {\n            for (Entity removedEntity : removedEntities) {\n                discardNode(removedEntity);\n            }\n        }\n    }","id":95164,"modified_method":"/**\n     * Decreases the cluster size by the given number.\n     * Called when synchronized on mutex, so overriders beware!\n     */\n    protected void shrink(int delta) {\n        Collection<Entity> removedEntities = pickAndRemoveMembers(delta * -1);\n\n        // FIXME symmetry in order of added as child, managed, started, and added to group\n        // FIXME assume stoppable; use logic of grow?\n        Task<?> invoke = Entities.invokeEffector(this, removedEntities, Startable.STOP, Collections.<String,Object>emptyMap());\n        try {\n            invoke.get();\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        } finally {\n            for (Entity removedEntity : removedEntities) {\n                discardNode(removedEntity);\n            }\n        }\n    }","commit_id":"02099f9ece45ae995bf0263cf2228479be6a428f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected Map<Entity, Throwable> waitForTasksOnEntityStart(Map<Entity,Task<?>> tasks) {\n        // TODO Could have CompoundException, rather than propagating first\n        Map<Entity, Throwable> errors = Maps.newLinkedHashMap();\n        \n        for (Map.Entry<Entity,Task<?>> entry : tasks.entrySet()) {\n            Entity entity = entry.getKey();\n            Task<?> task = entry.getValue();\n            try {\n                task.get();\n            } catch (InterruptedException e) {\n                throw Exceptions.propagate(e);\n            } catch (Throwable t) {\n                Throwable interesting = Exceptions.getFirstInteresting(t);\n                LOG.error(\"Cluster \"+this+\" failed to start entity \"+entity+\" (removing): \"+interesting, interesting);\n                LOG.debug(\"Trace for: Cluster \"+this+\" failed to start entity \"+entity+\" (removing): \"+t, t);\n                // previously we unwrapped but now there is no need I think\n                errors.put(entity, t);\n            }\n        }\n        return errors;\n    }","id":95165,"modified_method":"protected Map<Entity, Throwable> waitForTasksOnEntityStart(Map<? extends Entity,? extends Task<?>> tasks) {\n        // TODO Could have CompoundException, rather than propagating first\n        Map<Entity, Throwable> errors = Maps.newLinkedHashMap();\n        \n        for (Map.Entry<? extends Entity,? extends Task<?>> entry : tasks.entrySet()) {\n            Entity entity = entry.getKey();\n            Task<?> task = entry.getValue();\n            try {\n                task.get();\n            } catch (InterruptedException e) {\n                throw Exceptions.propagate(e);\n            } catch (Throwable t) {\n                Throwable interesting = Exceptions.getFirstInteresting(t);\n                LOG.error(\"Cluster \"+this+\" failed to start entity \"+entity+\" (removing): \"+interesting, interesting);\n                LOG.debug(\"Trace for: Cluster \"+this+\" failed to start entity \"+entity+\" (removing): \"+t, t);\n                // previously we unwrapped but now there is no need I think\n                errors.put(entity, t);\n            }\n        }\n        return errors;\n    }","commit_id":"02099f9ece45ae995bf0263cf2228479be6a428f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Increases the cluster size by the given number. Returns successfully added nodes.\n     * Called when synchronized on mutex, so overriders beware!\n     */\n    protected Collection<Entity> grow(int delta) {\n        Collection<Entity> addedEntities = Lists.newArrayList();\n        for (int i = 0; i < delta; i++) {\n            addedEntities.add(addNode(getLocation()));\n        }\n        Map<Entity, Task<?>> tasks = Maps.newLinkedHashMap();\n        for (Entity entity: addedEntities) {\n            Map<String,?> args = ImmutableMap.of(\"locations\", ImmutableList.of(getLocation()));\n            tasks.put(entity, entity.invoke(Startable.START, args));\n        }\n        Map<Entity, Throwable> errors = waitForTasksOnEntityStart(tasks);\n        \n        if (!errors.isEmpty()) {\n            if (isQuarantineEnabled()) {\n                quarantineFailedNodes(errors.keySet());\n            } else {\n                cleanupFailedNodes(errors.keySet());\n            }\n        }\n        \n        return MutableList.<Entity>builder().addAll(addedEntities).removeAll(errors.keySet()).build();\n    }","id":95166,"modified_method":"/**\n     * Increases the cluster size by the given number. Returns successfully added nodes.\n     * Called when synchronized on mutex, so overriders beware!\n     */\n    protected Collection<Entity> grow(int delta) {\n        // choose locations to be deployed to\n        List<Location> chosenLocations;\n        if (isAvailabilityZoneEnabled()) {\n            List<Location> subLocations = getNonFailedSubLocations();\n            Multimap<Location, Entity> membersByLocation = getMembersByLocation();\n            chosenLocations = getZonePlacementStrategy().locationsForAdditions(membersByLocation, subLocations, delta);\n            if (chosenLocations.size() != delta) {\n                throw new IllegalStateException(\"Node placement strategy chose \" + Iterables.size(chosenLocations)\n                        + \", when expected delta \" + delta + \" in \" + this);\n            }\n        } else {\n            chosenLocations = Collections.nCopies(delta, getLocation());\n        }\n\n        // create the entities and start them\n        List<Entity> addedEntities = Lists.newArrayList();\n        Map<Entity, Location> addedEntityLocations = Maps.newLinkedHashMap();\n        Map<Entity, Task<?>> tasks = Maps.newLinkedHashMap();\n        for (Location chosenLocation : chosenLocations) {\n            Entity entity = addNode(chosenLocation);\n            addedEntities.add(entity);\n            addedEntityLocations.put(entity, chosenLocation);\n            Map<String, ?> args = ImmutableMap.of(\"locations\", ImmutableList.of(chosenLocation));\n            tasks.put(entity, entity.invoke(Startable.START, args));\n        }\n        Map<Entity, Throwable> errors = waitForTasksOnEntityStart(tasks);\n\n        // if tracking, then report success/fail to the ZoneFailureDetector\n        if (isAvailabilityZoneEnabled()) {\n            for (Map.Entry<Entity, Location> entry : addedEntityLocations.entrySet()) {\n                Entity entity = entry.getKey();\n                Location loc = entry.getValue();\n                Throwable err = errors.get(entity);\n                if (err == null) {\n                    getZoneFailureDetector().onStartupSuccess(loc, entity);\n                } else {\n                    getZoneFailureDetector().onStartupFailure(loc, entity, err);\n                }\n            }\n        }\n\n        // quarantine/cleanup as necessary\n        if (!errors.isEmpty()) {\n            if (isQuarantineEnabled()) {\n                quarantineFailedNodes(errors.keySet());\n            } else {\n                cleanupFailedNodes(errors.keySet());\n            }\n        }\n\n        return MutableList.<Entity> builder().addAll(addedEntities).removeAll(errors.keySet()).build();\n    }","commit_id":"02099f9ece45ae995bf0263cf2228479be6a428f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n   * Test journalling of inodes being pinned.\n   */\n  @Test\n  public void pinTest() throws Exception {\n    SetStateOptions setPinned =\n        new SetStateOptions.Builder().setPinned(true).build();\n    SetStateOptions setUnpinned =\n        new SetStateOptions.Builder().setPinned(false).build();\n    mTfs.mkdir(new TachyonURI(\"/myFolder\"));\n    TachyonFile directory = mTfs.open(new TachyonURI(\"/myFolder\"));\n    mTfs.setState(directory, setPinned);\n\n    TachyonURI file0Path = new TachyonURI(\"/myFolder/file0\");\n    OutStreamOptions op =\n        new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes(64).build();\n    mTfs.getOutStream(file0Path, op).close();\n    TachyonFile file0 = mTfs.open(file0Path);\n    mTfs.setState(file0, setUnpinned);\n\n    TachyonURI file1Path = new TachyonURI(\"/myFolder/file1\");\n    mTfs.getOutStream(file1Path, op).close();\n\n    FileInfo directoryInfo = mTfs.getInfo(directory);\n    FileInfo file0Info = mTfs.getInfo(file0);\n    FileInfo file1Info = mTfs.getInfo(mTfs.open(file1Path));\n\n    mLocalTachyonCluster.stopTFS();\n\n    pinTestUtil(directoryInfo, file0Info, file1Info);\n    deleteFsMasterJournalLogs();\n    pinTestUtil(directoryInfo, file0Info, file1Info);\n  }","id":95167,"modified_method":"/**\n   * Test journalling of inodes being pinned.\n   */\n  @Test\n  public void pinTest() throws Exception {\n    SetAttributeOptions setPinned = SetAttributeOptions.defaults().setPinned(true);\n    SetAttributeOptions setUnpinned = SetAttributeOptions.defaults().setPinned(false);\n    TachyonURI dirUri = new TachyonURI(\"/myFolder\");\n    mTfs.createDirectory(dirUri);\n    mTfs.setAttribute(dirUri, setPinned);\n\n    TachyonURI file0Path = new TachyonURI(\"/myFolder/file0\");\n    CreateFileOptions op = CreateFileOptions.defaults().setBlockSizeBytes(64);\n    mTfs.createFile(file0Path, op).close();\n    mTfs.setAttribute(file0Path, setUnpinned);\n\n    TachyonURI file1Path = new TachyonURI(\"/myFolder/file1\");\n    mTfs.createFile(file1Path, op).close();\n\n    URIStatus directoryStatus = mTfs.getStatus(dirUri);\n    URIStatus file0Status = mTfs.getStatus(file0Path);\n    URIStatus file1Status = mTfs.getStatus(file1Path);\n\n    mLocalTachyonCluster.stopTFS();\n\n    pinTestUtil(directoryStatus, file0Status, file1Status);\n    deleteFsMasterJournalLogs();\n    pinTestUtil(directoryStatus, file0Status, file1Status);\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"private List<FileInfo> lsr(FileSystemMaster fsMaster, long fileId)\n      throws FileDoesNotExistException {\n    List<FileInfo> files = fsMaster.getFileInfoList(fileId);\n    List<FileInfo> ret = Lists.newArrayList(files);\n    for (FileInfo file : files) {\n      ret.addAll(lsr(fsMaster, file.getFileId()));\n    }\n    return ret;\n  }","id":95168,"modified_method":"private void rawTableTestUtil(URIStatus status) throws IOException, InvalidPathException,\n      FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n\n    long fileId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(fileId != -1);\n    // \"ls -r /\" should return 11 FileInfos, one is table root \"/xyz\", the others are 10 columns.\n    Assert.assertEquals(11, lsr(fsMaster, fileId).size());\n\n    fileId = fsMaster.getFileId(new TachyonURI(\"/xyz\"));\n    Assert.assertTrue(fileId != -1);\n    Assert.assertEquals(status, new URIStatus(fsMaster.getFileInfo(fileId)));\n\n    fsMaster.stop();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test reading multiple edit logs.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void multiEditLogTest() throws Exception {\n    for (int i = 0; i < 124; i ++) {\n      OutStreamOptions op =\n          new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes((i + 10) / 10 * 64)\n              .build();\n      mTfs.getOutStream(new TachyonURI(\"/a\" + i), op);\n    }\n    mLocalTachyonCluster.stopTFS();\n    multiEditLogTestUtil();\n    deleteFsMasterJournalLogs();\n    multiEditLogTestUtil();\n  }","id":95169,"modified_method":"/**\n   * Test reading multiple edit logs.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void multiEditLogTest() throws Exception {\n    for (int i = 0; i < 124; i ++) {\n      CreateFileOptions op = CreateFileOptions.defaults().setBlockSizeBytes((i + 10) / 10 * 64);\n      mTfs.createFile(new TachyonURI(\"/a\" + i), op);\n    }\n    mLocalTachyonCluster.stopTFS();\n    multiEditLogTestUtil();\n    deleteFsMasterJournalLogs();\n    multiEditLogTestUtil();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"private void deleteFsMasterJournalLogs() throws IOException {\n    String journalFolder = mLocalTachyonCluster.getMaster().getJournalFolder();\n    Journal journal = new ReadWriteJournal(\n        PathUtils.concatPath(journalFolder, Constants.FILE_SYSTEM_MASTER_NAME));\n    UnderFileSystem.get(journalFolder, mMasterTachyonConf).delete(journal.getCurrentLogFilePath(),\n        true);\n  }","id":95170,"modified_method":"private void addBlockTestUtil(URIStatus status)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(1, fsMaster.getFileInfoList(rootId).size());\n    long xyzId = fsMaster.getFileId(new TachyonURI(\"/xyz\"));\n    Assert.assertTrue(xyzId != IdUtils.INVALID_FILE_ID);\n    FileInfo fsMasterInfo = fsMaster.getFileInfo(xyzId);\n    Assert.assertEquals(0, fsMaster.getFileInfo(xyzId).getInMemoryPercentage());\n    Assert.assertEquals(status.getBlockIds(), fsMasterInfo.getBlockIds());\n    Assert.assertEquals(status.getBlockSizeBytes(), fsMasterInfo.getBlockSizeBytes());\n    Assert.assertEquals(status.getLength(), fsMasterInfo.getLength());\n    fsMaster.stop();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void persistDirectoryLaterTest() throws Exception {\n    String[] directories = new String[] {\n        \"/d11\", \"/d11/d21\", \"/d11/d22\",\n        \"/d12\", \"/d12/d21\", \"/d12/d22\",\n    };\n\n    MkdirOptions.Builder builder = new MkdirOptions.Builder(ClientContext.getConf())\n        .setRecursive(true).setUnderStorageType(UnderStorageType.NO_PERSIST);\n    for (String directory : directories) {\n      mTfs.mkdir(new TachyonURI(directory), builder.build());\n    }\n\n    builder.setUnderStorageType(UnderStorageType.SYNC_PERSIST);\n    for (String directory : directories) {\n      mTfs.mkdir(new TachyonURI(directory), builder.build());\n    }\n\n    Map<String, FileInfo> dInfos = Maps.newHashMap();\n    for (String directory : directories) {\n      dInfos.put(directory, mTfs.getInfo(mTfs.open(new TachyonURI(directory))));\n    }\n    mLocalTachyonCluster.stopTFS();\n    persistDirectoryLaterTestUtil(dInfos);\n    deleteFsMasterJournalLogs();\n    persistDirectoryLaterTestUtil(dInfos);\n  }","id":95171,"modified_method":"@Test\n  public void persistDirectoryLaterTest() throws Exception {\n    String[] directories = new String[] {\n        \"/d11\", \"/d11/d21\", \"/d11/d22\",\n        \"/d12\", \"/d12/d21\", \"/d12/d22\",\n    };\n\n    CreateDirectoryOptions options =\n        CreateDirectoryOptions.defaults().setRecursive(true).setWriteType(WriteType.MUST_CACHE);\n    for (String directory : directories) {\n      mTfs.createDirectory(new TachyonURI(directory), options);\n    }\n\n    options.setWriteType(WriteType.CACHE_THROUGH);\n    for (String directory : directories) {\n      mTfs.createDirectory(new TachyonURI(directory), options);\n    }\n\n    Map<String, URIStatus> directoryStatuses = Maps.newHashMap();\n    for (String directory : directories) {\n      directoryStatuses.put(directory, mTfs.getStatus(new TachyonURI(directory)));\n    }\n    mLocalTachyonCluster.stopTFS();\n    persistDirectoryLaterTestUtil(directoryStatuses);\n    deleteFsMasterJournalLogs();\n    persistDirectoryLaterTestUtil(directoryStatuses);\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"private void persistDirectoryLaterTestUtil(Map<String, FileInfo> dInfos) throws Exception {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    for (Map.Entry<String, FileInfo> dInfo : dInfos.entrySet()) {\n      Assert.assertEquals(dInfo.getValue(), fsMaster.getFileInfo(fsMaster.getFileId(\n          new TachyonURI(dInfo.getKey()))));\n    }\n  }","id":95172,"modified_method":"private void persistDirectoryLaterTestUtil(Map<String, URIStatus> directoryStatuses)\n      throws Exception {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    for (Map.Entry<String, URIStatus> directoryStatus : directoryStatuses.entrySet()) {\n      Assert.assertEquals(directoryStatus.getValue(), fsMaster.getFileInfo(fsMaster.getFileId(\n          new TachyonURI(directoryStatus.getKey()))));\n    }\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void fileTest() throws Exception {\n    OutStreamOptions option =\n        new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes(64).build();\n    TachyonURI filePath = new TachyonURI(\"/xyz\");\n    mTfs.getOutStream(filePath, option).close();\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(filePath));\n    mLocalTachyonCluster.stopTFS();\n    fileTestUtil(fInfo);\n    deleteFsMasterJournalLogs();\n    fileTestUtil(fInfo);\n  }","id":95173,"modified_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void fileTest() throws Exception {\n    CreateFileOptions option = CreateFileOptions.defaults().setBlockSizeBytes(64);\n    TachyonURI filePath = new TachyonURI(\"/xyz\");\n    mTfs.createFile(filePath, option).close();\n    URIStatus status = mTfs.getStatus(filePath);\n    mLocalTachyonCluster.stopTFS();\n    fileTestUtil(status);\n    deleteFsMasterJournalLogs();\n    fileTestUtil(status);\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test file and directory creation and deletion;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void deleteTest() throws Exception {\n    MkdirOptions recMkdir = new MkdirOptions.Builder(new TachyonConf()).setRecursive(true).build();\n    DeleteOptions recDelete =\n        new DeleteOptions.Builder().setRecursive(true).build();\n    for (int i = 0; i < 10; i ++) {\n      String dirPath = \"/i\" + i;\n      mTfs.mkdir(new TachyonURI(dirPath), recMkdir);\n      for (int j = 0; j < 10; j ++) {\n        OutStreamOptions option =\n            new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes((i + j + 1) * 64)\n                .build();\n        String filePath = dirPath + \"/j\" + j;\n        mTfs.getOutStream(new TachyonURI(filePath), option).close();\n        if (j >= 5) {\n          mTfs.delete(mTfs.open(new TachyonURI(filePath)), recDelete);\n        }\n      }\n      if (i >= 5) {\n        mTfs.delete(mTfs.open(new TachyonURI(dirPath)), recDelete);\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    deleteTestUtil();\n    deleteFsMasterJournalLogs();\n    deleteTestUtil();\n  }","id":95174,"modified_method":"/**\n   * Test file and directory creation and deletion;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void deleteTest() throws Exception {\n    CreateDirectoryOptions recMkdir = CreateDirectoryOptions.defaults().setRecursive(true);\n    DeleteOptions recDelete =\n        new DeleteOptions.Builder().setRecursive(true).build();\n    for (int i = 0; i < 10; i ++) {\n      String dirPath = \"/i\" + i;\n      mTfs.createDirectory(new TachyonURI(dirPath), recMkdir);\n      for (int j = 0; j < 10; j ++) {\n        CreateFileOptions option = CreateFileOptions.defaults().setBlockSizeBytes((i + j + 1) * 64);\n        String filePath = dirPath + \"/j\" + j;\n        mTfs.createFile(new TachyonURI(filePath), option).close();\n        if (j >= 5) {\n          mTfs.delete(new TachyonURI(filePath), recDelete);\n        }\n      }\n      if (i >= 5) {\n        mTfs.delete(new TachyonURI(dirPath), recDelete);\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    deleteTestUtil();\n    deleteFsMasterJournalLogs();\n    deleteTestUtil();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test add checkpoint\n   *\n   * @throws Exception\n   */\n  @Test\n  public void loadMetadataTest() throws Exception {\n    String ufsRoot = PathUtils\n        .concatPath(mLocalTachyonCluster.getMasterTachyonConf().get(Constants.UNDERFS_ADDRESS));\n    UnderFileSystem ufs = UnderFileSystem.get(ufsRoot, mLocalTachyonCluster.getMasterTachyonConf());\n    ufs.create(ufsRoot + \"/xyz\");\n    FileInfo fileInfo = mTfs.getInfo(mTfs.open(new TachyonURI(\"/xyz\")));\n    mLocalTachyonCluster.stopTFS();\n    loadMetadataTestUtil(fileInfo);\n    deleteFsMasterJournalLogs();\n    loadMetadataTestUtil(fileInfo);\n  }","id":95175,"modified_method":"/**\n   * Test add checkpoint\n   *\n   * @throws Exception\n   */\n  @Test\n  public void loadMetadataTest() throws Exception {\n    String ufsRoot = PathUtils\n        .concatPath(mLocalTachyonCluster.getMasterTachyonConf().get(Constants.UNDERFS_ADDRESS));\n    UnderFileSystem ufs = UnderFileSystem.get(ufsRoot, mLocalTachyonCluster.getMasterTachyonConf());\n    ufs.create(ufsRoot + \"/xyz\");\n    URIStatus status = mTfs.getStatus(new TachyonURI(\"/xyz\"));\n    mLocalTachyonCluster.stopTFS();\n    loadMetadataTestUtil(status);\n    deleteFsMasterJournalLogs();\n    loadMetadataTestUtil(status);\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test file and directory creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void fileDirectoryTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.mkdir(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        OutStreamOptions option =\n            new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes((i + j + 1) * 64)\n                .build();\n        mTfs.getOutStream(new TachyonURI(\"/i\" + i + \"/j\" + j), option).close();\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    fileDirectoryTestUtil();\n    deleteFsMasterJournalLogs();\n    fileDirectoryTestUtil();\n  }","id":95176,"modified_method":"/**\n   * Test file and directory creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void fileDirectoryTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.createDirectory(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        CreateFileOptions option = CreateFileOptions.defaults().setBlockSizeBytes((i + j + 1) * 64);\n        mTfs.createFile(new TachyonURI(\"/i\" + i + \"/j\" + j), option).close();\n      }\n    }\n    mLocalTachyonCluster.stopTFS();\n    fileDirectoryTestUtil();\n    deleteFsMasterJournalLogs();\n    fileDirectoryTestUtil();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"private void loadMetadataTestUtil(FileInfo fileInfo)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(1, fsMaster.getFileInfoList(rootId).size());\n    Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/xyz\")) != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(fileInfo, fsMaster.getFileInfo(fsMaster.getFileId(new TachyonURI(\"/xyz\"))));\n    fsMaster.stop();\n  }","id":95177,"modified_method":"private void loadMetadataTestUtil(URIStatus status)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(1, fsMaster.getFileInfoList(rootId).size());\n    Assert.assertTrue(fsMaster.getFileId(new TachyonURI(\"/xyz\")) != IdUtils.INVALID_FILE_ID);\n    FileInfo fsMasterInfo = fsMaster.getFileInfo(fsMaster.getFileId(new TachyonURI(\"/xyz\")));\n    Assert.assertEquals(status, new URIStatus(fsMasterInfo));\n    fsMaster.stop();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test directory creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void directoryTest() throws Exception {\n    TachyonURI directoryPath = new TachyonURI(\"/xyz\");\n    mTfs.mkdir(directoryPath);\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(directoryPath));\n    mLocalTachyonCluster.stopTFS();\n    directoryTestUtil(fInfo);\n    deleteFsMasterJournalLogs();\n    directoryTestUtil(fInfo);\n  }","id":95178,"modified_method":"/**\n   * Test directory creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void directoryTest() throws Exception {\n    TachyonURI directoryPath = new TachyonURI(\"/xyz\");\n    mTfs.createDirectory(directoryPath);\n    URIStatus status = mTfs.getStatus(directoryPath);\n    mLocalTachyonCluster.stopTFS();\n    directoryTestUtil(status);\n    deleteFsMasterJournalLogs();\n    directoryTestUtil(status);\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test add block\n   *\n   * @throws Exception\n   */\n  @Test\n  public void addBlockTest() throws Exception {\n    TachyonURI uri = new TachyonURI(\"/xyz\");\n    OutStreamOptions options =\n        new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes(64).build();\n    FileOutStream os = mTfs.getOutStream(uri, options);\n    for (int k = 0; k < 1000; k ++) {\n      os.write(k);\n    }\n    os.close();\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(uri));\n    mLocalTachyonCluster.stopTFS();\n    addBlockTestUtil(fInfo);\n  }","id":95179,"modified_method":"/**\n   * Test add block\n   *\n   * @throws Exception\n   */\n  @Test\n  public void addBlockTest() throws Exception {\n    TachyonURI uri = new TachyonURI(\"/xyz\");\n    CreateFileOptions options = CreateFileOptions.defaults().setBlockSizeBytes(64);\n    FileOutStream os = mTfs.createFile(uri, options);\n    for (int k = 0; k < 1000; k ++) {\n      os.write(k);\n    }\n    os.close();\n    URIStatus status = mTfs.getStatus(uri);\n    mLocalTachyonCluster.stopTFS();\n    addBlockTestUtil(status);\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test completed Editlog deletion\n   *\n   * @throws Exception\n   */\n  @Test\n  public void completedEditLogDeletionTest() throws Exception {\n    for (int i = 0; i < 124; i ++) {\n      mTfs.getOutStream(new TachyonURI(\"/a\" + i),\n          new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes((i + 10) / 10 * 64)\n              .build()).close();\n    }\n    mLocalTachyonCluster.stopTFS();\n\n    String journalFolder =\n        FileSystemMaster.getJournalDirectory(mLocalTachyonCluster.getMaster().getJournalFolder());\n    Journal journal = new ReadWriteJournal(journalFolder);\n    String completedPath = journal.getCompletedDirectory();\n    Assert.assertTrue(\n        UnderFileSystem.get(completedPath, mMasterTachyonConf).list(completedPath).length > 1);\n    multiEditLogTestUtil();\n    Assert.assertTrue(\n        UnderFileSystem.get(completedPath, mMasterTachyonConf).list(completedPath).length <= 1);\n    multiEditLogTestUtil();\n  }","id":95180,"modified_method":"/**\n   * Test completed Editlog deletion\n   *\n   * @throws Exception\n   */\n  @Test\n  public void completedEditLogDeletionTest() throws Exception {\n    for (int i = 0; i < 124; i ++) {\n      mTfs.createFile(new TachyonURI(\"/a\" + i),\n          CreateFileOptions.defaults().setBlockSizeBytes((i + 10) / 10 * 64)).close();\n    }\n    mLocalTachyonCluster.stopTFS();\n\n    String journalFolder =\n        FileSystemMaster.getJournalDirectory(mLocalTachyonCluster.getMaster().getJournalFolder());\n    Journal journal = new ReadWriteJournal(journalFolder);\n    String completedPath = journal.getCompletedDirectory();\n    Assert.assertTrue(\n        UnderFileSystem.get(completedPath, mMasterTachyonConf).list(completedPath).length > 1);\n    multiEditLogTestUtil();\n    Assert.assertTrue(\n        UnderFileSystem.get(completedPath, mMasterTachyonConf).list(completedPath).length <= 1);\n    multiEditLogTestUtil();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test file and directory creation, and rename;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void renameTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.mkdir(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        OutStreamOptions option =\n            new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes((i + j + 1) * 64)\n                .build();\n        TachyonURI path = new TachyonURI(\"/i\" + i + \"/j\" + j);\n        mTfs.getOutStream(path, option).close();\n        mTfs.rename(mTfs.open(path), new TachyonURI(\"/i\" + i + \"/jj\" + j));\n      }\n      mTfs.rename(mTfs.open(new TachyonURI(\"/i\" + i)), new TachyonURI(\"/ii\" + i));\n    }\n    mLocalTachyonCluster.stopTFS();\n    renameTestUtil();\n    deleteFsMasterJournalLogs();\n    renameTestUtil();\n  }","id":95181,"modified_method":"/**\n   * Test file and directory creation, and rename;\n   *\n   * @throws Exception\n   */\n  @Test\n  public void renameTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      mTfs.createDirectory(new TachyonURI(\"/i\" + i));\n      for (int j = 0; j < 10; j ++) {\n        CreateFileOptions option = CreateFileOptions.defaults().setBlockSizeBytes((i + j + 1) * 64);\n        TachyonURI path = new TachyonURI(\"/i\" + i + \"/j\" + j);\n        mTfs.createFile(path, option).close();\n        mTfs.rename(path, new TachyonURI(\"/i\" + i + \"/jj\" + j));\n      }\n      mTfs.rename(new TachyonURI(\"/i\" + i), new TachyonURI(\"/ii\" + i));\n    }\n    mLocalTachyonCluster.stopTFS();\n    renameTestUtil();\n    deleteFsMasterJournalLogs();\n    renameTestUtil();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"private void directoryTestUtil(FileInfo fileInfo)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(1, fsMaster.getFileInfoList(rootId).size());\n    long fileId = fsMaster.getFileId(new TachyonURI(\"/xyz\"));\n    Assert.assertTrue(fileId != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(fileInfo, fsMaster.getFileInfo(fileId));\n    fsMaster.stop();\n  }","id":95182,"modified_method":"private void directoryTestUtil(URIStatus status)\n      throws IOException, InvalidPathException, FileDoesNotExistException {\n    FileSystemMaster fsMaster = createFsMasterFromJournal();\n    long rootId = fsMaster.getFileId(mRootUri);\n    Assert.assertTrue(rootId != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(1, fsMaster.getFileInfoList(rootId).size());\n    long fileId = fsMaster.getFileId(new TachyonURI(\"/xyz\"));\n    Assert.assertTrue(fileId != IdUtils.INVALID_FILE_ID);\n    Assert.assertEquals(status, new URIStatus(fsMaster.getFileInfo(fileId)));\n    fsMaster.stop();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test raw table creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void rawTableTest() throws Exception {\n    mTachyonRawTables.create(new TachyonURI(\"/xyz\"), 10);\n    FileInfo fInfo = mTfs.getInfo(mTfs.open(new TachyonURI(\"/xyz\")));\n    mLocalTachyonCluster.stopTFS();\n    rawTableTestUtil(fInfo);\n    deleteFsMasterJournalLogs();\n    rawTableTestUtil(fInfo);\n  }","id":95183,"modified_method":"/**\n   * Test raw table creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void rawTableTest() throws Exception {\n    mTachyonRawTables.create(new TachyonURI(\"/xyz\"), 10);\n    URIStatus status = mTfs.getStatus(new TachyonURI(\"/xyz\"));\n    mLocalTachyonCluster.stopTFS();\n    rawTableTestUtil(status);\n    deleteFsMasterJournalLogs();\n    rawTableTestUtil(status);\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void manyFileTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      OutStreamOptions option =\n          new OutStreamOptions.Builder(mMasterTachyonConf).setBlockSizeBytes((i + 1) * 64).build();\n      mTfs.getOutStream(new TachyonURI(\"/a\" + i), option).close();\n    }\n    mLocalTachyonCluster.stopTFS();\n    manyFileTestUtil();\n    deleteFsMasterJournalLogs();\n    manyFileTestUtil();\n  }","id":95184,"modified_method":"/**\n   * Test files creation.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void manyFileTest() throws Exception {\n    for (int i = 0; i < 10; i ++) {\n      CreateFileOptions option = CreateFileOptions.defaults().setBlockSizeBytes((i + 1) * 64);\n      mTfs.createFile(new TachyonURI(\"/a\" + i), option).close();\n    }\n    mLocalTachyonCluster.stopTFS();\n    manyFileTestUtil();\n    deleteFsMasterJournalLogs();\n    manyFileTestUtil();\n  }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * Keep creating files/tables until something crashes or fail to create. Record how many files/\n     * tables are created successfully.\n     */\n    @Override\n    public void run() {\n      try {\n        // This infinity loop will be broken if something crashes or fail to create. This is\n        // expected since the master will shutdown at a certain time.\n        while (true) {\n          if (mOpType == 0) {\n            try {\n              mTfs.getOutStream(new TachyonURI(TEST_FILE_DIR + mSuccessNum)).close();\n            } catch (IOException ioe) {\n              break;\n            }\n          } else if (mOpType == 1) {\n            // TODO(gene): Add this back when there is new RawTable client API.\n            // if (mTfs.createRawTable(new TachyonURI(TEST_TABLE_DIR + mSuccessNum), 1) == -1) {\n            // break;\n            // }\n          }\n          // The create operation may succeed at the master side but still returns false due to the\n          // shutdown. So the mSuccessNum may be less than the actual success number.\n          mSuccessNum ++;\n          CommonUtils.sleepMs(100);\n        }\n      } catch (Exception e) {\n        // Something crashed. Stop the thread.\n      }\n    }","id":95185,"modified_method":"/**\n     * Keep creating files/tables until something crashes or fail to create. Record how many files/\n     * tables are created successfully.\n     */\n    @Override\n    public void run() {\n      try {\n        // This infinity loop will be broken if something crashes or fail to create. This is\n        // expected since the master will shutdown at a certain time.\n        while (true) {\n          if (mOpType == 0) {\n            try {\n              mTfs.createFile(new TachyonURI(TEST_FILE_DIR + mSuccessNum)).close();\n            } catch (IOException ioe) {\n              break;\n            }\n          } else if (mOpType == 1) {\n            // TODO(gene): Add this back when there is new RawTable client API.\n            // if (mTfs.createRawTable(new TachyonURI(TEST_TABLE_DIR + mSuccessNum), 1) == -1) {\n            // break;\n            // }\n          }\n          // The create operation may succeed at the master side but still returns false due to the\n          // shutdown. So the mSuccessNum may be less than the actual success number.\n          mSuccessNum ++;\n          CommonUtils.sleepMs(100);\n        }\n      } catch (Exception e) {\n        // Something crashed. Stop the thread.\n      }\n    }","commit_id":"b6e49b11494bc88d2f9053c6bab99a029d5b8621","url":"https://github.com/amplab/tachyon"},{"original_method":"@Nullable\n  private static String getNamespace(@NotNull final XmlAttributeValue xmlAttributeValue) {\n    final XmlTag tag = PsiTreeUtil.getParentOfType(xmlAttributeValue, XmlTag.class);\n    if (tag == null) {\n      return null;\n    }\n\n    final XmlAttribute namespaceAttribute = tag.getAttribute(\"namespace\");\n    return namespaceAttribute != null ? namespaceAttribute.getValue() : null;\n  }","id":95186,"modified_method":"@Nullable\n  private static String getNamespace(@NotNull final XmlAttributeValue xmlAttributeValue) {\n    final XmlTag tag = PsiTreeUtil.getParentOfType(xmlAttributeValue, XmlTag.class);\n    if (tag == null) {\n      return null;\n    }\n\n    return tag.getAttributeValue(\"namespace\");\n  }","commit_id":"e173708bbf657173f787ae98864946bc6d20416d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void loadSdkName(final FlashBuilderProject project, final Element compilerElement) {\n    final Attribute flexSdkAttr = compilerElement.getAttribute(FLEX_SDK_ATTR);\n    if (flexSdkAttr != null) {\n      project.setSdkName(flexSdkAttr.getValue());\n    }\n  }","id":95187,"modified_method":"private static void loadSdkName(final FlashBuilderProject project, final Element compilerElement) {\n    final String sdkName = compilerElement.getAttributeValue(FLEX_SDK_ATTR);\n    if (!StringUtil.isEmptyOrSpaces(sdkName)) {\n      project.setSdkName(sdkName);\n    }\n  }","commit_id":"afbde86b07511998203e7df07ba79ca93830bbc0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void loadDependenciesAndCheckIfSdkUsed(final FlashBuilderProject project,\n                                                        final Element compilerElement,\n                                                        final Map<String, String> pathReplacementMap) {\n    //noinspection unchecked\n    for (final Element libraryPathElement : ((Iterable<Element>)compilerElement.getChildren(LIBRARY_PATH_TAG))) {\n      //noinspection unchecked\n      for (final Element libraryPathEntryElement : ((Iterable<Element>)libraryPathElement.getChildren(LIBRARY_PATH_ENTRY_TAG))) {\n        final Attribute libraryKindAttr = libraryPathEntryElement.getAttribute(LIBRARY_KIND_ATTR);\n        final String libraryKind = libraryKindAttr != null ? libraryKindAttr.getValue() : SWC_FILE_KIND;\n        if (libraryKind.equals(USE_SDK_KIND)) {\n          project.setSdkUsed(true);\n        }\n        else {\n          final String libraryPath = libraryPathEntryElement.getAttributeValue(PATH_ATTR);\n          if (!StringUtil.isEmptyOrSpaces(libraryPath)) {\n            if (SWC_FILE_KIND.equals(libraryKind) || SWC_FOLDER_KIND.equals(libraryKind) || ANE_KIND.equals(libraryKind)) {\n              // TODO: parse sources\n              final Collection<String> librarySourcePaths = new ArrayList<String>();\n\n              final String replacedPath = pathReplacementMap.get(libraryPath);\n              String path = replacedPath != null ? replacedPath : libraryPath;\n\n              if (path.startsWith(FLEXUNIT_LIB_MACRO)) {\n                final String flexUnitFrameworkPath = guessFlexUnitFrameworkPath();\n                if (flexUnitFrameworkPath != null) {\n                  path = flexUnitFrameworkPath + \"/libs\" + path.substring(FLEXUNIT_LIB_MACRO.length());\n                }\n              }\n              else if (path.equals(FLEXUNIT_LOCALE_MACRO)) {\n                final String flexUnitFrameworkPath = guessFlexUnitFrameworkPath();\n                if (flexUnitFrameworkPath != null) {\n                  path = flexUnitFrameworkPath + \"/locale/version4locale/FlexUnitTestRunner_rb.swc\";\n                }\n              }\n\n              project.addLibraryPathAndSources(FileUtil.toSystemIndependentName(path),librarySourcePaths);\n            }\n          }\n        }\n      }\n    }\n  }","id":95188,"modified_method":"private static void loadDependenciesAndCheckIfSdkUsed(final FlashBuilderProject project,\n                                                        final Element compilerElement,\n                                                        final Map<String, String> pathReplacementMap) {\n    //noinspection unchecked\n    for (final Element libraryPathElement : ((Iterable<Element>)compilerElement.getChildren(LIBRARY_PATH_TAG))) {\n      //noinspection unchecked\n      for (final Element libraryPathEntryElement : ((Iterable<Element>)libraryPathElement.getChildren(LIBRARY_PATH_ENTRY_TAG))) {\n        final String libraryKind = StringUtil.notNullize(libraryPathEntryElement.getAttributeValue(LIBRARY_KIND_ATTR), SWC_FILE_KIND);\n        if (libraryKind.equals(USE_SDK_KIND)) {\n          project.setSdkUsed(true);\n        }\n        else {\n          final String libraryPath = libraryPathEntryElement.getAttributeValue(PATH_ATTR);\n          if (!StringUtil.isEmptyOrSpaces(libraryPath)) {\n            if (SWC_FILE_KIND.equals(libraryKind) || SWC_FOLDER_KIND.equals(libraryKind) || ANE_KIND.equals(libraryKind)) {\n              // TODO: parse sources\n              final Collection<String> librarySourcePaths = new ArrayList<String>();\n\n              final String replacedPath = pathReplacementMap.get(libraryPath);\n              String path = replacedPath != null ? replacedPath : libraryPath;\n\n              if (path.startsWith(FLEXUNIT_LIB_MACRO)) {\n                final String flexUnitFrameworkPath = guessFlexUnitFrameworkPath();\n                if (flexUnitFrameworkPath != null) {\n                  path = flexUnitFrameworkPath + \"/libs\" + path.substring(FLEXUNIT_LIB_MACRO.length());\n                }\n              }\n              else if (path.equals(FLEXUNIT_LOCALE_MACRO)) {\n                final String flexUnitFrameworkPath = guessFlexUnitFrameworkPath();\n                if (flexUnitFrameworkPath != null) {\n                  path = flexUnitFrameworkPath + \"/locale/version4locale/FlexUnitTestRunner_rb.swc\";\n                }\n              }\n\n              project.addLibraryPathAndSources(FileUtil.toSystemIndependentName(path), librarySourcePaths);\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"afbde86b07511998203e7df07ba79ca93830bbc0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void loadTargetPlayerVersion(final FlashBuilderProject project, final Element compilerElement) {\n    final Attribute targetPlayerVersionAttr = compilerElement.getAttribute(TARGET_PLAYER_VERSION_ATTR);\n    if (targetPlayerVersionAttr != null) {\n      final String version = targetPlayerVersionAttr.getValue();\n      if (!version.startsWith(\"0\")) {\n        project.setTargetPlayerVersion(version);\n      }\n    }\n  }","id":95189,"modified_method":"private static void loadTargetPlayerVersion(final FlashBuilderProject project, final Element compilerElement) {\n    final String version = compilerElement.getAttributeValue(TARGET_PLAYER_VERSION_ATTR);\n    if (version != null && !version.startsWith(\"0\")) {\n      project.setTargetPlayerVersion(version);\n    }\n  }","commit_id":"afbde86b07511998203e7df07ba79ca93830bbc0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void loadAdditionalCompilerArguments(final FlashBuilderProject project, final Element compilerElement) {\n    final Attribute additionalCompilerArgumentsAttr = compilerElement.getAttribute(ADDITIONAL_COMPILER_ARGUMENTS_ATTR);\n    if (additionalCompilerArgumentsAttr != null) {\n      project.setAdditionalCompilerOptions(\n        additionalCompilerArgumentsAttr.getValue().replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' '));\n    }\n  }","id":95190,"modified_method":"private static void loadAdditionalCompilerArguments(final FlashBuilderProject project, final Element compilerElement) {\n    final String arguments = compilerElement.getAttributeValue(ADDITIONAL_COMPILER_ARGUMENTS_ATTR);\n    if (!StringUtil.isEmptyOrSpaces(arguments)) {\n      project.setAdditionalCompilerOptions(arguments.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' '));\n    }\n  }","commit_id":"afbde86b07511998203e7df07ba79ca93830bbc0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void initializeSdksFromFBInstallation() {\n    final String installationPath = findFBInstallationPath();\n    if (installationPath == null) return;\n    final File sdksDir = new File(installationPath, SDKS_FOLDER);\n    if (!sdksDir.isDirectory()) return;\n\n    String maxVersion = \"0\";\n    for (File sdkDir : sdksDir.listFiles()) {\n      if (!sdkDir.isDirectory()) continue;\n      final File descriptionFile = new File(sdkDir, \"flex-sdk-description.xml\");\n      if (!descriptionFile.isFile()) return;\n\n      final String nameElement = \"<flex-sdk-description><name>\";\n      final String versionElement = \"<flex-sdk-description><version>\";\n      FileInputStream is = null;\n      try {\n        //noinspection IOResourceOpenedButNotSafelyClosed\n        is = new FileInputStream(descriptionFile);\n        final Map<String, List<String>> info = FlexUtils.findXMLElements(is, Arrays.asList(nameElement, versionElement));\n\n        final List<String> nameInfo = info.get(nameElement);\n        if (nameInfo.isEmpty()) continue;\n\n        mySdkNameToRootPath.put(nameInfo.get(0), FileUtil.toSystemIndependentName(sdkDir.getPath()));\n\n        final List<String> versionInfo = info.get(versionElement);\n        if (versionInfo.isEmpty()) continue;\n\n        final String version = versionInfo.get(0);\n        if (StringUtil.compareVersionNumbers(version, maxVersion) > 0) {\n          maxVersion = version;\n          mySdkNameToRootPath.put(DEFAULT_SDK_NAME, FileUtil.toSystemIndependentName(sdkDir.getPath()));\n        }\n      }\n      catch (IOException ignore) {/**/}\n      finally {\n        if (is != null) {\n          try {\n            is.close();\n          }\n          catch (IOException ignore) {/**/}\n        }\n      }\n    }\n  }","id":95191,"modified_method":"private void initializeSdksFromFBInstallation(final @NotNull String fbInstallationPath) {\n    final File sdksDir = new File(fbInstallationPath, SDKS_FOLDER);\n    if (!sdksDir.isDirectory()) return;\n\n    String maxVersion = \"0\";\n    for (File sdkDir : sdksDir.listFiles()) {\n      if (!sdkDir.isDirectory()) continue;\n      final File descriptionFile = new File(sdkDir, \"flex-sdk-description.xml\");\n      if (!descriptionFile.isFile()) return;\n\n      final String nameElement = \"<flex-sdk-description><name>\";\n      final String versionElement = \"<flex-sdk-description><version>\";\n      FileInputStream is = null;\n      try {\n        //noinspection IOResourceOpenedButNotSafelyClosed\n        is = new FileInputStream(descriptionFile);\n        final Map<String, List<String>> info = FlexUtils.findXMLElements(is, Arrays.asList(nameElement, versionElement));\n\n        final List<String> nameInfo = info.get(nameElement);\n        if (nameInfo.isEmpty()) continue;\n\n        mySdkNameToRootPath.put(nameInfo.get(0), FileUtil.toSystemIndependentName(sdkDir.getPath()));\n\n        final List<String> versionInfo = info.get(versionElement);\n        if (versionInfo.isEmpty()) continue;\n\n        final String version = versionInfo.get(0);\n        if (StringUtil.compareVersionNumbers(version, maxVersion) > 0) {\n          maxVersion = version;\n          mySdkNameToRootPath.put(DEFAULT_SDK_NAME, FileUtil.toSystemIndependentName(sdkDir.getPath()));\n        }\n      }\n      catch (IOException ignore) {/**/}\n      finally {\n        if (is != null) {\n          try {\n            is.close();\n          }\n          catch (IOException ignore) {/**/}\n        }\n      }\n    }\n  }","commit_id":"afbde86b07511998203e7df07ba79ca93830bbc0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public Sdk findSdk(final FlashBuilderProject fbProject) {\n    if (!myInitialized) {\n      initialize();\n      myInitialized = true;\n    }\n\n    final String sdkHome = mySdkNameToRootPath.get(fbProject.getSdkName());\n    if (sdkHome != null) return FlexSdkUtils.createOrGetSdk(FlexSdkType2.getInstance(), sdkHome);\n\n    if (myDialogWasShown) return mySdk;\n\n    final SelectFlexSdkDialog dialog = new SelectFlexSdkDialog(myProject,\n                                                               FlexBundle.message(\"flash.builder.project.import.title\"),\n                                                               FlexBundle.message(\"sdk.for.imported.projects\", myAllProjects.size()));\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      dialog.show();\n    }\n    else {\n      dialog.close(DialogWrapper.CANCEL_EXIT_CODE);\n    }\n    myDialogWasShown = true;\n    mySdk = dialog.isOK() ? dialog.getSdk() : null;\n    return mySdk;\n  }","id":95192,"modified_method":"@Nullable\n  public Sdk findSdk(final FlashBuilderProject fbProject) {\n    if (!myInitialized) {\n      initialize();\n      myInitialized = true;\n    }\n\n    if (fbProject.isPureActionScript() && myAirSdkHome != null) {\n      return FlexSdkUtils.createOrGetSdk(FlexSdkType2.getInstance(), myAirSdkHome);\n    }\n\n    final String sdkHome = mySdkNameToRootPath.get(fbProject.getSdkName());\n    if (sdkHome != null) return FlexSdkUtils.createOrGetSdk(FlexSdkType2.getInstance(), sdkHome);\n\n    if (myDialogWasShown) return mySdk;\n\n    final SelectFlexSdkDialog dialog = new SelectFlexSdkDialog(myProject,\n                                                               FlexBundle.message(\"flash.builder.project.import.title\"),\n                                                               FlexBundle.message(\"sdk.for.imported.projects\", myAllProjects.size()));\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      dialog.show();\n    }\n    else {\n      dialog.close(DialogWrapper.CANCEL_EXIT_CODE);\n    }\n    myDialogWasShown = true;\n    mySdk = dialog.isOK() ? dialog.getSdk() : null;\n    return mySdk;\n  }","commit_id":"afbde86b07511998203e7df07ba79ca93830bbc0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void initialize() {\n    // first look for SDKs in installation, then in workspace. Some can be overwritten by workspace-specific ones.\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      initializeSdksFromFBInstallation();\n    }\n\n    myWorkspacePath = findWorkspacePath();\n    if (myWorkspacePath != null) {\n      initSdksConfiguredInWorkspace(myWorkspacePath);\n    }\n  }","id":95193,"modified_method":"private void initialize() {\n    final String fbInstallationPath = findFBInstallationPath();\n\n    if (fbInstallationPath != null && !ApplicationManager.getApplication().isUnitTestMode()) {\n      initializeAirSdk(fbInstallationPath);\n\n      // first look for SDKs in installation, then in workspace. Some can be overwritten by workspace-specific ones.\n      initializeSdksFromFBInstallation(fbInstallationPath);\n    }\n\n    myWorkspacePath = findWorkspacePath();\n    if (myWorkspacePath != null) {\n      initSdksConfiguredInWorkspace(myWorkspacePath);\n    }\n  }","commit_id":"afbde86b07511998203e7df07ba79ca93830bbc0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Generate the statistic table\n     *\n     * @param locale\n     * @param sink\n     * @param dependencyMap\n     */\n    private void generateStats( Locale locale, Sink sink, Map dependencyMap )\n    {\n        int depCount = dependencyMap.size();\n        int artifactCount = 0;\n        int snapshotCount = 0;\n\n        Iterator it = dependencyMap.values().iterator();\n        while ( it.hasNext() )\n        {\n            List depList = (List) it.next();\n            Map artifactMap = getSortedUniqueArtifactMap( depList );\n            snapshotCount += countSnapshots( artifactMap );\n            artifactCount += artifactMap.size();\n        }\n\n        int convergence = (int) ( ( (double) depCount / (double) artifactCount ) * PERCENTAGE );\n\n        // To know the header cell width\n        List l = new ArrayList();\n        l.add( getI18nString( locale, \"stats.subprojects\" ) );\n        l.add( getI18nString( locale, \"stats.dependencies\" ) );\n        l.add( getI18nString( locale, \"stats.artifacts\" ) );\n        l.add( getI18nString( locale, \"stats.snapshots\" ) );\n        l.add( getI18nString( locale, \"stats.convergence\" ) );\n        l.add( getI18nString( locale, \"stats.readyrelease\" ) );\n\n        String biggest = getBiggestString( l );\n        String headerCellWidth = getMavenTableHeaderCell( biggest ) + \"px\";\n\n        // Create report\n        sink.table();\n        sink.tableCaption();\n        sink.bold();\n        sink.text( getI18nString( locale, \"stats.caption\" ) );\n        sink.bold_();\n        sink.tableCaption_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( headerCellWidth );\n        sink.text( getI18nString( locale, \"stats.subprojects\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( reactorProjects.size() ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( headerCellWidth );\n        sink.text( getI18nString( locale, \"stats.dependencies\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( depCount ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( headerCellWidth );\n        sink.text( getI18nString( locale, \"stats.artifacts\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( artifactCount ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( headerCellWidth );\n        sink.text( getI18nString( locale, \"stats.snapshots\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( snapshotCount ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( headerCellWidth );\n        sink.text( getI18nString( locale, \"stats.convergence\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        if ( convergence < PERCENTAGE )\n        {\n            iconError( sink );\n        }\n        else\n        {\n            iconSuccess( sink );\n        }\n        sink.nonBreakingSpace();\n        sink.bold();\n        sink.text( String.valueOf( convergence ) + \"%\" );\n        sink.bold_();\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( headerCellWidth );\n        sink.text( getI18nString( locale, \"stats.readyrelease\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        if ( convergence >= PERCENTAGE && snapshotCount <= 0 )\n        {\n            iconSuccess( sink );\n            sink.nonBreakingSpace();\n            sink.bold();\n            sink.text( getI18nString( locale, \"stats.readyrelease.success\" ) );\n            sink.bold_();\n        }\n        else\n        {\n            iconError( sink );\n            sink.nonBreakingSpace();\n            sink.bold();\n            sink.text( getI18nString( locale, \"stats.readyrelease.error\" ) );\n            sink.bold_();\n            if ( convergence < PERCENTAGE )\n            {\n                sink.lineBreak();\n                sink.text( getI18nString( locale, \"stats.readyrelease.error.convergence\" ) );\n            }\n            if ( snapshotCount > 0 )\n            {\n                sink.lineBreak();\n                sink.text( getI18nString( locale, \"stats.readyrelease.error.snapshots\" ) );\n            }\n        }\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.table_();\n    }","id":95194,"modified_method":"/**\n     * Generate the statistic table\n     *\n     * @param locale\n     * @param sink\n     * @param dependencyMap\n     */\n    private void generateStats( Locale locale, Sink sink, Map dependencyMap )\n    {\n        int depCount = dependencyMap.size();\n        int artifactCount = 0;\n        int snapshotCount = 0;\n\n        Iterator it = dependencyMap.values().iterator();\n        while ( it.hasNext() )\n        {\n            List depList = (List) it.next();\n            Map artifactMap = getSortedUniqueArtifactMap( depList );\n            snapshotCount += countSnapshots( artifactMap );\n            artifactCount += artifactMap.size();\n        }\n\n        int convergence = (int) ( ( (double) depCount / (double) artifactCount ) * PERCENTAGE );\n\n        // Create report\n        sink.table();\n        sink.tableCaption();\n        sink.bold();\n        sink.text( getI18nString( locale, \"stats.caption\" ) );\n        sink.bold_();\n        sink.tableCaption_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( );\n        sink.text( getI18nString( locale, \"stats.subprojects\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( reactorProjects.size() ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( );\n        sink.text( getI18nString( locale, \"stats.dependencies\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( depCount ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( );\n        sink.text( getI18nString( locale, \"stats.artifacts\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( artifactCount ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( );\n        sink.text( getI18nString( locale, \"stats.snapshots\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        sink.text( String.valueOf( snapshotCount ) );\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( );\n        sink.text( getI18nString( locale, \"stats.convergence\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        if ( convergence < PERCENTAGE )\n        {\n            iconError( sink );\n        }\n        else\n        {\n            iconSuccess( sink );\n        }\n        sink.nonBreakingSpace();\n        sink.bold();\n        sink.text( String.valueOf( convergence ) + \"%\" );\n        sink.bold_();\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.tableRow();\n        sink.tableHeaderCell( );\n        sink.text( getI18nString( locale, \"stats.readyrelease\" ) );\n        sink.tableHeaderCell_();\n        sink.tableCell();\n        if ( convergence >= PERCENTAGE && snapshotCount <= 0 )\n        {\n            iconSuccess( sink );\n            sink.nonBreakingSpace();\n            sink.bold();\n            sink.text( getI18nString( locale, \"stats.readyrelease.success\" ) );\n            sink.bold_();\n        }\n        else\n        {\n            iconError( sink );\n            sink.nonBreakingSpace();\n            sink.bold();\n            sink.text( getI18nString( locale, \"stats.readyrelease.error\" ) );\n            sink.bold_();\n            if ( convergence < PERCENTAGE )\n            {\n                sink.lineBreak();\n                sink.text( getI18nString( locale, \"stats.readyrelease.error.convergence\" ) );\n            }\n            if ( snapshotCount > 0 )\n            {\n                sink.lineBreak();\n                sink.text( getI18nString( locale, \"stats.readyrelease.error.snapshots\" ) );\n            }\n        }\n        sink.tableCell_();\n        sink.tableRow_();\n\n        sink.table_();\n    }","commit_id":"9e25ccf419b332849516bc6a088077e3c4adf7b8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate the detail table for a given dependency\n     *\n     * @param sink\n     * @param depList\n     * @param cellWidth\n     */\n    private void generateDependencyDetails( Sink sink, List depList, int cellWidth )\n    {\n        sink.table();\n\n        Map artifactMap = getSortedUniqueArtifactMap( depList );\n\n        sink.tableRow();\n\n        sink.tableCell( \"15px\" ); // according /images/icon_success_sml.gif and /images/icon_error_sml.gif\n        if ( artifactMap.size() > 1 )\n        {\n            iconError( sink );\n        }\n        else\n        {\n            iconSuccess( sink );\n        }\n        sink.tableCell_();\n\n        sink.tableCell();\n\n        sink.table();\n\n        Iterator it = artifactMap.keySet().iterator();\n        while ( it.hasNext() )\n        {\n            String version = (String) it.next();\n            sink.tableRow();\n            sink.tableCell( String.valueOf( cellWidth ) + \"px\" );\n            sink.text( version );\n            sink.tableCell_();\n\n            sink.tableCell();\n            generateVersionDetails( sink, artifactMap, version );\n            sink.tableCell_();\n\n            sink.tableRow_();\n        }\n        sink.table_();\n        sink.tableCell_();\n\n        sink.tableRow_();\n\n        sink.table_();\n    }","id":95195,"modified_method":"/**\n     * Generate the detail table for a given dependency\n     *\n     * @param sink\n     * @param depList\n     */\n    private void generateDependencyDetails( Sink sink, List depList )\n    {\n        sink.table();\n\n        Map artifactMap = getSortedUniqueArtifactMap( depList );\n\n        sink.tableRow();\n\n        sink.tableCell( );\n        if ( artifactMap.size() > 1 )\n        {\n            iconError( sink );\n        }\n        else\n        {\n            iconSuccess( sink );\n        }\n        sink.tableCell_();\n\n        sink.tableCell();\n\n        sink.table();\n\n        Iterator it = artifactMap.keySet().iterator();\n        while ( it.hasNext() )\n        {\n            String version = (String) it.next();\n            sink.tableRow();\n            sink.tableCell( \"25%\" );\n            sink.text( version );\n            sink.tableCell_();\n\n            sink.tableCell();\n            generateVersionDetails( sink, artifactMap, version );\n            sink.tableCell_();\n\n            sink.tableRow_();\n        }\n        sink.table_();\n        sink.tableCell_();\n\n        sink.tableRow_();\n\n        sink.table_();\n    }","commit_id":"9e25ccf419b332849516bc6a088077e3c4adf7b8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate the legend table\n     *\n     * @param locale\n     * @param sink\n     */\n    private void generateLegend( Locale locale, Sink sink )\n    {\n        sink.table();\n        sink.tableCaption();\n        sink.bold();\n        sink.text( getI18nString( locale, \"legend\" ) );\n        sink.bold_();\n        sink.tableCaption_();\n\n        sink.tableRow();\n\n        sink.tableCell( \"15px\" ); // according /images/icon_success_sml.gif\n        iconSuccess( sink );\n        sink.tableCell_();\n        sink.tableCell();\n        sink.text( getI18nString( locale, \"legend.shared\" ) );\n        sink.tableCell_();\n\n        sink.tableRow_();\n\n        sink.tableRow();\n\n        sink.tableCell( \"15px\" ); // according /images/icon_error_sml.gif\n        iconError( sink );\n        sink.tableCell_();\n        sink.tableCell();\n        sink.text( getI18nString( locale, \"legend.different\" ) );\n        sink.tableCell_();\n\n        sink.tableRow_();\n\n        sink.table_();\n    }","id":95196,"modified_method":"/**\n     * Generate the legend table\n     *\n     * @param locale\n     * @param sink\n     */\n    private void generateLegend( Locale locale, Sink sink )\n    {\n        sink.table();\n        sink.tableCaption();\n        sink.bold();\n        sink.text( getI18nString( locale, \"legend\" ) );\n        sink.bold_();\n        sink.tableCaption_();\n\n        sink.tableRow();\n\n        sink.tableCell( );\n        iconSuccess( sink );\n        sink.tableCell_();\n        sink.tableCell();\n        sink.text( getI18nString( locale, \"legend.shared\" ) );\n        sink.tableCell_();\n\n        sink.tableRow_();\n\n        sink.tableRow();\n\n        sink.tableCell( );\n        iconError( sink );\n        sink.tableCell_();\n        sink.tableCell();\n        sink.text( getI18nString( locale, \"legend.different\" ) );\n        sink.tableCell_();\n\n        sink.tableRow_();\n\n        sink.table_();\n    }","commit_id":"9e25ccf419b332849516bc6a088077e3c4adf7b8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Generate the convergenec table for all dependencies\n     *\n     * @param locale\n     * @param sink\n     * @param dependencyMap\n     */\n    private void generateConvergence( Locale locale, Sink sink, Map dependencyMap )\n    {\n        sink.section2();\n\n        sink.sectionTitle2();\n        sink.text( getI18nString( locale, \"convergence.caption\" ) );\n        sink.sectionTitle2_();\n\n        // To know the cell width for version\n        String biggestVersion = getBiggestStringVersion( dependencyMap );\n        int cellWidth = getMavenTableCell( biggestVersion );\n\n        Iterator it = dependencyMap.keySet().iterator();\n        while ( it.hasNext() )\n        {\n            String key = (String) it.next();\n            List depList = (List) dependencyMap.get( key );\n\n            sink.section3();\n            sink.sectionTitle3();\n            sink.text( key );\n            sink.sectionTitle3_();\n\n            generateDependencyDetails( sink, depList, cellWidth );\n\n            sink.section3_();\n        }\n\n        sink.section2_();\n    }","id":95197,"modified_method":"/**\n     * Generate the convergenec table for all dependencies\n     *\n     * @param locale\n     * @param sink\n     * @param dependencyMap\n     */\n    private void generateConvergence( Locale locale, Sink sink, Map dependencyMap )\n    {\n        sink.section2();\n\n        sink.sectionTitle2();\n        sink.text( getI18nString( locale, \"convergence.caption\" ) );\n        sink.sectionTitle2_();\n\n        Iterator it = dependencyMap.keySet().iterator();\n        while ( it.hasNext() )\n        {\n            String key = (String) it.next();\n            List depList = (List) dependencyMap.get( key );\n\n            sink.section3();\n            sink.sectionTitle3();\n            sink.text( key );\n            sink.sectionTitle3_();\n\n            generateDependencyDetails( sink, depList );\n\n            sink.section3_();\n        }\n\n        sink.section2_();\n    }","commit_id":"9e25ccf419b332849516bc6a088077e3c4adf7b8","url":"https://github.com/apache/maven-plugins"},{"original_method":"public CopyObjectResponseType copyObject(CopyObjectType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tCopyObjectResponseType reply = (CopyObjectResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString sourceBucket = request.getSourceBucket();\n\t\tString sourceKey = request.getSourceObject();\n\t\tString sourceVersionId = request.getSourceVersionId();\n\t\tString destinationBucket = request.getDestinationBucket();\n\t\tString destinationKey = request.getDestinationObject();\n\t\tString metadataDirective = request.getMetadataDirective();\n\t\tAccessControlListType accessControlList = request\n\t\t\t\t.getAccessControlList();\n\n\t\tString copyIfMatch = request.getCopySourceIfMatch();\n\t\tString copyIfNoneMatch = request.getCopySourceIfNoneMatch();\n\t\tDate copyIfUnmodifiedSince = request.getCopySourceIfUnmodifiedSince();\n\t\tDate copyIfModifiedSince = request.getCopySourceIfModifiedSince();\n\n\t\tif (metadataDirective == null)\n\t\t\tmetadataDirective = \"COPY\";\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(sourceBucket);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(sourceBucket,\n\t\t\t\t\tsourceKey);\n\t\t\tsearchObjectInfo.setVersionId(sourceVersionId);\n\t\t\tif(sourceVersionId == null)\n\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\tObjectInfo sourceObjectInfo = objectInfos.get(0);\n\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\tsourceObjectInfo.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t\t(sourceObjectInfo.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECT,\n\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\tPolicySpec.objectFullName(sourceBucket, sourceKey),\n\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\tif (copyIfMatch != null) {\n\t\t\t\t\t\tif (!copyIfMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfMatch: \" + copyIfMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfNoneMatch != null) {\n\t\t\t\t\t\tif (copyIfNoneMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfNoneMatch: \"\n\t\t\t\t\t\t\t\t\t+ copyIfNoneMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfUnmodifiedSince != null) {\n\t\t\t\t\t\tlong unmodifiedTime = copyIfUnmodifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified()\n\t\t\t\t\t\t\t\t.getTime();\n\t\t\t\t\t\tif (unmodifiedTime < objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfUnmodifiedSince: \"\n\t\t\t\t\t\t\t\t\t+ copyIfUnmodifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfModifiedSince != null) {\n\t\t\t\t\t\tlong modifiedTime = copyIfModifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified()\n\t\t\t\t\t\t\t\t.getTime();\n\t\t\t\t\t\tif (modifiedTime > objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfModifiedSince: \"\n\t\t\t\t\t\t\t\t\t+ copyIfModifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBucketInfo destinationBucketInfo = new BucketInfo(\n\t\t\t\t\t\t\tdestinationBucket);\n\t\t\t\t\tList<BucketInfo> destinationBuckets = db\n\t\t\t\t\t\t\t.query(destinationBucketInfo);\n\t\t\t\t\tif (destinationBuckets.size() > 0) {\n\t\t\t\t\t\tBucketInfo foundDestinationBucketInfo = destinationBuckets.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\t\tfoundDestinationBucketInfo.canWrite(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(foundDestinationBucketInfo.isGlobalWrite() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\t\t\t\tdestinationBucket,\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\t// all ok\n\t\t\t\t\t\t\tString destinationVersionId = sourceVersionId;\n\t\t\t\t\t\t\tObjectInfo destinationObjectInfo = null;\n\t\t\t\t\t\t\tString destinationObjectName;\n\t\t\t\t\t\t\tObjectInfo destSearchObjectInfo = new ObjectInfo(\n\t\t\t\t\t\t\t\t\tdestinationBucket, destinationKey);\n\t\t\t\t\t\t\tif(foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\tif(sourceVersionId != null)\n\t\t\t\t\t\t\t\t\tdestinationVersionId = sourceVersionId;\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tdestinationVersionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdestinationVersionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestSearchObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tList<ObjectInfo> destinationObjectInfos = dbObject\n\t\t\t\t\t\t\t\t\t.query(destSearchObjectInfo);\n\t\t\t\t\t\t\tif (destinationObjectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo = destinationObjectInfos\n\t\t\t\t\t\t\t\t\t\t.get(0);\n\t\t\t\t\t\t\t\tif (!destinationObjectInfo.canWrite(account.getAccountNumber())) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\",\n\t\t\t\t\t\t\t\t\t\t\tdestinationKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tboolean addNew = false;\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (destinationObjectInfo == null) {\n\t\t\t\t\t\t\t\t// not found. create a new one\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\t\t\t\tPermissions.isAuthorized(PolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\tsourceBucket,\n\t\t\t\t\t\t\t\t\t\t\t\tctx.getAccount(),\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\tctx.getUser()) &&\n\t\t\t\t\t\t\t\t\t\t\t\tPermissions.canAllocate(PolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceBucket,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tctx.getUser(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceObjectInfo.getSize()))) {\n\t\t\t\t\t\t\t\t\taddNew = true;\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo = new ObjectInfo();\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.setBucketName(destinationBucket);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.setObjectKey(destinationKey);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(),\n\t\t\t\t\t\t\t\t\t\t\tgrantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.setObjectName(UUID.randomUUID().toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\t\t\t\tdestinationObjectInfo.canWriteACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t\t\t(destinationObjectInfo.isGlobalWriteACP() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECTACL,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(destinationBucket, destinationKey),\n\t\t\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(),\n\t\t\t\t\t\t\t\t\t\t\tgrantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestinationObjectInfo.setSize(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getSize());\n\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t.setStorageClass(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getStorageClass());\n\t\t\t\t\t\t\tdestinationObjectInfo.setOwnerId(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getOwnerId());\n\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t.setContentType(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getContentType());\n\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t.setContentDisposition(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getContentDisposition());\n\t\t\t\t\t\t\tString etag = sourceObjectInfo.getEtag();\n\t\t\t\t\t\t\tDate lastModified = sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getLastModified();\n\t\t\t\t\t\t\tdestinationObjectInfo.setEtag(etag);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLastModified(lastModified);\n\t\t\t\t\t\t\tdestinationObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLast(true);\n\t\t\t\t\t\t\tdestinationObjectInfo.setDeleted(false);\n\t\t\t\t\t\t\tif (!metadataDirective.equals(\"REPLACE\")) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t.setMetaData(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t\t.cloneMetaData());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tList<MetaDataEntry> metaData = request\n\t\t\t\t\t\t\t\t\t\t.getMetaData();\n\t\t\t\t\t\t\t\tif (metaData != null)\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.replaceMetaData(metaData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tString sourceObjectName = sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getObjectName();\n\t\t\t\t\t\t\tdestinationObjectName = destinationObjectInfo\n\t\t\t\t\t\t\t\t\t.getObjectName();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstorageManager.copyObject(sourceBucket,\n\t\t\t\t\t\t\t\t\t\tsourceObjectName, destinationBucket,\n\t\t\t\t\t\t\t\t\t\tdestinationObjectName);\n\t\t\t\t\t\t\t\tif (WalrusProperties.trackUsageStatistics)\n\t\t\t\t\t\t\t\t\twalrusStatistics\n\t\t\t\t\t\t\t\t\t.updateSpaceUsed(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t\t\t.getSize());\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\t\t\t\"Could not rename \" + sourceObjectName\n\t\t\t\t\t\t\t\t\t\t+ \" to \"\n\t\t\t\t\t\t\t\t\t\t+ destinationObjectName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(addNew)\n\t\t\t\t\t\t\t\tdbObject.add(destinationObjectInfo);\n\n\t\t\t\t\t\t\t//get rid of delete marker\n\t\t\t\t\t\t\tObjectInfo deleteMarker = new ObjectInfo(destinationBucket, destinationKey);\n\t\t\t\t\t\t\tdeleteMarker.setDeleted(true);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObjectInfo foundDeleteMarker = dbObject.getUnique(deleteMarker);\n\t\t\t\t\t\t\t\tdbObject.delete(foundDeleteMarker);\n\t\t\t\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t//no delete marker found.\n\t\t\t\t\t\t\t\tLOG.trace(\"No delete marker found for: \" + destinationBucket + \"/\" + destinationKey);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified\n\t\t\t\t\t\t\t\t\t.getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\n\t\t\t\t\t\t\tif(foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\treply.setCopySourceVersionId(sourceVersionId);\n\t\t\t\t\t\t\t\treply.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\tdestinationBucket);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(destinationBucket);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", sourceKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(sourceKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(sourceBucket);\n\t\t}\n\t}","id":95198,"modified_method":"public CopyObjectResponseType copyObject(CopyObjectType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tCopyObjectResponseType reply = (CopyObjectResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString sourceBucket = request.getSourceBucket();\n\t\tString sourceKey = request.getSourceObject();\n\t\tString sourceVersionId = request.getSourceVersionId();\n\t\tString destinationBucket = request.getDestinationBucket();\n\t\tString destinationKey = request.getDestinationObject();\n\t\tString metadataDirective = request.getMetadataDirective();\n\t\tAccessControlListType accessControlList = request\n\t\t\t\t.getAccessControlList();\n\n\t\tString copyIfMatch = request.getCopySourceIfMatch();\n\t\tString copyIfNoneMatch = request.getCopySourceIfNoneMatch();\n\t\tDate copyIfUnmodifiedSince = request.getCopySourceIfUnmodifiedSince();\n\t\tDate copyIfModifiedSince = request.getCopySourceIfModifiedSince();\n\n\t\tif (metadataDirective == null)\n\t\t\tmetadataDirective = \"COPY\";\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(sourceBucket);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(sourceBucket,\n\t\t\t\t\tsourceKey);\n\t\t\tsearchObjectInfo.setVersionId(sourceVersionId);\n\t\t\tif(sourceVersionId == null)\n\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\tObjectInfo sourceObjectInfo = objectInfos.get(0);\n\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\tsourceObjectInfo.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t\t(sourceObjectInfo.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECT,\n\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\tPolicySpec.objectFullName(sourceBucket, sourceKey),\n\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\tif (copyIfMatch != null) {\n\t\t\t\t\t\tif (!copyIfMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfMatch: \" + copyIfMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfNoneMatch != null) {\n\t\t\t\t\t\tif (copyIfNoneMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfNoneMatch: \"\n\t\t\t\t\t\t\t\t\t+ copyIfNoneMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfUnmodifiedSince != null) {\n\t\t\t\t\t\tlong unmodifiedTime = copyIfUnmodifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified()\n\t\t\t\t\t\t\t\t.getTime();\n\t\t\t\t\t\tif (unmodifiedTime < objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfUnmodifiedSince: \"\n\t\t\t\t\t\t\t\t\t+ copyIfUnmodifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfModifiedSince != null) {\n\t\t\t\t\t\tlong modifiedTime = copyIfModifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified()\n\t\t\t\t\t\t\t\t.getTime();\n\t\t\t\t\t\tif (modifiedTime > objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey\n\t\t\t\t\t\t\t\t\t+ \" CopySourceIfModifiedSince: \"\n\t\t\t\t\t\t\t\t\t+ copyIfModifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBucketInfo destinationBucketInfo = new BucketInfo(\n\t\t\t\t\t\t\tdestinationBucket);\n\t\t\t\t\tList<BucketInfo> destinationBuckets = db\n\t\t\t\t\t\t\t.query(destinationBucketInfo);\n\t\t\t\t\tif (destinationBuckets.size() > 0) {\n\t\t\t\t\t\tBucketInfo foundDestinationBucketInfo = destinationBuckets.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\t\tfoundDestinationBucketInfo.canWrite(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(foundDestinationBucketInfo.isGlobalWrite() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\t\t\t\tdestinationBucket,\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\t// all ok\n\t\t\t\t\t\t\tString destinationVersionId = sourceVersionId;\n\t\t\t\t\t\t\tObjectInfo destinationObjectInfo = null;\n\t\t\t\t\t\t\tString destinationObjectName;\n\t\t\t\t\t\t\tObjectInfo destSearchObjectInfo = new ObjectInfo(\n\t\t\t\t\t\t\t\t\tdestinationBucket, destinationKey);\n\t\t\t\t\t\t\tif(foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\t\tdestinationVersionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdestinationVersionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestSearchObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tList<ObjectInfo> destinationObjectInfos = dbObject\n\t\t\t\t\t\t\t\t\t.query(destSearchObjectInfo);\n\t\t\t\t\t\t\tif (destinationObjectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo = destinationObjectInfos\n\t\t\t\t\t\t\t\t\t\t.get(0);\n\t\t\t\t\t\t\t\tif (!destinationObjectInfo.canWrite(account.getAccountNumber())) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\",\n\t\t\t\t\t\t\t\t\t\t\tdestinationKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tboolean addNew = false;\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (destinationObjectInfo == null) {\n\t\t\t\t\t\t\t\t// not found. create a new one\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\t\t\t\tPermissions.isAuthorized(PolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\tsourceBucket,\n\t\t\t\t\t\t\t\t\t\t\t\tctx.getAccount(),\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\tctx.getUser()) &&\n\t\t\t\t\t\t\t\t\t\t\t\tPermissions.canAllocate(PolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceBucket,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tctx.getUser(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceObjectInfo.getSize()))) {\n\t\t\t\t\t\t\t\t\taddNew = true;\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo = new ObjectInfo();\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.setBucketName(destinationBucket);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.setObjectKey(destinationKey);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(),\n\t\t\t\t\t\t\t\t\t\t\tgrantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.setObjectName(UUID.randomUUID().toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\t\t\t\tdestinationObjectInfo.canWriteACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t\t\t(destinationObjectInfo.isGlobalWriteACP() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECTACL,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(destinationBucket, destinationKey),\n\t\t\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(),\n\t\t\t\t\t\t\t\t\t\t\tgrantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestinationObjectInfo.setSize(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getSize());\n\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t.setStorageClass(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getStorageClass());\n\t\t\t\t\t\t\tdestinationObjectInfo.setOwnerId(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getOwnerId());\n\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t.setContentType(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getContentType());\n\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t.setContentDisposition(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getContentDisposition());\n\t\t\t\t\t\t\tString etag = sourceObjectInfo.getEtag();\n\t\t\t\t\t\t\tDate lastModified = sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getLastModified();\n\t\t\t\t\t\t\tdestinationObjectInfo.setEtag(etag);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLastModified(lastModified);\n\t\t\t\t\t\t\tdestinationObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLast(true);\n\t\t\t\t\t\t\tdestinationObjectInfo.setDeleted(false);\n\t\t\t\t\t\t\tif (!metadataDirective.equals(\"REPLACE\")) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t.setMetaData(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t\t.cloneMetaData());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tList<MetaDataEntry> metaData = request\n\t\t\t\t\t\t\t\t\t\t.getMetaData();\n\t\t\t\t\t\t\t\tif (metaData != null)\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo\n\t\t\t\t\t\t\t\t\t.replaceMetaData(metaData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tString sourceObjectName = sourceObjectInfo\n\t\t\t\t\t\t\t\t\t.getObjectName();\n\t\t\t\t\t\t\tdestinationObjectName = destinationObjectInfo\n\t\t\t\t\t\t\t\t\t.getObjectName();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstorageManager.copyObject(sourceBucket,\n\t\t\t\t\t\t\t\t\t\tsourceObjectName, destinationBucket,\n\t\t\t\t\t\t\t\t\t\tdestinationObjectName);\n\t\t\t\t\t\t\t\tif (WalrusProperties.trackUsageStatistics)\n\t\t\t\t\t\t\t\t\twalrusStatistics\n\t\t\t\t\t\t\t\t\t.updateSpaceUsed(sourceObjectInfo\n\t\t\t\t\t\t\t\t\t\t\t.getSize());\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\t\t\t\"Could not rename \" + sourceObjectName\n\t\t\t\t\t\t\t\t\t\t+ \" to \"\n\t\t\t\t\t\t\t\t\t\t+ destinationObjectName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(addNew)\n\t\t\t\t\t\t\t\tdbObject.add(destinationObjectInfo);\n\n\t\t\t\t\t\t\t//get rid of delete marker\n\t\t\t\t\t\t\tObjectInfo deleteMarker = new ObjectInfo(destinationBucket, destinationKey);\n\t\t\t\t\t\t\tdeleteMarker.setDeleted(true);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObjectInfo foundDeleteMarker = dbObject.getUnique(deleteMarker);\n\t\t\t\t\t\t\t\tdbObject.delete(foundDeleteMarker);\n\t\t\t\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t//no delete marker found.\n\t\t\t\t\t\t\t\tLOG.trace(\"No delete marker found for: \" + destinationBucket + \"/\" + destinationKey);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified\n\t\t\t\t\t\t\t\t\t.getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\n\t\t\t\t\t\t\tif(foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\treply.setCopySourceVersionId(sourceVersionId);\n\t\t\t\t\t\t\t\treply.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\tdestinationBucket);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(destinationBucket);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", sourceKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(sourceKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(sourceBucket);\n\t\t}\n\t}","commit_id":"1e3acd45db6974048036339ae8d2ea977d6f2b6b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(\n\t\t\tGetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\t\tBucketLogData logData;\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tif(bucket.isVersioningEnabled()) {\n\t\t\t\t\t\tif(request.getVersionId() == null)\n\t\t\t\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t\t\t}\n\t\t\t\t\tString versionId = request.getVersionId() != null ? request.getVersionId() : WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\tsearchObjectInfo.setVersionId(versionId);\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges( ) || (\n\t\t\t\t\t\t\t\tobjectInfo.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\n\t\t\t\t\t\t\t\t\taddPermission(grants, Accounts.lookupAccountById(uId), grantInfo);\n\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\t\t\t\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":95199,"modified_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(\n\t\t\tGetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\t\tBucketLogData logData;\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObjectInfo.setVersionId(request.getVersionId());\n\t\t\t\t\tif(request.getVersionId() == null) {\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges( ) || (\n\t\t\t\t\t\t\t\tobjectInfo.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\n\t\t\t\t\t\t\t\t\taddPermission(grants, Accounts.lookupAccountById(uId), grantInfo);\n\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\t\t\t\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"1e3acd45db6974048036339ae8d2ea977d6f2b6b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SetRESTObjectAccessControlPolicyResponseType setRESTObjectAccessControlPolicy(\n\t\t\tSetRESTObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tSetRESTObjectAccessControlPolicyResponseType reply = (SetRESTObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tAccessControlPolicyType accessControlPolicy = request\n\t\t\t\t.getAccessControlPolicy();\n\t\tif (accessControlPolicy == null) {\n\t\t\tthrow new AccessDeniedException(\"Key\", request.getKey());\n\t\t}\n\t\tAccessControlListType accessControlList = accessControlPolicy\n\t\t\t\t.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tif(bucket.isVersioningEnabled()) {\n\t\t\t\t\t\tif(request.getVersionId() == null)\n\t\t\t\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t\t\t}\n\t\t\t\t\tString versionId = request.getVersionId() != null ? request.getVersionId() : WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\tsearchObjectInfo.setVersionId(versionId);\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (!ctx.hasAdministrativePrivileges() && !(\n\t\t\t\t\t\t\t\tobjectInfo.canWriteACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalWriteACP() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\tif (!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db\n\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOG\n\t\t\t\t\t\t\t.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treply.setCode(\"204\");\n\t\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":95200,"modified_method":"public SetRESTObjectAccessControlPolicyResponseType setRESTObjectAccessControlPolicy(\n\t\t\tSetRESTObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tSetRESTObjectAccessControlPolicyResponseType reply = (SetRESTObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tAccessControlPolicyType accessControlPolicy = request\n\t\t\t\t.getAccessControlPolicy();\n\t\tif (accessControlPolicy == null) {\n\t\t\tthrow new AccessDeniedException(\"Key\", request.getKey());\n\t\t}\n\t\tAccessControlListType accessControlList = accessControlPolicy\n\t\t\t\t.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObjectInfo.setVersionId(request.getVersionId());\n\t\t\t\t\tif(request.getVersionId() == null) {\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (!ctx.hasAdministrativePrivileges() && !(\n\t\t\t\t\t\t\t\tobjectInfo.canWriteACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalWriteACP() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\tif (!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db\n\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOG\n\t\t\t\t\t\t\t.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treply.setCode(\"204\");\n\t\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"1e3acd45db6974048036339ae8d2ea977d6f2b6b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SetObjectAccessControlPolicyResponseType setObjectAccessControlPolicy(\n\t\t\tSetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tSetObjectAccessControlPolicyResponseType reply = (SetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tAccessControlListType accessControlList = request\n\t\t\t\t.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tif(bucket.isVersioningEnabled()) {\n\t\t\t\t\t\tif(request.getVersionId() == null)\n\t\t\t\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t\t\t}\n\t\t\t\t\tString versionId = request.getVersionId() != null ? request.getVersionId() : WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\tsearchObjectInfo.setVersionId(versionId);\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (!ctx.hasAdministrativePrivileges() && !(\n\t\t\t\t\t\t\t\tobjectInfo.canWriteACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalWriteACP() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\tif (!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db\n\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treply.setCode(\"204\");\n\t\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":95201,"modified_method":"public SetObjectAccessControlPolicyResponseType setObjectAccessControlPolicy(\n\t\t\tSetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tSetObjectAccessControlPolicyResponseType reply = (SetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tAccessControlListType accessControlList = request\n\t\t\t\t.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObjectInfo.setVersionId(request.getVersionId());\n\t\t\t\t\tif(request.getVersionId() == null) {\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\t\t\t\t\t\t\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (!ctx.hasAdministrativePrivileges() && !(\n\t\t\t\t\t\t\t\tobjectInfo.canWriteACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalWriteACP() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\tif (!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db\n\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treply.setCode(\"204\");\n\t\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"1e3acd45db6974048036339ae8d2ea977d6f2b6b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Map finAccountReplenish(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericDelegator delegator = dctx.getDelegator();\n\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        String productStoreId = (String) context.get(\"productStoreId\");\n        String finAccountId = (String) context.get(\"finAccountId\");\n\n        // lookup the FinAccount\n        GenericValue finAccount;\n        try {\n            finAccount = delegator.findByPrimaryKey(\"FinAccount\", UtilMisc.toMap(\"finAccountId\", finAccountId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (finAccount == null) {\n            return ServiceUtil.returnError(\"Invalid financial account [\" + finAccountId + \"]\");\n        }\n        String currency = finAccount.getString(\"currencyUomId\");\n\n        // look up the type -- determine auto-replenish is active\n        GenericValue finAccountType;\n        try {\n            finAccountType = finAccount.getRelatedOne(\"FinAccountType\");\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        String replenishEnumId = finAccountType.getString(\"replenishEnumId\");\n        if (!\"FARP_AUTOMATIC\".equals(replenishEnumId)) {\n            // type does not support auto-replenish\n            return ServiceUtil.returnSuccess();\n        }\n\n        // attempt to lookup the product store from a previous deposit\n        if (productStoreId == null) {\n            productStoreId = getLastProductStoreId(delegator, finAccountId);\n            if (productStoreId == null) {\n                return ServiceUtil.returnError(\"Cannot locate product store from previous deposits; product store cannot be empty\");\n            }\n        }\n\n        // get the product store settings\n        GenericValue finAccountSettings;\n        try {\n            finAccountSettings = delegator.findByPrimaryKeyCache(\"ProductStoreFinActSetting\",\n                    UtilMisc.toMap(\"productStoreId\", productStoreId, \"finAccountTypeId\",\n                            finAccount.getString(\"finAccountTypeId\")));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (finAccountSettings == null) {\n            // no settings; don't replenish\n            return ServiceUtil.returnSuccess();\n        }\n\n        Double replThres = finAccountSettings.getDouble(\"replenishThreshold\");\n        if (replThres == null) {\n            return ServiceUtil.returnSuccess();\n        }\n        BigDecimal replenishThreshold = new BigDecimal(replThres);\n\n        BigDecimal replenishLevel = finAccount.getBigDecimal(\"replenishLevel\");\n        if (replenishLevel == null || replenishLevel.compareTo(FinAccountHelper.ZERO) == 0) {\n            // no replenish level set; this account goes not support auto-replenish\n            return ServiceUtil.returnSuccess();\n        }\n\n        // get the current balance\n        BigDecimal balance = finAccount.getBigDecimal(\"actualBalance\");\n\n        // see if we are within the threshold for replenishment\n        if (balance.compareTo(replenishThreshold) > -1) {\n            // not ready\n            return ServiceUtil.returnSuccess();        \n        }\n\n        // configure rollback service to set good standing flag\n        Map rollbackCtx = UtilMisc.toMap(\"userLogin\", userLogin, \"finAccountId\", finAccountId, \"inGoodStanding\", \"N\");\n        try {\n            dispatcher.addRollbackService(\"updateFinAccount\", rollbackCtx, true);\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n\n        // the deposit is level - balance (500 - (-10) = 510 || 500 - (10) = 490)\n        BigDecimal depositAmount = replenishLevel.subtract(balance);\n\n        // get the owner party\n        String ownerPartyId = finAccount.getString(\"ownerPartyId\");\n        if (ownerPartyId == null) {\n            // no owner cannot replenish; (not fatal, just not supported by this account)\n            Debug.logWarning(\"No owner attached to financial account [\" + finAccountId + \"] cannot auto-replenish\", module);\n            return ServiceUtil.returnSuccess();\n        }\n\n        // get the payment method to use to replenish\n        String paymentMethodId = finAccount.getString(\"replenishPaymentId\");\n        if (paymentMethodId == null) {\n            Debug.logError(\"No payment method attached to financial account [\" + finAccountId + \"] cannot auto-replenish\", module);\n            return ServiceUtil.returnError(\"No payment method associated with replenish account\");\n        }\n\n        GenericValue paymentMethod;\n        try {\n            paymentMethod = delegator.findByPrimaryKey(\"PaymentMethod\", UtilMisc.toMap(\"paymentMethodId\", paymentMethodId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (paymentMethod == null) {\n            // no payment methods on file; cannot replenish\n            Debug.logWarning(\"No payment method found for ID [\" + paymentMethodId + \"] for party [\" + ownerPartyId + \"] cannot auto-replenish\", module);\n            return ServiceUtil.returnError(\"Cannot locate payment method ID [\" + paymentMethodId + \"]\");\n        }\n\n        // hit the payment method for the amount to replenish\n        Map orderItemMap = UtilMisc.toMap(\"Auto-Replenishment FA #\" + finAccountId, depositAmount.doubleValue());\n        Map replOrderCtx = FastMap.newInstance();\n        replOrderCtx.put(\"productStoreId\", productStoreId);\n        replOrderCtx.put(\"paymentMethodId\", paymentMethod.getString(\"paymentMethodId\"));\n        replOrderCtx.put(\"currency\", currency);\n        replOrderCtx.put(\"partyId\", ownerPartyId);\n        replOrderCtx.put(\"itemMap\", orderItemMap);\n        replOrderCtx.put(\"userLogin\", userLogin);\n        Map replResp;\n        try {\n            replResp = dispatcher.runSync(\"createSimpleNonProductSalesOrder\", replOrderCtx);\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (ServiceUtil.isError(replResp)) {\n            return replResp;\n        }\n        String orderId = (String) replResp.get(\"orderId\");\n\n        // create the deposit\n        Map depositCtx = FastMap.newInstance();\n        depositCtx.put(\"productStoreId\", productStoreId);\n        depositCtx.put(\"finAccountId\", finAccountId);\n        depositCtx.put(\"currency\", currency);\n        depositCtx.put(\"partyId\", ownerPartyId);\n        depositCtx.put(\"orderId\", orderId);\n        depositCtx.put(\"orderItemSeqId\", \"00001\"); // always one item on a replish order\n        depositCtx.put(\"amount\",  new Double(depositAmount.doubleValue()));\n        depositCtx.put(\"userLogin\", userLogin);\n        Map depositResp;\n        try {\n            depositResp = dispatcher.runSync(\"finAccountDeposit\", depositCtx);\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (ServiceUtil.isError(depositResp)) {\n            return depositResp;\n        }\n\n        // say we are in good standing again\n        finAccount.set(\"inGoodStanding\", \"Y\");\n        try {\n            finAccount.store();\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        \n        return ServiceUtil.returnSuccess();\n    }","id":95202,"modified_method":"public static Map finAccountReplenish(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericDelegator delegator = dctx.getDelegator();\n\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        String productStoreId = (String) context.get(\"productStoreId\");\n        String finAccountId = (String) context.get(\"finAccountId\");\n\n        // lookup the FinAccount\n        GenericValue finAccount;\n        try {\n            finAccount = delegator.findByPrimaryKey(\"FinAccount\", UtilMisc.toMap(\"finAccountId\", finAccountId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (finAccount == null) {\n            return ServiceUtil.returnError(\"Invalid financial account [\" + finAccountId + \"]\");\n        }\n        String currency = finAccount.getString(\"currencyUomId\");\n\n        // look up the type -- determine auto-replenish is active\n        GenericValue finAccountType;\n        try {\n            finAccountType = finAccount.getRelatedOne(\"FinAccountType\");\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        String replenishEnumId = finAccountType.getString(\"replenishEnumId\");\n        if (!\"FARP_AUTOMATIC\".equals(replenishEnumId)) {\n            // type does not support auto-replenish\n            return ServiceUtil.returnSuccess();\n        }\n\n        // attempt to lookup the product store from a previous deposit\n        if (productStoreId == null) {\n            productStoreId = getLastProductStoreId(delegator, finAccountId);\n            if (productStoreId == null) {\n                return ServiceUtil.returnError(\"Cannot locate product store from previous deposits; product store cannot be empty\");\n            }\n        }\n\n        // get the product store settings\n        GenericValue finAccountSettings;\n        Map psfasFindMap = UtilMisc.toMap(\"productStoreId\", productStoreId, \"finAccountTypeId\", finAccount.getString(\"finAccountTypeId\"));\n        try {\n            finAccountSettings = delegator.findByPrimaryKeyCache(\"ProductStoreFinActSetting\", psfasFindMap);\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (finAccountSettings == null) {\n            Debug.logWarning(\"finAccountReplenish Warning: not replenishing FinAccount [\" + finAccountId  + \"] because no ProductStoreFinActSetting record found for: \" + psfasFindMap, module);\n            // no settings; don't replenish\n            return ServiceUtil.returnSuccess();\n        }\n\n        Double replThres = finAccountSettings.getDouble(\"replenishThreshold\");\n        if (replThres == null) {\n            Debug.logWarning(\"finAccountReplenish Warning: not replenishing FinAccount [\" + finAccountId  + \"] because ProductStoreFinActSetting.replenishThreshold field was null for: \" + psfasFindMap, module);\n            return ServiceUtil.returnSuccess();\n        }\n        BigDecimal replenishThreshold = new BigDecimal(replThres);\n\n        BigDecimal replenishLevel = finAccount.getBigDecimal(\"replenishLevel\");\n        if (replenishLevel == null || replenishLevel.compareTo(FinAccountHelper.ZERO) == 0) {\n            Debug.logWarning(\"finAccountReplenish Warning: not replenishing FinAccount [\" + finAccountId  + \"] because FinAccount.replenishLevel field was null or 0\", module);\n            // no replenish level set; this account goes not support auto-replenish\n            return ServiceUtil.returnSuccess();\n        }\n\n        // get the current balance\n        BigDecimal balance = finAccount.getBigDecimal(\"actualBalance\");\n\n        // see if we are within the threshold for replenishment\n        if (balance.compareTo(replenishThreshold) > -1) {\n            Debug.logInfo(\"finAccountReplenish Info: Not replenishing FinAccount [\" + finAccountId  + \"] because balance [\" + balance + \"] is greater than the replenishThreshold [\" + replenishThreshold + \"]\", module);\n            // not ready\n            return ServiceUtil.returnSuccess();        \n        }\n\n        // configure rollback service to set good standing flag\n        Map rollbackCtx = UtilMisc.toMap(\"userLogin\", userLogin, \"finAccountId\", finAccountId, \"inGoodStanding\", \"N\");\n        try {\n            dispatcher.addRollbackService(\"updateFinAccount\", rollbackCtx, true);\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n\n        // the deposit is level - balance (500 - (-10) = 510 || 500 - (10) = 490)\n        BigDecimal depositAmount = replenishLevel.subtract(balance);\n\n        // get the owner party\n        String ownerPartyId = finAccount.getString(\"ownerPartyId\");\n        if (ownerPartyId == null) {\n            // no owner cannot replenish; (not fatal, just not supported by this account)\n            Debug.logWarning(\"finAccountReplenish Warning: No owner attached to financial account [\" + finAccountId + \"] cannot auto-replenish\", module);\n            return ServiceUtil.returnSuccess();\n        }\n\n        // get the payment method to use to replenish\n        String paymentMethodId = finAccount.getString(\"replenishPaymentId\");\n        if (paymentMethodId == null) {\n            Debug.logWarning(\"finAccountReplenish Warning: No payment method (replenishPaymentId) attached to financial account [\" + finAccountId + \"] cannot auto-replenish\", module);\n            return ServiceUtil.returnError(\"No payment method associated with replenish account\");\n        }\n\n        GenericValue paymentMethod;\n        try {\n            paymentMethod = delegator.findByPrimaryKey(\"PaymentMethod\", UtilMisc.toMap(\"paymentMethodId\", paymentMethodId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (paymentMethod == null) {\n            // no payment methods on file; cannot replenish\n            Debug.logWarning(\"finAccountReplenish Warning: No payment method found for ID [\" + paymentMethodId + \"] for party [\" + ownerPartyId + \"] cannot auto-replenish\", module);\n            return ServiceUtil.returnError(\"Cannot locate payment method ID [\" + paymentMethodId + \"]\");\n        }\n\n        // hit the payment method for the amount to replenish\n        Map orderItemMap = UtilMisc.toMap(\"Auto-Replenishment FA #\" + finAccountId, depositAmount.doubleValue());\n        Map replOrderCtx = FastMap.newInstance();\n        replOrderCtx.put(\"productStoreId\", productStoreId);\n        replOrderCtx.put(\"paymentMethodId\", paymentMethod.getString(\"paymentMethodId\"));\n        replOrderCtx.put(\"currency\", currency);\n        replOrderCtx.put(\"partyId\", ownerPartyId);\n        replOrderCtx.put(\"itemMap\", orderItemMap);\n        replOrderCtx.put(\"userLogin\", userLogin);\n        Map replResp;\n        try {\n            replResp = dispatcher.runSync(\"createSimpleNonProductSalesOrder\", replOrderCtx);\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (ServiceUtil.isError(replResp)) {\n            return replResp;\n        }\n        String orderId = (String) replResp.get(\"orderId\");\n\n        // create the deposit\n        Map depositCtx = FastMap.newInstance();\n        depositCtx.put(\"productStoreId\", productStoreId);\n        depositCtx.put(\"finAccountId\", finAccountId);\n        depositCtx.put(\"currency\", currency);\n        depositCtx.put(\"partyId\", ownerPartyId);\n        depositCtx.put(\"orderId\", orderId);\n        depositCtx.put(\"orderItemSeqId\", \"00001\"); // always one item on a replish order\n        depositCtx.put(\"amount\",  new Double(depositAmount.doubleValue()));\n        depositCtx.put(\"userLogin\", userLogin);\n        try {\n            Map depositResp = dispatcher.runSync(\"finAccountDeposit\", depositCtx);\n            if (ServiceUtil.isError(depositResp)) {\n                return depositResp;\n            }\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n\n        // say we are in good standing again\n        try {\n            Map ufaResp = dispatcher.runSync(\"updateFinAccount\", UtilMisc.toMap(\"finAccountId\", finAccountId, \"inGoodStanding\", \"Y\", \"userLogin\", userLogin));\n            if (ServiceUtil.isError(ufaResp)) {\n                return ufaResp;\n            }\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        \n        return ServiceUtil.returnSuccess();\n    }","commit_id":"9c73979bbd673b0ea8f522dd844159fd0f9ccfbb","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map finAccountPreAuth(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericDelegator delegator = dctx.getDelegator();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        String finAccountCode = (String) context.get(\"finAccountCode\");\n        String finAccountPin = (String) context.get(\"finAccountPin\");\n        String finAccountId = (String) context.get(\"finAccountId\");\n        String orderId = (String) context.get(\"orderId\");\n        Double amount = (Double) context.get(\"processAmount\");\n\n        // check for an existing auth trans and cancel it\n        GenericValue authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        if (authTrans != null) {\n            Map input = UtilMisc.toMap(\"userLogin\", userLogin, \"finAccountAuthId\", authTrans.get(\"referenceNum\"));\n            try {\n                dispatcher.runSync(\"expireFinAccountAuth\", input);\n            } catch (GenericServiceException e) {\n                Debug.logError(e, module);\n                return ServiceUtil.returnError(e.getMessage());\n            }\n        }\n        if (finAccountId == null && paymentPref != null) {\n            finAccountId = paymentPref.getString(\"finAccountId\");\n        }\n\n        // obtain the order information\n        OrderReadHelper orh = new OrderReadHelper(delegator, orderId);\n        \n        // NOTE DEJ20070808: this means that we want store related settings for where the item is being purchased, \n        //NOT where the account was setup; should this be changed to use settings from the store where the account was setup?\n        String productStoreId = orh.getProductStoreId();\n        \n        // TODO, NOTE DEJ20070808: why is this setup this way anyway? for the allowAuthToNegative wouldn't that be better setup\n        //on the FinAccount and not on the ProductStoreFinActSetting? maybe an override on the FinAccount would be good...\n\n        // get the financial account\n        GenericValue finAccount;\n        if (finAccountId != null) {\n            try {\n                finAccount = delegator.findByPrimaryKey(\"FinAccount\", UtilMisc.toMap(\"finAccountId\", finAccountId));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n                return ServiceUtil.returnError(e.getMessage());\n            }\n        } else {\n            if (finAccountCode != null) {\n                try {\n                    finAccount = FinAccountHelper.getFinAccountFromCode(finAccountCode, delegator);\n                } catch (GenericEntityException e) {\n                    Debug.logError(e, module);\n                    return ServiceUtil.returnError(\"Unable to locate financial account from account code\");\n                }\n            } else {\n                return ServiceUtil.returnError(\"Both finAccountId and finAccountCode cannot be null; at least one is required\");\n            }\n        }\n        if (finAccount == null) {\n            return ServiceUtil.returnError(\"Invalid financial account; cannot locate account\");\n        }\n\n        String finAccountTypeId = finAccount.getString(\"finAccountTypeId\");\n        finAccountId = finAccount.getString(\"finAccountId\");\n\n        try {\n            // fin the store requires a pin number; validate the PIN with the code\n            Map findProductStoreFinActSettingMap = UtilMisc.toMap(\"productStoreId\", productStoreId, \"finAccountTypeId\", finAccountTypeId);\n            GenericValue finAccountSettings = delegator.findByPrimaryKeyCache(\"ProductStoreFinActSetting\", findProductStoreFinActSettingMap);\n            \n            if (finAccountSettings == null) {\n                Debug.logWarning(\"In finAccountPreAuth could not find ProductStoreFinActSetting record, values searched by: \" + findProductStoreFinActSettingMap, module);\n            }\n            if (Debug.verboseOn()) Debug.logVerbose(\"In finAccountPreAuth finAccountSettings=\" + finAccountSettings, module);\n\n            BigDecimal minBalance = FinAccountHelper.ZERO;\n            String allowAuthToNegative = \"N\";\n\n            if (finAccountSettings != null) {\n                allowAuthToNegative = finAccountSettings.getString(\"allowAuthToNegative\");\n                minBalance = finAccountSettings.getBigDecimal(\"minBalance\");\n                if (minBalance == null) {\n                    minBalance = FinAccountHelper.ZERO;\n                }\n\n                // validate the PIN if the store requires it\n                if (\"Y\".equals(finAccountSettings.getString(\"requirePinCode\"))) {\n                    if (!FinAccountHelper.validatePin(delegator, finAccountCode, finAccountPin)) {\n                        Map result = ServiceUtil.returnSuccess();\n                        result.put(\"authMessage\", \"Financial account PIN/CODE combination not found\");\n                        result.put(\"authResult\", Boolean.FALSE);\n                        result.put(\"processAmount\", amount);\n                        result.put(\"authFlag\", \"0\");\n                        result.put(\"authCode\", \"A\");\n                        result.put(\"authRefNum\", \"0\");\n                        Debug.logError(\"Unable to auth FinAccount: \" + result, module);\n                        return result;\n                    }\n                }\n            }\n\n            // check for expiration date\n            if ((finAccount.getTimestamp(\"thruDate\") != null) && (finAccount.getTimestamp(\"thruDate\").before(UtilDateTime.nowTimestamp()))) {\n                Map result = ServiceUtil.returnSuccess();\n                result.put(\"authMessage\", \"Account has expired as of \" + finAccount.getTimestamp(\"thruDate\"));\n                result.put(\"authResult\", Boolean.FALSE);\n                result.put(\"processAmount\", amount);\n                result.put(\"authFlag\", \"0\");\n                result.put(\"authCode\", \"A\");\n                result.put(\"authRefNum\", \"0\");\n                Debug.logError(\"Unable to auth FinAccount: \" + result, module);\n                return result;\n            }\n\n            // check for account being in bad standing\n            String inGoodStanding = finAccount.getString(\"inGoodStanding\");\n            if (inGoodStanding != null && \"N\".equals(inGoodStanding)) {\n                // refresh the finaccount\n                finAccount.refresh();\n                inGoodStanding = finAccount.getString(\"inGoodStanding\");\n\n                if (inGoodStanding != null && \"N\".equals(inGoodStanding)) {\n                    Map result = ServiceUtil.returnSuccess();\n                    result.put(\"authMessage\", \"Account is currently in bad standing\");\n                    result.put(\"authResult\", Boolean.FALSE);\n                    result.put(\"processAmount\", amount);\n                    result.put(\"authFlag\", \"0\");\n                    result.put(\"authCode\", \"A\");\n                    result.put(\"authRefNum\", \"0\");\n                    Debug.logError(\"Unable to auth FinAccount: \" + result, module);\n                    return result;\n                }\n            }\n\n            // check for account being frozen\n            String isFrozen = finAccount.getString(\"isFrozen\");\n            if (isFrozen != null && \"Y\".equals(isFrozen)) {\n                // refresh the finaccount\n                finAccount.refresh();\n                isFrozen = finAccount.getString(\"isFrozen\");\n\n                if (isFrozen != null && \"Y\".equals(isFrozen)) {\n                    Map result = ServiceUtil.returnSuccess();\n                    result.put(\"authMessage\", \"Account is currently frozen\");\n                    result.put(\"authResult\", Boolean.FALSE);\n                    result.put(\"processAmount\", amount);\n                    result.put(\"authFlag\", \"0\");\n                    result.put(\"authCode\", \"A\");\n                    result.put(\"authRefNum\", \"0\");\n                    Debug.logError(\"Unable to auth FinAccount: \" + result, module);\n                    return result;\n                }\n            }\n\n            // check the amount to authorize against the available balance of fin account, which includes active authorizations as well as transactions\n            BigDecimal availableBalance = finAccount.getBigDecimal(\"availableBalance\");\n            if (availableBalance == null) {\n                availableBalance = FinAccountHelper.ZERO;\n            }\n            \n            Map result = ServiceUtil.returnSuccess();\n            String authMessage = null;\n            Boolean processResult;\n            String refNum;\n\n            // turn amount into a big decimal, making sure to round and scale it to the same as availableBalance\n            BigDecimal amountBd = (new BigDecimal(amount)).setScale(FinAccountHelper.decimals, FinAccountHelper.rounding);\n\n            Debug.logInfo(\"Allow auth to negative: \" + allowAuthToNegative + \" :: available: \" + availableBalance + \" comp: \" + minBalance + \" = \" + availableBalance.compareTo(minBalance) + \" :: req: \" + amountBd, module);\n            // check the available balance to see if we can auth this tx\n            if ((\"Y\".equals(allowAuthToNegative) && availableBalance.compareTo(minBalance) > -1)\n                    || (availableBalance.compareTo(amountBd) > -1)) {\n                Timestamp thruDate;\n                \n                if (finAccountSettings != null && finAccountSettings.getLong(\"authValidDays\") != null) {\n                    thruDate = UtilDateTime.getDayEnd(UtilDateTime.nowTimestamp(), finAccountSettings.getLong(\"authValidDays\").intValue());\n                } else {\n                    thruDate = UtilDateTime.getDayEnd(UtilDateTime.nowTimestamp(), 30); // default 30 days for an auth\n                }\n\n                Map tmpResult = dispatcher.runSync(\"createFinAccountAuth\", UtilMisc.toMap(\"finAccountId\", finAccountId,\n                        \"amount\", amount, \"thruDate\", thruDate, \"userLogin\", userLogin));\n\n                if (ServiceUtil.isError(tmpResult)) {\n                    return tmpResult;\n                } else {\n                    refNum = (String) tmpResult.get(\"finAccountAuthId\");\n                    processResult = Boolean.TRUE;\n                }\n                                \n                // refresh the account\n                finAccount.refresh();\n            } else {\n                Debug.logError(\"Attempted to authorize [\" + amount + \"] against a balance of only [\" + availableBalance + \"]\", module);\n                refNum = \"0\"; // a refNum is always required from authorization\n                authMessage = \"Insufficient funds\";\n                processResult = Boolean.FALSE;\n            }\n\n            result.put(\"processAmount\", amount);\n            result.put(\"authMessage\", authMessage);\n            result.put(\"authResult\", processResult);\n            result.put(\"processAmount\", amount);\n            result.put(\"authFlag\", \"1\");\n            result.put(\"authCode\", \"A\");            \n            result.put(\"authRefNum\", refNum);\n            Debug.logInfo(\"FinAccont Auth: \" + result, module);\n\n            return result;\n        } catch (GenericEntityException ex) {\n            Debug.logError(ex, \"Cannot authorize financial account\", module);\n            return ServiceUtil.returnError(\"Cannot authorize financial account due to \" + ex.getMessage());\n        } catch (GenericServiceException ex) {\n            Debug.logError(ex, \"Cannot authorize gift certificate\", module);\n            return ServiceUtil.returnError(\"Cannot authorize financial account due to \" + ex.getMessage());\n        }\n    }","id":95203,"modified_method":"public static Map finAccountPreAuth(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericDelegator delegator = dctx.getDelegator();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        String finAccountCode = (String) context.get(\"finAccountCode\");\n        String finAccountPin = (String) context.get(\"finAccountPin\");\n        String finAccountId = (String) context.get(\"finAccountId\");\n        String orderId = (String) context.get(\"orderId\");\n        Double amount = (Double) context.get(\"processAmount\");\n\n        // check for an existing auth trans and cancel it\n        GenericValue authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        if (authTrans != null) {\n            Map input = UtilMisc.toMap(\"userLogin\", userLogin, \"finAccountAuthId\", authTrans.get(\"referenceNum\"));\n            try {\n                dispatcher.runSync(\"expireFinAccountAuth\", input);\n            } catch (GenericServiceException e) {\n                Debug.logError(e, module);\n                return ServiceUtil.returnError(e.getMessage());\n            }\n        }\n        if (finAccountId == null && paymentPref != null) {\n            finAccountId = paymentPref.getString(\"finAccountId\");\n        }\n\n        // obtain the order information\n        OrderReadHelper orh = new OrderReadHelper(delegator, orderId);\n        \n        // NOTE DEJ20070808: this means that we want store related settings for where the item is being purchased, \n        //NOT where the account was setup; should this be changed to use settings from the store where the account was setup?\n        String productStoreId = orh.getProductStoreId();\n        \n        // TODO, NOTE DEJ20070808: why is this setup this way anyway? for the allowAuthToNegative wouldn't that be better setup\n        //on the FinAccount and not on the ProductStoreFinActSetting? maybe an override on the FinAccount would be good...\n\n        // get the financial account\n        GenericValue finAccount;\n        if (finAccountId != null) {\n            try {\n                finAccount = delegator.findByPrimaryKey(\"FinAccount\", UtilMisc.toMap(\"finAccountId\", finAccountId));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n                return ServiceUtil.returnError(e.getMessage());\n            }\n        } else {\n            if (finAccountCode != null) {\n                try {\n                    finAccount = FinAccountHelper.getFinAccountFromCode(finAccountCode, delegator);\n                } catch (GenericEntityException e) {\n                    Debug.logError(e, module);\n                    return ServiceUtil.returnError(\"Unable to locate financial account from account code\");\n                }\n            } else {\n                return ServiceUtil.returnError(\"Both finAccountId and finAccountCode cannot be null; at least one is required\");\n            }\n        }\n        if (finAccount == null) {\n            return ServiceUtil.returnError(\"Invalid financial account; cannot locate account\");\n        }\n\n        String finAccountTypeId = finAccount.getString(\"finAccountTypeId\");\n        finAccountId = finAccount.getString(\"finAccountId\");\n\n        try {\n            // fin the store requires a pin number; validate the PIN with the code\n            Map findProductStoreFinActSettingMap = UtilMisc.toMap(\"productStoreId\", productStoreId, \"finAccountTypeId\", finAccountTypeId);\n            GenericValue finAccountSettings = delegator.findByPrimaryKeyCache(\"ProductStoreFinActSetting\", findProductStoreFinActSettingMap);\n            \n            if (finAccountSettings == null) {\n                Debug.logWarning(\"In finAccountPreAuth could not find ProductStoreFinActSetting record, values searched by: \" + findProductStoreFinActSettingMap, module);\n            }\n            if (Debug.verboseOn()) Debug.logVerbose(\"In finAccountPreAuth finAccountSettings=\" + finAccountSettings, module);\n\n            BigDecimal minBalance = FinAccountHelper.ZERO;\n            String allowAuthToNegative = \"N\";\n\n            if (finAccountSettings != null) {\n                allowAuthToNegative = finAccountSettings.getString(\"allowAuthToNegative\");\n                minBalance = finAccountSettings.getBigDecimal(\"minBalance\");\n                if (minBalance == null) {\n                    minBalance = FinAccountHelper.ZERO;\n                }\n\n                // validate the PIN if the store requires it\n                if (\"Y\".equals(finAccountSettings.getString(\"requirePinCode\"))) {\n                    if (!FinAccountHelper.validatePin(delegator, finAccountCode, finAccountPin)) {\n                        Map result = ServiceUtil.returnSuccess();\n                        result.put(\"authMessage\", \"Financial account PIN/CODE combination not found\");\n                        result.put(\"authResult\", Boolean.FALSE);\n                        result.put(\"processAmount\", amount);\n                        result.put(\"authFlag\", \"0\");\n                        result.put(\"authCode\", \"A\");\n                        result.put(\"authRefNum\", \"0\");\n                        Debug.logWarning(\"Unable to auth FinAccount: \" + result, module);\n                        return result;\n                    }\n                }\n            }\n\n            // check for expiration date\n            if ((finAccount.getTimestamp(\"thruDate\") != null) && (finAccount.getTimestamp(\"thruDate\").before(UtilDateTime.nowTimestamp()))) {\n                Map result = ServiceUtil.returnSuccess();\n                result.put(\"authMessage\", \"Account has expired as of \" + finAccount.getTimestamp(\"thruDate\"));\n                result.put(\"authResult\", Boolean.FALSE);\n                result.put(\"processAmount\", amount);\n                result.put(\"authFlag\", \"0\");\n                result.put(\"authCode\", \"A\");\n                result.put(\"authRefNum\", \"0\");\n                Debug.logWarning(\"Unable to auth FinAccount: \" + result, module);\n                return result;\n            }\n\n            // check for account being in bad standing\n            String inGoodStanding = finAccount.getString(\"inGoodStanding\");\n            if (inGoodStanding != null && \"N\".equals(inGoodStanding)) {\n                // refresh the finaccount\n                finAccount.refresh();\n                inGoodStanding = finAccount.getString(\"inGoodStanding\");\n\n                if (inGoodStanding != null && \"N\".equals(inGoodStanding)) {\n                    Map result = ServiceUtil.returnSuccess();\n                    result.put(\"authMessage\", \"Account is currently not in good standing\");\n                    result.put(\"authResult\", Boolean.FALSE);\n                    result.put(\"processAmount\", amount);\n                    result.put(\"authFlag\", \"0\");\n                    result.put(\"authCode\", \"A\");\n                    result.put(\"authRefNum\", \"0\");\n                    Debug.logWarning(\"Unable to auth FinAccount: \" + result, module);\n                    return result;\n                }\n            }\n\n            // check for account being frozen\n            String isFrozen = finAccount.getString(\"isFrozen\");\n            if (isFrozen != null && \"Y\".equals(isFrozen)) {\n                // refresh the finaccount\n                finAccount.refresh();\n                isFrozen = finAccount.getString(\"isFrozen\");\n\n                if (isFrozen != null && \"Y\".equals(isFrozen)) {\n                    Map result = ServiceUtil.returnSuccess();\n                    result.put(\"authMessage\", \"Account is currently frozen\");\n                    result.put(\"authResult\", Boolean.FALSE);\n                    result.put(\"processAmount\", amount);\n                    result.put(\"authFlag\", \"0\");\n                    result.put(\"authCode\", \"A\");\n                    result.put(\"authRefNum\", \"0\");\n                    Debug.logWarning(\"Unable to auth FinAccount: \" + result, module);\n                    return result;\n                }\n            }\n\n            // check the amount to authorize against the available balance of fin account, which includes active authorizations as well as transactions\n            BigDecimal availableBalance = finAccount.getBigDecimal(\"availableBalance\");\n            if (availableBalance == null) {\n                availableBalance = FinAccountHelper.ZERO;\n            }\n            \n            Map result = ServiceUtil.returnSuccess();\n            String authMessage = null;\n            Boolean processResult;\n            String refNum;\n\n            // turn amount into a big decimal, making sure to round and scale it to the same as availableBalance\n            BigDecimal amountBd = (new BigDecimal(amount)).setScale(FinAccountHelper.decimals, FinAccountHelper.rounding);\n\n            Debug.logInfo(\"Allow auth to negative: \" + allowAuthToNegative + \" :: available: \" + availableBalance + \" comp: \" + minBalance + \" = \" + availableBalance.compareTo(minBalance) + \" :: req: \" + amountBd, module);\n            // check the available balance to see if we can auth this tx\n            if ((\"Y\".equals(allowAuthToNegative) && availableBalance.compareTo(minBalance) > -1)\n                    || (availableBalance.compareTo(amountBd) > -1)) {\n                Timestamp thruDate;\n                \n                if (finAccountSettings != null && finAccountSettings.getLong(\"authValidDays\") != null) {\n                    thruDate = UtilDateTime.getDayEnd(UtilDateTime.nowTimestamp(), finAccountSettings.getLong(\"authValidDays\").intValue());\n                } else {\n                    thruDate = UtilDateTime.getDayEnd(UtilDateTime.nowTimestamp(), 30); // default 30 days for an auth\n                }\n\n                Map tmpResult = dispatcher.runSync(\"createFinAccountAuth\", UtilMisc.toMap(\"finAccountId\", finAccountId,\n                        \"amount\", amount, \"thruDate\", thruDate, \"userLogin\", userLogin));\n\n                if (ServiceUtil.isError(tmpResult)) {\n                    return tmpResult;\n                } else {\n                    refNum = (String) tmpResult.get(\"finAccountAuthId\");\n                    processResult = Boolean.TRUE;\n                }\n                                \n                // refresh the account\n                finAccount.refresh();\n            } else {\n                Debug.logError(\"Attempted to authorize [\" + amount + \"] against a balance of only [\" + availableBalance + \"]\", module);\n                refNum = \"0\"; // a refNum is always required from authorization\n                authMessage = \"Insufficient funds\";\n                processResult = Boolean.FALSE;\n            }\n\n            result.put(\"processAmount\", amount);\n            result.put(\"authMessage\", authMessage);\n            result.put(\"authResult\", processResult);\n            result.put(\"processAmount\", amount);\n            result.put(\"authFlag\", \"1\");\n            result.put(\"authCode\", \"A\");            \n            result.put(\"authRefNum\", refNum);\n            Debug.logInfo(\"FinAccont Auth: \" + result, module);\n\n            return result;\n        } catch (GenericEntityException ex) {\n            Debug.logError(ex, \"Cannot authorize financial account\", module);\n            return ServiceUtil.returnError(\"Cannot authorize financial account due to \" + ex.getMessage());\n        } catch (GenericServiceException ex) {\n            Debug.logError(ex, \"Cannot authorize gift certificate\", module);\n            return ServiceUtil.returnError(\"Cannot authorize financial account due to \" + ex.getMessage());\n        }\n    }","commit_id":"9c73979bbd673b0ea8f522dd844159fd0f9ccfbb","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map finAccountCapture(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericDelegator delegator = dctx.getDelegator();\n\n        GenericValue orderPaymentPreference = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        Double amount = (Double) context.get(\"captureAmount\");\n        String currency = (String) context.get(\"currency\");\n\n        // get the authorization transaction\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(orderPaymentPreference);\n        }\n        if (authTrans == null) {\n            return ServiceUtil.returnError(\"No authorization transaction found for the OrderPaymentPreference; cannot capture\");\n        }\n\n        // get the auth record\n        String finAccountAuthId = authTrans.getString(\"referenceNum\");\n        GenericValue finAccountAuth;\n        try {\n            finAccountAuth = delegator.findByPrimaryKey(\"FinAccountAuth\", UtilMisc.toMap(\"finAccountAuthId\", finAccountAuthId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        Debug.logInfo(\"Financial account capture [\" + finAccountAuth.get(\"finAccountId\") + \"] for the amount of $\" +\n                amount + \" Tx #\" + finAccountAuth.get(\"finAccountAuthId\"), module);\n\n        // get the financial account\n        GenericValue finAccount;\n        try {\n            finAccount = finAccountAuth.getRelatedOne(\"FinAccount\");\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n\n        // make sure authorization has not expired\n        Timestamp authExpiration = finAccountAuth.getTimestamp(\"thruDate\");\n        if ((authExpiration != null) && (authExpiration.before(UtilDateTime.nowTimestamp()))) {\n            return ServiceUtil.returnError(\"Authorization transaction [\" + authTrans.getString(\"paymentGatewayResponseId\") + \"] has expired as of \" + authExpiration);\n        }\n\n        // make sure the fin account itself has not expired\n        if ((finAccount.getTimestamp(\"thruDate\") != null) && (finAccount.getTimestamp(\"thruDate\").before(UtilDateTime.nowTimestamp()))) {\n            return ServiceUtil.returnError(\"Financial account has expired as of \" + finAccount.getTimestamp(\"thruDate\"));\n        }\n        String finAccountId = finAccount.getString(\"finAccountId\");\n\n        // need the product store ID & party ID\n        String orderId = orderPaymentPreference.getString(\"orderId\");\n        String productStoreId = null;\n        String partyId = null;\n        if (orderId != null) {\n            OrderReadHelper orh = new OrderReadHelper(delegator, orderId);\n            productStoreId = orh.getProductStoreId();\n\n            GenericValue billToParty = orh.getBillToParty();\n            if (billToParty != null) {\n                partyId = billToParty.getString(\"partyId\");\n            }\n        }\n\n        // build the withdraw context\n        Map withdrawCtx = FastMap.newInstance();\n        withdrawCtx.put(\"finAccountId\", finAccountId);\n        withdrawCtx.put(\"productStoreId\", productStoreId);\n        withdrawCtx.put(\"currency\", currency);\n        withdrawCtx.put(\"partyId\", partyId);\n        withdrawCtx.put(\"orderId\", orderId);\n        withdrawCtx.put(\"amount\", amount);\n        withdrawCtx.put(\"requireBalance\", Boolean.FALSE); // for captures; if auth passed, allow\n        withdrawCtx.put(\"userLogin\", userLogin);\n\n        // call the withdraw service\n        Map withdrawResp;\n        try {\n            withdrawResp = dispatcher.runSync(\"finAccountWithdraw\", withdrawCtx);\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (ServiceUtil.isError(withdrawResp)) {\n            return withdrawResp;\n        }\n\n        // cancel the authorization\n        Map releaseResult;\n        try {\n            releaseResult = dispatcher.runSync(\"expireFinAccountAuth\", UtilMisc.toMap(\"userLogin\", userLogin, \"finAccountAuthId\", finAccountAuthId));\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (ServiceUtil.isError(releaseResult)) {\n            return releaseResult;\n        }\n\n        // create the capture response\n        Map result = ServiceUtil.returnSuccess();\n        Boolean processResult = (Boolean) withdrawResp.get(\"processResult\");\n        Double withdrawAmount = (Double) withdrawResp.get(\"amount\");\n        String referenceNum = (String) withdrawResp.get(\"referenceNum\");\n        result.put(\"captureResult\", processResult);\n        result.put(\"captureRefNum\", referenceNum);\n        result.put(\"captureCode\", \"C\");\n        result.put(\"captureFlag\", \"1\");\n        result.put(\"captureAmount\", withdrawAmount);\n\n        return result;\n    }","id":95204,"modified_method":"public static Map finAccountCapture(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericDelegator delegator = dctx.getDelegator();\n\n        GenericValue orderPaymentPreference = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        Double amount = (Double) context.get(\"captureAmount\");\n        String currency = (String) context.get(\"currency\");\n\n        // get the authorization transaction\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(orderPaymentPreference);\n        }\n        if (authTrans == null) {\n            return ServiceUtil.returnError(\"No authorization transaction found for the OrderPaymentPreference; cannot capture\");\n        }\n\n        // get the auth record\n        String finAccountAuthId = authTrans.getString(\"referenceNum\");\n        GenericValue finAccountAuth;\n        try {\n            finAccountAuth = delegator.findByPrimaryKey(\"FinAccountAuth\", UtilMisc.toMap(\"finAccountAuthId\", finAccountAuthId));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        Debug.logInfo(\"Financial account capture [\" + finAccountAuth.get(\"finAccountId\") + \"] for the amount of $\" +\n                amount + \" Tx #\" + finAccountAuth.get(\"finAccountAuthId\"), module);\n\n        // get the financial account\n        GenericValue finAccount;\n        try {\n            finAccount = finAccountAuth.getRelatedOne(\"FinAccount\");\n        } catch (GenericEntityException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n\n        // make sure authorization has not expired\n        Timestamp authExpiration = finAccountAuth.getTimestamp(\"thruDate\");\n        if ((authExpiration != null) && (authExpiration.before(UtilDateTime.nowTimestamp()))) {\n            return ServiceUtil.returnError(\"Authorization transaction [\" + authTrans.getString(\"paymentGatewayResponseId\") + \"] has expired as of \" + authExpiration);\n        }\n\n        // make sure the fin account itself has not expired\n        if ((finAccount.getTimestamp(\"thruDate\") != null) && (finAccount.getTimestamp(\"thruDate\").before(UtilDateTime.nowTimestamp()))) {\n            return ServiceUtil.returnError(\"Financial account has expired as of \" + finAccount.getTimestamp(\"thruDate\"));\n        }\n        String finAccountId = finAccount.getString(\"finAccountId\");\n\n        // need the product store ID & party ID\n        String orderId = orderPaymentPreference.getString(\"orderId\");\n        String productStoreId = null;\n        String partyId = null;\n        if (orderId != null) {\n            OrderReadHelper orh = new OrderReadHelper(delegator, orderId);\n            productStoreId = orh.getProductStoreId();\n\n            GenericValue billToParty = orh.getBillToParty();\n            if (billToParty != null) {\n                partyId = billToParty.getString(\"partyId\");\n            }\n        }\n        \n        // BIG NOTE: make sure the expireFinAccountAuth and finAccountWithdraw services are done in the SAME TRANSACTION \n        //(ie no require-new-transaction in either of them AND no running async) \n\n        // cancel the authorization before doing the withdraw to avoid problems with way negative available amount on account; should happen in same transaction to avoid conflict problems\n        Map releaseResult;\n        try {\n            releaseResult = dispatcher.runSync(\"expireFinAccountAuth\", UtilMisc.toMap(\"userLogin\", userLogin, \"finAccountAuthId\", finAccountAuthId));\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (ServiceUtil.isError(releaseResult)) {\n            return releaseResult;\n        }\n\n        // build the withdraw context\n        Map withdrawCtx = FastMap.newInstance();\n        withdrawCtx.put(\"finAccountId\", finAccountId);\n        withdrawCtx.put(\"productStoreId\", productStoreId);\n        withdrawCtx.put(\"currency\", currency);\n        withdrawCtx.put(\"partyId\", partyId);\n        withdrawCtx.put(\"orderId\", orderId);\n        withdrawCtx.put(\"amount\", amount);\n        withdrawCtx.put(\"requireBalance\", Boolean.FALSE); // for captures; if auth passed, allow\n        withdrawCtx.put(\"userLogin\", userLogin);\n\n        // call the withdraw service\n        Map withdrawResp;\n        try {\n            withdrawResp = dispatcher.runSync(\"finAccountWithdraw\", withdrawCtx);\n        } catch (GenericServiceException e) {\n            Debug.logError(e, module);\n            return ServiceUtil.returnError(e.getMessage());\n        }\n        if (ServiceUtil.isError(withdrawResp)) {\n            return withdrawResp;\n        }\n\n        // create the capture response\n        Map result = ServiceUtil.returnSuccess();\n        Boolean processResult = (Boolean) withdrawResp.get(\"processResult\");\n        Double withdrawAmount = (Double) withdrawResp.get(\"amount\");\n        String referenceNum = (String) withdrawResp.get(\"referenceNum\");\n        result.put(\"captureResult\", processResult);\n        result.put(\"captureRefNum\", referenceNum);\n        result.put(\"captureCode\", \"C\");\n        result.put(\"captureFlag\", \"1\");\n        result.put(\"captureAmount\", withdrawAmount);\n\n        return result;\n    }","commit_id":"9c73979bbd673b0ea8f522dd844159fd0f9ccfbb","url":"https://github.com/apache/ofbiz"},{"original_method":"public File mergeMount(File f1, File f2,\n            ReferenceFactory<? extends Reference> factory,\n            Row payloadrow, File newFile, int writeBuffer) {\n        Log.logInfo(\"BLOBArray\", \"merging \" + f1.getName() + \" with \" + f2.getName());\n        File resultFile = mergeWorker(factory, this.keylength, this.ordering, f1, f2, payloadrow, newFile, writeBuffer);\n        if (resultFile == null) {\n            Log.logWarning(\"BLOBArray\", \"merge of files \" + f1 + \", \" + f2 + \" returned null. newFile = \" + newFile);\n            return null;\n        }\n        try {\n            mountBLOB(resultFile, false);\n        } catch (IOException e) {\n            Log.logWarning(\"BLOBArray\", \"merge of files \" + f1 + \", \" + f2 + \" successfull, but read failed. resultFile = \" + resultFile);\n            return null;\n        }\n        Log.logInfo(\"BLOBArray\", \"merged \" + f1.getName() + \" with \" + f2.getName() + \" into \" + resultFile);\n        return resultFile;\n    }","id":95205,"modified_method":"/**\n     * merge two blob files into one. If the second file is given as null,\n     * then the first file is only rewritten into a new one.\n     * @param f1\n     * @param f2 (may also be null)\n     * @param factory\n     * @param payloadrow\n     * @param newFile\n     * @param writeBuffer\n     * @return the target file where the given files are merged in\n     */\n    public File mergeMount(File f1, File f2,\n            ReferenceFactory<? extends Reference> factory,\n            Row payloadrow, File newFile, int writeBuffer) {\n        if (f2 == null) {\n            // this is a rewrite\n            Log.logInfo(\"BLOBArray\", \"rewrite of \" + f1.getName());\n            File resultFile = rewriteWorker(factory, this.keylength, this.ordering, f1, payloadrow, newFile, writeBuffer);\n            if (resultFile == null) {\n                Log.logWarning(\"BLOBArray\", \"rewrite of file \" + f1 + \" returned null. newFile = \" + newFile);\n                return null;\n            }\n            try {\n                mountBLOB(resultFile, false);\n            } catch (IOException e) {\n                Log.logWarning(\"BLOBArray\", \"rewrite of file \" + f1 + \" successfull, but read failed. resultFile = \" + resultFile);\n                return null;\n            }\n            Log.logInfo(\"BLOBArray\", \"rewrite of \" + f1.getName() + \" into \" + resultFile);\n            return resultFile;\n        } else {\n            Log.logInfo(\"BLOBArray\", \"merging \" + f1.getName() + \" with \" + f2.getName());\n            File resultFile = mergeWorker(factory, this.keylength, this.ordering, f1, f2, payloadrow, newFile, writeBuffer);\n            if (resultFile == null) {\n                Log.logWarning(\"BLOBArray\", \"merge of files \" + f1 + \", \" + f2 + \" returned null. newFile = \" + newFile);\n                return null;\n            }\n            try {\n                mountBLOB(resultFile, false);\n            } catch (IOException e) {\n                Log.logWarning(\"BLOBArray\", \"merge of files \" + f1 + \", \" + f2 + \" successfull, but read failed. resultFile = \" + resultFile);\n                return null;\n            }\n            Log.logInfo(\"BLOBArray\", \"merged \" + f1.getName() + \" with \" + f2.getName() + \" into \" + resultFile);\n            return resultFile;\n        }\n    }","commit_id":"83d05e9176f3e885b53336cbbabb6f5c5d8d784c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void run() {\r\n        MergeJob mergeJob;\r\n        DumpJob<? extends Reference> dumpJob;\r\n        try {\r\n            loop: while (true) try {\r\n                controlQueue.acquire();\r\n                \r\n                // prefer dump actions to flush memory to disc\r\n                if (!dumpQueue.isEmpty()) {\r\n                \tFile f = null;\r\n                    try {\r\n                        dumpJob = dumpQueue.take();\r\n                        f = dumpJob.file;\r\n                        dumpJob.dump();\r\n                    } catch (InterruptedException e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (1)\", e);\r\n                        Log.logException(e);\r\n                    } catch (Exception e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job had errors (1), dump to \" + f + \" failed.\", e);\r\n                        Log.logException(e);\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // otherwise do a merge operation\r\n                if (!mergeQueue.isEmpty()) {\r\n                \tFile f = null, f1 = null, f2 = null;\r\n                    try {\r\n                        mergeJob = mergeQueue.take();\r\n                        f = mergeJob.newFile;\r\n                        f1 = mergeJob.f1;\r\n                        f2 = mergeJob.f2;\r\n                        mergeJob.merge();\r\n                    } catch (InterruptedException e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (2)\", e);\r\n                        Log.logException(e);\r\n                    } catch (Exception e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job had errors (2), dump to \" + f + \" failed. Input files are \" + f1 + \" and \" + f2, e);\r\n                        Log.logException(e);\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // check termination\r\n                if (this.terminate) {\r\n                    Log.logInfo(\"IODispatcher\", \"caught termination signal\");\r\n                    break;\r\n                }\r\n\r\n                Log.logSevere(\"IODispatcher\", \"main loop in bad state, dumpQueue.size() = \" + dumpQueue.size() + \", mergeQueue.size() = \" + mergeQueue.size() + \", controlQueue.availablePermits() = \" + controlQueue.availablePermits());\r\n                assert false : \"this process statt should not be reached\"; // this should never happen\r\n            } catch (Exception e) {\r\n                Log.logSevere(\"IODispatcher\", \"main run job failed (X)\", e);\r\n                Log.logException(e);\r\n            }\r\n            Log.logInfo(\"IODispatcher\", \"loop terminated\");\r\n        } catch (Exception e) {\r\n            Log.logSevere(\"IODispatcher\", \"main run job failed (4)\", e);\r\n            Log.logException(e);\r\n        } finally {\r\n            Log.logInfo(\"IODispatcher\", \"terminating run job\");\r\n            controlQueue = null;\r\n            dumpQueue = null;\r\n            mergeQueue = null;\r\n            termination.release();\r\n        }\r\n    }","id":95206,"modified_method":"public void run() {\r\n        MergeJob mergeJob;\r\n        DumpJob<? extends Reference> dumpJob;\r\n        try {\r\n            loop: while (true) try {\r\n                controlQueue.acquire();\r\n                \r\n                // prefer dump actions to flush memory to disc\r\n                if (!dumpQueue.isEmpty()) {\r\n                \tFile f = null;\r\n                    try {\r\n                        dumpJob = dumpQueue.take();\r\n                        f = dumpJob.file;\r\n                        dumpJob.dump();\r\n                    } catch (InterruptedException e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (1)\", e);\r\n                        Log.logException(e);\r\n                    } catch (Exception e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job had errors (1), dump to \" + f + \" failed.\", e);\r\n                        Log.logException(e);\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // otherwise do a merge operation\r\n                if (!mergeQueue.isEmpty()) {\r\n                \tFile f = null, f1 = null, f2 = null;\r\n                    try {\r\n                        mergeJob = mergeQueue.take();\r\n                        f = mergeJob.newFile;\r\n                        f1 = mergeJob.f1;\r\n                        f2 = mergeJob.f2;\r\n                        mergeJob.merge();\r\n                    } catch (InterruptedException e) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job was interrupted (2)\", e);\r\n                        Log.logException(e);\r\n                    } catch (Exception e) {\r\n                        if (f2 == null) {\r\n                        Log.logSevere(\"IODispatcher\", \"main run job had errors (2), dump to \" + f + \" failed. Input file is \" + f1, e);\r\n                        } else {\r\n                            Log.logSevere(\"IODispatcher\", \"main run job had errors (2), dump to \" + f + \" failed. Input files are \" + f1 + \" and \" + f2, e);\r\n                        }\r\n                        Log.logException(e);\r\n                    }\r\n                    continue loop;\r\n                }\r\n                \r\n                // check termination\r\n                if (this.terminate) {\r\n                    Log.logInfo(\"IODispatcher\", \"caught termination signal\");\r\n                    break;\r\n                }\r\n\r\n                Log.logSevere(\"IODispatcher\", \"main loop in bad state, dumpQueue.size() = \" + dumpQueue.size() + \", mergeQueue.size() = \" + mergeQueue.size() + \", controlQueue.availablePermits() = \" + controlQueue.availablePermits());\r\n                assert false : \"this process statt should not be reached\"; // this should never happen\r\n            } catch (Exception e) {\r\n                Log.logSevere(\"IODispatcher\", \"main run job failed (X)\", e);\r\n                Log.logException(e);\r\n            }\r\n            Log.logInfo(\"IODispatcher\", \"loop terminated\");\r\n        } catch (Exception e) {\r\n            Log.logSevere(\"IODispatcher\", \"main run job failed (4)\", e);\r\n            Log.logException(e);\r\n        } finally {\r\n            Log.logInfo(\"IODispatcher\", \"terminating run job\");\r\n            controlQueue = null;\r\n            dumpQueue = null;\r\n            mergeQueue = null;\r\n            termination.release();\r\n        }\r\n    }","commit_id":"83d05e9176f3e885b53336cbbabb6f5c5d8d784c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized void merge(File f1, File f2, ReferenceFactory<? extends Reference> factory, ArrayStack array, Row payloadrow, File newFile) {\r\n        if (mergeQueue == null || controlQueue == null || !this.isAlive()) {\r\n            Log.logWarning(\"IODispatcher\", \"emergency merge of files \" + f1.getName() + \", \" + f2.getName() + \" to \" + newFile.getName());\r\n            array.mergeMount(f1, f2, factory, payloadrow, newFile, (int) Math.min(MemoryControl.available() / 3, writeBufferSize));\r\n        } else {\r\n            MergeJob job = new MergeJob(f1, f2, factory, array, payloadrow, newFile);\r\n            try {\r\n                if (this.isAlive()) {\r\n                    this.mergeQueue.put(job);\r\n                    this.controlQueue.release();\r\n                    Log.logInfo(\"IODispatcher\", \"appended merge job of files \" + f1.getName() + \", \" + f2.getName() + \" to \" + newFile.getName());\r\n                } else {\r\n                    job.merge();\r\n                    Log.logWarning(\"IODispatcher\", \"dispatcher not running, merged files \" + f1.getName() + \", \" + f2.getName() + \" to \" + newFile.getName());\r\n                }\r\n            } catch (InterruptedException e) {\r\n                Log.logWarning(\"IODispatcher\", \"interrupted: \" + e.getMessage(), e);\r\n                array.mergeMount(f1, f2, factory, payloadrow, newFile, (int) Math.min(MemoryControl.available() / 3, writeBufferSize));\r\n            }\r\n        }\r\n    }","id":95207,"modified_method":"public synchronized void merge(File f1, File f2, ReferenceFactory<? extends Reference> factory, ArrayStack array, Row payloadrow, File newFile) {\r\n        if (mergeQueue == null || controlQueue == null || !this.isAlive()) {\r\n            if (f2 == null) {\r\n                Log.logWarning(\"IODispatcher\", \"emergency rewrite of file \" + f1.getName() + \" to \" + newFile.getName());\r\n            } else {\r\n                Log.logWarning(\"IODispatcher\", \"emergency merge of files \" + f1.getName() + \", \" + f2.getName() + \" to \" + newFile.getName());\r\n            }\r\n            array.mergeMount(f1, f2, factory, payloadrow, newFile, (int) Math.min(MemoryControl.available() / 3, writeBufferSize));\r\n        } else {\r\n            MergeJob job = new MergeJob(f1, f2, factory, array, payloadrow, newFile);\r\n            try {\r\n                if (this.isAlive()) {\r\n                    this.mergeQueue.put(job);\r\n                    this.controlQueue.release();\r\n                    if (f2 == null) {\r\n                        Log.logInfo(\"IODispatcher\", \"appended rewrite job of file \" + f1.getName() + \" to \" + newFile.getName());\r\n                    } else {\r\n                        Log.logInfo(\"IODispatcher\", \"appended merge job of files \" + f1.getName() + \", \" + f2.getName() + \" to \" + newFile.getName());\r\n                    }\r\n                } else {\r\n                    job.merge();\r\n                    if (f2 == null) {\r\n                        Log.logWarning(\"IODispatcher\", \"dispatcher not running, merged files \" + f1.getName() + \" to \" + newFile.getName());\r\n                    } else {\r\n                        Log.logWarning(\"IODispatcher\", \"dispatcher not running, rewrote file \" + f1.getName() + \", \" + f2.getName() + \" to \" + newFile.getName());\r\n                    }\r\n                }\r\n            } catch (InterruptedException e) {\r\n                Log.logWarning(\"IODispatcher\", \"interrupted: \" + e.getMessage(), e);\r\n                array.mergeMount(f1, f2, factory, payloadrow, newFile, (int) Math.min(MemoryControl.available() / 3, writeBufferSize));\r\n            }\r\n        }\r\n    }","commit_id":"83d05e9176f3e885b53336cbbabb6f5c5d8d784c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public File merge() {\r\n        \tif (!f1.exists()) {\r\n        \t\tLog.logWarning(\"IODispatcher\", \"merge of file (1) \" + f1.getName() + \" failed: file does not exists\");\r\n        \t\treturn null;\r\n        \t}\r\n        \tif (!f2.exists()) {\r\n        \t\tLog.logWarning(\"IODispatcher\", \"merge of file (2) \" + f2.getName() + \" failed: file does not exists\");\r\n        \t\treturn null;\r\n        \t}\r\n            return array.mergeMount(f1, f2, factory, payloadrow, newFile, (int) Math.min(MemoryControl.available() / 3, writeBufferSize));\r\n        }","id":95208,"modified_method":"public File merge() {\r\n        \tif (!f1.exists()) {\r\n        \t\tLog.logWarning(\"IODispatcher\", \"merge of file (1) \" + f1.getName() + \" failed: file does not exists\");\r\n        \t\treturn null;\r\n        \t}\r\n        \tif (f2 != null && !f2.exists()) {\r\n        \t\tLog.logWarning(\"IODispatcher\", \"merge of file (2) \" + f2.getName() + \" failed: file does not exists\");\r\n        \t\treturn null;\r\n        \t}\r\n            return array.mergeMount(f1, f2, factory, payloadrow, newFile, (int) Math.min(MemoryControl.available() / 3, writeBufferSize));\r\n        }","commit_id":"83d05e9176f3e885b53336cbbabb6f5c5d8d784c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized boolean shrink(long targetFileSize, long maxFileSize) {\r\n        if (this.array.entries() < 2) return false;\r\n        boolean donesomething = false;\r\n        \r\n        // first try to merge small files that match\r\n        while (this.merger.queueLength() < 3 || this.array.entries() >= 50) {\r\n            File[] ff = this.array.unmountBestMatch(2.0, targetFileSize);\r\n            if (ff == null) break;\r\n            Log.logInfo(\"RICELL-shrink1\", \"unmountBestMatch(2.0, \" + targetFileSize + \")\");\r\n            merger.merge(ff[0], ff[1], this.factory, this.array, this.payloadrow, newContainerBLOBFile());\r\n            donesomething = true;\r\n        }\r\n        \r\n        // then try to merge simply any small file\r\n        while (this.merger.queueLength() < 2) {\r\n            File[] ff = this.array.unmountSmallest(targetFileSize);\r\n            if (ff == null) break;\r\n            Log.logInfo(\"RICELL-shrink2\", \"unmountSmallest(\" + targetFileSize + \")\");\r\n            merger.merge(ff[0], ff[1], this.factory, this.array, this.payloadrow, newContainerBLOBFile());\r\n            donesomething = true;\r\n        }\r\n        \r\n        // if there is no small file, then merge matching files up to limit\r\n        while (this.merger.queueLength() < 1) {\r\n            File[] ff = this.array.unmountBestMatch(2.0, maxFileSize);\r\n            if (ff == null) break;\r\n            Log.logInfo(\"RICELL-shrink3\", \"unmountBestMatch(2.0, \" + maxFileSize + \")\");\r\n            merger.merge(ff[0], ff[1], this.factory, this.array, this.payloadrow, newContainerBLOBFile());\r\n            donesomething = true;\r\n        }\r\n\r\n        return donesomething;\r\n    }","id":95209,"modified_method":"public synchronized boolean shrink(long targetFileSize, long maxFileSize) {\r\n        if (this.array.entries() < 2) return false;\r\n        boolean donesomething = false;\r\n        \r\n        // first try to merge small files that match\r\n        while (this.merger.queueLength() < 3 || this.array.entries() >= 50) {\r\n            File[] ff = this.array.unmountBestMatch(2.0, targetFileSize);\r\n            if (ff == null) break;\r\n            Log.logInfo(\"RICELL-shrink1\", \"unmountBestMatch(2.0, \" + targetFileSize + \")\");\r\n            merger.merge(ff[0], ff[1], this.factory, this.array, this.payloadrow, newContainerBLOBFile());\r\n            donesomething = true;\r\n        }\r\n        \r\n        // then try to merge simply any small file\r\n        while (this.merger.queueLength() < 2) {\r\n            File[] ff = this.array.unmountSmallest(targetFileSize);\r\n            if (ff == null) break;\r\n            Log.logInfo(\"RICELL-shrink2\", \"unmountSmallest(\" + targetFileSize + \")\");\r\n            merger.merge(ff[0], ff[1], this.factory, this.array, this.payloadrow, newContainerBLOBFile());\r\n            donesomething = true;\r\n        }\r\n        \r\n        // if there is no small file, then merge matching files up to limit\r\n        while (this.merger.queueLength() < 1) {\r\n            File[] ff = this.array.unmountBestMatch(2.0, maxFileSize);\r\n            if (ff == null) break;\r\n            Log.logInfo(\"RICELL-shrink3\", \"unmountBestMatch(2.0, \" + maxFileSize + \")\");\r\n            merger.merge(ff[0], ff[1], this.factory, this.array, this.payloadrow, newContainerBLOBFile());\r\n            donesomething = true;\r\n        }\r\n\r\n        // merge very old files with it self (hack from sixcooler, see http://forum.yacy-websuche.de/viewtopic.php?p=15004#p15004)\r\n        while (this.merger.queueLength() < 1) {\r\n            File ff = this.array.unmountOldest();\r\n            if (ff == null) break;\r\n            Log.logInfo(\"RICELL-shrink4/rewrite\", \"unmountOldest()\");\r\n            merger.merge(ff, null, this.factory, this.array, this.payloadrow, newContainerBLOBFile());\r\n            donesomething = true;\r\n        }\r\n\r\n        return donesomething;\r\n    }","commit_id":"83d05e9176f3e885b53336cbbabb6f5c5d8d784c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    AttributeAccess getAttributeAccess(final ListIterator<PathElement> iterator, final String attributeName) {\n\n        if (iterator.hasNext()) {\n            final PathElement next = iterator.next();\n            final NodeSubregistry subregistry = children.get(next.getKey());\n            if (subregistry == null) {\n                return null;\n            }\n            return subregistry.getAttributeAccess(iterator, next.getValue(), attributeName);\n        } else {\n            checkPermission();\n            final Map<String, AttributeAccess> snapshot = attributesUpdater.get(this);\n            AttributeAccess access = snapshot.get(attributeName);\n            if (access == null && hasNoAlternativeWildcardRegistration()) {\n                // If there is metadata for an attribute but no AttributeAccess, assume RO. Can't\n                // be writable without a registered handler. This opens the possibility that out-of-date metadata\n                // for attribute \"foo\" can lead to a read of non-existent-in-model \"foo\" with\n                // an unexpected undefined value returned. But it removes the possibility of a\n                // dev forgetting to call registry.registerReadOnlyAttribute(\"foo\", null) resulting\n                // in the valid attribute \"foo\" not being readable\n                final ModelNode desc = resourceDefinition.getDescriptionProvider(this).getModelDescription(null);\n                if (desc.has(ATTRIBUTES) && desc.get(ATTRIBUTES).keys().contains(attributeName)) {\n                    access = new AttributeAccess(AccessType.READ_ONLY, Storage.CONFIGURATION, null, null, null, null);\n                }\n            }\n            return access;\n        }\n    }","id":95210,"modified_method":"@Override\n    AttributeAccess getAttributeAccess(final ListIterator<PathElement> iterator, final String attributeName) {\n\n        if (iterator.hasNext()) {\n            final PathElement next = iterator.next();\n            final NodeSubregistry subregistry = children.get(next.getKey());\n            if (subregistry == null) {\n                return null;\n            }\n            return subregistry.getAttributeAccess(iterator, next.getValue(), attributeName);\n        } else {\n            checkPermission();\n            final Map<String, AttributeAccess> snapshot = attributesUpdater.get(this);\n            AttributeAccess access = snapshot.get(attributeName);\n            if (access == null && hasNoAlternativeWildcardRegistration()) {\n                // If there is metadata for an attribute but no AttributeAccess, assume RO. Can't\n                // be writable without a registered handler. This opens the possibility that out-of-date metadata\n                // for attribute \"foo\" can lead to a read of non-existent-in-model \"foo\" with\n                // an unexpected undefined value returned. But it removes the possibility of a\n                // dev forgetting to call registry.registerReadOnlyAttribute(\"foo\", null) resulting\n                // in the valid attribute \"foo\" not being readable\n                DescriptionProvider provider = resourceDefinition.getDescriptionProvider(this);\n                if (provider instanceof DefaultResourceDescriptionProvider){\n                    return null; // attribute was not registered so it does not exist. no need to read resource description as we wont find anything and cause SO\n                }\n                //todo get rid of this fallback loop as with code cleanup we wont need it anymore.\n                final ModelNode desc = resourceDefinition.getDescriptionProvider(this).getModelDescription(null);\n                if (desc.has(ATTRIBUTES) && desc.get(ATTRIBUTES).keys().contains(attributeName)) {\n                    access = new AttributeAccess(AccessType.READ_ONLY, Storage.CONFIGURATION, null, null, null, null);\n                }\n            }\n            return access;\n        }\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testHandlersOnRootResource() throws Exception {\n\n        rootRegistration.registerOperationHandler(\"one\", TestHandler.ONE, new TestDescriptionProvider(\"one\"));\n        rootRegistration.registerOperationHandler(\"two\", TestHandler.TWO, new TestDescriptionProvider(\"two\"), false,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n\n        OperationStepHandler oneHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        OperationStepHandler twoHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n    }","id":95211,"modified_method":"@Test\n    public void testHandlersOnRootResource() throws Exception {\n\n        rootRegistration.registerOperationHandler(getOpDef(\"one\"), TestHandler.ONE);\n        rootRegistration.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.READ_ONLY), TestHandler.TWO);\n\n        OperationStepHandler oneHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        OperationStepHandler twoHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Before\n    public void setup() {\n        rootRegistration = ManagementResourceRegistration.Factory.create(new TestDescriptionProvider(\"RootResource\"));\n    }","id":95212,"modified_method":"@Before\n    public void setup() {\n        rootRegistration = ManagementResourceRegistration.Factory.create(new SimpleResourceDefinition(null, new NonResolvingResourceDescriptionResolver()));\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testHandlersOnChildResource() throws Exception {\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(childElement, new TestDescriptionProvider(\"child\"));\n        child.registerOperationHandler(\"one\", TestHandler.ONE, new TestDescriptionProvider(\"one\"));\n        child.registerOperationHandler(\"two\", TestHandler.TWO, new TestDescriptionProvider(\"two\"), false,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n\n        OperationStepHandler oneHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        OperationStepHandler twoHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(childAddress, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(childAddress, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(fullChildAddress, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(fullChildAddress, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNull(oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNull(twoHandler);\n    }","id":95213,"modified_method":"@Test\n    public void testHandlersOnChildResource() throws Exception {\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(new SimpleResourceDefinition(childElement, new NonResolvingResourceDescriptionResolver()));\n        child.registerOperationHandler(getOpDef(\"one\"), TestHandler.ONE);\n        child.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.READ_ONLY), TestHandler.TWO);\n\n\n        OperationStepHandler oneHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        OperationStepHandler twoHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(childAddress, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(childAddress, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(fullChildAddress, \"one\");\n        assertSame(TestHandler.ONE, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(fullChildAddress, \"two\");\n        assertSame(TestHandler.TWO, twoHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNull(oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNull(twoHandler);\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testInheritedAccessConstraints() {\n\n        ResourceDefinition rootRd = new SimpleResourceDefinition(null, new NonResolvingResourceDescriptionResolver()) {\n            @Override\n            public List<AccessConstraintDefinition> getAccessConstraints() {\n                return Arrays.asList(\n                        (AccessConstraintDefinition) SensitiveTargetAccessConstraintDefinition.EXTENSIONS,\n                        (AccessConstraintDefinition) ApplicationTypeAccessConstraintDefinition.DEPLOYMENT\n                );\n            }\n        };\n        ManagementResourceRegistration root = ManagementResourceRegistration.Factory.create(rootRd);\n\n        List<AccessConstraintDefinition> acds = root.getAccessConstraints();\n        assertEquals(2, acds.size());\n        assertTrue(acds.contains(SensitiveTargetAccessConstraintDefinition.EXTENSIONS));\n        assertTrue(acds.contains(ApplicationTypeAccessConstraintDefinition.DEPLOYMENT));\n\n        ResourceDefinition childRd = new SimpleResourceDefinition(PathElement.pathElement(\"child\"), new NonResolvingResourceDescriptionResolver()) {\n            @Override\n            public List<AccessConstraintDefinition> getAccessConstraints() {\n                return Arrays.asList(\n                        (AccessConstraintDefinition) SensitiveTargetAccessConstraintDefinition.SECURITY_DOMAIN,\n                        (AccessConstraintDefinition) ApplicationTypeAccessConstraintDefinition.DEPLOYMENT\n                );\n            }\n        };\n        ManagementResourceRegistration child = root.registerSubModel(childRd);\n        acds = child.getAccessConstraints();\n        assertEquals(4, acds.size());\n        assertTrue(acds.contains(SensitiveTargetAccessConstraintDefinition.EXTENSIONS));\n        assertTrue(acds.contains(SensitiveTargetAccessConstraintDefinition.SECURITY_DOMAIN));\n        assertTrue(acds.contains(ApplicationTypeAccessConstraintDefinition.DEPLOYMENT));\n    }","id":95214,"modified_method":"@Test\n    public void testInheritedAccessConstraints() {\n\n        ResourceDefinition rootRd = new SimpleResourceDefinition(null, new NonResolvingResourceDescriptionResolver()) {\n            @Override\n            public List<AccessConstraintDefinition> getAccessConstraints() {\n                return Arrays.asList(\n                        SensitiveTargetAccessConstraintDefinition.EXTENSIONS,\n                        ApplicationTypeAccessConstraintDefinition.DEPLOYMENT\n                );\n            }\n        };\n        ManagementResourceRegistration root = ManagementResourceRegistration.Factory.create(rootRd);\n\n        List<AccessConstraintDefinition> acds = root.getAccessConstraints();\n        assertEquals(2, acds.size());\n        assertTrue(acds.contains(SensitiveTargetAccessConstraintDefinition.EXTENSIONS));\n        assertTrue(acds.contains(ApplicationTypeAccessConstraintDefinition.DEPLOYMENT));\n\n        ResourceDefinition childRd = new SimpleResourceDefinition(PathElement.pathElement(\"child\"), new NonResolvingResourceDescriptionResolver()) {\n            @Override\n            public List<AccessConstraintDefinition> getAccessConstraints() {\n                return Arrays.asList(\n                        SensitiveTargetAccessConstraintDefinition.SECURITY_DOMAIN,\n                        ApplicationTypeAccessConstraintDefinition.DEPLOYMENT\n                );\n            }\n        };\n        ManagementResourceRegistration child = root.registerSubModel(childRd);\n        acds = child.getAccessConstraints();\n        assertEquals(4, acds.size());\n        assertTrue(acds.contains(SensitiveTargetAccessConstraintDefinition.EXTENSIONS));\n        assertTrue(acds.contains(SensitiveTargetAccessConstraintDefinition.SECURITY_DOMAIN));\n        assertTrue(acds.contains(ApplicationTypeAccessConstraintDefinition.DEPLOYMENT));\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testHandlerInheritance() throws Exception {\n\n        rootRegistration.registerOperationHandler(\"one\", TestHandler.PARENT, new TestDescriptionProvider(\"one\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        rootRegistration.registerOperationHandler(\"two\", TestHandler.PARENT, new TestDescriptionProvider(\"two\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        rootRegistration.registerOperationHandler(\"three\", TestHandler.PARENT, new TestDescriptionProvider(\"three\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        rootRegistration.registerOperationHandler(\"four\", TestHandler.PARENT, new TestDescriptionProvider(\"four\"), false,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(childElement, new TestDescriptionProvider(\"child\"));\n        child.registerOperationHandler(\"one\", TestHandler.CHILD, new TestDescriptionProvider(\"one\"), true);\n        child.registerOperationHandler(\"two\", TestHandler.CHILD, new TestDescriptionProvider(\"two\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        ManagementResourceRegistration grandchild = child.registerSubModel(grandchildElement, new TestDescriptionProvider(\"grandchild\"));\n\n        OperationStepHandler oneHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        OperationStepHandler twoHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        OperationStepHandler threeHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(childAddress, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(childAddress, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        threeHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        OperationStepHandler fourHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertNull(fourHandler);\n\n        fourHandler = rootRegistration.getOperationHandler(childAddress, \"four\");\n        assertNull(fourHandler);\n\n        // Sanity check\n        fourHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertSame(TestHandler.PARENT, fourHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(grandchildAddress, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(fullGrandchildAddress, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        oneHandler = grandchild.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(grandchildAddress, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(fullGrandchildAddress, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        twoHandler = grandchild.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        threeHandler = rootRegistration.getOperationHandler(grandchildAddress, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        threeHandler = rootRegistration.getOperationHandler(fullGrandchildAddress, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        threeHandler = grandchild.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n    }","id":95215,"modified_method":"@Test\n    public void testHandlerInheritance() throws Exception {\n\n        rootRegistration.registerOperationHandler(getOpDef(\"one\", OperationEntry.Flag.READ_ONLY), TestHandler.PARENT, true);\n        rootRegistration.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.READ_ONLY), TestHandler.PARENT, true);\n        rootRegistration.registerOperationHandler(getOpDef(\"three\", OperationEntry.Flag.READ_ONLY), TestHandler.PARENT, true);\n        rootRegistration.registerOperationHandler(getOpDef(\"four\", OperationEntry.Flag.READ_ONLY), TestHandler.PARENT, false);\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(new SimpleResourceDefinition(childElement, new NonResolvingResourceDescriptionResolver()));\n        child.registerOperationHandler(getOpDef(\"one\"), TestHandler.CHILD, true);\n        child.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY), TestHandler.CHILD, true);\n\n        ManagementResourceRegistration grandchild = child.registerSubModel(new SimpleResourceDefinition(grandchildElement, new NonResolvingResourceDescriptionResolver()));\n\n        OperationStepHandler oneHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        OperationStepHandler twoHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        OperationStepHandler threeHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(childAddress, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(childAddress, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        threeHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        OperationStepHandler fourHandler = child.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertNull(fourHandler);\n\n        fourHandler = rootRegistration.getOperationHandler(childAddress, \"four\");\n        assertNull(fourHandler);\n\n        // Sanity check\n        fourHandler = rootRegistration.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertSame(TestHandler.PARENT, fourHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(grandchildAddress, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        oneHandler = rootRegistration.getOperationHandler(fullGrandchildAddress, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        oneHandler = grandchild.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertSame(TestHandler.CHILD, oneHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(grandchildAddress, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        twoHandler = rootRegistration.getOperationHandler(fullGrandchildAddress, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        twoHandler = grandchild.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertSame(TestHandler.CHILD, twoHandler);\n\n        threeHandler = rootRegistration.getOperationHandler(grandchildAddress, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        threeHandler = rootRegistration.getOperationHandler(fullGrandchildAddress, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n\n        threeHandler = grandchild.getOperationHandler(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertSame(TestHandler.PARENT, threeHandler);\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testFlagsOnRootResource() throws Exception {\n\n        rootRegistration.registerOperationHandler(\"one\", TestHandler.INSTANCE, new TestDescriptionProvider(\"one\"));\n        rootRegistration.registerOperationHandler(\"two\", TestHandler.INSTANCE, new TestDescriptionProvider(\"two\"), false,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n\n        Set<OperationEntry.Flag> oneFlags = rootRegistration.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        Set<OperationEntry.Flag> twoFlags = rootRegistration.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n    }","id":95216,"modified_method":"@Test\n    public void testFlagsOnRootResource() throws Exception {\n\n        rootRegistration.registerOperationHandler(getOpDef(\"one\"), TestHandler.INSTANCE);\n        rootRegistration.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.READ_ONLY), TestHandler.INSTANCE, false);\n\n        Set<OperationEntry.Flag> oneFlags = rootRegistration.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        Set<OperationEntry.Flag> twoFlags = rootRegistration.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testFlagsOnChildResource() throws Exception {\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(childElement, new TestDescriptionProvider(\"child\"));\n        child.registerOperationHandler(\"one\", TestHandler.INSTANCE, new TestDescriptionProvider(\"one\"));\n        child.registerOperationHandler(\"two\", TestHandler.INSTANCE, new TestDescriptionProvider(\"two\"), false,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n\n        Set<OperationEntry.Flag> oneFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        Set<OperationEntry.Flag> twoFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n\n        oneFlags = rootRegistration.getOperationFlags(childAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(childAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n\n        oneFlags = rootRegistration.getOperationFlags(fullChildAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(fullChildAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n    }","id":95217,"modified_method":"@Test\n    public void testFlagsOnChildResource() throws Exception {\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(new SimpleResourceDefinition(childElement, new NonResolvingResourceDescriptionResolver()));\n        child.registerOperationHandler(getOpDef(\"one\"), TestHandler.INSTANCE);\n        child.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.READ_ONLY), TestHandler.INSTANCE, false);\n\n        Set<OperationEntry.Flag> oneFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        Set<OperationEntry.Flag> twoFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n\n        oneFlags = rootRegistration.getOperationFlags(childAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(childAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n\n        oneFlags = rootRegistration.getOperationFlags(fullChildAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(fullChildAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testFlagsInheritance() throws Exception {\n\n        rootRegistration.registerOperationHandler(\"one\", TestHandler.INSTANCE, new TestDescriptionProvider(\"one\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        rootRegistration.registerOperationHandler(\"two\", TestHandler.INSTANCE, new TestDescriptionProvider(\"two\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        rootRegistration.registerOperationHandler(\"three\", TestHandler.INSTANCE, new TestDescriptionProvider(\"three\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n        rootRegistration.registerOperationHandler(\"four\", TestHandler.INSTANCE, new TestDescriptionProvider(\"four\"), false,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.READ_ONLY));\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(childElement, new TestDescriptionProvider(\"child\"));\n        child.registerOperationHandler(\"one\", TestHandler.INSTANCE, new TestDescriptionProvider(\"one\"), true);\n        child.registerOperationHandler(\"two\", TestHandler.INSTANCE, new TestDescriptionProvider(\"two\"), true,\n                OperationEntry.EntryType.PUBLIC, EnumSet.of(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        ManagementResourceRegistration grandchild = child.registerSubModel(grandchildElement, new TestDescriptionProvider(\"grandchild\"));\n\n        Set<OperationEntry.Flag> oneFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        Set<OperationEntry.Flag> twoFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        Set<OperationEntry.Flag> threeFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        oneFlags = rootRegistration.getOperationFlags(childAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(childAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        threeFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        Set<OperationEntry.Flag> fourFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertNull(fourFlags);\n\n        fourFlags = rootRegistration.getOperationFlags(childAddress, \"four\");\n        assertNull(fourFlags);\n\n        // Sanity check\n        fourFlags = rootRegistration.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertNotNull(fourFlags);\n        assertEquals(1, fourFlags.size());\n        assertTrue(fourFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        oneFlags = rootRegistration.getOperationFlags(grandchildAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        oneFlags = rootRegistration.getOperationFlags(fullGrandchildAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        oneFlags = grandchild.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(grandchildAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        twoFlags = rootRegistration.getOperationFlags(fullGrandchildAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        twoFlags = grandchild.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        threeFlags = rootRegistration.getOperationFlags(grandchildAddress, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        threeFlags = rootRegistration.getOperationFlags(fullGrandchildAddress, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        threeFlags = grandchild.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n    }","id":95218,"modified_method":"@Test\n    public void testFlagsInheritance() throws Exception {\n\n        rootRegistration.registerOperationHandler(getOpDef(\"one\", OperationEntry.Flag.READ_ONLY), TestHandler.INSTANCE, true);\n        rootRegistration.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.READ_ONLY), TestHandler.INSTANCE, true);\n        rootRegistration.registerOperationHandler(getOpDef(\"three\", OperationEntry.Flag.READ_ONLY), TestHandler.INSTANCE, true);\n        rootRegistration.registerOperationHandler(getOpDef(\"four\", OperationEntry.Flag.READ_ONLY), TestHandler.INSTANCE, false);\n\n        ManagementResourceRegistration child = rootRegistration.registerSubModel(new SimpleResourceDefinition(childElement, new NonResolvingResourceDescriptionResolver()));\n        child.registerOperationHandler(getOpDef(\"one\"), TestHandler.INSTANCE, true);\n        child.registerOperationHandler(getOpDef(\"two\", OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY), TestHandler.INSTANCE, true);\n\n        ManagementResourceRegistration grandchild = child.registerSubModel(new SimpleResourceDefinition(grandchildElement, new NonResolvingResourceDescriptionResolver()));\n\n        Set<OperationEntry.Flag> oneFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        Set<OperationEntry.Flag> twoFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        Set<OperationEntry.Flag> threeFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        oneFlags = rootRegistration.getOperationFlags(childAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(childAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        threeFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        Set<OperationEntry.Flag> fourFlags = child.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertNull(fourFlags);\n\n        fourFlags = rootRegistration.getOperationFlags(childAddress, \"four\");\n        assertNull(fourFlags);\n\n        // Sanity check\n        fourFlags = rootRegistration.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"four\");\n        assertNotNull(fourFlags);\n        assertEquals(1, fourFlags.size());\n        assertTrue(fourFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        oneFlags = rootRegistration.getOperationFlags(grandchildAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        oneFlags = rootRegistration.getOperationFlags(fullGrandchildAddress, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        oneFlags = grandchild.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"one\");\n        assertNotNull(oneFlags);\n        assertEquals(0, oneFlags.size());\n\n        twoFlags = rootRegistration.getOperationFlags(grandchildAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        twoFlags = rootRegistration.getOperationFlags(fullGrandchildAddress, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        twoFlags = grandchild.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"two\");\n        assertNotNull(twoFlags);\n        assertEquals(1, twoFlags.size());\n        assertTrue(twoFlags.contains(OperationEntry.Flag.MASTER_HOST_CONTROLLER_ONLY));\n\n        threeFlags = rootRegistration.getOperationFlags(grandchildAddress, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        threeFlags = rootRegistration.getOperationFlags(fullGrandchildAddress, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n\n        threeFlags = grandchild.getOperationFlags(PathAddress.EMPTY_ADDRESS, \"three\");\n        assertNotNull(threeFlags);\n        assertEquals(1, threeFlags.size());\n        assertTrue(threeFlags.contains(OperationEntry.Flag.READ_ONLY));\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@BeforeClass\n    public static void setup() {\n        registration = ManagementResourceRegistration.Factory.create(rootDP);\n\n        parentWildReg = registration.registerSubModel(parentWild, parentWildDP);\n        parentWildReg.registerReadOnlyAttribute(\"wildAttr\", parentWildAttr, AttributeAccess.Storage.CONFIGURATION);\n        parentWildReg.registerOperationHandler(\"wildOp\", parentWildOp, new TestDescriptionProvider(\"wildOp\"));\n        parentWildReg.registerReadOnlyAttribute(\"overrideAttr\", parentWildOverrideAttr, AttributeAccess.Storage.CONFIGURATION);\n        parentWildReg.registerOperationHandler(\"overrideOp\", parentWildOverrideOp, new TestDescriptionProvider(\"overrideOp\"));\n\n        parentExtReg = registration.registerSubModel(parentExt, parentExtDP);\n        parentExtReg.registerReadOnlyAttribute(\"extAttr\", parentExtAttr, AttributeAccess.Storage.CONFIGURATION);\n        parentExtReg.registerOperationHandler(\"extOp\", parentExtOp, new TestDescriptionProvider(\"extOp\"));\n        parentExtReg.registerReadOnlyAttribute(\"overrideAttr\", parentExtOverrideAttr, AttributeAccess.Storage.CONFIGURATION);\n        parentExtReg.registerOperationHandler(\"overrideOp\", parentExtOverrideOp, new TestDescriptionProvider(\"overrideOp\"));\n\n        childWildReg = parentWildReg.registerSubModel(childWild, childWildDP);\n        childWildReg.registerReadOnlyAttribute(\"wildAttr\", childWildAttr, AttributeAccess.Storage.CONFIGURATION);\n        childWildReg.registerOperationHandler(\"wildOp\", childWildOp, new TestDescriptionProvider(\"wildOp\"));\n        childWildReg.registerReadOnlyAttribute(\"overrideAttr\", childWildOverrideAttr, AttributeAccess.Storage.CONFIGURATION);\n        childWildReg.registerOperationHandler(\"overrideOp\", childWildOverrideOp, new TestDescriptionProvider(\"overrideOp\"));\n\n        childWildExtReg = parentWildReg.registerSubModel(childWildExt, childWildExtDP);\n        childWildExtReg.registerReadOnlyAttribute(\"wildExtAttr\", childWildExtAttr, AttributeAccess.Storage.CONFIGURATION);\n        childWildExtReg.registerOperationHandler(\"wildExtOp\", childWildExtOp, new TestDescriptionProvider(\"wildExtOp\"));\n\n        childExtReg = parentExtReg.registerSubModel(childExt, childExtDP);\n        childExtReg.registerReadOnlyAttribute(\"extAttr\", childExtAttr, AttributeAccess.Storage.CONFIGURATION);\n        childExtReg.registerOperationHandler(\"extOp\", childExtOp, new TestDescriptionProvider(\"extOp\"));\n        childExtReg.registerReadOnlyAttribute(\"overrideAttr\", childExtOverrideAttr, AttributeAccess.Storage.CONFIGURATION);\n        childExtReg.registerOperationHandler(\"overrideOp\", childExtOverrideOp, new TestDescriptionProvider(\"overrideOp\"));\n    }","id":95219,"modified_method":"@BeforeClass\n    public static void setup() {\n        registration = ManagementResourceRegistration.Factory.create(new SimpleResourceDefinition(PathElement.pathElement(\"root\",\"root\"), new NonResolvingResourceDescriptionResolver()));\n\n        parentWildReg = registration.registerSubModel(new SimpleResourceDefinition(parentWild, new NonResolvingResourceDescriptionResolver()));\n        parentWildReg.registerReadOnlyAttribute(wildAttr, parentWildAttr);\n        parentWildReg.registerOperationHandler(getOpDef(\"wildOp\"), parentWildOp);\n        parentWildReg.registerReadOnlyAttribute(overrideAttr, parentWildOverrideAttr);\n        parentWildReg.registerOperationHandler(getOpDef(\"overrideOp\"), parentWildOverrideOp);\n\n        parentExtReg = registration.registerSubModel(new SimpleResourceDefinition(parentExt, new NonResolvingResourceDescriptionResolver()));\n        parentExtReg.registerReadOnlyAttribute(extAttr, parentExtAttr);\n        parentExtReg.registerOperationHandler(getOpDef(\"extOp\"), parentExtOp);\n        parentExtReg.registerReadOnlyAttribute(overrideAttr, parentExtOverrideAttr);\n        parentExtReg.registerOperationHandler(getOpDef(\"overrideOp\"), parentExtOverrideOp);\n\n        childWildReg = parentWildReg.registerSubModel(new SimpleResourceDefinition(childWild, new NonResolvingResourceDescriptionResolver()));\n        childWildReg.registerReadOnlyAttribute(wildAttr, childWildAttr);\n        childWildReg.registerOperationHandler(getOpDef(\"wildOp\"), childWildOp);\n        childWildReg.registerReadOnlyAttribute(overrideAttr, childWildOverrideAttr);\n        childWildReg.registerOperationHandler(getOpDef(\"overrideOp\"), childWildOverrideOp);\n\n        childWildExtReg = parentWildReg.registerSubModel(new SimpleResourceDefinition(childWildExt, new NonResolvingResourceDescriptionResolver()));\n        childWildExtReg.registerReadOnlyAttribute(wildExtAttr, childWildExtAttr);\n        childWildExtReg.registerOperationHandler(getOpDef(\"wildExtOp\"), childWildExtOp);\n\n        childExtReg = parentExtReg.registerSubModel(new SimpleResourceDefinition(childExt, new NonResolvingResourceDescriptionResolver()));\n        childExtReg.registerReadOnlyAttribute(extAttr, childExtAttr);\n        childExtReg.registerOperationHandler(getOpDef(\"extOp\"), childExtOp);\n        childExtReg.registerReadOnlyAttribute(overrideAttr, childExtOverrideAttr);\n        childExtReg.registerOperationHandler(getOpDef(\"overrideOp\"), childExtOverrideOp);\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDuplicateSubModel() {\n        try {\n            parentExtReg.registerSubModel(childWildExt, new TestDescriptionProvider(\"blah\"));\n            fail(\"Duplicate child not rejected\");\n        } catch (Exception good) {}\n\n        try {\n            parentExtReg.registerSubModel(childWild, new TestDescriptionProvider(\"blah\"));\n            fail(\"Duplicate child not rejected\");\n        } catch (Exception good) {}\n\n        try {\n            parentWildReg.registerSubModel(childWild, new TestDescriptionProvider(\"blah\"));\n            fail(\"Duplicate child not rejected\");\n        } catch (Exception good) {}\n\n    }","id":95220,"modified_method":"@Test\n    public void testDuplicateSubModel() {\n        try {\n            parentExtReg.registerSubModel(new SimpleResourceDefinition(childWildExt, new NonResolvingResourceDescriptionResolver()));\n            fail(\"Duplicate child not rejected\");\n        } catch (Exception good) {\n            //\n        }\n\n        try {\n            parentExtReg.registerSubModel(new SimpleResourceDefinition( childWild, new NonResolvingResourceDescriptionResolver()));\n            fail(\"Duplicate child not rejected\");\n        } catch (Exception good) {\n            //\n        }\n\n        try {\n            parentWildReg.registerSubModel(new SimpleResourceDefinition(childWild, new NonResolvingResourceDescriptionResolver()));\n            fail(\"Duplicate child not rejected\");\n        } catch (Exception good) {\n            //\n        }\n\n    }","commit_id":"c1ba7631abf5ad85de8ac3b7f87923703f4a4a2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void replaceConceptPropertyUsages(SNode conceptProperty, SNode overridenMethod) {\n    if (SNodeOperations.getAncestor(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false) == SNodeOperations.getAncestor(conceptProperty, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false)) {\n      return;\n    }\n\n\n    SNode conceptNode = SNodeOperations.getAncestor(conceptProperty, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false);\n    if (SNodeOperations.getAncestor(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.BaseConcept\")) {\n      String name = SPropertyOperations.getString(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"name\");\n      if (eq_azpnkk_a0b0e0j(name, \"alias\")) {\n        SPropertyOperations.set(conceptNode, \"conceptAlias\", SConceptPropertyOperations.getString(conceptNode, \"alias\"));\n        return;\n      } else if (eq_azpnkk_a0a1a4a9(name, \"shortDescription\")) {\n        SPropertyOperations.set(conceptNode, \"conceptShortDescription\", SConceptPropertyOperations.getString(conceptNode, \"shortDescription\"));\n        return;\n      } else if (eq_azpnkk_a0b1a4a9(name, \"abstract\")) {\n        SPropertyOperations.set(conceptNode, \"abstract\", \"\" + (SConceptPropertyOperations.getBoolean(conceptNode, \"abstract\")));\n        return;\n      } else if (eq_azpnkk_a0c1a4a9(name, \"final\")) {\n        SPropertyOperations.set(conceptNode, \"final\", \"\" + (SConceptPropertyOperations.getBoolean(conceptNode, \"final\")));\n        return;\n      }\n    }\n    if (overridenMethod == null) {\n      return;\n    }\n    SNode method = createMethod(SPropertyOperations.getString(overridenMethod, \"name\"), false, overridenMethod, SNodeOperations.copyNode(SLinkOperations.getTarget(overridenMethod, \"returnType\", true)));\n    SNode returnStatement;\n    if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.IntegerConceptProperty\")) {\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.IntegerConstant\", null);\n      SPropertyOperations.set(result, \"value\", \"\" + (SPropertyOperations.getInteger(SNodeOperations.cast(conceptProperty, \"jetbrains.mps.lang.structure.structure.IntegerConceptProperty\"), \"value\")));\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a2a8a9().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.StringConceptProperty\")) {\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StringLiteral\", null);\n      SPropertyOperations.set(result, \"value\", SPropertyOperations.getString(SNodeOperations.cast(conceptProperty, \"jetbrains.mps.lang.structure.structure.StringConceptProperty\"), \"value\"));\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a2a0i0j().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.BooleanConceptProperty\")) {\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a1i0j().createNode();\n    } else {\n      return;\n    }\n    ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(returnStatement);\n    addMethodToBehavior(conceptNode, method);\n    if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.BooleanConceptProperty\") && !(SPropertyOperations.getBoolean(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"inheritable\"))) {\n      createBooleanMethodForChilds(conceptNode, SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), overridenMethod);\n    }\n  }","id":95221,"modified_method":"private void replaceConceptPropertyUsages(SNode conceptProperty, SNode overridenMethod) {\n    if (SNodeOperations.getAncestor(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false) == SNodeOperations.getAncestor(conceptProperty, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false)) {\n      return;\n    }\n\n\n    SNode conceptNode = SNodeOperations.getAncestor(conceptProperty, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false);\n    if (SNodeOperations.getAncestor(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.BaseConcept\")) {\n      String name = SPropertyOperations.getString(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"name\");\n      if (eq_azpnkk_a0b0e0j(name, aliasName)) {\n        SPropertyOperations.set(conceptNode, \"conceptAlias\", SConceptPropertyOperations.getString(conceptNode, \"alias\"));\n        return;\n      } else if (eq_azpnkk_a0a1a4a9(name, shortDescriptionName)) {\n        SPropertyOperations.set(conceptNode, \"conceptShortDescription\", SConceptPropertyOperations.getString(conceptNode, \"shortDescription\"));\n        return;\n      } else if (eq_azpnkk_a0b1a4a9(name, abstractName)) {\n        SPropertyOperations.set(conceptNode, \"abstract\", \"\" + (SConceptPropertyOperations.getBoolean(conceptNode, \"abstract\")));\n        return;\n      } else if (eq_azpnkk_a0c1a4a9(name, finalName)) {\n        SPropertyOperations.set(conceptNode, \"final\", \"\" + (SConceptPropertyOperations.getBoolean(conceptNode, \"final\")));\n        return;\n      } else if (eq_azpnkk_a0d1a4a9(name, dontSubstituteName)) {\n        SNode reference = SConceptOperations.createNewNode(\"jetbrains.mps.lang.structure.structure.InterfaceConceptReference\", null);\n        SLinkOperations.setTarget(reference, \"intfc\", SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1835621062190663819\"), false);\n        if (SNodeOperations.isInstanceOf(conceptNode, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")) {\n          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(conceptNode, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"), \"implements\", true)).addElement(reference);\n        } else if (SNodeOperations.isInstanceOf(conceptNode, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\")) {\n          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(conceptNode, \"jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration\"), \"extends\", true)).addElement(reference);\n        }\n        return;\n      }\n    }\n    if (overridenMethod == null) {\n      return;\n    }\n    SNode method = createMethod(SPropertyOperations.getString(overridenMethod, \"name\"), false, overridenMethod, SNodeOperations.copyNode(SLinkOperations.getTarget(overridenMethod, \"returnType\", true)));\n    SNode returnStatement;\n    if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.IntegerConceptProperty\")) {\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.IntegerConstant\", null);\n      SPropertyOperations.set(result, \"value\", \"\" + (SPropertyOperations.getInteger(SNodeOperations.cast(conceptProperty, \"jetbrains.mps.lang.structure.structure.IntegerConceptProperty\"), \"value\")));\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a2a8a9().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.StringConceptProperty\")) {\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StringLiteral\", null);\n      SPropertyOperations.set(result, \"value\", SPropertyOperations.getString(SNodeOperations.cast(conceptProperty, \"jetbrains.mps.lang.structure.structure.StringConceptProperty\"), \"value\"));\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a2a0i0j().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.BooleanConceptProperty\")) {\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a1i0j().createNode();\n    } else {\n      return;\n    }\n    ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(returnStatement);\n    addMethodToBehavior(conceptNode, method);\n    if (SNodeOperations.isInstanceOf(conceptProperty, \"jetbrains.mps.lang.structure.structure.BooleanConceptProperty\") && !(SPropertyOperations.getBoolean(SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), \"inheritable\"))) {\n      createBooleanMethodForChilds(conceptNode, SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false), overridenMethod);\n    }\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_azpnkk_a0a4a31(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":95222,"modified_method":"private static boolean eq_azpnkk_a0a0a4a31(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_azpnkk_a0a1a51(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":95223,"modified_method":"private static boolean eq_azpnkk_a0a0a2a51(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void replaceAccessUsages(SNode accessOperation, SNode method) {\n    SNode source = SNodeOperations.cast(SNodeOperations.getParent(accessOperation), \"jetbrains.mps.baseLanguage.structure.DotExpression\");\n    SNode operand = SLinkOperations.getTarget(source, \"operand\", true);\n    SNode parent = SNodeOperations.getParent(source);\n    String accessName = SPropertyOperations.getString(SLinkOperations.getTarget(accessOperation, \"conceptProperty\", false), \"name\");\n    if (eq_azpnkk_a0e0n(accessName, \"alias\")) {\n      migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a4a31().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a4a31().createNode(operand));\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.DotExpression\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(parent, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operation\", true), \"jetbrains.mps.lang.smodel.structure.ConceptProperty_SetOperation\")) {\n        SNode setOperation = SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(parent, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operation\", true), \"jetbrains.mps.lang.smodel.structure.ConceptProperty_SetOperation\");\n        SNodeOperations.replaceWithAnother(setOperation, SLinkOperations.getTarget(new ConceptPropertiesHelper.QuotationClass_azpnkk_a0b0b0b0e0n().createNode(SLinkOperations.getTarget(setOperation, \"value\", true)), \"operation\", true));\n      }\n    } else if (eq_azpnkk_a0a4a31(accessName, \"shortDescription\")) {\n      migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a0e0n().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a0e0n().createNode(operand));\n    } else if (eq_azpnkk_a0b4a31(accessName, \"final\")) {\n      migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a1e0n().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a1e0n().createNode(operand));\n    } else if (eq_azpnkk_a0c4a31(accessName, \"abstract\")) {\n      migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a2e0n().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a2e0n().createNode(operand));\n    } else {\n      SNode methodCall = SConceptOperations.createNewNode(\"jetbrains.mps.lang.smodel.structure.Node_ConceptMethodCall\", null);\n      SLinkOperations.setTarget(methodCall, \"baseMethodDeclaration\", method, false);\n\n      migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a3a0e0n().createNode(operand, methodCall), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a3a0e0n().createNode(operand, methodCall));\n    }\n\n\n  }","id":95224,"modified_method":"private void replaceAccessUsages(SNode accessOperation, SNode method) {\n    SNode source = SNodeOperations.cast(SNodeOperations.getParent(accessOperation), \"jetbrains.mps.baseLanguage.structure.DotExpression\");\n    SNode operand = SLinkOperations.getTarget(source, \"operand\", true);\n    SNode parent = SNodeOperations.getParent(source);\n    String accessName = SPropertyOperations.getString(SLinkOperations.getTarget(accessOperation, \"conceptProperty\", false), \"name\");\n    if (SNodeOperations.getAncestor(SLinkOperations.getTarget(accessOperation, \"conceptProperty\", false), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.BaseConcept\")) {\n      if (eq_azpnkk_a0a0e0n(accessName, aliasName)) {\n        migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a0a4a31().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a0a4a31().createNode(operand));\n        if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.DotExpression\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(parent, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operation\", true), \"jetbrains.mps.lang.smodel.structure.ConceptProperty_SetOperation\")) {\n          SNode setOperation = SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(parent, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operation\", true), \"jetbrains.mps.lang.smodel.structure.ConceptProperty_SetOperation\");\n          SNodeOperations.replaceWithAnother(setOperation, SLinkOperations.getTarget(new ConceptPropertiesHelper.QuotationClass_azpnkk_a0b0b0b0a0e0n().createNode(SLinkOperations.getTarget(setOperation, \"value\", true)), \"operation\", true));\n        }\n        return;\n      } else if (eq_azpnkk_a0a0a4a31(accessName, shortDescriptionName)) {\n        migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a0a0e0n().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a0a0e0n().createNode(operand));\n        return;\n      } else if (eq_azpnkk_a0b0a4a31(accessName, finalName)) {\n        migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a1a0e0n().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a1a0e0n().createNode(operand));\n        return;\n      } else if (eq_azpnkk_a0c0a4a31(accessName, abstractName)) {\n        migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a2a0e0n().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a2a0e0n().createNode(operand));\n        return;\n      } else if (eq_azpnkk_a0d0a4a31(accessName, dontSubstituteName)) {\n        migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a0a3a0e0n().createNode(operand), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a0a3a0e0n().createNode(operand));\n        return;\n      }\n    }\n    SNode methodCall = SConceptOperations.createNewNode(\"jetbrains.mps.lang.smodel.structure.Node_ConceptMethodCall\", null);\n    SLinkOperations.setTarget(methodCall, \"baseMethodDeclaration\", method, false);\n    migrateAccess(source, new ConceptPropertiesHelper.QuotationClass_azpnkk_a1a7a31().createNode(operand, methodCall), new ConceptPropertiesHelper.QuotationClass_azpnkk_a2a7a31().createNode(operand, methodCall));\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_azpnkk_a0e0n(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":95225,"modified_method":"private static boolean eq_azpnkk_a0a0e0n(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void replaceCellUsages(SNode cell, SNode method) {\n    SNode modelComponent;\n    if (eq_azpnkk_a0b0p(SPropertyOperations.getString(SLinkOperations.getTarget(cell, \"relationDeclaration\", false), \"name\"), \"alias\")) {\n      modelComponent = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a1a51().createNode(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590284(jetbrains.mps.lang.core.editor)\", \"2900100530630621651\"));\n    } else if (eq_azpnkk_a0a1a51(SPropertyOperations.getString(SLinkOperations.getTarget(cell, \"relationDeclaration\", false), \"name\"), \"shortDescription\")) {\n      modelComponent = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a0b0p().createNode(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590284(jetbrains.mps.lang.core.editor)\", \"6639471181490591356\"));\n    } else {\n      SNode methodCall = SConceptOperations.createNewNode(\"jetbrains.mps.lang.smodel.structure.Node_ConceptMethodCall\", null);\n      SLinkOperations.setTarget(methodCall, \"baseMethodDeclaration\", method, false);\n\n      SNode cellModel_ReadOnlyModelAccessor = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a3a0b0p().createNode();\n      SNode conceptFunctionParameter_node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.ConceptFunctionParameter_node\", null);\n      SNode returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a5a0b0p().createNode(methodCall, conceptFunctionParameter_node);\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(cellModel_ReadOnlyModelAccessor, \"modelAccessor\", true), \"getter\", true), \"body\", true), \"statement\", true)).addElement(returnStatement);\n      modelComponent = cellModel_ReadOnlyModelAccessor;\n    }\n    SLinkOperations.setTarget(modelComponent, \"renderingCondition\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"renderingCondition\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"menuDescriptor\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"menuDescriptor\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"cellBackgroundFunction\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"cellBackgroundFunction\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"focusPolicyApplicable\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"focusPolicyApplicable\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"actionMap\", SLinkOperations.getTarget(cell, \"actionMap\", false), false);\n    SLinkOperations.setTarget(modelComponent, \"keyMap\", SLinkOperations.getTarget(cell, \"keyMap\", false), false);\n    SLinkOperations.setTarget(modelComponent, \"styleClass\", SLinkOperations.getTarget(cell, \"styleClass\", false), false);\n    {\n      Iterator<SNode> nodeChild_it = ListSequence.fromList(SLinkOperations.getTargets(cell, \"styleItem\", true)).iterator();\n      SNode nodeChild_var;\n      while (nodeChild_it.hasNext()) {\n        nodeChild_var = nodeChild_it.next();\n        ListSequence.fromList(SLinkOperations.getTargets(modelComponent, \"styleItem\", true)).addElement(SNodeOperations.copyNode(nodeChild_var));\n      }\n    }\n    SPropertyOperations.set(modelComponent, \"attractsFocus\", \"\" + (SPropertyOperations.getInteger_def(cell, \"attractsFocus\", \"0\")));\n    SNodeOperations.replaceWithAnother(cell, modelComponent);\n  }","id":95226,"modified_method":"private void replaceCellUsages(SNode cell, SNode method) {\n    SNode modelComponent = null;\n    SNode conceptNode = SNodeOperations.getAncestor(SLinkOperations.getTarget(cell, \"relationDeclaration\", false), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false);\n    if (conceptNode == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.BaseConcept\")) {\n      if (eq_azpnkk_a0a0c0p(SPropertyOperations.getString(SLinkOperations.getTarget(cell, \"relationDeclaration\", false), \"name\"), aliasName)) {\n        modelComponent = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a0a2a51().createNode(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590284(jetbrains.mps.lang.core.editor)\", \"2900100530630621651\"));\n      } else if (eq_azpnkk_a0a0a2a51(SPropertyOperations.getString(SLinkOperations.getTarget(cell, \"relationDeclaration\", false), \"name\"), shortDescriptionName)) {\n        modelComponent = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a0a0c0p().createNode(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590284(jetbrains.mps.lang.core.editor)\", \"6639471181490591356\"));\n      }\n    }\n    if (modelComponent == null) {\n      SNode methodCall = SConceptOperations.createNewNode(\"jetbrains.mps.lang.smodel.structure.Node_ConceptMethodCall\", null);\n      SLinkOperations.setTarget(methodCall, \"baseMethodDeclaration\", method, false);\n\n      SNode cellModel_ReadOnlyModelAccessor = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a3a3a51().createNode();\n      SNode conceptFunctionParameter_node = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.ConceptFunctionParameter_node\", null);\n      SNode returnStatement;\n      if (conceptNode == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.BaseConcept\") && eq_azpnkk_a0a6a3a51(SPropertyOperations.getString(SLinkOperations.getTarget(cell, \"relationDeclaration\", false), \"name\"), dontSubstituteName)) {\n        returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a6a3a51().createNode(conceptFunctionParameter_node);\n      } else {\n        returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a0g0d0p().createNode(methodCall, conceptFunctionParameter_node);\n      }\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(cellModel_ReadOnlyModelAccessor, \"modelAccessor\", true), \"getter\", true), \"body\", true), \"statement\", true)).addElement(returnStatement);\n      modelComponent = cellModel_ReadOnlyModelAccessor;\n\n    }\n    SLinkOperations.setTarget(modelComponent, \"renderingCondition\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"renderingCondition\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"menuDescriptor\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"menuDescriptor\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"cellBackgroundFunction\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"cellBackgroundFunction\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"focusPolicyApplicable\", SNodeOperations.copyNode(SLinkOperations.getTarget(cell, \"focusPolicyApplicable\", true)), true);\n    SLinkOperations.setTarget(modelComponent, \"actionMap\", SLinkOperations.getTarget(cell, \"actionMap\", false), false);\n    SLinkOperations.setTarget(modelComponent, \"keyMap\", SLinkOperations.getTarget(cell, \"keyMap\", false), false);\n    SLinkOperations.setTarget(modelComponent, \"styleClass\", SLinkOperations.getTarget(cell, \"styleClass\", false), false);\n    {\n      Iterator<SNode> nodeChild_it = ListSequence.fromList(SLinkOperations.getTargets(cell, \"styleItem\", true)).iterator();\n      SNode nodeChild_var;\n      while (nodeChild_it.hasNext()) {\n        nodeChild_var = nodeChild_it.next();\n        ListSequence.fromList(SLinkOperations.getTargets(modelComponent, \"styleItem\", true)).addElement(SNodeOperations.copyNode(nodeChild_var));\n      }\n    }\n    SPropertyOperations.set(modelComponent, \"attractsFocus\", \"\" + (SPropertyOperations.getInteger_def(cell, \"attractsFocus\", \"0\")));\n    SNodeOperations.replaceWithAnother(cell, modelComponent);\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SNode replaceConceptPropertyDeclarations(SNode conceptPropertyDeclaration, Set<SNode> conceptProperties) {\n    SNode conceptNode = SNodeOperations.getAncestor(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false);\n    if (SConceptOperations.isExactly(((SNode) conceptNode), \"jetbrains.mps.lang.core.structure.BaseConcept\") && (SPropertyOperations.getString(conceptPropertyDeclaration, \"name\").equals(\"abstract\") || SPropertyOperations.getString(conceptPropertyDeclaration, \"name\").equals(\"final\") || SPropertyOperations.getString(conceptPropertyDeclaration, \"name\").equals(\"shortDescription\") || SPropertyOperations.getString(conceptPropertyDeclaration, \"name\").equals(\"alias\"))) {\n      return null;\n    }\n    boolean valueIsDefault = true;\n    SNode sameConceptProperty = null;\n    for (SNode conceptProperty : ListSequence.fromList(SLinkOperations.getTargets(conceptNode, \"conceptProperty\", true))) {\n      if (SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false) == conceptPropertyDeclaration) {\n        valueIsDefault = false;\n        sameConceptProperty = conceptProperty;\n        break;\n      }\n    }\n\n    String name;\n    SNode returnType;\n    SNode returnStatement;\n    if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.IntegerConceptPropertyDeclaration\")) {\n      returnType = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a9a8().createNode();\n      name = \"get\" + NameUtil.capitalize(SPropertyOperations.getString(conceptPropertyDeclaration, \"name\"));\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.IntegerConstant\", null);\n      if (!(valueIsDefault)) {\n        SPropertyOperations.set(result, \"value\", \"\" + (SPropertyOperations.getInteger(SNodeOperations.cast(sameConceptProperty, \"jetbrains.mps.lang.structure.structure.IntegerConceptProperty\"), \"value\")));\n      } else {\n        SPropertyOperations.set(result, \"value\", \"\" + (0));\n      }\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a4a9a8().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.StringConceptPropertyDeclaration\")) {\n      returnType = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a0j0i().createNode();\n      name = \"get\" + NameUtil.capitalize(SPropertyOperations.getString(conceptPropertyDeclaration, \"name\"));\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StringLiteral\", null);\n      if (!(valueIsDefault)) {\n        SPropertyOperations.set(result, \"value\", SPropertyOperations.getString(SNodeOperations.cast(sameConceptProperty, \"jetbrains.mps.lang.structure.structure.StringConceptProperty\"), \"value\"));\n      } else {\n        SPropertyOperations.set(result, \"value\", null);\n      }\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a4a0j0i().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.BooleanConceptPropertyDeclaration\")) {\n      returnType = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a1j0i().createNode();\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null);\n      SPropertyOperations.set(result, \"value\", \"\" + (!(valueIsDefault)));\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a3a1j0i().createNode(result);\n      name = \"get\" + NameUtil.capitalize(SPropertyOperations.getString(conceptPropertyDeclaration, \"name\"));\n    } else {\n      return null;\n    }\n    SNode method = createMethod(name, true, null, returnType);\n    ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(returnStatement);\n    if (!(valueIsDefault)) {\n      SetSequence.fromSet(conceptProperties).removeElement(sameConceptProperty);\n    }\n\n    if (!(addMethodToBehavior(conceptNode, method))) {\n      return null;\n    }\n    if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.BooleanConceptPropertyDeclaration\") && !(SPropertyOperations.getBoolean(conceptPropertyDeclaration, \"inheritable\")) && !(valueIsDefault)) {\n      createBooleanMethodForChilds(conceptNode, conceptPropertyDeclaration, method);\n    }\n\n    return method;\n  }","id":95227,"modified_method":"private SNode replaceConceptPropertyDeclarations(SNode conceptPropertyDeclaration, Set<SNode> conceptProperties) {\n    SNode conceptNode = SNodeOperations.getAncestor(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false);\n    String conceptName = SPropertyOperations.getString(conceptPropertyDeclaration, \"name\");\n    if (SConceptOperations.isExactly(((SNode) conceptNode), \"jetbrains.mps.lang.core.structure.BaseConcept\") && (eq_azpnkk_a0a0a0a0c0i_0(conceptName, abstractName) || eq_azpnkk_a0a0a0a0c0i(conceptName, finalName) || eq_azpnkk_a0a0a0a2a8(conceptName, shortDescriptionName) || eq_azpnkk_a0a0a0c0i(conceptName, aliasName) || eq_azpnkk_a0a0a2a8(conceptName, dontSubstituteName))) {\n      return null;\n    }\n    boolean valueIsDefault = true;\n    SNode sameConceptProperty = null;\n    for (SNode conceptProperty : ListSequence.fromList(SLinkOperations.getTargets(conceptNode, \"conceptProperty\", true))) {\n      if (SLinkOperations.getTarget(conceptProperty, \"conceptPropertyDeclaration\", false) == conceptPropertyDeclaration) {\n        valueIsDefault = false;\n        sameConceptProperty = conceptProperty;\n        break;\n      }\n    }\n\n    String name;\n    SNode returnType;\n    SNode returnStatement;\n    if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.IntegerConceptPropertyDeclaration\")) {\n      returnType = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a01a8().createNode();\n      name = \"get\" + NameUtil.capitalize(conceptName);\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.IntegerConstant\", null);\n      if (!(valueIsDefault)) {\n        SPropertyOperations.set(result, \"value\", \"\" + (SPropertyOperations.getInteger(SNodeOperations.cast(sameConceptProperty, \"jetbrains.mps.lang.structure.structure.IntegerConceptProperty\"), \"value\")));\n      } else {\n        SPropertyOperations.set(result, \"value\", \"\" + (0));\n      }\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a4a01a8().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.StringConceptPropertyDeclaration\")) {\n      returnType = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a0k0i().createNode();\n      name = \"get\" + NameUtil.capitalize(conceptName);\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StringLiteral\", null);\n      if (!(valueIsDefault)) {\n        SPropertyOperations.set(result, \"value\", SPropertyOperations.getString(SNodeOperations.cast(sameConceptProperty, \"jetbrains.mps.lang.structure.structure.StringConceptProperty\"), \"value\"));\n      } else {\n        SPropertyOperations.set(result, \"value\", null);\n      }\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a4a0k0i().createNode(result);\n    } else if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.BooleanConceptPropertyDeclaration\")) {\n      returnType = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a0a1k0i().createNode();\n      SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null);\n      SPropertyOperations.set(result, \"value\", \"\" + (!(valueIsDefault)));\n      returnStatement = new ConceptPropertiesHelper.QuotationClass_azpnkk_a0a3a1k0i().createNode(result);\n      name = NameUtil.capitalize(conceptName);\n    } else {\n      return null;\n    }\n    SNode method = createMethod(name, true, null, returnType);\n    ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(returnStatement);\n    if (!(valueIsDefault)) {\n      SetSequence.fromSet(conceptProperties).removeElement(sameConceptProperty);\n    }\n\n    if (!(addMethodToBehavior(conceptNode, method))) {\n      return null;\n    }\n    if (SNodeOperations.isInstanceOf(conceptPropertyDeclaration, \"jetbrains.mps.lang.structure.structure.BooleanConceptPropertyDeclaration\") && !(SPropertyOperations.getBoolean(conceptPropertyDeclaration, \"inheritable\")) && !(valueIsDefault)) {\n      createBooleanMethodForChilds(conceptNode, conceptPropertyDeclaration, method);\n    }\n\n    return method;\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_azpnkk_a0c4a31(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":95228,"modified_method":"private static boolean eq_azpnkk_a0c0a4a31(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_azpnkk_a0b4a31(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":95229,"modified_method":"private static boolean eq_azpnkk_a0b0a4a31(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_azpnkk_a0b0p(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":95230,"modified_method":"private static boolean eq_azpnkk_a0a0c0p(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void removeConceptProperties() {\n    assert step == 2 : \"can't remove concept properties before migrating them to properties\";\n    final Set<SNode> conceptProperties = SetSequence.fromSet(new HashSet<SNode>());\n    final Set<SNode> conceptPropertyDeclarations = SetSequence.fromSet(new HashSet<SNode>());\n    final Set<SNode> searchedNodes = getSearchedConceptProperties();\n\n    Set<SReference> usages = FindUsagesManager.getInstance().findUsages(((Set<SNode>) searchedNodes), SearchType.USAGES, scope, new EmptyProgressMonitor());\n    final Set<SearchResult<SNode>> allUsages = SetSequence.fromSet(new HashSet<SearchResult<SNode>>());\n    for (SReference usage : SetSequence.fromSet(usages)) {\n      SNode source = usage.getSourceNode();\n      if (SNodeOperations.isInstanceOf(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\")) {\n        SetSequence.fromSet(conceptProperties).addElement(SNodeOperations.cast(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\"));\n        SetSequence.fromSet(conceptPropertyDeclarations).addElement(SLinkOperations.getTarget(SNodeOperations.cast(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\"), \"conceptPropertyDeclaration\", false));\n        SetSequence.fromSet(allUsages).addElement(new SearchResult<SNode>(source, \"\"));\n        SetSequence.fromSet(allUsages).addElement(new SearchResult<SNode>(SLinkOperations.getTarget(SNodeOperations.cast(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\"), \"conceptPropertyDeclaration\", false), \"\"));\n      }\n    }\n\n    final SearchResults searchResults = new SearchResults<SNode>(((Set<SNode>) searchedNodes), SetSequence.fromSet(allUsages).toListSequence());\n    showRefactoringView(new _FunctionTypes._void_P0_E0() {\n      public void invoke() {\n        for (SNode conceptProperty : SetSequence.fromSet(conceptProperties)) {\n          SNodeOperations.deleteNode(conceptProperty);\n        }\n      }\n    }, searchResults);\n  }","id":95231,"modified_method":"public void removeConceptProperties() {\n    final Set<SNode> conceptProperties = SetSequence.fromSet(new HashSet<SNode>());\n    final Set<SNode> conceptPropertyDeclarations = SetSequence.fromSet(new HashSet<SNode>());\n    final Set<SNode> searchedNodes = getSearchedConceptProperties();\n\n    Set<SReference> usages = FindUsagesManager.getInstance().findUsages(((Set<SNode>) searchedNodes), SearchType.USAGES, scope, new EmptyProgressMonitor());\n    final Set<SearchResult<SNode>> allUsages = SetSequence.fromSet(new HashSet<SearchResult<SNode>>());\n    for (SReference usage : SetSequence.fromSet(usages)) {\n      SNode source = usage.getSourceNode();\n      if (SNodeOperations.isInstanceOf(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\")) {\n        SetSequence.fromSet(conceptProperties).addElement(SNodeOperations.cast(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\"));\n        SetSequence.fromSet(conceptPropertyDeclarations).addElement(SLinkOperations.getTarget(SNodeOperations.cast(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\"), \"conceptPropertyDeclaration\", false));\n        SetSequence.fromSet(allUsages).addElement(new SearchResult<SNode>(source, \"\"));\n        SetSequence.fromSet(allUsages).addElement(new SearchResult<SNode>(SLinkOperations.getTarget(SNodeOperations.cast(source, \"jetbrains.mps.lang.structure.structure.ConceptProperty\"), \"conceptPropertyDeclaration\", false), \"\"));\n      }\n    }\n\n    final SearchResults searchResults = new SearchResults<SNode>(((Set<SNode>) searchedNodes), SetSequence.fromSet(allUsages).toListSequence());\n    showRefactoringView(new _FunctionTypes._void_P0_E0() {\n      public void invoke() {\n        for (SNode conceptProperty : SetSequence.fromSet(conceptProperties)) {\n          SNodeOperations.deleteNode(conceptProperty);\n        }\n      }\n    }, searchResults);\n  }","commit_id":"1c6603e18c6252b018d9f97006b5ef39a584fff1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  Object getUniqueId(){\n    if(myElement instanceof PsiClass){\n      return ((PsiClass)myElement).getQualifiedName();\n    }\n    if(myElement instanceof PsiPackage){\n      return ((PsiPackage)myElement).getQualifiedName();\n    }\n    if(myElement instanceof PsiMethod){\n      return ((PsiMethod)myElement).getSignature(mySubstitutor);\n    }\n    if (myElement instanceof PsiVariable) {\n      return getVariableUniqueId((PsiVariable)myElement);\n    }\n\n    return null;\n  }","id":95232,"modified_method":"@Nullable\n  private Object getUniqueId(){\n    if(myElement instanceof PsiClass){\n      String qName = ((PsiClass)myElement).getQualifiedName();\n      return qName == null ? ((PsiClass)myElement).getName() : qName;\n    }\n    if(myElement instanceof PsiPackage){\n      return ((PsiPackage)myElement).getQualifiedName();\n    }\n    if(myElement instanceof PsiMethod){\n      return ((PsiMethod)myElement).getSignature(mySubstitutor);\n    }\n    if (myElement instanceof PsiVariable) {\n      return \"#\" + ((PsiVariable)myElement).getName();\n    }\n\n    return null;\n  }","commit_id":"ba4cd7405604cf61d4b6346f3801a9d9f682ccbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CompletionElement(Object element, PsiSubstitutor substitutor) {\n    myElement = element;\n    mySubstitutor = substitutor;\n  }","id":95233,"modified_method":"public CompletionElement(Object element, PsiSubstitutor substitutor) {\n    myElement = element;\n    mySubstitutor = substitutor;\n    myEqualityObject = getUniqueId();\n  }","commit_id":"ba4cd7405604cf61d4b6346f3801a9d9f682ccbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Iterable<CompletionElement> getResults() {\n    if (myResults.isEmpty()) {\n      return myFilteredResults;\n    }\n    return myResults;\n  }","id":95234,"modified_method":"public Iterable<CompletionElement> getResults() {\n    if (mySecondRateResults.size() == myResults.size()) {\n      return mySecondRateResults;\n    }\n    return ContainerUtil.filter(myResults.values(), new Condition<CompletionElement>() {\n      @Override\n      public boolean value(CompletionElement element) {\n        return !mySecondRateResults.contains(element);\n      }\n    });\n  }","commit_id":"ba4cd7405604cf61d4b6346f3801a9d9f682ccbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean execute(@NotNull PsiElement element, @NotNull ResolveState state) {\n    //noinspection SuspiciousMethodCalls\n    if (myNonInitializedFields.contains(element)) {\n      return true;\n    }\n\n    if (element instanceof PsiPackage && !isQualifiedContext()) {\n      if (myScope instanceof PsiClass) {\n        return true;\n      }\n      if (((PsiPackage)element).getQualifiedName().contains(\".\") &&\n          PsiTreeUtil.getParentOfType(myElement, PsiImportStatementBase.class) != null) {\n        return true;\n      }\n    }\n\n    if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      if (PsiTypesUtil.isGetClass(method) && PsiUtil.isLanguageLevel5OrHigher(myElement)) {\n        PsiType patchedType = PsiTypesUtil.createJavaLangClassType(myElement, myQualifierType, false);\n        if (patchedType != null) {\n          element = new LightMethodBuilder(element.getManager(), method.getName()).\n            addModifier(PsiModifier.PUBLIC).\n            setMethodReturnType(patchedType).\n            setContainingClass(method.getContainingClass());\n        }\n      }\n    }\n\n    if (satisfies(element, state) && isAccessible(element)) {\n      CompletionElement element1 = new CompletionElement(element, state.get(PsiSubstitutor.KEY));\n      if (myResultNames.add(element1.getUniqueId())) {\n        StaticProblem sp = myElement.getParent() instanceof PsiMethodReferenceExpression ? StaticProblem.none : getStaticProblem(element);\n        if (sp != StaticProblem.instanceAfterStatic) {\n          (sp == StaticProblem.staticAfterInstance ? myFilteredResults : myResults).add(element1);\n        }\n      }\n    } else if (element instanceof PsiLocalVariable || element instanceof PsiParameter) {\n      myResultNames.add(CompletionElement.getVariableUniqueId((PsiVariable)element));\n    }\n\n    return true;\n  }","id":95235,"modified_method":"@Override\n  public boolean execute(@NotNull PsiElement element, @NotNull ResolveState state) {\n    //noinspection SuspiciousMethodCalls\n    if (myNonInitializedFields.contains(element)) {\n      return true;\n    }\n\n    if (element instanceof PsiPackage && !isQualifiedContext()) {\n      if (myScope instanceof PsiClass) {\n        return true;\n      }\n      if (((PsiPackage)element).getQualifiedName().contains(\".\") &&\n          PsiTreeUtil.getParentOfType(myElement, PsiImportStatementBase.class) != null) {\n        return true;\n      }\n    }\n\n    if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      if (PsiTypesUtil.isGetClass(method) && PsiUtil.isLanguageLevel5OrHigher(myElement)) {\n        PsiType patchedType = PsiTypesUtil.createJavaLangClassType(myElement, myQualifierType, false);\n        if (patchedType != null) {\n          element = new LightMethodBuilder(element.getManager(), method.getName()).\n            addModifier(PsiModifier.PUBLIC).\n            setMethodReturnType(patchedType).\n            setContainingClass(method.getContainingClass());\n        }\n      }\n    }\n\n    if (element instanceof PsiVariable) {\n      String name = ((PsiVariable)element).getName();\n      if (myShadowedNames.contains(name)) return true;\n      if (element instanceof PsiLocalVariable || element instanceof PsiParameter) {\n        myShadowedNames.add(name);\n      }\n    }\n\n    if (!satisfies(element, state) || !isAccessible(element)) return true;\n\n    StaticProblem sp = myElement.getParent() instanceof PsiMethodReferenceExpression ? StaticProblem.none : getStaticProblem(element);\n    if (sp == StaticProblem.instanceAfterStatic) return true;\n\n    CompletionElement completion = new CompletionElement(element,  state.get(PsiSubstitutor.KEY));\n    CompletionElement prev = myResults.get(completion);\n    if (prev == null || completion.isMoreSpecificThan(prev)) {\n      myResults.put(completion, completion);\n      if (sp == StaticProblem.staticAfterInstance) {\n        mySecondRateResults.add(completion);\n      }\n    }\n\n    return true;\n  }","commit_id":"ba4cd7405604cf61d4b6346f3801a9d9f682ccbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setCompletionElements(@NotNull Object[] elements) {\n    for (Object element: elements) {\n      myResults.add(new CompletionElement(element, PsiSubstitutor.EMPTY));\n    }\n  }","id":95236,"modified_method":"public void setCompletionElements(@NotNull Object[] elements) {\n    for (Object element: elements) {\n      CompletionElement completion = new CompletionElement(element, PsiSubstitutor.EMPTY);\n      myResults.put(completion, completion);\n    }\n  }","commit_id":"ba4cd7405604cf61d4b6346f3801a9d9f682ccbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void clear() {\n    myResults.clear();\n    myFilteredResults.clear();\n  }","id":95237,"modified_method":"public void clear() {\n    myResults.clear();\n    mySecondRateResults.clear();\n  }","commit_id":"ba4cd7405604cf61d4b6346f3801a9d9f682ccbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType getType() {\n    return null;\n  }","id":95238,"modified_method":"public PsiType getType() {\n    return getManager().getElementFactory().createTypeByFQClassName(\"groovy.lang.Closure\", getResolveScope());\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    ResolverProcessor processor = getResolveProcessor(this, null);\n    GrExpression qualifierExpression = getQualifierExpression();\n    if (qualifierExpression == null) {\n      ResolveUtil.treeWalkUp(this, processor);\n    } else {\n      PsiType qualifierType = qualifierExpression.getType();\n      if (qualifierType instanceof PsiClassType) {\n        PsiClass qualifierClass = ((PsiClassType) qualifierType).resolve();\n        if (qualifierClass != null) {\n          qualifierClass.processDeclarations(processor, PsiSubstitutor.EMPTY, null, this);\n        }\n      }\n    }\n\n    GroovyResolveResult[] candidates = processor.getCandidates();\n    if (candidates.length == 0) return PsiNamedElement.EMPTY_ARRAY;\n    return ResolveUtil.mapToElements(candidates);\n  }","id":95239,"modified_method":"public Object[] getVariants() {\n    ResolverProcessor processor = getResolveProcessor(this, null, true);\n    GrExpression qualifierExpression = getQualifierExpression();\n    if (qualifierExpression == null) {\n      ResolveUtil.treeWalkUp(this, processor);\n    } else {\n      PsiType qualifierType = qualifierExpression.getType();\n      if (qualifierType instanceof PsiClassType) {\n        PsiClass qualifierClass = ((PsiClassType) qualifierType).resolve();\n        if (qualifierClass != null) {\n          qualifierClass.processDeclarations(processor, PsiSubstitutor.EMPTY, null, this);\n        }\n      }\n    }\n\n    GroovyResolveResult[] candidates = processor.getCandidates();\n    if (candidates.length == 0) return PsiNamedElement.EMPTY_ARRAY;\n    return ResolveUtil.mapToElements(candidates);\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyResolveResult[] resolve(GrReferenceExpressionImpl refExpr, boolean incompleteCode) {\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      String name = refExpr.getReferenceName();\n      if (name == null) return null;\n      ResolverProcessor processor = getResolveProcessor(refExpr, name);\n\n      if (qualifier == null) {\n        ResolveUtil.treeWalkUp(refExpr, processor);\n      } else {\n        PsiType qualifierType = qualifier.getType();\n        if (qualifierType instanceof PsiClassType) {\n          PsiClass qualifierClass = ((PsiClassType) qualifierType).resolve();\n          if (qualifierClass != null) {\n            qualifierClass.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr);\n          }\n        }\n      }\n\n      return processor.getCandidates();\n    }","id":95240,"modified_method":"public GroovyResolveResult[] resolve(GrReferenceExpressionImpl refExpr, boolean incompleteCode) {\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      String name = refExpr.getReferenceName();\n      if (name == null) return null;\n      ResolverProcessor processor = getResolveProcessor(refExpr, name, false);\n\n      if (qualifier == null) {\n        ResolveUtil.treeWalkUp(refExpr, processor);\n      } else {\n        PsiType qualifierType = qualifier.getType();\n        if (qualifierType instanceof PsiClassType) {\n          PsiClass qualifierClass = ((PsiClassType) qualifierType).resolve();\n          if (qualifierClass != null) {\n            qualifierClass.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr);\n          }\n        }\n      }\n\n      return processor.getCandidates();\n    }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ResolverProcessor getResolveProcessor(GrReferenceExpressionImpl refExpr, String name) {\n    Kind kind = refExpr.getKind();\n    ResolverProcessor processor;\n    if (kind == Kind.TYPE_OR_PROPERTY) {\n      processor = new ResolverProcessor(name, EnumSet.of(ResolveKind.PROPERTY, ResolveKind.METHOD, ResolveKind.CLASS), refExpr); //todo package?\n    } else if (kind == Kind.METHOD_OR_PROPERTY) {\n      processor = new MethodResolverProcessor(name, refExpr);\n    } else {\n      processor = new ResolverProcessor(name, EnumSet.of(ResolveKind.METHOD, ResolveKind.PROPERTY), refExpr);\n    }\n\n    return processor;\n  }","id":95241,"modified_method":"private static ResolverProcessor getResolveProcessor(GrReferenceExpressionImpl refExpr, String name, boolean forCompletion) {\n    Kind kind = refExpr.getKind();\n    ResolverProcessor processor;\n    if (kind == Kind.TYPE_OR_PROPERTY) {\n      processor = new ResolverProcessor(name, EnumSet.of(ResolveKind.PROPERTY, ResolveKind.METHOD, ResolveKind.CLASS), refExpr, forCompletion); //todo package?\n    } else if (kind == Kind.METHOD_OR_PROPERTY) {\n      processor = new MethodResolverProcessor(name, refExpr, forCompletion);\n    } else {\n      processor = new ResolverProcessor(name, EnumSet.of(ResolveKind.METHOD, ResolveKind.PROPERTY), refExpr, forCompletion);\n    }\n\n    return processor;\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    PsiManager manager = getManager();\n    final ReferenceKind kind = getKind();\n    switch (kind) {\n      case PACKAGE_FQ:\n      case CLASS_OR_PACKAGE_FQ: {\n        final String refText = PsiUtil.getQualifiedReferenceText(this);\n        final int lastDot = refText.lastIndexOf(\".\");\n        String parentPackageFQName = lastDot > 0 ? refText.substring(0, lastDot) : \"\";\n        final PsiPackage parentPackage = manager.findPackage(parentPackageFQName);\n        if (parentPackage != null) {\n          final GlobalSearchScope scope = getResolveScope();\n          if (kind == PACKAGE_FQ) {\n            return parentPackage.getSubPackages(scope);\n          } else {\n            final PsiPackage[] subpackages = parentPackage.getSubPackages(scope);\n            final PsiClass[] classes = parentPackage.getClasses(scope);\n            PsiElement[] result = new PsiElement[subpackages.length + classes.length];\n            System.arraycopy(subpackages, 0, result, 0, subpackages.length);\n            System.arraycopy(classes, 0, result, subpackages.length, classes.length);\n            return result;\n          }\n        }\n      }\n\n      case CLASS: {\n        GrTypeOrPackageReferenceElement qualifier = getQualifier();\n        if (qualifier != null) {\n          PsiElement qualifierResolved = qualifier.resolve();\n          if (qualifierResolved instanceof PsiPackage) {\n            return ((PsiPackage) qualifierResolved).getClasses();\n          } else if (qualifierResolved instanceof PsiClass) {\n            return ((PsiClass) qualifierResolved).getInnerClasses();\n          }\n        } else {\n          ResolverProcessor processor = new ResolverProcessor(null, EnumSet.of(ClassHint.ResolveKind.CLASS), this);\n          ResolveUtil.treeWalkUp(this, processor);\n          GroovyResolveResult[] candidates = processor.getCandidates();\n          return ResolveUtil.mapToElements(candidates);\n        }\n      }\n    }\n\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","id":95242,"modified_method":"public Object[] getVariants() {\n    PsiManager manager = getManager();\n    final ReferenceKind kind = getKind();\n    switch (kind) {\n      case PACKAGE_FQ:\n      case CLASS_OR_PACKAGE_FQ: {\n        final String refText = PsiUtil.getQualifiedReferenceText(this);\n        final int lastDot = refText.lastIndexOf(\".\");\n        String parentPackageFQName = lastDot > 0 ? refText.substring(0, lastDot) : \"\";\n        final PsiPackage parentPackage = manager.findPackage(parentPackageFQName);\n        if (parentPackage != null) {\n          final GlobalSearchScope scope = getResolveScope();\n          if (kind == PACKAGE_FQ) {\n            return parentPackage.getSubPackages(scope);\n          } else {\n            final PsiPackage[] subpackages = parentPackage.getSubPackages(scope);\n            final PsiClass[] classes = parentPackage.getClasses(scope);\n            PsiElement[] result = new PsiElement[subpackages.length + classes.length];\n            System.arraycopy(subpackages, 0, result, 0, subpackages.length);\n            System.arraycopy(classes, 0, result, subpackages.length, classes.length);\n            return result;\n          }\n        }\n      }\n\n      case CLASS: {\n        GrTypeOrPackageReferenceElement qualifier = getQualifier();\n        if (qualifier != null) {\n          PsiElement qualifierResolved = qualifier.resolve();\n          if (qualifierResolved instanceof PsiPackage) {\n            return ((PsiPackage) qualifierResolved).getClasses();\n          } else if (qualifierResolved instanceof PsiClass) {\n            return ((PsiClass) qualifierResolved).getInnerClasses();\n          }\n        } else {\n          ResolverProcessor processor = new ResolverProcessor(null, EnumSet.of(ClassHint.ResolveKind.CLASS), this, true);\n          ResolveUtil.treeWalkUp(this, processor);\n          GroovyResolveResult[] candidates = processor.getCandidates();\n          return ResolveUtil.mapToElements(candidates);\n        }\n      }\n    }\n\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyResolveResult[] resolve(GrTypeOrPackageReferenceElementImpl groovyRef, boolean incompleteCode) {\n      String refName = groovyRef.getReferenceName();\n      if (refName == null) return null;\n      PsiManager manager = groovyRef.getManager();\n      ReferenceKind kind = groovyRef.getKind();\n      switch (kind) {\n        case CLASS_OR_PACKAGE_FQ: {\n          PsiClass aClass = manager.findClass(PsiUtil.getQualifiedReferenceText(groovyRef), groovyRef.getResolveScope());\n          if (aClass != null) {\n            boolean isAccessible = com.intellij.psi.util.PsiUtil.isAccessible(aClass, groovyRef, null);\n            return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n          }\n          //fallthrough\n        }\n\n        case PACKAGE_FQ:\n          PsiPackage aPackage = manager.findPackage(PsiUtil.getQualifiedReferenceText(groovyRef));\n          return new GroovyResolveResult[]{new GroovyResolveResultImpl(aPackage, true)};\n\n        case CLASS:\n        case CLASS_OR_PACKAGE:\n          GrTypeOrPackageReferenceElement qualifier = groovyRef.getQualifier();\n          if (qualifier != null) {\n            PsiElement qualifierResolved = qualifier.resolve();\n            if (qualifierResolved instanceof PsiPackage) {\n              PsiClass[] classes = ((PsiPackage) qualifierResolved).getClasses();\n              for (final PsiClass aClass : classes) {\n                if (refName.equals(aClass.getName())) {\n                  boolean isAccessible = com.intellij.psi.util.PsiUtil.isAccessible(aClass, groovyRef, null);\n                  return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n                }\n              }\n\n              if (kind == CLASS_OR_PACKAGE) {\n                for (final PsiPackage subpackage : ((PsiPackage) qualifierResolved).getSubPackages()) {\n                  if (refName.equals(subpackage.getName())) return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            }\n          } else {\n            ResolverProcessor processor = new ResolverProcessor(refName, EnumSet.of(ClassHint.ResolveKind.CLASS), groovyRef);\n            ResolveUtil.treeWalkUp(groovyRef, processor);\n            GroovyResolveResult[] candidates = processor.getCandidates();\n            if (candidates.length > 0) return candidates;\n\n            if (kind == CLASS_OR_PACKAGE) {\n              PsiPackage defaultPackage = groovyRef.getManager().findPackage(\"\");\n              if (defaultPackage != null) {\n                for (final PsiPackage subpackage : defaultPackage.getSubPackages()) {\n                  if (refName.equals(subpackage.getName())) return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            }\n          }\n      }\n\n      return null;\n    }","id":95243,"modified_method":"public GroovyResolveResult[] resolve(GrTypeOrPackageReferenceElementImpl groovyRef, boolean incompleteCode) {\n      String refName = groovyRef.getReferenceName();\n      if (refName == null) return null;\n      PsiManager manager = groovyRef.getManager();\n      ReferenceKind kind = groovyRef.getKind();\n      switch (kind) {\n        case CLASS_OR_PACKAGE_FQ: {\n          PsiClass aClass = manager.findClass(PsiUtil.getQualifiedReferenceText(groovyRef), groovyRef.getResolveScope());\n          if (aClass != null) {\n            boolean isAccessible = com.intellij.psi.util.PsiUtil.isAccessible(aClass, groovyRef, null);\n            return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n          }\n          //fallthrough\n        }\n\n        case PACKAGE_FQ:\n          PsiPackage aPackage = manager.findPackage(PsiUtil.getQualifiedReferenceText(groovyRef));\n          return new GroovyResolveResult[]{new GroovyResolveResultImpl(aPackage, true)};\n\n        case CLASS:\n        case CLASS_OR_PACKAGE:\n          GrTypeOrPackageReferenceElement qualifier = groovyRef.getQualifier();\n          if (qualifier != null) {\n            PsiElement qualifierResolved = qualifier.resolve();\n            if (qualifierResolved instanceof PsiPackage) {\n              PsiClass[] classes = ((PsiPackage) qualifierResolved).getClasses();\n              for (final PsiClass aClass : classes) {\n                if (refName.equals(aClass.getName())) {\n                  boolean isAccessible = com.intellij.psi.util.PsiUtil.isAccessible(aClass, groovyRef, null);\n                  return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n                }\n              }\n\n              if (kind == CLASS_OR_PACKAGE) {\n                for (final PsiPackage subpackage : ((PsiPackage) qualifierResolved).getSubPackages()) {\n                  if (refName.equals(subpackage.getName())) return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            }\n          } else {\n            ResolverProcessor processor = new ResolverProcessor(refName, EnumSet.of(ClassHint.ResolveKind.CLASS), groovyRef, false);\n            ResolveUtil.treeWalkUp(groovyRef, processor);\n            GroovyResolveResult[] candidates = processor.getCandidates();\n            if (candidates.length > 0) return candidates;\n\n            if (kind == CLASS_OR_PACKAGE) {\n              PsiPackage defaultPackage = groovyRef.getManager().findPackage(\"\");\n              if (defaultPackage != null) {\n                for (final PsiPackage subpackage : defaultPackage.getSubPackages()) {\n                  if (refName.equals(subpackage.getName())) return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            }\n          }\n      }\n\n      return null;\n    }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodResolverProcessor(String name, GroovyPsiElement place) {\n    super(name, EnumSet.of(ResolveKind.METHOD, ResolveKind.PROPERTY), place);\n    myArgumentTypes = getArgumentTypes(place);\n  }","id":95244,"modified_method":"public MethodResolverProcessor(String name, GroovyPsiElement place, boolean forCompletion) {\n    super(name, EnumSet.of(ResolveKind.METHOD, ResolveKind.PROPERTY), place, forCompletion);\n    myArgumentTypes = getArgumentTypes(place);\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean execute(PsiElement element, PsiSubstitutor substitutor) {\n    if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod) element;\n      if (method.isConstructor()) return true; //not interested in constructors <now>\n\n      boolean isAccessible = isAccessible((PsiNamedElement) element);\n      if (myName == null || isApplicable(method)) {\n        myCandidates.add(new GroovyResolveResultImpl(method, isAccessible));\n      }\n      else {\n        myInapplicableCandidates.add(new GroovyResolveResultImpl(method, isAccessible));\n      }\n\n      return true;\n    } else {\n      return super.execute(element, substitutor);\n    }\n  }","id":95245,"modified_method":"public boolean execute(PsiElement element, PsiSubstitutor substitutor) {\n    if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod) element;\n      if (method.isConstructor()) return true; //not interested in constructors <now>\n\n      if (!isAccessible((PsiNamedElement) element)) return true;\n\n      if (!myForCompletion) {\n        if (ResolveUtil.isSuperMethodDominated(method, myCandidateMethods)) return true;\n      }\n\n      if (myForCompletion || isApplicable(method)) {\n        myCandidates.add(new GroovyResolveResultImpl(method, true));\n      }\n      else {\n        myInapplicableCandidates.add(new GroovyResolveResultImpl(method, true));\n      }\n\n      myCandidateMethods.add(method);\n      return true;\n    } else {\n      return super.execute(element, substitutor);\n    }\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ResolverProcessor(String name, EnumSet<ResolveKind> resolveTargets, GroovyPsiElement place) {\n    myName = name;\n    myResolveTargetKinds = resolveTargets;\n    myPlace = place;\n  }","id":95246,"modified_method":"public ResolverProcessor(String name, EnumSet<ResolveKind> resolveTargets, GroovyPsiElement place, boolean forCompletion) {\n    myName = name;\n    myResolveTargetKinds = resolveTargets;\n    myPlace = place;\n    myForCompletion = forCompletion;\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean execute(PsiElement element, PsiSubstitutor substitutor) {\n    if (myResolveTargetKinds.contains(ResolveUtil.getResolveKind(element))) {\n      PsiNamedElement namedElement = (PsiNamedElement) element;\n      boolean isAccessible = isAccessible(namedElement);\n      myCandidates.add(new GroovyResolveResultImpl(namedElement, isAccessible));\n      return myName == null || !isAccessible;\n    }\n\n    return true;\n  }","id":95247,"modified_method":"public boolean execute(PsiElement element, PsiSubstitutor substitutor) {\n    if (myResolveTargetKinds.contains(ResolveUtil.getResolveKind(element))) {\n      PsiNamedElement namedElement = (PsiNamedElement) element;\n      boolean isAccessible = isAccessible(namedElement);\n      myCandidates.add(new GroovyResolveResultImpl(namedElement, isAccessible));\n      return myForCompletion || !isAccessible;\n    }\n\n    return true;\n  }","commit_id":"eefd7dbb07e2beb23743bb31ce4b81467eb15ad0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Tests if point is inside a polygon. The polygon can be self-intersecting. In such case the contains function works in xor-like manner.\n     * @param polygonNodes list of nodes from polygon path.\n     * @param point the point to test\n     * @return true if the point is inside polygon.\n     */\n    public static boolean nodeInsidePolygon(Node point, List<Node> polygonNodes) {\n        if (polygonNodes.size() < 2)\n            return false;\n\n        boolean inside = false;\n        Node p1, p2;\n\n        //iterate each side of the polygon, start with the last segment\n        Node oldPoint = polygonNodes.get(polygonNodes.size() - 1);\n\n        if (!oldPoint.isLatLonKnown()) {\n            return false;\n        }\n\n        for (Node newPoint : polygonNodes) {\n            //skip duplicate points\n            if (newPoint.equals(oldPoint)) {\n                continue;\n            }\n\n            if (!newPoint.isLatLonKnown()) {\n                return false;\n            }\n\n            //order points so p1.lat <= p2.lat\n            if (newPoint.getEastNorth().getY() > oldPoint.getEastNorth().getY()) {\n                p1 = oldPoint;\n                p2 = newPoint;\n            } else {\n                p1 = newPoint;\n                p2 = oldPoint;\n            }\n\n            //test if the line is crossed and if so invert the inside flag.\n            if ((newPoint.getEastNorth().getY() < point.getEastNorth().getY()) == (point.getEastNorth().getY() <= oldPoint.getEastNorth().getY())\n                    && (point.getEastNorth().getX() - p1.getEastNorth().getX()) * (p2.getEastNorth().getY() - p1.getEastNorth().getY())\n                    < (p2.getEastNorth().getX() - p1.getEastNorth().getX()) * (point.getEastNorth().getY() - p1.getEastNorth().getY())) {\n                inside = !inside;\n            }\n\n            oldPoint = newPoint;\n        }\n\n        return inside;\n    }","id":95248,"modified_method":"/**\n     * Tests if point is inside a polygon. The polygon can be self-intersecting. In such case the contains function works in xor-like manner.\n     * @param polygonNodes list of nodes from polygon path.\n     * @param point the point to test\n     * @return true if the point is inside polygon.\n     */\n    public static boolean nodeInsidePolygon(Node point, List<Node> polygonNodes) {\n        if (polygonNodes.size() < 2)\n            return false;\n\n        boolean inside = false;\n        Node p1, p2;\n\n        //iterate each side of the polygon, start with the last segment\n        Node oldPoint = polygonNodes.get(polygonNodes.size() - 1);\n\n        if (!oldPoint.isLatLonKnown()) {\n            return false;\n        }\n\n        for (Node newPoint : polygonNodes) {\n            //skip duplicate points\n            if (newPoint.equals(oldPoint)) {\n                continue;\n            }\n\n            if (!newPoint.isLatLonKnown()) {\n                return false;\n            }\n\n            //order points so p1.lat <= p2.lat\n            if (newPoint.getEastNorth().getY() > oldPoint.getEastNorth().getY()) {\n                p1 = oldPoint;\n                p2 = newPoint;\n            } else {\n                p1 = newPoint;\n                p2 = oldPoint;\n            }\n\n            EastNorth pEN = point.getEastNorth();\n            EastNorth opEN = oldPoint.getEastNorth();\n            EastNorth npEN = newPoint.getEastNorth();\n            EastNorth p1EN = p1.getEastNorth();\n            EastNorth p2EN = p2.getEastNorth();\n\n            if (pEN != null && opEN != null && npEN != null && p1EN != null && p2EN != null) {\n                //test if the line is crossed and if so invert the inside flag.\n                if ((npEN.getY() < pEN.getY()) == (pEN.getY() <= opEN.getY())\n                        && (pEN.getX() - p1EN.getX()) * (p2EN.getY() - p1EN.getY())\n                        < (p2EN.getX() - p1EN.getX()) * (pEN.getY() - p1EN.getY())) {\n                    inside = !inside;\n                }\n            }\n\n            oldPoint = newPoint;\n        }\n\n        return inside;\n    }","commit_id":"3143687b55c9c9f77d534858682f5003e9ff823c","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n  public Module getDistributedModules() {\n    return Modules.combine(getCommonModules(), new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(WeaveRunnerService.class).to(YarnWeaveRunnerService.class);\n        bind(new TypeLiteral<Iterable<WeaveRunner.LiveInfo>>() {}).toProvider(WeaveLiveInfoProvider.class);\n        bind(DiscoveryNameFinder.class).to(WeaveDiscoveryNameFinder.class);\n        expose(WeaveRunnerService.class);\n        expose(DiscoveryNameFinder.class);\n      }\n\n      @Singleton\n      @Provides\n      private YarnWeaveRunnerService provideYarnWeaveRunnerService(CConfiguration configuration,\n                                                                   YarnConfiguration yarnConfiguration,\n                                                                   LocationFactory locationFactory) {\n        String zkNamespace = configuration.get(Constants.CFG_WEAVE_ZK_NAMESPACE, \"/weave\");\n        return new YarnWeaveRunnerService(\n          yarnConfiguration,\n          configuration.get(Constants.Zookeeper.QUORUM) + zkNamespace,\n          LocationFactories.namespace(locationFactory, \"weave\"));\n      }\n    });\n  }","id":95249,"modified_method":"@Override\n  public Module getDistributedModules() {\n    return Modules.combine(getCommonModules(), new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(WeaveRunnerService.class).to(YarnWeaveRunnerService.class);\n        bind(new TypeLiteral<Iterable<WeaveRunner.LiveInfo>>() {}).toProvider(WeaveLiveInfoProvider.class);\n        expose(WeaveRunnerService.class);\n      }\n\n      @Singleton\n      @Provides\n      private YarnWeaveRunnerService provideYarnWeaveRunnerService(CConfiguration configuration,\n                                                                   YarnConfiguration yarnConfiguration,\n                                                                   LocationFactory locationFactory) {\n        String zkNamespace = configuration.get(Constants.CFG_WEAVE_ZK_NAMESPACE, \"/weave\");\n        return new YarnWeaveRunnerService(\n          yarnConfiguration,\n          configuration.get(Constants.Zookeeper.QUORUM) + zkNamespace,\n          LocationFactories.namespace(locationFactory, \"weave\"));\n      }\n    });\n  }","commit_id":"c27218ed9edbccef1b62911edc0356eb18dece85","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getInMemoryModules() {\n    return Modules.combine(getCommonModules(), new AbstractModule() {\n      @Override\n      protected void configure() {\n        bind(DiscoveryNameFinder.class).to(SinglenodeDiscoveryNameFinder.class);\n      }\n    });\n  }","id":95250,"modified_method":"@Override\n  public Module getInMemoryModules() {\n    return getCommonModules();\n  }","commit_id":"c27218ed9edbccef1b62911edc0356eb18dece85","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getSingleNodeModules() {\n    return Modules.combine(getCommonModules(), new AbstractModule() {\n      @Override\n      protected void configure() {\n        bind(DiscoveryNameFinder.class).to(SinglenodeDiscoveryNameFinder.class);\n      }\n    });\n  }","id":95251,"modified_method":"@Override\n  public Module getSingleNodeModules() {\n    return getCommonModules();\n  }","commit_id":"c27218ed9edbccef1b62911edc0356eb18dece85","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void init(String[] args) {\n    LOG.info(\"Initializing Router...\");\n    try {\n      // Load configuration\n      CConfiguration cConf = CConfiguration.create();\n\n      // Initialize ZK client\n      String zookeeper = cConf.get(Constants.Zookeeper.QUORUM);\n      if (zookeeper == null) {\n        LOG.error(\"No zookeeper quorum provided.\");\n        System.exit(1);\n      }\n\n      Injector injector = createGuiceInjector(cConf);\n      zkClientService = injector.getInstance(ZKClientService.class);\n\n      twillRunnerService = injector.getInstance(TwillRunnerService.class);\n\n      // Get the Router\n      router = injector.getInstance(NettyRouter.class);\n\n      LOG.info(\"Router initialized.\");\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","id":95252,"modified_method":"@Override\n  public void init(String[] args) {\n    LOG.info(\"Initializing Router...\");\n    try {\n      // Load configuration\n      CConfiguration cConf = CConfiguration.create();\n\n      // Initialize ZK client\n      String zookeeper = cConf.get(Constants.Zookeeper.QUORUM);\n      if (zookeeper == null) {\n        LOG.error(\"No zookeeper quorum provided.\");\n        System.exit(1);\n      }\n\n      Injector injector = createGuiceInjector(cConf);\n      zkClientService = injector.getInstance(ZKClientService.class);\n\n      // Get the Router\n      router = injector.getInstance(NettyRouter.class);\n\n      LOG.info(\"Router initialized.\");\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"44190f4897ae7df74c850d0886100417ba38ed47","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping Router...\");\n    Futures.getUnchecked(Services.chainStop(router, twillRunnerService, zkClientService));\n    LOG.info(\"Router stopped.\");\n  }","id":95253,"modified_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping Router...\");\n    Futures.getUnchecked(Services.chainStop(router, zkClientService));\n    LOG.info(\"Router stopped.\");\n  }","commit_id":"44190f4897ae7df74c850d0886100417ba38ed47","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void start() {\n    LOG.info(\"Starting Router...\");\n    Futures.getUnchecked(Services.chainStart(zkClientService, twillRunnerService, router));\n    LOG.info(\"Router started.\");\n  }","id":95254,"modified_method":"@Override\n  public void start() {\n    LOG.info(\"Starting Router...\");\n    Futures.getUnchecked(Services.chainStart(zkClientService, router));\n    LOG.info(\"Router started.\");\n  }","commit_id":"44190f4897ae7df74c850d0886100417ba38ed47","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getDistributedModules() {\n    return Modules.combine(getCommonModules(), new TwillModule());\n  }","id":95255,"modified_method":"@Override\n  public Module getDistributedModules() {\n    return getCommonModules();\n  }","commit_id":"44190f4897ae7df74c850d0886100417ba38ed47","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * @see org.opencms.gwt.shared.rpc.I_CmsVfsService#prepareEdit(org.opencms.util.CmsUUID, java.lang.String)\n     */\n    public CmsPrepareEditResponse prepareEdit(CmsUUID currentPageId, String pathWithMacros) throws CmsRpcException {\n\n        try {\n            CmsObject cms = getCmsObject();\n            CmsResource currentPage = cms.readResource(currentPageId, CmsResourceFilter.IGNORE_EXPIRATION);\n            String path = prepareFileNameForEditor(cms, currentPage, pathWithMacros);\n            CmsResource resource = cms.readResource(path, CmsResourceFilter.IGNORE_EXPIRATION);\n            ensureLock(resource);\n            CmsPrepareEditResponse result = new CmsPrepareEditResponse();\n            result.setRootPath(resource.getRootPath());\n            result.setSitePath(cms.getSitePath(resource));\n            result.setStructureId(resource.getStructureId());\n            return result;\n        } catch (Throwable e) {\n            error(e);\n        }\n        return null;\n    }","id":95256,"modified_method":"/**\n     * @see org.opencms.gwt.shared.rpc.I_CmsVfsService#prepareEdit(org.opencms.util.CmsUUID, java.lang.String)\n     */\n    public CmsPrepareEditResponse prepareEdit(CmsUUID currentPageId, String pathWithMacros) throws CmsRpcException {\n\n        try {\n            CmsObject cms = getCmsObject();\n            CmsResource resource = null;\n            if (cms.existsResource(pathWithMacros, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\n                resource = cms.readResource(pathWithMacros, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED);\n            } else {\n                CmsResource currentPage = cms.readResource(currentPageId, CmsResourceFilter.IGNORE_EXPIRATION);\n                String path = prepareFileNameForEditor(cms, currentPage, pathWithMacros);\n                resource = cms.readResource(path, CmsResourceFilter.IGNORE_EXPIRATION);\n            }\n            ensureLock(resource);\n            CmsPrepareEditResponse result = new CmsPrepareEditResponse();\n            result.setRootPath(resource.getRootPath());\n            result.setSitePath(cms.getSitePath(resource));\n            result.setStructureId(resource.getStructureId());\n            return result;\n        } catch (Throwable e) {\n            error(e);\n        }\n        return null;\n    }","commit_id":"b84ebce5545e5977cb2d19028c49a98274100652","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.apps.I_CmsWorkplaceApp#onStateChange(java.lang.String)\n     */\n    public void onStateChange(String state) {\n\n        CmsUUID resId = getResourceIdFromState(state);\n        CmsAppWorkplaceUi.get();\n        CmsObject cms = A_CmsUI.getCmsObject();\n        try {\n            CmsResource resource = cms.readResource(resId, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED);\n            I_CmsEditor editor = OpenCms.getWorkplaceAppManager().getEditorForResource(resource, isPlainText(state));\n            if (editor != null) {\n                m_editorInstance = editor.newInstance();\n                m_editorInstance.initUI(m_context, resource, getBackLinkFromState(state));\n            }\n\n        } catch (CmsException e) {\n            LOG.error(\"Error initializing the editor.\", e);\n        }\n    }","id":95257,"modified_method":"/**\n     * @see org.opencms.ui.apps.I_CmsWorkplaceApp#onStateChange(java.lang.String)\n     */\n    public void onStateChange(String state) {\n\n        CmsUUID resId = getResourceIdFromState(state);\n        String path = null;\n        if (resId == null) {\n            path = getResourcePathFromState(state);\n        }\n\n        CmsAppWorkplaceUi.get();\n        CmsObject cms = A_CmsUI.getCmsObject();\n        try {\n            CmsResource resource;\n            if (resId != null) {\n                resource = cms.readResource(resId, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED);\n            } else {\n                resource = cms.readResource(path, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED);\n            }\n            I_CmsEditor editor = OpenCms.getWorkplaceAppManager().getEditorForResource(resource, isPlainText(state));\n            if (editor != null) {\n                m_editorInstance = editor.newInstance();\n                m_editorInstance.initUI(m_context, resource, getBackLinkFromState(state));\n            }\n\n        } catch (CmsException e) {\n            LOG.error(\"Error initializing the editor.\", e);\n            CmsErrorDialog.showErrorDialog(e);\n        }\n    }","commit_id":"8f1fd2c56609c1cd77c707b3f5c3011ae15f2295","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.BodyTagSupport#doEndTag()\n     */\n    @Override\n    public int doEndTag() {\n\n        ServletRequest request = pageContext.getRequest();\n        ServletResponse response = pageContext.getResponse();\n        if (CmsFlexController.isCmsRequest(request)) {\n            // this will always be true if the page is called through OpenCms\n            CmsObject cms = CmsFlexController.getCmsObject(request);\n            try {\n                CmsResource res = cms.readResource(m_value);\n                boolean isOnline = cms.getRequestContext().getCurrentProject().isOnlineProject();\n                I_CmsFormatterBean formatter = getFormatterForType(cms, res, isOnline);\n                displayAction(\n                    res,\n                    formatter,\n                    m_parameterMap,\n                    m_editable,\n                    m_canCreate,\n                    m_canDelete,\n                    m_creationSiteMap,\n                    m_postCreateHandler,\n                    pageContext,\n                    request,\n                    response);\n            } catch (CmsException e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        release();\n        return EVAL_PAGE;\n    }","id":95258,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.BodyTagSupport#doEndTag()\n     */\n    @Override\n    public int doEndTag() {\n\n        ServletRequest request = pageContext.getRequest();\n        ServletResponse response = pageContext.getResponse();\n        if (CmsFlexController.isCmsRequest(request)) {\n            // this will always be true if the page is called through OpenCms\n            CmsObject cms = CmsFlexController.getCmsObject(request);\n            try {\n                boolean isOnline = cms.getRequestContext().getCurrentProject().isOnlineProject();\n                CmsResource res = isOnline\n                ? cms.readResource(m_value)\n                : cms.readResource(m_value, CmsResourceFilter.IGNORE_EXPIRATION);\n                I_CmsFormatterBean formatter = getFormatterForType(cms, res, isOnline);\n                displayAction(\n                    res,\n                    formatter,\n                    m_parameterMap,\n                    m_editable,\n                    m_canCreate,\n                    m_canDelete,\n                    m_creationSiteMap,\n                    m_postCreateHandler,\n                    pageContext,\n                    request,\n                    response);\n            } catch (CmsException e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        release();\n        return EVAL_PAGE;\n    }","commit_id":"52aeadb1fd21f9ca91b36d330f47e2d26076ae96","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@org.junit.Test\n    public void testUsernameTokenSAML1Encrypted() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = AsymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = AsymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML1EncryptedPort\");\n        DoubleItPortType asymmetricSaml1EncryptedPort = \n                service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(asymmetricSaml1EncryptedPort, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)asymmetricSaml1EncryptedPort, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(asymmetricSaml1EncryptedPort);\n        }\n        \n        // Set the X509Certificate manually on the STSClient (just to test that we can)\n        BindingProvider bindingProvider = (BindingProvider)asymmetricSaml1EncryptedPort;\n        STSClient stsClient = \n            (STSClient)bindingProvider.getRequestContext().get(SecurityConstants.STS_CLIENT);\n        Crypto crypto = CryptoFactory.getInstance(\"clientKeystore.properties\");\n        CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);\n        cryptoType.setAlias(\"myclientkey\");\n        X509Certificate[] certs = crypto.getX509Certificates(cryptoType);\n        stsClient.setUseKeyCertificate(certs[0]);\n        \n        // TODO Streaming - The encrypted issued token is placed under the Signature\n        // and hence an error is thrown on the receiving side\n        if (!test.isStreaming()) {\n            doubleIt(asymmetricSaml1EncryptedPort, 40);\n        }\n        \n        \n        ((java.io.Closeable)asymmetricSaml1EncryptedPort).close();\n        bus.shutdown(true);\n    }","id":95259,"modified_method":"@org.junit.Test\n    public void testUsernameTokenSAML1Encrypted() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = AsymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = AsymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML1EncryptedPort\");\n        DoubleItPortType asymmetricSaml1EncryptedPort = \n                service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(asymmetricSaml1EncryptedPort, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)asymmetricSaml1EncryptedPort, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(asymmetricSaml1EncryptedPort);\n        }\n        \n        // Set the X509Certificate manually on the STSClient (just to test that we can)\n        BindingProvider bindingProvider = (BindingProvider)asymmetricSaml1EncryptedPort;\n        STSClient stsClient = \n            (STSClient)bindingProvider.getRequestContext().get(SecurityConstants.STS_CLIENT);\n        Crypto crypto = CryptoFactory.getInstance(\"clientKeystore.properties\");\n        CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);\n        cryptoType.setAlias(\"myclientkey\");\n        X509Certificate[] certs = crypto.getX509Certificates(cryptoType);\n        stsClient.setUseKeyCertificate(certs[0]);\n        \n        // TODO Streaming - The encrypted issued token is placed under the Signature\n        // and hence an error is thrown on the receiving side\n        if (!test.isStreaming()) {\n            doubleIt(asymmetricSaml1EncryptedPort, 40);\n        }\n        \n        ((java.io.Closeable)asymmetricSaml1EncryptedPort).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameTokenSAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = AsymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = AsymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML2Port\");\n        DoubleItPortType asymmetricSaml2Port = \n                service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(asymmetricSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)asymmetricSaml2Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(asymmetricSaml2Port);\n        }\n        \n        doubleIt(asymmetricSaml2Port, 30);\n        TokenTestUtils.verifyToken(asymmetricSaml2Port);\n        \n        ((java.io.Closeable)asymmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95260,"modified_method":"@org.junit.Test\n    public void testUsernameTokenSAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = AsymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = AsymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML2Port\");\n        DoubleItPortType asymmetricSaml2Port = \n                service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(asymmetricSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)asymmetricSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(asymmetricSaml2Port);\n        }\n        \n        doubleIt(asymmetricSaml2Port, 30);\n        TokenTestUtils.verifyToken(asymmetricSaml2Port);\n        \n        ((java.io.Closeable)asymmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                \"Server failed to launch\",\n                // run the server in the same process\n                // set this to false to fork\n                launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95261,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                \"Server failed to launch\",\n                // run the server in the same process\n                // set this to false to fork\n                launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxSTSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false)},\n                                                {new TestParam(PORT, true)},\n                                                {new TestParam(STAX_PORT, false)},\n                                                {new TestParam(STAX_PORT, true)},\n        });\n    }","id":95262,"modified_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false, STSPORT2)},\n                                                {new TestParam(PORT, true, STSPORT2)},\n                                                {new TestParam(STAX_PORT, false, STSPORT2)},\n                                                {new TestParam(STAX_PORT, true, STSPORT2)},\n                                                \n                                                {new TestParam(PORT, false, STAX_STSPORT2)},\n                                                {new TestParam(PORT, true, STAX_STSPORT2)},\n                                                {new TestParam(STAX_PORT, false, STAX_STSPORT2)},\n                                                {new TestParam(STAX_PORT, true, STAX_STSPORT2)},\n        });\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameTokenSAML1() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = AsymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = AsymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML1Port\");\n        DoubleItPortType asymmetricSaml1Port = \n                service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(asymmetricSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)asymmetricSaml1Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(asymmetricSaml1Port);\n        }\n        \n        doubleIt(asymmetricSaml1Port, 25);\n        \n        ((java.io.Closeable)asymmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95263,"modified_method":"@org.junit.Test\n    public void testUsernameTokenSAML1() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = AsymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = AsymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML1Port\");\n        DoubleItPortType asymmetricSaml1Port = \n                service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(asymmetricSaml1Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)asymmetricSaml1Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(asymmetricSaml1Port);\n        }\n        \n        doubleIt(asymmetricSaml1Port, 25);\n        \n        ((java.io.Closeable)asymmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML2Bearer() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = BearerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = BearerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2BearerPort\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, STSPORT);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        doubleIt(transportSaml2Port, 45);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95264,"modified_method":"@org.junit.Test\n    public void testSAML2Bearer() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = BearerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = BearerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2BearerPort\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        doubleIt(transportSaml2Port, 45);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML2BearerNoBinding() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = BearerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = BearerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2BearerPort2\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, STSPORT);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        doubleIt(transportSaml2Port, 45);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95265,"modified_method":"@org.junit.Test\n    public void testSAML2BearerNoBinding() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = BearerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = BearerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2BearerPort2\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        doubleIt(transportSaml2Port, 45);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false)},\n                                                {new TestParam(PORT, true)},\n                                                {new TestParam(STAX_PORT, false)},\n                                                {new TestParam(STAX_PORT, true)},\n        });\n    }","id":95266,"modified_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false, STSPORT)},\n                                                {new TestParam(PORT, true, STSPORT)},\n                                                {new TestParam(STAX_PORT, false, STSPORT)},\n                                                {new TestParam(STAX_PORT, true, STSPORT)},\n                                                \n                                                {new TestParam(PORT, false, STAX_STSPORT)},\n                                                {new TestParam(PORT, true, STAX_STSPORT)},\n                                                {new TestParam(STAX_PORT, false, STAX_STSPORT)},\n                                                {new TestParam(STAX_PORT, true, STAX_STSPORT)},\n        });\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML2UnsignedBearer() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = BearerTest.class.getResource(\"cxf-unsigned-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = BearerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2BearerPort\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, STSPORT);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        //\n        // Create a SAML2 Bearer Assertion and add it to the TokenStore so that the\n        // IssuedTokenInterceptorProvider does not invoke on the STS\n        //\n        Client client = ClientProxy.getClient(transportSaml2Port);\n        Endpoint ep = client.getEndpoint();\n        String id = \"1234\";\n        ep.getEndpointInfo().setProperty(TokenStore.class.getName(), new MemoryTokenStore());\n        ep.getEndpointInfo().setProperty(SecurityConstants.TOKEN_ID, id);\n        TokenStore store = (TokenStore)ep.getEndpointInfo().getProperty(TokenStore.class.getName());\n\n        SAMLCallback samlCallback = new SAMLCallback();\n        SAMLUtil.doSAMLCallback(new Saml2CallbackHandler(), samlCallback);\n        SamlAssertionWrapper assertion = new SamlAssertionWrapper(samlCallback);\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        Element assertionElement = assertion.toDOM(db.newDocument());\n        \n        SecurityToken tok = new SecurityToken(id);\n        tok.setTokenType(WSConstants.WSS_SAML2_TOKEN_TYPE);\n        tok.setToken(assertionElement);\n        store.add(tok);\n        \n        doubleIt(transportSaml2Port, 50);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95267,"modified_method":"@org.junit.Test\n    public void testSAML2UnsignedBearer() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = BearerTest.class.getResource(\"cxf-unsigned-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = BearerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2BearerPort\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        //\n        // Create a SAML2 Bearer Assertion and add it to the TokenStore so that the\n        // IssuedTokenInterceptorProvider does not invoke on the STS\n        //\n        Client client = ClientProxy.getClient(transportSaml2Port);\n        Endpoint ep = client.getEndpoint();\n        String id = \"1234\";\n        ep.getEndpointInfo().setProperty(TokenStore.class.getName(), new MemoryTokenStore());\n        ep.getEndpointInfo().setProperty(SecurityConstants.TOKEN_ID, id);\n        TokenStore store = (TokenStore)ep.getEndpointInfo().getProperty(TokenStore.class.getName());\n\n        SAMLCallback samlCallback = new SAMLCallback();\n        SAMLUtil.doSAMLCallback(new Saml2CallbackHandler(), samlCallback);\n        SamlAssertionWrapper assertion = new SamlAssertionWrapper(samlCallback);\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        Element assertionElement = assertion.toDOM(db.newDocument());\n        \n        SecurityToken tok = new SecurityToken(id);\n        tok.setTokenType(WSConstants.WSS_SAML2_TOKEN_TYPE);\n        tok.setToken(assertionElement);\n        store.add(tok);\n        \n        doubleIt(transportSaml2Port, 50);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95268,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxSTSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testIntermediaryTransformationCaching() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IntermediaryTransformationCachingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n        \n        URL wsdl = IntermediaryTransformationCachingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportPort = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportPort, PORT);\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportPort, STSPORT);\n        }\n\n        // Make initial successful invocation\n        doubleIt(transportPort, 25);\n        \n        // Make another invocation - this should work as the intermediary caches the token\n        // even though its STSClient is disabled after the first invocation\n        doubleIt(transportPort, 30);\n        \n        ((java.io.Closeable)transportPort).close();\n        bus.shutdown(true);\n    }","id":95269,"modified_method":"@org.junit.Test\n    public void testIntermediaryTransformationCaching() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IntermediaryTransformationCachingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n        \n        URL wsdl = IntermediaryTransformationCachingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportPort = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportPort, PORT);\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportPort, STSPORT);\n\n        // Make initial successful invocation\n        doubleIt(transportPort, 25);\n        \n        // Make another invocation - this should work as the intermediary caches the token\n        // even though its STSClient is disabled after the first invocation\n        doubleIt(transportPort, 30);\n        \n        ((java.io.Closeable)transportPort).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Intermediary failed to launch\",\n            // run the Intermediary in the same process\n            // set this to false to fork\n            launchServer(IntermediaryCaching.class, true)\n        );\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95270,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Intermediary failed to launch\",\n            // run the Intermediary in the same process\n            // set this to false to fork\n            launchServer(IntermediaryCaching.class, true)\n        );\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testIntermediaryTransformation() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IntermediaryTransformationTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n        \n        URL wsdl = IntermediaryTransformationTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportPort = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportPort, PORT);\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportPort, STSPORT);\n        }\n\n        doubleIt(transportPort, 25);\n        \n        ((java.io.Closeable)transportPort).close();\n        bus.shutdown(true);\n    }","id":95271,"modified_method":"@org.junit.Test\n    public void testIntermediaryTransformation() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IntermediaryTransformationTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n        \n        URL wsdl = IntermediaryTransformationTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportPort = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportPort, PORT);\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportPort, STSPORT);\n\n        doubleIt(transportPort, 25);\n        \n        ((java.io.Closeable)transportPort).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testIntermediaryTransformationBadClient() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IntermediaryTransformationTest.class.getResource(\"cxf-bad-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = IntermediaryTransformationTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportPort = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportPort, PORT);\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportPort, STSPORT);\n        }\n\n        try {\n            doubleIt(transportPort, 30);\n            fail(\"Expected failure on a bad user\");\n        } catch (Exception ex) {\n            // expected\n        }\n        \n        ((java.io.Closeable)transportPort).close();\n        bus.shutdown(true);\n    }","id":95272,"modified_method":"@org.junit.Test\n    public void testIntermediaryTransformationBadClient() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IntermediaryTransformationTest.class.getResource(\"cxf-bad-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = IntermediaryTransformationTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportPort = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportPort, PORT);\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportPort, STSPORT);\n\n        try {\n            doubleIt(transportPort, 30);\n            fail(\"Expected failure on a bad user\");\n        } catch (Exception ex) {\n            // expected\n        }\n        \n        ((java.io.Closeable)transportPort).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Intermediary failed to launch\",\n            // run the Intermediary in the same process\n            // set this to false to fork\n            launchServer(Intermediary.class, true)\n        );\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95273,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Intermediary failed to launch\",\n            // run the Intermediary in the same process\n            // set this to false to fork\n            launchServer(Intermediary.class, true)\n        );\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95274,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"private SecurityToken requestSecurityToken(\n        String tokenType, \n        String keyType,\n        Element supportingToken,\n        Bus bus,\n        String endpointAddress,\n        String context,\n        Map<String, Object> msgProperties,\n        String realmUri,\n        String wsdlPort\n    ) throws Exception {\n        STSClient stsClient = new STSClient(bus);\n        String port = \"8443\";\n        if (standalone) {\n            port = STSPORT;\n        }\n        if (realmUri != null) {\n            stsClient.setWsdlLocation(\"https://localhost:\" + port + \"/SecurityTokenService/\" + realmUri\n                                      + \"/Transport?wsdl\");\n        } else {\n            stsClient.setWsdlLocation(\"https://localhost:\" + port + \"/SecurityTokenService/Transport?wsdl\");\n        }\n        stsClient.setServiceName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}SecurityTokenService\");\n        if (wsdlPort != null) {\n            stsClient.setEndpointName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}\" + wsdlPort);\n        } else {\n            stsClient.setEndpointName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}Transport_Port\");\n        }\n\n        Map<String, Object> properties = msgProperties;\n        if (properties == null) {\n            properties = new HashMap<String, Object>();\n            properties.put(SecurityConstants.USERNAME, \"alice\");\n            properties.put(\n                SecurityConstants.CALLBACK_HANDLER, \n                \"org.apache.cxf.systest.sts.common.CommonCallbackHandler\"\n            );\n        }\n        properties.put(SecurityConstants.IS_BSP_COMPLIANT, \"false\");\n        \n        if (PUBLIC_KEY_KEYTYPE.equals(keyType)) {\n            properties.put(SecurityConstants.STS_TOKEN_USERNAME, \"myclientkey\");\n            properties.put(SecurityConstants.STS_TOKEN_PROPERTIES, \"clientKeystore.properties\");\n            stsClient.setUseCertificateForConfirmationKeyInfo(true);\n        }\n        if (supportingToken != null) {\n            stsClient.setOnBehalfOf(supportingToken);\n        }\n        if (context != null) {\n            stsClient.setContext(context);\n        }\n        \n        stsClient.setProperties(properties);\n        stsClient.setTokenType(tokenType);\n        stsClient.setKeyType(keyType);\n        \n        return stsClient.requestSecurityToken(endpointAddress);\n    }","id":95275,"modified_method":"private SecurityToken requestSecurityToken(\n        String tokenType, \n        String keyType,\n        Element supportingToken,\n        Bus bus,\n        String endpointAddress,\n        String context,\n        Map<String, Object> msgProperties,\n        String realmUri,\n        String wsdlPort\n    ) throws Exception {\n        STSClient stsClient = new STSClient(bus);\n        String port = STSPORT;\n\n        if (realmUri != null) {\n            stsClient.setWsdlLocation(\"https://localhost:\" + port + \"/SecurityTokenService/\" + realmUri\n                                      + \"/Transport?wsdl\");\n        } else {\n            stsClient.setWsdlLocation(\"https://localhost:\" + port + \"/SecurityTokenService/Transport?wsdl\");\n        }\n        stsClient.setServiceName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}SecurityTokenService\");\n        if (wsdlPort != null) {\n            stsClient.setEndpointName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}\" + wsdlPort);\n        } else {\n            stsClient.setEndpointName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}Transport_Port\");\n        }\n\n        Map<String, Object> properties = msgProperties;\n        if (properties == null) {\n            properties = new HashMap<String, Object>();\n            properties.put(SecurityConstants.USERNAME, \"alice\");\n            properties.put(\n                SecurityConstants.CALLBACK_HANDLER, \n                \"org.apache.cxf.systest.sts.common.CommonCallbackHandler\"\n            );\n        }\n        properties.put(SecurityConstants.IS_BSP_COMPLIANT, \"false\");\n        \n        if (PUBLIC_KEY_KEYTYPE.equals(keyType)) {\n            properties.put(SecurityConstants.STS_TOKEN_USERNAME, \"myclientkey\");\n            properties.put(SecurityConstants.STS_TOKEN_PROPERTIES, \"clientKeystore.properties\");\n            stsClient.setUseCertificateForConfirmationKeyInfo(true);\n        }\n        if (supportingToken != null) {\n            stsClient.setOnBehalfOf(supportingToken);\n        }\n        if (context != null) {\n            stsClient.setContext(context);\n        }\n        \n        stsClient.setProperties(properties);\n        stsClient.setTokenType(tokenType);\n        stsClient.setKeyType(keyType);\n        \n        return stsClient.requestSecurityToken(endpointAddress);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"private SecurityToken requestSecurityTokenTTL(\n            String tokenType, \n            String keyType,\n            Bus bus,\n            String endpointAddress\n    ) throws Exception {\n        STSClient stsClient = new STSClient(bus);\n        String port = \"8443\";\n        if (standalone) {\n            port = STSPORT;\n        }\n        stsClient.setWsdlLocation(\"https://localhost:\" + port + \"/SecurityTokenService/Transport?wsdl\");\n        stsClient.setServiceName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}SecurityTokenService\");\n        stsClient.setEndpointName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}Transport_Port\");\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(SecurityConstants.USERNAME, \"alice\");\n        properties.put(\n            SecurityConstants.CALLBACK_HANDLER, \n            \"org.apache.cxf.systest.sts.common.CommonCallbackHandler\"\n        );\n        properties.put(SecurityConstants.ENCRYPT_PROPERTIES, \"clientKeystore.properties\");\n        properties.put(SecurityConstants.ENCRYPT_USERNAME, \"mystskey\");\n        properties.put(SecurityConstants.IS_BSP_COMPLIANT, \"false\");\n\n        if (PUBLIC_KEY_KEYTYPE.equals(keyType)) {\n            properties.put(SecurityConstants.STS_TOKEN_USERNAME, \"myclientkey\");\n            properties.put(SecurityConstants.STS_TOKEN_PROPERTIES, \"clientKeystore.properties\");\n            stsClient.setUseCertificateForConfirmationKeyInfo(true);\n        }\n        stsClient.setEnableLifetime(true);\n        stsClient.setTtl(60 * 30);\n\n        stsClient.setProperties(properties);\n        stsClient.setTokenType(tokenType);\n        stsClient.setKeyType(keyType);\n        stsClient.setAddressingNamespace(\"http://www.w3.org/2005/08/addressing\");\n\n        return stsClient.requestSecurityToken(endpointAddress);\n    }","id":95276,"modified_method":"private SecurityToken requestSecurityTokenTTL(\n            String tokenType, \n            String keyType,\n            Bus bus,\n            String endpointAddress\n    ) throws Exception {\n        STSClient stsClient = new STSClient(bus);\n        String port = STSPORT;\n\n        stsClient.setWsdlLocation(\"https://localhost:\" + port + \"/SecurityTokenService/Transport?wsdl\");\n        stsClient.setServiceName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}SecurityTokenService\");\n        stsClient.setEndpointName(\"{http://docs.oasis-open.org/ws-sx/ws-trust/200512/}Transport_Port\");\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(SecurityConstants.USERNAME, \"alice\");\n        properties.put(\n            SecurityConstants.CALLBACK_HANDLER, \n            \"org.apache.cxf.systest.sts.common.CommonCallbackHandler\"\n        );\n        properties.put(SecurityConstants.ENCRYPT_PROPERTIES, \"clientKeystore.properties\");\n        properties.put(SecurityConstants.ENCRYPT_USERNAME, \"mystskey\");\n        properties.put(SecurityConstants.IS_BSP_COMPLIANT, \"false\");\n\n        if (PUBLIC_KEY_KEYTYPE.equals(keyType)) {\n            properties.put(SecurityConstants.STS_TOKEN_USERNAME, \"myclientkey\");\n            properties.put(SecurityConstants.STS_TOKEN_PROPERTIES, \"clientKeystore.properties\");\n            stsClient.setUseCertificateForConfirmationKeyInfo(true);\n        }\n        stsClient.setEnableLifetime(true);\n        stsClient.setTtl(60 * 30);\n\n        stsClient.setProperties(properties);\n        stsClient.setTokenType(tokenType);\n        stsClient.setKeyType(keyType);\n        stsClient.setAddressingNamespace(\"http://www.w3.org/2005/08/addressing\");\n\n        return stsClient.requestSecurityToken(endpointAddress);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML2MEX() throws Exception {\n        \n        if (!standalone) {\n            return;\n        }\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IssuerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = IssuerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2Port\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, PORT);\n\n        doubleIt(transportSaml2Port, 25);\n\n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95277,"modified_method":"@org.junit.Test\n    public void testSAML2MEX() throws Exception {\n        \n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IssuerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = IssuerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2Port\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, PORT);\n\n        doubleIt(transportSaml2Port, 25);\n\n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML1Issuer() throws Exception {\n        \n        if (!standalone) {\n            return;\n        }\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IssuerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = IssuerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1Port\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, PORT);\n\n        doubleIt(transportSaml1Port, 25);\n\n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95278,"modified_method":"@org.junit.Test\n    public void testSAML1Issuer() throws Exception {\n        \n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = IssuerTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = IssuerTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1Port\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, PORT);\n\n        doubleIt(transportSaml1Port, 25);\n\n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        \n        try {\n            ServerSocket sock = new ServerSocket(30101);\n            sock.close();\n            \n            String deployment = System.getProperty(\"sts.deployment\");\n            if (\"standalone\".equals(deployment) || deployment == null) {\n                standalone = true;\n                assertTrue(\n                        \"Server failed to launch\",\n                        // run the server in the same process\n                        // set this to false to fork\n                        launchServer(STSServer.class, true)\n                );\n            }\n        } catch (IOException ex) {\n            // standalone is set to false + the test won't run\n        }\n    }","id":95279,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        \n        try {\n            ServerSocket sock = new ServerSocket(30101);\n            sock.close();\n            \n            assertTrue(\n                       \"Server failed to launch\",\n                       // run the server in the same process\n                       // set this to false to fork\n                       launchServer(STSServer.class, true)\n            );\n        } catch (IOException ex) {\n            // standalone is set to false + the test won't run\n        }\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameTokenSAML1Encrypted() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML1EncryptedPort\");\n        DoubleItPortType symmetricSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml1Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml1Port);\n        }\n\n        // TODO Streaming - The encrypted issued token is placed under the ReferenceList\n        // and hence an error is thrown on the receiving side\n        if (!test.isStreaming()) {\n            doubleIt(symmetricSaml1Port, 25);\n        }\n        \n        ((java.io.Closeable)symmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95280,"modified_method":"@org.junit.Test\n    public void testUsernameTokenSAML1Encrypted() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML1EncryptedPort\");\n        DoubleItPortType symmetricSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml1Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml1Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml1Port);\n        }\n\n        // TODO Streaming - The encrypted issued token is placed under the ReferenceList\n        // and hence an error is thrown on the receiving side\n        if (!test.isStreaming()) {\n            doubleIt(symmetricSaml1Port, 25);\n        }\n        \n        ((java.io.Closeable)symmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false)},\n                                                {new TestParam(PORT, true)},\n                                                {new TestParam(STAX_PORT, false)},\n                                                {new TestParam(STAX_PORT, true)},\n        });\n    }","id":95281,"modified_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false, STSPORT2)},\n                                                {new TestParam(PORT, true, STSPORT2)},\n                                                {new TestParam(STAX_PORT, false, STSPORT2)},\n                                                {new TestParam(STAX_PORT, true, STSPORT2)},\n                                                \n                                                {new TestParam(PORT, false, STAX_STSPORT2)},\n                                                {new TestParam(PORT, true, STAX_STSPORT2)},\n                                                {new TestParam(STAX_PORT, false, STAX_STSPORT2)},\n                                                {new TestParam(STAX_PORT, true, STAX_STSPORT2)},\n        });\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameTokenSAML2SecureConversation() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2SecureConversationPort\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        doubleIt(symmetricSaml2Port, 30);\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95282,"modified_method":"@org.junit.Test\n    public void testUsernameTokenSAML2SecureConversation() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2SecureConversationPort\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        doubleIt(symmetricSaml2Port, 30);\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95283,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxSTSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameTokenSAML1() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML1Port\");\n        DoubleItPortType symmetricSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml1Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml1Port);\n        }\n\n        doubleIt(symmetricSaml1Port, 25);\n        TokenTestUtils.verifyToken(symmetricSaml1Port);\n        \n        ((java.io.Closeable)symmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95284,"modified_method":"@org.junit.Test\n    public void testUsernameTokenSAML1() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML1Port\");\n        DoubleItPortType symmetricSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml1Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml1Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml1Port);\n        }\n\n        doubleIt(symmetricSaml1Port, 25);\n        TokenTestUtils.verifyToken(symmetricSaml1Port);\n        \n        ((java.io.Closeable)symmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameTokenSAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2Port\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        doubleIt(symmetricSaml2Port, 30);\n        TokenTestUtils.verifyToken(symmetricSaml2Port);\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95285,"modified_method":"@org.junit.Test\n    public void testUsernameTokenSAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2Port\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        doubleIt(symmetricSaml2Port, 30);\n        TokenTestUtils.verifyToken(symmetricSaml2Port);\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"public TestParam(String p, boolean b) {\n        port = p;\n        streaming = b;\n    }","id":95286,"modified_method":"public TestParam(String p, boolean b) {\n        this(p, b, null);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"public String toString() {\n        return port + \":\" + (streaming ? \"streaming\" : \"dom\");\n    }","id":95287,"modified_method":"public String toString() {\n        return port + \":\" + (streaming ? \"streaming\" : \"dom\") + \":\" + stsPort;\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML1Endorsing() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, STSPORT);\n        }\n\n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        doubleIt(transportSaml1Port, 25);\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95288,"modified_method":"@org.junit.Test\n    public void testSAML1Endorsing() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n\n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        doubleIt(transportSaml1Port, 25);\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2Port\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, STSPORT);\n        }\n\n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        doubleIt(transportSaml2Port, 25);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95289,"modified_method":"@org.junit.Test\n    public void testSAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML2Port\");\n        DoubleItPortType transportSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml2Port, test.getStsPort());\n\n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml2Port);\n        }\n        \n        doubleIt(transportSaml2Port, 25);\n        \n        ((java.io.Closeable)transportSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSAML1() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1Port\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, STSPORT);\n        }\n\n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        doubleIt(transportSaml1Port, 25);\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95290,"modified_method":"@org.junit.Test\n    public void testSAML1() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1Port\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, test.getStsPort());\n\n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        doubleIt(transportSaml1Port, 25);\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * In this test-case, the client sends a request for a Security Token with no\n     * AppliesTo address (configured in Spring on the STSClient object). The STS fails as\n     * it will not issue a token to an unknown address.\n     */\n    @org.junit.Test\n    public void testUnknownAddress() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-bad-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, STSPORT);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        try {\n            doubleIt(transportSaml1Port, 35);\n            //fail(\"Expected failure on an unknown address\");\n        } catch (javax.xml.ws.soap.SOAPFaultException fault) {\n            // expected\n        }\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95291,"modified_method":"/**\n     * In this test-case, the client sends a request for a Security Token with no\n     * AppliesTo address (configured in Spring on the STSClient object). The STS fails as\n     * it will not issue a token to an unknown address.\n     */\n    @org.junit.Test\n    public void testUnknownAddress() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-bad-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1EndorsingPort\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n\n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        try {\n            doubleIt(transportSaml1Port, 35);\n            //fail(\"Expected failure on an unknown address\");\n        } catch (javax.xml.ws.soap.SOAPFaultException fault) {\n            // expected\n        }\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * In this test-case, the client sends another cert to the STS for inclusion in the\n     * SAML Assertion and connects via 2-way TLS as normal to the service provider. The\n     * service provider will fail, as the TLS cert does not match the cert provided in\n     * the SAML Assertion.\n     */\n    @org.junit.Test\n    public void testUnknownClient() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-bad-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1Port\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, STSPORT);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        try {\n            doubleIt(transportSaml1Port, 35);\n            fail(\"Expected failure on an unknown client\");\n        } catch (javax.xml.ws.soap.SOAPFaultException fault) {\n            // expected\n        }\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95292,"modified_method":"/**\n     * In this test-case, the client sends another cert to the STS for inclusion in the\n     * SAML Assertion and connects via 2-way TLS as normal to the service provider. The\n     * service provider will fail, as the TLS cert does not match the cert provided in\n     * the SAML Assertion.\n     */\n    @org.junit.Test\n    public void testUnknownClient() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = TransportBindingTest.class.getResource(\"cxf-bad-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = TransportBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItTransportSAML1Port\");\n        DoubleItPortType transportSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(transportSaml1Port, test.getPort());\n\n        TokenTestUtils.updateSTSPort((BindingProvider)transportSaml1Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(transportSaml1Port);\n        }\n        \n        try {\n            doubleIt(transportSaml1Port, 35);\n            fail(\"Expected failure on an unknown client\");\n        } catch (javax.xml.ws.soap.SOAPFaultException fault) {\n            // expected\n        }\n        \n        ((java.io.Closeable)transportSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95293,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxSTSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false)},\n                                                {new TestParam(PORT, true)},\n                                                {new TestParam(STAX_PORT, false)},\n                                                {new TestParam(STAX_PORT, true)},\n        });\n    }","id":95294,"modified_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false, STSPORT)},\n                                                {new TestParam(PORT, true, STSPORT)},\n                                                {new TestParam(STAX_PORT, false, STSPORT)},\n                                                {new TestParam(STAX_PORT, true, STSPORT)},\n                                                \n                                                {new TestParam(PORT, false, STAX_STSPORT)},\n                                                {new TestParam(PORT, true, STAX_STSPORT)},\n                                                {new TestParam(STAX_PORT, false, STAX_STSPORT)},\n                                                {new TestParam(STAX_PORT, true, STAX_STSPORT)},\n        });\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameActAs() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = UsernameActAsTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = UsernameActAsTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML2BearerPort\");\n        DoubleItPortType port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port, PORT);\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)port, STSPORT2);\n        }\n        \n        // Transport port\n        ((BindingProvider)port).getRequestContext().put(\n            \"ws-security.username\", \"alice\"\n        );\n        doubleIt(port, 25);\n        \n        ((java.io.Closeable)port).close();\n        \n        DoubleItPortType port2 = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port2, PORT);\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)port2, STSPORT2);\n        }\n        \n        ((BindingProvider)port2).getRequestContext().put(\n            \"ws-security.username\", \"eve\"\n        );\n        // This time we expect a failure as the server validator doesn't accept \"eve\".\n        try {\n            doubleIt(port2, 30);\n            fail(\"Failure expected on an unknown user\");\n        } catch (Exception ex) {\n            // expected\n        }\n        \n        ((java.io.Closeable)port2).close();\n        bus.shutdown(true);\n    }","id":95295,"modified_method":"@org.junit.Test\n    public void testUsernameActAs() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = UsernameActAsTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = UsernameActAsTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItAsymmetricSAML2BearerPort\");\n        DoubleItPortType port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(port);\n        }\n        \n        // Transport port\n        ((BindingProvider)port).getRequestContext().put(\n            \"ws-security.username\", \"alice\"\n        );\n        doubleIt(port, 25);\n        \n        ((java.io.Closeable)port).close();\n        \n        DoubleItPortType port2 = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port2, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)port2, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(port2);\n        }\n        \n        ((BindingProvider)port2).getRequestContext().put(\n            \"ws-security.username\", \"eve\"\n        );\n        // This time we expect a failure as the server validator doesn't accept \"eve\".\n        try {\n            doubleIt(port2, 30);\n            fail(\"Failure expected on an unknown user\");\n        } catch (Exception ex) {\n            // expected\n        }\n        \n        ((java.io.Closeable)port2).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95296,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxSTSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testUsernameOnBehalfOf() throws Exception {\n        // Only run these tests for the standalone scenario.\n        if (!standalone) {\n            return;\n        }\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = UsernameOnBehalfOfTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = UsernameOnBehalfOfTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItOBOAsymmetricSAML2BearerPort\");\n        DoubleItPortType port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port, PORT);\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)port, STSPORT2);\n        }\n\n        // Transport port\n        ((BindingProvider)port).getRequestContext().put(\n            \"ws-security.username\", \"alice\"\n        );\n        doubleIt(port, 25);\n        \n        ((java.io.Closeable)port).close();\n        \n        DoubleItPortType port2 = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port2, PORT);\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)port2, STSPORT2);\n        }\n        ((BindingProvider)port2).getRequestContext().put(\n            \"ws-security.username\", \"eve\"\n        );\n        // This time we expect a failure as the server validator doesn't accept \"eve\".\n        try {\n            doubleIt(port2, 30);\n            fail(\"Failure expected on an unknown user\");\n        } catch (Exception ex) {\n            // expected\n        }\n        \n        ((java.io.Closeable)port2).close();\n        bus.shutdown(true);\n    }","id":95297,"modified_method":"@org.junit.Test\n    public void testUsernameOnBehalfOf() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = UsernameOnBehalfOfTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = UsernameOnBehalfOfTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItOBOAsymmetricSAML2BearerPort\");\n        DoubleItPortType port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(port);\n        }\n\n        // Transport port\n        ((BindingProvider)port).getRequestContext().put(\n            \"ws-security.username\", \"alice\"\n        );\n        doubleIt(port, 25);\n        \n        ((java.io.Closeable)port).close();\n        \n        DoubleItPortType port2 = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(port2, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)port2, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(port2);\n        }\n        \n        ((BindingProvider)port2).getRequestContext().put(\n            \"ws-security.username\", \"eve\"\n        );\n        // This time we expect a failure as the server validator doesn't accept \"eve\".\n        try {\n            doubleIt(port2, 30);\n            fail(\"Failure expected on an unknown user\");\n        } catch (Exception ex) {\n            // expected\n        }\n        \n        ((java.io.Closeable)port2).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95298,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n            \"Server failed to launch\",\n            // run the server in the same process\n            // set this to false to fork\n            launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxSTSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false)},\n                                                {new TestParam(PORT, true)},\n                                                {new TestParam(STAX_PORT, false)},\n                                                {new TestParam(STAX_PORT, true)},\n        });\n    }","id":95299,"modified_method":"@Parameters(name = \"{0}\")\n    public static Collection<TestParam[]> data() {\n       \n        return Arrays.asList(new TestParam[][] {{new TestParam(PORT, false, STSPORT2)},\n                                                {new TestParam(PORT, true, STSPORT2)},\n                                                {new TestParam(STAX_PORT, false, STSPORT2)},\n                                                {new TestParam(STAX_PORT, true, STSPORT2)},\n                                                \n                                                {new TestParam(PORT, false, STAX_STSPORT2)},\n                                                {new TestParam(PORT, true, STAX_STSPORT2)},\n                                                {new TestParam(STAX_PORT, false, STAX_STSPORT2)},\n                                                {new TestParam(STAX_PORT, true, STAX_STSPORT2)},\n        });\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testX509SAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = X509SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = X509SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2Port\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        doubleIt(symmetricSaml2Port, 30);\n        TokenTestUtils.verifyToken(symmetricSaml2Port);\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95300,"modified_method":"@org.junit.Test\n    public void testX509SAML2() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = X509SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = X509SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2Port\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        doubleIt(symmetricSaml2Port, 30);\n        TokenTestUtils.verifyToken(symmetricSaml2Port);\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        String deployment = System.getProperty(\"sts.deployment\");\n        if (\"standalone\".equals(deployment) || deployment == null) {\n            standalone = true;\n            assertTrue(\n                    \"Server failed to launch\",\n                    // run the server in the same process\n                    // set this to false to fork\n                    launchServer(STSServer.class, true)\n            );\n        }\n    }","id":95301,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(Server.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(STSServer.class, true)\n        );\n        assertTrue(\n                   \"Server failed to launch\",\n                   // run the server in the same process\n                   // set this to false to fork\n                   launchServer(StaxSTSServer.class, true)\n        );\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testX509SAML2Endorsing() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = X509SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = X509SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2EndorsingPort\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        // TODO See WSS-481 - \"Problem with EncryptSignature + EndorsingSupportingTokens\"\n        if (!STAX_PORT.equals(test.getPort())) {\n            doubleIt(symmetricSaml2Port, 30);\n        }\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","id":95302,"modified_method":"@org.junit.Test\n    public void testX509SAML2Endorsing() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = X509SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n\n        URL wsdl = X509SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML2EndorsingPort\");\n        DoubleItPortType symmetricSaml2Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml2Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml2Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml2Port);\n        }\n        \n        // TODO See WSS-481 - \"Problem with EncryptSignature + EndorsingSupportingTokens\"\n        if (!STAX_PORT.equals(test.getPort())) {\n            doubleIt(symmetricSaml2Port, 30);\n        }\n        \n        ((java.io.Closeable)symmetricSaml2Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testX509SAML1() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = X509SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n        \n        URL wsdl = X509SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML1Port\");\n        DoubleItPortType symmetricSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml1Port, test.getPort());\n        if (standalone) {\n            TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml1Port, STSPORT2);\n        }\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml1Port);\n        }\n\n        doubleIt(symmetricSaml1Port, 25);\n        \n        ((java.io.Closeable)symmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","id":95303,"modified_method":"@org.junit.Test\n    public void testX509SAML1() throws Exception {\n\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = X509SymmetricBindingTest.class.getResource(\"cxf-client.xml\");\n\n        Bus bus = bf.createBus(busFile.toString());\n        SpringBusFactory.setDefaultBus(bus);\n        SpringBusFactory.setThreadDefaultBus(bus);\n        \n        URL wsdl = X509SymmetricBindingTest.class.getResource(\"DoubleIt.wsdl\");\n        Service service = Service.create(wsdl, SERVICE_QNAME);\n        QName portQName = new QName(NAMESPACE, \"DoubleItSymmetricSAML1Port\");\n        DoubleItPortType symmetricSaml1Port = \n            service.getPort(portQName, DoubleItPortType.class);\n        updateAddressPort(symmetricSaml1Port, test.getPort());\n        \n        TokenTestUtils.updateSTSPort((BindingProvider)symmetricSaml1Port, test.getStsPort());\n        \n        if (test.isStreaming()) {\n            SecurityTestUtil.enableStreaming(symmetricSaml1Port);\n        }\n\n        doubleIt(symmetricSaml1Port, 25);\n        \n        ((java.io.Closeable)symmetricSaml1Port).close();\n        bus.shutdown(true);\n    }","commit_id":"3b0aae20f9709c5c72fe231edc3eff4a2675c47f","url":"https://github.com/apache/cxf"},{"original_method":"private Class<?> defineType(String name, byte[] bytecode) {\n        if (typesClassLoader == null) {\n            typesClassLoader = new InternalTypesClassLoader(this);\n        }\n        return typesClassLoader.defineClass(name, bytecode);\n    }","id":95304,"modified_method":"private Class<?> defineType(String name, byte[] bytecode) {\n        if (definedTypes == null) {\n            definedTypes = new HashMap<String, ClassBytecode>();\n        } else {\n            ClassBytecode existingClass = definedTypes.get(name);\n            if (existingClass != null && Arrays.equals(bytecode, existingClass.bytes)) {\n                return existingClass.clazz;\n            }\n        }\n\n        if (typesClassLoader == null) {\n            typesClassLoader = new InternalTypesClassLoader(this);\n        }\n        Class<?> clazz = typesClassLoader.defineClass(name, bytecode);\n        definedTypes.put(name, new ClassBytecode(clazz, bytecode));\n        return clazz;\n    }","commit_id":"323f9abe0fef8c9dc41f0b1871d661e1889312e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * open up the super class define that takes raw bytes\n     *\n     */\n    public Class defineClass(String name, byte[] b) {\n        return super.defineClass(name, b, 0, b.length);\n    }","id":95305,"modified_method":"/**\n     * open up the super class define that takes raw bytes\n     *\n     */\n    public Class defineClass(String name, byte[] b) {\n        Class c = super.defineClass(name, b, 0, b.length);\n        synchronized (cache) {\n            cache.put(name, c);\n        }\n        return c;\n    }","commit_id":"095042d95a531304214d3fa0b3c46433c4d461fd","url":"https://github.com/apache/groovy"},{"original_method":"public Account(String firstName, String lastName, String company, String emailId, int accountId,String apiKey) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.company = company;\n    this.emailId = emailId;\n    this.accountId = accountId;\n    this.apiKey = apiKey;\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    accountJson = gson.toJson(this);\n  }","id":95306,"modified_method":"public Account(String firstName, String lastName, String company, int accountId) {\n    this(firstName, lastName, company, \"\", accountId);\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public Account(String firstName, String lastName, String company, String emailId, int accountId) {\n    this(firstName,lastName,company,emailId,accountId,StringUtils.EMPTY);\n  }","id":95307,"modified_method":"public Account(String firstName, String lastName, String company, String emailId, int accountId) {\n    this(firstName, lastName, company, emailId, accountId, StringUtils.EMPTY, false);\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return accountJson;\n  }","id":95308,"modified_method":"@Override\n  public String toString() {\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    return gson.toJson(this);\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addRoleType(int accountId, Role role) throws ConfigurationException, RuntimeException {\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\" ,\n                                              DBUtils.AccountRoleType.TABLE_NAME,\n                                              DBUtils.AccountRoleType.ACCOUNT_ID_COLUMN,\n                                              DBUtils.AccountRoleType.ROLE_NAME_COLUMN,\n                                              DBUtils.AccountRoleType.PERMISSIONS_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,accountId);\n      ps.setString(2,role.getRoleName());\n      ps.setString(3,role.getPermissions());\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":95309,"modified_method":"@Override\n  public boolean addRoleType(int accountId, Role role) throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\",\n        DBUtils.AccountRoleType.TABLE_NAME,\n        DBUtils.AccountRoleType.ACCOUNT_ID_COLUMN,\n        DBUtils.AccountRoleType.ROLE_NAME_COLUMN,\n        DBUtils.AccountRoleType.PERMISSIONS_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1, accountId);\n      ps.setString(2, role.getRoleName());\n      ps.setString(3, role.getPermissions());\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Create Account in the system\n   * @param account Instance of {@code Account}\n   * @return boolean status of account creation\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account createAccount(Account account) throws ConfigurationException, RuntimeException {\n    //TODO: Return boolean?\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n      String SQL = String.format( \"INSERT INTO %s (%s, %s, %s, %s, %s, %s) VALUES (?,?,?,?,?,?)\",\n                                  DBUtils.AccountTable.TABLE_NAME,\n                                  DBUtils.AccountTable.EMAIL_COLUMN, DBUtils.AccountTable.FIRST_NAME_COLUMN,\n                                  DBUtils.AccountTable.LAST_NAME_COLUMN, DBUtils.AccountTable.COMPANY_COLUMN,\n                                  DBUtils.AccountTable.CONFIRMED_COLUMN, DBUtils.AccountTable.ACCOUNT_CREATED_AT\n                                  );\n\n\n      PreparedStatement ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setString(1, account.getEmailId());\n      ps.setString(2,account.getFirstName());\n      ps.setString(3,account.getLastName());\n      ps.setString(4, account.getCompany());\n      ps.setInt(5, DBUtils.AccountTable.ACCOUNT_UNCONFIRMED);\n      ps.setTimestamp(6, new java.sql.Timestamp(System.currentTimeMillis()));\n\n      ps.executeUpdate();\n\n      ResultSet result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n\n      Account createdAccount  = new Account(account.getFirstName(),account.getLastName(),\n                                account.getCompany(),account.getEmailId(),result.getInt(1));\n      return createdAccount;\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n  }","id":95310,"modified_method":"/**\n   * Create Account in the system\n   *\n   * @param account Instance of {@code Account}\n   * @return boolean status of account creation\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account createAccount(Account account)\n    throws ConfigurationException, RuntimeException, AccountAlreadyExistsException {\n    //TODO: Return boolean?\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet result = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"INSERT INTO %s (%s, %s, %s, %s, %s, %s) VALUES (?,?,?,?,?,?)\",\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.EMAIL_COLUMN, DBUtils.AccountTable.FIRST_NAME_COLUMN,\n        DBUtils.AccountTable.LAST_NAME_COLUMN, DBUtils.AccountTable.COMPANY_COLUMN,\n        DBUtils.AccountTable.CONFIRMED_COLUMN, DBUtils.AccountTable.ACCOUNT_CREATED_AT\n      );\n\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setString(1, account.getEmailId());\n      ps.setString(2, account.getFirstName());\n      ps.setString(3, account.getLastName());\n      ps.setString(4, account.getCompany());\n      ps.setInt(5, DBUtils.AccountTable.ACCOUNT_UNCONFIRMED);\n      ps.setTimestamp(6, new java.sql.Timestamp(System.currentTimeMillis()));\n\n      ps.executeUpdate();\n\n      result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n\n      Account createdAccount = new Account(account.getFirstName(), account.getLastName(),\n        account.getCompany(), account.getEmailId(), result.getInt(1));\n      return createdAccount;\n    } catch (SQLException e) {\n      if (DB_INTEGRITY_CONSTRAINT_VIOLATION.equals(e.getSQLState())) {\n        throw new AccountAlreadyExistsException(e.getMessage());\n      }\n\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, result);\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * GetAccount\n   *\n   * @param accountId id of the account\n   * @return null if no entry matches, Instance of {@code Account} otherwise\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account getAccount(int accountId) throws ConfigurationException, RuntimeException {\n\n    Account account = null;\n\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n      String SQL = String.format( \"SELECT %s,%s,%s,%s,%s, %s FROM %s WHERE %s = ?\",\n                                  DBUtils.AccountTable.FIRST_NAME_COLUMN,DBUtils.AccountTable.LAST_NAME_COLUMN,\n                                  DBUtils.AccountTable.COMPANY_COLUMN, DBUtils.AccountTable.EMAIL_COLUMN,\n                                  DBUtils.AccountTable.ID_COLUMN, DBUtils.AccountTable.API_KEY_COLUMN,\n                                  DBUtils.AccountTable.TABLE_NAME,\n                                  DBUtils.AccountTable.ID_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setInt(1,accountId);\n      ResultSet rs = ps.executeQuery();\n\n      int count  = 0;\n      while(rs.next()) {\n        count++;\n        account = new Account(rs.getString(1),rs.getString(2),rs.getString(3),\n                              rs.getString(4),rs.getInt(5),rs.getString(6));\n        if (count > 1 ) { // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    return account;\n  }","id":95311,"modified_method":"/**\n   * GetAccount\n   *\n   * @param accountId id of the account\n   * @return null if no entry matches, Instance of {@code Account} otherwise\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account getAccount(int accountId) throws ConfigurationException, RuntimeException {\n\n    Account account = null;\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n      String SQL = String.format(\"SELECT %s,%s,%s,%s,%s,%s,%s FROM %s WHERE %s = ?\",\n        DBUtils.AccountTable.FIRST_NAME_COLUMN, DBUtils.AccountTable.LAST_NAME_COLUMN,\n        DBUtils.AccountTable.COMPANY_COLUMN, DBUtils.AccountTable.EMAIL_COLUMN,\n        DBUtils.AccountTable.ID_COLUMN, DBUtils.AccountTable.API_KEY_COLUMN,\n        DBUtils.AccountTable.CONFIRMED_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, accountId);\n      rs = ps.executeQuery();\n\n\n      int count = 0;\n      while (rs.next()) {\n        count++;\n        account = new Account(rs.getString(1), rs.getString(2), rs.getString(3),\n          rs.getString(4), rs.getInt(5), rs.getString(6), rs.getBoolean(7));\n        if (count > 1) { // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, rs);\n    }\n\n\n    return account;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void updateAccount(int accountId, Map<String, Object> keyValueParams) throws  ConfigurationException, RuntimeException {\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n\n       Connection connection = this.poolManager.getConnection();\n\n       //Set basic update command\n       StringBuilder sb  = new StringBuilder();\n\n       sb.append(String.format(\"UPDATE %s SET \", DBUtils.AccountTable.TABLE_NAME));\n       boolean firstValue = true;\n\n       if(!keyValueParams.isEmpty()){\n\n         //Add Column names\n         for(Map.Entry e: keyValueParams.entrySet()){\n\n           if (firstValue){\n             sb.append(String.format(\" %s= ?\", (String) e.getKey()));\n             firstValue = false;\n           }\n           else {\n             //append a comma as well\n             sb.append(String.format(\", %s = ?\", (String) e.getKey()));\n           }\n         }\n\n         sb.append(String.format(\" where %s = ? \", DBUtils.AccountTable.ID_COLUMN));\n\n         //Prepared Statement\n         PreparedStatement ps = connection.prepareStatement(sb.toString());\n         int count = 1;\n\n         System.out.println(sb.toString());\n         //Set Values in prepared statement\n         //All values are set as String for now.\n         //For now we are only updating String fields\n         // TODO: Enhance it to actual type of columns later.\n\n         for (Map.Entry e : keyValueParams.entrySet()){\n           ps.setString(count,(String)e.getValue());\n           count++;\n         }\n\n         //Set value for where clause\n         ps.setInt(count, accountId);\n         ps.executeUpdate();\n\n       }\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n  }","id":95312,"modified_method":"@Override\n  public void updateAccount(int accountId, Map<String, Object> keyValueParams) throws ConfigurationException, RuntimeException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n\n      connection = this.poolManager.getConnection();\n\n      //Set basic update command\n      StringBuilder sb = new StringBuilder();\n\n      sb.append(String.format(\"UPDATE %s SET \", DBUtils.AccountTable.TABLE_NAME));\n      boolean firstValue = true;\n\n      if (!keyValueParams.isEmpty()) {\n\n        //Add Column names\n        for (Map.Entry e : keyValueParams.entrySet()) {\n\n          if (firstValue) {\n            sb.append(String.format(\" %s= ?\", (String) e.getKey()));\n            firstValue = false;\n          } else {\n            //append a comma as well\n            sb.append(String.format(\", %s = ?\", (String) e.getKey()));\n          }\n        }\n\n        sb.append(String.format(\" where %s = ? \", DBUtils.AccountTable.ID_COLUMN));\n\n        //Prepared Statement\n        ps = connection.prepareStatement(sb.toString());\n        int count = 1;\n\n        //Set Values in prepared statement\n        //All values are set as String for now.\n        //For now we are only updating String fields\n        // TODO: Enhance it to actual type of columns later.\n\n        for (Map.Entry e : keyValueParams.entrySet()) {\n          ps.setString(count, (String) e.getValue());\n          count++;\n        }\n\n        //Set value for where clause\n        ps.setInt(count, accountId);\n        ps.executeUpdate();\n\n      }\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @param accountId\n   * @throws com.continuuity.passport.core.exceptions.ConfigurationException\n   *\n   * @throws RuntimeException\n   */\n  @Override\n  public void confirmDownload(int accountId) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"UPDATE %s SET %s = ? WHERE %s = ? AND %s is NULL\" ,\n                                  DBUtils.AccountTable.TABLE_NAME,\n                                  DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT,\n                                  DBUtils.AccountTable.ID_COLUMN,\n                                  DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setTimestamp(1, new java.sql.Timestamp(System.currentTimeMillis()));\n      ps.setInt(2, accountId);\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n  }","id":95313,"modified_method":"/**\n   * @param accountId\n   * @throws com.continuuity.passport.core.exceptions.ConfigurationException\n   *\n   * @throws RuntimeException\n   */\n  @Override\n  public void confirmDownload(int accountId) throws ConfigurationException, RuntimeException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"UPDATE %s SET %s = ? WHERE %s = ? AND %s is NULL\",\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT,\n        DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT);\n\n      ps = connection.prepareStatement(SQL);\n\n      ps.setTimestamp(1, new java.sql.Timestamp(System.currentTimeMillis()));\n      ps.setInt(2, accountId);\n\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n\n\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean updateBillingInfo(int accountId, BillingInfo billingInfo) throws ConfigurationException,RuntimeException {\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\" ,\n                                    DBUtils.AccountPayment.TABLE_NAME,\n                                    DBUtils.AccountPayment.ACCOUNT_ID_COLUMN,\n                                    DBUtils.AccountPayment.CREDIT_CARD_NAME_COLUMN,\n                                    DBUtils.AccountPayment.CREDIT_CARD_NUMBER_COLUMN,\n                                    DBUtils.AccountPayment.CREDIT_CARD_CVV_COLUMN,\n                                    DBUtils.AccountPayment.CREDIT_CARD_EXPIRY_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,accountId);\n      ps.setString(2, billingInfo.getCreditCardName());\n      ps.setString(3, billingInfo.getCreditCardNumber());\n      ps.setString(4,billingInfo.getCvv());\n      ps.setString(5,billingInfo.getExpirationDate());\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":95314,"modified_method":"@Override\n  public boolean updateBillingInfo(int accountId, BillingInfo billingInfo) throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n\n      String SQL = String.format(\"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\",\n        DBUtils.AccountPayment.TABLE_NAME,\n        DBUtils.AccountPayment.ACCOUNT_ID_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_NAME_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_NUMBER_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_CVV_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_EXPIRY_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1, accountId);\n      ps.setString(2, billingInfo.getCreditCardName());\n      ps.setString(3, billingInfo.getCreditCardNumber());\n      ps.setString(4, billingInfo.getCvv());\n      ps.setString(5, billingInfo.getExpirationDate());\n\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public boolean confirmRegistration(AccountSecurity security) throws ConfigurationException, RuntimeException{\n\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"UPDATE %s SET %s = ?, %s = ?, %s = ? WHERE %s = ?\" ,\n                                          DBUtils.AccountTable.TABLE_NAME,\n                                          DBUtils.AccountTable.PASSWORD_COLUMN, DBUtils.AccountTable.CONFIRMED_COLUMN,\n                                          DBUtils.AccountTable.API_KEY_COLUMN, DBUtils.AccountTable.ID_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setString(1, generateSaltedHashedPassword(security.getPassword()));\n      ps.setInt(2, DBUtils.AccountTable.ACCOUNT_CONFIRMED);\n      ps.setString(3, ApiKey.generateKey(String.valueOf(security.getAccountId())));\n      ps.setInt(4, security.getAccountId());\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n\n    return true;\n  }","id":95315,"modified_method":"public boolean confirmRegistration(Account account, String password)\n    throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"UPDATE %s SET %s = ?, %s = ?, %s = ?, %s = ?, %s = ?, %s = ? WHERE %s = ?\",\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.PASSWORD_COLUMN, DBUtils.AccountTable.CONFIRMED_COLUMN,\n        DBUtils.AccountTable.API_KEY_COLUMN, DBUtils.AccountTable.FIRST_NAME_COLUMN,\n        DBUtils.AccountTable.LAST_NAME_COLUMN, DBUtils.AccountTable.COMPANY_COLUMN,\n        DBUtils.AccountTable.ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1, generateSaltedHashedPassword(password));\n      ps.setInt(2, DBUtils.AccountTable.ACCOUNT_CONFIRMED);\n      ps.setString(3, ApiKey.generateKey(String.valueOf(account.getAccountId())));\n      ps.setString(4, account.getFirstName());\n      ps.setString(5, account.getLastName());\n      ps.setString(6, account.getCompany());\n      ps.setInt(7, account.getAccountId());\n\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n\n    return true;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Delete Account in the system\n   *\n   * @param accountId AccountId to be deleted\n   * @return boolean status of account deletion\n   * @throws {@code RetryException}\n   */\n  @Override\n  public boolean deleteAccount(String accountId) throws ConfigurationException, RuntimeException {\n\n    //TODO: accountId to int\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"DELETE FROM %s WHERE %s = ?\",\n                                  DBUtils.AccountTable.TABLE_NAME,\n                                  DBUtils.AccountTable.ID_COLUMN);\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setString(1, accountId);\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    return true;\n  }","id":95316,"modified_method":"/**\n   * GetAccount\n   *\n   * @param emailId emailId requested\n   * @return {@code Account}\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account getAccount(String emailId) throws ConfigurationException, RuntimeException {\n\n    Account account = null;\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n      String SQL = String.format(\"SELECT %s,%s,%s,%s,%s,%s,%s FROM %s WHERE %s = ?\",\n        DBUtils.AccountTable.FIRST_NAME_COLUMN, DBUtils.AccountTable.LAST_NAME_COLUMN,\n        DBUtils.AccountTable.COMPANY_COLUMN, DBUtils.AccountTable.EMAIL_COLUMN,\n        DBUtils.AccountTable.ID_COLUMN, DBUtils.AccountTable.API_KEY_COLUMN,\n        DBUtils.AccountTable.CONFIRMED_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.EMAIL_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1, emailId);\n      rs = ps.executeQuery();\n\n      int count = 0;\n      while (rs.next()) {\n        count++;\n        account = new Account(rs.getString(1), rs.getString(2), rs.getString(3),\n          rs.getString(4), rs.getInt(5), rs.getString(6), rs.getBoolean(7));\n        if (count > 1) { // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, rs);\n    }\n\n\n    return account;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public int getAccountId() {\n    return accountId;\n  }","id":95317,"modified_method":"public Account getAccount() {\n    return account;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public AccountSecurity(int accountId, String password) {\n    this.accountId = accountId;\n    this.password = password;\n  }","id":95318,"modified_method":"public AccountSecurity(Account account, String password) {\n    this.account = account;\n    this.password = password;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Register an {@code Account} in the system\n   *\n   * @param account Account information\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Account registerAccount(Account account) throws RuntimeException {\n    if (accountDAO ==null) {\n      throw new RuntimeException(\"Could not init data access Object\");\n\n    }\n    try {\n      return accountDAO.createAccount(account);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":95319,"modified_method":"/**\n   * Register an {@code Account} in the system\n   *\n   * @param account Account information\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Account registerAccount(Account account) throws RuntimeException, AccountAlreadyExistsException {\n    checkValidDAO();\n\n    try {\n      return accountDAO.createAccount(account);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Update account with passed Params\n   *\n   * @param accountId accountId\n   * @param params    Map<\"keyName\", \"value\">\n   */\n  @Override\n  public void updateAccount(int accountId, Map<String, Object> params) throws RuntimeException {\n\n    if (accountDAO ==null) {\n      throw new RuntimeException(\"Could not init data access Object\");\n    }\n    try {\n      accountDAO.updateAccount(accountId, params);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n\n  }","id":95320,"modified_method":"/**\n   * Update account with passed Params\n   *\n   * @param accountId accountId\n   * @param params    Map<\"keyName\", \"value\">\n   */\n  @Override\n  public void updateAccount(int accountId, Map<String, Object> params) throws RuntimeException {\n\n    checkValidDAO();\n    try {\n      accountDAO.updateAccount(accountId, params);\n    } catch (Exception e) {\n      throw new RuntimeException(e.getMessage());\n    }\n\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * GetAccount object\n   *\n   * @param accountId Id of the account\n   * @return Instance of {@code Account}\n   */\n  @Override\n  public Account getAccount(int accountId) throws RuntimeException {\n\n    Account account = null;\n    if (accountDAO ==null) {\n      throw new RuntimeException(\"Could not init data access Object\");\n    }\n    try {\n     account= accountDAO.getAccount(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return account;\n  }","id":95321,"modified_method":"/**\n   * GetAccount object\n   *\n   * @param accountId Id of the account\n   * @return Instance of {@code Account}\n   */\n  @Override\n  public Account getAccount(int accountId) throws RuntimeException {\n\n    checkValidDAO();\n    Account account = null;\n    try {\n      account = accountDAO.getAccount(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return account;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Status confirmRegistration(AccountSecurity account) throws RuntimeException {\n\n    if (accountDAO ==null) {\n      throw new RuntimeException(\"Could not init data access Object\");\n\n    }\n    try {\n      accountDAO.confirmRegistration(account);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return null;\n  }","id":95322,"modified_method":"@Override\n  public Status confirmRegistration(Account account, String password) throws RuntimeException {\n\n    checkValidDAO();\n    try {\n      accountDAO.confirmRegistration(account, password);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return null;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void confirmDownload(int accountId) throws RuntimeException {\n    if (accountDAO ==null) {\n      throw new RuntimeException(\"Could not init data access Object\");\n    }\n    try {\n      accountDAO.confirmDownload(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":95323,"modified_method":"@Override\n  public void confirmDownload(int accountId) throws RuntimeException {\n    checkValidDAO();\n    try {\n      accountDAO.confirmDownload(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Get VPC List based on the ApiKey\n   *\n   * @param apiKey apiKey of the account\n   * @return List of {@code VPC}\n   */\n  @Override\n  public List<VPC> getVPC(String apiKey) {\n    List<VPC> vpcs;\n    if(vpcDao == null) {\n      throw new RuntimeException(\"Could not initialize data access object\");\n    }\n    try {\n      vpcs = vpcDao.getVPC(apiKey);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return vpcs;\n\n  }","id":95324,"modified_method":"/**\n   * Get VPC List based on the ApiKey\n   *\n   * @param apiKey apiKey of the account\n   * @return List of {@code VPC}\n   */\n  @Override\n  public List<VPC> getVPC(String apiKey) {\n\n    checkValidDAO();\n\n    List<VPC> vpcs;\n    try {\n      vpcs = vpcDao.getVPC(apiKey);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return vpcs;\n\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(int accountId) {\n    List<VPC> vpcs;\n    if(vpcDao == null) {\n      throw new RuntimeException(\"Could not initialize data access object\");\n    }\n    try {\n       vpcs = vpcDao.getVPC(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return vpcs;\n  }","id":95325,"modified_method":"@Override\n  public List<VPC> getVPC(int accountId) {\n\n    checkValidDAO();\n    List<VPC> vpcs;\n\n    try {\n      vpcs = vpcDao.getVPC(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return vpcs;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"private DataManagementServiceImpl() {\n    accountDAO = new AccountDBAccess();\n    Map<String,String> config = new HashMap<String,String>();\n    config.put(\"jdbcType\",\"mysql\");\n   // config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n    config.put(\"connectionString\",\"jdbc:mysql://localhost/continuuity?user=passport_user\");\n    accountDAO.configure(config);\n\n    vpcDao = new VpcDBAccess();\n    vpcDao.configure(config);\n  }","id":95326,"modified_method":"@Inject\n  public DataManagementServiceImpl(AccountDAO accountDAO, VpcDAO vpcDAO, NonceDAO nonceDAO) {\n    this.accountDAO = accountDAO;\n    this.vpcDao = vpcDAO;\n    this.nonceDAO = nonceDAO;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public VPC addVPC(int accountId, VPC vpc) throws RuntimeException {\n    if(vpcDao == null) {\n      throw new RuntimeException(\"Could not initialize data access object\");\n    }\n    try {\n     return vpcDao.addVPC(accountId, vpc);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","id":95327,"modified_method":"public VPC addVPC(int accountId, VPC vpc) throws RuntimeException {\n    checkValidDAO();\n    try {\n      return vpcDao.addVPC(accountId, vpc);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Delete an {@code Account} in the system\n   *\n   * @param accountId   account to be deleted\n   * @param credentials credentials of the owner of the account\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public Status deleteAccount(String accountId, Credentials credentials) throws RetryException {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":95328,"modified_method":"/**\n   * Delete an {@code Account} in the system\n   *\n   * @param accountId account to be deleted\n   * @return Instance of {@code Status}\n   * @throws RuntimeException\n   */\n  @Override\n  public void deleteAccount(int accountId) throws RuntimeException, AccountNotFoundException {\n    checkValidDAO();\n\n    try {\n      accountDAO.deleteAccount(accountId);\n    } catch (ConfigurationException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Retrieves authentication data from RDBMS for the given authentication token.\n   * <p/>\n   * For most datasources, this means just 'pulling' authentication data for an associated subject/user and nothing\n   * more and letting Shiro do the rest.  But in some systems, this method could actually perform EIS specific\n   * log-in logic in addition to just retrieving data - it is up to the Realm implementation.\n   * <p/>\n   * A {@code null} return value means that no account could be associated with the specified token.\n   *\n   * @param token the authentication token containing the user's principal and credentials.\n   * @return an {@link org.apache.shiro.authc.AuthenticationInfo} object containing account data resulting from the\n   *         authentication ONLY if the lookup is successful (i.e. account exists and is valid, etc.)\n   * @throws org.apache.shiro.authc.AuthenticationException\n   *          if there is an error acquiring data or performing\n   *          realm-specific authentication logic for the specified <tt>token<\/tt>\n   */\n  @Override\n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    UsernamePasswordApiKeyToken upToken = (UsernamePasswordApiKeyToken) token;\n    String emailId = upToken.getUsername();\n    String apiKey = upToken.getApiKey();\n\n    SimpleAuthenticationInfo info = null;\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n\n      String SQL = null;\n      PreparedStatement ps = null;\n      //Precedence for lookup if emailID is present use that to lookup. Else use apIKey.\n      if (emailId !=null && !emailId.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_EMAIL;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1,emailId);\n\n      }\n      else if (apiKey!=null && ! apiKey.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_APIKEY;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1,apiKey);\n\n      }\n\n      if (ps == null){\n        throw new AuthenticationException(\"ApiKey or emailId should be set.\");\n      }\n\n      ResultSet rs = ps.executeQuery();\n\n      int count = 0;\n      String password = null;\n      int accountId = -1;\n      String firstName = null;\n      String lastName = null;\n      String company = null;\n      String apiToken = null;\n\n      while(rs.next()) {\n        firstName = rs.getString(1);\n        lastName = rs.getString(2);\n        company = rs.getString(3);\n\n        accountId  = rs.getInt(4);\n        password = rs.getString(5);\n        apiToken = rs.getString(6);\n        count++;\n        if(count > 1) {\n          // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n      if (password ==null || password.isEmpty()) {\n        throw new RuntimeException(String.format(\"Password not found for %s\",emailId));\n      }\n\n      Account account = new Account(firstName,lastName,company,emailId,accountId,apiToken);\n      info = new SimpleAuthenticationInfo(account,password,getName());\n\n    } catch (SQLException e) {\n      //TODO: Log and throw exception\n      e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n    }\n    return info;\n  }","id":95329,"modified_method":"/**\n   * Retrieves authentication data from RDBMS for the given authentication token.\n   * <p/>\n   * For most datasources, this means just 'pulling' authentication data for an associated subject/user and nothing\n   * more and letting Shiro do the rest.  But in some systems, this method could actually perform EIS specific\n   * log-in logic in addition to just retrieving data - it is up to the Realm implementation.\n   * <p/>\n   * A {@code null} return value means that no account could be associated with the specified token.\n   *\n   * @param token the authentication token containing the user's principal and credentials.\n   * @return an {@link org.apache.shiro.authc.AuthenticationInfo} object containing account data resulting from the\n   *         authentication ONLY if the lookup is successful (i.e. account exists and is valid, etc.)\n   * @throws org.apache.shiro.authc.AuthenticationException\n   *          if there is an error acquiring data or performing\n   *          realm-specific authentication logic for the specified <tt>token<\/tt>\n   */\n  @Override\n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    UsernamePasswordApiKeyToken upToken = (UsernamePasswordApiKeyToken) token;\n    String emailId = upToken.getUsername();\n    String apiKey = upToken.getApiKey();\n\n    SimpleAuthenticationInfo info = null;\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n\n      String SQL = null;\n      PreparedStatement ps = null;\n      //Precedence for lookup if emailID is present use that to lookup. Else use apIKey.\n      if (emailId != null && !emailId.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_EMAIL;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1, emailId);\n\n      } else if (apiKey != null && !apiKey.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_APIKEY;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1, apiKey);\n\n      }\n\n      if (ps == null) {\n        throw new AuthenticationException(\"ApiKey or emailId should be set.\");\n      }\n\n      ResultSet rs = ps.executeQuery();\n\n      int count = 0;\n      String password = null;\n      int accountId = -1;\n      String firstName = null;\n      String lastName = null;\n      String company = null;\n      String apiToken = null;\n      boolean confirmed = false;\n      while (rs.next()) {\n        firstName = rs.getString(1);\n        lastName = rs.getString(2);\n        company = rs.getString(3);\n\n        accountId = rs.getInt(4);\n        password = rs.getString(5);\n        apiToken = rs.getString(6);\n        confirmed = rs.getBoolean(7);\n        count++;\n        if (count > 1) {\n          // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n      if (password == null || password.isEmpty()) {\n        throw new RuntimeException(String.format(\"Password not found for %s\", emailId));\n      }\n\n      Account account = new Account(firstName, lastName, company, emailId, accountId, apiToken, confirmed);\n      info = new SimpleAuthenticationInfo(account, password, getName());\n\n    } catch (SQLException e) {\n      //TODO: Log and throw exception\n      e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n    }\n    return info;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"private void start() {\n    try{\n      Server server = new Server(port);\n      server.setStopAtShutdown(true);\n      server.setGracefulShutdown(gracefulShutdownTime);\n\n      Context context = new Context(server, \"/\", Context.SESSIONS);\n\n      context.addServlet(new ServletHolder(new ServletContainer(\n        new PackagesResourceConfig(\"com.continuuity.passport.http\"))), \"/*\");\n\n    //  context.addFilter(ContinuuitySecurityFilter.class,\"/passport/v1/*\",0);\n\n        //JMX jetty\n      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n      MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);\n      server.getContainer().addEventListener(mBeanContainer);\n      mBeanContainer.start();\n\n      server.start();\n      server.join();\n\n    }\n    catch(Exception e) {\n      e.printStackTrace();\n    }\n  }","id":95330,"modified_method":"private void start() {\n\n    try {\n\n      Server server = new Server(port);\n      server.setStopAtShutdown(true);\n      server.setGracefulShutdown(gracefulShutdownTime);\n\n\n      Context context = new Context(server, \"/\", Context.SESSIONS);\n      context.addEventListener(new PassportGuiceServletContextListener(configuration));\n      context.addServlet(DefaultServlet.class, \"/\");\n      context.addFilter(GuiceFilter.class, \"/*\", 0);\n\n      //JMX jetty\n      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n      MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);\n      server.getContainer().addEventListener(mBeanContainer);\n      mBeanContainer.start();\n\n      server.start();\n      server.join();\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void main(String [] args) {\n\n    Map<String,String> config = new HashMap<String,String>();\n\n    //TODO: Move this configurations to a central place\n    config.put(\"jdbcType\",\"mysql\");\n    config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n    //config.put(\"connectionString\",\"jdbc:mysql://localhost:3306/continuuity?user=passport_user\");\n\n    Realm realm = new JDBCAuthrozingRealm(config);\n\n    org.apache.shiro.mgt.SecurityManager securityManager = new DefaultSecurityManager(realm);\n    SecurityUtils.setSecurityManager(securityManager);\n\n    PassportHttpServer server = new PassportHttpServer();\n    server.start();\n\n\n  }","id":95331,"modified_method":"public static void main(String[] args) {\n\n    Map<String, String> config = new HashMap<String, String>();\n\n    CConfiguration conf = CConfiguration.create();\n    conf.addResource(\"continuuity-passport.xml\");\n\n    String jdbcType = conf.get(\"passport.jdbc.type\");\n    String connectionString  = conf.get(\"passport.jdbc.connection.string\");\n    System.out.println(jdbcType);\n    int port = Integer.parseInt(conf.get(\"passport.http.server.port\"));\n    int gracefulShutdownTime = Integer.parseInt(conf.get(\"passport.http.graceful.shutdown.time\"));\n\n    config.put(\"jdbcType\", jdbcType);\n    config.put(\"connectionString\",connectionString);\n\n    Realm realm = new JDBCAuthrozingRealm(config);\n\n    org.apache.shiro.mgt.SecurityManager securityManager = new DefaultSecurityManager(realm);\n    SecurityUtils.setSecurityManager(securityManager);\n\n    PassportHttpServer server = new PassportHttpServer(port, config, gracefulShutdownTime);\n    server.start();\n\n\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public VPC(String vpcName) {\n    this(-1,vpcName);\n  }","id":95332,"modified_method":"public VPC(String vpcName, String vpcLabel) {\n    this(-1, vpcName, vpcLabel);\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"public VPC(int vpcId, String vpcName) {\n    this.vpcId = vpcId;\n    this.vpcName = vpcName;\n\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    vpcJson = gson.toJson(this);\n\n  }","id":95333,"modified_method":"public VPC(int vpcId, String vpcName, String vpcLabel) {\n    this.vpcId = vpcId;\n    this.vpcName = vpcName;\n    this.vpcLabel = vpcLabel;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return vpcJson;\n  }","id":95334,"modified_method":"@Override\n  public String toString() {\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    return gson.toJson(this);\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean removeVPC( int vpcId) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n\n      String SQL = String.format( \"DELETE FROM %s WHERE %s = ?\",\n                                  DBUtils.VPC.TABLE_NAME,\n                                  DBUtils.VPC.VPC_ID_COLUMN);\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,vpcId);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return true;\n  }","id":95335,"modified_method":"@Override\n  public void removeVPC(int accountId, int vpcId)\n    throws ConfigurationException, RuntimeException, VPCNotFoundException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n      String SQL = String.format(\"DELETE FROM %s WHERE %s = ? and %s = ?\",\n        DBUtils.VPC.TABLE_NAME,\n        DBUtils.VPC.VPC_ID_COLUMN,\n        DBUtils.VPC.ACCOUNT_ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, vpcId);\n      ps.setInt(2, accountId);\n\n      int count = ps.executeUpdate();\n      if (count == 0) {\n        throw new VPCNotFoundException(\"VPC not found\");\n      }\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(int accountId) throws RuntimeException, ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"SELECT %s, %s FROM %s WHERE %s = ?\",\n                                  DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN, //COLUMNS\n                                  DBUtils.VPC.TABLE_NAME, //FROM\n                                  DBUtils.VPC.ACCOUNT_ID_COLUMN); //WHERE\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setInt(1,accountId);\n      ResultSet rs = ps.executeQuery();\n\n\n      while(rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1),rs.getString(2));\n        vpcList.add(vpc);\n\n      }\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return vpcList;\n  }","id":95336,"modified_method":"@Override\n  public List<VPC> getVPC(int accountId) throws RuntimeException, ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s WHERE %s = ?\",\n        DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n        DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.VPC.ACCOUNT_ID_COLUMN); //WHERE\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1, accountId);\n      rs = ps.executeQuery();\n\n\n      while (rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n        vpcList.add(vpc);\n\n      }\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpcList;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public VPC addVPC(int accountId, VPC vpc) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n\n      String SQL = String.format( \"INSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\",\n                                  DBUtils.VPC.TABLE_NAME,\n                                  DBUtils.VPC.ACCOUNT_ID_COLUMN, DBUtils.VPC.NAME_COLUMN ,\n                                  DBUtils.VPC.VPC_CREATED_AT);\n\n      Date date = new Date();\n      PreparedStatement ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, accountId);\n      ps.setString(2, vpc.getVpcName());\n      ps.setTimestamp(3, new java.sql.Timestamp(date.getTime()));\n\n      ps.executeUpdate();\n\n      ResultSet result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n      return new VPC(result.getInt(1),vpc.getVpcName());\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n  }","id":95337,"modified_method":"@Override\n  public VPC addVPC(int accountId, VPC vpc) throws ConfigurationException, RuntimeException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet result = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n      String SQL = String.format(\"INSERT INTO %s (%s, %s, %s, %s) VALUES (?,?,?,?)\",\n        DBUtils.VPC.TABLE_NAME,\n        DBUtils.VPC.ACCOUNT_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n        DBUtils.VPC.LABEL_COLUMN,\n        DBUtils.VPC.VPC_CREATED_AT);\n\n      Date date = new Date();\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, accountId);\n      ps.setString(2, vpc.getVpcName());\n      ps.setString(3, vpc.getVpcLabel());\n      ps.setTimestamp(4, new java.sql.Timestamp(date.getTime()));\n\n      ps.executeUpdate();\n\n      result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n      return new VPC(result.getInt(1), vpc.getVpcName(), vpc.getVpcLabel());\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, result);\n    }\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(String apiKey) throws RuntimeException, ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"SELECT %s, %s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n                                  DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.VPC_ID_COLUMN,\n                                  DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.NAME_COLUMN, //COLUMNS\n                                  DBUtils.VPC.TABLE_NAME, //FROM\n                                  DBUtils.AccountTable.TABLE_NAME, //JOIN\n                                  DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.ACCOUNT_ID_COLUMN, //CONDITION\n                                  DBUtils.AccountTable.TABLE_NAME+\".\"+DBUtils.AccountTable.ID_COLUMN,\n                                  DBUtils.AccountTable.TABLE_NAME+\".\"+DBUtils.AccountTable.API_KEY_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setString(1,apiKey);\n      ResultSet rs = ps.executeQuery();\n\n      while(rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1),rs.getString(2));\n        vpcList.add(vpc);\n\n      }\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return vpcList;\n  }","id":95338,"modified_method":"@Override\n  public List<VPC> getVPC(String apiKey) throws RuntimeException, ConfigurationException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format(\"SELECT %s, %s, %s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.VPC_ID_COLUMN,\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.NAME_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.AccountTable.TABLE_NAME, //JOIN\n        DBUtils.VPC.TABLE_NAME + \".\" + DBUtils.VPC.ACCOUNT_ID_COLUMN, //CONDITION\n        DBUtils.AccountTable.TABLE_NAME + \".\" + DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME + \".\" + DBUtils.AccountTable.API_KEY_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1, apiKey);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1), rs.getString(2), rs.getString(3));\n        vpcList.add(vpc);\n\n      }\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps, rs);\n    }\n    return vpcList;\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addRoles(int accountId, int vpcId, int userId, Role role, String overrides)\n           throws ConfigurationException, RuntimeException {\n\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n\n\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES (?,?,?,?,?)\",\n                                  DBUtils.VPCRole.TABLE_NAME,\n                                  DBUtils.VPCRole.VPC_ID_COLUMN, DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n                                  DBUtils.VPCRole.USER_ID_COLUMN, DBUtils.VPCRole.ROLE_TYPE_COLUMN,\n                                  DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, vpcId);\n      ps.setInt(2, accountId);\n      ps.setInt(3, userId);\n      ps.setString(4, role.getRoleType());\n      ps.setString(5,overrides);\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":95339,"modified_method":"@Override\n  public boolean addRoles(int accountId, int vpcId, int userId, Role role, String overrides)\n    throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null) {\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n\n      String SQL = String.format(\"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES (?,?,?,?,?)\",\n        DBUtils.VPCRole.TABLE_NAME,\n        DBUtils.VPCRole.VPC_ID_COLUMN, DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n        DBUtils.VPCRole.USER_ID_COLUMN, DBUtils.VPCRole.ROLE_TYPE_COLUMN,\n        DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN);\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, vpcId);\n      ps.setInt(2, accountId);\n      ps.setInt(3, userId);\n      ps.setString(4, role.getRoleType());\n      ps.setString(5, overrides);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    } finally {\n      close(connection, ps);\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"162de509b25083dc02520c73bcaa084f41ded77d","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\r\n     * Checks if a certain file is in a given directory.\r\n     * @param file the file to check\r\n     * @param directory the directory which must contain the file\r\n     * @return true if file is contained in diretory\r\n     */\r\n    public static boolean isInDirectory(final File file, final File directory) throws IOException {\r\n        \r\n        return \r\n                directory != null\r\n                && directory.isDirectory()\r\n                && file != null\r\n                && file.isFile()\r\n                && directory.getCanonicalPath().equalsIgnoreCase(\r\n                        file.getParentFile().getCanonicalPath());\r\n    }","id":95340,"modified_method":"/**\r\n     * Checks if a certain file is in a given directory.\r\n     * @param file the file to check\r\n     * @param directory the directory which must contain the file\r\n     * @return true if file is contained in directory\r\n     */\r\n    public static boolean isInDirectory(final File file, final File directory) {\r\n        \r\n        boolean inDirectory;\r\n        \r\n        try {\r\n            inDirectory = (\r\n                    directory != null\r\n                    && directory.isDirectory()\r\n                    && file != null\r\n                    && file.isFile()\r\n                    && directory.getCanonicalPath().equalsIgnoreCase(\r\n                            file.getParentFile().getCanonicalPath()));\r\n        } catch (IOException e) {\r\n            inDirectory = false;\r\n        }\r\n        \r\n        return inDirectory;\r\n    }","commit_id":"75f95684725403fa9376cf345aa804920f454a61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch ss) {\r\n        if (post == null || ss == null) { return new serverObjects(); }\r\n\r\n        final Switchboard sb = (Switchboard) ss;\r\n        final serverObjects prop = new serverObjects();\r\n        prop.put(\"info\", \"0\"); //no information submitted\r\n\r\n        final String requestIP = post.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, Domains.LOCALHOST);\r\n\r\n        // handle access rights\r\n        if (!sb.verifyAuthentication(header)) {\r\n            Log.logInfo(\"STEERING\", \"log-in attempt for steering from \" + requestIP);\r\n        \tprop.authenticationRequired();\r\n            return prop;\r\n        }\r\n\r\n        if (post.containsKey(\"shutdown\")) {\r\n            Log.logInfo(\"STEERING\", \"shutdown request from \" + requestIP);\r\n            sb.terminate(10, \"shutdown request from Steering; ip = \" + requestIP);\r\n            prop.put(\"info\", \"3\");\r\n\r\n            return prop;\r\n        }\r\n\r\n        if (post.containsKey(\"restart\")) {\r\n            Log.logInfo(\"STEERING\", \"restart request from \" + requestIP);\r\n            yacyRelease.restart();\r\n            prop.put(\"info\", \"4\");\r\n\r\n            return prop;\r\n        }\r\n\r\n        if (post.containsKey(\"update\")) {\r\n            Log.logInfo(\"STEERING\", \"update request from \" + requestIP);\r\n            final boolean devenvironment = new File(sb.getAppPath(), \".git\").exists();\r\n            final String releaseFileName = post.get(\"releaseinstall\", \"\");\r\n            final File releaseFile = new File(sb.getDataPath(), \"DATA/RELEASE/\".replace(\"/\", File.separator) + releaseFileName);\r\n            if ((!devenvironment) && (releaseFileName.length() > 0) && (releaseFile.exists())) {\r\n                yacyRelease.deployRelease(releaseFile);\r\n            }\r\n            prop.put(\"info\", \"5\");\r\n            prop.putHTML(\"info_release\", releaseFileName);\r\n\r\n            return prop;\r\n        }\r\n        return prop;\r\n    }","id":95341,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch ss) {\r\n        if (post == null || ss == null) { return new serverObjects(); }\r\n\r\n        final Switchboard sb = (Switchboard) ss;\r\n        final serverObjects prop = new serverObjects();\r\n        prop.put(\"info\", \"0\"); //no information submitted\r\n\r\n        final String requestIP = post.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, Domains.LOCALHOST);\r\n\r\n        // handle access rights\r\n        if (!sb.verifyAuthentication(header)) {\r\n            Log.logInfo(\"STEERING\", \"log-in attempt for steering from \" + requestIP);\r\n        \tprop.authenticationRequired();\r\n            return prop;\r\n        }\r\n\r\n        if (post.containsKey(\"shutdown\")) {\r\n            Log.logInfo(\"STEERING\", \"shutdown request from \" + requestIP);\r\n            sb.terminate(10, \"shutdown request from Steering; ip = \" + requestIP);\r\n            prop.put(\"info\", \"3\");\r\n\r\n            return prop;\r\n        }\r\n\r\n        if (post.containsKey(\"restart\")) {\r\n            Log.logInfo(\"STEERING\", \"restart request from \" + requestIP);\r\n            yacyRelease.restart();\r\n            prop.put(\"info\", \"4\");\r\n\r\n            return prop;\r\n        }\r\n\r\n        if (post.containsKey(\"update\")) {\r\n            Log.logInfo(\"STEERING\", \"update request from \" + requestIP);\r\n            final boolean devenvironment = new File(sb.getAppPath(), \".git\").exists();\r\n            final String releaseFileName = post.get(\"releaseinstall\", \"\");\r\n            final File releaseFile = new File(sb.releasePath, releaseFileName);\r\n            if (FileUtils.isInDirectory(releaseFile, sb.releasePath)) {\r\n                if ((!devenvironment) && (releaseFileName.length() > 0) && (releaseFile.exists())) {\r\n                    yacyRelease.deployRelease(releaseFile);\r\n                }\r\n                prop.put(\"info\", \"5\");\r\n                prop.putHTML(\"info_release\", releaseFileName);\r\n            } else {\r\n                prop.put(\"info\", \"6\");\r\n            }\r\n\r\n            return prop;\r\n        }\r\n        return prop;\r\n    }","commit_id":"75f95684725403fa9376cf345aa804920f454a61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n\t * Construct a proper key value for the cache\n\t * \n\t * @param container\n\t *            The container requesting the markup\n\t * @param clazz\n\t *            The clazz to get the key for\n\t * @return Key that uniquely identifies any markup that might be associated with this markup\n\t *         container.\n\t */\n\t@Override\n\tpublic String getCacheKey(final MarkupContainer container, final Class<?> clazz)\n\t{\n\t\tfinal String classname = clazz.getName();\n\t\tfinal StringBuilder buffer = new StringBuilder(classname.length() + 64);\n\t\tbuffer.append(classname);\n\n\t\tif (container.getVariation() != null)\n\t\t{\n\t\t\tbuffer.append('_').append(container.getVariation());\n\t\t}\n\n\t\tif (container.getStyle() != null)\n\t\t{\n\t\t\tbuffer.append('_').append(container.getStyle());\n\t\t}\n\n\t\tfinal Locale locale = container.getLocale();\n\t\tif (locale != null)\n\t\t{\n\t\t\tbuffer.append('_').append(locale.getLanguage());\n\n\t\t\tfinal boolean hasLocale = locale.getLanguage().length() != 0;\n\t\t\tfinal boolean hasCountry = locale.getCountry().length() != 0;\n\t\t\tfinal boolean hasVariant = locale.getVariant().length() != 0;\n\n\t\t\tif (hasCountry || (hasLocale && hasVariant))\n\t\t\t{\n\t\t\t\tbuffer.append('_').append(locale.getCountry());\n\t\t\t}\n\t\t\tif (hasVariant && (hasLocale || hasCountry))\n\t\t\t{\n\t\t\t\tbuffer.append('_').append(locale.getVariant());\n\t\t\t}\n\t\t}\n\n\t\tbuffer.append('.').append(container.getMarkupType().getExtension());\n\t\treturn buffer.toString();\n\t}","id":95342,"modified_method":"/**\n\t * Construct a proper key value for the cache\n\t * \n\t * @param container\n\t *            The container requesting the markup\n\t * @param clazz\n\t *            The clazz to get the key for\n\t * @return Key that uniquely identifies any markup that might be associated with this markup\n\t *         container.\n\t */\n\t@Override\n\tpublic String getCacheKey(final MarkupContainer container, final Class<?> clazz)\n\t{\n\t\tfinal String classname = clazz.getName();\n\t\tfinal StringBuilder buffer = new StringBuilder(classname.length() + 64);\n\t\tbuffer.append(classname);\n\n\t\tfinal String variation = container.getVariation();\n\t\tif (variation != null)\n\t\t{\n\t\t\tbuffer.append('_').append(variation);\n\t\t}\n\n\t\tfinal String style = container.getStyle();\n\t\tif (style != null)\n\t\t{\n\t\t\tbuffer.append('_').append(style);\n\t\t}\n\n\t\tfinal Locale locale = container.getLocale();\n\t\tif (locale != null)\n\t\t{\n\t\t\tbuffer.append('_').append(locale.toString());\n\t\t}\n\n\t\tbuffer.append('.').append(container.getMarkupType().getExtension());\n\t\treturn buffer.toString();\n\t}","commit_id":"831b11ccc0c0990bdb50661077341008a28eefa4","url":"https://github.com/apache/wicket"},{"original_method":"public LWComponent createLWComponent(Object type)\n    {\n        if(typeCache.containsKey(type))\n        {\n            return (LWComponent)typeCache.get(type);\n        }    \n        LWComponent compFor = null;\n        OntType ontType = null;\n        if(type instanceof OntType)\n        {\n          ontType = (OntType)type;\n          if(ontType !=null)\n            if(isNode(ontType))  \n            {\n              compFor = new LWNode(ontType.getLabel());\n            }\n            else\n            {\n              LWLink r = new LWLink();\n              r.setHeadPoint(20,20);\n              r.setTailPoint(80,30);\n              r.setLabel(ontType.getLabel());\n              compFor = r;\n            }\n          else\n            compFor = new LWNode(\"null ont type\");\n        }\n        else\n        {\n          compFor = new LWNode(\"error\");    \n        }\n        \n        \n        //$\n        if(ontType.getStyle()!=null)\n            compFor.applyCSS(ontType.getStyle());\n        //$\n        \n        LWComponent noLabel = compFor.duplicate();\n        noLabel.setLabel(\"\");\n        typeNoLabelCache.put(type,noLabel);\n        typeCache.put(type,compFor);\n        \n        return compFor;\n    }","id":95343,"modified_method":"public LWComponent createLWComponent(Object type)\n    {\n        if(typeCache.containsKey(type))\n        {\n            return (LWComponent)typeCache.get(type);\n        }\n      \n        LWComponent compFor = null;\n        OntType ontType = null;\n        if(type instanceof OntType)\n        {\n          ontType = (OntType)type;\n          if(ontType !=null)\n          {\n            Style style = ontType.getStyle();\n            if(isNode(ontType))  \n            {\n              String image = style.getAttribute(\"background-image\");\n              if(image != null)\n              {\n                 System.out.println(\"TypeList: image not null\");\n                 java.net.URL imageURL = null;\n                 URLResource resource = null;\n                 java.io.File file = null;\n                 try\n                 {\n                    file = new java.io.File(image);\n                    imageURL = file.toURL();//new URL(image);\n                    resource = new URLResource(imageURL);\n                 }\n                 catch(java.net.MalformedURLException mue)\n                 {\n                    System.out.println(\"TypeList: MalformedURLException: \" + mue);    \n                 }\n                 if(resource!=null)\n                 {    \n                   compFor = new LWImage();\n                   compFor.setResource(resource);\n                 }\n                 else\n                 {\n                     compFor = new LWNode(ontType.getLabel());\n                 }\n              }\n              else\n                compFor = new LWNode(ontType.getLabel());\n            }\n            else\n            {\n              LWLink r = new LWLink();\n              r.setHeadPoint(20,20);\n              r.setTailPoint(80,30);\n              r.setLabel(ontType.getLabel());\n              compFor = r;\n            }\n            compFor.applyCSS(style);\n          }\n          else\n            compFor = new LWNode(\"null ont type\");\n        }\n        else\n        {\n          compFor = new LWNode(\"error\");    \n        }\n        \n        \n        //put within condition check for non-null ontType above\n        //if(ontType.getStyle()!=null)\n        //    compFor.applyCSS(ontType.getStyle());\n        \n        //needed \n        //LWComponent noLabel = compFor.duplicate();\n        //noLabel.setLabel(\"\");\n        //typeNoLabelCache.put(type,noLabel);\n        \n        //blocking reload of style, need to account for \n        //new style before reenabling\n        //typeCache.put(type,compFor);\n        \n        return compFor;\n    }","commit_id":"0d1304f60b86d74d21bb0a1249d4385551ce5bd0","url":"https://github.com/VUE/VUE"},{"original_method":"public void paintComponent(java.awt.Graphics g)\n        {\n            //tufts.vue.DrawContext dc = new tufts.vue.DrawContext(g);\n           // comp.draw(dc);\n            java.awt.Color old = g.getColor();\n            g.setColor(getBackground());\n            g.fillRect(0,0,getWidth(),getHeight());\n            g.setColor(old);\n            if(!isNode(type))\n            {\n              Style style = type.getStyle();\n                  \n              float strokeWidth = 1.0f;     \n              if(style!= null && style.getAttribute(\"stroke-width\") != null)\n                strokeWidth = edu.tufts.vue.style.ShorthandParser.parseSize(style.getAttribute(\"stroke-width\"));\n                //strokeWidth = Float.parseFloat(style.getAttribute(\"stroke-width\"));\n              //System.out.println(\"typelist: stroke width: \" + strokeWidth);\n              //if(strokeWidth <= 1.1f)\n              //{\n               g.drawLine(10,20,40,20);\n              /*}\n              else\n              {\n               g.fillRect(10,20,30,(int)(strokeWidth));\n               for(int i=0;i<ypoints.length;i++)\n               {\n                  ypoints[i] += (int)((strokeWidth+1)/2 );\n               }\n              }*/\n              \n               \n               g.fillPolygon(xpoints,ypoints,numpoints);\n            }\n            else\n            {\n              old = g.getColor();\n              Style style = type.getStyle();\n              java.awt.Color fillColor = tufts.vue.VueResources.getColor(\"node.fillColor\");\n              if(style!=null)\n              {\n                String fillColorString = style.getAttribute(\"background\");\n                if(fillColorString!=null)\n                {\n                    try\n                    {        \n                      fillColor =  java.awt.Color.decode(fillColorString);\n                    }\n                    catch(NumberFormatException nfe)\n                    {\n                        System.out.println(\"TypeList: NumberFormatException \" + nfe);\n                    }\n                }\n              }\n              g.setColor(fillColor);  \n              //g.fillRoundRect(10,15,30,25,5,5);\n              g.fillRoundRect(10,8,30,20,5,5);\n              g.setColor(old);\n            }\n            if(type.getLabel()!=null);\n              //g.drawString(type.getLabel(),60,20);\n              g.drawString(type.getLabel(),60,18 - 2 +g.getFontMetrics().getHeight()/2);\n              //g.drawString(type.getLabel(),60,18-g.getFontMetrics().getAscent()/2);\n              //g.drawString(type.getLabel(),60,18);\n              //g.drawString(comp.getLabel(),40,10);\n              \n                Style s = type.getStyle();\n                if(s!=null)\n                {\n                  String icon = s.getAttribute(\"background-image\");\n                  //System.out.println(\"icon \" + icon);\n                  if(icon != null)\n                  {\n                    javax.swing.ImageIcon ii = new javax.swing.ImageIcon(icon);\n                    //System.out.println(\"image icon: \" + ii);\n                    //p.add(new JLabel(ii));\n                    //g.drawImage(ii.getImage(),200,10,40,40,null);\n                    g.drawImage(ii.getImage(),200,5,26,26,null);\n                  }\n                }\n        }","id":95344,"modified_method":"public void paintComponent(java.awt.Graphics g)\n        {\n            //tufts.vue.DrawContext dc = new tufts.vue.DrawContext(g);\n           // comp.draw(dc);\n            java.awt.Color old = g.getColor();\n            g.setColor(getBackground());\n            g.fillRect(0,0,getWidth(),getHeight());\n            g.setColor(old);\n            if(!isNode(type))\n            {\n                \n              //Style style = type.getStyle();\n                  \n              //float strokeWidth = 1.0f;     \n              //if(style!= null && style.getAttribute(\"stroke-width\") != null)\n              //  strokeWidth = edu.tufts.vue.style.ShorthandParser.parseSize(style.getAttribute(\"stroke-width\"));\n                //strokeWidth = Float.parseFloat(style.getAttribute(\"stroke-width\"));\n              //System.out.println(\"typelist: stroke width: \" + strokeWidth);\n              //if(strokeWidth <= 1.1f)\n              //{\n               g.drawLine(10,20,40,20);\n              /*}\n              else\n              {\n               g.fillRect(10,20,30,(int)(strokeWidth));\n               for(int i=0;i<ypoints.length;i++)\n               {\n                  ypoints[i] += (int)((strokeWidth+1)/2 );\n               }\n              }*/\n              \n               \n               g.fillPolygon(xpoints,ypoints,numpoints);\n            }\n            else\n            {\n              old = g.getColor();\n              Style style = type.getStyle();\n              java.awt.Color fillColor = tufts.vue.VueResources.getColor(\"node.fillColor\");\n              if(style!=null)\n              {\n                String fillColorString = style.getAttribute(\"background\");\n                if(fillColorString!=null)\n                {\n                    try\n                    {        \n                      fillColor =  java.awt.Color.decode(fillColorString);\n                    }\n                    catch(NumberFormatException nfe)\n                    {\n                        System.out.println(\"TypeList: NumberFormatException \" + nfe);\n                    }\n                }\n              }\n              g.setColor(fillColor);  \n              //g.fillRoundRect(10,15,30,25,5,5);\n              g.fillRoundRect(10,8,30,20,5,5);\n              g.setColor(old);\n            }\n            if(type.getLabel()!=null);\n              //g.drawString(type.getLabel(),60,20);\n              g.drawString(type.getLabel(),60,18 - 2 +g.getFontMetrics().getHeight()/2);\n              //g.drawString(type.getLabel(),60,18-g.getFontMetrics().getAscent()/2);\n              //g.drawString(type.getLabel(),60,18);\n              //g.drawString(comp.getLabel(),40,10);\n              \n                Style s = type.getStyle();\n                if(s!=null)\n                {\n                  String icon = s.getAttribute(\"background-image\");\n                  //System.out.println(\"icon \" + icon);\n                  if(icon != null)\n                  {\n                    javax.swing.ImageIcon ii = new javax.swing.ImageIcon(icon);\n                    //System.out.println(\"image icon: \" + ii);\n                    //p.add(new JLabel(ii));\n                    //g.drawImage(ii.getImage(),200,10,40,40,null);\n                    g.drawImage(ii.getImage(),200,5,26,26,null);\n                  }\n                }\n        }","commit_id":"0d1304f60b86d74d21bb0a1249d4385551ce5bd0","url":"https://github.com/VUE/VUE"},{"original_method":"protected BindingInfo createBindingInfo() {\n        BindingFactoryManager mgr = bus.getExtension(BindingFactoryManager.class);\n        String binding = bindingId;\n        \n        if (binding == null && bindingConfig != null) {\n            binding = bindingConfig.getBindingId();\n        }\n        \n        if (binding == null) {\n            // default to soap binding\n            binding = \"http://schemas.xmlsoap.org/soap/\";\n        }\n        \n        try {\n            if (binding.contains(\"/soap\")) {\n                if (bindingConfig == null) {\n                    bindingConfig = new SoapBindingConfiguration();\n                }\n                if (bindingConfig instanceof SoapBindingConfiguration\n                    && !((SoapBindingConfiguration)bindingConfig).isSetStyle()) {\n                    ((SoapBindingConfiguration)bindingConfig).setStyle(serviceFactory.getStyle());\n                }\n            }\n\n            bindingFactory = mgr.getBindingFactory(binding);\n            \n            BindingInfo inf = bindingFactory.createBindingInfo(serviceFactory.getService(),\n                                                    binding, bindingConfig);\n            \n            for (BindingOperationInfo boi : inf.getOperations()) {\n                serviceFactory.updateBindingOperation(boi);\n            }\n            return inf;\n        } catch (BusException ex) {\n            throw new ServiceConstructionException(\n                   new Message(\"COULD.NOT.RESOLVE.BINDING\", LOG, bindingId), ex);\n        }\n    }","id":95345,"modified_method":"protected BindingInfo createBindingInfo() {\n        BindingFactoryManager mgr = bus.getExtension(BindingFactoryManager.class);\n        String binding = bindingId;\n        \n        if (binding == null && bindingConfig != null) {\n            binding = bindingConfig.getBindingId();\n        }\n        \n        if (binding == null) {\n            // default to soap binding\n            binding = \"http://schemas.xmlsoap.org/soap/\";\n        }\n        \n        try {\n            if (binding.contains(\"/soap\")) {\n                if (bindingConfig == null) {\n                    bindingConfig = createSoapBindingConfig();\n                }\n                if (bindingConfig instanceof SoapBindingConfiguration\n                    && !((SoapBindingConfiguration)bindingConfig).isSetStyle()) {\n                    ((SoapBindingConfiguration)bindingConfig).setStyle(serviceFactory.getStyle());\n                }\n            }\n\n            bindingFactory = mgr.getBindingFactory(binding);\n            \n            BindingInfo inf = bindingFactory.createBindingInfo(serviceFactory.getService(),\n                                                    binding, bindingConfig);\n            \n            for (BindingOperationInfo boi : inf.getOperations()) {\n                serviceFactory.updateBindingOperation(boi);\n            }\n            return inf;\n        } catch (BusException ex) {\n            throw new ServiceConstructionException(\n                   new Message(\"COULD.NOT.RESOLVE.BINDING\", LOG, bindingId), ex);\n        }\n    }","commit_id":"15c14870901b12cc8f7572c256ab2ca7798e04bd","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public Boolean isRPC(Method method) {\n        SOAPBinding ann = implInfo.getEndpointClass().getAnnotation(SOAPBinding.class);\n        if (ann != null) {\n            return ann.style().equals(SOAPBinding.Style.RPC);\n        }\n        return super.isRPC(method);\n    }","id":95346,"modified_method":"@Override\n    public Boolean isRPC(Method method) {\n        SOAPBinding ann = method.getAnnotation(SOAPBinding.class);\n        if (ann != null) {\n            return ann.style().equals(SOAPBinding.Style.RPC);\n        }\n        ann = implInfo.getEndpointClass().getAnnotation(SOAPBinding.class);\n        if (ann != null) {\n            return ann.style().equals(SOAPBinding.Style.RPC);\n        }\n        return super.isRPC(method);\n    }","commit_id":"15c14870901b12cc8f7572c256ab2ca7798e04bd","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(Message message) {\n        if (isGET(message)) {\n            LOG.info(\"RPCInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n\n        BindingOperationInfo operation = null;\n        if (!StaxUtils.toNextElement(xmlReader)) {\n            message.setContent(Exception.class, new RuntimeException(\"There must be a method name element.\"));\n        }\n        String opName = xmlReader.getLocalName();\n        if (isRequestor(message) && opName.endsWith(\"Response\")) {\n            opName = opName.substring(0, opName.length() - 8);\n        }\n\n        if (message.getExchange().get(BindingOperationInfo.class) == null) {\n            operation = getOperation(message, new QName(xmlReader.getNamespaceURI(), opName));\n            if (operation == null) {\n                // it's doc-lit-bare\n                new BareInInterceptor().handleMessage(message);\n                return;\n            } else {\n                setMessage(message, operation);\n            }\n        } else {\n            operation = message.getExchange().get(BindingOperationInfo.class);\n        }\n        MessageInfo msg;\n        DataReader<XMLStreamReader> dr = getDataReader(message, XMLStreamReader.class);\n\n        if (!isRequestor(message)) {\n            msg = operation.getOperationInfo().getInput();\n        } else {\n            msg = operation.getOperationInfo().getOutput();\n        }\n        message.put(MessageInfo.class, msg);\n        \n        MessageContentsList parameters = new MessageContentsList();\n\n        StaxUtils.nextEvent(xmlReader);\n        \n        boolean hasNext = true;\n        Iterator<MessagePartInfo> itr = msg.getMessageParts().iterator();\n        while (itr.hasNext()) {\n            MessagePartInfo part = itr.next();\n            if (hasNext) {\n                hasNext = StaxUtils.toNextElement(xmlReader);\n            }\n\n            if (hasNext) {\n                QName qn = xmlReader.getName();\n                if (qn.equals(SOAP12_RESULT)) {\n                    //just ignore this.   The parts should work correctly.\n                    try {\n                        while (xmlReader.getEventType() != XMLStreamReader.END_ELEMENT) {\n                            xmlReader.next();\n                        }\n                        xmlReader.next();\n                    } catch (XMLStreamException e) {\n                        //ignore\n                    }\n                    StaxUtils.toNextElement(xmlReader);\n                    qn = xmlReader.getName();\n                }\n                \n                \n                // WSI-BP states that RPC/Lit part accessors should be completely unqualified\n                // However, older toolkits (Axis 1.x) are qualifying them.   We'll go\n                // ahead and just match on the localpart.   The RPCOutInterceptor\n                // will always generate WSI-BP compliant messages so it's unknown if\n                // the non-WSI-BP toolkits will be able to understand the CXF\n                // generated messages if they are expecting it to be qualified.\n                Iterator<MessagePartInfo> partItr = msg.getMessageParts().iterator();\n                while (!qn.getLocalPart().equals(part.getConcreteName().getLocalPart())\n                    && partItr.hasNext()) {\n                    part = partItr.next();\n                }\n                \n                if (!qn.equals(part.getConcreteName())) {\n                    throw new Fault(\n                                    new org.apache.cxf.common.i18n.Message(\n                                                                           \"UNKNOWN_RPC_LIT_PART\",\n                                                                           LOG,\n                                                                           qn));\n                }\n                //honor JAXBAnnotation\n                part.setProperty(\"honor.jaxb.annotations\", true);\n                try {\n                    parameters.put(part, dr.read(part, xmlReader));\n                } catch (Fault f) {\n                    if (!isRequestor(message)) {\n                        f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n                    }\n                    throw f;\n                }\n            }\n        }\n\n        message.setContent(List.class, parameters);\n    }","id":95347,"modified_method":"public void handleMessage(Message message) {\n        if (isGET(message)) {\n            LOG.fine(\"RPCInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n\n        BindingOperationInfo operation = null;\n        if (!StaxUtils.toNextElement(xmlReader)) {\n            message.setContent(Exception.class, new RuntimeException(\"There must be a method name element.\"));\n        }\n        String opName = xmlReader.getLocalName();\n        if (isRequestor(message) && opName.endsWith(\"Response\")) {\n            opName = opName.substring(0, opName.length() - 8);\n        }\n\n        if (message.getExchange().get(BindingOperationInfo.class) == null) {\n            operation = getOperation(message, new QName(xmlReader.getNamespaceURI(), opName));\n            if (operation == null) {\n                // it's doc-lit-bare\n                new BareInInterceptor().handleMessage(message);\n                return;\n            } else {\n                setMessage(message, operation);\n            }\n        } else {\n            operation = message.getExchange().get(BindingOperationInfo.class);\n        }\n        MessageInfo msg;\n        DataReader<XMLStreamReader> dr = getDataReader(message, XMLStreamReader.class);\n\n        if (!isRequestor(message)) {\n            msg = operation.getOperationInfo().getInput();\n        } else {\n            msg = operation.getOperationInfo().getOutput();\n        }\n        message.put(MessageInfo.class, msg);\n        \n        MessageContentsList parameters = new MessageContentsList();\n\n        StaxUtils.nextEvent(xmlReader);\n        \n        boolean hasNext = true;\n        Iterator<MessagePartInfo> itr = msg.getMessageParts().iterator();\n        while (itr.hasNext()) {\n            MessagePartInfo part = itr.next();\n            if (hasNext) {\n                hasNext = StaxUtils.toNextElement(xmlReader);\n            }\n\n            if (hasNext) {\n                QName qn = xmlReader.getName();\n                if (qn.equals(SOAP12_RESULT)) {\n                    //just ignore this.   The parts should work correctly.\n                    try {\n                        while (xmlReader.getEventType() != XMLStreamReader.END_ELEMENT) {\n                            xmlReader.next();\n                        }\n                        xmlReader.next();\n                    } catch (XMLStreamException e) {\n                        //ignore\n                    }\n                    StaxUtils.toNextElement(xmlReader);\n                    qn = xmlReader.getName();\n                }\n                \n                \n                // WSI-BP states that RPC/Lit part accessors should be completely unqualified\n                // However, older toolkits (Axis 1.x) are qualifying them.   We'll go\n                // ahead and just match on the localpart.   The RPCOutInterceptor\n                // will always generate WSI-BP compliant messages so it's unknown if\n                // the non-WSI-BP toolkits will be able to understand the CXF\n                // generated messages if they are expecting it to be qualified.\n                Iterator<MessagePartInfo> partItr = msg.getMessageParts().iterator();\n                while (!qn.getLocalPart().equals(part.getConcreteName().getLocalPart())\n                    && partItr.hasNext()) {\n                    part = partItr.next();\n                }\n                \n                if (!qn.equals(part.getConcreteName())) {\n                    throw new Fault(\n                                    new org.apache.cxf.common.i18n.Message(\n                                                                           \"UNKNOWN_RPC_LIT_PART\",\n                                                                           LOG,\n                                                                           qn));\n                }\n                //honor JAXBAnnotation\n                part.setProperty(\"honor.jaxb.annotations\", true);\n                try {\n                    parameters.put(part, dr.read(part, xmlReader));\n                } catch (Fault f) {\n                    if (!isRequestor(message)) {\n                        f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n                    }\n                    throw f;\n                }\n            }\n        }\n\n        message.setContent(List.class, parameters);\n    }","commit_id":"15c14870901b12cc8f7572c256ab2ca7798e04bd","url":"https://github.com/apache/cxf"},{"original_method":"public Binding createBinding(BindingInfo binding) {\n        // TODO what about the mix style/use?\n\n        // The default style should be doc-lit wrapped.\n        String parameterStyle = SoapBindingConstants.PARAMETER_STYLE_WRAPPED;\n        String bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n\n        boolean hasWrapped = false;\n        \n        org.apache.cxf.binding.soap.SoapBinding sb = null;\n        SoapVersion version = null;\n        if (binding instanceof SoapBindingInfo) {\n            SoapBindingInfo sbi = (SoapBindingInfo) binding;\n            version = sbi.getSoapVersion();\n            sb = new org.apache.cxf.binding.soap.SoapBinding(binding, version);\n            // Service wide style\n            if (!StringUtils.isEmpty(sbi.getStyle())) {\n                bindingStyle = sbi.getStyle();\n            }\n\n            // Operation wide style, what to do with the mixed style/use?\n            for (BindingOperationInfo boi : sbi.getOperations()) {\n                if (sbi.getStyle(boi.getOperationInfo()) != null) {\n                    bindingStyle = sbi.getStyle(boi.getOperationInfo());\n                }\n                if (boi.getUnwrappedOperation() == null) {\n                    parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                } else {\n                    hasWrapped = true;\n                }\n            }\n        } else {\n            throw new RuntimeException(\"Can not initialize SoapBinding, BindingInfo is not SoapBindingInfo\");\n        }\n\n        sb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n        //Do not add any interceptors if it is Provider/Dispatch\n        if (!Boolean.TRUE.equals(binding.getProperty(DATABINDING_DISABLED))) {\n            sb.getInInterceptors().add(new AttachmentInInterceptor());\n            sb.getInInterceptors().add(new StaxInInterceptor());\n            sb.getInInterceptors().add(new SoapActionInInterceptor());\n            \n            sb.getOutInterceptors().add(new AttachmentOutInterceptor());\n            sb.getOutInterceptors().add(new StaxOutInterceptor());\n            sb.getOutInterceptors().add(new SoapHeaderOutFilterInterceptor());\n\n            if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(bindingStyle)) {\n                sb.getInInterceptors().add(new RPCInInterceptor());\n                sb.getOutInterceptors().add(new RPCOutInterceptor());\n            } else if (SoapBindingConstants.BINDING_STYLE_DOC.equalsIgnoreCase(bindingStyle)\n                            && SoapBindingConstants.PARAMETER_STYLE_BARE.equalsIgnoreCase(parameterStyle)) {\n                //sb.getInInterceptors().add(new BareInInterceptor());\n                sb.getInInterceptors().add(new DocLiteralInInterceptor());\n                if (hasWrapped) {\n                    sb.getOutInterceptors().add(new WrappedOutInterceptor());                    \n                }\n                sb.getOutInterceptors().add(new BareOutInterceptor());\n            } else {\n                //sb.getInInterceptors().add(new WrappedInInterceptor());\n                sb.getInInterceptors().add(new DocLiteralInInterceptor());\n                sb.getOutInterceptors().add(new WrappedOutInterceptor());\n                sb.getOutInterceptors().add(new BareOutInterceptor());\n            }\n            sb.getInInterceptors().add(new SoapHeaderInterceptor());\n\n            sb.getInInterceptors().add(new ReadHeadersInterceptor(getBus()));\n            sb.getInInterceptors().add(new CheckFaultInterceptor());\n            sb.getInInterceptors().add(new MustUnderstandInterceptor());\n            sb.getOutInterceptors().add(new SoapPreProtocolOutInterceptor());\n            sb.getOutInterceptors().add(new SoapOutInterceptor(getBus()));\n            sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n            // REVISIT: The phase interceptor chain seems to freak out if this added\n            // first. Not sure what the deal is at the moment, I suspect the\n            // ordering algorithm needs to be improved\n            sb.getInInterceptors().add(new URIMappingInterceptor());\n        }\n\n        if (version.getVersion() == 1.1) {\n            sb.getInFaultInterceptors().add(new Soap11FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap11FaultOutInterceptor());\n        } else if (version.getVersion() == 1.2) {\n            sb.getInFaultInterceptors().add(new Soap12FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap12FaultOutInterceptor());\n        }\n\n        return sb;\n    }","id":95348,"modified_method":"public Binding createBinding(BindingInfo binding) {\n        // TODO what about the mix style/use?\n\n        // The default style should be doc-lit wrapped.\n        String parameterStyle = SoapBindingConstants.PARAMETER_STYLE_WRAPPED;\n        String bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n\n        boolean hasWrapped = false;\n        \n        org.apache.cxf.binding.soap.SoapBinding sb = null;\n        SoapVersion version = null;\n        if (binding instanceof SoapBindingInfo) {\n            SoapBindingInfo sbi = (SoapBindingInfo) binding;\n            version = sbi.getSoapVersion();\n            sb = new org.apache.cxf.binding.soap.SoapBinding(binding, version);\n            // Service wide style\n            if (!StringUtils.isEmpty(sbi.getStyle())) {\n                bindingStyle = sbi.getStyle();\n            }\n\n            boolean hasRPC = false;\n            boolean hasDoc = false;\n            \n            // Operation wide style, what to do with the mixed style/use?\n            for (BindingOperationInfo boi : sbi.getOperations()) {\n                String st = sbi.getStyle(boi.getOperationInfo());\n                if (st != null) {\n                    bindingStyle = st;\n                    if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(st)) {\n                        hasRPC = true;\n                    } else {\n                        hasDoc = true;\n                    }\n                }\n                if (boi.getUnwrappedOperation() == null) {\n                    parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                } else {\n                    hasWrapped = true;\n                }\n            }\n            if (hasRPC && hasDoc) {\n                throw new RuntimeException(\"WSI-BP prohibits RPC and Document style \"\n                                           + \"operations in same service.\");\n            }\n        } else {\n            throw new RuntimeException(\"Can not initialize SoapBinding, BindingInfo is not SoapBindingInfo\");\n        }\n\n        sb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n        //Do not add any interceptors if it is Provider/Dispatch\n        if (!Boolean.TRUE.equals(binding.getProperty(DATABINDING_DISABLED))) {\n            sb.getInInterceptors().add(new AttachmentInInterceptor());\n            sb.getInInterceptors().add(new StaxInInterceptor());\n            sb.getInInterceptors().add(new SoapActionInInterceptor());\n            \n            sb.getOutInterceptors().add(new AttachmentOutInterceptor());\n            sb.getOutInterceptors().add(new StaxOutInterceptor());\n            sb.getOutInterceptors().add(new SoapHeaderOutFilterInterceptor());\n\n            if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(bindingStyle)) {\n                sb.getInInterceptors().add(new RPCInInterceptor());\n                sb.getOutInterceptors().add(new RPCOutInterceptor());\n            } else if (SoapBindingConstants.BINDING_STYLE_DOC.equalsIgnoreCase(bindingStyle)\n                            && SoapBindingConstants.PARAMETER_STYLE_BARE.equalsIgnoreCase(parameterStyle)) {\n                //sb.getInInterceptors().add(new BareInInterceptor());\n                sb.getInInterceptors().add(new DocLiteralInInterceptor());\n                if (hasWrapped) {\n                    sb.getOutInterceptors().add(new WrappedOutInterceptor());                    \n                }\n                sb.getOutInterceptors().add(new BareOutInterceptor());\n            } else {\n                //sb.getInInterceptors().add(new WrappedInInterceptor());\n                sb.getInInterceptors().add(new DocLiteralInInterceptor());\n                sb.getOutInterceptors().add(new WrappedOutInterceptor());\n                sb.getOutInterceptors().add(new BareOutInterceptor());\n            }\n            sb.getInInterceptors().add(new SoapHeaderInterceptor());\n\n            sb.getInInterceptors().add(new ReadHeadersInterceptor(getBus()));\n            sb.getInInterceptors().add(new CheckFaultInterceptor());\n            sb.getInInterceptors().add(new MustUnderstandInterceptor());\n            sb.getOutInterceptors().add(new SoapPreProtocolOutInterceptor());\n            sb.getOutInterceptors().add(new SoapOutInterceptor(getBus()));\n            sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n            // REVISIT: The phase interceptor chain seems to freak out if this added\n            // first. Not sure what the deal is at the moment, I suspect the\n            // ordering algorithm needs to be improved\n            sb.getInInterceptors().add(new URIMappingInterceptor());\n        }\n\n        if (version.getVersion() == 1.1) {\n            sb.getInFaultInterceptors().add(new Soap11FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap11FaultOutInterceptor());\n        } else if (version.getVersion() == 1.2) {\n            sb.getInFaultInterceptors().add(new Soap12FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap12FaultOutInterceptor());\n        }\n\n        return sb;\n    }","commit_id":"15c14870901b12cc8f7572c256ab2ca7798e04bd","url":"https://github.com/apache/cxf"},{"original_method":"public boolean setProperties(Properties props) {\n        String tmp=null, str;\n\n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n\n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        return super.setProperties(props);\n    }","id":95349,"modified_method":"public boolean setProperties(Properties props) {\n        String tmp=null, str;\n\n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n\n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            bind_to_all_interfaces=new Boolean(str).booleanValue();\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        return super.setProperties(props);\n    }","commit_id":"c428f24c2d76f021147cbb33c78477879a1cf6de","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception {\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n        if(bind_addr != null)\n            mcast_sock.setInterface(bind_addr);\n        mcast_sock.joinGroup(mcast_addr);\n        startReceiver();\n        super.start();\n    }","id":95350,"modified_method":"public void start() throws Exception {\n        int jdk_version=Util.getJavaVersion();\n\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n\n        if(bind_to_all_interfaces && jdk_version >= 14) {\n            bindToAllInterfaces();\n        }\n        else {\n            if(bind_addr == null) {\n                InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n                if(interfaces != null && interfaces.length > 0)\n                    bind_addr=interfaces[0];\n            }\n            if(bind_addr == null)\n                bind_addr=InetAddress.getLocalHost();\n\n            if(bind_addr != null)\n                if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n            if(bind_addr != null) {\n                mcast_sock.setInterface(bind_addr);\n                // mcast_sock.setNetworkInterface(NetworkInterface.getByInetAddress(bind_addr)); // JDK 1.4 specific\n            }\n            mcast_sock.joinGroup(mcast_addr);\n        }\n\n        startReceiver();\n        super.start();\n    }","commit_id":"c428f24c2d76f021147cbb33c78477879a1cf6de","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception {\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n        if(bind_addr != null)\n            mcast_sock.setInterface(bind_addr);\n        mcast_sock.joinGroup(mcast_addr);\n        startReceiver();\n        super.start();\n    }","id":95351,"modified_method":"public void start() throws Exception {\n        int jdk_version=Util.getJavaVersion();\n\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n\n        if(bind_to_all_interfaces && jdk_version >= 14) {\n            bindToAllInterfaces();\n        }\n        else {\n            if(bind_addr == null) {\n                InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n                if(interfaces != null && interfaces.length > 0)\n                    bind_addr=interfaces[0];\n            }\n            if(bind_addr == null)\n                bind_addr=InetAddress.getLocalHost();\n\n            if(bind_addr != null)\n                if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n            if(bind_addr != null) {\n                mcast_sock.setInterface(bind_addr);\n                // mcast_sock.setNetworkInterface(NetworkInterface.getByInetAddress(bind_addr)); // JDK 1.4 specific\n            }\n            mcast_sock.joinGroup(mcast_addr);\n        }\n\n        startReceiver();\n        super.start();\n    }","commit_id":"bb87ccef9e1d03eef31c203d0c183e9e3d580858","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String tmp=null, str;\n\n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n\n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        return super.setProperties(props);\n    }","id":95352,"modified_method":"public boolean setProperties(Properties props) {\n        String tmp=null, str;\n\n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n\n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            bind_to_all_interfaces=new Boolean(str).booleanValue();\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        return super.setProperties(props);\n    }","commit_id":"bb87ccef9e1d03eef31c203d0c183e9e3d580858","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getLayoutsCount(\n\t\t\tUser user, boolean privateLayout, boolean checkUserGroup)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = classNameLocalService.getClassNameId(User.class);\n\n\t\tGroup group = groupPersistence.findByC_C_C(\n\t\t\t\tuser.getCompanyId(), classNameId, user.getUserId());\n\n\t\treturn getLayoutsCount(group, privateLayout, checkUserGroup);\n\t}","id":95353,"modified_method":"public int getLayoutsCount(\n\t\t\tUser user, boolean privateLayout, boolean includeUserGroups)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = classNameLocalService.getClassNameId(User.class);\n\n\t\tGroup group = groupPersistence.findByC_C_C(\n\t\t\tuser.getCompanyId(), classNameId, user.getUserId());\n\n\t\treturn getLayoutsCount(group, privateLayout, includeUserGroups);\n\t}","commit_id":"c69d61d5551a5ec6805e97662e42b6ff1b6ef598","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean hasLayouts(\n\t\t\tUser user, boolean privateLayout, boolean checkUserGroup)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = classNameLocalService.getClassNameId(User.class);\n\n\t\tGroup group = groupPersistence.findByC_C_C(\n\t\t\t\tuser.getCompanyId(), classNameId, user.getUserId());\n\n\t\treturn hasLayouts(group, privateLayout, checkUserGroup);\n\t}","id":95354,"modified_method":"public boolean hasLayouts(\n\t\t\tUser user, boolean privateLayout, boolean includeUserGroups)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = classNameLocalService.getClassNameId(User.class);\n\n\t\tGroup group = groupPersistence.findByC_C_C(\n\t\t\tuser.getCompanyId(), classNameId, user.getUserId());\n\n\t\treturn hasLayouts(group, privateLayout, includeUserGroups);\n\t}","commit_id":"c69d61d5551a5ec6805e97662e42b6ff1b6ef598","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean hasLayouts(\n\t\t\tGroup group, boolean privateLayout, boolean checkUserGroup)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutSet layoutSet = layoutSetPersistence.findByG_P(\n\t\t\tgroup.getGroupId(), privateLayout);\n\n\t\tif (layoutSet.getPageCount() > 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (group.isUser() && checkUserGroup) {\n\t\t\tList<UserGroup> userGroups = userPersistence.getUserGroups(\n\t\t\t\tgroup.getClassPK());\n\n\t\t\tif (!userGroups.isEmpty()) {\n\t\t\t\tlong userGroupClassNameId =\n\t\t\t\t\tclassNameLocalService.getClassNameId(UserGroup.class);\n\n\t\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\t\tGroup userGroupGroup = groupPersistence.findByC_C_C(\n\t\t\t\t\t\tgroup.getCompanyId(), userGroupClassNameId,\n\t\t\t\t\t\tuserGroup.getUserGroupId());\n\n\t\t\t\t\tlayoutSet = layoutSetPersistence.findByG_P(\n\t\t\t\t\t\tuserGroupGroup.getGroupId(), privateLayout);\n\n\t\t\t\t\tif (layoutSet.getPageCount() > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":95355,"modified_method":"public boolean hasLayouts(\n\t\t\tGroup group, boolean privateLayout, boolean includeUserGroups)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutSet layoutSet = layoutSetPersistence.findByG_P(\n\t\t\tgroup.getGroupId(), privateLayout);\n\n\t\tif (layoutSet.getPageCount() > 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!group.isUser() || !includeUserGroups) {\n\t\t\treturn false;\n\t\t}\n\n\t\tList<UserGroup> userGroups = userPersistence.getUserGroups(\n\t\t\tgroup.getClassPK());\n\n\t\tif (!userGroups.isEmpty()) {\n\t\t\tlong userGroupClassNameId = classNameLocalService.getClassNameId(\n\t\t\t\tUserGroup.class);\n\n\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\tGroup userGroupGroup = groupPersistence.findByC_C_C(\n\t\t\t\t\tgroup.getCompanyId(), userGroupClassNameId,\n\t\t\t\t\tuserGroup.getUserGroupId());\n\n\t\t\t\tlayoutSet = layoutSetPersistence.findByG_P(\n\t\t\t\t\tuserGroupGroup.getGroupId(), privateLayout);\n\n\t\t\t\tif (layoutSet.getPageCount() > 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"c69d61d5551a5ec6805e97662e42b6ff1b6ef598","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int getLayoutsCount(\n\t\t\tGroup group, boolean privateLayout, boolean checkUserGroup)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutSet layoutSet = layoutSetPersistence.findByG_P(\n\t\t\t\tgroup.getGroupId(), privateLayout);\n\n\t\tint count = layoutSet.getPageCount();\n\n\t\tif (group.isUser() && checkUserGroup) {\n\t\t\tList<UserGroup> userGroups = userPersistence.getUserGroups(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\tif (!userGroups.isEmpty()) {\n\t\t\t\tlong userGroupClassNameId =\n\t\t\t\t\t\tclassNameLocalService.getClassNameId(UserGroup.class);\n\n\t\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\t\tGroup userGroupGroup = groupPersistence.findByC_C_C(\n\t\t\t\t\t\t\tgroup.getCompanyId(), userGroupClassNameId,\n\t\t\t\t\t\t\tuserGroup.getUserGroupId());\n\n\t\t\t\t\tlayoutSet = layoutSetPersistence.findByG_P(\n\t\t\t\t\t\t\tuserGroupGroup.getGroupId(), privateLayout);\n\n\t\t\t\t\tcount += layoutSet.getPageCount();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}","id":95356,"modified_method":"public int getLayoutsCount(\n\t\t\tGroup group, boolean privateLayout, boolean includeUserGroups)\n\t\tthrows PortalException, SystemException {\n\n\t\tLayoutSet layoutSet = layoutSetPersistence.findByG_P(\n\t\t\tgroup.getGroupId(), privateLayout);\n\n\t\tint count = layoutSet.getPageCount();\n\n\t\tif (!group.isUser() || !includeUserGroups) {\n\t\t\treturn count;\n\t\t}\n\n\t\tList<UserGroup> userGroups = userPersistence.getUserGroups(\n\t\t\tgroup.getClassPK());\n\n\t\tif (!userGroups.isEmpty()) {\n\t\t\tlong userGroupClassNameId = classNameLocalService.getClassNameId(\n\t\t\t\tUserGroup.class);\n\n\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\tGroup userGroupGroup = groupPersistence.findByC_C_C(\n\t\t\t\t\tgroup.getCompanyId(), userGroupClassNameId,\n\t\t\t\t\tuserGroup.getUserGroupId());\n\n\t\t\t\tlayoutSet = layoutSetPersistence.findByG_P(\n\t\t\t\t\tuserGroupGroup.getGroupId(), privateLayout);\n\n\t\t\t\tcount += layoutSet.getPageCount();\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}","commit_id":"c69d61d5551a5ec6805e97662e42b6ff1b6ef598","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isPasswordTokenEnabled(\n\t\tPortletRequest portletRequest) {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tboolean userPrivatePages =\n\t\t\tlayout.getGroup().isUser() && layout.isPrivateLayout();\n\n\t\tString roleName = PropsValues.IFRAME_PASSWORD_PASSWORD_TOKEN_ROLE;\n\n\t\tboolean passwordTokenEnabled = true;\n\n\t\tif (!userPrivatePages && Validator.isNotNull(roleName)) {\n\n\t\t\ttry {\n\t\t\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tthemeDisplay.getCompanyId(), roleName);\n\n\t\t\t\tif (!UserLocalServiceUtil.hasRoleUser(\n\t\t\t\t\t\trole.getRoleId(), themeDisplay.getUserId())) {\n\n\t\t\t\t\tpasswordTokenEnabled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Error checking role \" + roleName + \". The password \" +\n\t\t\t\t\t\t\t\"token will be disabled\");\n\t\t\t\t}\n\n\t\t\t\tpasswordTokenEnabled = false;\n\t\t\t}\n\t\t}\n\n\t\treturn passwordTokenEnabled;\n\t}","id":95357,"modified_method":"public static boolean isPasswordTokenEnabled(\n\t\tPortletRequest portletRequest) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tString roleName = PropsValues.IFRAME_PASSWORD_PASSWORD_TOKEN_ROLE;\n\n\t\tif (Validator.isNull(roleName)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!layout.isPrivateLayout() || !layout.getGroup().isUser()) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\t\tthemeDisplay.getCompanyId(), roleName);\n\n\t\t\tif (UserLocalServiceUtil.hasRoleUser(\n\t\t\t\t\trole.getRoleId(), themeDisplay.getUserId())) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Error getting role \" + roleName + \". The password token \" +\n\t\t\t\t\t\t\"will be disabled.\");\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"c90a02ed6b2e0b940a78a834c8aea4a3feb744e2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void unsetPermission(ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tlong roleId = ParamUtil.getLong(req, \"roleId\");\n\t\tlong permissionId = ParamUtil.getLong(req, \"permissionId\");\n\n\t\tPermissionServiceUtil.unsetRolePermission(\n\t\t\troleId, themeDisplay.getPortletGroupId(), permissionId);\n\n\t\t// Send redirect\n\n\t\tSessionMessages.add(req, \"permissionDeleted\");\n\n\t\tString redirect = ParamUtil.getString(req, \"redirect\");\n\n\t\tres.sendRedirect(redirect);\n\t}","id":95358,"modified_method":"protected void deletePermission(ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tlong roleId = ParamUtil.getLong(req, \"roleId\");\n\t\tlong permissionId = ParamUtil.getLong(req, \"permissionId\");\n\n\t\tPermissionServiceUtil.unsetRolePermission(\n\t\t\troleId, themeDisplay.getPortletGroupId(), permissionId);\n\n\t\t// Send redirect\n\n\t\tSessionMessages.add(req, \"permissionDeleted\");\n\n\t\tString redirect = ParamUtil.getString(req, \"redirect\");\n\n\t\tres.sendRedirect(redirect);\n\t}","commit_id":"7e16d238f0d03d824ed154117b068ee617b0754f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateGroupPermissions(ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tlong roleId = ParamUtil.getLong(req, \"roleId\");\n\n\t\tString portletResource = ParamUtil.getString(req, \"portletResource\");\n\t\tString modelResource = ParamUtil.getString(req, \"modelResource\");\n\n\t\tString selResource = modelResource;\n\t\tif (Validator.isNull(modelResource)) {\n\t\t\tselResource = portletResource;\n\t\t}\n\n\t\tint groupScopePos = ParamUtil.getInteger(req, \"groupScopePos\");\n\t\tString[] groupScopeActionIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"groupScopeActionIds\"));\n\n\t\tString actionId = groupScopeActionIds[groupScopePos];\n\n\t\tString[] addGroupIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"addGroupIds\"));\n\t\tString[] removeGroupIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"removeGroupIds\"));\n\n\t\tfor (int i = 0; i < addGroupIds.length; i++) {\n\t\t\tPermissionServiceUtil.setRolePermission(\n\t\t\t\troleId, themeDisplay.getPortletGroupId(), selResource,\n\t\t\t\tResourceImpl.SCOPE_GROUP, addGroupIds[i], actionId);\n\t\t}\n\n\t\tfor (int i = 0; i < removeGroupIds.length; i++) {\n\t\t\tPermissionServiceUtil.unsetRolePermission(\n\t\t\t\troleId, themeDisplay.getPortletGroupId(), selResource,\n\t\t\t\tResourceImpl.SCOPE_GROUP, removeGroupIds[i], actionId);\n\t\t}\n\n\t\tString redirect = ParamUtil.getString(req, \"redirect\");\n\n\t\tif (redirect.indexOf(\"groupScopePos=\" + groupScopePos + \"&\") != -1) {\n\n\t\t\t// Show message only if the user stayed on the same page\n\n\t\t\tSessionMessages.add(req, \"request_processed\");\n\t\t}\n\n\t\tres.sendRedirect(redirect);\n\t}","id":95359,"modified_method":"protected void updateGroupPermissions(ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tlong roleId = ParamUtil.getLong(req, \"roleId\");\n\n\t\tString portletResource = ParamUtil.getString(req, \"portletResource\");\n\t\tString modelResource = ParamUtil.getString(req, \"modelResource\");\n\n\t\tString selResource = modelResource;\n\t\tif (Validator.isNull(modelResource)) {\n\t\t\tselResource = portletResource;\n\t\t}\n\n\t\tint groupScopePos = ParamUtil.getInteger(req, \"groupScopePos\");\n\t\tString[] groupScopeActionIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"groupScopeActionIds\"));\n\n\t\tString actionId = groupScopeActionIds[groupScopePos];\n\n\t\tString[] addGroupIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"addGroupIds\"));\n\t\tString[] removeGroupIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"removeGroupIds\"));\n\n\t\tfor (int i = 0; i < addGroupIds.length; i++) {\n\t\t\tPermissionServiceUtil.setRolePermission(\n\t\t\t\troleId, themeDisplay.getPortletGroupId(), selResource,\n\t\t\t\tResourceImpl.SCOPE_GROUP, addGroupIds[i], actionId);\n\t\t}\n\n\t\tfor (int i = 0; i < removeGroupIds.length; i++) {\n\t\t\tPermissionServiceUtil.unsetRolePermission(\n\t\t\t\troleId, themeDisplay.getPortletGroupId(), selResource,\n\t\t\t\tResourceImpl.SCOPE_GROUP, removeGroupIds[i], actionId);\n\t\t}\n\n\t\tString redirect = ParamUtil.getString(req, \"redirect\");\n\n\t\tif (redirect.indexOf(\"groupScopePos=\" + groupScopePos + \"&\") != -1) {\n\n\t\t\t// Show message only if the user stayed on the same page\n\n\t\t\tSessionMessages.add(req, \"request_processed\");\n\t\t}\n\t\telse if ((groupScopePos + 1) == groupScopeActionIds.length) {\n\t\t\tSessionMessages.add(req, \"permissionsUpdated\");\n\t\t}\n\n\t\tres.sendRedirect(redirect);\n\t}","commit_id":"7e16d238f0d03d824ed154117b068ee617b0754f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(\"actions\")) {\n\t\t\t\tupdateActions(req, res);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"group_permissions\")) {\n\t\t\t\tupdateGroupPermissions(req, res);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"unset_permission\")) {\n\t\t\t\tunsetPermission(req, res);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchRoleException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\n\t\t\t\tsetForward(req, \"portlet.enterprise_admin.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":95360,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(\"actions\")) {\n\t\t\t\tupdateActions(req, res);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"delete_permission\")) {\n\t\t\t\tdeletePermission(req, res);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"group_permissions\")) {\n\t\t\t\tupdateGroupPermissions(req, res);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchRoleException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\n\t\t\t\tsetForward(req, \"portlet.enterprise_admin.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"7e16d238f0d03d824ed154117b068ee617b0754f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _read(\n\t\t\tString servletContextName, ClassLoader classLoader, String source)\n\t\tthrows Exception {\n\n\t\tString xml = null;\n\n\t\ttry {\n\t\t\txml = StringUtil.read(classLoader, source);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.warn(\"Cannot load \" + source);\n\t\t}\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Loading \" + source);\n\t\t}\n\n\t\tSAXReader reader = new SAXReader();\n\n\t\tDocument doc = reader.read(new StringReader(xml));\n\n\t\tElement root = doc.getRootElement();\n\n\t\tIterator itr1 = root.elements(\"resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = (Element)itr1.next();\n\n\t\t\tString file = resource.attributeValue(\"file\");\n\n\t\t\t_read(servletContextName, classLoader, file);\n\t\t}\n\n\t\titr1 = root.elements(\"portlet-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = (Element)itr1.next();\n\n\t\t\tString name = resource.elementText(\"portlet-name\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tname = name + PortletImpl.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tname = PortalUtil.getJsSafePortletName(name);\n\n\t\t\t// Actions\n\n\t\t\tList actions = _getActions(_portletResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\tIterator itr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkPortletActions(actions);\n\n\t\t\t// Community default actions\n\n\t\t\tList communityDefaultActions =\n\t\t\t\t_getActions(_portletResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkPortletCommunityDefaultActions(communityDefaultActions);\n\n\t\t\t// Guest default actions\n\n\t\t\tList guestDefaultActions =\n\t\t\t\t_getActions(_portletResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList guestUnsupportedActions =\n\t\t\t\t_getActions(_portletResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\t\t}\n\n\t\titr1 = root.elements(\"model-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = (Element)itr1.next();\n\n\t\t\tString name = resource.elementText(\"model-name\");\n\n\t\t\tElement portletRef = resource.element(\"portlet-ref\");\n\n\t\t\tIterator itr2 = portletRef.elements(\"portlet-name\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement portletName = (Element)itr2.next();\n\n\t\t\t\tString portletNameString = portletName.getText();\n\n\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\tportletNameString =\n\t\t\t\t\t\tportletNameString + PortletImpl.WAR_SEPARATOR +\n\t\t\t\t\t\t\tservletContextName;\n\t\t\t\t}\n\n\t\t\t\tportletNameString = PortalUtil.getJsSafePortletName(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\tSet modelResources = (Set)_portletModelResources.get(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\tif (modelResources == null) {\n\t\t\t\t\tmodelResources = new HashSet();\n\n\t\t\t\t\t_portletModelResources.put(\n\t\t\t\t\t\tportletNameString, modelResources);\n\t\t\t\t}\n\n\t\t\t\tmodelResources.add(name);\n\t\t\t}\n\n\t\t\t// Actions\n\n\t\t\tList actions = _getActions(_modelResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\titr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList communityDefaultActions =\n\t\t\t\t_getActions(_modelResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList guestDefaultActions =\n\t\t\t\t_getActions(_modelResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList guestUnsupportedActions =\n\t\t\t\t_getActions(_modelResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\t\t}\n\t}","id":95361,"modified_method":"private void _read(\n\t\t\tString servletContextName, ClassLoader classLoader, String source)\n\t\tthrows Exception {\n\n\t\tString xml = null;\n\n\t\ttry {\n\t\t\txml = StringUtil.read(classLoader, source);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.warn(\"Cannot load \" + source);\n\t\t}\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Loading \" + source);\n\t\t}\n\n\t\tSAXReader reader = new SAXReader();\n\n\t\tDocument doc = reader.read(new StringReader(xml));\n\n\t\tElement root = doc.getRootElement();\n\n\t\tIterator itr1 = root.elements(\"resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = (Element)itr1.next();\n\n\t\t\tString file = resource.attributeValue(\"file\");\n\n\t\t\t_read(servletContextName, classLoader, file);\n\t\t}\n\n\t\titr1 = root.elements(\"portlet-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = (Element)itr1.next();\n\n\t\t\tString name = resource.elementText(\"portlet-name\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tname = name + PortletImpl.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tname = PortalUtil.getJsSafePortletName(name);\n\n\t\t\t// Actions\n\n\t\t\tList actions = _getActions(_portletResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\tIterator itr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t_checkPortletActions(actions);\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList communityDefaultActions =\n\t\t\t\t_getActions(_portletResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkPortletCommunityDefaultActions(communityDefaultActions);\n\n\t\t\t// Guest default actions\n\n\t\t\tList guestDefaultActions =\n\t\t\t\t_getActions(_portletResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList guestUnsupportedActions =\n\t\t\t\t_getActions(_portletResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\t\t}\n\n\t\titr1 = root.elements(\"model-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = (Element)itr1.next();\n\n\t\t\tString name = resource.elementText(\"model-name\");\n\n\t\t\tElement portletRef = resource.element(\"portlet-ref\");\n\n\t\t\tIterator itr2 = portletRef.elements(\"portlet-name\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement portletName = (Element)itr2.next();\n\n\t\t\t\tString portletNameString = portletName.getText();\n\n\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\tportletNameString =\n\t\t\t\t\t\tportletNameString + PortletImpl.WAR_SEPARATOR +\n\t\t\t\t\t\t\tservletContextName;\n\t\t\t\t}\n\n\t\t\t\tportletNameString = PortalUtil.getJsSafePortletName(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\t// Reference for a portlet to child models\n\n\t\t\t\tSet modelResources = (Set)_portletModelResources.get(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\tif (modelResources == null) {\n\t\t\t\t\tmodelResources = new HashSet();\n\n\t\t\t\t\t_portletModelResources.put(\n\t\t\t\t\t\tportletNameString, modelResources);\n\t\t\t\t}\n\n\t\t\t\tmodelResources.add(name);\n\n\t\t\t\t// Reference for a model to parent portlets\n\n\t\t\t\tSet portletResources = (Set)_modelPortletResources.get(name);\n\n\t\t\t\tif (portletResources == null) {\n\t\t\t\t\tportletResources = new HashSet();\n\n\t\t\t\t\t_modelPortletResources.put(name, portletResources);\n\t\t\t\t}\n\n\t\t\t\tportletResources.add(portletNameString);\n\t\t\t}\n\n\t\t\t// Actions\n\n\t\t\tList actions = _getActions(_modelResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\titr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList communityDefaultActions =\n\t\t\t\t_getActions(_modelResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList guestDefaultActions =\n\t\t\t\t_getActions(_modelResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList guestUnsupportedActions =\n\t\t\t\t_getActions(_modelResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = (Element)itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\t\t}\n\t}","commit_id":"7e16d238f0d03d824ed154117b068ee617b0754f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private List _getPortletResourceActions(long companyId, String name)\n\t\tthrows SystemException {\n\n\t\tname = PortletImpl.getRootPortletId(name);\n\n\t\tList actions = _getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tactions.clear();\n\n\t\t\t\tif (name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t\tactions.add(ActionKeys.ADD_COMMUNITY);\n\t\t\t\t\tactions.add(ActionKeys.ADD_LICENSE);\n\t\t\t\t\tactions.add(ActionKeys.ADD_ORGANIZATION);\n\t\t\t\t\tactions.add(ActionKeys.ADD_PASSWORD_POLICY);\n\t\t\t\t\tactions.add(ActionKeys.ADD_ROLE);\n\t\t\t\t\tactions.add(ActionKeys.ADD_USER_GROUP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\t\tcompanyId, name);\n\n\t\t\t\t\tMap portletModes = portlet.getPortletModes();\n\n\t\t\t\t\tSet mimeTypeModes = (Set)portletModes.get(\"text/html\");\n\n\t\t\t\t\tif (mimeTypeModes != null) {\n\t\t\t\t\t\tIterator itr = mimeTypeModes.iterator();\n\n\t\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\t\tString actionId = (String)itr.next();\n\n\t\t\t\t\t\t\tif (actionId.equalsIgnoreCase(\"edit\")) {\n\t\t\t\t\t\t\t\tactions.add(ActionKeys.PREFERENCES);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (actionId.equalsIgnoreCase(\"edit_guest\")) {\n\t\t\t\t\t\t\t\tactions.add(ActionKeys.GUEST_PREFERENCES);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tactions.add(actionId.toUpperCase());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_checkPortletActions(actions);\n\n\t\t\t\t\tList communityDefaultActions = _getActions(\n\t\t\t\t\t\t_portletResourceCommunityDefaultActions, name);\n\n\t\t\t\t\tcommunityDefaultActions.clear();\n\n\t\t\t\t\t_checkPortletCommunityDefaultActions(\n\t\t\t\t\t\tcommunityDefaultActions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actions;\n\t}","id":95362,"modified_method":"private List _getPortletResourceActions(long companyId, String name)\n\t\tthrows SystemException {\n\n\t\tname = PortletImpl.getRootPortletId(name);\n\n\t\tList actions = _getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tactions.clear();\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcompanyId, name);\n\n\t\t\t\tMap portletModes = portlet.getPortletModes();\n\n\t\t\t\tSet mimeTypeModes = (Set)portletModes.get(\"text/html\");\n\n\t\t\t\tif (mimeTypeModes != null) {\n\t\t\t\t\tIterator itr = mimeTypeModes.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tString actionId = (String)itr.next();\n\n\t\t\t\t\t\tif (actionId.equalsIgnoreCase(\"edit\")) {\n\t\t\t\t\t\t\tactions.add(ActionKeys.PREFERENCES);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (actionId.equalsIgnoreCase(\"edit_guest\")) {\n\t\t\t\t\t\t\tactions.add(ActionKeys.GUEST_PREFERENCES);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tactions.add(actionId.toUpperCase());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_checkPortletActions(actions);\n\n\t\t\t\tList communityDefaultActions = _getActions(\n\t\t\t\t\t_portletResourceCommunityDefaultActions, name);\n\n\t\t\t\tcommunityDefaultActions.clear();\n\n\t\t\t\t_checkPortletCommunityDefaultActions(communityDefaultActions);\n\t\t\t}\n\t\t}\n\n\t\treturn actions;\n\t}","commit_id":"7e16d238f0d03d824ed154117b068ee617b0754f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private ResourceActionsUtil() {\n\t\t_portletModelResources = CollectionFactory.getHashMap();\n\t\t_portletResourceActions = CollectionFactory.getHashMap();\n\t\t_portletResourceCommunityDefaultActions =\n\t\t\tCollectionFactory.getHashMap();\n\t\t_portletResourceGuestDefaultActions = CollectionFactory.getHashMap();\n\t\t_portletResourceGuestUnsupportedActions =\n\t\t\tCollectionFactory.getHashMap();\n\t\t_modelResourceActions = CollectionFactory.getHashMap();\n\t\t_modelResourceCommunityDefaultActions = CollectionFactory.getHashMap();\n\t\t_modelResourceGuestDefaultActions = CollectionFactory.getHashMap();\n\t\t_modelResourceGuestUnsupportedActions = CollectionFactory.getHashMap();\n\n\t\ttry {\n\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\t\tString[] configs = StringUtil.split(\n\t\t\t\tPropsUtil.get(PropsUtil.RESOURCE_ACTIONS_CONFIGS));\n\n\t\t\tfor (int i = 0; i < configs.length; i++) {\n\t\t\t\t_read(null, classLoader, configs[i]);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":95363,"modified_method":"private ResourceActionsUtil() {\n\t\t_portletModelResources = CollectionFactory.getHashMap();\n\t\t_portletResourceActions = CollectionFactory.getHashMap();\n\t\t_portletResourceCommunityDefaultActions =\n\t\t\tCollectionFactory.getHashMap();\n\t\t_portletResourceGuestDefaultActions = CollectionFactory.getHashMap();\n\t\t_portletResourceGuestUnsupportedActions =\n\t\t\tCollectionFactory.getHashMap();\n\t\t_modelPortletResources = CollectionFactory.getHashMap();\n\t\t_modelResourceActions = CollectionFactory.getHashMap();\n\t\t_modelResourceCommunityDefaultActions = CollectionFactory.getHashMap();\n\t\t_modelResourceGuestDefaultActions = CollectionFactory.getHashMap();\n\t\t_modelResourceGuestUnsupportedActions = CollectionFactory.getHashMap();\n\n\t\ttry {\n\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\t\tString[] configs = StringUtil.split(\n\t\t\t\tPropsUtil.get(PropsUtil.RESOURCE_ACTIONS_CONFIGS));\n\n\t\t\tfor (int i = 0; i < configs.length; i++) {\n\t\t\t\t_read(null, classLoader, configs[i]);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"7e16d238f0d03d824ed154117b068ee617b0754f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _read(\n\t\t\tString servletContextName, ClassLoader classLoader, String source)\n\t\tthrows Exception {\n\n\t\tString xml = null;\n\n\t\ttry {\n\t\t\txml = StringUtil.read(classLoader, source);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled() && !source.endsWith(\"-ext.xml\")) {\n\t\t\t\t_log.warn(\"Cannot load \" + source);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Error reading \" + source, e);\n\t\t\t}\n\t\t}\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Loading \" + source);\n\t\t}\n\n\t\tDocument doc = SAXReaderUtil.read(xml);\n\n\t\tElement root = doc.getRootElement();\n\n\t\tIterator<Element> itr1 = root.elements(\"resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString file = resource.attributeValue(\"file\");\n\n\t\t\t_read(servletContextName, classLoader, file);\n\n\t\t\tString extFile = StringUtil.replace(file, \".xml\", \"-ext.xml\");\n\n\t\t\t_read(servletContextName, classLoader, extFile);\n\t\t}\n\n\t\titr1 = root.elements(\"portlet-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"portlet-name\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tname =\n\t\t\t\t\tname + PortletConstants.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tname = PortalUtil.getJsSafePortletId(name);\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\tIterator<Element> itr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t_checkPortletActions(actions);\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_portletResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_portletResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_portletResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Layout manager actions\n\n\t\t\tList<String> layoutManagerActions = _getActions(\n\t\t\t\t_portletResourceLayoutManagerActions, name);\n\n\t\t\tElement layoutManager = resource.element(\"layout-manager\");\n\n\t\t\tif (layoutManager != null) {\n\t\t\t\titr2 = layoutManager.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\tlayoutManagerActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Set the layout manager actions to contain all the portlet\n\t\t\t\t// resource actions if the element is not specified\n\n\t\t\t\tlayoutManagerActions.addAll(actions);\n\t\t\t}\n\t\t}\n\n\t\titr1 = root.elements(\"model-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"model-name\");\n\n\t\t\tElement portletRef = resource.element(\"portlet-ref\");\n\n\t\t\tIterator<Element> itr2 = portletRef.elements(\n\t\t\t\t\"portlet-name\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement portletName = itr2.next();\n\n\t\t\t\tString portletNameString = portletName.getText();\n\n\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\tportletNameString =\n\t\t\t\t\t\tportletNameString + PortletConstants.WAR_SEPARATOR +\n\t\t\t\t\t\t\tservletContextName;\n\t\t\t\t}\n\n\t\t\t\tportletNameString = PortalUtil.getJsSafePortletId(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\t// Reference for a portlet to child models\n\n\t\t\t\tSet<String> modelResources = _portletModelResources.get(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\tif (modelResources == null) {\n\t\t\t\t\tmodelResources = new HashSet<String>();\n\n\t\t\t\t\t_portletModelResources.put(\n\t\t\t\t\t\tportletNameString, modelResources);\n\t\t\t\t}\n\n\t\t\t\tmodelResources.add(name);\n\n\t\t\t\t// Reference for a model to parent portlets\n\n\t\t\t\tSet<String> portletResources = _modelPortletResources.get(name);\n\n\t\t\t\tif (portletResources == null) {\n\t\t\t\t\tportletResources = new HashSet<String>();\n\n\t\t\t\t\t_modelPortletResources.put(name, portletResources);\n\t\t\t\t}\n\n\t\t\t\tportletResources.add(portletNameString);\n\t\t\t}\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_modelResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\titr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_modelResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_modelResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_modelResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Owner default actions\n\n\t\t\tList<String> ownerDefaultActions = _getActions(\n\t\t\t\t_modelResourceOwnerDefaultActions, name);\n\n\t\t\tElement ownerDefaults = resource.element(\"owner-defaults\");\n\n\t\t\tif (ownerDefaults != null) {\n\t\t\t\titr2 = ownerDefaults.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\townerDefaultActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":95364,"modified_method":"private void _read(\n\t\t\tString servletContextName, ClassLoader classLoader, String source)\n\t\tthrows Exception {\n\n\t\tString xml = null;\n\n\t\ttry {\n\t\t\txml = StringUtil.read(classLoader, source);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled() && !source.endsWith(\"-ext.xml\")) {\n\t\t\t\t_log.warn(\"Cannot load \" + source);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Error reading \" + source, e);\n\t\t\t}\n\t\t}\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Loading \" + source);\n\t\t}\n\n\t\tDocument doc = SAXReaderUtil.read(xml);\n\n\t\tElement root = doc.getRootElement();\n\n\t\tIterator<Element> itr1 = root.elements(\"resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString file = resource.attributeValue(\"file\");\n\n\t\t\t_read(servletContextName, classLoader, file);\n\n\t\t\tString extFile = StringUtil.replace(file, \".xml\", \"-ext.xml\");\n\n\t\t\t_read(servletContextName, classLoader, extFile);\n\t\t}\n\n\t\titr1 = root.elements(\"portlet-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"portlet-name\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tname =\n\t\t\t\t\tname + PortletConstants.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tname = PortalUtil.getJsSafePortletId(name);\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\tIterator<Element> itr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactions.addAll(_getPortletMimeTypeActions(name));\n\n\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t_checkPortletActions(actions);\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_portletResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_portletResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_portletResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Layout manager actions\n\n\t\t\tList<String> layoutManagerActions = _getActions(\n\t\t\t\t_portletResourceLayoutManagerActions, name);\n\n\t\t\tElement layoutManager = resource.element(\"layout-manager\");\n\n\t\t\tif (layoutManager != null) {\n\t\t\t\titr2 = layoutManager.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\tlayoutManagerActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Set the layout manager actions to contain all the portlet\n\t\t\t\t// resource actions if the element is not specified\n\n\t\t\t\tlayoutManagerActions.addAll(actions);\n\t\t\t}\n\t\t}\n\n\t\titr1 = root.elements(\"model-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"model-name\");\n\n\t\t\tElement portletRef = resource.element(\"portlet-ref\");\n\n\t\t\tIterator<Element> itr2 = portletRef.elements(\n\t\t\t\t\"portlet-name\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement portletName = itr2.next();\n\n\t\t\t\tString portletNameString = portletName.getText();\n\n\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\tportletNameString =\n\t\t\t\t\t\tportletNameString + PortletConstants.WAR_SEPARATOR +\n\t\t\t\t\t\t\tservletContextName;\n\t\t\t\t}\n\n\t\t\t\tportletNameString = PortalUtil.getJsSafePortletId(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\t// Reference for a portlet to child models\n\n\t\t\t\tSet<String> modelResources = _portletModelResources.get(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\tif (modelResources == null) {\n\t\t\t\t\tmodelResources = new HashSet<String>();\n\n\t\t\t\t\t_portletModelResources.put(\n\t\t\t\t\t\tportletNameString, modelResources);\n\t\t\t\t}\n\n\t\t\t\tmodelResources.add(name);\n\n\t\t\t\t// Reference for a model to parent portlets\n\n\t\t\t\tSet<String> portletResources = _modelPortletResources.get(name);\n\n\t\t\t\tif (portletResources == null) {\n\t\t\t\t\tportletResources = new HashSet<String>();\n\n\t\t\t\t\t_modelPortletResources.put(name, portletResources);\n\t\t\t\t}\n\n\t\t\t\tportletResources.add(portletNameString);\n\t\t\t}\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_modelResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\titr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_modelResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_modelResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_modelResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Owner default actions\n\n\t\t\tList<String> ownerDefaultActions = _getActions(\n\t\t\t\t_modelResourceOwnerDefaultActions, name);\n\n\t\t\tElement ownerDefaults = resource.element(\"owner-defaults\");\n\n\t\t\tif (ownerDefaults != null) {\n\t\t\t\titr2 = ownerDefaults.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\townerDefaultActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"c02b54d9edd7e101dbe65088ac1d2030cbbf43ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private List<String> _getPortletResourceActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(name);\n\n\t\t\t\tif (portlet != null) {\n\t\t\t\t\tMap<String, Set<String>> portletModes =\n\t\t\t\t\t\tportlet.getPortletModes();\n\n\t\t\t\t\tSet<String> mimeTypePortletModes = portletModes.get(\n\t\t\t\t\t\tContentTypes.TEXT_HTML);\n\n\t\t\t\t\tif (mimeTypePortletModes != null) {\n\t\t\t\t\t\tfor (String actionId : mimeTypePortletModes) {\n\t\t\t\t\t\t\tif (actionId.equalsIgnoreCase(\"edit\")) {\n\t\t\t\t\t\t\t\tactions.add(ActionKeys.PREFERENCES);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (actionId.equalsIgnoreCase(\"edit_guest\")) {\n\t\t\t\t\t\t\t\tactions.add(ActionKeys.GUEST_PREFERENCES);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tactions.add(actionId.toUpperCase());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"Unable to obtain resource actions for unknown \" +\n\t\t\t\t\t\t\t\t\"portlet \" + name);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_checkPortletActions(actions);\n\n\t\t\t\tList<String> communityDefaultActions =\n\t\t\t\t\t_portletResourceCommunityDefaultActions.get(name);\n\n\t\t\t\tif (communityDefaultActions == null) {\n\t\t\t\t\tcommunityDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceCommunityDefaultActions.put(\n\t\t\t\t\t\tname, communityDefaultActions);\n\n\t\t\t\t\t_checkPortletCommunityDefaultActions(\n\t\t\t\t\t\tcommunityDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> guestDefaultActions =\n\t\t\t\t\t_portletResourceGuestDefaultActions.get(name);\n\n\t\t\t\tif (guestDefaultActions == null) {\n\t\t\t\t\tguestDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceGuestDefaultActions.put(\n\t\t\t\t\t\tname, guestDefaultActions);\n\n\t\t\t\t\t_checkPortletGuestDefaultActions(guestDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> layoutManagerActions =\n\t\t\t\t\t_portletResourceLayoutManagerActions.get(name);\n\n\t\t\t\tif (layoutManagerActions == null) {\n\t\t\t\t\tlayoutManagerActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceLayoutManagerActions.put(\n\t\t\t\t\t\tname, layoutManagerActions);\n\n\t\t\t\t\t_checkPortletLayoutManagerActions(layoutManagerActions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actions;\n\t}","id":95365,"modified_method":"private List<String> _getPortletResourceActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tactions = _getPortletMimeTypeActions(name);\n\n\t\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t\t_checkPortletActions(actions);\n\t\t\t\t}\n\n\t\t\t\tList<String> communityDefaultActions =\n\t\t\t\t\t_portletResourceCommunityDefaultActions.get(name);\n\n\t\t\t\tif (communityDefaultActions == null) {\n\t\t\t\t\tcommunityDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceCommunityDefaultActions.put(\n\t\t\t\t\t\tname, communityDefaultActions);\n\n\t\t\t\t\t_checkPortletCommunityDefaultActions(\n\t\t\t\t\t\tcommunityDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> guestDefaultActions =\n\t\t\t\t\t_portletResourceGuestDefaultActions.get(name);\n\n\t\t\t\tif (guestDefaultActions == null) {\n\t\t\t\t\tguestDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceGuestDefaultActions.put(\n\t\t\t\t\t\tname, guestDefaultActions);\n\n\t\t\t\t\t_checkPortletGuestDefaultActions(guestDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> layoutManagerActions =\n\t\t\t\t\t_portletResourceLayoutManagerActions.get(name);\n\n\t\t\t\tif (layoutManagerActions == null) {\n\t\t\t\t\tlayoutManagerActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceLayoutManagerActions.put(\n\t\t\t\t\t\tname, layoutManagerActions);\n\n\t\t\t\t\t_checkPortletLayoutManagerActions(layoutManagerActions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actions;\n\t}","commit_id":"c02b54d9edd7e101dbe65088ac1d2030cbbf43ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _read(\n\t\t\tString servletContextName, ClassLoader classLoader, String source)\n\t\tthrows Exception {\n\n\t\tString xml = null;\n\n\t\ttry {\n\t\t\txml = StringUtil.read(classLoader, source);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled() && !source.endsWith(\"-ext.xml\")) {\n\t\t\t\t_log.warn(\"Cannot load \" + source);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Error reading \" + source, e);\n\t\t\t}\n\t\t}\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Loading \" + source);\n\t\t}\n\n\t\tDocument doc = SAXReaderUtil.read(xml);\n\n\t\tElement root = doc.getRootElement();\n\n\t\tIterator<Element> itr1 = root.elements(\"resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString file = resource.attributeValue(\"file\");\n\n\t\t\t_read(servletContextName, classLoader, file);\n\n\t\t\tString extFile = StringUtil.replace(file, \".xml\", \"-ext.xml\");\n\n\t\t\t_read(servletContextName, classLoader, extFile);\n\t\t}\n\n\t\titr1 = root.elements(\"portlet-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"portlet-name\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tname =\n\t\t\t\t\tname + PortletConstants.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tname = PortalUtil.getJsSafePortletId(name);\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\tIterator<Element> itr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t_checkPortletActions(actions);\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_portletResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_portletResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_portletResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Layout manager actions\n\n\t\t\tList<String> layoutManagerActions = _getActions(\n\t\t\t\t_portletResourceLayoutManagerActions, name);\n\n\t\t\tElement layoutManager = resource.element(\"layout-manager\");\n\n\t\t\tif (layoutManager != null) {\n\t\t\t\titr2 = layoutManager.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\tlayoutManagerActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Set the layout manager actions to contain all the portlet\n\t\t\t\t// resource actions if the element is not specified\n\n\t\t\t\tlayoutManagerActions.addAll(actions);\n\t\t\t}\n\t\t}\n\n\t\titr1 = root.elements(\"model-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"model-name\");\n\n\t\t\tElement portletRef = resource.element(\"portlet-ref\");\n\n\t\t\tIterator<Element> itr2 = portletRef.elements(\n\t\t\t\t\"portlet-name\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement portletName = itr2.next();\n\n\t\t\t\tString portletNameString = portletName.getText();\n\n\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\tportletNameString =\n\t\t\t\t\t\tportletNameString + PortletConstants.WAR_SEPARATOR +\n\t\t\t\t\t\t\tservletContextName;\n\t\t\t\t}\n\n\t\t\t\tportletNameString = PortalUtil.getJsSafePortletId(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\t// Reference for a portlet to child models\n\n\t\t\t\tSet<String> modelResources = _portletModelResources.get(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\tif (modelResources == null) {\n\t\t\t\t\tmodelResources = new HashSet<String>();\n\n\t\t\t\t\t_portletModelResources.put(\n\t\t\t\t\t\tportletNameString, modelResources);\n\t\t\t\t}\n\n\t\t\t\tmodelResources.add(name);\n\n\t\t\t\t// Reference for a model to parent portlets\n\n\t\t\t\tSet<String> portletResources = _modelPortletResources.get(name);\n\n\t\t\t\tif (portletResources == null) {\n\t\t\t\t\tportletResources = new HashSet<String>();\n\n\t\t\t\t\t_modelPortletResources.put(name, portletResources);\n\t\t\t\t}\n\n\t\t\t\tportletResources.add(portletNameString);\n\t\t\t}\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_modelResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\titr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_modelResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_modelResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_modelResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Owner default actions\n\n\t\t\tList<String> ownerDefaultActions = _getActions(\n\t\t\t\t_modelResourceOwnerDefaultActions, name);\n\n\t\t\tElement ownerDefaults = resource.element(\"owner-defaults\");\n\n\t\t\tif (ownerDefaults != null) {\n\t\t\t\titr2 = ownerDefaults.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\townerDefaultActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":95366,"modified_method":"private void _read(\n\t\t\tString servletContextName, ClassLoader classLoader, String source)\n\t\tthrows Exception {\n\n\t\tString xml = null;\n\n\t\ttry {\n\t\t\txml = StringUtil.read(classLoader, source);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled() && !source.endsWith(\"-ext.xml\")) {\n\t\t\t\t_log.warn(\"Cannot load \" + source);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Error reading \" + source, e);\n\t\t\t}\n\t\t}\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Loading \" + source);\n\t\t}\n\n\t\tDocument doc = SAXReaderUtil.read(xml);\n\n\t\tElement root = doc.getRootElement();\n\n\t\tIterator<Element> itr1 = root.elements(\"resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString file = resource.attributeValue(\"file\");\n\n\t\t\t_read(servletContextName, classLoader, file);\n\n\t\t\tString extFile = StringUtil.replace(file, \".xml\", \"-ext.xml\");\n\n\t\t\t_read(servletContextName, classLoader, extFile);\n\t\t}\n\n\t\titr1 = root.elements(\"portlet-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"portlet-name\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tname =\n\t\t\t\t\tname + PortletConstants.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tname = PortalUtil.getJsSafePortletId(name);\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\tIterator<Element> itr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactions.addAll(_getPortletMimeTypeActions(name));\n\n\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t_checkPortletActions(actions);\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_portletResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_portletResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_portletResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Layout manager actions\n\n\t\t\tList<String> layoutManagerActions = _getActions(\n\t\t\t\t_portletResourceLayoutManagerActions, name);\n\n\t\t\tElement layoutManager = resource.element(\"layout-manager\");\n\n\t\t\tif (layoutManager != null) {\n\t\t\t\titr2 = layoutManager.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\tlayoutManagerActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Set the layout manager actions to contain all the portlet\n\t\t\t\t// resource actions if the element is not specified\n\n\t\t\t\tlayoutManagerActions.addAll(actions);\n\t\t\t}\n\t\t}\n\n\t\titr1 = root.elements(\"model-resource\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement resource = itr1.next();\n\n\t\t\tString name = resource.elementText(\"model-name\");\n\n\t\t\tElement portletRef = resource.element(\"portlet-ref\");\n\n\t\t\tIterator<Element> itr2 = portletRef.elements(\n\t\t\t\t\"portlet-name\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement portletName = itr2.next();\n\n\t\t\t\tString portletNameString = portletName.getText();\n\n\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\tportletNameString =\n\t\t\t\t\t\tportletNameString + PortletConstants.WAR_SEPARATOR +\n\t\t\t\t\t\t\tservletContextName;\n\t\t\t\t}\n\n\t\t\t\tportletNameString = PortalUtil.getJsSafePortletId(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\t// Reference for a portlet to child models\n\n\t\t\t\tSet<String> modelResources = _portletModelResources.get(\n\t\t\t\t\tportletNameString);\n\n\t\t\t\tif (modelResources == null) {\n\t\t\t\t\tmodelResources = new HashSet<String>();\n\n\t\t\t\t\t_portletModelResources.put(\n\t\t\t\t\t\tportletNameString, modelResources);\n\t\t\t\t}\n\n\t\t\t\tmodelResources.add(name);\n\n\t\t\t\t// Reference for a model to parent portlets\n\n\t\t\t\tSet<String> portletResources = _modelPortletResources.get(name);\n\n\t\t\t\tif (portletResources == null) {\n\t\t\t\t\tportletResources = new HashSet<String>();\n\n\t\t\t\t\t_modelPortletResources.put(name, portletResources);\n\t\t\t\t}\n\n\t\t\t\tportletResources.add(portletNameString);\n\t\t\t}\n\n\t\t\t// Actions\n\n\t\t\tList<String> actions = _getActions(_modelResourceActions, name);\n\n\t\t\tElement supports = resource.element(\"supports\");\n\n\t\t\titr2 = supports.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tactions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community default actions\n\n\t\t\tList<String> communityDefaultActions = _getActions(\n\t\t\t\t_modelResourceCommunityDefaultActions, name);\n\n\t\t\tElement communityDefaults = resource.element(\"community-defaults\");\n\n\t\t\titr2 = communityDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tcommunityDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest default actions\n\n\t\t\tList<String> guestDefaultActions = _getActions(\n\t\t\t\t_modelResourceGuestDefaultActions, name);\n\n\t\t\tElement guestDefaults = resource.element(\"guest-defaults\");\n\n\t\t\titr2 = guestDefaults.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestDefaultActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest unsupported actions\n\n\t\t\tList<String> guestUnsupportedActions = _getActions(\n\t\t\t\t_modelResourceGuestUnsupportedActions, name);\n\n\t\t\tElement guestUnsupported = resource.element(\"guest-unsupported\");\n\n\t\t\titr2 = guestUnsupported.elements(\"action-key\").iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\tguestUnsupportedActions.add(actionKeyText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_checkGuestUnsupportedActions(\n\t\t\t\tguestUnsupportedActions, guestDefaultActions);\n\n\t\t\t// Owner default actions\n\n\t\t\tList<String> ownerDefaultActions = _getActions(\n\t\t\t\t_modelResourceOwnerDefaultActions, name);\n\n\t\t\tElement ownerDefaults = resource.element(\"owner-defaults\");\n\n\t\t\tif (ownerDefaults != null) {\n\t\t\t\titr2 = ownerDefaults.elements(\"action-key\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement actionKey = itr2.next();\n\n\t\t\t\t\tString actionKeyText = actionKey.getText();\n\n\t\t\t\t\tif (Validator.isNotNull(actionKeyText)) {\n\t\t\t\t\t\townerDefaultActions.add(actionKeyText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"b421f4ce679197d25df3c32ca832ab706003cc9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private List<String> _getPortletResourceActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(name);\n\n\t\t\t\tif (portlet != null) {\n\t\t\t\t\tMap<String, Set<String>> portletModes =\n\t\t\t\t\t\tportlet.getPortletModes();\n\n\t\t\t\t\tSet<String> mimeTypePortletModes = portletModes.get(\n\t\t\t\t\t\tContentTypes.TEXT_HTML);\n\n\t\t\t\t\tif (mimeTypePortletModes != null) {\n\t\t\t\t\t\tfor (String actionId : mimeTypePortletModes) {\n\t\t\t\t\t\t\tif (actionId.equalsIgnoreCase(\"edit\")) {\n\t\t\t\t\t\t\t\tactions.add(ActionKeys.PREFERENCES);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (actionId.equalsIgnoreCase(\"edit_guest\")) {\n\t\t\t\t\t\t\t\tactions.add(ActionKeys.GUEST_PREFERENCES);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tactions.add(actionId.toUpperCase());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"Unable to obtain resource actions for unknown \" +\n\t\t\t\t\t\t\t\t\"portlet \" + name);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_checkPortletActions(actions);\n\n\t\t\t\tList<String> communityDefaultActions =\n\t\t\t\t\t_portletResourceCommunityDefaultActions.get(name);\n\n\t\t\t\tif (communityDefaultActions == null) {\n\t\t\t\t\tcommunityDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceCommunityDefaultActions.put(\n\t\t\t\t\t\tname, communityDefaultActions);\n\n\t\t\t\t\t_checkPortletCommunityDefaultActions(\n\t\t\t\t\t\tcommunityDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> guestDefaultActions =\n\t\t\t\t\t_portletResourceGuestDefaultActions.get(name);\n\n\t\t\t\tif (guestDefaultActions == null) {\n\t\t\t\t\tguestDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceGuestDefaultActions.put(\n\t\t\t\t\t\tname, guestDefaultActions);\n\n\t\t\t\t\t_checkPortletGuestDefaultActions(guestDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> layoutManagerActions =\n\t\t\t\t\t_portletResourceLayoutManagerActions.get(name);\n\n\t\t\t\tif (layoutManagerActions == null) {\n\t\t\t\t\tlayoutManagerActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceLayoutManagerActions.put(\n\t\t\t\t\t\tname, layoutManagerActions);\n\n\t\t\t\t\t_checkPortletLayoutManagerActions(layoutManagerActions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actions;\n\t}","id":95367,"modified_method":"private List<String> _getPortletResourceActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = _getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tactions = _getPortletMimeTypeActions(name);\n\n\t\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t\t_checkPortletActions(actions);\n\t\t\t\t}\n\n\t\t\t\tList<String> communityDefaultActions =\n\t\t\t\t\t_portletResourceCommunityDefaultActions.get(name);\n\n\t\t\t\tif (communityDefaultActions == null) {\n\t\t\t\t\tcommunityDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceCommunityDefaultActions.put(\n\t\t\t\t\t\tname, communityDefaultActions);\n\n\t\t\t\t\t_checkPortletCommunityDefaultActions(\n\t\t\t\t\t\tcommunityDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> guestDefaultActions =\n\t\t\t\t\t_portletResourceGuestDefaultActions.get(name);\n\n\t\t\t\tif (guestDefaultActions == null) {\n\t\t\t\t\tguestDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceGuestDefaultActions.put(\n\t\t\t\t\t\tname, guestDefaultActions);\n\n\t\t\t\t\t_checkPortletGuestDefaultActions(guestDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> layoutManagerActions =\n\t\t\t\t\t_portletResourceLayoutManagerActions.get(name);\n\n\t\t\t\tif (layoutManagerActions == null) {\n\t\t\t\t\tlayoutManagerActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceLayoutManagerActions.put(\n\t\t\t\t\t\tname, layoutManagerActions);\n\n\t\t\t\t\t_checkPortletLayoutManagerActions(layoutManagerActions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actions;\n\t}","commit_id":"b421f4ce679197d25df3c32ca832ab706003cc9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected File getCacheFile(HttpServletRequest request) throws IOException {\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(request.getRequestURI());\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (queryString != null) {\n\t\t\tsb.append(StringPool.QUESTION);\n\t\t\tsb.append(queryString);\n\t\t}\n\n\t\tlong lastModified = 0;\n\n\t\tEnumeration<String> enu = request.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString modulePath = enu.nextElement();\n\n\t\t\tFile file = getFile(modulePath);\n\n\t\t\tif (file != null) {\n\t\t\t\tlastModified += file.lastModified();\n\t\t\t}\n\t\t}\n\n\t\tif (lastModified > 0) {\n\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\tsb.append(lastModified);\n\t\t}\n\n\t\tString cacheFileName = _TEMP_DIR.concat(\n\t\t\tCacheKeyGeneratorUtil.getCacheKeyGenerator(\n\t\t\t\tComboServlet.class.getName()).getCacheKey(sb));\n\n\t\treturn new File(cacheFileName);\n\t}","id":95368,"modified_method":"protected File getCacheFile(HttpServletRequest request) throws IOException {\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(request.getRequestURI());\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (queryString != null) {\n\t\t\tsb.append(StringPool.QUESTION);\n\t\t\tsb.append(queryString);\n\t\t}\n\n\t\tlong lastModified = 0;\n\n\t\tEnumeration<String> enu = request.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString modulePath = enu.nextElement();\n\n\t\t\tFile file = getFile(modulePath);\n\n\t\t\tif (file != null) {\n\t\t\t\tlastModified += file.lastModified();\n\t\t\t}\n\t\t}\n\n\t\tif (lastModified > 0) {\n\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\tsb.append(lastModified);\n\t\t}\n\n\t\tCacheKeyGenerator cacheKeyGenerator =\n\t\t\tCacheKeyGeneratorUtil.getCacheKeyGenerator(\n\t\t\t\tComboServlet.class.getName());\n\n\t\tString cacheFileName = _TEMP_DIR.concat(\n\t\t\tcacheKeyGenerator.getCacheKey(sb));\n\n\t\treturn new File(cacheFileName);\n\t}","commit_id":"6493571a2c7be7927f43b2ca741a7827b949a934","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _encodeCacheKey(Serializable primaryKeyObj) {\n\t\treturn CacheKeyGeneratorUtil.getCacheKeyGenerator(CACHE_NAME).\n\t\t\tgetCacheKey(primaryKeyObj.toString());\n\t}","id":95369,"modified_method":"private String _encodeCacheKey(Serializable primaryKeyObj) {\n\t\tCacheKeyGenerator cacheKeyGenerator =\n\t\t\tCacheKeyGeneratorUtil.getCacheKeyGenerator(CACHE_NAME);\n\n\t\treturn cacheKeyGenerator.getCacheKey(primaryKeyObj.toString());\n\t}","commit_id":"6493571a2c7be7927f43b2ca741a7827b949a934","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _encodeLocalCacheKey(\n\t\tClass<?> classObj, Serializable primaryKeyObj) {\n\n\t\treturn CacheKeyGeneratorUtil.getCacheKeyGenerator(CACHE_NAME)\n\t\t\t.append(classObj.getName())\n\t\t\t.append(primaryKeyObj.toString())\n\t\t\t.finish();\n\t}","id":95370,"modified_method":"private String _encodeLocalCacheKey(\n\t\tClass<?> classObj, Serializable primaryKeyObj) {\n\n\t\tCacheKeyGenerator cacheKeyGenerator =\n\t\t\tCacheKeyGeneratorUtil.getCacheKeyGenerator(CACHE_NAME);\n\n\t\tcacheKeyGenerator.append(classObj.getName());\n\t\tcacheKeyGenerator.append(primaryKeyObj.toString());\n\n\t\treturn cacheKeyGenerator.finish();\n\t}","commit_id":"6493571a2c7be7927f43b2ca741a7827b949a934","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String encodeLocalCacheKey(Object[] args) {\n\t\tStringBundler sb = new StringBundler(args.length * 2 + 1);\n\n\t\tsb.append(_localCacheKeyPrefix);\n\n\t\tfor (Object arg : args) {\n\t\t\tsb.append(StringPool.PERIOD);\n\t\t\tsb.append(String.valueOf(arg));\n\t\t}\n\n\t\treturn CacheKeyGeneratorUtil.getCacheKeyGenerator(\n\t\t\tFinderCache.class.getName()).getCacheKey(sb);\n\t}","id":95371,"modified_method":"public String encodeLocalCacheKey(Object[] args) {\n\t\tStringBundler sb = new StringBundler(args.length * 2 + 1);\n\n\t\tsb.append(_localCacheKeyPrefix);\n\n\t\tfor (Object arg : args) {\n\t\t\tsb.append(StringPool.PERIOD);\n\t\t\tsb.append(String.valueOf(arg));\n\t\t}\n\n\t\tCacheKeyGenerator cacheKeyGenerator =\n\t\t\tCacheKeyGeneratorUtil.getCacheKeyGenerator(\n\t\t\t\tFinderCache.class.getName());\n\n\t\treturn cacheKeyGenerator.getCacheKey(sb);\n\t}","commit_id":"6493571a2c7be7927f43b2ca741a7827b949a934","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String encodeCacheKey(Object[] args) {\n\t\tStringBundler sb = new StringBundler(args.length * 2 + 1);\n\n\t\tsb.append(_cacheKeyPrefix);\n\n\t\tfor (Object arg : args) {\n\t\t\tsb.append(StringPool.PERIOD);\n\t\t\tsb.append(String.valueOf(arg));\n\t\t}\n\n\t\treturn CacheKeyGeneratorUtil.getCacheKeyGenerator(\n\t\t\tFinderCache.class.getName()).getCacheKey(sb);\n\t}","id":95372,"modified_method":"public String encodeCacheKey(Object[] args) {\n\t\tStringBundler sb = new StringBundler(args.length * 2 + 1);\n\n\t\tsb.append(_cacheKeyPrefix);\n\n\t\tfor (Object arg : args) {\n\t\t\tsb.append(StringPool.PERIOD);\n\t\t\tsb.append(String.valueOf(arg));\n\t\t}\n\n\t\tCacheKeyGenerator cacheKeyGenerator =\n\t\t\tCacheKeyGeneratorUtil.getCacheKeyGenerator(\n\t\t\t\tFinderCache.class.getName());\n\n\t\treturn cacheKeyGenerator.getCacheKey(sb);\n\t}","commit_id":"6493571a2c7be7927f43b2ca741a7827b949a934","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CacheKeyGenerator clone() {\n\t\ttry {\n\t\t\treturn new JavaMD5CacheKeyGenerator(_maxLength);\n\t\t} catch (NoSuchAlgorithmException ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Fail to look up MD5 digester.\", ex);\n\t\t}\n\t}","id":95373,"modified_method":"public CacheKeyGenerator clone() {\n\t\ttry {\n\t\t\treturn new JavaMD5CacheKeyGenerator(_maxLength);\n\t\t}\n\t\tcatch (NoSuchAlgorithmException nsae) {\n\t\t\tthrow new IllegalStateException(nsae.getMessage(), nsae);\n\t\t}\n\t}","commit_id":"6493571a2c7be7927f43b2ca741a7827b949a934","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DocumentId getCurrentDocumentId() {\r\n\t\treturn tableModel.getCurrentDocumentId();\r\n\t}","id":95374,"modified_method":"public DocumentId getDocumentId() {\r\n\t\treturn tableModel.getDocumentId();\r\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setCurrentDocumentId(DocumentId currentDocumentId) {\r\n\t\ttableModel.setCurrentDocumentId(currentDocumentId);\r\n\t\tclearCache();\r\n\t}","id":95375,"modified_method":"public void setDocumentId(DocumentId documentId) {\r\n\t\tclearCache();\r\n\t\ttableModel.setDocumentId(documentId);\r\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n\tpublic TableEditorPresenter(final Display display, final EventBus eventBus) {\n\t\tsuper(display, eventBus);\n\t}","id":95376,"modified_method":"@Inject\n\tpublic TableEditorPresenter(final Display display, final EventBus eventBus, final TableEditorCachedTableModel tableModel) {\n\t\tsuper(display, eventBus);\n\t\tthis.tableModel = tableModel;\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tprotected void onBind() {\n\t\t\n\t\tregisterHandler(display.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\tif(event.getSelectedItem() != currentSelection) {\n\t\t\t\t\tcurrentSelection = event.getSelectedItem();\n\t\t\t\t\teventBus.fireEvent(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\tregisterHandler(\n\t\t\t\teventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onDocumentSelected(DocumentSelectionEvent event) {\n\t\t\t\t\t\tif(!event.getDocumentId().equals(currentDocumentId)) {\n\t\t\t\t\t\t\tdisplay.getCachedTableModel().setCurrentDocumentId(event.getDocumentId());\n\t\t\t\t\t\t\tgetDisplay().getPageNavigation().gotoPage(0, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t\n\t\tdisplay.getPageNavigation().gotoFirstPage();\n\t\t\n\t}","id":95377,"modified_method":"@Override\n\tprotected void onBind() {\n\t\t\n\t\tregisterHandler(display.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\tif(event.getSelectedItem() != currentSelection) {\n\t\t\t\t\tcurrentSelection = event.getSelectedItem();\n\t\t\t\t\teventBus.fireEvent(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\tregisterHandler(\n\t\t\t\teventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onDocumentSelected(DocumentSelectionEvent event) {\n\t\t\t\t\t\tif(!event.getDocumentId().equals(documentId)) {\n\t\t\t\t\t\t\ttableModel.setDocumentId(event.getDocumentId());\n\t\t\t\t\t\t\tdisplay.getPageNavigation().gotoPage(0, true);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t\n\t\tdisplay.getPageNavigation().gotoFirstPage();\n\t\t\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DocumentId getCurrentDocumentId() {\n\t\treturn currentDocumentId;\n\t}","id":95378,"modified_method":"public DocumentId getDocumentId() {\n\t\treturn documentId;\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setCurrentDocumentId(DocumentId currentDocumentId) {\n\t\tthis.currentDocumentId = currentDocumentId;\n\t}","id":95379,"modified_method":"public void setDocumentId(DocumentId documentId) {\n\t\tthis.documentId = documentId;\n\t\tthis.setRowCount(UNKNOWN_ROW_COUNT);\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic void requestRows(\n\t\t\tfinal Request request,\n\t\t\tfinal Callback<TransUnit> callback) {\n\t\tint numRows = request.getNumRows();\n\t\tint startRow = request.getStartRow();\n\t\tLog.debug(\"Table requesting\" + numRows + \" starting from \"+ startRow);\n\t\t\n\t\tif(currentDocumentId == null){\n\t\t\tcallback.onFailure(new RuntimeException(\"No DocumentId\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdispatcher.execute(new GetTransUnits(currentDocumentId, workspaceContext.getLocaleId(), startRow, numRows), new AsyncCallback<GetTransUnitsResult>() {\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GetTransUnitsResult result) {\n\t\t\t\tSerializableResponse<TransUnit> response = new SerializableResponse<TransUnit>(\n\t\t\t\t\t\tresult.getUnits());\n\t\t\t\tLog.debug(\"Got \" + result.getUnits().size() +\" rows back\");\n\t\t\t\tcallback.onRowsReady(request, response);\n\t\t\t\tsetRowCount(result.getTotalCount());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\tif(caught instanceof AuthenticationError) {\n\t\t\t\t\teventBus.fireEvent( new NotificationEvent(Severity.Error, \"Not logged in!\"));\n\t\t\t\t}\n\t\t\t\telse if(caught instanceof AuthorizationError) {\n\t\t\t\t\teventBus.fireEvent( new NotificationEvent(Severity.Error, \"Failed to load data from Server\"));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\teventBus.fireEvent( new NotificationEvent(Severity.Error, \"An unknown error occured\"));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":95380,"modified_method":"@Override\n\tpublic void requestRows(\n\t\t\tfinal Request request,\n\t\t\tfinal Callback<TransUnit> callback) {\n\t\tint numRows = request.getNumRows();\n\t\tint startRow = request.getStartRow();\n\t\tLog.debug(\"Table requesting\" + numRows + \" starting from \"+ startRow);\n\t\t\n\t\tif(documentId == null){\n\t\t\tcallback.onFailure(new RuntimeException(\"No DocumentId\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdispatcher.execute(new GetTransUnits(documentId, workspaceContext.getLocaleId(), startRow, numRows), new AsyncCallback<GetTransUnitsResult>() {\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GetTransUnitsResult result) {\n\t\t\t\tSerializableResponse<TransUnit> response = new SerializableResponse<TransUnit>(\n\t\t\t\t\t\tresult.getUnits());\n\t\t\t\tLog.debug(\"Got \" + result.getUnits().size() +\" rows back\");\n\t\t\t\tcallback.onRowsReady(request, response);\n\t\t\t\tsetRowCount(result.getTotalCount());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\tif(caught instanceof AuthenticationError) {\n\t\t\t\t\teventBus.fireEvent( new NotificationEvent(Severity.Error, \"Not logged in!\"));\n\t\t\t\t}\n\t\t\t\telse if(caught instanceof AuthorizationError) {\n\t\t\t\t\teventBus.fireEvent( new NotificationEvent(Severity.Error, \"Failed to load data from Server\"));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\teventBus.fireEvent( new NotificationEvent(Severity.Error, \"An unknown error occured\"));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic void startProcessing() {\n\t}","id":95381,"modified_method":"@Override\n\tpublic void startProcessing() {\n\t\tsetVisible(false);\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n\tpublic TableEditorView(TableEditorTableModel tableModel) {\n\t\tthis(tableModel, new TableEditorTableDefinition());\n\t}","id":95382,"modified_method":"@Inject\n\tpublic TableEditorView(TableEditorCachedTableModel tableModel) {\n\t\tthis(tableModel, new TableEditorTableDefinition());\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TableEditorView(TableEditorTableModel tableModel, TableEditorTableDefinition tableDefinition) {\n\t\tsuper(tableModel,tableDefinition);\n\t\t\n\t\tthis.tableModel = tableModel;\n\t\tcachedTableModel = new TableEditorCachedTableModel(tableModel);\n\t\t\n\t\tsetSize(\"100%\", \"100%\");\n\t\ttableDefinition.setRowRenderer( new TableEditorRowRenderer());\n\t\tsetPageSize(50);\n\t\tsetEmptyTableWidget(new HTML(\n\t\t\t\t\"There is no data to display\"));\n\n\t\t// Setup the bulk renderer\n\t\tFixedWidthGridBulkRenderer<TransUnit> bulkRenderer = new FixedWidthGridBulkRenderer<TransUnit>(\n\t\t\t\tgetDataTable(), this);\n\t\tsetBulkRenderer(bulkRenderer);\n\n\t\t// Setup the formatting\n\t\tsetCellPadding(3);\n\t\tsetCellSpacing(0);\n\t\tsetResizePolicy(ScrollTable.ResizePolicy.FILL_WIDTH);\n\t\t\n\t\tgetDataTable().setSelectionPolicy(SelectionPolicy.ONE_ROW);\n\t\tgetDataTable().setCellPadding(3);\n\t\t\n\t\tgetDataTable().addRowSelectionHandler(new RowSelectionHandler() {\n\t\t\t@Override\n\t\t\tpublic void onRowSelection(RowSelectionEvent event) {\n\t\t\t\tif(!event.getSelectedRows().isEmpty()){\n\t\t\t\t\tRow row = event.getSelectedRows().iterator().next();\n\t\t\t\t\tTransUnit tu = getRowValue(row.getRowIndex());\n\t\t\t\t\tSelectionEvent.fire(TableEditorView.this, tu);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t}","id":95383,"modified_method":"public TableEditorView(TableEditorCachedTableModel tableModel, TableEditorTableDefinition tableDefinition) {\n\t\tsuper(tableModel,tableDefinition);\n\t\t\n\t\tsetSize(\"100%\", \"100%\");\n\t\ttableDefinition.setRowRenderer( new TableEditorRowRenderer());\n\t\tsetPageSize(50);\n\t\tsetEmptyTableWidget(new HTML(\n\t\t\t\t\"There is no data to display\"));\n\n\t\t// Setup the bulk renderer\n\t\tFixedWidthGridBulkRenderer<TransUnit> bulkRenderer = new FixedWidthGridBulkRenderer<TransUnit>(\n\t\t\t\tgetDataTable(), this);\n\t\tsetBulkRenderer(bulkRenderer);\n\n\t\t// Setup the formatting\n\t\tsetCellPadding(3);\n\t\tsetCellSpacing(0);\n\t\tsetResizePolicy(ScrollTable.ResizePolicy.FILL_WIDTH);\n\t\t\n\t\tgetDataTable().setSelectionPolicy(SelectionPolicy.ONE_ROW);\n\t\tgetDataTable().setCellPadding(3);\n\t\tgetDataTable().addRowSelectionHandler(new RowSelectionHandler() {\n\t\t\t@Override\n\t\t\tpublic void onRowSelection(RowSelectionEvent event) {\n\t\t\t\tif(!event.getSelectedRows().isEmpty()){\n\t\t\t\t\tRow row = event.getSelectedRows().iterator().next();\n\t\t\t\t\tTransUnit tu = getRowValue(row.getRowIndex());\n\t\t\t\t\tSelectionEvent.fire(TableEditorView.this, tu);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic void stopProcessing() {\n\t}","id":95384,"modified_method":"@Override\n\tpublic void stopProcessing() {\n\t\tsetVisible(true);\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n\t * The Binding EDSL is described in {@link com.google.inject.Binder}\n\t */\n\t@Override\n\tprotected void configure() {\t\t\n\t\tbind(EventBus.class).to(DefaultEventBus.class).in(Singleton.class);\n\t\tbind(PlaceManager.class).in(Singleton.class);\n\t\t\n\t\tbindPresenter(AppPresenter.class, AppPresenter.Display.class, AppView.class);\n\t\tbindPresenter(DocumentListPresenter.class, DocumentListPresenter.Display.class, DocumentListView.class);\n\t\tbindPresenter(FilterPresenter.class, FilterPresenter.Display.class, FilterView.class);\n\t\tbindPresenter(PhraseFilterPresenter.class, PhraseFilterPresenter.Display.class, PhraseFilterWidget.class);\n\t\tbindPresenter(TableEditorPresenter.class, TableEditorPresenter.Display.class, TableEditorView.class);\n\t\tbindPresenter(WestNavigationPresenter.class, WestNavigationPresenter.Display.class, WestNavigationView.class);\n\t\tbindPresenter(WorkspaceUsersPresenter.class, WorkspaceUsersPresenter.Display.class, WorkspaceUsersView.class);\n\t\tbindPresenter(WebTransEditorPresenter.class, WebTransEditorPresenter.Display.class, WebTransEditorView.class);\n\t\tbindPresenter(LoginPresenter.class, LoginPresenter.Display.class, LoginPanel.class);\n\t\tbindPresenter(TranslationStatsBarPresenter.class, TranslationStatsBarPresenter.Display.class, TranslationStatsBar.class);\n\t\t\n\t\tbind(HasPageNavigation.class).to(TableEditorView.class).in(Singleton.class);\n\n\t\t// NB: if we bind directly to SeamDispatchAsync, we can't use replace-class in\n\t\t// the module definition unless the replacement extends SeamDispatchAsync\n\t\tbind(DispatchAsync.class).to(DelegatingDispatchAsync.class).in(Singleton.class);\n\t\t\n\t\tbind(Identity.class).to(IdentityImpl.class).in(Singleton.class);\n\t}","id":95385,"modified_method":"/**\n\t * The Binding EDSL is described in {@link com.google.inject.Binder}\n\t */\n\t@Override\n\tprotected void configure() {\t\t\n\t\tbind(EventBus.class).to(DefaultEventBus.class).in(Singleton.class);\n\t\tbind(PlaceManager.class).in(Singleton.class);\n\t\t\n\t\tbind(TableEditorCachedTableModel.class).in(Singleton.class);\n\t\t\n\t\tbindPresenter(AppPresenter.class, AppPresenter.Display.class, AppView.class);\n\t\tbindPresenter(DocumentListPresenter.class, DocumentListPresenter.Display.class, DocumentListView.class);\n\t\tbindPresenter(FilterPresenter.class, FilterPresenter.Display.class, FilterView.class);\n\t\tbindPresenter(PhraseFilterPresenter.class, PhraseFilterPresenter.Display.class, PhraseFilterWidget.class);\n\t\tbindPresenter(TableEditorPresenter.class, TableEditorPresenter.Display.class, TableEditorView.class);\n\t\tbindPresenter(WestNavigationPresenter.class, WestNavigationPresenter.Display.class, WestNavigationView.class);\n\t\tbindPresenter(WorkspaceUsersPresenter.class, WorkspaceUsersPresenter.Display.class, WorkspaceUsersView.class);\n\t\tbindPresenter(WebTransEditorPresenter.class, WebTransEditorPresenter.Display.class, WebTransEditorView.class);\n\t\tbindPresenter(LoginPresenter.class, LoginPresenter.Display.class, LoginPanel.class);\n\t\tbindPresenter(TranslationStatsBarPresenter.class, TranslationStatsBarPresenter.Display.class, TranslationStatsBar.class);\n\t\t\n\t\tbind(HasPageNavigation.class).to(TableEditorView.class).in(Singleton.class);\n\n\t\t// NB: if we bind directly to SeamDispatchAsync, we can't use replace-class in\n\t\t// the module definition unless the replacement extends SeamDispatchAsync\n\t\tbind(DispatchAsync.class).to(DelegatingDispatchAsync.class).in(Singleton.class);\n\t\t\n\t\tbind(Identity.class).to(IdentityImpl.class).in(Singleton.class);\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public WebTransEditorMenubar() {\n\t\tsetStylePrimaryName(\"WebTransEditor\");\n\t\taddStyleDependentName(\"MenuBar\");\n\t\tsetHeight(\"20px\");\n\t\tsetWidth(\"100%\");\n\t\tsetVerticalAlignment(HorizontalPanel.ALIGN_MIDDLE);\n\t\tthis.leftWidget = new Label();\n\t\tthis.middleWidget = new Label();\n\t\tthis.rightWidget = new Label();\n\t}","id":95386,"modified_method":"public WebTransEditorMenubar() {\n\t\tsetStylePrimaryName(\"WebTransEditor\");\n\t\taddStyleDependentName(\"MenuBar\");\n\t\tsetHeight(\"20px\");\n\t\tsetWidth(\"100%\");\n\t\tsetVerticalAlignment(HorizontalPanel.ALIGN_MIDDLE);\n\t\tsetLeftWidget(new Label());\n\t\tsetMiddleWidget(new Label());\n\t\tsetRightWidget(new Label());\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setMiddleWidget(Widget middleWidget) {\n\t\tthis.middleWidget.removeFromParent();\n\t\tthis.middleWidget = middleWidget;\n\t\tinsert(middleWidget, 1);\n\t\tsetCellHorizontalAlignment(this.middleWidget, HorizontalPanel.ALIGN_CENTER);\n\t}","id":95387,"modified_method":"public void setMiddleWidget(Widget middleWidget) {\n\t\tif(this.middleWidget != null)\n\t\t\tthis.middleWidget.removeFromParent();\n\t\tthis.middleWidget = middleWidget;\n\t\tinsert(middleWidget, 1);\n\t\tsetCellHorizontalAlignment(this.middleWidget, HorizontalPanel.ALIGN_CENTER);\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setLeftWidget(Widget leftWidget) {\n\t\tthis.leftWidget.removeFromParent();\n\t\tthis.leftWidget = leftWidget;\n\t\tinsert(leftWidget, 0);\n\t\tsetCellHorizontalAlignment(this.leftWidget, HorizontalPanel.ALIGN_LEFT);\n\t}","id":95388,"modified_method":"public void setLeftWidget(Widget leftWidget) {\n\t\tif(this.leftWidget != null)\n\t\t\tthis.leftWidget.removeFromParent();\n\t\tthis.leftWidget = leftWidget;\n\t\tinsert(leftWidget, 0);\n\t\tsetCellHorizontalAlignment(this.leftWidget, HorizontalPanel.ALIGN_LEFT);\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setRightWidget(Widget rightWidget) {\n\t\tthis.rightWidget.removeFromParent();\n\t\tthis.rightWidget = rightWidget;\n\t\tinsert(rightWidget, 2);\n\t\tsetCellHorizontalAlignment(this.rightWidget, HorizontalPanel.ALIGN_RIGHT);\n\t}","id":95389,"modified_method":"public void setRightWidget(Widget rightWidget) {\n\t\tif(this.rightWidget != null)\n\t\t\tthis.rightWidget.removeFromParent();\n\t\tthis.rightWidget = rightWidget;\n\t\tinsert(rightWidget, 2);\n\t\tsetCellHorizontalAlignment(this.rightWidget, HorizontalPanel.ALIGN_RIGHT);\n\t}","commit_id":"df6b8ea06ba12d57b6a81c4231307ab9ff793239","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph( personRepository );\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","id":95390,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"4672e6e3e6ccbe356d4270e41413c9b8c60da6b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph( personRepository );\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","id":95391,"modified_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph();\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","commit_id":"4672e6e3e6ccbe356d4270e41413c9b8c60da6b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph( personRepository );\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","id":95392,"modified_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph();\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","commit_id":"4672e6e3e6ccbe356d4270e41413c9b8c60da6b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void deleteSocialGraph( PersonRepository personRepository )\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","id":95393,"modified_method":"private void deleteSocialGraph()\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","commit_id":"4672e6e3e6ccbe356d4270e41413c9b8c60da6b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = new ArrayList<StatusUpdate>();\n        IteratorUtil.addToCollection( person.friendStatuses(), updates );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","id":95394,"modified_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = getArrayList( person.friendStatuses() );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","commit_id":"4672e6e3e6ccbe356d4270e41413c9b8c60da6b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph( personRepository );\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","id":95395,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"bc28c572968db5ac33ed7eda52c8d96c9a8438be","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph( personRepository );\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","id":95396,"modified_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph();\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","commit_id":"bc28c572968db5ac33ed7eda52c8d96c9a8438be","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph( personRepository );\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","id":95397,"modified_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph();\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","commit_id":"bc28c572968db5ac33ed7eda52c8d96c9a8438be","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void deleteSocialGraph( PersonRepository personRepository )\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","id":95398,"modified_method":"private void deleteSocialGraph()\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","commit_id":"bc28c572968db5ac33ed7eda52c8d96c9a8438be","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = new ArrayList<StatusUpdate>();\n        IteratorUtil.addToCollection( person.friendStatuses(), updates );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","id":95399,"modified_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = getArrayList( person.friendStatuses() );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","commit_id":"bc28c572968db5ac33ed7eda52c8d96c9a8438be","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph( personRepository );\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","id":95400,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"8d7f3bcc946b970ff950c4a41b756a575f9dcc5f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph( personRepository );\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","id":95401,"modified_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph();\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","commit_id":"8d7f3bcc946b970ff950c4a41b756a575f9dcc5f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph( personRepository );\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","id":95402,"modified_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph();\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","commit_id":"8d7f3bcc946b970ff950c4a41b756a575f9dcc5f","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void deleteSocialGraph( PersonRepository personRepository )\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","id":95403,"modified_method":"private void deleteSocialGraph()\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","commit_id":"8d7f3bcc946b970ff950c4a41b756a575f9dcc5f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = new ArrayList<StatusUpdate>();\n        IteratorUtil.addToCollection( person.friendStatuses(), updates );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","id":95404,"modified_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = getArrayList( person.friendStatuses() );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","commit_id":"8d7f3bcc946b970ff950c4a41b756a575f9dcc5f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph( personRepository );\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","id":95405,"modified_method":"@Before\n    public void setup()\n    {\n        graphDb = new EmbeddedGraphDatabase( \"target/socnetdb\" );\n        index = new LuceneIndexService( graphDb );\n        personRepository = new PersonRepository( graphDb, index );\n        deleteSocialGraph();\n\n        nrOfPersons = 20;\n        createPersons();\n        setupFriendsBetweenPeople( 10 );\n    }","commit_id":"2c1df40aacdc634ac9cd9ffbefd3e9d8aa565df3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = new ArrayList<StatusUpdate>();\n        IteratorUtil.addToCollection( person.friendStatuses(), updates );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","id":95406,"modified_method":"@Test\n    public void retrieveStatusUpdatesInDateOrder() throws Exception\n    {\n        Person person = getRandomPersonWithFriends();\n        int numberOfStatuses = 20;\n\n        for ( int i = 0; i < numberOfStatuses; i++ )\n        {\n            Person friend = getRandomFriendOf( person );\n            friend.addStatus( \"Dum-deli-dum...\" );\n        }\n\n        ArrayList<StatusUpdate> updates = getArrayList( person.friendStatuses() );\n        assertThat( updates.size(), equalTo( numberOfStatuses ) );\n        assertUpdatesAreSortedByDate( updates );\n    }","commit_id":"2c1df40aacdc634ac9cd9ffbefd3e9d8aa565df3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph( personRepository );\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","id":95407,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathsAreEquals( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"2c1df40aacdc634ac9cd9ffbefd3e9d8aa565df3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void deleteSocialGraph( PersonRepository personRepository )\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","id":95408,"modified_method":"private void deleteSocialGraph()\n    {\n        for ( Person person : personRepository.getAllPersons() )\n        {\n            personRepository.deletePerson( person );\n        }\n    }","commit_id":"2c1df40aacdc634ac9cd9ffbefd3e9d8aa565df3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph( personRepository );\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","id":95409,"modified_method":"@After\n    public void teardown()\n    {\n        try\n        {\n            deleteSocialGraph();\n        }\n        finally\n        {\n            index.shutdown();\n            graphDb.shutdown();\n        }\n    }","commit_id":"2c1df40aacdc634ac9cd9ffbefd3e9d8aa565df3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public long getThreadId() {\n        return getRequestPacket().getThreadId();\n    }","id":95410,"modified_method":"@Override\n    public long getThreadId() {\n        final ICMPv6EchoRequest requestPacket = getRequestPacket();\n        return requestPacket == null? 0l : requestPacket.getThreadId();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public int getIdentifier() {\n        return getRequestPacket().getIdentifier();\n    }","id":95411,"modified_method":"@Override\n    public int getIdentifier() {\n        final ICMPv6EchoRequest requestPacket = getRequestPacket();\n        return requestPacket == null? 0 : requestPacket.getIdentifier();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public long getSentTimeNanos() {\n        return getRequestPacket().getSentTime() * 1000000;\n    }","id":95412,"modified_method":"@Override\n    public long getSentTimeNanos() {\n        final ICMPv6EchoRequest requestPacket = getRequestPacket();\n        return requestPacket == null? 0l : requestPacket.getSentTime() * 1000000;\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public long getReceivedTimeNanos() {\n        return getRequestPacket().getReceiveTime() * 1000000;\n    }","id":95413,"modified_method":"@Override\n    public long getReceivedTimeNanos() {\n        final ICMPv6EchoRequest requestPacket = getRequestPacket();\n        return requestPacket == null? 0l : requestPacket.getReceiveTime() * 1000000;\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public int getSequenceNumber() {\n        return getRequestPacket().getSequenceNumber();\n    }","id":95414,"modified_method":"@Override\n    public int getSequenceNumber() {\n        final ICMPv6EchoRequest requestPacket = getRequestPacket();\n        return requestPacket == null? 0 : requestPacket.getSequenceNumber();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean isEchoReply() {\n        return getRequestPacket().getType() == Type.EchoReply;\n    }","id":95415,"modified_method":"@Override\n    public boolean isEchoReply() {\n        final ICMPv6EchoRequest requestPacket = getRequestPacket();\n        return requestPacket == null? false : requestPacket.getType() == Type.EchoReply;\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public double elapsedTime(final TimeUnit timeUnit) {\n        // {@link org.opennms.protocols.icmp.ICMPEchoPacket.getPingRTT()} returns microseconds.\n        final double nanosPerUnit = TimeUnit.NANOSECONDS.convert(1, timeUnit);\n        return (getRequestPacket().getRoundTripTime() * 1000) / nanosPerUnit;\n    }","id":95416,"modified_method":"@Override\n    public double elapsedTime(final TimeUnit timeUnit) {\n        final ICMPv6EchoRequest requestPacket = getRequestPacket();\n        if (requestPacket == null) return 0d;\n\n        // {@link org.opennms.protocols.icmp.ICMPEchoPacket.getPingRTT()} returns microseconds.\n        final double nanosPerUnit = TimeUnit.NANOSECONDS.convert(1, timeUnit);\n        return (requestPacket.getRoundTripTime() * 1000) / nanosPerUnit;\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public long getThreadId() {\n        return getRequestPacket().getTID();\n    }","id":95417,"modified_method":"@Override\n    public long getThreadId() {\n        final ICMPEchoPacket requestPacket = getRequestPacket();\n        return requestPacket == null? 0 : requestPacket.getTID();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public int getIdentifier() {\n        return getRequestPacket().getIdentity();\n    }","id":95418,"modified_method":"@Override\n    public int getIdentifier() {\n        final ICMPEchoPacket requestPacket = getRequestPacket();\n        return requestPacket == null? 0 : requestPacket.getIdentity();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public int getSequenceNumber() {\n        return getRequestPacket().getSequenceId();\n    }","id":95419,"modified_method":"@Override\n    public int getSequenceNumber() {\n        final ICMPEchoPacket requestPacket = getRequestPacket();\n        return requestPacket == null? 0 : requestPacket.getSequenceId();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean isEchoReply() {\n        return getRequestPacket().isEchoReply();\n    }","id":95420,"modified_method":"@Override\n    public boolean isEchoReply() {\n        final ICMPEchoPacket requestPacket = getRequestPacket();\n        return requestPacket == null? false : requestPacket.isEchoReply();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public long getSentTimeNanos() {\n        return getRequestPacket().getSentTime();\n    }","id":95421,"modified_method":"@Override\n    public long getSentTimeNanos() {\n        final ICMPEchoPacket requestPacket = getRequestPacket();\n        return requestPacket == null? 0l : requestPacket.getSentTime();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public long getReceivedTimeNanos() {\n        return getRequestPacket().getReceivedTime();\n    }","id":95422,"modified_method":"@Override\n    public long getReceivedTimeNanos() {\n        final ICMPEchoPacket requestPacket = getRequestPacket();\n        return requestPacket == null? 0l : requestPacket.getReceivedTime();\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public double elapsedTime(TimeUnit timeUnit) {\n        // {@link org.opennms.protocols.icmp.ICMPEchoPacket.getPingRTT()} returns microseconds.\n        double nanosPerUnit = TimeUnit.NANOSECONDS.convert(1, timeUnit);\n        return (getRequestPacket().getPingRTT() * 1000) / nanosPerUnit;\n    }","id":95423,"modified_method":"@Override\n    public double elapsedTime(TimeUnit timeUnit) {\n        final ICMPEchoPacket requestPacket = getRequestPacket();\n        if (requestPacket == null) return 0d;\n        \n        // {@link org.opennms.protocols.icmp.ICMPEchoPacket.getPingRTT()} returns microseconds.\n        double nanosPerUnit = TimeUnit.NANOSECONDS.convert(1, timeUnit);\n        return (requestPacket.getPingRTT() * 1000) / nanosPerUnit;\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleTimeout(InetAddress address, EchoPacket request) {\n        try {\n            m_responseTimes[request.getSequenceNumber()] = null;\n        } finally {\n            m_latch.countDown();\n        }\n    }","id":95424,"modified_method":"/** {@inheritDoc} */\n    public void handleTimeout(InetAddress address, EchoPacket request) {\n        try {\n            if (request != null) {\n                m_responseTimes[request.getSequenceNumber()] = null;\n            }\n        } finally {\n            m_latch.countDown();\n        }\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, EchoPacket response) {\n        try {\n            m_responseTimes[response.getSequenceNumber()] = response.elapsedTime(TimeUnit.MICROSECONDS);\n        } finally {\n            m_latch.countDown();\n        }\n    }","id":95425,"modified_method":"/** {@inheritDoc} */\n    public void handleResponse(InetAddress address, EchoPacket response) {\n        try {\n            if (response != null) {\n                m_responseTimes[response.getSequenceNumber()] = response.elapsedTime(TimeUnit.MICROSECONDS);\n            }\n        } finally {\n            m_latch.countDown();\n        }\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public void handleError(InetAddress address, EchoPacket request, Throwable t) {\n        try {\n            m_responseTimes[request.getSequenceNumber()] = null;\n            m_error = t;\n        } finally {\n            m_latch.countDown();\n        }\n    }","id":95426,"modified_method":"/** {@inheritDoc} */\n    public void handleError(InetAddress address, EchoPacket request, Throwable t) {\n        try {\n            if (request != null) {\n                m_responseTimes[request.getSequenceNumber()] = null;\n            }\n            m_error = t;\n        } finally {\n            m_latch.countDown();\n        }\n    }","commit_id":"9c6cf8224b444eec39d798c6d6c336d9917f8e93","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Implements the <tt>SIPCommFrame<\/tt> close method, which is invoked when\n     * user presses the Esc key. Checks if the popup menu is visible and if\n     * this is the case hides it, otherwise saves the current history window\n     * size and location and disposes the window.\n     * @param isEscaped indicates if the window has been closed by pressing the\n     * Esc key\n     */\n    @Override\n    protected void close(boolean isEscaped)\n    {\n        if(chatConvPanel.getRightButtonMenu().isVisible())\n        {\n            chatConvPanel.getRightButtonMenu().setVisible(false);\n        }\n        else if(historyMenu.isPopupMenuVisible())\n        {\n            MenuSelectionManager.defaultManager().clearSelectedPath();\n        }\n        else\n        {\n            GuiActivator.getUIService().getHistoryWindowManager()\n                .removeHistoryWindowForContact(historyContact);\n\n            datesPanel.dispose();\n            chatConvPanel.dispose();\n\n            this.dispose();\n        }\n    }","id":95427,"modified_method":"/**\n     * Implements the <tt>SIPCommFrame<\/tt> close method, which is invoked when\n     * user presses the Esc key. Checks if the popup menu is visible and if\n     * this is the case hides it, otherwise saves the current history window\n     * size and location and disposes the window.\n     * @param isEscaped indicates if the window has been closed by pressing the\n     * Esc key\n     */\n    @Override\n    protected void close(boolean isEscaped)\n    {\n        /*\n         * Remove all listeners in order to have this instance ready for garbage\n         * collection.\n         */\n        history.removeSearchProgressListener(this);\n\n        if (basicInstantMessagings != null)\n        {\n            for (OperationSetBasicInstantMessaging basicInstantMessaging\n                : basicInstantMessagings)\n                basicInstantMessaging.removeMessageListener(this);\n            basicInstantMessagings = null;\n        }\n\n        if (chatRoom != null)\n        {\n            chatRoom.removeMessageListener(this);\n            chatRoom = null;\n        }\n\n        if(chatConvPanel != null\n            && chatConvPanel.getRightButtonMenu() != null\n            && chatConvPanel.getRightButtonMenu().isVisible())\n        {\n            chatConvPanel.getRightButtonMenu().setVisible(false);\n        }\n        else if(historyMenu != null && historyMenu.isPopupMenuVisible())\n        {\n            MenuSelectionManager.defaultManager().clearSelectedPath();\n        }\n        else\n        {\n            GuiActivator.getUIService().getHistoryWindowManager()\n                .removeHistoryWindowForContact(historyContact);\n\n            if(datesPanel != null)\n                datesPanel.dispose();\n\n            if(chatConvPanel != null)\n                chatConvPanel.dispose();\n\n            this.dispose();\n        }\n    }","commit_id":"19f30212f510d07fde26dd8792cbfe1cb95a33dc","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * <p>\n     * This constructor is called when an archive for a bundle is being\n     * reconstructed when the framework is restarted. Each archive receives\n     * a logger, a root directory, and its associated bundle identifier.\n     * The root directory is where any required state can be stored.\n     * <\/p>\n     * @param logger the logger to be used by the archive.\n     * @param archiveRootDir the archive root directory for storing state.\n     * @param id the bundle identifier associated with the archive.\n     * @throws Exception if any error occurs.\n    **/\n    public BundleArchive(Logger logger, File archiveRootDir)    \n        throws Exception\n    {\n        m_logger = logger;\n        m_archiveRootDir = archiveRootDir;\n\n        // Add a revision for the content.\n        revise(getCurrentLocation(), null);\n    }","id":95428,"modified_method":"/**\n     * <p>\n     * This constructor is called when an archive for a bundle is being\n     * reconstructed when the framework is restarted. Each archive receives\n     * a logger, a root directory, and its associated bundle identifier.\n     * The root directory is where any required state can be stored.\n     * <\/p>\n     * @param logger the logger to be used by the archive.\n     * @param archiveRootDir the archive root directory for storing state.\n     * @param id the bundle identifier associated with the archive.\n     * @throws Exception if any error occurs.\n    **/\n    public BundleArchive(Logger logger, File archiveRootDir)    \n        throws Exception\n    {\n        m_logger = logger;\n        m_archiveRootDir = archiveRootDir;\n\n        // Add a revision for each one that already exists in the file\n        // system. The file system might contain more than one revision\n        // if the bundle was updated in a previous session, but the\n        // framework was not refreshed; this might happen if the framework\n        // did not exit cleanly. We must create the existing revisions so\n        // that they can be properly purged.\n        int revisionCount = 0;\n        while (true)\n        {\n            // Count the number of existing revision directories, which\n            // will be in a directory named like:\n            //     \"${REVISION_DIRECTORY)${refresh-count}.${revision-count}\"\n            File revisionRootDir = new File(m_archiveRootDir,\n                REVISION_DIRECTORY + getRefreshCount() + \".\" + revisionCount);\n            if (!BundleCache.getSecureAction().fileExists(revisionRootDir))\n            {\n                break;\n            }\n\n            // Increment the revision count.\n            revisionCount++;\n        }\n\n        // If there are multiple revisions in the file system, then create\n        // an array that is big enough to hold all revisions minus one; the\n        // call below to revise() will add the most recent revision. NOTE: We\n        // do not actually need to add a real revision object for the older\n        // revisions since they will be purged immediately on framework startup.\n        if (revisionCount > 1)\n        {\n            m_revisions = new BundleRevision[revisionCount - 1];\n        }\n\n        // Add the revision object for the most recent revision.\n        revise(getCurrentLocation(), null);\n    }","commit_id":"01e802af34aaaa9faa6a8330d1ed51f2bc008f0b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * <p>\n     * This method removes all old revisions associated with the archive\n     * and keeps only the current revision.\n     * <\/p>\n     * @throws Exception if any error occurs.\n    **/\n    public synchronized void purge() throws Exception\n    {\n        // Get the current refresh count.\n        long refreshCount = getRefreshCount();\n        // Get the current revision count.\n        int count = getRevisionCount();\n\n        // Dispose and delete all but the current revision.\n        File revisionDir = null;\n        for (int i = 0; i < count - 1; i++)\n        {\n            m_revisions[i].dispose();\n            revisionDir = new File(m_archiveRootDir, REVISION_DIRECTORY + refreshCount + \".\" + i);\n            if (BundleCache.getSecureAction().fileExists(revisionDir))\n            {\n                BundleCache.deleteDirectoryTree(revisionDir);\n            }\n        }\n\n        // We still need to dispose the current revision, but we\n        // don't want to delete it, because we want to rename it\n        // to the new refresh level.\n        m_revisions[count - 1].dispose();\n\n        // Increment the refresh count.\n        setRefreshCount(refreshCount + 1);\n\n        // Rename the current revision directory to be the zero revision\n        // of the new refresh level.\n        File currentDir = new File(m_archiveRootDir, REVISION_DIRECTORY + (refreshCount + 1) + \".0\");\n        revisionDir = new File(m_archiveRootDir, REVISION_DIRECTORY + refreshCount + \".\" + (count - 1));\n        BundleCache.getSecureAction().renameFile(revisionDir, currentDir);\n\n        // Null the revision array since they are all invalid now.\n        m_revisions = null;\n        // Finally, recreate the revision for the current location.\n        BundleRevision revision = createRevisionFromLocation(getCurrentLocation(), null);\n        // Create new revision array.\n        m_revisions = new BundleRevision[] { revision };\n    }","id":95429,"modified_method":"/**\n     * <p>\n     * This method removes all old revisions associated with the archive\n     * and keeps only the current revision.\n     * <\/p>\n     * @throws Exception if any error occurs.\n    **/\n    public synchronized void purge() throws Exception\n    {\n        // Get the current refresh count.\n        long refreshCount = getRefreshCount();\n        // Get the current revision count.\n        int count = getRevisionCount();\n\n        // Dispose and delete all but the current revision.\n        File revisionDir = null;\n        for (int i = 0; i < count - 1; i++)\n        {\n            // Dispose of the revision, but this might be null in certain\n            // circumstances, such as if this bundle archive was created\n            // for an existing bundle that was updated, but not refreshed\n            // due to a system crash; see the constructor code for details.\n            if (m_revisions[i] != null)\n            {\n                m_revisions[i].dispose();\n            }\n            revisionDir = new File(m_archiveRootDir, REVISION_DIRECTORY + refreshCount + \".\" + i);\n            if (BundleCache.getSecureAction().fileExists(revisionDir))\n            {\n                BundleCache.deleteDirectoryTree(revisionDir);\n            }\n        }\n\n        // We still need to dispose the current revision, but we\n        // don't want to delete it, because we want to rename it\n        // to the new refresh level.\n        m_revisions[count - 1].dispose();\n\n        // Increment the refresh count.\n        setRefreshCount(refreshCount + 1);\n\n        // Rename the current revision directory to be the zero revision\n        // of the new refresh level.\n        File currentDir = new File(m_archiveRootDir, REVISION_DIRECTORY + (refreshCount + 1) + \".0\");\n        revisionDir = new File(m_archiveRootDir, REVISION_DIRECTORY + refreshCount + \".\" + (count - 1));\n        BundleCache.getSecureAction().renameFile(revisionDir, currentDir);\n\n        // Null the revision array since they are all invalid now.\n        m_revisions = null;\n        // Finally, recreate the revision for the current location.\n        BundleRevision revision = createRevisionFromLocation(getCurrentLocation(), null);\n        // Create new revision array.\n        m_revisions = new BundleRevision[] { revision };\n    }","commit_id":"01e802af34aaaa9faa6a8330d1ed51f2bc008f0b","url":"https://github.com/apache/felix"},{"original_method":"/**\n         * Is it a failed search?\n         */\n        public boolean isFailure() {\n            return failureMessage != null;\n        }","id":95430,"modified_method":"/**\n         * Is it a failed search?\n         */\n        public boolean isFailure() {\n            return throwable != null;\n        }","commit_id":"dc67bd0021555beefb9be8ef5c1606937baf812c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startArray(Fields.RESPONSES);\n        for (Item item : items) {\n            if (item.isFailure()) {\n                builder.startObject();\n                builder.field(Fields.ERROR, item.getFailureMessage());\n                builder.endObject();\n            } else {\n                builder.startObject();\n                item.getResponse().toXContent(builder, params);\n                builder.endObject();\n            }\n        }\n        builder.endArray();\n        return builder;\n    }","id":95431,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startArray(Fields.RESPONSES);\n        for (Item item : items) {\n            if (item.isFailure()) {\n                builder.startObject();\n                builder.startObject(Fields.ERROR);\n                final Throwable t = item.getFailure();\n                final ElasticsearchException[] rootCauses = ElasticsearchException.guessRootCauses(t);\n                builder.field(Fields.ROOT_CAUSE);\n                builder.startArray();\n                for (ElasticsearchException rootCause : rootCauses){\n                    builder.startObject();\n                    rootCause.toXContent(builder, new ToXContent.DelegatingMapParams(Collections.singletonMap(ElasticsearchException.REST_EXCEPTION_SKIP_CAUSE, \"true\"), params));\n                    builder.endObject();\n                }\n                builder.endArray();\n                ElasticsearchException.toXContent(builder, params, t);\n                builder.endObject();\n                builder.endObject();\n            } else {\n                builder.startObject();\n                item.getResponse().toXContent(builder, params);\n                builder.endObject();\n            }\n        }\n        builder.endArray();\n        return builder;\n    }","commit_id":"dc67bd0021555beefb9be8ef5c1606937baf812c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            if (response != null) {\n                out.writeBoolean(true);\n                response.writeTo(out);\n            } else {\n                out.writeBoolean(false);\n                out.writeString(failureMessage);\n            }\n        }","id":95432,"modified_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            if (response != null) {\n                out.writeBoolean(true);\n                response.writeTo(out);\n            } else {\n                out.writeBoolean(false);\n                out.writeThrowable(throwable);\n            }\n        }","commit_id":"dc67bd0021555beefb9be8ef5c1606937baf812c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            if (in.readBoolean()) {\n                this.response = new SearchResponse();\n                response.readFrom(in);\n            } else {\n                failureMessage = in.readString();\n            }\n        }","id":95433,"modified_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            if (in.readBoolean()) {\n                this.response = new SearchResponse();\n                response.readFrom(in);\n            } else {\n                throwable = in.readThrowable();\n            }\n        }","commit_id":"dc67bd0021555beefb9be8ef5c1606937baf812c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Item(SearchResponse response, String failureMessage) {\n            this.response = response;\n            this.failureMessage = failureMessage;\n        }","id":95434,"modified_method":"public Item(SearchResponse response, Throwable throwable) {\n            this.response = response;\n            this.throwable = throwable;\n        }","commit_id":"dc67bd0021555beefb9be8ef5c1606937baf812c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n         * The actual failure message, null if its not a failure.\n         */\n        @Nullable\n        public String getFailureMessage() {\n            return failureMessage;\n        }","id":95435,"modified_method":"/**\n         * The actual failure message, null if its not a failure.\n         */\n        @Nullable\n        public String getFailureMessage() {\n            return throwable == null ? null : throwable.getMessage();\n        }","commit_id":"dc67bd0021555beefb9be8ef5c1606937baf812c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doExecute(final MultiSearchRequest request, final ActionListener<MultiSearchResponse> listener) {\n        ClusterState clusterState = clusterService.state();\n        clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.READ);\n\n        final AtomicArray<MultiSearchResponse.Item> responses = new AtomicArray<>(request.requests().size());\n        final AtomicInteger counter = new AtomicInteger(responses.length());\n        for (int i = 0; i < responses.length(); i++) {\n            final int index = i;\n            SearchRequest searchRequest = new SearchRequest(request.requests().get(i), request);\n            searchAction.execute(searchRequest, new ActionListener<SearchResponse>() {\n                @Override\n                public void onResponse(SearchResponse searchResponse) {\n                    responses.set(index, new MultiSearchResponse.Item(searchResponse, null));\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    responses.set(index, new MultiSearchResponse.Item(null, ExceptionsHelper.detailedMessage(e)));\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                private void finishHim() {\n                    listener.onResponse(new MultiSearchResponse(responses.toArray(new MultiSearchResponse.Item[responses.length()])));\n                }\n            });\n        }\n    }","id":95436,"modified_method":"@Override\n    protected void doExecute(final MultiSearchRequest request, final ActionListener<MultiSearchResponse> listener) {\n        ClusterState clusterState = clusterService.state();\n        clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.READ);\n\n        final AtomicArray<MultiSearchResponse.Item> responses = new AtomicArray<>(request.requests().size());\n        final AtomicInteger counter = new AtomicInteger(responses.length());\n        for (int i = 0; i < responses.length(); i++) {\n            final int index = i;\n            SearchRequest searchRequest = new SearchRequest(request.requests().get(i), request);\n            searchAction.execute(searchRequest, new ActionListener<SearchResponse>() {\n                @Override\n                public void onResponse(SearchResponse searchResponse) {\n                    responses.set(index, new MultiSearchResponse.Item(searchResponse, null));\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    responses.set(index, new MultiSearchResponse.Item(null, e));\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                private void finishHim() {\n                    listener.onResponse(new MultiSearchResponse(responses.toArray(new MultiSearchResponse.Item[responses.length()])));\n                }\n            });\n        }\n    }","commit_id":"dc67bd0021555beefb9be8ef5c1606937baf812c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public List<RuleParam> params() {\n    List<RuleParam> params = new ArrayList<RuleParam>();\n    if(this.fields.get(RuleField.PARAMS.key()) != null) {\n      Collection<Object> esParams = (Collection<Object>) this.fields.get(RuleField.PARAMS.key());\n      for (Object temp : esParams) {\n        final Map<String, Object> param = (Map<String, Object>) temp;\n        params.add(new RuleParam() {\n          {\n            this.fields = param;\n          }\n\n          Map<String, Object> fields;\n\n          @Override\n          public String key() {\n            return (String) param.get(RuleNormalizer.RuleParamField.NAME.key());\n          }\n\n          @Override\n          public String description() {\n            return (String) param.get(RuleNormalizer.RuleParamField.DESCRIPTION.key());\n          }\n\n          @Override\n          public String defaultValue() {\n            return (String) param.get(RuleNormalizer.RuleParamField.DEFAULT_VALUE.key());\n          }\n\n          @Override\n          public RuleParamType type() {\n            return RuleParamType\n              .parse((String) param.get(RuleNormalizer.RuleParamField.TYPE.key()));\n          }\n        });\n      }\n    }\n    return params;\n  }","id":95437,"modified_method":"@Override\n  public List<RuleParam> params() {\n    List<RuleParam> params = new ArrayList<RuleParam>();\n    if(this.fields.get(RuleField.PARAMS.key()) != null) {\n      Collection<Object> esParams = (Collection<Object>) this.fields.get(RuleField.PARAMS.key());\n      for (Object temp : esParams) {\n        final Map<String, Object> param = (Map<String, Object>) temp;\n        params.add(new RuleParam() {\n          {\n            this.fields = param;\n          }\n\n          Map<String, Object> fields;\n\n          @Override\n          public String key() {\n            return (String) param.get(RuleNormalizer.RuleParamField.NAME.key());\n          }\n\n          @Override\n          public String description() {\n            return (String) param.get(RuleNormalizer.RuleParamField.DESCRIPTION.key());\n          }\n\n          @Override\n          public String defaultValue() {\n            return (String) param.get(RuleNormalizer.RuleParamField.VALUE.key());\n          }\n\n          @Override\n          public RuleParamType type() {\n            return RuleParamType\n              .parse((String) param.get(RuleNormalizer.RuleParamField.TYPE.key()));\n          }\n        });\n      }\n    }\n    return params;\n  }","commit_id":"b350d6c3cafaa10ffad8ea619d75cda5f0c88034","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public XContentBuilder normalize(RuleDto rule) throws IOException {\n    XContentBuilder document = jsonBuilder().startObject();\n    indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n    indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n    indexField(RuleField.NAME.key(), rule.getName(), document);\n    indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n    indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n    indexField(RuleField.DESCRIPTION.key(), rule.getDescription(), document);\n    indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n    indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n    indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n    indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n    indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n\n    /* Normalize the tags */\n    List<RuleRuleTagDto> tags = ruleDao.selectTagsByRuleId(rule.getId());\n    if (tags != null && !tags.isEmpty()) {\n      ArrayList<String> sys = new ArrayList<String>();\n      ArrayList<String> admin = new ArrayList<String>();\n      for (RuleRuleTagDto tag : tags) {\n        if (tag.getType().equals(RuleTagType.SYSTEM)) {\n          sys.add(tag.getTag());\n        } else {\n          admin.add(tag.getTag());\n        }\n      }\n      if (!admin.isEmpty()) {\n        document.array(RuleField.TAGS.key(), admin.toArray(new String[admin.size()]));\n      }\n      if (!sys.isEmpty()) {\n        document.array(RuleField.SYSTEM_TAGS.key(), sys.toArray(new String[sys.size()]));\n      }\n    }\n\n    /* Normalize the params */\n    List<RuleParamDto> params = ruleDao.selectParametersByRuleId(rule.getId());\n    if (!params.isEmpty()) {\n      document.startArray(RuleField.PARAMS.key());\n      for (RuleParamDto param : params) {\n        document.startObject();\n        indexField(RuleParamField.NAME.key(), param.getName(), document);\n        indexField(RuleParamField.TYPE.key(), param.getType(), document);\n        indexField(RuleParamField.DESCRIPTION.key(), param.getDescription(), document);\n        indexField(RuleParamField.DEFAULT_VALUE.key(), param.getDefaultValue(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Normalize activeRules */\n    List<ActiveRuleDto> activeRules = activeRuleDao.selectByRuleId(rule.getId());\n    if (!activeRules.isEmpty()) {\n      document.startArray(RuleField.ACTIVE.key());\n      for (ActiveRuleDto activeRule : activeRules) {\n        document.startObject();\n        indexField(ActiveRuleField.OVERRIDE.key(), activeRule.doesOverride(), document);\n        indexField(ActiveRuleField.INHERITANCE.key(), activeRule.getInheritance(), document);\n        indexField(ActiveRuleField.NOTE_CREATED.key(), activeRule.getNoteCreatedAt(), document);\n        indexField(ActiveRuleField.NOTE_UPDATED.key(), activeRule.getNoteUpdatedAt(), document);\n        indexField(ActiveRuleField.NOTE_DATA.key(), activeRule.getNoteData(), document);\n        indexField(ActiveRuleField.NOTE_USER.key(), activeRule.getNoteUserLogin(), document);\n        indexField(ActiveRuleField.PROFILE_ID.key(), activeRule.getProfileId(), document);\n        indexField(ActiveRuleField.SEVERITY.key(), activeRule.getSeverityString(), document);\n        indexField(ActiveRuleField.PARENT_ID.key(), activeRule.getParentId(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Done normalizing for Rule */\n    return document.endObject();\n  }","id":95438,"modified_method":"@Override\n  public XContentBuilder normalize(RuleDto rule) throws IOException {\n    XContentBuilder document = jsonBuilder().startObject();\n    indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n    indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n    indexField(RuleField.NAME.key(), rule.getName(), document);\n    indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n    indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n    indexField(RuleField.DESCRIPTION.key(), rule.getDescription(), document);\n    indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n    indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n    indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n    indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n    indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n\n    /* Normalize the tags */\n    List<RuleRuleTagDto> tags = ruleDao.selectTagsByRuleId(rule.getId());\n    if (tags != null && !tags.isEmpty()) {\n      ArrayList<String> sys = new ArrayList<String>();\n      ArrayList<String> admin = new ArrayList<String>();\n      for (RuleRuleTagDto tag : tags) {\n        if (tag.getType().equals(RuleTagType.SYSTEM)) {\n          sys.add(tag.getTag());\n        } else {\n          admin.add(tag.getTag());\n        }\n      }\n      if (!admin.isEmpty()) {\n        document.array(RuleField.TAGS.key(), admin.toArray(new String[admin.size()]));\n      }\n      if (!sys.isEmpty()) {\n        document.array(RuleField.SYSTEM_TAGS.key(), sys.toArray(new String[sys.size()]));\n      }\n    }\n\n    /* Normalize the params */\n    List<RuleParamDto> params = ruleDao.selectParametersByRuleId(rule.getId());\n    Map<Integer, String> paramIdNameLookup = new HashMap<Integer, String>();\n    if (!params.isEmpty()) {\n      document.startArray(RuleField.PARAMS.key());\n      for (RuleParamDto param : params) {\n        paramIdNameLookup.put(param.getId(), param.getName());\n        document.startObject();\n        indexField(RuleParamField.NAME.key(), param.getName(), document);\n        indexField(RuleParamField.TYPE.key(), param.getType(), document);\n        indexField(RuleParamField.DESCRIPTION.key(), param.getDescription(), document);\n        indexField(RuleParamField.VALUE.key(), param.getDefaultValue(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Normalize activeRules */\n    List<ActiveRuleDto> activeRules = activeRuleDao.selectByRuleId(rule.getId());\n    if (!activeRules.isEmpty()) {\n      document.startArray(RuleField.ACTIVE.key());\n      for (ActiveRuleDto activeRule : activeRules) {\n        document.startObject();\n        indexField(ActiveRuleField.OVERRIDE.key(), activeRule.doesOverride(), document);\n        indexField(ActiveRuleField.INHERITANCE.key(), activeRule.getInheritance(), document);\n        indexField(ActiveRuleField.NOTE_CREATED.key(), activeRule.getNoteCreatedAt(), document);\n        indexField(ActiveRuleField.NOTE_UPDATED.key(), activeRule.getNoteUpdatedAt(), document);\n        indexField(ActiveRuleField.NOTE_DATA.key(), activeRule.getNoteData(), document);\n        indexField(ActiveRuleField.NOTE_USER.key(), activeRule.getNoteUserLogin(), document);\n        indexField(ActiveRuleField.PROFILE_ID.key(), activeRule.getProfileId(), document);\n        indexField(ActiveRuleField.SEVERITY.key(), activeRule.getSeverityString(), document);\n        indexField(ActiveRuleField.PARENT_ID.key(), activeRule.getParentId(), document);\n\n        /* Get all activeRuleParams */\n        List<ActiveRuleParamDto> activeRuleParams = activeRuleDao.selectParamsByActiveRuleId(activeRule.getId());\n        if(!activeRuleParams.isEmpty()) {\n          document.startArray(ActiveRuleField.PARAMS.key());\n          for (ActiveRuleParamDto param : activeRuleParams) {\n            document.startObject();\n            indexField(RuleParamField.NAME.key(), param.getKey(), document);\n            indexField(RuleParamField.VALUE.key(), param.getValue(), document);\n            document.endObject();\n          }\n          document.endArray();\n        }\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Done normalizing for Rule */\n    return document.endObject();\n  }","commit_id":"b350d6c3cafaa10ffad8ea619d75cda5f0c88034","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public XContentBuilder normalize(RuleDto rule) throws IOException {\n    XContentBuilder document = jsonBuilder().startObject();\n    indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n    indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n    indexField(RuleField.NAME.key(), rule.getName(), document);\n    indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n    indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n    indexField(RuleField.DESCRIPTION.key(), rule.getDescription(), document);\n    indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n    indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n    indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n    indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n    indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n\n    /* Normalize the tags */\n    List<RuleRuleTagDto> tags = ruleDao.selectTagsByRuleId(rule.getId());\n    if (!tags.isEmpty()) {\n      XContentBuilder sysTags = document.startArray(RuleField.SYSTEM_TAGS.key());\n      XContentBuilder adminTags = document.startArray(RuleField.TAGS.key());\n\n      for (RuleRuleTagDto tag : tags) {\n        switch (tag.getType()) {\n          case SYSTEM:\n            sysTags.startObject(tag.getTag()).endObject();\n            break;\n          case ADMIN:\n            adminTags.startObject(tag.getTag()).endObject();\n            break;\n        }\n      }\n      sysTags.endArray();\n      adminTags.endArray();\n    }\n\n    /*Normalize the params */\n    List<RuleParamDto> params = ruleDao.selectParametersByRuleId(rule.getId());\n    document.startArray(RuleField.PARAMS.key());\n    if (!params.isEmpty()) {\n      for (RuleParamDto param :params) {\n        document.startObject();\n        indexField(RuleParamField.NAME.key(), param.getName(), document);\n        indexField(RuleParamField.TYPE.key(), param.getType(), document);\n        indexField(RuleParamField.DESCRIPTION.key(), param.getDescription(), document);\n        indexField(RuleParamField.DEFAULT_VALUE.key(), param.getDefaultValue(), document);\n        document.endObject();\n      }\n    }\n    document.endArray();\n\n\n    // document.startArray(\"active\");\n    // for (ActiveRuleDto activeRule : activeRuleDao.selectByRuleId(rule.getId())) {\n    // document.startObject();\n    // Map<String, Object> activeRuleProperties = BeanUtils.describe(activeRule);\n    // for (Entry<String, Object> activeRuleProp : activeRuleProperties.entrySet()) {\n    // LOG.trace(\"NORMALIZING: --- {} -> {}\", activeRuleProp.getKey(), activeRuleProp.getValue());\n    // document.field(activeRuleProp.getKey(), activeRuleProp.getValue());\n    // }\n    // document.endObject();\n    // }\n    // document.endArray();\n\n    return document.endObject();\n  }","id":95439,"modified_method":"@Override\n  public XContentBuilder normalize(RuleDto rule) throws IOException {\n    XContentBuilder document = jsonBuilder().startObject();\n    indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n    indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n    indexField(RuleField.NAME.key(), rule.getName(), document);\n    indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n    indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n    indexField(RuleField.DESCRIPTION.key(), rule.getDescription(), document);\n    indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n    indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n    indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n    indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n    indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n\n    /* Normalize the tags */\n    List<RuleRuleTagDto> tags = ruleDao.selectTagsByRuleId(rule.getId());\n    if (!tags.isEmpty()) {\n      XContentBuilder sysTags = document.startArray(RuleField.SYSTEM_TAGS.key());\n      XContentBuilder adminTags = document.startArray(RuleField.TAGS.key());\n\n      for (RuleRuleTagDto tag : tags) {\n        switch (tag.getType()) {\n          case SYSTEM:\n            sysTags.startObject(tag.getTag()).endObject();\n            break;\n          case ADMIN:\n            adminTags.startObject(tag.getTag()).endObject();\n            break;\n        }\n      }\n      sysTags.endArray();\n      adminTags.endArray();\n    }\n\n    /* Normalize the params */\n    List<RuleParamDto> params = ruleDao.selectParametersByRuleId(rule.getId());\n    if (!params.isEmpty()) {\n      document.startArray(RuleField.PARAMS.key());\n      for (RuleParamDto param :params) {\n        document.startObject();\n        indexField(RuleParamField.NAME.key(), param.getName(), document);\n        indexField(RuleParamField.TYPE.key(), param.getType(), document);\n        indexField(RuleParamField.DESCRIPTION.key(), param.getDescription(), document);\n        indexField(RuleParamField.DEFAULT_VALUE.key(), param.getDefaultValue(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Normalize activeRules */\n    List<ActiveRuleDto> activeRules = activeRuleDao.selectByRuleId(rule.getId());\n    if(!activeRules.isEmpty()) {\n      document.startArray(RuleField.ACTIVE.key());\n      for (ActiveRuleDto activeRule : activeRules) {\n        document.startObject();\n        indexField(ActiveRuleField.OVERRIDE.key(), activeRule.doesOverride(), document);\n        indexField(ActiveRuleField.INHERITANCE.key(), activeRule.getInheritance(), document);\n        indexField(ActiveRuleField.NOTE_CREATED.key(), activeRule.getNoteCreatedAt(), document);\n        indexField(ActiveRuleField.NOTE_UPDATED.key(), activeRule.getNoteUpdatedAt(), document);\n        indexField(ActiveRuleField.NOTE_DATA.key(), activeRule.getNoteData(), document);\n        indexField(ActiveRuleField.NOTE_USER.key(), activeRule.getNoteUserLogin(), document);\n        indexField(ActiveRuleField.PROFILE_ID.key(), activeRule.getProfileId(), document);\n        indexField(ActiveRuleField.SEVERITY.key(), activeRule.getSeverityString(), document);\n        indexField(ActiveRuleField.PARENT_ID.key(), activeRule.getParentId(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Done normalizing for Rule */\n    return document.endObject();\n  }","commit_id":"2248191e14451c2b9d2f90e3309e982622bab7b1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public RuleNormalizer(RuleDao ruleDao) {\n    this.ruleDao = ruleDao;\n  }","id":95440,"modified_method":"public RuleNormalizer(RuleDao ruleDao, ActiveRuleDao activeRuleDao) {\n    this.ruleDao = ruleDao;\n    this.activeRuleDao = activeRuleDao;\n  }","commit_id":"2248191e14451c2b9d2f90e3309e982622bab7b1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void insert_and_index_rule_parameters() {\n    DbSession dbSession = tester.get(MyBatis.class).openSession(false);\n\n    // insert db\n    RuleKey ruleKey = RuleKey.of(\"javascript\", \"S001\");\n    RuleDto ruleDto = newRuleDto(ruleKey);\n    dao.insert(ruleDto, dbSession);\n    RuleParamDto minParamDto = new RuleParamDto()\n      .setRuleId(ruleDto.getId())\n      .setName(\"min\")\n      .setType(RuleParamType.INTEGER.type())\n      .setDefaultValue(\"2\")\n      .setDescription(\"Minimum\");\n    dao.insert(minParamDto, dbSession);\n    RuleParamDto maxParamDto = new RuleParamDto()\n      .setRuleId(ruleDto.getId())\n      .setName(\"max\")\n      .setType(RuleParamType.INTEGER.type())\n      .setDefaultValue(\"10\")\n      .setDescription(\"Maximum\");\n    dao.insert(maxParamDto, dbSession);\n    dbSession.commit();\n\n    // verify that parameters are persisted in db\n    List<RuleParamDto> persistedDtos = dao.selectParametersByRuleId(ruleDto.getId());\n    assertThat(persistedDtos).hasSize(2);\n\n    // verify that parameters are indexed in es\n    index.refresh();\n    Hit hit = index.getByKey(ruleKey);\n    assertThat(hit).isNotNull();\n    assertThat(hit.getField(\"params\")).isNotNull();\n\n\n    RuleService service = tester.get(RuleService.class);\n    Rule rule = service.getByKey(ruleKey);\n\n    assertThat(rule.params()).hasSize(2);\n    assertThat(Iterables.getLast(rule.params(), null).key()).isEqualTo(\"max\");\n  }","id":95441,"modified_method":"@Test\n  public void insert_and_index_rule_parameters() {\n    DbSession dbSession = tester.get(MyBatis.class).openSession(false);\n\n    // insert db\n    RuleKey ruleKey = RuleKey.of(\"javascript\", \"S001\");\n    RuleDto ruleDto = newRuleDto(ruleKey);\n    dao.insert(ruleDto, dbSession);\n    RuleParamDto minParamDto = new RuleParamDto()\n      .setRuleId(ruleDto.getId())\n      .setName(\"min\")\n      .setType(RuleParamType.INTEGER.type())\n      .setDefaultValue(\"2\")\n      .setDescription(\"Minimum\");\n    dao.insert(minParamDto, dbSession);\n    RuleParamDto maxParamDto = new RuleParamDto()\n      .setRuleId(ruleDto.getId())\n      .setName(\"max\")\n      .setType(RuleParamType.INTEGER.type())\n      .setDefaultValue(\"10\")\n      .setDescription(\"Maximum\");\n    dao.insert(maxParamDto, dbSession);\n    dbSession.commit();\n\n    // verify that parameters are persisted in db\n    List<RuleParamDto> persistedDtos = dao.selectParametersByRuleId(ruleDto.getId());\n    assertThat(persistedDtos).hasSize(2);\n\n    // verify that parameters are indexed in es\n    index.refresh();\n    Hit hit = index.getByKey(ruleKey);\n    assertThat(hit).isNotNull();\n    assertThat(hit.getField(RuleNormalizer.RuleField.PARAMS.key())).isNotNull();\n\n\n    RuleService service = tester.get(RuleService.class);\n    Rule rule = service.getByKey(ruleKey);\n\n    assertThat(rule.params()).hasSize(2);\n    assertThat(Iterables.getLast(rule.params(), null).key()).isEqualTo(\"max\");\n  }","commit_id":"2248191e14451c2b9d2f90e3309e982622bab7b1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public BurningInquiry(UUID ownerId) {\r\n        super(ownerId, 128, \"Burning Inquiry\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{R}\");\r\n        this.expansionSetCode = \"M10\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Each player draws three cards, then discards three cards at random.\r\n        this.getSpellAbility().addEffect(new DrawCardAllEffect(3));\r\n        this.getSpellAbility().addEffect(new BurningInquiryEffect());\r\n    }","id":95442,"modified_method":"public BurningInquiry(UUID ownerId) {\r\n        super(ownerId, 128, \"Burning Inquiry\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{R}\");\r\n        this.expansionSetCode = \"M10\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Each player draws three cards, then discards three cards at random.\r\n        this.getSpellAbility().addEffect(new DrawCardAllEffect(3));\r\n        Effect effect = new DiscardEachPlayerEffect(3, true);\r\n        effect.setText(\"then discards three cards at random\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public CacklingFiend(UUID ownerId) {\n        super(ownerId, 121, \"Cackling Fiend\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{2}{B}{B}\");\n        this.expansionSetCode = \"USG\";\n        this.subtype.add(\"Zombie\");\n        this.color.setBlack(true);\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(1);\n\n        this.addAbility(FlyingAbility.getInstance());\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new CacklingFiendEffect(), false));\n    }","id":95443,"modified_method":"public CacklingFiend(UUID ownerId) {\n        super(ownerId, 121, \"Cackling Fiend\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{2}{B}{B}\");\n        this.expansionSetCode = \"USG\";\n        this.subtype.add(\"Zombie\");\n        this.color.setBlack(true);\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(1);\n\n        this.addAbility(FlyingAbility.getInstance());\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new DiscardEachPlayerEffect(TargetController.OPPONENT), false));\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public static String numberToText(String number) {\r\n        if (checkNumeric(number)) {\r\n            return numberToText(Integer.parseInt(number));\r\n        }\r\n        return number;\r\n    }","id":95444,"modified_method":"public static String numberToText(String number) {\r\n        return numberToText(number, \"one\");\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public DeathCloud(UUID ownerId) {\r\n        super(ownerId, 76, \"Death Cloud\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{X}{B}{B}{B}\");\r\n        this.expansionSetCode = \"MMA\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Each player loses X life, discards X cards, sacrifices X creatures, then sacrifices X lands.\r\n        DynamicValue xValue = new ManacostVariableValue();\r\n        this.getSpellAbility().addEffect(new LoseLifePlayersEffect(xValue));\r\n        this.getSpellAbility().addEffect(new DiscardEachPlayerEffect(xValue, false));\r\n        this.getSpellAbility().addEffect(new SacrificeAllEffect(xValue, new FilterControlledCreaturePermanent(\"creatures\")));\r\n        this.getSpellAbility().addEffect(new SacrificeAllEffect(xValue, new FilterControlledLandPermanent(\"lands\")));\r\n    }","id":95445,"modified_method":"public DeathCloud(UUID ownerId) {\r\n        super(ownerId, 76, \"Death Cloud\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{X}{B}{B}{B}\");\r\n        this.expansionSetCode = \"MMA\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Each player loses X life, discards X cards, sacrifices X creatures, then sacrifices X lands.\r\n        DynamicValue xValue = new ManacostVariableValue();\r\n        this.getSpellAbility().addEffect(new LoseLifePlayersEffect(xValue));\r\n        Effect effect = new DiscardEachPlayerEffect(xValue, false);\r\n        effect.setText(\", discards X cards\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new SacrificeAllEffect(xValue, new FilterControlledCreaturePermanent(\"creatures\"));\r\n        effect.setText(\", sacrifices X creatures\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new SacrificeAllEffect(xValue, new FilterControlledLandPermanent(\"lands\"));\r\n        effect.setText(\"then sacrifices X lands\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public DiscardEachPlayerEffect(final DiscardEachPlayerEffect effect) {\r\n        super(effect);\r\n        this.randomDiscard = effect.randomDiscard;\r\n        this.amount = effect.amount;\r\n    }","id":95446,"modified_method":"public DiscardEachPlayerEffect(final DiscardEachPlayerEffect effect) {\r\n        super(effect);\r\n        this.randomDiscard = effect.randomDiscard;\r\n        this.amount = effect.amount;\r\n        this.targetController = effect.targetController;\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public DiscardEachPlayerEffect(DynamicValue amount, boolean randomDiscard) {\r\n        super(Outcome.Discard);\r\n        this.randomDiscard = randomDiscard;\r\n        this.amount = amount;\r\n    }","id":95447,"modified_method":"public DiscardEachPlayerEffect(DynamicValue amount, boolean randomDiscard) {\r\n        this(amount, randomDiscard, TargetController.ANY);\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public String getText(Mode mode) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Each player discards \");\r\n        sb.append(CardUtil.numberToText(amount.toString())).append(\" card\");\r\n        try {\r\n            if (Integer.parseInt(amount.toString()) > 1) {\r\n                sb.append(\"s\");\r\n            }\r\n        } catch (Exception e) {\r\n            sb.append(\"s\");\r\n        }\r\n        if (randomDiscard) {\r\n            sb.append(\" at random\");\r\n        }\r\n        return sb.toString();\r\n    }","id":95448,"modified_method":"@Override\r\n    public String getText(Mode mode) {\r\n        if (staticText != null && !staticText.isEmpty()) {\r\n            return staticText;\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"each \");\r\n        switch(targetController) {\r\n            case NOT_YOU:\r\n                sb.append(\"other player\");\r\n                break;\r\n            case OPPONENT:\r\n                sb.append(\"opponent\");\r\n                break;\r\n            case ANY:\r\n                sb.append(\"player\");\r\n                break;\r\n        }\r\n        sb.append(\" discards \");\r\n        sb.append(CardUtil.numberToText(amount.toString())).append(\" card\");\r\n        try {\r\n            if (Integer.parseInt(amount.toString()) > 1) {\r\n                sb.append(\"s\");\r\n            }\r\n        } catch (Exception e) {\r\n            sb.append(\"s\");\r\n        }\r\n        if (randomDiscard) {\r\n            sb.append(\" at random\");\r\n        }\r\n        return sb.toString();\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        // Store for each player the cards to discard, that's important because all discard shall happen at the same time\r\n        HashMap<UUID, Cards> cardsToDiscard = new HashMap<UUID, Cards>();\r\n        if (controller != null) {\r\n            // choose cards to discard\r\n            for (UUID playerId : controller.getInRange()) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                     int numberOfCardsToDiscard = Math.min(amount.calculate(game, source), player.getHand().size());\r\n                     Cards cards = new CardsImpl();\r\n                     if (randomDiscard) {\r\n                         while (cards.size() < numberOfCardsToDiscard) {\r\n                             Card card = player.getHand().getRandom(game);\r\n                             if (!cards.contains(card.getId())) {\r\n                                 cards.add(card);\r\n                             }\r\n                         }\r\n                     } else {\r\n                         Target target = new TargetDiscard(numberOfCardsToDiscard, numberOfCardsToDiscard, new FilterCard(), playerId);\r\n                         target.setRequired(true);\r\n                         player.chooseTarget(outcome, target, source, game);\r\n                         cards.addAll(target.getTargets());\r\n                     }\r\n                     cardsToDiscard.put(playerId, cards);\r\n                }\r\n            }\r\n            // discard all choosen cards\r\n            for (UUID playerId : controller.getInRange()) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    Cards cardsPlayer = cardsToDiscard.get(playerId);\r\n                    if (cardsPlayer != null) {\r\n                        for (UUID cardId : cardsPlayer) {\r\n                            Card card = game.getCard(cardId);\r\n                            if (card != null) {\r\n                                player.discard(card, source, game);\r\n                            }\r\n                        }\r\n                        game.informPlayers(new StringBuilder(player.getName()).append(\" discards \").append(Integer.toString(cardsPlayer.size())).append(\" card\").append(cardsPlayer.size() > 1?\"s\":\"\").toString());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","id":95449,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        // Store for each player the cards to discard, that's important because all discard shall happen at the same time\r\n        HashMap<UUID, Cards> cardsToDiscard = new HashMap<UUID, Cards>();\r\n        if (controller != null) {\r\n            // choose cards to discard\r\n            for (UUID playerId : controller.getInRange()) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    switch(targetController) {\r\n                        case NOT_YOU:\r\n                            if (playerId.equals(source.getControllerId())) {\r\n                                continue;\r\n                            }\r\n                            break;\r\n                        case OPPONENT:\r\n                            if (!game.getOpponents(source.getControllerId()).contains(playerId)) {\r\n                                continue;\r\n                            }\r\n                            break;\r\n                    }\r\n                    int numberOfCardsToDiscard = Math.min(amount.calculate(game, source), player.getHand().size());\r\n                    Cards cards = new CardsImpl();\r\n                    if (randomDiscard) {\r\n                        while (cards.size() < numberOfCardsToDiscard) {\r\n                            Card card = player.getHand().getRandom(game);\r\n                            if (!cards.contains(card.getId())) {\r\n                                cards.add(card);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        Target target = new TargetDiscard(numberOfCardsToDiscard, numberOfCardsToDiscard, new FilterCard(), playerId);\r\n                        target.setRequired(true);\r\n                        player.chooseTarget(outcome, target, source, game);\r\n                        cards.addAll(target.getTargets());\r\n                    }\r\n                    cardsToDiscard.put(playerId, cards);\r\n                }\r\n            }\r\n            // discard all choosen cards\r\n            for (UUID playerId : controller.getInRange()) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    Cards cardsPlayer = cardsToDiscard.get(playerId);\r\n                    if (cardsPlayer != null) {\r\n                        for (UUID cardId : cardsPlayer) {\r\n                            Card card = game.getCard(cardId);\r\n                            if (card != null) {\r\n                                player.discard(card, source, game);\r\n                            }\r\n                        }\r\n                        game.informPlayers(new StringBuilder(player.getName()).append(\" discards \").append(Integer.toString(cardsPlayer.size())).append(\" card\").append(cardsPlayer.size() > 1 ? \"s\" : \"\").toString());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public LilianasSpecter(UUID ownerId) {\n        super(ownerId, 104, \"Liliana's Specter\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}{B}\");\n        this.expansionSetCode = \"M11\";\n        this.subtype.add(\"Specter\");\n        this.color.setBlack(true);\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(1);\n\n        this.addAbility(FlyingAbility.getInstance());\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new LilianasSpecterEffect(), false));\n    }","id":95450,"modified_method":"public LilianasSpecter(UUID ownerId) {\n        super(ownerId, 104, \"Liliana's Specter\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}{B}\");\n        this.expansionSetCode = \"M11\";\n        this.subtype.add(\"Specter\");\n        this.color.setBlack(true);\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(1);\n\n        this.addAbility(FlyingAbility.getInstance());\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new DiscardEachPlayerEffect(TargetController.OPPONENT), false));\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (UUID playerId : game.getPlayerList()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                player.loseLife(1, game);\r\n            }\r\n        }\r\n\r\n        for (UUID playerId : game.getPlayerList()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                player.discard(1, source, game);\r\n            }\r\n        }\r\n\r\n\r\n        for (UUID playerId : game.getPlayerList()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                sacrifice(game, source, player, filterCreature);\r\n            }\r\n        }\r\n\r\n        for (UUID playerId : game.getPlayerList()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                sacrifice(game, source, player, filterLand);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }","id":95451,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Set <UUID> players = controller.getInRange();\r\n            for (UUID playerId : players) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    player.loseLife(1, game);\r\n                }\r\n            }\r\n            for (UUID playerId : players) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    player.discard(1, source, game);\r\n                }\r\n            }\r\n            for (UUID playerId : players) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    sacrifice(game, source, player, filterCreature);\r\n                }\r\n            }\r\n            for (UUID playerId : players) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    sacrifice(game, source, player, filterLand);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"private void sacrifice(Game game, Ability source, Player player, FilterPermanent filter) {\r\n        Target target = new TargetControlledPermanent(1, 1, filter, false);\r\n        if (target.canChoose(player.getId(), game)) {\r\n            while (!target.isChosen() && target.canChoose(player.getId(), game)) {\r\n                player.choose(Outcome.Sacrifice, target, source.getSourceId(), game);\r\n            }\r\n\r\n            for ( int idx = 0; idx < target.getTargets().size(); idx++) {\r\n                Permanent permanent = game.getPermanent((UUID)target.getTargets().get(idx));\r\n\r\n                if ( permanent != null ) {\r\n                    permanent.sacrifice(source.getSourceId(), game);\r\n                }\r\n            }\r\n        }\r\n    }","id":95452,"modified_method":"private void sacrifice(Game game, Ability source, Player player, FilterPermanent filter) {\r\n        Target target = new TargetControlledPermanent(1, 1, filter, false);\r\n        if (target.canChoose(player.getId(), game)) {\r\n            while (!target.isChosen() && target.canChoose(player.getId(), game) && player.isInGame()) {\r\n                player.choose(Outcome.Sacrifice, target, source.getSourceId(), game);\r\n            }\r\n\r\n            for ( int idx = 0; idx < target.getTargets().size(); idx++) {\r\n                Permanent permanent = game.getPermanent((UUID)target.getTargets().get(idx));\r\n\r\n                if ( permanent != null ) {\r\n                    permanent.sacrifice(source.getSourceId(), game);\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public UrzasGuilt(UUID ownerId) {\r\n        super(ownerId, 130, \"Urza's Guilt\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{U}{B}\");\r\n        this.expansionSetCode = \"PLS\";\r\n\r\n        this.color.setBlue(true);\r\n        this.color.setBlack(true);\r\n\r\n        // Each player draws two cards, then discards three cards, then loses 4 life.\r\n        this.getSpellAbility().addEffect(new DrawCardAllEffect(2));\r\n        this.getSpellAbility().addEffect(new DiscardEachPlayerEffect(3, false));\r\n        this.getSpellAbility().addEffect(new LoseLifeAllEffect(4));\r\n\r\n    }","id":95453,"modified_method":"public UrzasGuilt(UUID ownerId) {\r\n        super(ownerId, 130, \"Urza's Guilt\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{U}{B}\");\r\n        this.expansionSetCode = \"PLS\";\r\n\r\n        this.color.setBlue(true);\r\n        this.color.setBlack(true);\r\n\r\n        // Each player draws two cards, then discards three cards, then loses 4 life.\r\n        this.getSpellAbility().addEffect(new DrawCardAllEffect(2));\r\n        Effect effect = new DiscardEachPlayerEffect(3, false);\r\n        effect.setText(\"then discards three cards\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new LoseLifeAllEffect(4);\r\n        effect.setText(\"then loses 4 life\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"d5feac4bfee4e04c20934eef068f8892ea3d3c8e","url":"https://github.com/magefree/mage"},{"original_method":"public DragonGrip(UUID ownerId) {\r\n        super(ownerId, 107, \"Dragon Grip\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"KTK\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n\r\n        // Ferocious - If you control a creature with power 4 or greater, you may cast Dragon Grip as though it had flash.\r\n        AsThoughEffect effect = new CastAsThoughItHadFlashSourceEffect(Duration.EndOfGame);\r\n        effect.setText(\"<i>Ferocious<\/i> &mdash; If you control a creature with power 4 or greater, you may cast Dragon Grip as though it had flash\");\r\n        this.addAbility(new SimpleStaticAbility(Zone.ALL, new ConditionalAsThoughEffect(effect,\r\n                        FerociousCondition.getInstance())));\r\n\r\n        // Enchant creature\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        // Enchanted creature gets +2/+0 and has first strike.\r\n        Effect effect2 = new BoostEnchantedEffect(2, 0, Duration.WhileOnBattlefield);\r\n        effect2.setText(\"Enchanted creature gets +2/+0\");\r\n        ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 0, Duration.WhileOnBattlefield));\r\n        effect2 = new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.AURA);\r\n        effect2.setText(\"and has first strike\");\r\n        ability.addEffect(effect2);\r\n        this.addAbility(ability);\r\n    }","id":95454,"modified_method":"public DragonGrip(UUID ownerId) {\r\n        super(ownerId, 107, \"Dragon Grip\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"KTK\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n        // Ferocious - If you control a creature with power 4 or greater, you may cast Dragon Grip as though it had flash.\r\n        AsThoughEffect effect = new CastAsThoughItHadFlashSourceEffect(Duration.EndOfGame);\r\n        effect.setText(\"<i>Ferocious<\/i> &mdash; If you control a creature with power 4 or greater, you may cast Dragon Grip as though it had flash\");\r\n        this.addAbility(new SimpleStaticAbility(Zone.ALL, new ConditionalAsThoughEffect(effect,\r\n                FerociousCondition.getInstance())));\r\n\r\n        // Enchant creature\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        // Enchanted creature gets +2/+0 and has first strike.\r\n        Effect effect2 = new BoostEnchantedEffect(2, 0, Duration.WhileOnBattlefield);\r\n        effect2.setText(\"Enchanted creature gets +2/+0\");\r\n        ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect2);\r\n        effect2 = new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.AURA);\r\n        effect2.setText(\"and has first strike\");\r\n        ability.addEffect(effect2);\r\n        this.addAbility(ability);\r\n    }","commit_id":"d4408931a92941627f3ed8645c6fbf2fae7dbe24","url":"https://github.com/magefree/mage"},{"original_method":"public Geistblast(UUID ownerId) {\r\n        super(ownerId, 160, \"Geistblast\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"SOI\";\r\n\r\n        // Geistblast deals 2 damage to target creature or player.\r\n        this.getSpellAbility().addEffect(new DamageTargetEffect(2));\r\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());\r\n\r\n        // {2}{U}, Exile Geist from your graveyard: Copy target instant or sorcery you control. You may choose new targets for the copy.\r\n        Ability ability = new SimpleActivatedAbility(Zone.GRAVEYARD, new CopyTargetSpellEffect(), new ManaCostsImpl<>(\"{2}{U}\"));\r\n        ability.addTarget(new TargetSpell(filter));\r\n        ExileSourceCost cost = new ExileSourceCost();\r\n        cost.setText(\"Exile {this} from your graveyard\");\r\n        ability.addCost(cost);\r\n        this.addAbility(ability);\r\n\r\n    }","id":95455,"modified_method":"public Geistblast(UUID ownerId) {\r\n        super(ownerId, 160, \"Geistblast\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"SOI\";\r\n\r\n        // Geistblast deals 2 damage to target creature or player.\r\n        this.getSpellAbility().addEffect(new DamageTargetEffect(2));\r\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());\r\n\r\n        // {2}{U}, Exile Geist from your graveyard: Copy target instant or sorcery you control. You may choose new targets for the copy.\r\n        Ability ability = new SimpleActivatedAbility(Zone.GRAVEYARD, new CopyTargetSpellEffect(), new ManaCostsImpl<>(\"{2}{U}\"));\r\n        ability.addTarget(new TargetSpell(filter));\r\n        ability.addCost(new ExileSourceFromGraveCost());\r\n        this.addAbility(ability);\r\n\r\n    }","commit_id":"d4408931a92941627f3ed8645c6fbf2fae7dbe24","url":"https://github.com/magefree/mage"},{"original_method":"public Gelectrode(UUID ownerId) {\r\n        super(ownerId, 113, \"Gelectrode\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{U}{R}\");\r\n        this.expansionSetCode = \"GPT\";\r\n        this.subtype.add(\"Weird\");\r\n\r\n\r\n        this.power = new MageInt(0);\r\n        this.toughness = new MageInt(1);\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());\r\n        ability.addTarget(new TargetCreatureOrPlayer());\r\n        this.addAbility(ability);\r\n        this.addAbility(new SpellCastControllerTriggeredAbility(new UntapSourceEffect(), filter, true));\r\n    }","id":95456,"modified_method":"public Gelectrode(UUID ownerId) {\r\n        super(ownerId, 113, \"Gelectrode\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{U}{R}\");\r\n        this.expansionSetCode = \"GPT\";\r\n        this.subtype.add(\"Weird\");\r\n\r\n        this.power = new MageInt(0);\r\n        this.toughness = new MageInt(1);\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());\r\n        ability.addTarget(new TargetCreatureOrPlayer());\r\n        this.addAbility(ability);\r\n        this.addAbility(new SpellCastControllerTriggeredAbility(new UntapSourceEffect(), new FilterInstantOrSorcerySpell(\"an instant or sorcery spell\"), true));\r\n    }","commit_id":"d4408931a92941627f3ed8645c6fbf2fae7dbe24","url":"https://github.com/magefree/mage"},{"original_method":"public LightningTalons (UUID ownerId) {\r\n        super(ownerId, 107, \"Lightning Talons\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"ALA\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 0, Duration.WhileOnBattlefield)));\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.AURA)));\r\n    }","id":95457,"modified_method":"public LightningTalons(UUID ownerId) {\r\n        super(ownerId, 107, \"Lightning Talons\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"ALA\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        Effect effect2 = new BoostEnchantedEffect(3, 0, Duration.WhileOnBattlefield);\r\n        effect2.setText(\"Enchanted creature gets +3/+0\");\r\n        ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 0, Duration.WhileOnBattlefield));\r\n        effect2 = new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.AURA);\r\n        effect2.setText(\"and has first strike\");\r\n        ability.addEffect(effect2);\r\n        this.addAbility(ability);\r\n    }","commit_id":"d4408931a92941627f3ed8645c6fbf2fae7dbe24","url":"https://github.com/magefree/mage"},{"original_method":"public PredatorsStrike(UUID ownerId) {\r\n        super(ownerId, 128, \"Predator's Strike\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{G}\");\r\n        this.expansionSetCode = \"MRD\";\r\n\r\n        this.getSpellAbility().addEffect(new BoostTargetEffect(3, 3, Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n    }","id":95458,"modified_method":"public PredatorsStrike(UUID ownerId) {\r\n        super(ownerId, 128, \"Predator's Strike\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{G}\");\r\n        this.expansionSetCode = \"MRD\";\r\n\r\n        Effect effect = new BoostTargetEffect(3, 3, Duration.EndOfTurn);\r\n        effect.setText(\"Target creature gets +3/+3\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);\r\n        effect.setText(\"and gains trample until end of turn\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n    }","commit_id":"d4408931a92941627f3ed8645c6fbf2fae7dbe24","url":"https://github.com/magefree/mage"},{"original_method":"public PressIntoService(UUID ownerId) {\n        super(ownerId, 114, \"Press into Service\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{4}{R}\");\n        this.expansionSetCode = \"OGW\";\n\n        // Support 2.\n        getSpellAbility().addEffect(new SupportEffect(this, 2, false));\n\n        // Gain control of target creature until end of turn. Untap that creature. It gains haste until end of turn.\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n        Effect effect = new GainControlTargetEffect(Duration.EndOfTurn);\n        effect.setTargetPointer(new SecondTargetPointer()); // First target is used by Support\n        this.getSpellAbility().addEffect(effect);\n        effect = new UntapTargetEffect();\n        effect.setTargetPointer(new SecondTargetPointer()); // First target is used by Support\n        this.getSpellAbility().addEffect(effect);\n        effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);\n        effect.setTargetPointer(new SecondTargetPointer()); // First target is used by Suppor\n        this.getSpellAbility().addEffect(effect);\n    }","id":95459,"modified_method":"public PressIntoService(UUID ownerId) {\n        super(ownerId, 114, \"Press into Service\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{4}{R}\");\n        this.expansionSetCode = \"OGW\";\n\n        // Support 2.\n        getSpellAbility().addEffect(new SupportEffect(this, 2, false));\n\n        // Gain control of target creature until end of turn. Untap that creature. It gains haste until end of turn.\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n        Effect effect = new GainControlTargetEffect(Duration.EndOfTurn);\n        effect.setTargetPointer(new SecondTargetPointer()); // First target is used by Support\n        this.getSpellAbility().addEffect(effect);\n        effect = new UntapTargetEffect();\n        effect.setText(\"Untap that creature\");\n        effect.setTargetPointer(new SecondTargetPointer()); // First target is used by Support\n        this.getSpellAbility().addEffect(effect);\n        effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);\n        effect.setTargetPointer(new SecondTargetPointer()); // First target is used by Suppor\n        effect.setText(\"It gains haste until end of turn\");\n        this.getSpellAbility().addEffect(effect);\n    }","commit_id":"d4408931a92941627f3ed8645c6fbf2fae7dbe24","url":"https://github.com/magefree/mage"},{"original_method":"public AcolytesRewardEffect() {\r\n        super(Duration.EndOfTurn);\r\n        staticText = \"Prevent the next X damage that would be dealt to target creature this turn, where X is your devotion to white. If damage is prevented this way, {this} deals that much damage to target creature or player.\";\r\n    }","id":95460,"modified_method":"public AcolytesRewardEffect() {\r\n        super(Duration.EndOfTurn);\r\n        staticText = \"Prevent the next X damage that would be dealt to target creature this turn, where X is your devotion to white. If damage is prevented this way, {this} deals that much damage to target creature or player\";\r\n    }","commit_id":"2af52cfd3a68c300358ae2a84dffe7d47b4d85c5","url":"https://github.com/magefree/mage"},{"original_method":"public AngelToken(String tokenImageSetCode) {\r\n        super(\"Angel\", \"4/4 white Angel creature token with flying\");\r\n        this.setOriginalExpansionSetCode(tokenImageSetCode);\r\n        cardType.add(CardType.CREATURE);\r\n        color.setWhite(true);\r\n\r\n        subtype.add(\"Angel\");\r\n        power = new MageInt(4);\r\n        toughness = new MageInt(4);\r\n        addAbility(FlyingAbility.getInstance());\r\n\r\n    }","id":95461,"modified_method":"public AngelToken(String setCode) {\r\n        super(\"Angel\", \"4/4 white Angel creature token with flying\");\r\n        this.setOriginalExpansionSetCode(setCode);\r\n        cardType.add(CardType.CREATURE);\r\n        color.setWhite(true);\r\n\r\n        subtype.add(\"Angel\");\r\n        power = new MageInt(4);\r\n        toughness = new MageInt(4);\r\n        addAbility(FlyingAbility.getInstance());\r\n\r\n    }","commit_id":"2af52cfd3a68c300358ae2a84dffe7d47b4d85c5","url":"https://github.com/magefree/mage"},{"original_method":"public ChainReaction(UUID ownerId) {\r\n        super(ownerId, 74, \"Chain Reaction\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{R}{R}\");\r\n        this.expansionSetCode = \"WWK\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Chain Reaction deals X damage to each creature, where X is the number of creatures on the battlefield.\r\n        this.getSpellAbility().addEffect(new DamageAllEffect(new PermanentsOnBattlefieldCount(new FilterCreaturePermanent()), new FilterCreaturePermanent()));\r\n    }","id":95462,"modified_method":"public ChainReaction(UUID ownerId) {\r\n        super(ownerId, 74, \"Chain Reaction\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{R}{R}\");\r\n        this.expansionSetCode = \"WWK\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Chain Reaction deals X damage to each creature, where X is the number of creatures on the battlefield.\r\n        Effect effect = new DamageAllEffect(new PermanentsOnBattlefieldCount(new FilterCreaturePermanent()), new FilterCreaturePermanent());\r\n        effect.setText(\"{this} deals X damage to each creature, where X is the number of creatures on the battlefield\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"2af52cfd3a68c300358ae2a84dffe7d47b4d85c5","url":"https://github.com/magefree/mage"},{"original_method":"protected void calculatePostCombatActions(Game game) {\n        if (!getNextAction(game)) {\n            currentScore = GameStateEvaluator2.evaluate(playerId, game);\n            Game sim = createSimulation(game);\n            SimulationNode2.resetCount();\n            root = new SimulationNode2(null, sim, maxDepth, playerId);\n            logger.debug(\"Sim Calculate post combat actions ----------------------------------------------------------------------------------------\");\n\n            addActionsTimed();\n            if (root.children.size() > 0) {\n                root = root.children.get(0);\n                int bestScore = root.getScore();\n                if (bestScore > currentScore || allowBadMoves) {\n                    actions = new LinkedList<Ability>(root.abilities);\n                    combat = root.combat;\n                } else {\n                    logger.debug(\"[\" + game.getPlayer(playerId).getName() + \"] no better score  current: \" + currentScore + \" bestScore: \" + bestScore );\n                }\n            } else {\n                logger.debug(\"[\" + game.getPlayer(playerId).getName() + \"][post] Action: skip\");\n            }\n        }\n    }","id":95463,"modified_method":"protected void calculatePostCombatActions(Game game) {\n        if (!getNextAction(game)) {\n            currentScore = GameStateEvaluator2.evaluate(playerId, game);\n            Game sim = createSimulation(game);\n            SimulationNode2.resetCount();\n            root = new SimulationNode2(null, sim, maxDepth, playerId);\n            logger.debug(\"Sim Calculate post combat actions ----------------------------------------------------------------------------------------\");\n\n            addActionsTimed();\n            if (root != null && root.children.size() > 0) {\n                root = root.children.get(0);\n                int bestScore = root.getScore();\n                if (bestScore > currentScore || allowBadMoves) {\n                    actions = new LinkedList<>(root.abilities);\n                    combat = root.combat;\n                } else {\n                    logger.debug(\"[\" + game.getPlayer(playerId).getName() + \"] no better score  current: \" + currentScore + \" bestScore: \" + bestScore );\n                }\n            } else {\n                logger.debug(\"[\" + game.getPlayer(playerId).getName() + \"][post] Action: skip\");\n            }\n        }\n    }","commit_id":"2af52cfd3a68c300358ae2a84dffe7d47b4d85c5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int value = amount.calculate(game, source, this);\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            if (value < 1) {\r\n                return true;\r\n            }\r\n            if(token.putOntoBattlefield(value, game, source.getSourceId(), targetPointer.getFirst(game, source), tapped, attacking)) {\r\n                game.informPlayers(new StringBuilder(controller.getName())\r\n                    .append(\" puts \").append(CardUtil.numberToText(value,\"a\")).append(\" \").append(token.getName())\r\n                    .append(value == 1?\" token\":\" tokens\").append(\" onto the Battlefield\").toString());\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":95464,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int value = amount.calculate(game, source, this);\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            if (value < 1) {\r\n                return true;\r\n            }\r\n            return token.putOntoBattlefield(value, game, source.getSourceId(), targetPointer.getFirst(game, source), tapped, attacking);\r\n        }\r\n        return false;\r\n    }","commit_id":"2af52cfd3a68c300358ae2a84dffe7d47b4d85c5","url":"https://github.com/magefree/mage"},{"original_method":"public RestForTheWeary(UUID ownerId) {\r\n        super(ownerId, 18, \"Rest for the Weary\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\r\n        this.expansionSetCode = \"WWK\";\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Target player gains 4 life.\r\n        // Landfall - If you had a land enter the battlefield under your control this turn, that player gains 8 life instead.\r\n        this.addWatcher(new LandfallWatcher());\r\n        this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new GainLifeTargetEffect(8), new GainLifeTargetEffect(4), LandfallCondition.getInstance(), \"Target player gains 4 life. Landfall - If you had a land enter the battlefield under your control this turn, that player gains 8 life instead\"));\r\n        this.getSpellAbility().addTarget(new TargetPlayer());\r\n    }","id":95465,"modified_method":"public RestForTheWeary(UUID ownerId) {\r\n        super(ownerId, 18, \"Rest for the Weary\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\r\n        this.expansionSetCode = \"WWK\";\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Target player gains 4 life.\r\n        // Landfall - If you had a land enter the battlefield under your control this turn, that player gains 8 life instead.\r\n        this.addWatcher(new LandfallWatcher());\r\n        this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new GainLifeTargetEffect(8), new GainLifeTargetEffect(4), LandfallCondition.getInstance(), \"Target player gains 4 life. <br/>Landfall - If you had a land enter the battlefield under your control this turn, that player gains 8 life instead\"));\r\n        this.getSpellAbility().addTarget(new TargetPlayer());\r\n    }","commit_id":"2af52cfd3a68c300358ae2a84dffe7d47b4d85c5","url":"https://github.com/magefree/mage"},{"original_method":"public SwordOfVengeance(UUID ownerId) {\n        super(ownerId, 216, \"Sword of Vengeance\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{3}\");\n        this.expansionSetCode = \"M11\";\n        this.subtype.add(\"Equipment\");\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.EQUIPMENT)));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.EQUIPMENT)));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.EQUIPMENT)));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(HasteAbility.getInstance(), AttachmentType.EQUIPMENT)));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 0)));\n    }","id":95466,"modified_method":"public SwordOfVengeance(UUID ownerId) {\n        super(ownerId, 216, \"Sword of Vengeance\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{3}\");\n        this.expansionSetCode = \"M11\";\n        this.subtype.add(\"Equipment\");\n        \n        \n        // Equipped creature gets +2/+0 and has first strike, vigilance, trample, and haste.\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 0));\n        Effect effect = new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.EQUIPMENT);\n        effect.setText(\"and has first strike\");\n        ability.addEffect(effect);\n        effect = new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.EQUIPMENT);\n        effect.setText(\", vigilance\");\n        ability.addEffect(effect);\n        effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.EQUIPMENT);\n        effect.setText(\", trample\");\n        ability.addEffect(effect);\n        effect = new GainAbilityAttachedEffect(HasteAbility.getInstance(), AttachmentType.EQUIPMENT);\n        effect.setText(\", and haste\");\n        ability.addEffect(effect);\n        this.addAbility(ability);\n\n        // Equip 3\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\n    }","commit_id":"2af52cfd3a68c300358ae2a84dffe7d47b4d85c5","url":"https://github.com/magefree/mage"},{"original_method":"public GuidedStrike(UUID ownerId) {\n        super(ownerId, 132, \"Guided Strike\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\n        this.expansionSetCode = \"WTH\";\n\n        // Target creature gets +1/+0 and gains first strike until end of turn.\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 1));\n        this.getSpellAbility().addEffect(new BoostTargetEffect(1, 0, Duration.EndOfTurn));\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));\n        // Draw a card.\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\n    }","id":95467,"modified_method":"public GuidedStrike(UUID ownerId) {\n        super(ownerId, 132, \"Guided Strike\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\n        this.expansionSetCode = \"WTH\";\n\n        // Target creature gets +1/+0 and gains first strike until end of turn.\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 1));\n        Effect effect = new BoostTargetEffect(1, 0, Duration.EndOfTurn);\n        effect.setText(\"Target creature gets +1/+0\");\n        this.getSpellAbility().addEffect(effect);\n        effect = new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);\n        effect.setText(\"and gains first strike until end of turn\");\n        this.getSpellAbility().addEffect(effect);\n        // Draw a card.\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\n    }","commit_id":"81108be3466ad55ebbc1ae11895c512013b1f663","url":"https://github.com/magefree/mage"},{"original_method":"public GuulDrazVampire(UUID ownerId) {\r\n        super(ownerId, 93, \"Guul Draz Vampire\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{B}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Vampire\");\r\n        this.subtype.add(\"Rogue\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // As long as an opponent has 10 or less life, Guul Draz Vampire gets +2/+1 and has intimidate. (It can't be blocked except by artifact creatures and/or creatures that share a color with it.)\r\n        Condition condition = new TenOrLessLifeCondition(TenOrLessLifeCondition.CheckType.AN_OPPONENT);\r\n        ConditionalContinuousEffect effect1 = new ConditionalContinuousEffect(new BoostSourceEffect(2, 1, Duration.WhileOnBattlefield), condition, rule1);\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect1));\r\n        ConditionalContinuousEffect effect2 = new ConditionalContinuousEffect(new GainAbilitySourceEffect(IntimidateAbility.getInstance()), condition, rule2);\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect2));\r\n\r\n    }","id":95468,"modified_method":"public GuulDrazVampire(UUID ownerId) {\r\n        super(ownerId, 93, \"Guul Draz Vampire\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{B}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Vampire\");\r\n        this.subtype.add(\"Rogue\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // As long as an opponent has 10 or less life, Guul Draz Vampire gets +2/+1 and has intimidate. (It can't be blocked except by artifact creatures and/or creatures that share a color with it.)\r\n        Condition condition = new TenOrLessLifeCondition(TenOrLessLifeCondition.CheckType.AN_OPPONENT);\r\n        ConditionalContinuousEffect effect1 = new ConditionalContinuousEffect(new BoostSourceEffect(2, 1, Duration.WhileOnBattlefield), condition, rule1);\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect1);\r\n        ability.addEffect(new ConditionalContinuousEffect(new GainAbilitySourceEffect(IntimidateAbility.getInstance()), condition, rule2));\r\n        this.addAbility(ability);\r\n\r\n    }","commit_id":"539603af3d69cde0b23ac4d85c6621fefd0f0d38","url":"https://github.com/magefree/mage"},{"original_method":"public LavaballTrap(UUID ownerId) {\r\n        super(ownerId, 135, \"Lavaball Trap\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{6}{R}{R}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Trap\");\r\n\r\n\r\n        // If an opponent had two or more lands enter the battlefield under his or her control this turn, you may pay {3}{R}{R} rather than pay Lavaball Trap's mana cost.\r\n        this.getSpellAbility().addAlternativeCost(new LavaballTrapAlternativeCost());\r\n        this.getSpellAbility().addWatcher(new LavaballTrapWatcher());\r\n\r\n        // Destroy two target lands. Lavaball Trap deals 4 damage to each creature.\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect());\r\n        this.getSpellAbility().addEffect(new DamageAllEffect(4, new FilterCreaturePermanent()));\r\n        this.getSpellAbility().addTarget(new TargetLandPermanent(2));\r\n\r\n    }","id":95469,"modified_method":"public LavaballTrap(UUID ownerId) {\r\n        super(ownerId, 135, \"Lavaball Trap\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{6}{R}{R}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Trap\");\r\n\r\n        // If an opponent had two or more lands enter the battlefield under his or her control this turn, you may pay {3}{R}{R} rather than pay Lavaball Trap's mana cost.\r\n        this.getSpellAbility().addAlternativeCost(new LavaballTrapAlternativeCost());\r\n        this.getSpellAbility().addWatcher(new LavaballTrapWatcher());\r\n\r\n        // Destroy two target lands. Lavaball Trap deals 4 damage to each creature.\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect());\r\n        this.getSpellAbility().addEffect(new DamageAllEffect(4, new FilterCreaturePermanent()));\r\n        this.getSpellAbility().addTarget(new TargetLandPermanent(2, 2, new FilterLandPermanent(\"lands\"), false));\r\n\r\n    }","commit_id":"539603af3d69cde0b23ac4d85c6621fefd0f0d38","url":"https://github.com/magefree/mage"},{"original_method":"public SlaughterCry(UUID ownerId) {\r\n        super(ownerId, 149, \"Slaughter Cry\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n\r\n\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n        this.getSpellAbility().addEffect(new BoostTargetEffect(3, 0, Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));\r\n    }","id":95470,"modified_method":"public SlaughterCry(UUID ownerId) {\r\n        super(ownerId, 149, \"Slaughter Cry\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n\r\n        // Target creature gets +3/+0 and gains first strike until end of turn. (It deals combat damage before creatures without first strike.)\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n        Effect effect = new BoostTargetEffect(3, 0, Duration.EndOfTurn);\r\n        effect.setText(\"Target creature gets +3/+0\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);\r\n        effect.setText(\"and gains first strike until end of turn. <i>(It deals combat damage before creatures without first strike.)<\/i>\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"539603af3d69cde0b23ac4d85c6621fefd0f0d38","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void build() {\n        // Creatures you control have flying, first strike, vigilance, trample, haste, and protection from black and from red.\n        CompoundAbility abilities = new CompoundAbility(FlyingAbility.getInstance(), FirstStrikeAbility.getInstance(), VigilanceAbility.getInstance(), TrampleAbility.getInstance(), HasteAbility.getInstance(), new ProtectionAbility(filterBlack), new ProtectionAbility(filterRed));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(abilities, Duration.WhileOnBattlefield, new FilterControlledCreaturePermanent(\"Creatures you control\"))));\n    }","id":95471,"modified_method":"@Override\n    public void build() {\n        // Creatures you control have flying, first strike, vigilance, trample, haste, and protection from black and from red.\n        CompoundAbility compoundAbilities = new CompoundAbility(FlyingAbility.getInstance(), FirstStrikeAbility.getInstance(), VigilanceAbility.getInstance(), TrampleAbility.getInstance(), HasteAbility.getInstance(), new ProtectionAbility(filterBlack), new ProtectionAbility(filterRed));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(compoundAbilities, Duration.WhileOnBattlefield, new FilterControlledCreaturePermanent(\"Creatures\"))));\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public ArmWithAEther(UUID ownerId) {\r\n        super(ownerId, 28, \"Arm with AEther\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{2}{U}\");\r\n        this.expansionSetCode = \"NPH\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Until end of turn, creatures you control gain \"Whenever this creature deals damage to an opponent, you may return target creature that player controls to its owner's hand.\"\r\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(new ArmWithAEtherTriggeredAbility(), Duration.EndOfTurn, filter));\r\n    }","id":95472,"modified_method":"public ArmWithAEther(UUID ownerId) {\r\n        super(ownerId, 28, \"Arm with AEther\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{2}{U}\");\r\n        this.expansionSetCode = \"NPH\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Until end of turn, creatures you control gain \"Whenever this creature deals damage to an opponent, you may return target creature that player controls to its owner's hand.\"\r\n        Effect effect = new GainAbilityControlledEffect(new ArmWithAEtherTriggeredAbility(), Duration.EndOfTurn, new FilterCreaturePermanent());\r\n        effect.setText(\"Until end of turn, creatures you control gain \\\"Whenever this creature deals damage to an opponent, you may return target creature that player controls to its owner's hand.\\\"\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public BoostAllEffect(DynamicValue power, DynamicValue toughness, Duration duration, FilterCreaturePermanent filter, boolean excludeSource, String rule) {\n        this(power, toughness, duration, filter, excludeSource, null, false);\n    }","id":95473,"modified_method":"public BoostAllEffect(DynamicValue power, DynamicValue toughness, Duration duration, FilterCreaturePermanent filter, boolean excludeSource, String rule) {\n        this(power, toughness, duration, filter, excludeSource, rule, false);\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public BurstOfSpeed(UUID ownerId) {\r\n        super(ownerId, 129, \"Burst of Speed\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{R}\");\r\n        this.expansionSetCode = \"M10\";\r\n        this.color.setRed(true);\r\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(HasteAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent(), false));\r\n    }","id":95474,"modified_method":"public BurstOfSpeed(UUID ownerId) {\r\n        super(ownerId, 129, \"Burst of Speed\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{R}\");\r\n        this.expansionSetCode = \"M10\";\r\n        this.color.setRed(true);\r\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(HasteAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent(), false));\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public CleaverRiot(UUID ownerId) {\r\n        super(ownerId, 125, \"Cleaver Riot\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{4}{R}\");\r\n        this.expansionSetCode = \"M13\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Creatures you control gain double strike until end of turn.\r\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(DoubleStrikeAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent(), false));\r\n    }","id":95475,"modified_method":"public CleaverRiot(UUID ownerId) {\r\n        super(ownerId, 125, \"Cleaver Riot\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{4}{R}\");\r\n        this.expansionSetCode = \"M13\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Creatures you control gain double strike until end of turn.\r\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(DoubleStrikeAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent(), false));\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public FamiliarsRuse(UUID ownerId) {\r\n        super(ownerId, 64, \"Familiar's Ruse\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{U}{U}\");\r\n        this.expansionSetCode = \"LRW\";\r\n        this.color.setBlue(true);\r\n        this.getSpellAbility().addCost(new ReturnToHandTargetCost(new TargetControlledCreaturePermanent()));\r\n        this.getSpellAbility().addEffect(new CounterTargetEffect());\r\n        this.getSpellAbility().addTarget(new TargetSpell());\r\n    }","id":95476,"modified_method":"public FamiliarsRuse(UUID ownerId) {\r\n        super(ownerId, 64, \"Familiar's Ruse\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{U}{U}\");\r\n        this.expansionSetCode = \"LRW\";\r\n        this.color.setBlue(true);\r\n        this.getSpellAbility().addCost(new ReturnToHandTargetCost(new TargetControlledCreaturePermanent(1,1, new FilterControlledCreaturePermanent(\"creature\"),false)));\r\n        this.getSpellAbility().addEffect(new CounterTargetEffect());\r\n        this.getSpellAbility().addTarget(new TargetSpell());\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public MadrushCyclops (UUID ownerId) {\r\n        super(ownerId, 119, \"Madrush Cyclops\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{B}{R}{G}\");\r\n        this.expansionSetCode = \"ARB\";\r\n        this.subtype.add(\"Cyclops\");\r\n        this.subtype.add(\"Warrior\");\r\n        this.color.setBlack(true);\r\n        this.color.setRed(true);\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(4);\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(HasteAbility.getInstance(), Duration.WhileOnBattlefield, new FilterControlledCreaturePermanent())));\r\n    }","id":95477,"modified_method":"public MadrushCyclops (UUID ownerId) {\r\n        super(ownerId, 119, \"Madrush Cyclops\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{B}{R}{G}\");\r\n        this.expansionSetCode = \"ARB\";\r\n        this.subtype.add(\"Cyclops\");\r\n        this.subtype.add(\"Warrior\");\r\n        this.color.setBlack(true);\r\n        this.color.setRed(true);\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(4);\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(HasteAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent())));\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public MoonbowIllusionist(UUID ownerId) {\r\n        super(ownerId, 46, \"Moonbow Illusionist\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{2}{U}\");\r\n        this.expansionSetCode = \"SOK\";\r\n        this.subtype.add(\"Moonfolk\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n        // {2}, Return a land you control to its owner's hand: Target land becomes the basic land type of your choice until end of turn.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn), new GenericManaCost(2));\r\n        ability.addCost(new ReturnToHandTargetCost(new TargetControlledPermanent(new FilterControlledLandPermanent())));\r\n        ability.addTarget(new TargetLandPermanent());\r\n        this.addAbility(ability);\r\n\r\n\r\n    }","id":95478,"modified_method":"public MoonbowIllusionist(UUID ownerId) {\r\n        super(ownerId, 46, \"Moonbow Illusionist\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{2}{U}\");\r\n        this.expansionSetCode = \"SOK\";\r\n        this.subtype.add(\"Moonfolk\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n        // {2}, Return a land you control to its owner's hand: Target land becomes the basic land type of your choice until end of turn.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn), new GenericManaCost(2));\r\n        ability.addCost(new ReturnToHandTargetCost(new TargetControlledPermanent(new FilterControlledLandPermanent(\"land\"))));\r\n        ability.addTarget(new TargetLandPermanent());\r\n        this.addAbility(ability);\r\n\r\n\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public SteelformSliver(UUID ownerId) {\r\n        super(ownerId, 38, \"Steelform Sliver\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Sliver\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Sliver creatures you control get +0/+1.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, \r\n                new BoostControlledEffect(0, 1, Duration.WhileOnBattlefield,\r\n                new FilterCreaturePermanent(\"Sliver\", \"Sliver creatures you control\"), false)));\r\n    }","id":95479,"modified_method":"public SteelformSliver(UUID ownerId) {\r\n        super(ownerId, 38, \"Steelform Sliver\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Sliver\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Sliver creatures you control get +0/+1.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, \r\n                new BoostControlledEffect(0, 1, Duration.WhileOnBattlefield,\r\n                new FilterCreaturePermanent(\"Sliver\", \"Sliver creatures\"), false)));\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public TortoiseFormation(UUID ownerId) {\r\n        super(ownerId, 61, \"Tortoise Formation\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{3}{U}\");\r\n        this.expansionSetCode = \"ALA\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Creatures you control gain shroud until end of turn.\r\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(ShroudAbility.getInstance(), Duration.EndOfTurn, filter));\r\n    }","id":95480,"modified_method":"public TortoiseFormation(UUID ownerId) {\r\n        super(ownerId, 61, \"Tortoise Formation\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{3}{U}\");\r\n        this.expansionSetCode = \"ALA\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Creatures you control gain shroud until end of turn.\r\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(ShroudAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent()));\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public VelaTheNightClad(UUID ownerId) {\r\n        super(ownerId, 107, \"Vela the Night-Clad\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{4}{U}{B}\");\r\n        this.expansionSetCode = \"PC2\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setBlue(true);\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(4);\r\n\r\n        // Intimidate\r\n        this.addAbility(IntimidateAbility.getInstance());\r\n        // Other creatures you control have intimidate.\r\n        this.addAbility(new SimpleStaticAbility(\r\n                Zone.BATTLEFIELD,\r\n                new GainAbilityControlledEffect(IntimidateAbility.getInstance(),\r\n                    Duration.WhileOnBattlefield, new FilterCreaturePermanent(\"Other creatures you control\"), true )));\r\n        // Whenever Vela the Night-Clad or another creature you control leaves the battlefield, each opponent loses 1 life.\r\n        Ability ability = new ZoneChangeAllTriggeredAbility(\r\n                Zone.BATTLEFIELD,\r\n                Zone.BATTLEFIELD, null,\r\n                new LoseLifeOpponentsEffect(1),\r\n                filter, rule, false);\r\n        this.addAbility(ability);\r\n    }","id":95481,"modified_method":"public VelaTheNightClad(UUID ownerId) {\r\n        super(ownerId, 107, \"Vela the Night-Clad\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{4}{U}{B}\");\r\n        this.expansionSetCode = \"PC2\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setBlue(true);\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(4);\r\n\r\n        // Intimidate\r\n        this.addAbility(IntimidateAbility.getInstance());\r\n        // Other creatures you control have intimidate.\r\n        this.addAbility(new SimpleStaticAbility(\r\n                Zone.BATTLEFIELD,\r\n                new GainAbilityControlledEffect(IntimidateAbility.getInstance(),\r\n                    Duration.WhileOnBattlefield, new FilterCreaturePermanent(), true )));\r\n        // Whenever Vela the Night-Clad or another creature you control leaves the battlefield, each opponent loses 1 life.\r\n        Ability ability = new ZoneChangeAllTriggeredAbility(\r\n                Zone.BATTLEFIELD,\r\n                Zone.BATTLEFIELD, null,\r\n                new LoseLifeOpponentsEffect(1),\r\n                filter, rule, false);\r\n        this.addAbility(ability);\r\n    }","commit_id":"51d4dff35b1419a2feca090e6b14cbe466e23717","url":"https://github.com/magefree/mage"},{"original_method":"public EbonyHorse(UUID ownerId) {\n        super(ownerId, 336, \"Ebony Horse\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{3}\");\n        this.expansionSetCode = \"4ED\";\n\n        // {2}, {tap}: Untap target attacking creature you control. Prevent all combat damage that would be dealt to and dealt by that creature this turn.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapTargetEffect(), new GenericManaCost(2));\n        ability.addCost(new TapSourceCost());\n        ability.addEffect(new PreventCombatDamageToSourceEffect(Duration.EndOfTurn));\n        ability.addEffect(new PreventCombatDamageBySourceEffect(Duration.EndOfTurn));\n        Target target = new TargetCreaturePermanent(filter);\n        ability.addTarget(target);\n        this.addAbility(ability);\n    }","id":95482,"modified_method":"public EbonyHorse(UUID ownerId) {\n        super(ownerId, 336, \"Ebony Horse\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{3}\");\n        this.expansionSetCode = \"4ED\";\n\n        // {2}, {tap}: Untap target attacking creature you control. Prevent all combat damage that would be dealt to and dealt by that creature this turn.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapTargetEffect(), new GenericManaCost(2));\n        ability.addCost(new TapSourceCost());\n        Effect effect = new PreventCombatDamageToSourceEffect(Duration.EndOfTurn);\n        effect.setText(\"Prevent all combat damage that would be dealt to\");\n        ability.addEffect(effect);\n        effect = new PreventCombatDamageBySourceEffect(Duration.EndOfTurn);\n        effect.setText(\"and dealt by that creature this turn\");\n        ability.addEffect(effect);\n        ability.addTarget(new TargetCreaturePermanent(filter));\n        this.addAbility(ability);\n    }","commit_id":"67c64bbe9ef42dcd4b96156422e883aeab92b3f0","url":"https://github.com/magefree/mage"},{"original_method":"public FanaticalFever(UUID ownerId) {\r\n        super(ownerId, 122, \"Fanatical Fever\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{2}{G}{G}\");\r\n        this.expansionSetCode = \"ICE\";\r\n\r\n        // Target creature gets +3/+0 and gains trample until end of turn.\r\n        this.getSpellAbility().addEffect(new BoostTargetEffect(3, 0, Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n    }","id":95483,"modified_method":"public FanaticalFever(UUID ownerId) {\r\n        super(ownerId, 122, \"Fanatical Fever\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{2}{G}{G}\");\r\n        this.expansionSetCode = \"ICE\";\r\n\r\n        // Target creature gets +3/+0 and gains trample until end of turn.\r\n        Effect effect = new BoostTargetEffect(3, 0, Duration.EndOfTurn);\r\n        effect.setText(\"Target creature gets +3/+0\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);\r\n        effect.setText(\"and gains trample until end of turn\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n    }","commit_id":"67c64bbe9ef42dcd4b96156422e883aeab92b3f0","url":"https://github.com/magefree/mage"},{"original_method":"public OrcishCannoneers(UUID ownerId) {\n        super(ownerId, 205, \"Orcish Cannoneers\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{R}{R}\");\n        this.expansionSetCode = \"ICE\";\n        this.subtype.add(\"Orc\");\n        this.subtype.add(\"Warrior\");\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(3);\n\n        // {tap}: Orcish Cannoneers deals 2 damage to target creature or player and 3 damage to you.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new TapSourceCost());                                                                                         ability.addTarget(new TargetCreatureOrPlayer());\n        ability.addEffect(new DamageControllerEffect(3));\n        this.addAbility(ability);\n    }","id":95484,"modified_method":"public OrcishCannoneers(UUID ownerId) {\n        super(ownerId, 205, \"Orcish Cannoneers\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{R}{R}\");\n        this.expansionSetCode = \"ICE\";\n        this.subtype.add(\"Orc\");\n        this.subtype.add(\"Warrior\");\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(3);\n\n        // {tap}: Orcish Cannoneers deals 2 damage to target creature or player and 3 damage to you.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new TapSourceCost());                                                                                         ability.addTarget(new TargetCreatureOrPlayer());\n        Effect effect = new DamageControllerEffect(3);\n        effect.setText(\"and 3 damage to you\");\n        ability.addEffect(effect);\n        this.addAbility(ability);\n    }","commit_id":"67c64bbe9ef42dcd4b96156422e883aeab92b3f0","url":"https://github.com/magefree/mage"},{"original_method":"public Shatterstorm(UUID ownerId) {\n        super(ownerId, 266, \"Shatterstorm\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{2}{R}{R}\");\n        this.expansionSetCode = \"5ED\";\n\n\n        // Destroy all artifacts. They can't be regenerated.\n        this.getSpellAbility().addEffect(new DestroyAllEffect(new FilterArtifactPermanent(), true));\n    }","id":95485,"modified_method":"public Shatterstorm(UUID ownerId) {\n        super(ownerId, 266, \"Shatterstorm\", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, \"{2}{R}{R}\");\n        this.expansionSetCode = \"5ED\";\n\n\n        // Destroy all artifacts. They can't be regenerated.\n        this.getSpellAbility().addEffect(new DestroyAllEffect(new FilterArtifactPermanent(\"artifacts\"), true));\n    }","commit_id":"67c64bbe9ef42dcd4b96156422e883aeab92b3f0","url":"https://github.com/magefree/mage"},{"original_method":"public SnowHound(UUID ownerId) {\n        super(ownerId, 277, \"Snow Hound\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\n        this.expansionSetCode = \"ICE\";\n        this.subtype.add(\"Hound\");\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(1);\n\n        // {1}, {tap}: Return Snow Hound and target green or blue creature you control to their owner's hand.\n        Effect effect = new ReturnToHandSourceEffect(true);\n        effect.setText(\"Return Snow Hound\");        \n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl(\"{1}\"));\n        ability.addCost(new TapSourceCost());\n        effect = new ReturnToHandTargetEffect();\n        effect.setText(\"and green or blue creature you control to their owners' hands\");\n        ability.addTarget(new TargetControlledCreaturePermanent(filter));\n        ability.addEffect(effect);\n        this.addAbility(ability);\n    }","id":95486,"modified_method":"public SnowHound(UUID ownerId) {\n        super(ownerId, 277, \"Snow Hound\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\n        this.expansionSetCode = \"ICE\";\n        this.subtype.add(\"Hound\");\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(1);\n\n        // {1}, {tap}: Return Snow Hound and target green or blue creature you control to their owner's hand.\n        Effect effect = new ReturnToHandSourceEffect(true);\n        effect.setText(\"Return Snow Hound\");\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl(\"{1}\"));\n        ability.addCost(new TapSourceCost());\n        effect = new ReturnToHandTargetEffect();\n        effect.setText(\"and target green or blue creature you control to their owners' hands\");\n        ability.addTarget(new TargetControlledCreaturePermanent(filter));\n        ability.addEffect(effect);\n        this.addAbility(ability);\n    }","commit_id":"67c64bbe9ef42dcd4b96156422e883aeab92b3f0","url":"https://github.com/magefree/mage"},{"original_method":"public TimeBomb(UUID ownerId) {\n        super(ownerId, 223, \"Time Bomb\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{4}\");\n        this.expansionSetCode = \"ME2\";\n\n        // At the beginning of your upkeep, put a time counter on Time Bomb.\n        this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AddCountersSourceEffect(CounterType.TIME.createInstance(), true), TargetController.YOU, false));\n\n        // {1}, {tap}, Sacrifice Time Bomb: Time Bomb deals damage equal to the number of time counters on it to each creature and each player.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,\n                new DamageEverythingEffect(new CountersCount(CounterType.TIME), new FilterCreaturePermanent()),\n                new GenericManaCost(1));\n        ability.addCost(new TapSourceCost());\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","id":95487,"modified_method":"public TimeBomb(UUID ownerId) {\n        super(ownerId, 223, \"Time Bomb\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{4}\");\n        this.expansionSetCode = \"ME2\";\n\n        // At the beginning of your upkeep, put a time counter on Time Bomb.\n        this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AddCountersSourceEffect(CounterType.TIME.createInstance(), true), TargetController.YOU, false));\n\n        // {1}, {tap}, Sacrifice Time Bomb: Time Bomb deals damage equal to the number of time counters on it to each creature and each player.\n        Effect effect = new DamageEverythingEffect(new CountersCount(CounterType.TIME), new FilterCreaturePermanent());\n        effect.setText(\"{this} deals damage equal to the number of time counters on it to each creature and each player\");\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(1));\n        ability.addCost(new TapSourceCost());\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","commit_id":"67c64bbe9ef42dcd4b96156422e883aeab92b3f0","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getText(Mode mode) {\n        StringBuilder sb = new StringBuilder();\n        Target target = mode.getTargets().get(0);\n        if(target.getMaxNumberOfTargets() > 1){\n            if (target.getNumberOfTargets() < target.getMaxNumberOfTargets()) {\n                sb.append(\"Up to \");\n            }\n            sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(\" target \").append(target.getTargetName()).append(\"  each become \");\n        } else {\n            sb.append(\"Target \").append(target.getTargetName()).append(\" becomes a \");\n        }\n        sb.append(token.getDescription());\n        sb.append(\" \").append(duration.toString());\n        if (type != null && type.length() > 0) {\n            if (target.getMaxNumberOfTargets() > 1) {\n                sb.append(\". They're still \").append(type);\n            } else {\n                sb.append(\". It's still a \").append(type);\n            }\n        }\n        return sb.toString();\n    }","id":95488,"modified_method":"@Override\n    public String getText(Mode mode) {\n        if (staticText != null && !staticText.isEmpty()) {\n            return staticText;\n        }\n        StringBuilder sb = new StringBuilder();\n        Target target = mode.getTargets().get(0);\n        if(target.getMaxNumberOfTargets() > 1){\n            if (target.getNumberOfTargets() < target.getMaxNumberOfTargets()) {\n                sb.append(\"Up to \");\n            }\n            sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(\" target \").append(target.getTargetName()).append(\"  each become \");\n        } else {\n            sb.append(\"Target \").append(target.getTargetName()).append(\" becomes a \");\n        }\n        sb.append(token.getDescription());\n        sb.append(\" \").append(duration.toString());\n        if (type != null && type.length() > 0) {\n            if (target.getMaxNumberOfTargets() > 1) {\n                sb.append(\". They're still \").append(type);\n            } else {\n                sb.append(\". It's still a \").append(type);\n            }\n        }\n        return sb.toString();\n    }","commit_id":"08d0a3662c896f2cc7b0c1cfcd68d49877ab9300","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean targetChosen = false;\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        TargetPermanent target = new TargetPermanent(1, 1, filter, false);\r\n\r\n        if (target.canChoose(player.getId(), game)) {\r\n            player.choose(Outcome.ReturnToHand, target, source.getSourceId(), game);\r\n            Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n\r\n            if ( permanent != null ) {\r\n                targetChosen = true;\r\n                permanent.moveToZone(Zone.HAND, source.getSourceId(), game, false);\r\n            }\r\n        }\r\n\r\n        if ( !targetChosen ) {\r\n            new SacrificeSourceEffect().apply(game, source);\r\n        }\r\n\r\n        return false;\r\n    }","id":95489,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            boolean targetChosen = false;\r\n            TargetPermanent target = new TargetPermanent(1, 1, filter, false);\r\n\r\n            if (target.canChoose(controller.getId(), game)) {\r\n                controller.choose(Outcome.ReturnToHand, target, source.getSourceId(), game);\r\n                Permanent permanent = game.getPermanent(target.getFirstTarget());\r\n\r\n                if ( permanent != null ) {\r\n                    targetChosen = true;\r\n                    controller.moveCardToHandWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD);\r\n                }\r\n            }\r\n\r\n            if ( !targetChosen ) {\r\n                new SacrificeSourceEffect().apply(game, source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"08d0a3662c896f2cc7b0c1cfcd68d49877ab9300","url":"https://github.com/magefree/mage"},{"original_method":"public JaceTheLivingGuildpact(UUID ownerId) {\r\n        super(ownerId, 62, \"Jace, the Living Guildpact\", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, \"{2}{U}{U}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Jace\");\r\n\r\n        this.color.setBlue(true);\r\n\r\n        this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.LOYALTY.createInstance(5)), false));\r\n\r\n        // +1: Look at the top two cards of your library. Put one of them into your graveyard.\r\n        this.addAbility(new LoyaltyAbility(new LookLibraryAndPickControllerEffect(\r\n                new StaticValue(2), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, true, false, false, Zone.GRAVEYARD, false), 1));\r\n\r\n        // -3: Return another target nonland permanent to its owner's hand. \r\n        LoyaltyAbility ability = new LoyaltyAbility(new ReturnToHandTargetEffect(), -3);\r\n        ability.addTarget(new TargetPermanent(filter));\r\n        this.addAbility(ability);\r\n\r\n        // -8: Each player shuffles his or her hand and graveyard into his or her library. You draw seven cards.\r\n        this.addAbility(new LoyaltyAbility(new JaceTheLivingGuildpactEffect(), -8));\r\n\r\n    }","id":95490,"modified_method":"public JaceTheLivingGuildpact(UUID ownerId) {\r\n        super(ownerId, 62, \"Jace, the Living Guildpact\", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, \"{2}{U}{U}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Jace\");\r\n\r\n        this.color.setBlue(true);\r\n\r\n        this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.LOYALTY.createInstance(5)), false));\r\n\r\n        // +1: Look at the top two cards of your library. Put one of them into your graveyard.\r\n        Effect effect = new LookLibraryAndPickControllerEffect(\r\n                new StaticValue(2), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, true, false, false, Zone.GRAVEYARD, false);\r\n        effect.setText(\"Look at the top two cards of your library. Put one of them into your graveyard\");\r\n        this.addAbility(new LoyaltyAbility(effect, 1));\r\n\r\n        // -3: Return another target nonland permanent to its owner's hand. \r\n        LoyaltyAbility ability = new LoyaltyAbility(new ReturnToHandTargetEffect(), -3);\r\n        ability.addTarget(new TargetPermanent(filter));\r\n        this.addAbility(ability);\r\n\r\n        // -8: Each player shuffles his or her hand and graveyard into his or her library. You draw seven cards.\r\n        this.addAbility(new LoyaltyAbility(new JaceTheLivingGuildpactEffect(), -8));\r\n\r\n    }","commit_id":"08d0a3662c896f2cc7b0c1cfcd68d49877ab9300","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getText(Mode mode) {\n        StringBuilder sb = new StringBuilder();\n        if (numberToPick.calculate(null, null) > 0) {\n            \n                if (revealPickedCards) {\n                    sb.append(\". You may reveal \");\n                    sb.append(filter.getMessage()).append(\" from among them and put it into your \");\n                } else {\n                    if (targetPickedCards.equals(Zone.BATTLEFIELD)) {\n                        sb.append(\". You \");\n                        if (optional) {\n                            sb.append(\"may \");\n                        }\n                        sb.append(\"put \").append(filter.getMessage()).append(\" from among them onto the \");\n                    } else {\n                        sb.append(\". Put one of them into your \");\n                    }\n                }\n                sb.append(targetPickedCards.toString().toLowerCase());\n\n            if (targetZoneLookedCards == Zone.LIBRARY) {\n                sb.append(\". Put the rest \");\n                if (putOnTop) {\n                    sb.append(\"back \");\n                } else {\n                    sb.append(\"on the bottom of your library \");\n                }\n                sb.append(\"in any order\");\n            } else if (targetZoneLookedCards == Zone.GRAVEYARD) {\n                sb.append(\" and the other into your graveyard\");\n            }\n        }\n        // get text frame from super class and inject action text\n        return setText(mode, sb.toString());\n    }","id":95491,"modified_method":"@Override\n    public String getText(Mode mode) {\n        if (staticText != null && !staticText.isEmpty()) {\n            return staticText;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (numberToPick.calculate(null, null) > 0) {\n            \n                if (revealPickedCards) {\n                    sb.append(\". You may reveal \");\n                    sb.append(filter.getMessage()).append(\" from among them and put it into your \");\n                } else {\n                    if (targetPickedCards.equals(Zone.BATTLEFIELD)) {\n                        sb.append(\". You \");\n                        if (optional) {\n                            sb.append(\"may \");\n                        }\n                        sb.append(\"put \").append(filter.getMessage()).append(\" from among them onto the \");\n                    } else {\n                        sb.append(\". Put one of them into your \");\n                    }\n                }\n                sb.append(targetPickedCards.toString().toLowerCase());\n\n            if (targetZoneLookedCards == Zone.LIBRARY) {\n                sb.append(\". Put the rest \");\n                if (putOnTop) {\n                    sb.append(\"back \");\n                } else {\n                    sb.append(\"on the bottom of your library \");\n                }\n                sb.append(\"in any order\");\n            } else if (targetZoneLookedCards == Zone.GRAVEYARD) {\n                sb.append(\" and the other into your graveyard\");\n            }\n        }\n        // get text frame from super class and inject action text\n        return setText(mode, sb.toString());\n    }","commit_id":"08d0a3662c896f2cc7b0c1cfcd68d49877ab9300","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getText(Mode mode) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Target \").append(mode.getTargets().get(0).getTargetName()).append(\" loses all abilities \").append(duration.toString());\n        return sb.toString();\n    }","id":95492,"modified_method":"@Override\n    public String getText(Mode mode) {\n        if (staticText != null && !staticText.isEmpty()) {\n            return staticText;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Target \").append(mode.getTargets().get(0).getTargetName()).append(\" loses all abilities \").append(duration.toString());\n        return sb.toString();\n    }","commit_id":"08d0a3662c896f2cc7b0c1cfcd68d49877ab9300","url":"https://github.com/magefree/mage"},{"original_method":"public SoulOfTheros(UUID ownerId) {\r\n        super(ownerId, 34, \"Soul of Theros\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{4}{W}{W}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Avatar\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(6);\r\n        this.toughness = new MageInt(6);\r\n\r\n        // Vigilance\r\n        this.addAbility(VigilanceAbility.getInstance());\r\n        \r\n        // {4}{W}{W}: Creatures you control get +2/+2 and gain first strike and lifelink until end of turn.\r\n        Effect effect1 = new BoostControlledEffect(2, 2, Duration.EndOfTurn);\r\n        effect1.setText(\"Creatures you control get +2/+2\");\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect1, new ManaCostsImpl(\"{4}{W}{W}\"));\r\n        Effect effect2 = new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);\r\n        effect2.setText(\"and gain first strike\");\r\n        ability.addEffect(effect2);\r\n        Effect effect3 = new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn);\r\n        effect3.setText(\"and lifelink until end of turn\");\r\n        ability.addEffect(effect3);\r\n        this.addAbility(ability);\r\n\r\n        // {4}{W}{W}, Exile Soul of Theros from your graveyard: Creatures you control get +2/+2 and gain first strike and lifelink until end of turn.\r\n        ability = new SimpleActivatedAbility(Zone.GRAVEYARD, effect1, new ManaCostsImpl(\"{4}{W}{W}\"));\r\n        ability.addCost(new ExileSourceCost());\r\n        ability.addEffect(effect2);\r\n        ability.addEffect(effect3);\r\n        this.addAbility(ability);\r\n    }","id":95493,"modified_method":"public SoulOfTheros(UUID ownerId) {\r\n        super(ownerId, 34, \"Soul of Theros\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{4}{W}{W}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Avatar\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(6);\r\n        this.toughness = new MageInt(6);\r\n\r\n        // Vigilance\r\n        this.addAbility(VigilanceAbility.getInstance());\r\n        \r\n        // {4}{W}{W}: Creatures you control get +2/+2 and gain first strike and lifelink until end of turn.\r\n        Effect effect1 = new BoostControlledEffect(2, 2, Duration.EndOfTurn);\r\n        effect1.setText(\"Creatures you control get +2/+2\");\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect1, new ManaCostsImpl(\"{4}{W}{W}\"));\r\n        Effect effect2 = new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);\r\n        effect2.setText(\"and gain first strike\");\r\n        ability.addEffect(effect2);\r\n        Effect effect3 = new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn);\r\n        effect3.setText(\"and lifelink until end of turn\");\r\n        ability.addEffect(effect3);\r\n        this.addAbility(ability);\r\n\r\n        // {4}{W}{W}, Exile Soul of Theros from your graveyard: Creatures you control get +2/+2 and gain first strike and lifelink until end of turn.\r\n        ability = new SimpleActivatedAbility(Zone.GRAVEYARD, effect1, new ManaCostsImpl(\"{4}{W}{W}\"));\r\n        ability.addCost(new ExileSourceFromGraveCost());\r\n        ability.addEffect(effect2);\r\n        ability.addEffect(effect3);\r\n        this.addAbility(ability);\r\n    }","commit_id":"08d0a3662c896f2cc7b0c1cfcd68d49877ab9300","url":"https://github.com/magefree/mage"},{"original_method":"public TurnToFrog(UUID ownerId) {\r\n        super(ownerId, 78, \"Turn to Frog\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{U}\");\r\n        this.expansionSetCode = \"M12\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Target creature loses all abilities and becomes a 1/1 blue Frog until end of turn.\r\n        this.getSpellAbility().addEffect(new LoseAllAbilitiesTargetEffect(Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new BecomesCreatureTargetEffect(new FrogToken(), null, Duration.EndOfTurn));\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n    }","id":95494,"modified_method":"public TurnToFrog(UUID ownerId) {\r\n        super(ownerId, 78, \"Turn to Frog\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{U}\");\r\n        this.expansionSetCode = \"M12\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Until end of turn, target creature loses all abilities and becomes a blue Frog with base power and toughness 1/1.\r\n        Effect effect = new LoseAllAbilitiesTargetEffect(Duration.EndOfTurn);\r\n        effect.setText(\"Until end of turn, target creature loses all abilities\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new BecomesCreatureTargetEffect(new FrogToken(), null, Duration.EndOfTurn);\r\n        effect.setText(\"and becomes a blue Frog with base power and toughness 1/1\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n    }","commit_id":"08d0a3662c896f2cc7b0c1cfcd68d49877ab9300","url":"https://github.com/magefree/mage"},{"original_method":"public ReadyWilling(UUID ownerId) {\r\n        super(ownerId, 132, \"Ready\", \"Willing\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{1}{G}{W}\", \"{1}{W}{B}\", true);\r\n        this.expansionSetCode = \"DGM\";\r\n\r\n        this.color.setGreen(true);\r\n        this.color.setWhite(true);\r\n        this.color.setBlack(true);\r\n\r\n        // Ready\r\n        // Creatures you control are indestructible this turn. Untap each creature you control.\r\n        getLeftHalfCard().getColor().setGreen(true);\r\n        getLeftHalfCard().getColor().setWhite(true);\r\n        getLeftHalfCard().getSpellAbility().addEffect(\r\n                new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent(\"Creatures you controll\"), false));\r\n        getLeftHalfCard().getSpellAbility().addEffect(new UntapAllControllerEffect(new FilterControlledCreaturePermanent(),\"Untap each creature you control\"));\r\n\r\n        // Willing\r\n        // Creatures you control gain deathtouch and lifelink until end of turn.\r\n        getRightHalfCard().getColor().setWhite(true);\r\n        getRightHalfCard().getColor().setBlack(true);\r\n        getRightHalfCard().getSpellAbility().addEffect(new GainAbilityControlledEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent(\"Creatures\")) );\r\n        Effect effect = new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent(\"Creatures\"));\r\n        effect.setText(\"Creatures you control gain lifelink until end of turn.\");\r\n        getRightHalfCard().getSpellAbility().addEffect(effect);\r\n\r\n    }","id":95495,"modified_method":"public ReadyWilling(UUID ownerId) {\r\n        super(ownerId, 132, \"Ready\", \"Willing\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{1}{G}{W}\", \"{1}{W}{B}\", true);\r\n        this.expansionSetCode = \"DGM\";\r\n\r\n        this.color.setGreen(true);\r\n        this.color.setWhite(true);\r\n        this.color.setBlack(true);\r\n\r\n        // Ready\r\n        // Creatures you control are indestructible this turn. Untap each creature you control.\r\n        getLeftHalfCard().getColor().setGreen(true);\r\n        getLeftHalfCard().getColor().setWhite(true);\r\n        Effect effect = new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent(\"Creatures you controll\"), false);\r\n        effect.setText(\"Creatures you control are indestructible this turn\");\r\n        getLeftHalfCard().getSpellAbility().addEffect(effect);\r\n        getLeftHalfCard().getSpellAbility().addEffect(new UntapAllControllerEffect(new FilterControlledCreaturePermanent(),\"Untap each creature you control\"));\r\n\r\n        // Willing\r\n        // Creatures you control gain deathtouch and lifelink until end of turn.\r\n        getRightHalfCard().getColor().setWhite(true);\r\n        getRightHalfCard().getColor().setBlack(true);\r\n        getRightHalfCard().getSpellAbility().addEffect(new GainAbilityControlledEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent(\"Creatures\")) );\r\n        effect = new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent(\"Creatures\"));\r\n        effect.setText(\"Creatures you control gain lifelink until end of turn\");\r\n        getRightHalfCard().getSpellAbility().addEffect(effect);\r\n\r\n    }","commit_id":"7c579c198d84c51ffd662a7c3cfbae0df14ff59a","url":"https://github.com/magefree/mage"},{"original_method":"public Smash(UUID ownerId) {\r\n        super(ownerId, 69, \"Smash\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"APC\";\r\n        this.color.setRed(true);\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect());\r\n        this.getSpellAbility().addTarget(new TargetPermanent(filter));\r\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\r\n    }","id":95496,"modified_method":"public Smash(UUID ownerId) {\r\n        super(ownerId, 69, \"Smash\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"APC\";\r\n        this.color.setRed(true);\r\n\r\n        // Destroy target artifact.\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect(true));\r\n        this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactPermanent()));\r\n        // Draw a card.\r\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\r\n    }","commit_id":"6b1fe53fac2f41259e547e4726ba80dce2b38f4e","url":"https://github.com/magefree/mage"},{"original_method":"public SwiftJustice(UUID ownerId) {\r\n        super(ownerId, 26, \"Swift Justice\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{W}\");\r\n        this.expansionSetCode = \"RTR\";\r\n        this.color.setWhite(true);\r\n\r\n        // Until end of turn, target creature gets +1/+0 and gains first strike and lifelink.\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n        this.getSpellAbility().addEffect(new BoostTargetEffect(1,0,Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn));\r\n    }","id":95497,"modified_method":"public SwiftJustice(UUID ownerId) {\r\n        super(ownerId, 26, \"Swift Justice\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{W}\");\r\n        this.expansionSetCode = \"RTR\";\r\n        this.color.setWhite(true);\r\n\r\n        // Until end of turn, target creature gets +1/+0 and gains first strike and lifelink.\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(true));\r\n        Effect effect = new BoostTargetEffect(1,0,Duration.EndOfTurn);\r\n        effect.setText(\"Until end of turn, target creature gets +1/+0\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);\r\n        effect.setText(\"and gains first strike\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new GainAbilityTargetEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn);\r\n        effect.setText(\"and lifelink\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"6b1fe53fac2f41259e547e4726ba80dce2b38f4e","url":"https://github.com/magefree/mage"},{"original_method":"public Unsummon(UUID ownerId) {\n        super(ownerId, 122, \"Unsummon\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{U}\");\n        this.expansionSetCode = \"10E\";\n        this.color.setBlue(true);\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n        this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());\n    }","id":95498,"modified_method":"public Unsummon(UUID ownerId) {\n        super(ownerId, 122, \"Unsummon\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{U}\");\n        this.expansionSetCode = \"10E\";\n        this.color.setBlue(true);\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(true));\n        this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());\n    }","commit_id":"6b1fe53fac2f41259e547e4726ba80dce2b38f4e","url":"https://github.com/magefree/mage"},{"original_method":"public Zap(UUID ownerId) {\r\n        super(ownerId, 180, \"Zap\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"INV\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Zap deals 1 damage to target creature or player.\r\n        this.getSpellAbility().addEffect(new DamageTargetEffect(1));\r\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());\r\n        // Draw a card.\r\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\r\n    }","id":95499,"modified_method":"public Zap(UUID ownerId) {\r\n        super(ownerId, 180, \"Zap\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{R}\");\r\n        this.expansionSetCode = \"INV\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Zap deals 1 damage to target creature or player.\r\n        this.getSpellAbility().addEffect(new DamageTargetEffect(1));\r\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer(true));\r\n        // Draw a card.\r\n        this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));\r\n    }","commit_id":"6b1fe53fac2f41259e547e4726ba80dce2b38f4e","url":"https://github.com/magefree/mage"},{"original_method":"public DeceiverOfFormEffect() {\r\n        super(Outcome.Copy);\r\n        this.staticText = \"At the beginning of combat on your turn, reveal the top card of your library. If a creature card is revealed this way, you may have creatures you control other than Deceiver of Form becomes copies of that card until end of turn. You may put that card on the bottom of your library\";\r\n    }","id":95500,"modified_method":"public DeceiverOfFormEffect() {\n        super(Outcome.Copy);\n        this.staticText = \"reveal the top card of your library. If a creature card is revealed this way, you may have creatures you control other than Deceiver of Form becomes copies of that card until end of turn. You may put that card on the bottom of your library\";\n    }","commit_id":"be05be87337b51cef1f883b4847df1c4ec4372ac","url":"https://github.com/magefree/mage"},{"original_method":"public DeceiverOfFormCopyEffect(Card card) {\r\n        super(Duration.WhileOnBattlefield, Layer.CopyEffects_1, SubLayer.NA, Outcome.BecomeCreature);\r\n        this.card = card;\r\n        staticText = \"becomes copies of that card until end of turn\";\r\n    }","id":95501,"modified_method":"public DeceiverOfFormCopyEffect(Card card) {\n        super(Duration.EndOfTurn, Layer.CopyEffects_1, SubLayer.NA, Outcome.BecomeCreature);\n        this.card = card;\n        staticText = \"becomes copies of that card until end of turn\";\n    }","commit_id":"be05be87337b51cef1f883b4847df1c4ec4372ac","url":"https://github.com/magefree/mage"},{"original_method":"public SparkmagesGambit(UUID ownerId) {\n        super(ownerId, 117, \"Sparkmage's Gambit\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{1}{R}\");\n        this.expansionSetCode = \"OGW\";\n\n        // Sparkmage's Gambit deals 1 damage to each of up to two target creatures. Those creatures can't block this turn.\n        this.getSpellAbility().addEffect(new DamageTargetEffect(1));\n        this.getSpellAbility().addEffect(new CantBlockTargetEffect(Duration.EndOfTurn));\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));\n    }","id":95502,"modified_method":"public SparkmagesGambit(UUID ownerId) {\n        super(ownerId, 117, \"Sparkmage's Gambit\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{1}{R}\");\n        this.expansionSetCode = \"OGW\";\n\n        // Sparkmage's Gambit deals 1 damage to each of up to two target creatures. Those creatures can't block this turn.\n        Effect effect = new DamageTargetEffect(1);\n        effect.setText(\"{this} deals 1 damage to each of up to two target creatures. \");\n        this.getSpellAbility().addEffect(effect);\n        effect = new CantBlockTargetEffect(Duration.EndOfTurn);\n        effect.setText(\"Those creatures can't block this turn\");\n        this.getSpellAbility().addEffect(effect);\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));\n    }","commit_id":"be05be87337b51cef1f883b4847df1c4ec4372ac","url":"https://github.com/magefree/mage"},{"original_method":"public BloodHost(UUID ownerId) {\r\n        super(ownerId, 87, \"Blood Host\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{3}{B}{B}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Vampire\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // {1}{B}, Sacrifice another creature: Put a +1/+1 counter on Blood Host\r\n        Effect effect = new AddCountersSourceEffect(CounterType.P1P1.createInstance());\r\n        effect.setText(\"Put a +1/+1 counter on {this}\");\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new SacrificeTargetCost(new TargetControlledPermanent(filter)));\r\n        // and you gain 2 life.\r\n        effect = new GainLifeEffect(2);\r\n        effect.setText(\"and you gain 2 life\");\r\n        ability.addEffect(effect);\r\n        ability.addCost(new GenericManaCost(1));\r\n        ability.addCost(new ColoredManaCost(ColoredManaSymbol.B));\r\n        this.addAbility(ability);\r\n    }","id":95503,"modified_method":"public BloodHost(UUID ownerId) {\r\n        super(ownerId, 87, \"Blood Host\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{3}{B}{B}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Vampire\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // {1}{B}, Sacrifice another creature: Put a +1/+1 counter on Blood Host\r\n        Effect effect = new AddCountersSourceEffect(CounterType.P1P1.createInstance());\r\n        effect.setText(\"Put a +1/+1 counter on {this}\");\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl(\"{1}{B}\"));\r\n        ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));\r\n        // and you gain 2 life.\r\n        effect = new GainLifeEffect(2);\r\n        effect.setText(\"and you gain 2 life\");\r\n        ability.addEffect(effect);\r\n        this.addAbility(ability);\r\n    }","commit_id":"e5aec13610dfbbb02533ee83ffebb730b699dfbd","url":"https://github.com/magefree/mage"},{"original_method":"public CovenantOfBlood(UUID ownerId) {\r\n        super(ownerId, 91, \"Covenant of Blood\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{6}{B}\");\r\n        this.expansionSetCode = \"M15\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Convoke\r\n        this.addAbility(new ConvokeAbility());\r\n        \r\n        // Covenant of Blood deals 4 damage\r\n        this.getSpellAbility().addEffect(new DamageTargetEffect(4));\r\n        // to target creature or player\r\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());\r\n        // and you gain 4 life.\r\n        this.getSpellAbility().addEffect(new GainLifeEffect(4));\r\n    }","id":95504,"modified_method":"public CovenantOfBlood(UUID ownerId) {\r\n        super(ownerId, 91, \"Covenant of Blood\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{6}{B}\");\r\n        this.expansionSetCode = \"M15\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Convoke\r\n        this.addAbility(new ConvokeAbility());\r\n        \r\n        // Covenant of Blood deals 4 damage to target creature or player\r\n        Effect effect = new DamageTargetEffect(4);\r\n        effect.setText(\"{this} deals 4 damage to target creature or player\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        // and you gain 4 life.\r\n        effect = new GainLifeEffect(4);\r\n        effect.setText(\"and you gain 4 life\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());\r\n    }","commit_id":"e5aec13610dfbbb02533ee83ffebb730b699dfbd","url":"https://github.com/magefree/mage"},{"original_method":"public CruelSadist(UUID ownerId) {\r\n        super(ownerId, 93, \"Cruel Sadist\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{B}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Assassin\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // {B}, {T}, Pay 1 life: Put a +1/+1 counter on Cruel Sadist.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new ColoredManaCost(ColoredManaSymbol.B));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new PayLifeCost(1));\r\n        this.addAbility(ability);\r\n               \r\n        // {2}{B}, {T}, Remove X +1/+1 counters from Cruel Sadist: Cruel Sadist deals X damage to target creature.\r\n        Effect effect = new DamageTargetEffect(new RemovedCountersForCostValue());\r\n        effect.setText(\"{this} deals X damage to target creature\");\r\n        ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(2));\r\n        ability.addCost(new ColoredManaCost(ColoredManaSymbol.B));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new RemoveVariableCountersSourceCost(CounterType.P1P1.createInstance()));\r\n        ability.addTarget(new TargetCreaturePermanent());\r\n        this.addAbility(ability);\r\n    }","id":95505,"modified_method":"public CruelSadist(UUID ownerId) {\r\n        super(ownerId, 93, \"Cruel Sadist\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{B}\");\r\n        this.expansionSetCode = \"M15\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Assassin\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // {B}, {T}, Pay 1 life: Put a +1/+1 counter on Cruel Sadist.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new ColoredManaCost(ColoredManaSymbol.B));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new PayLifeCost(1));\r\n        this.addAbility(ability);\r\n               \r\n        // {2}{B}, {T}, Remove X +1/+1 counters from Cruel Sadist: Cruel Sadist deals X damage to target creature.\r\n        Effect effect = new DamageTargetEffect(new RemovedCountersForCostValue());\r\n        effect.setText(\"{this} deals X damage to target creature\");\r\n        ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl(\"{2}{B}\"));\r\n        ability.addCost(new TapSourceCost());\r\n        ability.addCost(new RemoveVariableCountersSourceCost(CounterType.P1P1.createInstance()));\r\n        ability.addTarget(new TargetCreaturePermanent());\r\n        this.addAbility(ability);\r\n    }","commit_id":"e5aec13610dfbbb02533ee83ffebb730b699dfbd","url":"https://github.com/magefree/mage"},{"original_method":"public ForiysianTotemToken() {\n        super(\"\", \"4/4 red Giant artifact creature\");\n        cardType.add(CardType.CREATURE);\n        cardType.add(CardType.ARTIFACT);\n        subtype.add(\"Giant\");\n        color.setRed(true);\n        power = new MageInt(4);\n        toughness = new MageInt(4);\n        this.addAbility(TrampleAbility.getInstance());\n    }","id":95506,"modified_method":"public ForiysianTotemToken() {\n        super(\"\", \"4/4 red Giant artifact creature with trample\");\n        cardType.add(CardType.CREATURE);\n        cardType.add(CardType.ARTIFACT);\n        subtype.add(\"Giant\");\n        color.setRed(true);\n        power = new MageInt(4);\n        toughness = new MageInt(4);\n        this.addAbility(TrampleAbility.getInstance());\n    }","commit_id":"85d02a77e6e1ccd464683d2781ea4fcc9d642299","url":"https://github.com/magefree/mage"},{"original_method":"public GruesomeSlaughter(UUID ownerId) {\n        super(ownerId, 9, \"Gruesome Slaughter\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{6}\");\n        this.expansionSetCode = \"BFZ\";\n\n        // Until end of turn, colorless creatures you control gain \"{T}: This creature deals damage equal to its power to target creature.\"\n        Effect effect = new DamageTargetEffect(new SourcePermanentPowerCount());\n        effect.setText(\"{this} deals damage equal to its power to target creature.\");\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());\n        ability.addTarget(new TargetCreaturePermanent());\n        this.getSpellAbility().addEffect(new GainAbilityControlledEffect(ability, Duration.EndOfTurn, filter));\n    }","id":95507,"modified_method":"public GruesomeSlaughter(UUID ownerId) {\n        super(ownerId, 9, \"Gruesome Slaughter\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{6}\");\n        this.expansionSetCode = \"BFZ\";\n\n        // Until end of turn, colorless creatures you control gain \"{T}: This creature deals damage equal to its power to target creature.\"\n        Effect effect = new DamageTargetEffect(new SourcePermanentPowerCount());\n        effect.setText(\"{this} deals damage equal to its power to target creature.\");\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());\n        ability.addTarget(new TargetCreaturePermanent());\n        effect = new GainAbilityControlledEffect(ability, Duration.EndOfTurn, filter);\n        effect.setText(\"Until end of turn, colorless creatures you control gain \\\"{T}: This creature deals damage equal to its power to target creature.\\\"\");\n        this.getSpellAbility().addEffect(effect);\n    }","commit_id":"85d02a77e6e1ccd464683d2781ea4fcc9d642299","url":"https://github.com/magefree/mage"},{"original_method":"public GarrukWildspeaker(UUID ownerId) {\n        super(ownerId, 183, \"Garruk Wildspeaker\", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, \"{2}{G}{G}\");\n        this.expansionSetCode = \"M10\";\n        this.subtype.add(\"Garruk\");\n        this.color.setGreen(true);\n        this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.LOYALTY.createInstance(3)), false));\n\n\n        LoyaltyAbility ability1 = new LoyaltyAbility(new UntapTargetEffect(), 1);\n        ability1.addTarget(new TargetLandPermanent(2));\n        this.addAbility(ability1);\n\n        this.addAbility(new LoyaltyAbility(new CreateTokenEffect(beastToken), -1));\n\n        Effects effects1 = new Effects();\n        effects1.add(new BoostControlledEffect(3, 3, Duration.EndOfTurn));\n        effects1.add(new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent()));\n        this.addAbility(new LoyaltyAbility(effects1, -4));\n    }","id":95508,"modified_method":"public GarrukWildspeaker(UUID ownerId) {\n        super(ownerId, 183, \"Garruk Wildspeaker\", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, \"{2}{G}{G}\");\n        this.expansionSetCode = \"M10\";\n        this.subtype.add(\"Garruk\");\n        this.color.setGreen(true);\n\n        this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.LOYALTY.createInstance(3)), false));\n\n        // +1: Untap two target lands.\n        LoyaltyAbility ability1 = new LoyaltyAbility(new UntapTargetEffect(), 1);\n        ability1.addTarget(new TargetLandPermanent(2));\n        this.addAbility(ability1);\n\n        // −1: Put a 3/3 green Beast creature token onto the battlefield.\n        this.addAbility(new LoyaltyAbility(new CreateTokenEffect(beastToken), -1));\n\n        // −4: Creatures you control get +3/+3 and gain trample until end of turn.\n        Effects effects1 = new Effects();\n        Effect effect = new BoostControlledEffect(3, 3, Duration.EndOfTurn);\n        effect.setText(\"Creatures you control get +3/+3\");\n        effects1.add(effect);\n        effect = new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent());\n        effect.setText(\"and gain trample until end of turn\");\n        effects1.add(effect);\n        this.addAbility(new LoyaltyAbility(effects1, -4));\n    }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player != null) {\n            TargetCardInLibrary target = new TargetCardInLibrary(new FilterArtifactCard());\n            if (player.searchLibrary(target, game)) {\n                if (target.getTargets().size() > 0) {\n                    Card card = player.getLibrary().getCard(target.getFirstTarget(), game);\n                    if (card != null) {\n                        card.moveToExile(exileId, \"Hoarding Dragon\", source.getSourceId(), game);\n                    }\n                }\n            }\n            player.shuffleLibrary(game);\n            return true;\n        }       \n        return false;\n    }","id":95509,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            TargetCardInLibrary target = new TargetCardInLibrary(new FilterArtifactCard());\n            if (controller.searchLibrary(target, game)) {\n                if (target.getTargets().size() > 0) {\n                    Card card = controller.getLibrary().getCard(target.getFirstTarget(), game);\n                    if (card != null) {\n                        controller.moveCardToExileWithInfo(card, exileId, \"Hoarding Dragon\", source.getSourceId(), game, Zone.LIBRARY);\n                    }\n                }\n            }\n            controller.shuffleLibrary(game);\n            return true;\n        }       \n        return false;\n    }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"public LifesLegacy(UUID ownerId) {\r\n        super(ownerId, 183, \"Life's Legacy\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{1}{G}\");\r\n        this.expansionSetCode = \"M15\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // As an additional cost to cast Life's Legacy, sacrifice a creature.\r\n        this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));\r\n        // Draw cards equal to the sacrificed creature's power.\r\n        this.getSpellAbility().addEffect(new LifesLegacyEffect());\r\n\r\n    }","id":95510,"modified_method":"public LifesLegacy(UUID ownerId) {\r\n        super(ownerId, 183, \"Life's Legacy\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{1}{G}\");\r\n        this.expansionSetCode = \"M15\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // As an additional cost to cast Life's Legacy, sacrifice a creature.\r\n        this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent(\"a creature\"))));\r\n        // Draw cards equal to the sacrificed creature's power.\r\n        this.getSpellAbility().addEffect(new LifesLegacyEffect());\r\n\r\n    }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"public ProteanHydraEffect2() {\n            super(Duration.WhileOnBattlefield);\n        }","id":95511,"modified_method":"public ProteanHydraEffect2() {\n            super(Duration.WhileOnBattlefield);\n            staticText = \"If damage would be dealt to {this}, prevent that damage and remove that many +1/+1 counters from it\";\n        }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"public ProteanHydraEffect2(final ProteanHydraEffect2 effect) {\n            super(effect);\n            staticText = \"If damage would be dealt to {this}, prevent that damage and remove that many +1/+1 counters from it\";\n        }","id":95512,"modified_method":"public ProteanHydraEffect2(final ProteanHydraEffect2 effect) {\n            super(effect);            \n        }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"public ProteanHydra(UUID ownerId) {\n        super(ownerId, 200, \"Protean Hydra\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{X}{G}\");\n        this.expansionSetCode = \"M10\";\n        this.subtype.add(\"Hydra\");\n        this.color.setGreen(true);\n        this.power = new MageInt(0);\n        this.toughness = new MageInt(0);\n\n        this.addAbility(new EntersBattlefieldAbility(new ProteanHydraEffect1(), \"with X +1/+1 counters on it\"));\n        this.addAbility(new ProteanHydraAbility());\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ProteanHydraEffect2()));\n    }","id":95513,"modified_method":"public ProteanHydra(UUID ownerId) {\n        super(ownerId, 200, \"Protean Hydra\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{X}{G}\");\n        this.expansionSetCode = \"M10\";\n        this.subtype.add(\"Hydra\");\n        this.color.setGreen(true);\n        this.power = new MageInt(0);\n        this.toughness = new MageInt(0);\n\n\n        // Protean Hydra enters the battlefield with X +1/+1 counters on it.\n        this.addAbility(new EntersBattlefieldAbility(new ProteanHydraEffect1(), \"with X +1/+1 counters on it\"));\n        \n        // If damage would be dealt to Protean Hydra, prevent that damage and remove that many +1/+1 counters from it.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ProteanHydraEffect2()));\n\n        // Whenever a +1/+1 counter is removed from Protean Hydra, put two +1/+1 counters on it at the beginning of the next end step.\n        this.addAbility(new ProteanHydraAbility());\n\n    }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"public RangersGuile(UUID ownerId) {\r\n        super(ownerId, 201, \"Ranger's Guile\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{G}\");\r\n        this.expansionSetCode = \"ISD\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // Target creature you control gets +1/+1 and gains hexproof until end of turn.\r\n        this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());\r\n        this.getSpellAbility().addEffect(new BoostTargetEffect(1, 1, Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HexproofAbility.getInstance(), Duration.EndOfTurn));\r\n    }","id":95514,"modified_method":"public RangersGuile(UUID ownerId) {\r\n        super(ownerId, 201, \"Ranger's Guile\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{G}\");\r\n        this.expansionSetCode = \"ISD\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // Target creature you control gets +1/+1 and gains hexproof until end of turn.\r\n        this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());\r\n        Effect effect = new BoostTargetEffect(1, 1, Duration.EndOfTurn);\r\n        effect.setText(\"Target creature you control gets +1/+1\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        effect = new GainAbilityTargetEffect(HexproofAbility.getInstance(), Duration.EndOfTurn);\r\n        effect.setText(\"and gains hexproof until end of turn\");\r\n        this.getSpellAbility().addEffect(effect);\r\n    }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getRule() {\n        String superRule = super.getRule(true);\n        StringBuilder sb = new StringBuilder();\n        if (!superRule.isEmpty()) {\n            String ruleLow = superRule.toLowerCase();\n            if (optional) {\n                if (ruleLow.startsWith(\"you \")) {\n                    if (!ruleLow.startsWith(\"you may\")) {\n                        StringBuilder newRule = new StringBuilder(superRule);\n                        newRule.insert(4, \"may \");\n                        superRule = newRule.toString();\n                    }\n                } else {\n                    if (this.getTargets().isEmpty()\n                            || ruleLow.startsWith(\"exile\")\n                            || ruleLow.startsWith(\"destroy\")\n                            || ruleLow.startsWith(\"return\")\n                            || ruleLow.startsWith(\"tap\")\n                            || ruleLow.startsWith(\"untap\")) {\n                        sb.append(\"you may \");\n                    } else {\n                        if (!ruleLow.startsWith(\"its controller may\")) {\n                            sb.append(\"you may have \");\n                        }\n                    }\n                }\n\n            }\n            sb.append(superRule);\n        }\n\n        return sb.toString();\n    }","id":95515,"modified_method":"@Override\n    public String getRule() {\n        String superRule = super.getRule(true);\n        StringBuilder sb = new StringBuilder();\n        if (!superRule.isEmpty()) {\n            String ruleLow = superRule.toLowerCase();\n            if (optional) {\n                if (ruleLow.startsWith(\"you \")) {\n                    if (!ruleLow.startsWith(\"you may\")) {\n                        StringBuilder newRule = new StringBuilder(superRule);\n                        newRule.insert(4, \"may \");\n                        superRule = newRule.toString();\n                    }\n                } else {\n                    if (this.getTargets().isEmpty()\n                            || ruleLow.startsWith(\"exile\")\n                            || ruleLow.startsWith(\"destroy\")\n                            || ruleLow.startsWith(\"return\")\n                            || ruleLow.startsWith(\"tap\")\n                            || ruleLow.startsWith(\"untap\")\n                            || ruleLow.startsWith(\"put\")) {\n                        sb.append(\"you may \");\n                    } else {\n                        if (!ruleLow.startsWith(\"its controller may\")) {\n                            sb.append(\"you may have \");\n                        }\n                    }\n                }\n\n            }\n            sb.append(superRule);\n        }\n\n        return sb.toString();\n    }","commit_id":"15b08c110e9ab73ec156a96b580816dbb624bab1","url":"https://github.com/magefree/mage"},{"original_method":"public MightyLeap(UUID ownerId) {\n        super(ownerId, 22, \"Mighty Leap\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\n        this.expansionSetCode = \"M11\";\n        this.color.setWhite(true);\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n        this.getSpellAbility().addEffect(new BoostTargetEffect(2, 2, Duration.EndOfTurn));\n        this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));\n    }","id":95516,"modified_method":"public MightyLeap(UUID ownerId) {\n        super(ownerId, 22, \"Mighty Leap\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\n        this.expansionSetCode = \"M11\";\n\n        // Target creature gets +2/+2 and gains flying until end of turn.\n        Effect effect = new BoostTargetEffect(2, 2, Duration.EndOfTurn);\n        effect.setText(\"Target creature gets +2/+2\");\n        this.getSpellAbility().addEffect(effect);\n        effect = new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);\n        effect.setText(\"and gains flying until end of turn\");\n        this.getSpellAbility().addEffect(effect);\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n    }","commit_id":"41b6a41fdafcd35adceeaa1442801ddd2c22ffad","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {\n        Card card = game.getCard(sourceId);\n        if (card != null && filter.match(card, game)) {\n            Player player = game.getPlayer(card.getOwnerId());\n            if (player != null && card.equals(player.getLibrary().getFromTop(game))) {\n                return true;\n            }\n        }\n        return false;\n    }","id":95517,"modified_method":"@Override\n    public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {\n        Card cardOnTop = game.getCard(objectId);\n        if (cardOnTop != null &&\n                affectedControllerId.equals(source.getControllerId()) &&\n                filter.match(cardOnTop, game)) {\n            Player player = game.getPlayer(cardOnTop.getOwnerId());\n            if (player != null && cardOnTop.equals(player.getLibrary().getFromTop(game))) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"41b6a41fdafcd35adceeaa1442801ddd2c22ffad","url":"https://github.com/magefree/mage"},{"original_method":"private List<CustomNode> parseNodeRange(final Map<String, String> nodeMap) throws InstallerException {\r\n\r\n\t\tfinal List<CustomNode> cloudNodes = new ArrayList<CustomNode>();\r\n\t\tfinal String idPrefix = nodeMap.get(CLOUD_NODE_ID_PREFIX);\r\n\t\tfinal String ipRange = nodeMap.get(CLOUD_NODE_IP_RANGE);\r\n\r\n\t\t// syntax validation (IPs are validated later, through IPUtils)\r\n\t\tfinal int ipDashIndex = ipRange.indexOf(\"-\");\r\n\t\tif (ipDashIndex < 0) {\r\n\t\t\tthrow new InstallerException(\"Failed to start cloud node, invalid IP range configuration: \" + ipRange\r\n\t\t\t\t\t+ \" is missing the token \\\"-\\\"\");\r\n\t\t}\r\n\r\n\t\t// run through the range of IPs\r\n\t\tfinal String ipRangeStart = ipRange.substring(0, ipRange.indexOf(\"-\"));\r\n\t\tfinal String ipRangeEnd = ipRange.substring(ipRange.indexOf(\"-\") + 1);\r\n\r\n\t\tString ip = ipRangeStart;\r\n\t\tint index = 1;\r\n\t\ttry {\r\n\t\t\twhile (IPUtils.ip2Long(ip) <= IPUtils.ip2Long(ipRangeEnd)) {\r\n\t\t\t\tcloudNodes.add(new CustomNodeImpl(PROVIDER_ID, idPrefix + index, ip, nodeMap.get(CLOUD_NODE_USERNAME),\r\n\t\t\t\t\t\tnodeMap.get(CLOUD_NODE_CREDENTIAL), idPrefix + index));\r\n\t\t\t\tindex++;\r\n\t\t\t\tip = IPUtils.getNextIP(ip);\r\n\t\t\t}\r\n\t\t} catch (final Exception e) {\r\n\t\t\tthrow new InstallerException(\"Failed to start cloud machine.\", e);\r\n\t\t}\r\n\r\n\t\treturn cloudNodes;\r\n\t}","id":95518,"modified_method":"private List<CustomNode> parseNodeRange(final Map<String, String> nodeMap) throws CloudProvisioningException {\r\n\r\n\t\tfinal List<CustomNode> cloudNodes = new ArrayList<CustomNode>();\r\n\t\tfinal String id = nodeMap.get(CLOUD_NODE_ID);\r\n\t\tfinal String idPrefix = nodeMap.get(CLOUD_NODE_ID_PREFIX);\r\n\t\tfinal String ipRange = nodeMap.get(CLOUD_NODE_IP_RANGE);\r\n\r\n\t\t// syntax validation (IPs are validated later, through IPUtils)\r\n\t\tfinal int ipDashIndex = ipRange.indexOf(\"-\");\r\n\t\tif (ipDashIndex < 0) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud node, invalid IP range configuration: \"\r\n\t\t\t\t\t+ ipRange + \" is missing the token \\\"-\\\"\");\r\n\t\t}\r\n\r\n\t\t// run through the range of IPs\r\n\t\tfinal String ipRangeStart = ipRange.substring(0, ipRange.indexOf(\"-\"));\r\n\t\tfinal String ipRangeEnd = ipRange.substring(ipRange.indexOf(\"-\") + 1);\r\n\r\n\t\tString ip = ipRangeStart;\r\n\t\tint index = 1;\r\n\t\ttry {\r\n\t\t\tString currnentId;\r\n\t\t\twhile (IPUtils.ip2Long(ip) <= IPUtils.ip2Long(ipRangeEnd)) {\r\n\t\t\t\tif (StringUtils.isNotBlank(id)) {\r\n\t\t\t\t\tcurrnentId = MessageFormat.format(id, index);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrnentId = idPrefix + index;\r\n\t\t\t\t}\r\n\t\t\t\tcloudNodes.add(new CustomNodeImpl(PROVIDER_ID, currnentId, ip, nodeMap.get(CLOUD_NODE_USERNAME),\r\n\t\t\t\t\t\tnodeMap.get(CLOUD_NODE_CREDENTIAL), currnentId));\r\n\t\t\t\tindex++;\r\n\t\t\t\tip = IPUtils.getNextIP(ip);\r\n\t\t\t}\r\n\t\t} catch (final Exception e) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine.\", e);\r\n\t\t}\r\n\r\n\t\treturn cloudNodes;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Creates a server (AKA a machine or a node) with the assigned logical name.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverName\r\n\t *            A logical name used to uniquely identify this node (does not have to match the host name)\r\n\t * @return A node available for use\r\n\t * @throws InstallerException\r\n\t *             Indicated a new machine could not be allocated, either because the name is empty or because\r\n\t *             the nodes pool is exhausted\r\n\t */\r\n\tpublic synchronized CustomNode createServer(final String templateName, final String serverName)\r\n\t\t\tthrows InstallerException {\r\n\t\tCustomNode node = null;\r\n\r\n\t\tif (org.apache.commons.lang.StringUtils.isBlank(serverName)) {\r\n\t\t\tthrow new InstallerException(\"Failed to start cloud node, server name is missing\");\r\n\t\t}\r\n\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\r\n\t\tif (freeNodesPool.size() == 0) {\r\n\t\t\tthrow new InstallerException(\"Failed to create new cloud node, all nodes are currently used\");\r\n\t\t}\r\n\r\n\t\tnode = freeNodesPool.iterator().next();\r\n\r\n\t\tif (!allocatedNodesPool.contains(node)) {\r\n\t\t\tallocatedNodesPool.add(node);\r\n\t\t}\r\n\t\tfreeNodesPool.remove(node);\r\n\t\t((CustomNodeImpl) node).setNodeName(serverName);\r\n\r\n\t\treturn node;\r\n\t}","id":95519,"modified_method":"/**\r\n\t * Creates a server (AKA a machine or a node) with the assigned logical name.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverName\r\n\t *            A logical name used to uniquely identify this node (does not have to match the host name)\r\n\t * @return A node available for use\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicated a new machine could not be allocated, either because the name is empty or because\r\n\t *             the nodes pool is exhausted\r\n\t */\r\n\tpublic synchronized CustomNode createServer(final String templateName, final String serverName)\r\n\t\t\tthrows CloudProvisioningException {\r\n\t\tCustomNode node = null;\r\n\r\n\t\tif (org.apache.commons.lang.StringUtils.isBlank(serverName)) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to create new cloud node, server name is missing\");\r\n\t\t}\r\n\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tif (templateLists == null || templateLists.size() == 0) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to create new cloud node. \\\"\" + templateName\r\n\t\t\t\t\t+ \"\\\" is not a known template.\");\r\n\t\t}\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\r\n\t\tif (freeNodesPool.size() == 0) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to create new cloud node, all nodes are currently used\");\r\n\t\t}\r\n\r\n\t\tnode = freeNodesPool.iterator().next();\r\n\r\n\t\tif (!allocatedNodesPool.contains(node)) {\r\n\t\t\tallocatedNodesPool.add(node);\r\n\t\t}\r\n\t\tfreeNodesPool.remove(node);\r\n\t\t((CustomNodeImpl) node).setNodeName(serverName);\r\n\r\n\t\treturn node;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Retrieves the server with the given IP (not a host name).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this IP belongs to\r\n\t * @param ipAddress\r\n\t *            The IP address of the server to retrieve\r\n\t * @return A node with the given IP, if found\r\n\t */\r\n\tpublic CustomNode getServerByIP(final String templateName, final String ipAddress) {\r\n\t\tCustomNode selectedNode = null;\r\n\r\n\t\tfor (final CustomNode node : getAllNodesByTemplateName(templateName)) {\r\n\t\t\tif (StringUtils.isNotBlank(node.getPrivateIP()) && node.getPrivateIP().equalsIgnoreCase(ipAddress)\r\n\t\t\t\t\t|| StringUtils.isNotBlank(node.getPublicIP()) && node.getPublicIP().equalsIgnoreCase(ipAddress)) {\r\n\t\t\t\tselectedNode = node;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn selectedNode;\r\n\t}","id":95520,"modified_method":"/**\r\n\t * Retrieves the server with the given IP (not a host name).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this IP belongs to\r\n\t * @param ipAddress\r\n\t *            The IP address of the server to retrieve\r\n\t * @return A node with the given IP, if found\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the server could not be obtained with the specified template\r\n\t */\r\n\tpublic CustomNode getServerByIP(final String templateName, final String ipAddress)\r\n\t\t\tthrows CloudProvisioningException {\r\n\t\tCustomNode selectedNode = null;\r\n\r\n\t\tfor (final CustomNode node : getAllNodesByTemplateName(templateName)) {\r\n\t\t\tif (StringUtils.isNotBlank(node.getPrivateIP()) && node.getPrivateIP().equalsIgnoreCase(ipAddress)\r\n\t\t\t\t\t|| StringUtils.isNotBlank(node.getPublicIP()) && node.getPublicIP().equalsIgnoreCase(ipAddress)) {\r\n\t\t\t\tselectedNode = node;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn selectedNode;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Retrieves the server with the given name (not a host name).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverName\r\n\t *            The name of the server to retrieve\r\n\t * @return A node matching the given name, if found\r\n\t */\r\n\tpublic CustomNode getServerByName(final String templateName, final String serverName) {\r\n\t\tCustomNode selectedNode = null;\r\n\r\n\t\tfor (final CustomNode node : getAllNodesByTemplateName(templateName)) {\r\n\t\t\tif (node.getNodeName().equalsIgnoreCase(serverName)) {\r\n\t\t\t\tselectedNode = node;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn selectedNode;\r\n\t}","id":95521,"modified_method":"/**\r\n\t * Retrieves the server with the given name (not a host name).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverName\r\n\t *            The name of the server to retrieve\r\n\t * @return A node matching the given name, if found\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the server could not be obtained with the specified template\r\n\t */\r\n\tpublic CustomNode getServerByName(final String templateName, final String serverName)\r\n\t\t\tthrows CloudProvisioningException {\r\n\t\tCustomNode selectedNode = null;\r\n\r\n\t\tfor (final CustomNode node : getAllNodesByTemplateName(templateName)) {\r\n\t\t\tif (node.getNodeName().equalsIgnoreCase(serverName)) {\r\n\t\t\t\tselectedNode = node;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn selectedNode;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Adds a list of nodes related to a specific template.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the template this nodes-list belongs to\r\n\t * @param managementNodesList\r\n\t *            A list of maps, each map representing a cloud node\r\n\t * @throws Exception\r\n\t *             Indicates the node parsing failed\r\n\t */\r\n\tpublic synchronized void addNodesList(final String templateName, final List<Map<String, String>> nodesList)\r\n\t\t\tthrows Exception {\r\n\t\tfinal List<CustomNode> parsedNodes = parseCloudNodes(nodesList);\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = new Hashtable<String, List<CustomNode>>();\r\n\t\tfinal List<CustomNode> freeNodesPool = new ArrayList<CustomNode>();\r\n\t\tfreeNodesPool.addAll(aggregate(freeNodesPool, parsedNodes));\r\n\t\ttemplateLists.put(NODES_LIST_FREE, freeNodesPool);\r\n\t\ttemplateLists.put(NODES_LIST_ALLOCATED, new ArrayList<CustomNode>());\r\n\t\ttemplateLists.put(NODES_LIST_INVALID, new ArrayList<CustomNode>());\r\n\r\n\t\tnodesListsByTemplates.put(templateName, templateLists);\r\n\t}","id":95522,"modified_method":"/**\r\n\t * Adds a list of nodes related to a specific template.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the template this nodes-list belongs to\r\n\t * @param nodesList\r\n\t *            A list of maps, each map representing a cloud node\r\n\t * @throws Exception\r\n\t *             Indicates the node parsing failed\r\n\t */\r\n\tpublic synchronized void addNodesList(final String templateName, final List<Map<String, String>> nodesList)\r\n\t\t\tthrows Exception {\r\n\t\tfinal List<CustomNode> parsedNodes = parseCloudNodes(nodesList);\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = new Hashtable<String, List<CustomNode>>();\r\n\t\tfinal List<CustomNode> freeNodesPool = new ArrayList<CustomNode>();\r\n\t\tfreeNodesPool.addAll(aggregate(freeNodesPool, parsedNodes));\r\n\t\ttemplateLists.put(NODES_LIST_FREE, freeNodesPool);\r\n\t\ttemplateLists.put(NODES_LIST_ALLOCATED, new ArrayList<CustomNode>());\r\n\t\ttemplateLists.put(NODES_LIST_INVALID, new ArrayList<CustomNode>());\r\n\r\n\t\tnodesListsByTemplates.put(templateName, templateLists);\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Shuts down a given node, (moves the node back to the free nodes list, to be used again).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverName\r\n\t *            A server to shutdown\r\n\t */\r\n\tpublic synchronized void shutdownServer(final String templateName, final CustomNode serverName) {\r\n\t\tif (serverName == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\r\n\t\t((CustomNodeImpl) serverName).setGroup(null);\r\n\t\tallocatedNodesPool.remove(serverName);\r\n\t\tif (!freeNodesPool.contains(serverName)) {\r\n\t\t\tfreeNodesPool.add(serverName);\r\n\t\t}\r\n\t}","id":95523,"modified_method":"/**\r\n\t * Shuts down a given node, (moves the node back to the free nodes list, to be used again).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverName\r\n\t *            A server to shutdown\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the server could not be shutdown with the specified template\r\n\t */\r\n\tpublic synchronized void shutdownServer(final String templateName, final CustomNode serverName)\r\n\t\t\tthrows CloudProvisioningException {\r\n\t\tif (serverName == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tif (templateLists == null || templateLists.size() == 0) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to shutdown server \\\"\" + serverName + \"\\\". \\\"\" + templateName\r\n\t\t\t\t\t+ \"\\\" is not a known template.\");\r\n\t\t}\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\r\n\t\t((CustomNodeImpl) serverName).setGroup(null);\r\n\t\tallocatedNodesPool.remove(serverName);\r\n\t\tif (!freeNodesPool.contains(serverName)) {\r\n\t\t\tfreeNodesPool.add(serverName);\r\n\t\t}\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private CustomNode parseOneNode(final Map<String, String> nodeMap) throws InstallerException {\r\n\t\tfinal String ipAddress = nodeMap.get(CLOUD_NODE_IP);\r\n\t\tif (!IPUtils.validateIPAddress(ipAddress)) {\r\n\t\t\tthrow new InstallerException(\"Invalid IP address: \" + ipAddress);\r\n\t\t}\r\n\r\n\t\treturn new CustomNodeImpl(PROVIDER_ID, nodeMap.get(CLOUD_NODE_ID), ipAddress,\r\n\t\t\t\tnodeMap.get(CLOUD_NODE_USERNAME), nodeMap.get(CLOUD_NODE_CREDENTIAL), nodeMap.get(CLOUD_NODE_ID));\r\n\t}","id":95524,"modified_method":"private CustomNode parseOneNode(final Map<String, String> nodeMap) throws CloudProvisioningException {\r\n\t\tfinal String ipAddress = nodeMap.get(CLOUD_NODE_IP);\r\n\t\tif (!IPUtils.validateIPAddress(ipAddress)) {\r\n\t\t\tthrow new CloudProvisioningException(\"Invalid IP address: \" + ipAddress);\r\n\t\t}\r\n\r\n\t\treturn new CustomNodeImpl(PROVIDER_ID, nodeMap.get(CLOUD_NODE_ID), ipAddress,\r\n\t\t\t\tnodeMap.get(CLOUD_NODE_USERNAME), nodeMap.get(CLOUD_NODE_CREDENTIAL), nodeMap.get(CLOUD_NODE_ID));\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Shuts down the server with the given IP address.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverIp\r\n\t *            The IP of the server to shutdown (dotted decimal format)\r\n\t */\r\n\tpublic void shutdownServerByIp(final String templateName, final String serverIp) {\r\n\t\tshutdownServer(templateName, getServerByIP(templateName, serverIp));\r\n\t}","id":95525,"modified_method":"/**\r\n\t * Shuts down the server with the given IP address.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverIp\r\n\t *            The IP of the server to shutdown (dotted decimal format)\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the server could not be shutdown with the specified template\r\n\t */\r\n\tpublic void shutdownServerByIp(final String templateName, final String serverIp) throws CloudProvisioningException {\r\n\t\tshutdownServer(templateName, getServerByIP(templateName, serverIp));\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Retrieves all nodes (i.e. in all states - free, allocated and invalid).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template to use\r\n\t * @return A collection of all the managed nodes of the specified template\r\n\t */\r\n\tpublic Set<CustomNode> getAllNodesByTemplateName(final String templateName) {\r\n\t\tfinal Set<CustomNode> allNodes = new HashSet<CustomNode>();\r\n\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\t\tfinal List<CustomNode> invalidNodesPool = templateLists.get(NODES_LIST_INVALID);\r\n\r\n\t\tallNodes.addAll(freeNodesPool);\r\n\t\tallNodes.addAll(allocatedNodesPool);\r\n\t\tallNodes.addAll(invalidNodesPool);\r\n\r\n\t\treturn allNodes;\r\n\t}","id":95526,"modified_method":"/**\r\n\t * Retrieves all nodes (i.e. in all states - free, allocated and invalid).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template to use\r\n\t * @return A collection of all the managed nodes of the specified template\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the servers list could not be obtained for the given template name\r\n\t */\r\n\tpublic Set<CustomNode> getAllNodesByTemplateName(final String templateName) throws CloudProvisioningException {\r\n\t\tfinal Set<CustomNode> allNodes = new HashSet<CustomNode>();\r\n\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tif (templateLists == null || templateLists.size() == 0) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to get servers list. \\\"\" + templateName\r\n\t\t\t\t\t+ \"\\\" is not a known template.\");\r\n\t\t}\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\t\tfinal List<CustomNode> invalidNodesPool = templateLists.get(NODES_LIST_INVALID);\r\n\r\n\t\tallNodes.addAll(freeNodesPool);\r\n\t\tallNodes.addAll(allocatedNodesPool);\r\n\t\tallNodes.addAll(invalidNodesPool);\r\n\r\n\t\treturn allNodes;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Invalidates the given node (i.e. moves it from the free pool to the invalidated pool), so it will not\r\n\t * be allocated unless all the free nodes are in use.\r\n\t * \r\n\t * @param node\r\n\t *            The node to invalidate\r\n\t */\r\n\tpublic synchronized void invalidateServer(final String templateName, final CustomNode serverName) {\r\n\t\t// attempting to remove the invalid node from the active lists so it will not be used anymore, just to\r\n\t\t// be\r\n\t\t// sure.\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\t\tfinal List<CustomNode> invalidNodesPool = templateLists.get(NODES_LIST_INVALID);\r\n\r\n\t\tfreeNodesPool.remove(serverName);\r\n\t\tallocatedNodesPool.remove(serverName);\r\n\t\tif (!invalidNodesPool.contains(serverName)) {\r\n\t\t\tinvalidNodesPool.add(serverName);\r\n\t\t}\r\n\t}","id":95527,"modified_method":"/**\r\n\t * * Invalidates the given node (i.e. moves it from the free pool to the invalidated pool), so it will not\r\n\t * be allocated unless all the free nodes are in use.\r\n\t * \r\n\t * @param templateName\r\n\t *            The template this server belongs to\r\n\t * @param serverName\r\n\t *            The name of the server to invalidate\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the server could not be marked as Invalid for the specified template\r\n\t */\r\n\tpublic synchronized void invalidateServer(final String templateName, final CustomNode serverName)\r\n\t\t\tthrows CloudProvisioningException {\r\n\t\t// attempting to remove the invalid node from the active lists so it will not be used anymore, just to\r\n\t\t// be sure.\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tif (templateLists == null || templateLists.size() == 0) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to invalidate server. \\\"\" + templateName\r\n\t\t\t\t\t+ \"\\\" is not a known template.\");\r\n\t\t}\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\t\tfinal List<CustomNode> invalidNodesPool = templateLists.get(NODES_LIST_INVALID);\r\n\r\n\t\tfreeNodesPool.remove(serverName);\r\n\t\tallocatedNodesPool.remove(serverName);\r\n\t\tif (!invalidNodesPool.contains(serverName)) {\r\n\t\t\tinvalidNodesPool.add(serverName);\r\n\t\t}\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Retrieves the server with the given Id (not a host name).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param id\r\n\t *            The id of the server to retrieve\r\n\t * @return A node matching the given id, if found\r\n\t */\r\n\tpublic CustomNode getServerByID(final String templateName, final String id) {\r\n\t\tCustomNode selectedNode = null;\r\n\r\n\t\tfor (final CustomNode node : getAllNodesByTemplateName(templateName)) {\r\n\t\t\tif (node.getId().equalsIgnoreCase(id)) {\r\n\t\t\t\tselectedNode = node;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn selectedNode;\r\n\t}","id":95528,"modified_method":"/**\r\n\t * Retrieves the server with the given Id (not a host name).\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param id\r\n\t *            The id of the server to retrieve\r\n\t * @return A node matching the given id, if found\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the server could not be obtained with the specified template\r\n\t */\r\n\tpublic CustomNode getServerByID(final String templateName, final String id) throws CloudProvisioningException {\r\n\t\tCustomNode selectedNode = null;\r\n\r\n\t\tfor (final CustomNode node : getAllNodesByTemplateName(templateName)) {\r\n\t\t\tif (node.getId().equalsIgnoreCase(id)) {\r\n\t\t\t\tselectedNode = node;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn selectedNode;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private List<CustomNode> parseCloudNodes(final List<Map<String, String>> nodesMapList) throws Exception {\r\n\r\n\t\tfinal List<CustomNode> cloudNodes = new ArrayList<CustomNode>();\r\n\r\n\t\tfor (final Map<String, String> nodeMap : nodesMapList) {\r\n\t\t\tif (StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID))\r\n\t\t\t\t\t&& StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP))) {\r\n\t\t\t\tcloudNodes.add(parseOneNode(nodeMap));\r\n\t\t\t} else if (StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID_PREFIX))\r\n\t\t\t\t\t&& StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP_LIST))) {\r\n\t\t\t\tcloudNodes.addAll(parseNodeList(nodeMap));\r\n\t\t\t} else if (StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID_PREFIX))\r\n\t\t\t\t\t&& StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP_CIDR))) {\r\n\t\t\t\tcloudNodes.addAll(parseNodeCIDR(nodeMap));\r\n\t\t\t} else if (StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID_PREFIX))\r\n\t\t\t\t\t&& StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP_RANGE))) {\r\n\t\t\t\tcloudNodes.addAll(parseNodeRange(nodeMap));\r\n\t\t\t} else {\r\n\t\t\t\tthrow new InstallerException(\"Failed to start cloud node, invalid IP/ID configuration.\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cloudNodes;\r\n\t}","id":95529,"modified_method":"private List<CustomNode> parseCloudNodes(final List<Map<String, String>> nodesMapList)\r\n\t\t\tthrows CloudProvisioningException {\r\n\r\n\t\tfinal List<CustomNode> cloudNodes = new ArrayList<CustomNode>();\r\n\r\n\t\tfor (final Map<String, String> nodeMap : nodesMapList) {\r\n\t\t\tif (StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID))\r\n\t\t\t\t\t&& StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP))) {\r\n\t\t\t\tcloudNodes.add(parseOneNode(nodeMap));\r\n\t\t\t} else if ((StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID)) || StringUtils.isNotBlank(nodeMap\r\n\t\t\t\t\t.get(CLOUD_NODE_ID_PREFIX))) && StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP_LIST))) {\r\n\t\t\t\tcloudNodes.addAll(parseNodeList(nodeMap));\r\n\t\t\t} else if ((StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID)) || StringUtils.isNotBlank(nodeMap\r\n\t\t\t\t\t.get(CLOUD_NODE_ID_PREFIX))) && StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP_CIDR))) {\r\n\t\t\t\tcloudNodes.addAll(parseNodeCIDR(nodeMap));\r\n\t\t\t} else if ((StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_ID)) || StringUtils.isNotBlank(nodeMap\r\n\t\t\t\t\t.get(CLOUD_NODE_ID_PREFIX))) && StringUtils.isNotBlank(nodeMap.get(CLOUD_NODE_IP_RANGE))) {\r\n\t\t\t\tcloudNodes.addAll(parseNodeRange(nodeMap));\r\n\t\t\t} else {\r\n\t\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud node, invalid IP/ID configuration.\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cloudNodes;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Sets the nodes holding certain IPs as allocated, so they would not be re-allocated to other clients.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template the IPs belongs to\r\n\t * @param ipAddresses\r\n\t *            A set of IP addresses (decimal dotted format)\r\n\t */\r\n\tpublic synchronized void setAllocated(final String templateName, final Set<String> ipAddresses) {\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\r\n\t\tfor (final String ipAddress : ipAddresses) {\r\n\t\t\tfor (final CustomNode node : freeNodesPool) {\r\n\t\t\t\tif (StringUtils.isNotBlank(node.getPrivateIP()) && node.getPrivateIP().equalsIgnoreCase(ipAddress)\r\n\t\t\t\t\t\t|| StringUtils.isNotBlank(node.getPublicIP())\r\n\t\t\t\t\t\t&& node.getPublicIP().equalsIgnoreCase(ipAddress)) {\r\n\t\t\t\t\tfreeNodesPool.remove(node);\r\n\t\t\t\t\tif (!allocatedNodesPool.contains(node)) {\r\n\t\t\t\t\t\tallocatedNodesPool.add(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":95530,"modified_method":"/**\r\n\t * Sets the servers with the specified IPs as allocated, so they would not be re-allocated on future\r\n\t * calls.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template the IPs belongs to\r\n\t * @param ipAddresses\r\n\t *            A set of IP addresses (decimal dotted format)\r\n\t * \r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the IPs could not be marked as allocated with the specified template\r\n\t */\r\n\tpublic synchronized void setAllocated(final String templateName, final Set<String> ipAddresses)\r\n\t\t\tthrows CloudProvisioningException {\r\n\t\tfinal Map<String, List<CustomNode>> templateLists = nodesListsByTemplates.get(templateName);\r\n\t\tif (templateLists == null || templateLists.size() == 0) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to set allocated servers. \\\"\" + templateName\r\n\t\t\t\t\t+ \"\\\" is not a known template.\");\r\n\t\t}\r\n\t\tfinal List<CustomNode> freeNodesPool = templateLists.get(NODES_LIST_FREE);\r\n\t\tfinal List<CustomNode> allocatedNodesPool = templateLists.get(NODES_LIST_ALLOCATED);\r\n\r\n\t\tfor (final String ipAddress : ipAddresses) {\r\n\t\t\tfor (final CustomNode node : freeNodesPool) {\r\n\t\t\t\tif (StringUtils.isNotBlank(node.getPrivateIP()) && node.getPrivateIP().equalsIgnoreCase(ipAddress)\r\n\t\t\t\t\t\t|| StringUtils.isNotBlank(node.getPublicIP())\r\n\t\t\t\t\t\t&& node.getPublicIP().equalsIgnoreCase(ipAddress)) {\r\n\t\t\t\t\tfreeNodesPool.remove(node);\r\n\t\t\t\t\tif (!allocatedNodesPool.contains(node)) {\r\n\t\t\t\t\t\tallocatedNodesPool.add(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private List<CustomNode> parseNodeCIDR(final Map<String, String> nodeMap) throws InstallerException {\r\n\t\tfinal String ipCIDR = nodeMap.get(CLOUD_NODE_IP_CIDR);\r\n\t\ttry {\r\n\t\t\tnodeMap.put(CLOUD_NODE_IP_RANGE, IPUtils.ipCIDR2Range(ipCIDR));\r\n\t\t} catch (final Exception e) {\r\n\t\t\tthrow new InstallerException(\"Failed to start cloud machine.\", e);\r\n\t\t}\r\n\r\n\t\treturn parseNodeRange(nodeMap);\r\n\t}","id":95531,"modified_method":"private List<CustomNode> parseNodeCIDR(final Map<String, String> nodeMap) throws CloudProvisioningException {\r\n\t\tfinal String ipCIDR = nodeMap.get(CLOUD_NODE_IP_CIDR);\r\n\t\ttry {\r\n\t\t\tnodeMap.put(CLOUD_NODE_IP_RANGE, IPUtils.ipCIDR2Range(ipCIDR));\r\n\t\t} catch (final Exception e) {\r\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine.\", e);\r\n\t\t}\r\n\r\n\t\treturn parseNodeRange(nodeMap);\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private List<CustomNode> parseNodeList(final Map<String, String> nodeMap) throws InstallerException {\r\n\t\tfinal List<CustomNode> cloudNodes = new ArrayList<CustomNode>();\r\n\t\tfinal String idPrefix = nodeMap.get(CLOUD_NODE_ID_PREFIX);\r\n\t\tfinal String ipList = nodeMap.get(CLOUD_NODE_IP_LIST);\r\n\t\tfinal String[] ipsArr = ipList.split(\",\");\r\n\t\tint index = 1;\r\n\t\tfor (String ip : ipsArr) {\r\n\t\t\tip = ip.trim();\r\n\t\t\tif (!IPUtils.validateIPAddress(ip)) {\r\n\t\t\t\tthrow new InstallerException(\"Invalid IP address: \" + ip);\r\n\t\t\t}\r\n\t\t\tcloudNodes.add(new CustomNodeImpl(PROVIDER_ID, idPrefix + index, ip, nodeMap.get(CLOUD_NODE_USERNAME),\r\n\t\t\t\t\tnodeMap.get(CLOUD_NODE_CREDENTIAL), idPrefix + index));\r\n\t\t\tindex++;\r\n\t\t}\r\n\r\n\t\treturn cloudNodes;\r\n\t}","id":95532,"modified_method":"private List<CustomNode> parseNodeList(final Map<String, String> nodeMap) throws CloudProvisioningException {\r\n\t\tfinal List<CustomNode> cloudNodes = new ArrayList<CustomNode>();\r\n\t\tfinal String id = nodeMap.get(CLOUD_NODE_ID);\r\n\t\tfinal String idPrefix = nodeMap.get(CLOUD_NODE_ID_PREFIX);\r\n\t\tfinal String ipList = nodeMap.get(CLOUD_NODE_IP_LIST);\r\n\r\n\t\tfinal String[] ipsArr = ipList.split(\",\");\r\n\t\tint index = 1;\r\n\t\tString currnentId;\r\n\t\tfor (String ip : ipsArr) {\r\n\t\t\tip = ip.trim();\r\n\t\t\tif (!IPUtils.validateIPAddress(ip)) {\r\n\t\t\t\tthrow new CloudProvisioningException(\"Invalid IP address: \" + ip);\r\n\t\t\t}\r\n\t\t\tif (StringUtils.isNotBlank(id)) {\r\n\t\t\t\tcurrnentId = MessageFormat.format(id, index);\r\n\t\t\t} else {\r\n\t\t\t\tcurrnentId = idPrefix + index;\r\n\t\t\t}\r\n\t\t\tcloudNodes.add(new CustomNodeImpl(PROVIDER_ID, currnentId, ip, nodeMap.get(CLOUD_NODE_USERNAME), nodeMap\r\n\t\t\t\t\t.get(CLOUD_NODE_CREDENTIAL), currnentId));\r\n\t\t\tindex++;\r\n\t\t}\r\n\r\n\t\treturn cloudNodes;\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Shuts down the server with the given ID.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverId\r\n\t *            The ID of the server to shutdown\r\n\t */\r\n\tpublic void shutdownServerById(final String templateName, final String serverId) {\r\n\t\tshutdownServer(templateName, getServerByID(templateName, serverId));\r\n\t}","id":95533,"modified_method":"/**\r\n\t * Shuts down the server with the given ID.\r\n\t * \r\n\t * @param templateName\r\n\t *            The name of the nodes-list' template this server belongs to\r\n\t * @param serverId\r\n\t *            The ID of the server to shutdown\r\n\t * @throws CloudProvisioningException\r\n\t *             Indicates the server could not be shutdown with the specified template\r\n\t */\r\n\tpublic void shutdownServerById(final String templateName, final String serverId) throws CloudProvisioningException {\r\n\t\tshutdownServer(templateName, getServerByID(templateName, serverId));\r\n\t}","commit_id":"3bd6d40b0dedb4954e64e91976300907ae0da290","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void setupGutterRenderer() {\n    getHighlighter().setGutterIconRenderer(new GutterIconRenderer() {\n      public Icon getIcon() {\n        return BreakpointWithHighlighter.this.getIcon();\n      }\n\n      public String getTooltipText() {\n        return getDescription();\n      }\n\n      public AnAction getClickAction() {\n        return new AnAction() {\n          public void actionPerformed(AnActionEvent e) {\n            DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().removeBreakpoint(BreakpointWithHighlighter.this);\n          }\n        };\n      }\n\n      public AnAction getMiddleButtonClickAction() {\n        return new AnAction() {\n          public void actionPerformed(AnActionEvent e) {\n            boolean value = !ENABLED;\n            ENABLED = value;\n            DebuggerManagerEx.getInstanceEx(getProject()).getBreakpointManager().breakpointChanged(BreakpointWithHighlighter.this);\n            updateUI();\n          }\n        };\n      }\n\n      public ActionGroup getPopupMenuActions() {\n        return createMenuActions();\n      }\n\n      public GutterDraggableObject getDraggableObject() {\n        return new GutterDraggableObject() {\n          public void removeSelf() {\n            //DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().removeBreakpoint(BreakpointWithHighlighter.this);\n          }\n\n          public boolean copy(int line) {\n            return moveTo(SourcePosition.createFromLine(getSourcePosition().getFile(), line));\n          }\n\n          public Cursor getCursor() {\n            return new Cursor (Cursor.MOVE_CURSOR);\n          }\n        };\n      }\n    });\n  }","id":95534,"modified_method":"private void setupGutterRenderer() {\n    getHighlighter().setGutterIconRenderer(new GutterIconRenderer() {\n      public Icon getIcon() {\n        return BreakpointWithHighlighter.this.getIcon();\n      }\n\n      public String getTooltipText() {\n        return getDescription();\n      }\n\n      public AnAction getClickAction() {\n        return new AnAction() {\n          public void actionPerformed(AnActionEvent e) {\n            DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().removeBreakpoint(BreakpointWithHighlighter.this);\n          }\n        };\n      }\n\n      public AnAction getMiddleButtonClickAction() {\n        return new AnAction() {\n          public void actionPerformed(AnActionEvent e) {\n            ENABLED = !ENABLED;\n            DebuggerManagerEx.getInstanceEx(getProject()).getBreakpointManager().breakpointChanged(BreakpointWithHighlighter.this);\n            updateUI();\n          }\n        };\n      }\n\n      public ActionGroup getPopupMenuActions() {\n        return createMenuActions();\n      }\n\n      public GutterDraggableObject getDraggableObject() {\n        return new GutterDraggableObject() {\n          public void removeSelf() {\n            //DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().removeBreakpoint(BreakpointWithHighlighter.this);\n          }\n\n          public boolean copy(int line) {\n            return moveTo(SourcePosition.createFromLine(getSourcePosition().getFile(), line));\n          }\n\n          public Cursor getCursor() {\n            return new Cursor (Cursor.MOVE_CURSOR);\n          }\n        };\n      }\n    });\n  }","commit_id":"a819e8aea696e5dcfbe7bd6445a13fee96cc89ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isValid() {\n    return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){\n      public Boolean compute() {\n        return new Boolean(getSourcePosition() != null && getSourcePosition().getFile().isValid());\n      }\n    }).booleanValue();\n  }","id":95535,"modified_method":"public boolean isValid() {\n    return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){\n      public Boolean compute() {\n        return getSourcePosition() != null && getSourcePosition().getFile().isValid()? Boolean.TRUE : Boolean.FALSE;\n      }\n    }).booleanValue();\n  }","commit_id":"a819e8aea696e5dcfbe7bd6445a13fee96cc89ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean moveTo(SourcePosition position) {\n    RangeHighlighter oldHighlighter = myHighlighter;\n\n    Document document = getDocument();\n    myHighlighter = createHighlighter(myProject, document, position.getLine());\n\n    reload();\n    if(!isValid()) {\n      document.getMarkupModel(myProject).removeHighlighter(myHighlighter);\n      myHighlighter = oldHighlighter;\n      reload();\n      return false;\n    }\n\n    document.getMarkupModel(myProject).removeHighlighter(oldHighlighter);\n\n    DebuggerManagerEx.getInstanceEx(getProject()).getBreakpointManager().breakpointChanged(this);\n    updateUI();\n\n    return true;\n  }","id":95536,"modified_method":"protected boolean moveTo(SourcePosition position) {\n\n    Document document = getDocument();\n    final RangeHighlighter newHighlighter = createHighlighter(myProject, document, position.getLine());\n    if (newHighlighter == null) {\n      return false;\n    }\n    final RangeHighlighter oldHighlighter = myHighlighter;\n    myHighlighter = newHighlighter;\n\n    reload();\n    if(!isValid()) {\n      document.getMarkupModel(myProject).removeHighlighter(myHighlighter);\n      myHighlighter = oldHighlighter;\n      reload();\n      return false;\n    }\n\n    document.getMarkupModel(myProject).removeHighlighter(oldHighlighter);\n\n    DebuggerManagerEx.getInstanceEx(getProject()).getBreakpointManager().breakpointChanged(this);\n    updateUI();\n\n    return true;\n  }","commit_id":"a819e8aea696e5dcfbe7bd6445a13fee96cc89ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canAddLineBreakpoint(Project project, final Document document, final int lineIndex) {\n    final boolean[] canAdd = new boolean[]{false};\n\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n\n    DebuggerUtilsEx.iterateLine(project, document, lineIndex, new DebuggerUtilsEx.ElementVisitor() {\n      public boolean acceptElement(PsiElement element) {\n        if ((element instanceof PsiWhiteSpace) || (PsiTreeUtil.getParentOfType(element, PsiComment.class, false) != null)) {\n          return false;\n        }\n        PsiElement child = element;\n        while(element != null) {\n\n          if (document.getLineNumber(element.getTextOffset()) != lineIndex) {\n            break;\n          }\n          child = element;\n          element = element.getParent();\n        }\n\n        if(child instanceof PsiMethod && child.getTextRange().getEndOffset() >= document.getLineEndOffset(lineIndex)) {\n          PsiCodeBlock body = ((PsiMethod)child).getBody();\n          if(body == null) {\n            canAdd[0] = false;\n          }\n          else {\n            PsiStatement[] statements = body.getStatements();\n            canAdd[0] = statements.length > 0 && document.getLineNumber(statements[0].getTextOffset()) == lineIndex;\n          }\n        }\n        else {\n          canAdd[0] = true;\n        }\n        return true;\n      }\n    });\n\n    return canAdd[0];\n  }","id":95537,"modified_method":"public static boolean canAddLineBreakpoint(Project project, final Document document, final int lineIndex) {\n    if (lineIndex < 0 || lineIndex >= document.getLineCount()) {\n      return false;\n    }\n    final BreakpointWithHighlighter breakpointAtLine = DebuggerManagerEx.getInstanceEx(project).getBreakpointManager().findBreakpoint(\n      document,\n      document.getLineStartOffset(lineIndex)\n    );\n    if (breakpointAtLine != null && CATEGORY.equals(breakpointAtLine.getCategory())) {\n      // there already exists a line breakpoint at this line\n      return false;\n    }\n    final boolean[] canAdd = new boolean[]{false};\n\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n\n    DebuggerUtilsEx.iterateLine(project, document, lineIndex, new DebuggerUtilsEx.ElementVisitor() {\n      public boolean acceptElement(PsiElement element) {\n        if ((element instanceof PsiWhiteSpace) || (PsiTreeUtil.getParentOfType(element, PsiComment.class, false) != null)) {\n          return false;\n        }\n        PsiElement child = element;\n        while(element != null) {\n\n          if (document.getLineNumber(element.getTextOffset()) != lineIndex) {\n            break;\n          }\n          child = element;\n          element = element.getParent();\n        }\n\n        if(child instanceof PsiMethod && child.getTextRange().getEndOffset() >= document.getLineEndOffset(lineIndex)) {\n          PsiCodeBlock body = ((PsiMethod)child).getBody();\n          if(body == null) {\n            canAdd[0] = false;\n          }\n          else {\n            PsiStatement[] statements = body.getStatements();\n            canAdd[0] = statements.length > 0 && document.getLineNumber(statements[0].getTextOffset()) == lineIndex;\n          }\n        }\n        else {\n          canAdd[0] = true;\n        }\n        return true;\n      }\n    });\n\n    return canAdd[0];\n  }","commit_id":"a819e8aea696e5dcfbe7bd6445a13fee96cc89ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static LineBreakpoint create(Project project, Document document, int lineIndex) {\n    VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(document);\n    if (virtualFile == null) return null;\n\n    LineBreakpoint breakpoint = new LineBreakpoint(project, createHighlighter(project, document, lineIndex));\n    return (LineBreakpoint)breakpoint.init();\n  }","id":95538,"modified_method":"protected static LineBreakpoint create(Project project, Document document, int lineIndex) {\n    VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(document);\n    if (virtualFile == null) {\n      return null;\n    }\n\n    final RangeHighlighter highlighter = createHighlighter(project, document, lineIndex);\n    if (highlighter == null) {\n      return null;\n    }\n\n    LineBreakpoint breakpoint = new LineBreakpoint(project, highlighter);\n    return (LineBreakpoint)breakpoint.init();\n  }","commit_id":"f5c201d2e142c77b4131a041b5217d74c493bec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected static RunToCursorBreakpoint create(Project project, Document document, int lineIndex, boolean restoreBreakpoints) {\n    VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(document);\n    if (virtualFile == null) {\n      return null;\n    }\n\n    RunToCursorBreakpoint breakpoint = new RunToCursorBreakpoint(project, createHighlighter(project, document, lineIndex), restoreBreakpoints);\n    breakpoint.getHighlighter().dispose();\n\n    return (RunToCursorBreakpoint)breakpoint.init();\n  }","id":95539,"modified_method":"@Nullable\n  protected static RunToCursorBreakpoint create(Project project, Document document, int lineIndex, boolean restoreBreakpoints) {\n    VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(document);\n    if (virtualFile == null) {\n      return null;\n    }\n\n    final RangeHighlighter highlighter = createHighlighter(project, document, lineIndex);\n    if (highlighter == null) {\n      return null;\n    }\n\n    final RunToCursorBreakpoint breakpoint = new RunToCursorBreakpoint(project, highlighter, restoreBreakpoints);\n    breakpoint.getHighlighter().dispose();\n\n    return (RunToCursorBreakpoint)breakpoint.init();\n  }","commit_id":"f5c201d2e142c77b4131a041b5217d74c493bec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void notifyRemoteException(Address remoteAddress, Throwable throwable) {\n        // Cancel all partition states\n        jobProcessInformation.cancelPartitionState();\n\n        // Notify all other nodes about cancellation\n        Set<Address> addresses = new HashSet<Address>();\n        for (Set<Address> remoteReducers : this.remoteReducers.values()) {\n            addAllFilterJobOwner(addresses, remoteReducers);\n        }\n        for (JobPartitionState partitionState : jobProcessInformation.getPartitionStates()) {\n            if (partitionState != null && partitionState.getOwner() != null) {\n                if (!partitionState.getOwner().equals(jobOwner)) {\n                    addresses.add(partitionState.getOwner());\n                }\n            }\n        }\n\n        // Now notify all involved members to cancel the job\n        String name = getConfiguration().getName();\n        String jobId = getConfiguration().getJobId();\n        for (Address address : addresses) {\n            try {\n                CancelJobSupervisorOperation operation = new CancelJobSupervisorOperation(name, jobId);\n                mapReduceService.processRequest(address, operation, name);\n            } catch (Exception ignore) {\n                // We can ignore this exception since we just want to cancel the job\n                // and the member may be crashed or unreachable in some way\n            }\n        }\n\n        TrackableJobFuture future = jobTracker.unregisterTrackableJob(jobId);\n        jobTracker.unregisterMapCombineTask(jobId);\n        jobTracker.unregisterReducerTask(jobId);\n        mapReduceService.destroyJobSupervisor(this);\n\n        if (future != null) {\n            // Might be already cancelled by another members exception\n            ExceptionUtil.fixRemoteStackTrace(throwable,\n                    Thread.currentThread().getStackTrace(), \"Operation failed on node: \" + remoteAddress);\n            future.setResult(throwable);\n        }\n    }","id":95540,"modified_method":"public void notifyRemoteException(Address remoteAddress, Throwable throwable) {\n        // Cancel all partition states\n        jobProcessInformation.cancelPartitionState();\n\n        // Notify all other nodes about cancellation\n        Set<Address> addresses = new HashSet<Address>();\n        for (Set<Address> remoteReducers : this.remoteReducers.values()) {\n            addAllFilterJobOwner(addresses, remoteReducers);\n        }\n        for (JobPartitionState partitionState : jobProcessInformation.getPartitionStates()) {\n            if (partitionState != null && partitionState.getOwner() != null) {\n                if (!partitionState.getOwner().equals(jobOwner)) {\n                    addresses.add(partitionState.getOwner());\n                }\n            }\n        }\n\n        // Now notify all involved members to cancel the job\n        String name = getConfiguration().getName();\n        String jobId = getConfiguration().getJobId();\n        for (Address address : addresses) {\n            try {\n                CancelJobSupervisorOperation operation = new CancelJobSupervisorOperation(name, jobId);\n                mapReduceService.processRequest(address, operation, name);\n            } catch (Exception ignore) {\n                // We can ignore this exception since we just want to cancel the job\n                // and the member may be crashed or unreachable in some way\n            }\n        }\n\n        TrackableJobFuture future = jobTracker.unregisterTrackableJob(jobId);\n        MapCombineTask mapCombineTask = jobTracker.unregisterMapCombineTask(jobId);\n        if (mapCombineTask != null) {\n            mapCombineTask.cancel();\n        }\n        ReducerTask reducerTask = jobTracker.unregisterReducerTask(jobId);\n        if (reducerTask != null) {\n            reducerTask.cancel();\n        }\n        mapReduceService.destroyJobSupervisor(this);\n\n        if (future != null) {\n            // Might be already cancelled by another members exception\n            ExceptionUtil.fixRemoteStackTrace(throwable,\n                    Thread.currentThread().getStackTrace(), \"Operation failed on node: \" + remoteAddress);\n            future.setResult(throwable);\n        }\n    }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean cancelAndNotify() {\n        // Cancel all partition states\n        jobProcessInformation.cancelPartitionState();\n\n        // Notify all other nodes about cancellation\n        Set<Address> addresses = new HashSet<Address>();\n        for (Set<Address> remoteReducers : this.remoteReducers.values()) {\n            addAllFilterJobOwner(addresses, remoteReducers);\n        }\n        for (JobPartitionState partitionState : jobProcessInformation.getPartitionStates()) {\n            if (partitionState != null && partitionState.getOwner() != null) {\n                if (!partitionState.getOwner().equals(jobOwner)) {\n                    addresses.add(partitionState.getOwner());\n                }\n            }\n        }\n\n        // Now notify all involved members to cancel the job\n        String name = getConfiguration().getName();\n        String jobId = getConfiguration().getJobId();\n        for (Address address : addresses) {\n            try {\n                CancelJobSupervisorOperation operation = new CancelJobSupervisorOperation(name, jobId);\n                mapReduceService.processRequest(address, operation, name);\n            } catch (Exception ignore) {\n                // We can ignore this exception since we just want to cancel the job\n                // and the member may be crashed or unreachable in some way\n            }\n        }\n\n        TrackableJobFuture future = jobTracker.unregisterTrackableJob(jobId);\n        jobTracker.unregisterMapCombineTask(jobId);\n        jobTracker.unregisterReducerTask(jobId);\n        mapReduceService.destroyJobSupervisor(this);\n\n        if (future != null) {\n            // Might be already cancelled by another members exception\n            future.setResult(new CancellationException(\"Operation was cancelled by the user\"));\n        }\n\n        return true;\n    }","id":95541,"modified_method":"public boolean cancelAndNotify() {\n        // Cancel all partition states\n        jobProcessInformation.cancelPartitionState();\n\n        // Notify all other nodes about cancellation\n        Set<Address> addresses = new HashSet<Address>();\n        for (Set<Address> remoteReducers : this.remoteReducers.values()) {\n            addAllFilterJobOwner(addresses, remoteReducers);\n        }\n        for (JobPartitionState partitionState : jobProcessInformation.getPartitionStates()) {\n            if (partitionState != null && partitionState.getOwner() != null) {\n                if (!partitionState.getOwner().equals(jobOwner)) {\n                    addresses.add(partitionState.getOwner());\n                }\n            }\n        }\n\n        // Now notify all involved members to cancel the job\n        String name = getConfiguration().getName();\n        String jobId = getConfiguration().getJobId();\n        for (Address address : addresses) {\n            try {\n                CancelJobSupervisorOperation operation = new CancelJobSupervisorOperation(name, jobId);\n                mapReduceService.processRequest(address, operation, name);\n            } catch (Exception ignore) {\n                // We can ignore this exception since we just want to cancel the job\n                // and the member may be crashed or unreachable in some way\n            }\n        }\n\n        TrackableJobFuture future = jobTracker.unregisterTrackableJob(jobId);\n        MapCombineTask mapCombineTask = jobTracker.unregisterMapCombineTask(jobId);\n        if (mapCombineTask != null) {\n            mapCombineTask.cancel();\n        }\n        ReducerTask reducerTask = jobTracker.unregisterReducerTask(jobId);\n        if (reducerTask != null) {\n            reducerTask.cancel();\n        }\n        mapReduceService.destroyJobSupervisor(this);\n\n        if (future != null) {\n            // Might be already cancelled by another members exception\n            future.setResult(new CancellationException(\"Operation was cancelled by the user\"));\n        }\n\n        return true;\n    }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void cancel() {\n        String jobId = getConfiguration().getJobId();\n        jobTracker.unregisterTrackableJob(jobId);\n        jobTracker.unregisterMapCombineTask(jobId);\n        jobTracker.unregisterReducerTask(jobId);\n        mapReduceService.destroyJobSupervisor(this);\n    }","id":95542,"modified_method":"public void cancel() {\n        String jobId = getConfiguration().getJobId();\n        jobTracker.unregisterTrackableJob(jobId);\n        MapCombineTask mapCombineTask = jobTracker.unregisterMapCombineTask(jobId);\n        if (mapCombineTask != null) {\n            mapCombineTask.cancel();\n        }\n        ReducerTask reducerTask = jobTracker.unregisterReducerTask(jobId);\n        if (reducerTask != null) {\n            reducerTask.cancel();\n        }\n        mapReduceService.destroyJobSupervisor(this);\n    }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void executeMappingPhase(KeyValueSource<KeyIn, ValueIn> keyValueSource,\n                                    Mapper<KeyIn, ValueIn, KeyOut, ValueOut> mapper,\n                                    Context<KeyOut, ValueOut> context) {\n\n        while (keyValueSource.hasNext()) {\n            if (matches(keyValueSource.key())) {\n                Map.Entry<KeyIn, ValueIn> entry = keyValueSource.element();\n                mapper.map(entry.getKey(), entry.getValue(), context);\n            }\n        }\n    }","id":95543,"modified_method":"@Override\n    public void executeMappingPhase(KeyValueSource<KeyIn, ValueIn> keyValueSource,\n                                    Mapper<KeyIn, ValueIn, KeyOut, ValueOut> mapper,\n                                    Context<KeyOut, ValueOut> context) {\n\n        while (keyValueSource.hasNext()) {\n            if (matches(keyValueSource.key())) {\n                Map.Entry<KeyIn, ValueIn> entry = keyValueSource.element();\n                mapper.map(entry.getKey(), entry.getValue(), context);\n            }\n            if (isCancelled()) {\n                return;\n            }\n        }\n    }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public void run() {\n            KeyValueSource<KeyIn, ValueIn> delegate = keyValueSource;\n            if (supervisor.getConfiguration().isCommunicateStats()) {\n                delegate = new KeyValueSourceFacade<KeyIn, ValueIn>(keyValueSource, supervisor);\n            }\n\n            for (; ; ) {\n                Integer partitionId = findNewPartitionProcessing();\n                if (partitionId == null) {\n                    // Job's done\n                    return;\n                }\n\n                // Migration event occurred, just retry\n                if (partitionId == -1) {\n                    continue;\n                }\n\n                try {\n                    // This call cannot be delegated\n                    ((PartitionIdAware) keyValueSource).setPartitionId(partitionId);\n                    delegate.reset();\n                    delegate.open(nodeEngine);\n                    processMapping(partitionId, delegate);\n                    delegate.close();\n                } catch (Throwable t) {\n                    notifyRemoteException(supervisor, t);\n                }\n            }\n        }","id":95544,"modified_method":"@Override\n        public void run() {\n            KeyValueSource<KeyIn, ValueIn> delegate = keyValueSource;\n            if (supervisor.getConfiguration().isCommunicateStats()) {\n                delegate = new KeyValueSourceFacade<KeyIn, ValueIn>(keyValueSource, supervisor);\n            }\n\n            for (; ; ) {\n                if (cancelled.get()) {\n                    return;\n                }\n\n                Integer partitionId = findNewPartitionProcessing();\n                if (partitionId == null) {\n                    // Job's done\n                    return;\n                }\n\n                // Migration event occurred, just retry\n                if (partitionId == -1) {\n                    continue;\n                }\n\n                try {\n                    // This call cannot be delegated\n                    ((PartitionIdAware) keyValueSource).setPartitionId(partitionId);\n                    delegate.reset();\n                    delegate.open(nodeEngine);\n                    processMapping(partitionId, delegate);\n                    delegate.close();\n                } catch (Throwable t) {\n                    notifyRemoteException(supervisor, t);\n                }\n            }\n        }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final void processMapping(int partitionId, KeyValueSource<KeyIn, ValueIn> keyValueSource)\n            throws Exception {\n\n        DefaultContext<KeyOut, ValueOut> context = supervisor.createContext(this);\n        context.setPartitionId(partitionId);\n\n        if (mapper instanceof LifecycleMapper) {\n            ((LifecycleMapper) mapper).initialize(context);\n        }\n        mappingPhase.executeMappingPhase(keyValueSource, mapper, context);\n        if (mapper instanceof LifecycleMapper) {\n            ((LifecycleMapper) mapper).finalized(context);\n        }\n\n        RequestPartitionResult result = mapReduceService.processRequest(supervisor.getJobOwner(),\n                new RequestPartitionReducing(name, jobId, partitionId), name);\n\n        if (result.getResultState() == SUCCESSFUL) {\n            // If we have a reducer defined just send it over\n            if (supervisor.getConfiguration().getReducerFactory() != null) {\n                Map<KeyOut, Chunk> chunkMap = context.finish();\n                if (chunkMap.size() > 0) {\n                    Address sender = mapReduceService.getLocalAddress();\n\n                    // Wrap into LastChunkNotification object\n                    Map<Address, Map<KeyOut, Chunk>> mapping = mapResultToMember(supervisor, chunkMap);\n\n                    // Register remote addresses and partitionId for receiving reducer events\n                    supervisor.registerReducerEventInterests(partitionId, mapping.keySet());\n\n                    // Send LastChunk notifications\n                    for (Map.Entry<Address, Map<KeyOut, Chunk>> entry : mapping.entrySet()) {\n                        Address receiver = entry.getKey();\n                        Map<KeyOut, Chunk> chunk = entry.getValue();\n                        mapReduceService.sendNotification(receiver, new LastChunkNotification(\n                                receiver, name, jobId, sender, partitionId, chunk));\n                    }\n\n                    // Send LastChunk notification to notify reducers that received at least one chunk\n                    Set<Address> addresses = mapping.keySet();\n                    Collection<Address> reducerInterests = supervisor.getReducerEventInterests(partitionId);\n                    if (reducerInterests != null) {\n                        for (Address address : reducerInterests) {\n                            if (!addresses.contains(address)) {\n                                mapReduceService.sendNotification(address, new LastChunkNotification(\n                                        address, name, jobId, sender, partitionId, Collections.emptyMap()));\n                            }\n                        }\n                    }\n\n                } else {\n                    // If nothing to reduce we just set partition to processed\n                    result = mapReduceService.processRequest(supervisor.getJobOwner(),\n                            new RequestPartitionProcessed(name, jobId, partitionId, REDUCING), name);\n\n                    if (result.getResultState() != SUCCESSFUL) {\n                        throw new RuntimeException(\"Could not finalize processing for partitionId \" + partitionId);\n                    }\n                }\n            }\n        }\n    }","id":95545,"modified_method":"public final void processMapping(int partitionId, KeyValueSource<KeyIn, ValueIn> keyValueSource)\n            throws Exception {\n\n        DefaultContext<KeyOut, ValueOut> context = supervisor.createContext(this);\n        context.setPartitionId(partitionId);\n\n        if (mapper instanceof LifecycleMapper) {\n            ((LifecycleMapper) mapper).initialize(context);\n        }\n        mappingPhase.executeMappingPhase(keyValueSource, mapper, context);\n        if (mapper instanceof LifecycleMapper) {\n            ((LifecycleMapper) mapper).finalized(context);\n        }\n\n        if (cancelled.get()) {\n            return;\n        }\n\n        RequestPartitionResult result = mapReduceService.processRequest(supervisor.getJobOwner(),\n                new RequestPartitionReducing(name, jobId, partitionId), name);\n\n        if (result.getResultState() == SUCCESSFUL) {\n            // If we have a reducer defined just send it over\n            if (supervisor.getConfiguration().getReducerFactory() != null) {\n                Map<KeyOut, Chunk> chunkMap = context.finish();\n                if (chunkMap.size() > 0) {\n                    Address sender = mapReduceService.getLocalAddress();\n\n                    // Wrap into LastChunkNotification object\n                    Map<Address, Map<KeyOut, Chunk>> mapping = mapResultToMember(supervisor, chunkMap);\n\n                    // Register remote addresses and partitionId for receiving reducer events\n                    supervisor.registerReducerEventInterests(partitionId, mapping.keySet());\n\n                    // Send LastChunk notifications\n                    for (Map.Entry<Address, Map<KeyOut, Chunk>> entry : mapping.entrySet()) {\n                        Address receiver = entry.getKey();\n                        Map<KeyOut, Chunk> chunk = entry.getValue();\n                        mapReduceService.sendNotification(receiver, new LastChunkNotification(\n                                receiver, name, jobId, sender, partitionId, chunk));\n                    }\n\n                    // Send LastChunk notification to notify reducers that received at least one chunk\n                    Set<Address> addresses = mapping.keySet();\n                    Collection<Address> reducerInterests = supervisor.getReducerEventInterests(partitionId);\n                    if (reducerInterests != null) {\n                        for (Address address : reducerInterests) {\n                            if (!addresses.contains(address)) {\n                                mapReduceService.sendNotification(address, new LastChunkNotification(\n                                        address, name, jobId, sender, partitionId, Collections.emptyMap()));\n                            }\n                        }\n                    }\n\n                } else {\n                    // If nothing to reduce we just set partition to processed\n                    result = mapReduceService.processRequest(supervisor.getJobOwner(),\n                            new RequestPartitionProcessed(name, jobId, partitionId, REDUCING), name);\n\n                    if (result.getResultState() != SUCCESSFUL) {\n                        throw new RuntimeException(\"Could not finalize processing for partitionId \" + partitionId);\n                    }\n                }\n            }\n        }\n    }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void run() {\n        try {\n            ReducerChunk<Key, Chunk> reducerChunk;\n            while ((reducerChunk = reducerQueue.poll()) != null) {\n                reduceChunk(reducerChunk.chunk);\n                processProcessedState(reducerChunk);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            active.compareAndSet(true, false);\n        }\n    }","id":95546,"modified_method":"@Override\n    public void run() {\n        try {\n            ReducerChunk<Key, Chunk> reducerChunk;\n            while ((reducerChunk = reducerQueue.poll()) != null) {\n                if (cancelled.get()) {\n                    return;\n                }\n\n                reduceChunk(reducerChunk.chunk);\n                processProcessedState(reducerChunk);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            active.compareAndSet(true, false);\n        }\n    }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void processChunk(int partitionId, Address sender, Map<Key, Chunk> chunk) {\n        reducerQueue.offer(new ReducerChunk<Key, Chunk>(chunk, partitionId, sender));\n        if (active.compareAndSet(false, true)) {\n            MapReduceService mapReduceService = supervisor.getMapReduceService();\n            ExecutorService es = mapReduceService.getExecutorService(name);\n            es.submit(this);\n        }\n    }","id":95547,"modified_method":"public void processChunk(int partitionId, Address sender, Map<Key, Chunk> chunk) {\n        if (cancelled.get()) {\n            return;\n        }\n        reducerQueue.offer(new ReducerChunk<Key, Chunk>(chunk, partitionId, sender));\n        if (active.compareAndSet(false, true)) {\n            MapReduceService mapReduceService = supervisor.getMapReduceService();\n            ExecutorService es = mapReduceService.getExecutorService(name);\n            es.submit(this);\n        }\n    }","commit_id":"bfcb69a2a6a4f82bdec21c8811ac72460a0b5611","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public org.apache.catalina.Session createSession(String sessionId, Random random) {\n        String id = (sessionId != null) ? this.getSessionId(sessionId) : this.manager.createSessionId();\n        this.manager.getBatcher().startBatch();\n        return this.getSession(this.manager.createSession(id));\n    }","id":95548,"modified_method":"@Override\n    public org.apache.catalina.Session createSession(String sessionId, Random random) {\n        String id = (sessionId != null) ? this.getSessionId(sessionId) : this.manager.createSessionId();\n        Batcher batcher = this.manager.getBatcher();\n        boolean started = batcher.startBatch();\n        try {\n            return this.getSession(this.manager.createSession(id));\n        } catch (RuntimeException | Error e) {\n            if (started) {\n                batcher.endBatch(false);\n            }\n            throw e;\n        }\n    }","commit_id":"32dae99c6079eb8ebe601d410e2f8d93de3a9460","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public org.apache.catalina.Session findSession(String id) {\n        Batcher batcher = this.manager.getBatcher();\n        boolean started = batcher.startBatch();\n        Session<LocalSessionContext> session = this.manager.findSession(this.getSessionId(id));\n        if (session == null) {\n            if (started) {\n                batcher.endBatch(false);\n            }\n            return null;\n        }\n        return this.getSession(session);\n    }","id":95549,"modified_method":"@Override\n    public org.apache.catalina.Session findSession(String id) {\n        Batcher batcher = this.manager.getBatcher();\n        boolean started = batcher.startBatch();\n        Session<LocalSessionContext> session = null;\n        try {\n            session = this.manager.findSession(this.getSessionId(id));\n            return (session != null) ? this.getSession(session) : null;\n        } finally {\n            if (started && (session == null)) {\n                batcher.endBatch(false);\n            }\n        }\n    }","commit_id":"32dae99c6079eb8ebe601d410e2f8d93de3a9460","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public io.undertow.server.session.Session getSession(HttpServerExchange exchange, SessionConfig config) {\n        String id = this.findSessionId(exchange, config);\n        if (id == null) return null;\n        Batcher batcher = this.manager.getBatcher();\n        boolean started = batcher.startBatch();\n        Session<Void> session = this.manager.findSession(id);\n        if (session == null) {\n            if (started) {\n                batcher.endBatch(false);\n            }\n            return null;\n        }\n        return this.getSession(session, exchange, config);\n    }","id":95550,"modified_method":"@Override\n    public io.undertow.server.session.Session getSession(HttpServerExchange exchange, SessionConfig config) {\n        String id = this.findSessionId(exchange, config);\n        if (id == null) return null;\n\n        Batcher batcher = this.manager.getBatcher();\n        boolean started = batcher.startBatch();\n        Session<Void> session = null;\n        try {\n            session = this.manager.findSession(id);\n            return (session != null) ? this.getSession(session, exchange, config) : null;\n        } finally {\n            if (started && (session == null)) {\n                batcher.endBatch(false);\n            }\n        }\n    }","commit_id":"32dae99c6079eb8ebe601d410e2f8d93de3a9460","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public io.undertow.server.session.Session createSession(HttpServerExchange exchange, SessionConfig config) {\n        if (config == null) {\n            throw UndertowMessages.MESSAGES.couldNotFindSessionCookieConfig();\n        }\n        String id = this.findSessionId(exchange, config);\n        Batcher batcher = this.manager.getBatcher();\n        boolean started = batcher.startBatch();\n\n        if (id != null) {\n            if (this.manager.findSession(id) != null) {\n                if (started) {\n                    batcher.endBatch(false);\n                }\n                throw UndertowMessages.MESSAGES.sessionAlreadyExists(id);\n            }\n        } else {\n            id = this.manager.createSessionId();\n        }\n\n        Session<Void> session = this.manager.createSession(id);\n        io.undertow.server.session.Session facade = this.getSession(session, exchange, config);\n        this.sessionListeners.sessionCreated(facade, exchange);\n        return facade;\n    }","id":95551,"modified_method":"@Override\n    public io.undertow.server.session.Session createSession(HttpServerExchange exchange, SessionConfig config) {\n        if (config == null) {\n            throw UndertowMessages.MESSAGES.couldNotFindSessionCookieConfig();\n        }\n        String id = this.findSessionId(exchange, config);\n\n        if (id != null) {\n            if (this.manager.containsSession(id)) {\n                throw UndertowMessages.MESSAGES.sessionAlreadyExists(id);\n            }\n        } else {\n            id = this.manager.createSessionId();\n        }\n\n        Batcher batcher = this.manager.getBatcher();\n        boolean started = batcher.startBatch();\n        try {\n            Session<Void> session = this.manager.createSession(id);\n            io.undertow.server.session.Session facade = this.getSession(session, exchange, config);\n            this.sessionListeners.sessionCreated(facade, exchange);\n            return facade;\n        } catch (RuntimeException | Error e) {\n            if (started) {\n                batcher.endBatch(false);\n            }\n            throw e;\n        }\n    }","commit_id":"32dae99c6079eb8ebe601d410e2f8d93de3a9460","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void createSessionNoSessionId() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        Batcher batcher = mock(Batcher.class);\n        SessionConfig config = mock(SessionConfig.class);\n        @SuppressWarnings(\"unchecked\")\n        Session<Void> session = mock(Session.class);\n        String sessionId = \"session\";\n        String route = \"route\";\n        String routingSessionId = \"session.route\";\n        \n        when(this.manager.createSessionId()).thenReturn(sessionId);\n        when(this.manager.findSession(sessionId)).thenReturn(null);\n        when(this.manager.createSession(sessionId)).thenReturn(session);\n        when(this.manager.locate(sessionId)).thenReturn(route);\n        when(this.manager.getBatcher()).thenReturn(batcher);\n        when(batcher.startBatch()).thenReturn(true);\n        when(session.getId()).thenReturn(sessionId);\n        \n        io.undertow.server.session.Session sessionFacade = this.facade.createSession(exchange, config);\n        \n        assertNotNull(sessionFacade);\n        \n        verify(this.listener).sessionCreated(sessionFacade, exchange);\n        verify(config).setSessionId(exchange, routingSessionId);\n        \n        String expected = \"expected\";\n        when(session.getId()).thenReturn(expected);\n        \n        String result = sessionFacade.getId();\n        assertSame(expected, result);\n    }","id":95552,"modified_method":"@Test\n    public void createSessionNoSessionId() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        Batcher batcher = mock(Batcher.class);\n        SessionConfig config = mock(SessionConfig.class);\n        @SuppressWarnings(\"unchecked\")\n        Session<Void> session = mock(Session.class);\n        String sessionId = \"session\";\n        String route = \"route\";\n        String routingSessionId = \"session.route\";\n        \n        when(this.manager.createSessionId()).thenReturn(sessionId);\n        when(this.manager.containsSession(sessionId)).thenReturn(false);\n        when(this.manager.createSession(sessionId)).thenReturn(session);\n        when(this.manager.locate(sessionId)).thenReturn(route);\n        when(this.manager.getBatcher()).thenReturn(batcher);\n        when(batcher.startBatch()).thenReturn(true);\n        when(session.getId()).thenReturn(sessionId);\n        \n        io.undertow.server.session.Session sessionFacade = this.facade.createSession(exchange, config);\n        \n        assertNotNull(sessionFacade);\n        \n        verify(this.listener).sessionCreated(sessionFacade, exchange);\n        verify(config).setSessionId(exchange, routingSessionId);\n        \n        String expected = \"expected\";\n        when(session.getId()).thenReturn(expected);\n        \n        String result = sessionFacade.getId();\n        assertSame(expected, result);\n    }","commit_id":"32dae99c6079eb8ebe601d410e2f8d93de3a9460","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void createSessionAlreadyExists() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        Batcher batcher = mock(Batcher.class);\n        SessionConfig config = mock(SessionConfig.class);\n        @SuppressWarnings(\"unchecked\")\n        Session<Void> session = mock(Session.class);\n        String requestedSessionId = \"session.route1\";\n        String sessionId = \"session\";\n        \n        when(this.manager.getBatcher()).thenReturn(batcher);\n        when(batcher.startBatch()).thenReturn(true);\n        when(config.findSessionId(exchange)).thenReturn(requestedSessionId);\n        when(this.manager.findSession(sessionId)).thenReturn(session);\n        \n        IllegalStateException exception = null;\n        try {\n            this.facade.createSession(exchange, config);\n        } catch (IllegalStateException e) {\n            exception = e;\n        }\n        assertNotNull(exception);\n        \n        verify(batcher).endBatch(false);\n    }","id":95553,"modified_method":"@Test\n    public void createSessionAlreadyExists() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        SessionConfig config = mock(SessionConfig.class);\n        String requestedSessionId = \"session.route1\";\n        String sessionId = \"session\";\n        \n        when(config.findSessionId(exchange)).thenReturn(requestedSessionId);\n        when(this.manager.containsSession(sessionId)).thenReturn(true);\n        \n        IllegalStateException exception = null;\n        try {\n            this.facade.createSession(exchange, config);\n        } catch (IllegalStateException e) {\n            exception = e;\n        }\n        assertNotNull(exception);\n    }","commit_id":"32dae99c6079eb8ebe601d410e2f8d93de3a9460","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void createSessionSpecifiedSessionId() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        Batcher batcher = mock(Batcher.class);\n        SessionConfig config = mock(SessionConfig.class);\n        @SuppressWarnings(\"unchecked\")\n        Session<Void> session = mock(Session.class);\n        String requestedSessionId = \"session.route1\";\n        String sessionId = \"session\";\n        String route = \"route\";\n        String routingSessionId = \"session.route\";\n        \n        when(config.findSessionId(exchange)).thenReturn(requestedSessionId);\n        when(this.manager.findSession(sessionId)).thenReturn(null);\n        when(this.manager.createSession(sessionId)).thenReturn(session);\n        when(this.manager.locate(sessionId)).thenReturn(route);\n        when(this.manager.getBatcher()).thenReturn(batcher);\n        when(batcher.startBatch()).thenReturn(true);\n        when(session.getId()).thenReturn(sessionId);\n        \n        io.undertow.server.session.Session sessionFacade = this.facade.createSession(exchange, config);\n        \n        assertNotNull(sessionFacade);\n        \n        verify(this.listener).sessionCreated(sessionFacade, exchange);\n        verify(config).setSessionId(exchange, routingSessionId);\n        \n        String expected = \"expected\";\n        when(session.getId()).thenReturn(expected);\n        \n        String result = sessionFacade.getId();\n        assertSame(expected, result);\n    }","id":95554,"modified_method":"@Test\n    public void createSessionSpecifiedSessionId() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        Batcher batcher = mock(Batcher.class);\n        SessionConfig config = mock(SessionConfig.class);\n        @SuppressWarnings(\"unchecked\")\n        Session<Void> session = mock(Session.class);\n        String requestedSessionId = \"session.route1\";\n        String sessionId = \"session\";\n        String route = \"route\";\n        String routingSessionId = \"session.route\";\n        \n        when(config.findSessionId(exchange)).thenReturn(requestedSessionId);\n        when(this.manager.containsSession(sessionId)).thenReturn(false);\n        when(this.manager.createSession(sessionId)).thenReturn(session);\n        when(this.manager.locate(sessionId)).thenReturn(route);\n        when(this.manager.getBatcher()).thenReturn(batcher);\n        when(batcher.startBatch()).thenReturn(true);\n        when(session.getId()).thenReturn(sessionId);\n        \n        io.undertow.server.session.Session sessionFacade = this.facade.createSession(exchange, config);\n        \n        assertNotNull(sessionFacade);\n        \n        verify(this.listener).sessionCreated(sessionFacade, exchange);\n        verify(config).setSessionId(exchange, routingSessionId);\n        \n        String expected = \"expected\";\n        when(session.getId()).thenReturn(expected);\n        \n        String result = sessionFacade.getId();\n        assertSame(expected, result);\n    }","commit_id":"32dae99c6079eb8ebe601d410e2f8d93de3a9460","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public io.undertow.server.session.Session getSession(HttpServerExchange exchange, SessionConfig config) {\n        String id = this.findSessionId(exchange, config);\n        if (id == null) return null;\n\n        Batch batch = this.manager.getBatcher().startBatch();\n        Session<LocalSessionContext> session = null;\n        try {\n            session = this.manager.findSession(id);\n            return (session != null) ? this.getSession(session, exchange, config, batch) : null;\n        } finally {\n            if (session == null) {\n                batch.discard();\n            }\n        }\n    }","id":95555,"modified_method":"@Override\n    public io.undertow.server.session.Session getSession(HttpServerExchange exchange, SessionConfig config) {\n        String id = this.findSessionId(exchange, config);\n        if (id == null) return null;\n\n        Batch batch = this.manager.getBatcher().startBatch();\n        try {\n            Session<LocalSessionContext> session = this.manager.findSession(id);\n            if (session == null) {\n                batch.close();\n                return null;\n            }\n            return this.getSession(session, exchange, config, batch);\n        } catch (RuntimeException | Error e) {\n            batch.discard();\n            throw e;\n        }\n    }","commit_id":"fb0f918db2d5aeed4f712760df6eea21c6f78569","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void getSessionNotExists() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        Batcher batcher = mock(Batcher.class);\n        Batch batch = mock(Batch.class);\n        SessionConfig config = mock(SessionConfig.class);\n        String requestedSessionId = \"session.route1\";\n        String sessionId = \"session\";\n        \n        when(config.findSessionId(exchange)).thenReturn(requestedSessionId);\n        when(this.manager.findSession(sessionId)).thenReturn(null);\n        when(this.manager.getBatcher()).thenReturn(batcher);\n        when(batcher.startBatch()).thenReturn(batch);\n\n        io.undertow.server.session.Session sessionAdapter = this.adapter.getSession(exchange, config);\n        \n        assertNull(sessionAdapter);\n        \n        verify(batch).discard();\n    }","id":95556,"modified_method":"@Test\n    public void getSessionNotExists() {\n        HttpServerExchange exchange = new HttpServerExchange(null);\n        Batcher batcher = mock(Batcher.class);\n        Batch batch = mock(Batch.class);\n        SessionConfig config = mock(SessionConfig.class);\n        String requestedSessionId = \"session.route1\";\n        String sessionId = \"session\";\n        \n        when(config.findSessionId(exchange)).thenReturn(requestedSessionId);\n        when(this.manager.findSession(sessionId)).thenReturn(null);\n        when(this.manager.getBatcher()).thenReturn(batcher);\n        when(batcher.startBatch()).thenReturn(batch);\n\n        io.undertow.server.session.Session sessionAdapter = this.adapter.getSession(exchange, config);\n        \n        assertNull(sessionAdapter);\n        \n        verify(batch).close();\n    }","commit_id":"fb0f918db2d5aeed4f712760df6eea21c6f78569","url":"https://github.com/wildfly/wildfly"},{"original_method":"@POST\n  @Path(\"/namespaces/system/artifacts\")\n  public void refreshSystemArtifacts(HttpRequest request, HttpResponder responder,\n                                     @PathParam(\"namespace-id\") String namespaceId) {\n    try {\n      artifactRepository.addSystemArtifacts();\n      responder.sendStatus(HttpResponseStatus.OK);\n    } catch (IOException e) {\n      LOG.error(\"Error while refreshing system artifacts.\", e);\n      responder.sendString(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n        \"There was an IO error while refreshing system artifacts, please try again.\");\n    } catch (WriteConflictException e) {\n      LOG.error(\"Error while refreshing system artifacts.\", e);\n      responder.sendString(HttpResponseStatus.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n  }","id":95557,"modified_method":"@POST\n  @Path(\"/namespaces/system/artifacts\")\n  public void refreshSystemArtifacts(HttpRequest request, HttpResponder responder) {\n    try {\n      artifactRepository.addSystemArtifacts();\n      responder.sendStatus(HttpResponseStatus.OK);\n    } catch (IOException e) {\n      LOG.error(\"Error while refreshing system artifacts.\", e);\n      responder.sendString(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n        \"There was an IO error while refreshing system artifacts, please try again.\");\n    } catch (WriteConflictException e) {\n      LOG.error(\"Error while refreshing system artifacts.\", e);\n      responder.sendString(HttpResponseStatus.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n  }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Inspects and builds plugin and application information for the given artifact.\n   *\n   * @param artifactId the id of the artifact to inspect and store\n   * @param artifactFile the artifact to inspect and store\n   * @param parentArtifacts artifacts the given artifact extends.\n   *                        If null, the given artifact does not extend another artifact\n   * @throws IOException if there was an exception reading from the artifact store\n   * @throws ArtifactRangeNotFoundException if none of the parent artifacts could be found\n   * @throws WriteConflictException if there was a write conflict writing to the metatable. Should not happen often,\n   *                                and it should be possible to retry the operation if it occurs.\n   * @throws ArtifactAlreadyExistsException if the artifact already exists and is not a snapshot version\n   * @throws InvalidArtifactException if the artifact is invalid. Can happen if it is not a zip file,\n   *                                  if the application class given is not an Application,\n   *                                  or if it has parents that also have parents.\n   */\n  public ArtifactDetail addArtifact(Id.Artifact artifactId, File artifactFile,\n                                    @Nullable Set<ArtifactRange> parentArtifacts)\n    throws IOException, ArtifactRangeNotFoundException, WriteConflictException,\n    ArtifactAlreadyExistsException, InvalidArtifactException {\n\n    CloseableClassLoader parentClassLoader;\n    parentArtifacts = parentArtifacts == null ? ImmutableSet.<ArtifactRange>of() : parentArtifacts;\n    if (parentArtifacts.isEmpty()) {\n      // if this artifact doesn't extend another, use itself to create the parent classloader\n      parentClassLoader = artifactClassLoaderFactory.createClassLoader(Locations.toLocation(artifactFile));\n    } else {\n      parentClassLoader = createParentClassLoader(artifactId, parentArtifacts);\n    }\n\n    try {\n      ArtifactClasses artifactClasses = artifactInspector.inspectArtifact(artifactId, artifactFile, parentClassLoader);\n      ArtifactMeta meta = new ArtifactMeta(artifactClasses, parentArtifacts);\n      return artifactStore.write(artifactId, meta, Files.newInputStreamSupplier(artifactFile));\n    } finally {\n      parentClassLoader.close();\n    }\n  }","id":95558,"modified_method":"/**\n   * Inspects and builds plugin and application information for the given artifact.\n   *\n   * @param artifactId the id of the artifact to inspect and store\n   * @param artifactFile the artifact to inspect and store\n   * @param parentArtifacts artifacts the given artifact extends.\n   *                        If null, the given artifact does not extend another artifact\n   * @throws IOException if there was an exception reading from the artifact store\n   * @throws ArtifactRangeNotFoundException if none of the parent artifacts could be found\n   * @throws WriteConflictException if there was a write conflict writing to the metatable. Should not happen often,\n   *                                and it should be possible to retry the operation if it occurs.\n   * @throws ArtifactAlreadyExistsException if the artifact already exists and is not a snapshot version\n   * @throws InvalidArtifactException if the artifact is invalid. Can happen if it is not a zip file,\n   *                                  if the application class given is not an Application,\n   *                                  or if it has parents that also have parents.\n   */\n  public ArtifactDetail addArtifact(Id.Artifact artifactId, File artifactFile,\n                                    @Nullable Set<ArtifactRange> parentArtifacts)\n    throws IOException, ArtifactRangeNotFoundException, WriteConflictException,\n    ArtifactAlreadyExistsException, InvalidArtifactException {\n\n    CloseableClassLoader parentClassLoader;\n    parentArtifacts = parentArtifacts == null ? ImmutableSet.<ArtifactRange>of() : parentArtifacts;\n    if (parentArtifacts.isEmpty()) {\n      // if this artifact doesn't extend another, use itself to create the parent classloader\n      parentClassLoader = artifactClassLoaderFactory.createClassLoader(Locations.toLocation(artifactFile));\n    } else {\n      parentClassLoader = createParentClassLoader(artifactId, parentArtifacts);\n    }\n    validateParentSet(parentArtifacts);\n\n    try {\n      ArtifactClasses artifactClasses = artifactInspector.inspectArtifact(artifactId, artifactFile, parentClassLoader);\n      validatePluginSet(artifactClasses.getPlugins());\n      ArtifactMeta meta = new ArtifactMeta(artifactClasses, parentArtifacts);\n      return artifactStore.write(artifactId, meta, Files.newInputStreamSupplier(artifactFile));\n    } finally {\n      parentClassLoader.close();\n    }\n  }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Inspects and builds plugin and application information for the given artifact.\n   * TODO (CDAP-3319) check parents don't have parents\n   *\n   * @param artifactId the id of the artifact to inspect and store\n   * @param artifactFile the artifact to inspect and store\n   * @return detail about the newly added artifact\n   * @throws IOException if there was an exception reading from the artifact store\n   * @throws WriteConflictException if there was a write conflict writing to the ArtifactStore\n   * @throws ArtifactAlreadyExistsException if the artifact already exists\n   * @throws InvalidArtifactException if the artifact is invalid. For example, if it is not a zip file,\n   *                                  or the application class given is not an Application.\n   */\n  public ArtifactDetail addArtifact(Id.Artifact artifactId, File artifactFile)\n    throws IOException, WriteConflictException, ArtifactAlreadyExistsException, InvalidArtifactException {\n\n    try (CloseableClassLoader parentClassLoader =\n           artifactClassLoaderFactory.createClassLoader(Locations.toLocation(artifactFile))) {\n      ArtifactClasses artifactClasses = artifactInspector.inspectArtifact(artifactId, artifactFile, parentClassLoader);\n      ArtifactMeta meta = new ArtifactMeta(artifactClasses, ImmutableSet.<ArtifactRange>of());\n      return artifactStore.write(artifactId, meta, Files.newInputStreamSupplier(artifactFile));\n    }\n  }","id":95559,"modified_method":"/**\n   * Inspects and builds plugin and application information for the given artifact.\n   *\n   * @param artifactId the id of the artifact to inspect and store\n   * @param artifactFile the artifact to inspect and store\n   * @return detail about the newly added artifact\n   * @throws IOException if there was an exception reading from the artifact store\n   * @throws WriteConflictException if there was a write conflict writing to the ArtifactStore\n   * @throws ArtifactAlreadyExistsException if the artifact already exists\n   * @throws InvalidArtifactException if the artifact is invalid. For example, if it is not a zip file,\n   *                                  or the application class given is not an Application.\n   */\n  public ArtifactDetail addArtifact(Id.Artifact artifactId, File artifactFile)\n    throws IOException, WriteConflictException, ArtifactAlreadyExistsException, InvalidArtifactException {\n\n    try (CloseableClassLoader parentClassLoader =\n           artifactClassLoaderFactory.createClassLoader(Locations.toLocation(artifactFile))) {\n      ArtifactClasses artifactClasses = artifactInspector.inspectArtifact(artifactId, artifactFile, parentClassLoader);\n      validatePluginSet(artifactClasses.getPlugins());\n      ArtifactMeta meta = new ArtifactMeta(artifactClasses, ImmutableSet.<ArtifactRange>of());\n      return artifactStore.write(artifactId, meta, Files.newInputStreamSupplier(artifactFile));\n    }\n  }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Scan all files in the local system artifact directory, looking for jar files and adding them as system artifacts.\n   * If the artifact already exists it will not be added again unless it is a snapshot version.\n   *\n   * @throws IOException if there was some IO error adding the system artifacts\n   * @throws WriteConflictException if there was a write conflicting adding the system artifact. This shouldn't happen,\n   *                                but if it does, it should be ok to retry the operation.\n   */\n  public void addSystemArtifacts() throws IOException, WriteConflictException {\n\n    // scan the directory for artifact .jar files and config files for those artifacts\n    List<SystemArtifactConfig> systemArtifacts = new ArrayList<>();\n    for (File jarFile : DirUtils.listFiles(systemArtifactDir, \"jar\")) {\n      // parse id from filename\n      Id.Artifact artifactId;\n      try {\n        artifactId = parse(Id.Namespace.SYSTEM, jarFile.getName());\n      } catch (InvalidArtifactException e) {\n        LOG.warn(String.format(\"Skipping system artifact '%s' because the name is invalid: \", e.getMessage()));\n        continue;\n      }\n\n      // check for a corresponding .json config file\n      String artifactFileName = jarFile.getName();\n      String configFileName = artifactFileName.substring(0, artifactFileName.length() - \".jar\".length()) + \".json\";\n      File configFile = new File(systemArtifactDir, configFileName);\n      try {\n        if (configFile.isFile()) {\n          // if a config file exists, parse it and add it to the list\n          systemArtifacts.add(SystemArtifactConfig.read(artifactId, configFile, jarFile));\n        } else {\n          // otherwise, don't parse it\n          systemArtifacts.add(SystemArtifactConfig.builder(artifactId, jarFile).build());\n        }\n      } catch (InvalidArtifactException e) {\n        LOG.warn(String.format(\"Could not add system artifact '%s' because it is invalid.\", artifactFileName), e);\n      }\n    }\n\n\n    // Need to be sure to add parent artifacts before artifacts that extend them.\n    Collections.sort(systemArtifacts);\n    for (SystemArtifactConfig systemArtifactConfig : systemArtifacts) {\n      String fileName = systemArtifactConfig.getFile().getName();\n      try {\n        Id.Artifact artifactId = systemArtifactConfig.getArtifactId();\n\n        // if it's not a snapshot and it already exists, don't bother trying to add it since artifacts are immutable\n        if (!artifactId.getVersion().isSnapshot()) {\n          try {\n            artifactStore.getArtifact(artifactId);\n            continue;\n          } catch (ArtifactNotFoundException e) {\n            // this is fine, means it doesn't exist yet and we should add it\n          }\n        }\n\n        // TODO: (CDAP-3272) use plugin classes from config file\n        addArtifact(artifactId,\n                    systemArtifactConfig.getFile(),\n                    systemArtifactConfig.getParents());\n      } catch (ArtifactAlreadyExistsException e) {\n        // shouldn't happen... but if it does for some reason it's fine, it means it was added some other way already.\n      } catch (ArtifactRangeNotFoundException e) {\n        LOG.warn(String.format(\"Could not add system artifact '%s' because it extends artifacts that do not exist.\",\n          fileName), e);\n      } catch (InvalidArtifactException e) {\n        LOG.warn(String.format(\"Could not add system artifact '%s' because it is invalid.\", fileName), e);\n      }\n    }\n  }","id":95560,"modified_method":"/**\n   * Scan all files in the local system artifact directory, looking for jar files and adding them as system artifacts.\n   * If the artifact already exists it will not be added again unless it is a snapshot version.\n   *\n   * @throws IOException if there was some IO error adding the system artifacts\n   * @throws WriteConflictException if there was a write conflicting adding the system artifact. This shouldn't happen,\n   *                                but if it does, it should be ok to retry the operation.\n   */\n  public void addSystemArtifacts() throws IOException, WriteConflictException {\n\n    // scan the directory for artifact .jar files and config files for those artifacts\n    List<SystemArtifactConfig> systemArtifacts = new ArrayList<>();\n    for (File jarFile : DirUtils.listFiles(systemArtifactDir, \"jar\")) {\n      // parse id from filename\n      Id.Artifact artifactId;\n      try {\n        artifactId = parse(Id.Namespace.SYSTEM, jarFile.getName());\n      } catch (InvalidArtifactException e) {\n        LOG.warn(String.format(\"Skipping system artifact '%s' because the name is invalid: \", e.getMessage()));\n        continue;\n      }\n\n      // check for a corresponding .json config file\n      String artifactFileName = jarFile.getName();\n      String configFileName = artifactFileName.substring(0, artifactFileName.length() - \".jar\".length()) + \".json\";\n      File configFile = new File(systemArtifactDir, configFileName);\n\n      try {\n        // read and parse the config file if it exists. Otherwise use an empty config with the artifact filename\n        SystemArtifactConfig systemArtifactConfig = configFile.isFile() ?\n          SystemArtifactConfig.read(artifactId, configFile, jarFile) :\n          SystemArtifactConfig.builder(artifactId, jarFile).build();\n\n        validateParentSet(systemArtifactConfig.getParents());\n        validatePluginSet(systemArtifactConfig.getPlugins());\n        systemArtifacts.add(systemArtifactConfig);\n      } catch (InvalidArtifactException e) {\n        LOG.warn(String.format(\"Could not add system artifact '%s' because it is invalid.\", artifactFileName), e);\n      }\n    }\n\n    // Need to be sure to add parent artifacts before artifacts that extend them.\n    // Sorting will accomplish this because SystemArtifactConfig is comparable based on parents\n    Collections.sort(systemArtifacts);\n\n    for (SystemArtifactConfig systemArtifactConfig : systemArtifacts) {\n      String fileName = systemArtifactConfig.getFile().getName();\n      try {\n        Id.Artifact artifactId = systemArtifactConfig.getArtifactId();\n\n        // if it's not a snapshot and it already exists, don't bother trying to add it since artifacts are immutable\n        if (!artifactId.getVersion().isSnapshot()) {\n          try {\n            artifactStore.getArtifact(artifactId);\n            continue;\n          } catch (ArtifactNotFoundException e) {\n            // this is fine, means it doesn't exist yet and we should add it\n          }\n        }\n\n        // TODO: (CDAP-3272) use plugin classes from config file\n        addArtifact(artifactId,\n                    systemArtifactConfig.getFile(),\n                    systemArtifactConfig.getParents());\n      } catch (ArtifactAlreadyExistsException e) {\n        // shouldn't happen... but if it does for some reason it's fine, it means it was added some other way already.\n      } catch (ArtifactRangeNotFoundException e) {\n        LOG.warn(String.format(\"Could not add system artifact '%s' because it extends artifacts that do not exist.\",\n          fileName), e);\n      } catch (InvalidArtifactException e) {\n        LOG.warn(String.format(\"Could not add system artifact '%s' because it is invalid.\", fileName), e);\n      }\n    }\n  }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public PluginClass deserialize(JsonElement json, Type typeOfT,\n                                 JsonDeserializationContext context) throws JsonParseException {\n    if (!json.isJsonObject()) {\n      throw new JsonParseException(\"PluginClass should be a JSON Object\");\n    }\n\n    JsonObject jsonObj = json.getAsJsonObject();\n\n    String type = jsonObj.has(\"type\") ? jsonObj.get(\"type\").getAsString() : Plugin.DEFAULT_TYPE;\n    String name = getRequired(jsonObj, \"name\").getAsString();\n    String description = getRequired(jsonObj, \"description\").getAsString();\n    String className = getRequired(jsonObj, \"className\").getAsString();\n\n    Map<String, PluginPropertyField> properties = jsonObj.has(\"properties\")\n      ? context.<Map<String, PluginPropertyField>>deserialize(jsonObj.get(\"properties\"), PROPERTIES_TYPE)\n      : ImmutableMap.<String, PluginPropertyField>of();\n\n    return new PluginClass(type, name, description, className, null, properties);\n  }","id":95561,"modified_method":"@Override\n  public PluginClass deserialize(JsonElement json, Type typeOfT,\n                                 JsonDeserializationContext context) throws JsonParseException {\n    if (!json.isJsonObject()) {\n      throw new JsonParseException(\"PluginClass should be a JSON Object\");\n    }\n\n    JsonObject jsonObj = json.getAsJsonObject();\n\n    String type = jsonObj.has(\"type\") ? jsonObj.get(\"type\").getAsString() : Plugin.DEFAULT_TYPE;\n    String name = getRequired(jsonObj, \"name\").getAsString();\n    String description = jsonObj.has(\"description\") ? jsonObj.get(\"description\").getAsString() : \"\";\n    String className = getRequired(jsonObj, \"className\").getAsString();\n\n    Map<String, PluginPropertyField> properties = jsonObj.has(\"properties\")\n      ? context.<Map<String, PluginPropertyField>>deserialize(jsonObj.get(\"properties\"), PROPERTIES_TYPE)\n      : ImmutableMap.<String, PluginPropertyField>of();\n\n    return new PluginClass(type, name, description, className, null, properties);\n  }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"SystemArtifactConfig build() throws InvalidArtifactException {\n      validateParentList(parents);\n      validatePluginList(plugins);\n      SystemArtifactConfig config = new SystemArtifactConfig(artifactId, artifactFile,\n        Collections.unmodifiableSet(parents), Collections.unmodifiableSet(plugins));\n      return config;\n    }","id":95562,"modified_method":"SystemArtifactConfig build() {\n      return new SystemArtifactConfig(artifactId, artifactFile,\n        Collections.unmodifiableSet(parents), Collections.unmodifiableSet(plugins));\n    }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"@VisibleForTesting\n    Builder addParents(ArtifactRange parent, ArtifactRange... parents) {\n      this.parents.add(parent);\n      for (ArtifactRange parentRange : parents) {\n        this.parents.add(parentRange);\n      }\n      return this;\n    }","id":95563,"modified_method":"@VisibleForTesting\n    Builder addParents(ArtifactRange parent, ArtifactRange... parents) {\n      this.parents.add(parent);\n      Collections.addAll(this.parents, parents);\n      return this;\n    }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"@VisibleForTesting\n    Builder addPlugins(PluginClass pluginClass, PluginClass... plugins) {\n      this.plugins.add(pluginClass);\n      for (PluginClass plugin : plugins) {\n        this.plugins.add(plugin);\n      }\n      return this;\n    }","id":95564,"modified_method":"@VisibleForTesting\n    Builder addPlugins(PluginClass pluginClass, PluginClass... plugins) {\n      this.plugins.add(pluginClass);\n      Collections.addAll(this.plugins, plugins);\n      return this;\n    }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public SystemArtifactConfig deserialize(JsonElement json, Type typeOfT,\n                                            JsonDeserializationContext context) throws JsonParseException {\n      if (!json.isJsonObject()) {\n        throw new JsonParseException(\"Config file must be a JSON Object.\");\n      }\n      JsonObject obj = json.getAsJsonObject();\n\n      // deserialize fields\n      Set<ArtifactRange> parents = context.deserialize(obj.get(\"parents\"), PARENTS_TYPE);\n      parents = parents == null ? Collections.<ArtifactRange>emptySet() : parents;\n      Set<PluginClass> plugins = context.deserialize(obj.get(\"plugins\"), PLUGINS_TYPE);\n      plugins = plugins == null ? Collections.<PluginClass>emptySet() : plugins;\n\n      try {\n        validateParentList(parents);\n        validatePluginList(plugins);\n      } catch (InvalidArtifactException e) {\n        throw new JsonParseException(e.getMessage());\n      }\n\n      return new SystemArtifactConfig(parents, plugins);\n    }","id":95565,"modified_method":"@Override\n    public SystemArtifactConfig deserialize(JsonElement json, Type typeOfT,\n                                            JsonDeserializationContext context) throws JsonParseException {\n      if (!json.isJsonObject()) {\n        throw new JsonParseException(\"Config file must be a JSON Object.\");\n      }\n      JsonObject obj = json.getAsJsonObject();\n\n      // deserialize fields\n      Set<ArtifactRange> parents = context.deserialize(obj.get(\"parents\"), PARENTS_TYPE);\n      parents = parents == null ? Collections.<ArtifactRange>emptySet() : parents;\n      Set<PluginClass> plugins = context.deserialize(obj.get(\"plugins\"), PLUGINS_TYPE);\n      plugins = plugins == null ? Collections.<PluginClass>emptySet() : plugins;\n\n      return new SystemArtifactConfig(parents, plugins);\n    }","commit_id":"1e82666faefd9101cb67047447fd7b8cbfd52525","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configuration time constructor.\n   * \n   * @param name the name of the table\n   * @param table table to use as the table\n   * @param index table to use as the index\n   * @param columnsToIndex the names of the data columns to index\n   */\n  public IndexedTable(String name, Table table, Table index, byte[][] columnsToIndex) {\n    super(name, table, index);\n    this.table = table;\n    this.index = index;\n    this.indexedColumns = Sets.newTreeSet(Bytes.BYTES_COMPARATOR);\n    for (byte[] col : columnsToIndex) {\n      this.indexedColumns.add(col);\n    }\n  }","id":95566,"modified_method":"/**\n   * Configuration time constructor.\n   * \n   * @param name the name of the table\n   * @param table table to use as the table\n   * @param index table to use as the index\n   * @param columnsToIndex the names of the data columns to index\n   */\n  public IndexedTable(String name, Table table, Table index, byte[][] columnsToIndex) {\n    super(name, table, index);\n    this.table = table;\n    this.index = index;\n    this.indexedColumns = Sets.newTreeSet(Bytes.BYTES_COMPARATOR);\n    Collections.addAll(this.indexedColumns, columnsToIndex);\n  }","commit_id":"4ae0489126d16d64ac682f5892cbe8303c0d97ef","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Reads table rows by the given secondary index key.  If no rows are indexed by the given key, then a\n   * {@link co.cask.cdap.api.dataset.table.Scanner} with no results will be returned.\n   * \n   * @return a Scanner returning rows from the data table, whose stored value for the given column matches the\n   * given value.\n   * @throws java.lang.IllegalArgumentException if the given column is not configured for indexing.\n   */\n  public Scanner readByIndex(byte[] column, byte[] value) {\n    if (!indexedColumns.contains(column)) {\n      throw new IllegalArgumentException(\"Column \" + Bytes.toStringBinary(column) + \" is not configured for indexing\");\n    }\n    byte[] rowKeyPrefix = Bytes.concat(column, keyDelimiter, value, keyDelimiter);\n    byte[] stopRow = Bytes.stopKeyForPrefix(rowKeyPrefix);\n    Scanner indexScan = index.scan(rowKeyPrefix, stopRow);\n    return new IndexScanner(indexScan, rowKeyPrefix);\n  }","id":95567,"modified_method":"/**\n   * Reads table rows by the given secondary index key.  If no rows are indexed by the given key, then a\n   * {@link co.cask.cdap.api.dataset.table.Scanner} with no results will be returned.\n   * \n   * @return a Scanner returning rows from the data table, whose stored value for the given column matches the\n   * given value.\n   * @throws java.lang.IllegalArgumentException if the given column is not configured for indexing.\n   */\n  public Scanner readByIndex(byte[] column, byte[] value) {\n    assertIndexedColumn(column);\n    byte[] rowKeyPrefix = Bytes.concat(column, keyDelimiter, value, keyDelimiter);\n    byte[] stopRow = Bytes.stopKeyForPrefix(rowKeyPrefix);\n    Scanner indexScan = index.scan(rowKeyPrefix, stopRow);\n    return new IndexScanner(indexScan, rowKeyPrefix);\n  }","commit_id":"4ae0489126d16d64ac682f5892cbe8303c0d97ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Nullable\n    @Override\n    public Row next() {\n      // TODO: retrieve results in batches to minimize RPC overhead (requires multi-get support in table)\n      Row dataRow = null;\n      // keep going until we hit a non-null, non-empty data row, or we exhaust the index\n      while (dataRow == null) {\n        Row indexRow = baseScanner.next();\n        if (indexRow == null) {\n          // end of index\n          return null;\n        }\n        byte[] rowkey = indexRow.get(IDX_COL);\n        // verify that datarow matches the expected row key to avoid issues with column name or value\n        // containing the delimiter used\n        if (rowkey != null && Bytes.equals(indexRow.getRow(), Bytes.add(rowKeyPrefix, rowkey))) {\n          dataRow = table.get(rowkey);\n        }\n      }\n      return dataRow;\n    }","id":95568,"modified_method":"@Nullable\n    @Override\n    public Row next() {\n      // TODO: retrieve results in batches to minimize RPC overhead (requires multi-get support in table)\n      // keep going until we hit a non-null, non-empty data row, or we exhaust the index\n      Row indexRow;\n      while ((indexRow = baseScanner.next()) != null) {\n        byte[] rowkey = indexRow.get(IDX_COL);\n        // verify that datarow matches the expected row key to avoid issues with column name or value\n        // containing the delimiter used\n        if (rowkey != null) {\n          if (rowKeyPrefix == null || Bytes.equals(indexRow.getRow(), Bytes.add(rowKeyPrefix, rowkey))) {\n            return table.get(rowkey);\n          }\n        }\n      }\n      // end of index\n      return null;\n    }","commit_id":"4ae0489126d16d64ac682f5892cbe8303c0d97ef","url":"https://github.com/caskdata/cdap"},{"original_method":"private Row readFirst(Scanner scanner) {\n    Row row = null;\n    try {\n      row = scanner.next();\n    } finally {\n      scanner.close();\n    }\n    return row;\n  }","id":95569,"modified_method":"private Row readFirst(Scanner scanner) {\n    try {\n      return scanner.next();\n    } finally {\n      scanner.close();\n    }\n  }","commit_id":"4ae0489126d16d64ac682f5892cbe8303c0d97ef","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testIndexedOperations() throws Exception {\n    TransactionExecutor txnl = dsFrameworkUtil.newTransactionExecutor(table);\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // add a value c with idx = 1, and b with idx = 2\n        table.put(new Put(keyC).add(idxCol, idx1).add(valCol, valC));\n        table.put(new Put(keyB).add(idxCol, idx2).add(valCol, valB));\n      }\n    });\n\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // read by key c\n        Row row = table.get(new Get(keyC, colIdxVal));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valC});\n        // read by key b\n        row = table.get(new Get(keyB, colIdxVal));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valB});\n        // read by idx 1 -> c\n        row = readFirst(table.readByIndex(idxCol, idx1));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valC});\n        // read by idx 2 -> b\n        row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valB});\n        // test read over empty index (idx 3)\n        row = readFirst(table.readByIndex(idxCol, idx3));\n        Assert.assertNull(row);\n      }\n    });\n\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // add a value a with idx = 1\n        table.put(new Put(keyA).add(idxCol, idx1).add(valCol, valA));\n      }\n    });\n\n    // read by idx 1 -> a\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx1));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valA});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // delete value a\n        table.delete(new Delete(keyA, colIdxVal));\n      }\n    });\n\n    // read by idx 1 -> c\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx1));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valC});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // add a value aa with idx 2\n        table.put(new Put(keyAA).add(idxCol, idx2).add(valCol, valAA));\n      }\n    });\n\n    // read by idx 2 -> aa\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valAA});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap value for aa to ab\n        Assert.assertTrue(table.compareAndSwap(keyAA, valCol, valAA, valAB));\n      }\n    });\n\n    // read by idx 2 -> ab\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valAB});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap value for aa to bb\n        Assert.assertTrue(table.compareAndSwap(keyAA, valCol, valAB, valBB));\n      }\n    });\n\n    // read by idx 2 -> bb (value of key aa)\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valBB});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap value for aa to null\n        Assert.assertTrue(table.compareAndSwap(keyAA, valCol, valBB, null));\n      }\n    });\n\n    // read by idx 2 -> null (value of b)\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumn(row, idxCol, idx2);\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap idx for c to 3\n        Assert.assertTrue(table.compareAndSwap(keyC, idxCol, idx1, idx3));\n      }\n    });\n\n    // read by idx 1 -> null (no row has that any more)\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Assert.assertNull(readFirst(table.readByIndex(idxCol, idx1)));\n        // read by idx 3 > c\n        Row row = readFirst(table.readByIndex(idxCol, idx3));\n        TableAssert.assertColumns(row, new byte[][]{idxCol, valCol}, new byte[][]{idx3, valC});\n      }\n    });\n  }","id":95570,"modified_method":"@Test\n  public void testIndexedOperations() throws Exception {\n    TransactionExecutor txnl = dsFrameworkUtil.newTransactionExecutor(table);\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // add a value c with idx = 1, and b with idx = 2\n        table.put(new Put(keyC).add(idxCol, idx1).add(valCol, valC));\n        table.put(new Put(keyB).add(idxCol, idx2).add(valCol, valB));\n      }\n    });\n\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // read by key c\n        Row row = table.get(new Get(keyC, colIdxVal));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valC});\n        // read by key b\n        row = table.get(new Get(keyB, colIdxVal));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valB});\n        // read by idx 1 -> c\n        row = readFirst(table.readByIndex(idxCol, idx1));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valC});\n        // read by idx 2 -> b\n        row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valB});\n        // test read over empty index (idx 3)\n        assertEmpty(table.readByIndex(idxCol, idx3));\n      }\n    });\n\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // add a value a with idx = 1\n        table.put(new Put(keyA).add(idxCol, idx1).add(valCol, valA));\n      }\n    });\n\n    // read by idx 1 -> a\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx1));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valA});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // delete value a\n        table.delete(new Delete(keyA, colIdxVal));\n      }\n    });\n\n    // read by idx 1 -> c\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx1));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx1, valC});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // add a value aa with idx 2\n        table.put(new Put(keyAA).add(idxCol, idx2).add(valCol, valAA));\n      }\n    });\n\n    // read by idx 2 -> aa\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valAA});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap value for aa to ab\n        Assert.assertTrue(table.compareAndSwap(keyAA, valCol, valAA, valAB));\n      }\n    });\n\n    // read by idx 2 -> ab\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valAB});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap value for aa to bb\n        Assert.assertTrue(table.compareAndSwap(keyAA, valCol, valAB, valBB));\n      }\n    });\n\n    // read by idx 2 -> bb (value of key aa)\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumns(row, colIdxVal, new byte[][]{idx2, valBB});\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap value for aa to null\n        Assert.assertTrue(table.compareAndSwap(keyAA, valCol, valBB, null));\n      }\n    });\n\n    // read by idx 2 -> null (value of b)\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        Row row = readFirst(table.readByIndex(idxCol, idx2));\n        TableAssert.assertColumn(row, idxCol, idx2);\n      }\n    });\n\n    // start a new transaction\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        // swap idx for c to 3\n        Assert.assertTrue(table.compareAndSwap(keyC, idxCol, idx1, idx3));\n      }\n    });\n\n    // read by idx 1 -> null (no row has that any more)\n    txnl.execute(new TransactionExecutor.Subroutine() {\n      @Override\n      public void apply() throws Exception {\n        assertEmpty(table.readByIndex(idxCol, idx1));\n        // read by idx 3 > c\n        Row row = readFirst(table.readByIndex(idxCol, idx3));\n        TableAssert.assertColumns(row, new byte[][]{idxCol, valCol}, new byte[][]{idx3, valC});\n      }\n    });\n  }","commit_id":"4ae0489126d16d64ac682f5892cbe8303c0d97ef","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * @param flags flags to set. If no flags are supplied, default flags will be set.\n     */\n    public CommonStatsFlags(Flag... flags) {\n        if (flags.length > 0) {\n            clear();\n            for (Flag f : flags) {\n                this.flags.add(f);\n            }\n        }\n    }","id":95571,"modified_method":"/**\n     * @param flags flags to set. If no flags are supplied, default flags will be set.\n     */\n    public CommonStatsFlags(Flag... flags) {\n        if (flags.length > 0) {\n            clear();\n            Collections.addAll(this.flags, flags);\n        }\n    }","commit_id":"a33e4b1d7648934ae57a2c8cfb0ad06408029c66","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * @see org.apache.felix.cm.impl.ConfigurationImpl#getBundleLocation()\n     */\n    public String getBundleLocation()\n    {\n        delegatee.getConfigurationManager().log( LogService.LOG_DEBUG, \"getBundleLocation()\", ( Throwable ) null );\n\n        // CM 1.4 / 104.13.2.4\n        configurationAdmin.checkPermission( delegatee.getBundleLocation() );\n        checkDeleted();\n        return delegatee.getBundleLocation();\n    }","id":95572,"modified_method":"/**\n     * @see org.apache.felix.cm.impl.ConfigurationImpl#getBundleLocation()\n     */\n    public String getBundleLocation()\n    {\n        delegatee.getConfigurationManager().log( LogService.LOG_DEBUG, \"getBundleLocation()\", ( Throwable ) null );\n\n        // CM 1.4 / 104.13.2.4\n        final String bundleLocation = delegatee.getBundleLocation();\n        configurationAdmin.checkPermission( ( bundleLocation == null ) ? \"*\" : bundleLocation );\n        checkDeleted();\n        return bundleLocation;\n    }","commit_id":"fa6f013b13060e7c941e5a79b7f80f391be8d32f","url":"https://github.com/apache/felix"},{"original_method":"public Configuration createFactoryConfiguration( String factoryPid, String location ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"createFactoryConfiguration(factoryPid={0}, location={1})\",\n            new Object[]\n                { factoryPid, location } );\n\n        // CM 1.4 / 104.13.2.3\n        this.checkPermission( location );\n\n        return this.wrap( configurationManager.createFactoryConfiguration( factoryPid, location ) );\n    }","id":95573,"modified_method":"public Configuration createFactoryConfiguration( String factoryPid, String location ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"createFactoryConfiguration(factoryPid={0}, location={1})\",\n            new Object[]\n                { factoryPid, location } );\n\n        // CM 1.4 / 104.13.2.3\n        this.checkPermission( ( location == null ) ? \"*\" : location );\n\n        ConfigurationImpl config = configurationManager.createFactoryConfiguration( factoryPid, location );\n        return this.wrap( config );\n    }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"public Configuration createFactoryConfiguration( String factoryPid ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"createFactoryConfiguration(factoryPid={0})\", new Object[]\n            { factoryPid } );\n\n        return this.wrap( configurationManager.createFactoryConfiguration( this, factoryPid ) );\n    }","id":95574,"modified_method":"public Configuration createFactoryConfiguration( String factoryPid ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"createFactoryConfiguration(factoryPid={0})\", new Object[]\n            { factoryPid } );\n\n        ConfigurationImpl config = configurationManager.createFactoryConfiguration( factoryPid, this.getBundle()\n            .getLocation() );\n        return this.wrap( config );\n    }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"public Configuration getConfiguration( String pid ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"getConfiguration(pid={0})\", new Object[]\n            { pid } );\n\n        ConfigurationImpl config = configurationManager.getConfiguration( pid, getBundle().getLocation() );\n\n        if ( config.getBundleLocation() == null )\n        {\n            configurationManager.log( LogService.LOG_DEBUG, \"Binding configuration {0} (isNew: {1}) to bundle {2}\",\n                new Object[]\n                    { config.getPid(), Boolean.valueOf( config.isNew() ), getBundle().getLocation() } );\n\n            config.setStaticBundleLocation( this.getBundle().getLocation() );\n        }\n        else if ( !config.getBundleLocation().equals( this.getBundle().getLocation() ) )\n        {\n            // CM 1.4 / 104.13.2.3\n            this.checkPermission( config.getBundleLocation() );\n        }\n\n        return this.wrap( config );\n    }","id":95575,"modified_method":"public Configuration getConfiguration( String pid ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"getConfiguration(pid={0})\", new Object[]\n            { pid } );\n\n        ConfigurationImpl config = configurationManager.getConfiguration( pid );\n        if ( config == null )\n        {\n            config = configurationManager.createConfiguration( pid, getBundle().getLocation() );\n        }\n        else\n        {\n            if ( config.getBundleLocation() == null )\n            {\n                configurationManager.log( LogService.LOG_DEBUG, \"Binding configuration {0} (isNew: {1}) to bundle {2}\",\n                    new Object[]\n                        { config.getPid(), Boolean.valueOf( config.isNew() ), this.getBundle().getLocation() } );\n\n                config.setStaticBundleLocation( this.getBundle().getLocation() );\n            }\n            else\n            {\n                // CM 1.4 / 104.13.2.3\n                this.checkPermission( config.getBundleLocation() );\n            }\n        }\n\n        return this.wrap( config );\n    }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"public Configuration getConfiguration( String pid, String location ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"getConfiguration(pid={0}, location={1})\", new Object[]\n            { pid, location } );\n\n        // CM 1.4 / 104.13.2.3\n        this.checkPermission( location );\n\n        ConfigurationImpl config = configurationManager.getConfiguration( pid, location );\n        if ( config.getBundleLocation() != null )\n        {\n            // CM 1.4 / 104.13.2.3\n            this.checkPermission( config.getBundleLocation() );\n        }\n\n        return this.wrap( config );\n    }","id":95576,"modified_method":"public Configuration getConfiguration( String pid, String location ) throws IOException\n    {\n        configurationManager.log( LogService.LOG_DEBUG, \"getConfiguration(pid={0}, location={1})\", new Object[]\n            { pid, location } );\n\n        // CM 1.4 / 104.13.2.3\n        this.checkPermission( ( location == null ) ? \"*\" : location );\n\n        ConfigurationImpl config = configurationManager.getConfiguration( pid );\n        if ( config == null )\n        {\n            config = configurationManager.createConfiguration( pid, location );\n        }\n        else\n        {\n            final String configLocation = config.getBundleLocation();\n            this.checkPermission( ( configLocation == null ) ? \"*\" : configLocation );\n        }\n\n        return this.wrap( config );\n    }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"ConfigurationImpl getConfiguration( String pid, String bundleLocation ) throws IOException\n    {\n        // check for existing (cached or persistent) configuration\n        ConfigurationImpl config = getExistingConfiguration( pid );\n        if ( config != null )\n        {\n            return config;\n        }\n\n        // else create new configuration also setting the bundle location\n        // and cache the new configuration\n        config = createConfiguration( pid, null, bundleLocation );\n        return cacheConfiguration( config );\n    }","id":95577,"modified_method":"/**\n     * Returns the {@link ConfigurationImpl} with the given PID if\n     * available in the internal cache or from any persistence manager.\n     * Otherwise <code>null<\/code> is returned.\n     *\n     * @param pid The PID for which to return the configuration\n     * @return The configuration or <code>null<\/code> if non exists\n     * @throws IOException If an error occurrs reading from a persistence\n     *      manager.\n     */\n    ConfigurationImpl getConfiguration( String pid ) throws IOException\n    {\n        ConfigurationImpl config = getCachedConfiguration( pid );\n        if ( config != null )\n        {\n            log( LogService.LOG_DEBUG, \"Found cached configuration {0} bound to {1}\", new Object[]\n                { pid, config.getBundleLocation() } );\n            return config;\n        }\n\n        PersistenceManager[] pmList = getPersistenceManagers();\n        for ( int i = 0; i < pmList.length; i++ )\n        {\n            if ( pmList[i].exists( pid ) )\n            {\n                Dictionary props = pmList[i].load( pid );\n                config = new ConfigurationImpl( this, pmList[i], props );\n                log( LogService.LOG_DEBUG, \"Found existing configuration {0} bound to {1}\", new Object[]\n                    { pid, config.getBundleLocation() } );\n                return cacheConfiguration( config );\n            }\n        }\n\n        // neither the cache nor any persistence manager has configuration\n        return null;\n    }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"ManagedServiceUpdate( String pid, ServiceReference sr, ManagedService service )\n        {\n            this.pid = pid;\n            this.sr = sr;\n            this.service = service;\n\n            // get or load configuration for the pid\n            ConfigurationImpl config = null;\n            Dictionary rawProperties = null;\n            long lastModificationTime = -1;\n            try\n            {\n                config = getExistingConfiguration( pid );\n                if ( config != null )\n                {\n                    synchronized ( config )\n                    {\n                        rawProperties = config.getProperties( true );\n                        lastModificationTime = config.getLastModificationTime();\n                    }\n                }\n            }\n            catch ( IOException ioe )\n            {\n                log( LogService.LOG_ERROR, \"Error loading configuration for {0}\", new Object[]\n                    { pid, ioe } );\n            }\n\n            this.config = config;\n            this.rawProperties = rawProperties;\n            this.lastModificationTime = lastModificationTime;\n        }","id":95578,"modified_method":"ManagedServiceUpdate( String pid, ServiceReference sr, ManagedService service )\n        {\n            this.pid = pid;\n            this.sr = sr;\n            this.service = service;\n\n            // get or load configuration for the pid\n            ConfigurationImpl config = null;\n            Dictionary rawProperties = null;\n            long lastModificationTime = -1;\n            try\n            {\n                config = getConfiguration( pid );\n                if ( config != null )\n                {\n                    synchronized ( config )\n                    {\n                        rawProperties = config.getProperties( true );\n                        lastModificationTime = config.getLastModificationTime();\n                    }\n                }\n            }\n            catch ( IOException ioe )\n            {\n                log( LogService.LOG_ERROR, \"Error loading configuration for {0}\", new Object[]\n                    { pid, ioe } );\n            }\n\n            this.config = config;\n            this.rawProperties = rawProperties;\n            this.lastModificationTime = lastModificationTime;\n        }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"ManagedServiceFactoryUpdate( String factoryPid, ServiceReference sr, ManagedServiceFactory service )\n        {\n            this.factoryPid = factoryPid;\n            this.sr = sr;\n            this.service = service;\n\n            Factory factory = null;\n            Map configs = null;\n            Map stamps = null;\n            try\n            {\n                factory = getFactory( factoryPid );\n                if (factory != null) {\n                    configs = new HashMap();\n                    stamps = new HashMap();\n                    for ( Iterator pi = factory.getPIDs().iterator(); pi.hasNext(); )\n                    {\n                        final String pid = ( String ) pi.next();\n                        ConfigurationImpl cfg;\n                        try\n                        {\n                            cfg = getExistingConfiguration( pid );\n                        }\n                        catch ( IOException ioe )\n                        {\n                            log( LogService.LOG_ERROR, \"Error loading configuration for {0}\", new Object[]\n                                { pid, ioe } );\n                            continue;\n                        }\n\n                        // sanity check on the configuration\n                        if ( cfg == null )\n                        {\n                            log( LogService.LOG_ERROR, \"Configuration {0} referred to by factory {1} does not exist\",\n                                new Object[]\n                                    { pid, factoryPid } );\n                            factory.removePID( pid );\n                            factory.storeSilently();\n                            continue;\n                        }\n                        else if ( cfg.isNew() )\n                        {\n                            // Configuration has just been created but not yet updated\n                            // we currently just ignore it and have the update mechanism\n                            // provide the configuration to the ManagedServiceFactory\n                            // As of FELIX-612 (not storing new factory configurations)\n                            // this should not happen. We keep this for added stability\n                            // but raise the logging level to error.\n                            log( LogService.LOG_ERROR, \"Ignoring new configuration pid={0}\", new Object[]\n                                { pid } );\n                            continue;\n                        }\n                        else if ( !factoryPid.equals( cfg.getFactoryPid() ) )\n                        {\n                            log( LogService.LOG_ERROR,\n                                \"Configuration {0} referred to by factory {1} seems to belong to factory {2}\",\n                                new Object[]\n                                    { pid, factoryPid, cfg.getFactoryPid() } );\n                            factory.removePID( pid );\n                            factory.storeSilently();\n                            continue;\n                        }\n\n                        // get the configuration properties for later\n                        synchronized ( cfg )\n                        {\n                            configs.put( cfg, cfg.getProperties( true ) );\n                            stamps.put( cfg, new Long( cfg.getLastModificationTime() ) );\n                        }\n                    }\n                }\n            }\n            catch ( IOException ioe )\n            {\n                log( LogService.LOG_ERROR, \"Cannot get factory mapping for factory PID {0}\", new Object[]\n                    { factoryPid, ioe } );\n            }\n\n            this.configs = configs;\n            this.stamps = stamps;\n        }","id":95579,"modified_method":"ManagedServiceFactoryUpdate( String factoryPid, ServiceReference sr, ManagedServiceFactory service )\n        {\n            this.factoryPid = factoryPid;\n            this.sr = sr;\n            this.service = service;\n\n            Factory factory = null;\n            Map configs = null;\n            Map stamps = null;\n            try\n            {\n                factory = getFactory( factoryPid );\n                if (factory != null) {\n                    configs = new HashMap();\n                    stamps = new HashMap();\n                    for ( Iterator pi = factory.getPIDs().iterator(); pi.hasNext(); )\n                    {\n                        final String pid = ( String ) pi.next();\n                        ConfigurationImpl cfg;\n                        try\n                        {\n                            cfg = getConfiguration( pid );\n                        }\n                        catch ( IOException ioe )\n                        {\n                            log( LogService.LOG_ERROR, \"Error loading configuration for {0}\", new Object[]\n                                { pid, ioe } );\n                            continue;\n                        }\n\n                        // sanity check on the configuration\n                        if ( cfg == null )\n                        {\n                            log( LogService.LOG_ERROR, \"Configuration {0} referred to by factory {1} does not exist\",\n                                new Object[]\n                                    { pid, factoryPid } );\n                            factory.removePID( pid );\n                            factory.storeSilently();\n                            continue;\n                        }\n                        else if ( cfg.isNew() )\n                        {\n                            // Configuration has just been created but not yet updated\n                            // we currently just ignore it and have the update mechanism\n                            // provide the configuration to the ManagedServiceFactory\n                            // As of FELIX-612 (not storing new factory configurations)\n                            // this should not happen. We keep this for added stability\n                            // but raise the logging level to error.\n                            log( LogService.LOG_ERROR, \"Ignoring new configuration pid={0}\", new Object[]\n                                { pid } );\n                            continue;\n                        }\n                        else if ( !factoryPid.equals( cfg.getFactoryPid() ) )\n                        {\n                            log( LogService.LOG_ERROR,\n                                \"Configuration {0} referred to by factory {1} seems to belong to factory {2}\",\n                                new Object[]\n                                    { pid, factoryPid, cfg.getFactoryPid() } );\n                            factory.removePID( pid );\n                            factory.storeSilently();\n                            continue;\n                        }\n\n                        // get the configuration properties for later\n                        synchronized ( cfg )\n                        {\n                            configs.put( cfg, cfg.getProperties( true ) );\n                            stamps.put( cfg, new Long( cfg.getLastModificationTime() ) );\n                        }\n                    }\n                }\n            }\n            catch ( IOException ioe )\n            {\n                log( LogService.LOG_ERROR, \"Cannot get factory mapping for factory PID {0}\", new Object[]\n                    { factoryPid, ioe } );\n            }\n\n            this.configs = configs;\n            this.stamps = stamps;\n        }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"ConfigurationImpl getExistingConfiguration( String pid ) throws IOException\n    {\n        ConfigurationImpl config = getCachedConfiguration( pid );\n        if ( config != null )\n        {\n            log( LogService.LOG_DEBUG, \"Found cached configuration {0} bound to {1}\", new Object[]\n                { pid, config.getBundleLocation() } );\n            return config;\n        }\n\n        PersistenceManager[] pmList = getPersistenceManagers();\n        for ( int i = 0; i < pmList.length; i++ )\n        {\n            if ( pmList[i].exists( pid ) )\n            {\n                Dictionary props = pmList[i].load( pid );\n                config = new ConfigurationImpl( this, pmList[i], props );\n                log( LogService.LOG_DEBUG, \"Found existing configuration {0} bound to {1}\", new Object[]\n                    { pid, config.getBundleLocation() } );\n                return cacheConfiguration( config );\n            }\n        }\n\n        // neither the cache nor any persistence manager has configuration\n        return null;\n    }","id":95580,"modified_method":"/**\n     * Creates a regular (non-factory) configuration for the given PID\n     * setting the bundle location accordingly.\n     * <p>\n     * This method assumes the configuration to not exist yet and will\n     * create it without further checking.\n     *\n     * @param pid The PID of the new configuration\n     * @param bundleLocation The location to set on the new configuration.\n     *      This may be <code>null<\/code> to not bind the configuration\n     *      yet.\n     * @return The new configuration persisted in the first persistence\n     *      manager.\n     * @throws IOException If an error occurrs writing the configuration\n     *      to the persistence.\n     */\n    ConfigurationImpl createConfiguration( String pid, String bundleLocation ) throws IOException\n    {\n        // check for existing (cached or persistent) configuration\n        ConfigurationImpl config = getConfiguration( pid );\n        if ( config != null )\n        {\n            return config;\n        }\n\n        // else create new configuration also setting the bundle location\n        // and cache the new configuration\n        config = createConfiguration( pid, null, bundleLocation );\n        return cacheConfiguration( config );\n    }","commit_id":"ad9498716cb8e978554d9ce56536443441b5c7d7","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @param bundleLocation\n     * @see org.apache.felix.cm.impl.ConfigurationImpl#setBundleLocation(java.lang.String)\n     */\n    public void setBundleLocation( String bundleLocation )\n    {\n        delegatee.getConfigurationManager().log( LogService.LOG_DEBUG, \"setBundleLocation(bundleLocation={0})\",\n            new Object[]\n                { bundleLocation } );\n\n        // CM 1.4 / 104.13.2.4\n        configurationAdmin.checkPermission( delegatee.getBundleLocation() );\n        configurationAdmin.checkPermission( ( bundleLocation == null ) ? \"*\" : bundleLocation );\n        checkDeleted();\n        delegatee.setStaticBundleLocation( bundleLocation );\n    }","id":95581,"modified_method":"/**\n     * @param bundleLocation\n     * @see org.apache.felix.cm.impl.ConfigurationImpl#setBundleLocation(java.lang.String)\n     */\n    public void setBundleLocation( String bundleLocation )\n    {\n        delegatee.getConfigurationManager().log( LogService.LOG_DEBUG, \"setBundleLocation(bundleLocation={0})\",\n            new Object[]\n                { bundleLocation } );\n\n        // CM 1.4 / 104.13.2.4\n        final String configLocation = delegatee.getBundleLocation();\n        configurationAdmin.checkPermission( ( configLocation == null ) ? \"*\" : configLocation );\n        configurationAdmin.checkPermission( ( bundleLocation == null ) ? \"*\" : bundleLocation );\n        checkDeleted();\n        delegatee.setStaticBundleLocation( bundleLocation );\n    }","commit_id":"565151a56d62190293a4e1511782e4cbfd03ee4a","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Schedules our popular numbers query to run every 3 seconds.\n     *\n     * @param ignite Ignite.\n     * @param timer Timer.\n     * @param cnt Number of popular numbers to return.\n     * @return Scheduled task.\n     */\n    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer, final int cnt) {\n        TimerTask task = new TimerTask() {\n            private CacheQuery<List<?>> qry;\n\n            @Override public void run() {\n                // Get reference to cache.\n                GridCache<Integer, Long> cache = ignite.cache(CACHE_NAME);\n\n                if (qry == null)\n                    qry = cache.queries().\n                        createSqlFieldsQuery(\"select _key, _val from Long order by _val desc limit \" + cnt);\n\n                try {\n                    List<List<?>> results = new ArrayList<>(qry.execute().get());\n\n                    Collections.sort(results, new Comparator<List<?>>() {\n                        @Override public int compare(List<?> r1, List<?> r2) {\n                            long cnt1 = (Long)r1.get(1);\n                            long cnt2 = (Long)r2.get(1);\n\n                            return cnt1 < cnt2 ? 1 : cnt1 > cnt2 ? -1 : 0;\n                        }\n                    });\n\n                    for (int i = 0; i < cnt && i < results.size(); i++) {\n                        List<?> res = results.get(i);\n\n                        System.out.println(res.get(0) + \"=\" + res.get(1));\n                    }\n\n                    System.out.println(\"----------------\");\n                }\n                catch (IgniteCheckedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }","id":95582,"modified_method":"/**\n     * Schedules our popular numbers query to run every 3 seconds.\n     *\n     * @param ignite Ignite.\n     * @param timer Timer.\n     * @param cnt Number of popular numbers to return.\n     * @return Scheduled task.\n     */\n    private static TimerTask scheduleQuery(final Ignite ignite, Timer timer, final int cnt) {\n        TimerTask task = new TimerTask() {\n            @Override public void run() {\n                // Get reference to cache.\n                IgniteCache<Integer, Long> cache = ignite.jcache(CACHE_NAME);\n\n                try {\n                    List<List<?>> results = new ArrayList<>(cache.queryFields(\n                        sql(\"select _key, _val from Long order by _val desc limit ?\").setArgs(cnt)).getAll());\n\n                    for (List<?> res : results)\n                        System.out.println(res.get(0) + \"=\" + res.get(1));\n\n                    System.out.println(\"----------------\");\n                }\n                catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        timer.schedule(task, 3000, 3000);\n\n        return task;\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Example for SQL queries based on salary ranges.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlQuery() throws IgniteCheckedException {\n        GridCache<CacheAffinityKey<UUID>, Person> cache = Ignition.ignite().cache(CACHE_NAME);\n\n        // Create query which selects salaries based on range.\n        CacheQuery<Map.Entry<CacheAffinityKey<UUID>, Person>> qry =\n            cache.queries().createSqlQuery(Person.class, \"salary > ? and salary <= ?\");\n\n        // Execute queries for salary ranges.\n        print(\"People with salaries between 0 and 1000: \", qry.execute(0, 1000).get());\n\n        print(\"People with salaries between 1000 and 2000: \", qry.execute(1000, 2000).get());\n\n        print(\"People with salaries greater than 2000: \", qry.execute(2000, Integer.MAX_VALUE).get());\n    }","id":95583,"modified_method":"/**\n     * Example for SQL queries based on salary ranges.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlQuery() throws IgniteCheckedException {\n        IgniteCache<CacheAffinityKey<UUID>, Person> cache = Ignition.ignite().jcache(CACHE_NAME);\n\n        // SQL clause which selects salaries based on range.\n        String sql = \"salary > ? and salary <= ?\";\n\n        // Execute queries for salary ranges.\n        print(\"People with salaries between 0 and 1000: \",\n            cache.query(sql(Person.class, sql).setArgs(0, 1000)).getAll());\n\n        print(\"People with salaries between 1000 and 2000: \",\n            cache.query(sql(Person.class, sql).setArgs(1000, 2000)).getAll());\n\n        print(\"People with salaries greater than 2000: \",\n            cache.query(sql(Person.class, sql).setArgs(2000, Integer.MAX_VALUE)).getAll());\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Example for TEXT queries using LUCENE-based indexing of people's resumes.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void textQuery() throws IgniteCheckedException {\n        GridCache<CacheAffinityKey<UUID>, Person> cache = Ignition.ignite().cache(CACHE_NAME);\n\n        //  Query for all people with \"Master Degree\" in their resumes.\n        CacheQuery<Map.Entry<CacheAffinityKey<UUID>, Person>> masters =\n            cache.queries().createFullTextQuery(Person.class, \"Master\");\n\n        // Query for all people with \"Bachelor Degree\"in their resumes.\n        CacheQuery<Map.Entry<CacheAffinityKey<UUID>, Person>> bachelors =\n            cache.queries().createFullTextQuery(Person.class, \"Bachelor\");\n\n        print(\"Following people have 'Master Degree' in their resumes: \", masters.execute().get());\n        print(\"Following people have 'Bachelor Degree' in their resumes: \", bachelors.execute().get());\n    }","id":95584,"modified_method":"/**\n     * Example for TEXT queries using LUCENE-based indexing of people's resumes.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void textQuery() throws IgniteCheckedException {\n        IgniteCache<CacheAffinityKey<UUID>, Person> cache = Ignition.ignite().jcache(CACHE_NAME);\n\n        //  Query for all people with \"Master Degree\" in their resumes.\n        QueryCursor<Cache.Entry<CacheAffinityKey<UUID>, Person>> masters =\n            cache.query(text(Person.class, \"Master\"));\n\n        // Query for all people with \"Bachelor Degree\" in their resumes.\n        QueryCursor<Cache.Entry<CacheAffinityKey<UUID>, Person>> bachelors =\n            cache.query(text(Person.class, \"Bachelor\"));\n\n        print(\"Following people have 'Master Degree' in their resumes: \", masters.getAll());\n        print(\"Following people have 'Bachelor Degree' in their resumes: \", bachelors.getAll());\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Populate cache with test data.\n     *\n     * @throws IgniteCheckedException In case of error.\n     * @throws InterruptedException In case of error.\n     */\n    private static void initialize() throws IgniteCheckedException, InterruptedException {\n        GridCache<?, ?> cache = Ignition.ignite().cache(CACHE_NAME);\n\n        // Organization projection.\n        CacheProjection<UUID, Organization> orgCache = cache.projection(UUID.class, Organization.class);\n\n        // Person projection.\n        CacheProjection<CacheAffinityKey<UUID>, Person> personCache =\n            cache.projection(CacheAffinityKey.class, Person.class);\n\n        // Organizations.\n        Organization org1 = new Organization(\"Ignite\");\n        Organization org2 = new Organization(\"Other\");\n\n        // People.\n        Person p1 = new Person(org1, \"John\", \"Doe\", 2000, \"John Doe has Master Degree.\");\n        Person p2 = new Person(org1, \"Jane\", \"Doe\", 1000, \"Jane Doe has Bachelor Degree.\");\n        Person p3 = new Person(org2, \"John\", \"Smith\", 1000, \"John Smith has Bachelor Degree.\");\n        Person p4 = new Person(org2, \"Jane\", \"Smith\", 2000, \"Jane Smith has Master Degree.\");\n\n        orgCache.put(org1.id, org1);\n        orgCache.put(org2.id, org2);\n\n        // Note that in this example we use custom affinity key for Person objects\n        // to ensure that all persons are collocated with their organizations.\n        personCache.put(p1.key(), p1);\n        personCache.put(p2.key(), p2);\n        personCache.put(p3.key(), p3);\n        personCache.put(p4.key(), p4);\n\n        // Wait 1 second to be sure that all nodes processed put requests.\n        Thread.sleep(1000);\n    }","id":95585,"modified_method":"/**\n     * Populate cache with test data.\n     *\n     * @throws IgniteCheckedException In case of error.\n     * @throws InterruptedException In case of error.\n     */\n    private static void initialize() throws IgniteCheckedException, InterruptedException {\n        IgniteCache cache = Ignition.ignite().jcache(CACHE_NAME);\n\n        // Organizations.\n        Organization org1 = new Organization(\"GridGain\");\n        Organization org2 = new Organization(\"Other\");\n\n        // People.\n        Person p1 = new Person(org1, \"John\", \"Doe\", 2000, \"John Doe has Master Degree.\");\n        Person p2 = new Person(org1, \"Jane\", \"Doe\", 1000, \"Jane Doe has Bachelor Degree.\");\n        Person p3 = new Person(org2, \"John\", \"Smith\", 1000, \"John Smith has Bachelor Degree.\");\n        Person p4 = new Person(org2, \"Jane\", \"Smith\", 2000, \"Jane Smith has Master Degree.\");\n\n        cache.put(org1.id, org1);\n        cache.put(org2.id, org2);\n\n        // Note that in this example we use custom affinity key for Person objects\n        // to ensure that all persons are collocated with their organizations.\n        cache.put(p1.key(), p1);\n        cache.put(p2.key(), p2);\n        cache.put(p3.key(), p3);\n        cache.put(p4.key(), p4);\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Example for SQL queries based on all employees working for a specific organization.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlQueryWithJoin() throws IgniteCheckedException {\n        GridCache<CacheAffinityKey<UUID>, Person> cache = Ignition.ignite().cache(CACHE_NAME);\n\n        // Create query which joins on 2 types to select people for a specific organization.\n        CacheQuery<Map.Entry<CacheAffinityKey<UUID>, Person>> qry =\n            cache.queries().createSqlQuery(Person.class, \"from Person, Organization \" +\n                \"where Person.orgId = Organization.id \" +\n                \"and lower(Organization.name) = lower(?)\");\n\n        // Execute queries for find employees for different organizations.\n        print(\"Following people are 'Ignite' employees: \", qry.execute(\"Ignite\").get());\n        print(\"Following people are 'Other' employees: \", qry.execute(\"Other\").get());\n    }","id":95586,"modified_method":"/**\n     * Example for SQL queries based on all employees working for a specific organization.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlQueryWithJoin() throws IgniteCheckedException {\n        IgniteCache<CacheAffinityKey<UUID>, Person> cache = Ignition.ignite().jcache(CACHE_NAME);\n\n        // SQL clause query which joins on 2 types to select people for a specific organization.\n        String joinSql =\n            \"from Person, Organization \"\n            + \"where Person.orgId = Organization.id \"\n            + \"and lower(Organization.name) = lower(?)\";\n\n        // Execute queries for find employees for different organizations.\n        print(\"Following people are 'GridGain' employees: \",\n            cache.query(sql(Person.class, joinSql).setArgs(\"GridGain\")).getAll());\n        print(\"Following people are 'Other' employees: \",\n            cache.query(sql(Person.class, joinSql).setArgs(\"Other\")).getAll());\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws Exception If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite ignite = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache query example started.\");\n\n            // Clean up caches on all nodes before run.\n            ignite.jcache(CACHE_NAME).clear();\n\n            // Populate cache.\n            initialize();\n\n            // Example for SQL-based querying employees based on salary ranges.\n            sqlQuery();\n\n            // Example for SQL-based querying employees for a given organization (includes SQL join).\n            sqlQueryWithJoin();\n\n            // Example for TEXT-based querying for a given string in peoples resumes.\n            textQuery();\n\n            // Example for SQL-based querying with custom remote and local reducers\n            // to calculate average salary among all employees within a company.\n            sqlQueryWithReducers();\n\n            // Example for SQL-based querying with custom remote transformer to make sure\n            // that only required data without any overhead is returned to caller.\n            sqlQueryWithTransformer();\n\n            // Example for SQL-based fields queries that return only required\n            // fields instead of whole key-value pairs.\n            sqlFieldsQuery();\n\n            // Example for SQL-based fields queries that uses joins.\n            sqlFieldsQueryWithJoin();\n\n            print(\"Cache query example finished.\");\n        }\n    }","id":95587,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws Exception If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite ignite = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache query example started.\");\n\n            // Clean up caches on all nodes before run.\n            ignite.jcache(CACHE_NAME).removeAll();\n\n            // Populate cache.\n            initialize();\n\n            // Example for SQL-based querying employees based on salary ranges.\n            sqlQuery();\n\n            // Example for SQL-based querying employees for a given organization (includes SQL join).\n            sqlQueryWithJoin();\n\n            // Example for TEXT-based querying for a given string in peoples resumes.\n            textQuery();\n\n            // Example for SQL-based fields queries that return only required\n            // fields instead of whole key-value pairs.\n            sqlFieldsQuery();\n\n            // Example for SQL-based fields queries that uses joins.\n            sqlFieldsQueryWithJoin();\n\n            print(\"Cache query example finished.\");\n        }\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Example for SQL-based fields queries that return only required\n     * fields instead of whole key-value pairs.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlFieldsQuery() throws IgniteCheckedException {\n        GridCache<?, ?> cache = Ignition.ignite().cache(CACHE_NAME);\n\n        // Create query to get names of all employees.\n        CacheQuery<List<?>> qry1 = cache.queries().createSqlFieldsQuery(\n            \"select concat(firstName, ' ', lastName) from Person\");\n\n        // Execute query to get collection of rows. In this particular\n        // case each row will have one element with full name of an employees.\n        Collection<List<?>> res = qry1.execute().get();\n\n        // Print names.\n        print(\"Names of all employees:\", res);\n    }","id":95588,"modified_method":"/**\n     * Example for SQL-based fields queries that return only required\n     * fields instead of whole key-value pairs.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlFieldsQuery() throws IgniteCheckedException {\n        IgniteCache<?, ?> cache = Ignition.ignite().jcache(CACHE_NAME);\n\n        // Create query to get names of all employees.\n        QueryCursor<List<?>> cursor = cache.queryFields(\n                sql(\"select concat(firstName, ' ', lastName) from Person\"));\n\n        // Execute query to get collection of rows. In this particular\n        // case each row will have one element with full name of an employees.\n        List<List<?>> res = cursor.getAll();\n\n        // Print names.\n        print(\"Names of all employees:\", res);\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Example for SQL-based fields queries that return only required\n     * fields instead of whole key-value pairs.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlFieldsQueryWithJoin() throws IgniteCheckedException {\n        GridCache<?, ?> cache = Ignition.ignite().cache(CACHE_NAME);\n\n        // Create query to get names of all employees.\n        CacheQuery<List<?>> qry1 = cache.queries().createSqlFieldsQuery(\n            \"select concat(firstName, ' ', lastName), Organization.name from Person, Organization where \" +\n                \"Person.orgId = Organization.id\");\n\n        // Execute query to get collection of rows. In this particular\n        // case each row will have one element with full name of an employees.\n        Collection<List<?>> res = qry1.execute().get();\n\n        // Print persons' names and organizations' names.\n        print(\"Names of all employees and organizations they belong to:\", res);\n    }","id":95589,"modified_method":"/**\n     * Example for SQL-based fields queries that return only required\n     * fields instead of whole key-value pairs.\n     *\n     * @throws IgniteCheckedException In case of error.\n     */\n    private static void sqlFieldsQueryWithJoin() throws IgniteCheckedException {\n        IgniteCache<?, ?> cache = Ignition.ignite().jcache(CACHE_NAME);\n\n        // Execute query to get names of all employees.\n        QueryCursor<List<?>> cursor = cache.queryFields(sql(\"select concat(firstName, ' ', lastName), \"\n                + \"Organization.name from Person, Organization where \"\n                + \"Person.orgId = Organization.id\"));\n\n        // In this particular case each row will have one element with full name of an employees.\n        List<List<?>> res = cursor.getAll();\n\n        // Print persons' names and organizations' names.\n        print(\"Names of all employees and organizations they belong to:\", res);\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Print query results.\n     *\n     * @param msg Initial message.\n     * @param res Results to print.\n     */\n    private static <V> void printQueryResults(String msg, Iterable<Map.Entry<Integer, V>> res) {\n        System.out.println(msg);\n\n        for (Map.Entry<?, ?> e : res)\n            System.out.println(\"    \" + e.getValue().toString());\n    }","id":95590,"modified_method":"/**\n     * Print query results.\n     *\n     * @param msg Initial message.\n     * @param res Results to print.\n     */\n    private static <V> void printQueryResults(String msg, Iterable<Cache.Entry<Integer, V>> res) {\n        System.out.println(msg);\n\n        for (Cache.Entry<?, ?> e : res)\n            System.out.println(\"    \" + e.getValue().toString());\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Query all purchases made at a specific store for 3 specific products.\n     * This query uses cross-cache joins between {@link DimStore}, {@link DimProduct}\n     * objects stored in {@code 'replicated'} cache and {@link FactPurchase} objects\n     * stored in {@code 'partitioned'} cache.\n     *\n     * @throws IgniteException If failed.\n     */\n    private static void queryProductPurchases() throws IgniteCheckedException {\n        GridCache<Integer, Object> dimCache = Ignition.ignite().cache(REPLICATED_CACHE_NAME);\n        GridCache<Integer, FactPurchase> factCache = Ignition.ignite().cache(PARTITIONED_CACHE_NAME);\n\n        CacheProjection<Integer, DimProduct> prods = dimCache.projection(Integer.class, DimProduct.class);\n\n        // All purchases for certain product made at store2.\n        // =================================================\n\n        DimProduct p1 = rand(prods.values());\n        DimProduct p2 = rand(prods.values());\n        DimProduct p3 = rand(prods.values());\n\n        System.out.println(\"IDs of products [p1=\" + p1.getId() + \", p2=\" + p2.getId() + \", p3=\" + p3.getId() + ']');\n\n        // Create cross cache query to get all purchases made at store2\n        // for specified products.\n        CacheQuery<Map.Entry<Integer, FactPurchase>> prodPurchases = factCache.queries().createSqlQuery(\n            FactPurchase.class,\n            \"from \\\"replicated\\\".DimStore, \\\"replicated\\\".DimProduct, \\\"partitioned\\\".FactPurchase \" +\n                \"where DimStore.id=FactPurchase.storeId and DimProduct.id=FactPurchase.productId \" +\n                \"and DimStore.name=? and DimProduct.id in(?, ?, ?)\");\n\n        printQueryResults(\"All purchases made at store2 for 3 specific products:\",\n            prodPurchases.execute(\"Store2\", p1.getId(), p2.getId(), p3.getId()).get());\n    }","id":95591,"modified_method":"/**\n     * Query all purchases made at a specific store for 3 specific products.\n     * This query uses cross-cache joins between {@link DimStore}, {@link DimProduct}\n     * objects stored in {@code 'replicated'} cache and {@link FactPurchase} objects\n     * stored in {@code 'partitioned'} cache.\n     *\n     * @throws IgniteException If failed.\n     */\n    private static void queryProductPurchases() throws IgniteCheckedException {\n        IgniteCache<Integer, FactPurchase> factCache = Ignition.ignite().jcache(PARTITIONED_CACHE_NAME);\n\n        // All purchases for certain product made at store2.\n        // =================================================\n\n        DimProduct p1 = rand(dataProduct.values());\n        DimProduct p2 = rand(dataProduct.values());\n        DimProduct p3 = rand(dataProduct.values());\n\n        System.out.println(\"IDs of products [p1=\" + p1.getId() + \", p2=\" + p2.getId() + \", p3=\" + p3.getId() + ']');\n\n        // Create cross cache query to get all purchases made at store2\n        // for specified products.\n        QueryCursor<Cache.Entry<Integer, FactPurchase>> prodPurchases = factCache.query(sql(\n            FactPurchase.class,\n            \"from \\\"replicated\\\".DimStore, \\\"replicated\\\".DimProduct, \\\"partitioned\\\".FactPurchase \"\n                + \"where DimStore.id=FactPurchase.storeId and DimProduct.id=FactPurchase.productId \"\n                + \"and DimStore.name=? and DimProduct.id in(?, ?, ?)\")\n            .setArgs(\"Store2\", p1.getId(), p2.getId(), p3.getId()));\n\n        printQueryResults(\"All purchases made at store2 for 3 specific products:\", prodPurchases.getAll());\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Query all purchases made at a specific store. This query uses cross-cache joins\n     * between {@link DimStore} objects stored in {@code 'replicated'} cache and\n     * {@link FactPurchase} objects stored in {@code 'partitioned'} cache.\n     *\n     * @throws IgniteException If failed.\n     */\n    private static void queryStorePurchases() throws IgniteCheckedException {\n        GridCache<Integer, FactPurchase> factCache = Ignition.ignite().cache(PARTITIONED_CACHE_NAME);\n\n        // All purchases for store1.\n        // ========================\n\n        // Create cross cache query to get all purchases made at store1.\n        CacheQuery<Map.Entry<Integer, FactPurchase>> storePurchases = factCache.queries().createSqlQuery(\n            FactPurchase.class,\n            \"from \\\"replicated\\\".DimStore, \\\"partitioned\\\".FactPurchase \" +\n                \"where DimStore.id=FactPurchase.storeId and DimStore.name=?\");\n\n        printQueryResults(\"All purchases made at store1:\",\n            storePurchases.execute(\"Store1\").get());\n    }","id":95592,"modified_method":"/**\n     * Query all purchases made at a specific store. This query uses cross-cache joins\n     * between {@link DimStore} objects stored in {@code 'replicated'} cache and\n     * {@link FactPurchase} objects stored in {@code 'partitioned'} cache.\n     *\n     * @throws IgniteException If failed.\n     */\n    private static void queryStorePurchases() throws IgniteCheckedException {\n        IgniteCache<Integer, FactPurchase> factCache = Ignition.ignite().jcache(PARTITIONED_CACHE_NAME);\n\n        // All purchases for store1.\n        // ========================\n\n        // Create cross cache query to get all purchases made at store1.\n        QueryCursor<Cache.Entry<Integer, FactPurchase>> storePurchases = factCache.query(sql(\n            FactPurchase.class,\n            \"from \\\"replicated\\\".DimStore, \\\"partitioned\\\".FactPurchase \"\n                + \"where DimStore.id=FactPurchase.storeId and DimStore.name=?\").setArgs(\"Store1\"));\n\n        printQueryResults(\"All purchases made at store1:\", storePurchases.getAll());\n    }","commit_id":"eef98c23faa640eceeaafaa4fe6bfeb6ce650274","url":"https://github.com/apache/ignite"},{"original_method":"public static CompositeClassPathItem createClassPathItem(Iterable<String> classPath, String requestor) {\n    CompositeClassPathItem classPathItem = new CompositeClassPathItem(false);\n\n    for (String path : classPath) {\n      try {\n        IClassPathItem pathItem = ClassPathFactory.getInstance().createFromPath(path, requestor);\n        classPathItem.add(pathItem);\n      } catch (IOException e) {\n        LOG.error(e.getMessage());\n      }\n    }\n\n    return classPathItem;\n  }","id":95593,"modified_method":"/**\n   *\n   * @param classPath a sequence of paths to classes\n   * @param requestor debug info describing the caller of this method\n   * @return constructed CompositeClassPathItem\n   */\n  public static CompositeClassPathItem createClassPathItem(Iterable<String> classPath, String requestor) {\n    CompositeClassPathItem classPathItem = new CompositeClassPathItem(false);\n\n    for (String path : classPath) {\n      try {\n        IClassPathItem pathItem = ClassPathFactory.getInstance().createFromPath(path, requestor);\n        classPathItem.add(pathItem);\n      } catch (IOException e) {\n        LOG.error(e.getMessage());\n      }\n    }\n\n    return classPathItem;\n  }","commit_id":"22323bf4af8e0f0257a56189cfd13faca3d44267","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public URL getResource(SModule module, String resourceName) {\n    ModuleDescriptor descriptor = ((AbstractModule) module).getModuleDescriptor();\n    if (SModuleOperations.isCompileInMps(module) || (descriptor != null && !(descriptor.getAdditionalJavaStubPaths().isEmpty()))) {\n      return JavaModuleOperations.createClassPathItem(module.getFacet(JavaModuleFacet.class).getClassPath(), JavaTraceInfoResourceProvider.class.getName()).getResource(resourceName);\n    }\n    if (SModuleOperations.isCompileInIdea(module)) {\n      return CommonPaths.getMPSClassPath().getResource(resourceName);\n    }\n    return null;\n  }","id":95594,"modified_method":"@Override\n  public URL getResource(@NotNull SModule module, String resourceName) {\n    JavaModuleFacet javaModuleFacet = module.getFacet(JavaModuleFacet.class);\n    if (javaModuleFacet != null) {\n      CompositeClassPathItem paths = JavaModuleOperations.createClassPathItem(javaModuleFacet.getClassPath(), JavaTraceInfoResourceProvider.class.getName());\n      if (!javaModuleFacet.isCompileInMps()) {\n        paths.add(CommonPaths.getMPSClassPath()); // all mps core jars (however no plugins)\n      }\n      return paths.getResource(resourceName);\n    }\n    return null;\n  }","commit_id":"22323bf4af8e0f0257a56189cfd13faca3d44267","url":"https://github.com/JetBrains/MPS"},{"original_method":"public URL getResource(SModule module, String resourceName);","id":95595,"modified_method":"/**\n     * Provider returns url to the requested trace.info resource file with respect to the particular module\n     * @param module which is supposed to own the requested trace.info resource file\n     * @param resourceName full path to the trace.info resource file\n     * @return null if the trace.info could not be found\n     */\n    @Nullable URL getResource(@NotNull SModule module, String resourceName);","commit_id":"22323bf4af8e0f0257a56189cfd13faca3d44267","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IJob createJob() {\n      return new IJob.Stub() {\n        @Override\n        public IResult execute(final Iterable<IResource> rawInput, final IJobMonitor monitor, final IPropertiesAccessor pa, @NotNull final ProgressMonitor progressMonitor) {\n          Iterable<IResource> _output_wf1ya0_a0b = null;\n          final Iterable<TResource> input = (Iterable<TResource>) (Iterable) rawInput;\n          switch (0) {\n            case 0:\n              if (Boolean.TRUE.equals(pa.global().properties(new ITarget.Name(\"jetbrains.mps.baseLanguage.JavaCompile.compile\"), JavaCompile_Facet.Target_compile.Parameters.class).skipCompilation())) {\n                _output_wf1ya0_a0b = Sequence.fromIterable(_output_wf1ya0_a0b).concat(Sequence.fromIterable(input));\n                return new IResult.SUCCESS(_output_wf1ya0_a0b);\n              }\n              if (pa.global().properties(Target_auxCompile.this.getName(), JavaCompile_Facet.Target_auxCompile.Parameters.class).skipAuxCompile() != null && pa.global().properties(Target_auxCompile.this.getName(), JavaCompile_Facet.Target_auxCompile.Parameters.class).skipAuxCompile()) {\n                return new IResult.SUCCESS(_output_wf1ya0_a0b);\n              }\n              if (Sequence.fromIterable(input).any(new IWhereFilter<TResource>() {\n                public boolean accept(TResource it) {\n                  return it.module() == null;\n                }\n              })) {\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              // collect modules to compile \n              Iterable<TResource> toCompile = Sequence.fromIterable(input).where(new IWhereFilter<TResource>() {\n                public boolean accept(TResource it) {\n                  JavaModuleFacet facet = it.module().getFacet(JavaModuleFacet.class);\n                  return facet != null && !(facet.isCompileInMPS());\n                }\n              });\n\n              // compile modules \n              if (Sequence.fromIterable(toCompile).isEmpty()) {\n                return new IResult.SUCCESS(_output_wf1ya0_a0b);\n              }\n              if (MPSCore.getInstance().isTestMode()) {\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              IdeaJavaCompiler compiler = pa.global().properties(new ITarget.Name(\"jetbrains.mps.lang.core.Generate.checkParameters\"), Variables.class).project().getComponent(IdeaJavaCompiler.class);\n              if (compiler == null || !(compiler.isValid())) {\n                monitor.reportFeedback(new IFeedback.ERROR(String.valueOf(\"IntelliJ IDEA is required for compilation\")));\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              monitor.currentProgress().beginWork(\"Compiling in IntelliJ IDEA\", 1, monitor.currentProgress().workLeft());\n\n              monitor.currentProgress().advanceWork(\"Compiling in IntelliJ IDEA\", 1);\n              MPSCompilationResult cr = compiler.compileModules(Sequence.fromIterable(toCompile).select(new ISelector<TResource, IModule>() {\n                public IModule select(TResource it) {\n                  return it.module();\n                }\n              }).toGenericArray(IModule.class));\n\n              // analyse results \n              if (cr != null) {\n                for (IMessage msg : cr.getMessages()) {\n                  monitor.reportFeedback(new IFeedback.MESSAGE(msg));\n                }\n              }\n              if (cr == null || !(cr.isOk())) {\n                if (cr != null) {\n                  if (cr.getErrors() > 0) {\n                    monitor.reportFeedback(new IFeedback.ERROR(String.valueOf(cr)));\n                  } else if (cr.getWarnings() > 0) {\n                    monitor.reportFeedback(new IFeedback.WARNING(String.valueOf(cr)));\n                  } else {\n                    monitor.reportFeedback(new IFeedback.INFORMATION(String.valueOf(cr)));\n                  }\n                }\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              _output_wf1ya0_a0b = Sequence.fromIterable(_output_wf1ya0_a0b).concat(Sequence.fromIterable(toCompile));\n              monitor.currentProgress().finishWork(\"Compiling in IntelliJ IDEA\");\n            default:\n              return new IResult.SUCCESS(_output_wf1ya0_a0b);\n          }\n        }\n      };\n    }","id":95596,"modified_method":"public IJob createJob() {\n      return new IJob.Stub() {\n        @Override\n        public IResult execute(final Iterable<IResource> rawInput, final IJobMonitor monitor, final IPropertiesAccessor pa, @NotNull final ProgressMonitor progressMonitor) {\n          Iterable<IResource> _output_wf1ya0_a0b = null;\n          final Iterable<TResource> input = (Iterable<TResource>) (Iterable) rawInput;\n          switch (0) {\n            case 0:\n              if (Boolean.TRUE.equals(pa.global().properties(new ITarget.Name(\"jetbrains.mps.baseLanguage.JavaCompile.compile\"), JavaCompile_Facet.Target_compile.Parameters.class).skipCompilation())) {\n                _output_wf1ya0_a0b = Sequence.fromIterable(_output_wf1ya0_a0b).concat(Sequence.fromIterable(input));\n                return new IResult.SUCCESS(_output_wf1ya0_a0b);\n              }\n              if (pa.global().properties(Target_auxCompile.this.getName(), JavaCompile_Facet.Target_auxCompile.Parameters.class).skipAuxCompile() != null && pa.global().properties(Target_auxCompile.this.getName(), JavaCompile_Facet.Target_auxCompile.Parameters.class).skipAuxCompile()) {\n                return new IResult.SUCCESS(_output_wf1ya0_a0b);\n              }\n              if (Sequence.fromIterable(input).any(new IWhereFilter<TResource>() {\n                public boolean accept(TResource it) {\n                  return it.module() == null;\n                }\n              })) {\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              // collect modules to compile \n              Iterable<TResource> toCompile = Sequence.fromIterable(input).where(new IWhereFilter<TResource>() {\n                public boolean accept(TResource it) {\n                  return SModuleOperations.isCompileInIdea(it.module());\n                }\n              });\n\n              // compile modules \n              if (Sequence.fromIterable(toCompile).isEmpty()) {\n                return new IResult.SUCCESS(_output_wf1ya0_a0b);\n              }\n              if (MPSCore.getInstance().isTestMode()) {\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              IdeaJavaCompiler compiler = pa.global().properties(new ITarget.Name(\"jetbrains.mps.lang.core.Generate.checkParameters\"), Variables.class).project().getComponent(IdeaJavaCompiler.class);\n              if (compiler == null || !(compiler.isValid())) {\n                monitor.reportFeedback(new IFeedback.ERROR(String.valueOf(\"IntelliJ IDEA is required for compilation\")));\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              monitor.currentProgress().beginWork(\"Compiling in IntelliJ IDEA\", 1, monitor.currentProgress().workLeft());\n\n              monitor.currentProgress().advanceWork(\"Compiling in IntelliJ IDEA\", 1);\n              MPSCompilationResult cr = compiler.compileModules(Sequence.fromIterable(toCompile).select(new ISelector<TResource, IModule>() {\n                public IModule select(TResource it) {\n                  return it.module();\n                }\n              }).toGenericArray(IModule.class));\n\n              // analyse results \n              if (cr != null) {\n                for (IMessage msg : cr.getMessages()) {\n                  monitor.reportFeedback(new IFeedback.MESSAGE(msg));\n                }\n              }\n              if (cr == null || !(cr.isOk())) {\n                if (cr != null) {\n                  if (cr.getErrors() > 0) {\n                    monitor.reportFeedback(new IFeedback.ERROR(String.valueOf(cr)));\n                  } else if (cr.getWarnings() > 0) {\n                    monitor.reportFeedback(new IFeedback.WARNING(String.valueOf(cr)));\n                  } else {\n                    monitor.reportFeedback(new IFeedback.INFORMATION(String.valueOf(cr)));\n                  }\n                }\n                return new IResult.FAILURE(_output_wf1ya0_a0b);\n              }\n\n              _output_wf1ya0_a0b = Sequence.fromIterable(_output_wf1ya0_a0b).concat(Sequence.fromIterable(toCompile));\n              monitor.currentProgress().finishWork(\"Compiling in IntelliJ IDEA\");\n            default:\n              return new IResult.SUCCESS(_output_wf1ya0_a0b);\n          }\n        }\n      };\n    }","commit_id":"daec63ebbb2480db96150a080188fbe8aac1522d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IJob createJob() {\n      return new IJob.Stub() {\n        @Override\n        public IResult execute(final Iterable<IResource> rawInput, final IJobMonitor monitor, final IPropertiesAccessor pa, @NotNull final ProgressMonitor progressMonitor) {\n          Iterable<IResource> _output_wf1ya0_a0a = null;\n          final Iterable<TResource> input = (Iterable<TResource>) (Iterable) rawInput;\n          switch (0) {\n            case 0:\n              if (Boolean.TRUE.equals(pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).skipCompilation())) {\n                _output_wf1ya0_a0a = Sequence.fromIterable(_output_wf1ya0_a0a).concat(Sequence.fromIterable(input));\n                return new IResult.SUCCESS(_output_wf1ya0_a0a);\n              }\n              pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).compiledAnything(false);\n              final Set<SModule> toCompile = SetSequence.fromSetWithValues(new HashSet<SModule>(), Sequence.fromIterable(input).select(new ISelector<TResource, IModule>() {\n                public IModule select(TResource it) {\n                  return it.module();\n                }\n              }).where(new IWhereFilter<IModule>() {\n                public boolean accept(IModule it) {\n                  JavaModuleFacet facet = check_wf1ya0_a0a0a0a0a0a2a0a0(it);\n                  return facet != null && facet.isCompileInMPS();\n                }\n              }).distinct());\n              if ((int) SetSequence.fromSet(toCompile).count() == 0) {\n                return new IResult.SUCCESS(_output_wf1ya0_a0a);\n              }\n              final Wrappers._T<MPSCompilationResult> cr = new Wrappers._T<MPSCompilationResult>();\n              ModelAccess.instance().runReadAction(new Runnable() {\n                public void run() {\n                  cr.value = new ModuleMaker().make(toCompile, progressMonitor);\n                }\n              });\n              if (cr.value != null) {\n                pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).compiledAnything(pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).compiledAnything() || cr.value.isCompiledAnything());\n                for (IMessage msg : cr.value.getMessages()) {\n                  monitor.reportFeedback(new IFeedback.MESSAGE(msg));\n                }\n              }\n              if (cr.value == null || !(cr.value.isOk())) {\n                if (cr.value != null) {\n                  if (cr.value.getErrors() > 0) {\n                    monitor.reportFeedback(new IFeedback.ERROR(String.valueOf(cr.value)));\n                  } else if (cr.value.getWarnings() > 0) {\n                    monitor.reportFeedback(new IFeedback.WARNING(String.valueOf(cr.value)));\n                  } else {\n                    monitor.reportFeedback(new IFeedback.INFORMATION(String.valueOf(cr.value)));\n                  }\n                }\n                return new IResult.FAILURE(_output_wf1ya0_a0a);\n              }\n\n              for (TResource tres : Sequence.fromIterable(input)) {\n                if (tres.module() == null) {\n                  return new IResult.FAILURE(_output_wf1ya0_a0a);\n                }\n                if (SetSequence.fromSet(toCompile).contains(tres.module())) {\n                  _output_wf1ya0_a0a = Sequence.fromIterable(_output_wf1ya0_a0a).concat(Sequence.fromIterable(Sequence.<IResource>singleton(tres)));\n                }\n              }\n            default:\n              return new IResult.SUCCESS(_output_wf1ya0_a0a);\n          }\n        }\n      };\n    }","id":95597,"modified_method":"public IJob createJob() {\n      return new IJob.Stub() {\n        @Override\n        public IResult execute(final Iterable<IResource> rawInput, final IJobMonitor monitor, final IPropertiesAccessor pa, @NotNull final ProgressMonitor progressMonitor) {\n          Iterable<IResource> _output_wf1ya0_a0a = null;\n          final Iterable<TResource> input = (Iterable<TResource>) (Iterable) rawInput;\n          switch (0) {\n            case 0:\n              if (Boolean.TRUE.equals(pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).skipCompilation())) {\n                _output_wf1ya0_a0a = Sequence.fromIterable(_output_wf1ya0_a0a).concat(Sequence.fromIterable(input));\n                return new IResult.SUCCESS(_output_wf1ya0_a0a);\n              }\n              pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).compiledAnything(false);\n              final Set<SModule> toCompile = SetSequence.fromSetWithValues(new HashSet<SModule>(), Sequence.fromIterable(input).select(new ISelector<TResource, IModule>() {\n                public IModule select(TResource it) {\n                  return it.module();\n                }\n              }).where(new IWhereFilter<IModule>() {\n                public boolean accept(IModule it) {\n                  return SModuleOperations.isCompileInMps(it);\n                }\n              }).distinct());\n              if ((int) SetSequence.fromSet(toCompile).count() == 0) {\n                return new IResult.SUCCESS(_output_wf1ya0_a0a);\n              }\n              final Wrappers._T<MPSCompilationResult> cr = new Wrappers._T<MPSCompilationResult>();\n              ModelAccess.instance().runReadAction(new Runnable() {\n                public void run() {\n                  cr.value = new ModuleMaker().make(toCompile, progressMonitor);\n                }\n              });\n              if (cr.value != null) {\n                pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).compiledAnything(pa.global().properties(Target_compile.this.getName(), JavaCompile_Facet.Target_compile.Parameters.class).compiledAnything() || cr.value.isCompiledAnything());\n                for (IMessage msg : cr.value.getMessages()) {\n                  monitor.reportFeedback(new IFeedback.MESSAGE(msg));\n                }\n              }\n              if (cr.value == null || !(cr.value.isOk())) {\n                if (cr.value != null) {\n                  if (cr.value.getErrors() > 0) {\n                    monitor.reportFeedback(new IFeedback.ERROR(String.valueOf(cr.value)));\n                  } else if (cr.value.getWarnings() > 0) {\n                    monitor.reportFeedback(new IFeedback.WARNING(String.valueOf(cr.value)));\n                  } else {\n                    monitor.reportFeedback(new IFeedback.INFORMATION(String.valueOf(cr.value)));\n                  }\n                }\n                return new IResult.FAILURE(_output_wf1ya0_a0a);\n              }\n\n              for (TResource tres : Sequence.fromIterable(input)) {\n                if (tres.module() == null) {\n                  return new IResult.FAILURE(_output_wf1ya0_a0a);\n                }\n                if (SetSequence.fromSet(toCompile).contains(tres.module())) {\n                  _output_wf1ya0_a0a = Sequence.fromIterable(_output_wf1ya0_a0a).concat(Sequence.fromIterable(Sequence.<IResource>singleton(tres)));\n                }\n              }\n            default:\n              return new IResult.SUCCESS(_output_wf1ya0_a0a);\n          }\n        }\n      };\n    }","commit_id":"daec63ebbb2480db96150a080188fbe8aac1522d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public URL getResource(IModule module, String resourceName) {\n    JavaModuleFacet facet = module.getFacet(JavaModuleFacet.class);\n    if (facet == null) {\n      return null;\n    }\n\n    IClassPathItem classPathItem;\n    ModuleDescriptor descriptor = module.getModuleDescriptor();\n    if (facet.isCompileInMps() || descriptor != null && !(descriptor.getAdditionalJavaStubPaths().isEmpty())) {\n      classPathItem = JavaModuleOperations.createClassPathItem(facet.getClassPath(), JavaTraceInfoResourceProvider.class.getName());\n    } else {\n      // todo: looks wrong. just go to classes gen in this case too \n      classPathItem = CommonPaths.getMPSClassPath();\n    }\n    if (classPathItem == null) {\n      return null;\n    }\n    return classPathItem.getResource(resourceName);\n  }","id":95598,"modified_method":"public URL getResource(IModule module, String resourceName) {\n    ModuleDescriptor descriptor = module.getModuleDescriptor();\n    if (SModuleOperations.isCompileInMps(module) || (descriptor != null && !(descriptor.getAdditionalJavaStubPaths().isEmpty()))) {\n      return JavaModuleOperations.createClassPathItem(module.getFacet(JavaModuleFacet.class).getClassPath(), JavaTraceInfoResourceProvider.class.getName()).getResource(resourceName);\n    }\n    if (SModuleOperations.isCompileInIdea(module)) {\n      return CommonPaths.getMPSClassPath().getResource(resourceName);\n    }\n    return null;\n  }","commit_id":"daec63ebbb2480db96150a080188fbe8aac1522d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void testAdditionalInstance() throws Throwable {\n        logger.info(\"testAdditionalInstance: start\");\n        assertNotNull(instance1);\n        assertNotNull(instance2);\n\n        assertEquals(instance1.getSlingId(), instance1.getClusterViewService()\n                .getSlingId());\n        assertEquals(instance2.getSlingId(), instance2.getClusterViewService()\n                .getSlingId());\n\n        try{\n            instance1.getClusterViewService().getLocalClusterView();\n            fail(\"should complain\");\n        } catch(UndefinedClusterViewException e) {\n            // ok\n        }\n        try{\n            instance2.getClusterViewService().getLocalClusterView();\n            fail(\"should complain\");\n        } catch(UndefinedClusterViewException e) {\n            // ok\n        }\n\n        instance1.heartbeatsAndCheckView();\n        instance2.heartbeatsAndCheckView();\n\n        instance1.dumpRepo();\n        logger.info(\"testAdditionalInstance: 1st 2s sleep\");\n        Thread.sleep(2000);\n\n        instance1.heartbeatsAndCheckView();\n        instance2.heartbeatsAndCheckView();\n        logger.info(\"testAdditionalInstance: 2nd 2s sleep\");\n        Thread.sleep(2000);\n\n        instance1.dumpRepo();\n        String clusterId1 = instance1.getClusterViewService().getLocalClusterView()\n                .getId();\n        logger.info(\"clusterId1=\" + clusterId1);\n        String clusterId2 = instance2.getClusterViewService().getLocalClusterView()\n                .getId();\n        logger.info(\"clusterId2=\" + clusterId2);\n        assertEquals(clusterId1, clusterId2);\n\n        assertEquals(2, instance1.getClusterViewService().getLocalClusterView()\n                .getInstances().size());\n        assertEquals(2, instance2.getClusterViewService().getLocalClusterView()\n                .getInstances().size());\n\n        AssertingTopologyEventListener assertingTopologyEventListener = new AssertingTopologyEventListener();\n        assertingTopologyEventListener.addExpected(Type.TOPOLOGY_INIT);\n        assertEquals(1, assertingTopologyEventListener.getRemainingExpectedCount());\n        instance1.bindTopologyEventListener(assertingTopologyEventListener);\n        Thread.sleep(500); // SLING-4755: async event sending requires some minimal wait time nowadays\n        assertEquals(0, assertingTopologyEventListener.getRemainingExpectedCount());\n\n        // startup instance 3\n        AcceptsMultiple acceptsMultiple = new AcceptsMultiple(\n                Type.TOPOLOGY_CHANGING, Type.TOPOLOGY_CHANGED);\n        assertingTopologyEventListener.addExpected(acceptsMultiple);\n        assertingTopologyEventListener.addExpected(acceptsMultiple);\n        instance3 = newBuilder().setDebugName(\"thirdInstance\")\n                .useRepositoryOf(instance1)\n                .build();\n        instance1.heartbeatsAndCheckView();\n        instance2.heartbeatsAndCheckView();\n        instance3.heartbeatsAndCheckView();\n        logger.info(\"testAdditionalInstance: 3rd 2s sleep\");\n        Thread.sleep(2000);\n        instance1.heartbeatsAndCheckView();\n        instance2.heartbeatsAndCheckView();\n        instance3.heartbeatsAndCheckView();\n        logger.info(\"testAdditionalInstance: 4th 2s sleep\");\n        Thread.sleep(3000);\n        assertEquals(1, acceptsMultiple.getEventCnt(Type.TOPOLOGY_CHANGING));\n        assertEquals(1, acceptsMultiple.getEventCnt(Type.TOPOLOGY_CHANGED));\n        logger.info(\"testAdditionalInstance: end\");\n    }","id":95599,"modified_method":"@Test\n    public void testAdditionalInstance() throws Throwable {\n        logger.info(\"testAdditionalInstance: start\");\n        assertNotNull(instance1);\n        assertNotNull(instance2);\n\n        assertEquals(instance1.getSlingId(), instance1.getClusterViewService()\n                .getSlingId());\n        assertEquals(instance2.getSlingId(), instance2.getClusterViewService()\n                .getSlingId());\n\n        try{\n            instance1.getClusterViewService().getLocalClusterView();\n            fail(\"should complain\");\n        } catch(UndefinedClusterViewException e) {\n            // ok\n        }\n        try{\n            instance2.getClusterViewService().getLocalClusterView();\n            fail(\"should complain\");\n        } catch(UndefinedClusterViewException e) {\n            // ok\n        }\n\n        instance1.heartbeatsAndCheckView();\n        instance2.heartbeatsAndCheckView();\n\n        instance1.dumpRepo();\n        logger.info(\"testAdditionalInstance: 1st 2s sleep\");\n        Thread.sleep(2000);\n\n        instance1.heartbeatsAndCheckView();\n        instance2.heartbeatsAndCheckView();\n        logger.info(\"testAdditionalInstance: 2nd 2s sleep\");\n        Thread.sleep(2000);\n\n        instance1.dumpRepo();\n        String clusterId1 = instance1.getClusterViewService().getLocalClusterView()\n                .getId();\n        logger.info(\"clusterId1=\" + clusterId1);\n        String clusterId2 = instance2.getClusterViewService().getLocalClusterView()\n                .getId();\n        logger.info(\"clusterId2=\" + clusterId2);\n        assertEquals(clusterId1, clusterId2);\n\n        assertEquals(2, instance1.getClusterViewService().getLocalClusterView()\n                .getInstances().size());\n        assertEquals(2, instance2.getClusterViewService().getLocalClusterView()\n                .getInstances().size());\n\n        AssertingTopologyEventListener assertingTopologyEventListener = new AssertingTopologyEventListener();\n        assertingTopologyEventListener.addExpected(Type.TOPOLOGY_INIT);\n        assertEquals(1, assertingTopologyEventListener.getRemainingExpectedCount());\n        instance1.bindTopologyEventListener(assertingTopologyEventListener);\n        Thread.sleep(500); // SLING-4755: async event sending requires some minimal wait time nowadays\n        assertEquals(0, assertingTopologyEventListener.getRemainingExpectedCount());\n\n        // startup instance 3\n        AcceptsMultiple acceptsMultiple = new AcceptsMultiple(\n                Type.TOPOLOGY_CHANGING, Type.TOPOLOGY_CHANGED);\n        assertingTopologyEventListener.addExpected(acceptsMultiple);\n        assertingTopologyEventListener.addExpected(acceptsMultiple);\n        instance3 = newBuilder().setDebugName(\"thirdInstance\")\n                .useRepositoryOf(instance1)\n                .build();\n        for(int i=0; i<4; i++) {\n            instance1.heartbeatsAndCheckView();\n            instance2.heartbeatsAndCheckView();\n            instance3.heartbeatsAndCheckView();\n            logger.info(\"testAdditionalInstance: i=\"+i+\", 2s sleep\");\n            Thread.sleep(2000);\n        }\n\n        assertEquals(1, acceptsMultiple.getEventCnt(Type.TOPOLOGY_CHANGING));\n        assertEquals(1, acceptsMultiple.getEventCnt(Type.TOPOLOGY_CHANGED));\n        logger.info(\"testAdditionalInstance: end\");\n    }","commit_id":"d3ccb969458da92302e9a282e13d8010374d9dcf","url":"https://github.com/apache/sling"},{"original_method":"@Override\n\tpublic String getXmlAsString(ResultSet rs, String columnName) throws SQLException {\n\t\treturn rs.getSQLXML(columnName).getString();\n\t}","id":95600,"modified_method":"@Override\n\tpublic String getXmlAsString(ResultSet rs, String columnName) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnName);\n\t\treturn (xmlObject != null ? xmlObject.getString() : null);\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Reader getXmlAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\treturn rs.getSQLXML(columnIndex).getCharacterStream();\n\t}","id":95601,"modified_method":"@Override\n\tpublic Reader getXmlAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnIndex);\n\t\treturn (xmlObject != null ? xmlObject.getCharacterStream() : null);\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Source getXmlAsSource(ResultSet rs, int columnIndex, Class<? extends Source> sourceClass) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnIndex);\n\t\treturn (sourceClass != null ? xmlObject.getSource(sourceClass) : xmlObject.getSource(DOMSource.class));\n\t}","id":95602,"modified_method":"@Override\n\tpublic Source getXmlAsSource(ResultSet rs, int columnIndex, Class<? extends Source> sourceClass) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnIndex);\n\t\tif (xmlObject == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (sourceClass != null ? xmlObject.getSource(sourceClass) : xmlObject.getSource(DOMSource.class));\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic InputStream getXmlAsBinaryStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn rs.getSQLXML(columnName).getBinaryStream();\n\t}","id":95603,"modified_method":"@Override\n\tpublic InputStream getXmlAsBinaryStream(ResultSet rs, String columnName) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnName);\n\t\treturn (xmlObject != null ? xmlObject.getBinaryStream() : null);\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Reader getXmlAsCharacterStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn rs.getSQLXML(columnName).getCharacterStream();\n\t}","id":95604,"modified_method":"@Override\n\tpublic Reader getXmlAsCharacterStream(ResultSet rs, String columnName) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnName);\n\t\treturn (xmlObject != null ? xmlObject.getCharacterStream() : null);\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic String getXmlAsString(ResultSet rs, int columnIndex) throws SQLException {\n\t\treturn rs.getSQLXML(columnIndex).getString();\n\t}","id":95605,"modified_method":"@Override\n\tpublic String getXmlAsString(ResultSet rs, int columnIndex) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnIndex);\n\t\treturn (xmlObject != null ? xmlObject.getString() : null);\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Source getXmlAsSource(ResultSet rs, String columnName, Class<? extends Source> sourceClass) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnName);\n\t\treturn (sourceClass != null ? xmlObject.getSource(sourceClass) : xmlObject.getSource(DOMSource.class));\n\t}","id":95606,"modified_method":"@Override\n\tpublic Source getXmlAsSource(ResultSet rs, String columnName, Class<? extends Source> sourceClass) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnName);\n\t\tif (xmlObject == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (sourceClass != null ? xmlObject.getSource(sourceClass) : xmlObject.getSource(DOMSource.class));\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic InputStream getXmlAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\treturn rs.getSQLXML(columnIndex).getBinaryStream();\n\t}","id":95607,"modified_method":"@Override\n\tpublic InputStream getXmlAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tSQLXML xmlObject = rs.getSQLXML(columnIndex);\n\t\treturn (xmlObject != null ? xmlObject.getBinaryStream() : null);\n\t}","commit_id":"78dad4cfc33e24d1bd9a69eb26f79579ace576ae","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void foundGuaranteedNullDeref(\n\t\t\t@NonNull Set<Location> assignedNullLocationSet,\n\t\t\t@NonNull Set<Location> derefLocationSet,\n\t\t\tSortedSet<Location> doomedLocations,\n\t\t\tValueNumber refValue, boolean alwaysOnExceptionPath, boolean npeIfStatementCovered) {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Found guaranteed null deref in \" + method.getName());\n\t\t\tfor(Location loc : doomedLocations)\n\t\t\t\tSystem.out.println(\"Doomed at \" + loc);\n\t\t}\n\t\t\n\t\tString bugType = alwaysOnExceptionPath\n\t\t\t? \"NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH\"\n\t\t\t: \"NP_GUARANTEED_DEREF\";\n\t\tint priority = alwaysOnExceptionPath ? NORMAL_PRIORITY : HIGH_PRIORITY;\n\t\tif (!npeIfStatementCovered) priority++;\n\t\t\n\t\t// Create BugInstance\n\t\tBugInstance bugInstance = new BugInstance(this, bugType, priority)\n\t\t\t.addClassAndMethod(classContext.getJavaClass(), method);\n\t\t\n\t\t// Add Locations in the set of locations at least one of which\n\t\t// is guaranteed to be dereferenced\n\t\tTreeSet<Location> sortedDerefLocationSet = new TreeSet<Location>(derefLocationSet);\n\t\tfor (Location loc : sortedDerefLocationSet) {\n\t\t\tbugInstance.addSourceLine(classContext, method, loc).describe(\"SOURCE_LINE_DEREF\");\n\t\t}\n\n\t\tif (!doomedLocations.isEmpty()) {\n\t\t\tbugInstance.addSourceLine(classContext, method, doomedLocations.first()).describe(\"SOURCE_LINE_NULL_VALUE\");\n\t\t}\n\t\telse {\n\t\t\t// Add Locations where the value was observed to become null\n\t\t\tTreeSet<Location> sortedAssignedNullLocationSet = new TreeSet<Location>(assignedNullLocationSet);\n\t\t\tfor (Location loc : sortedAssignedNullLocationSet) {\n\t\t\t\tbugInstance.addSourceLine(classContext, method, loc).describe(\"SOURCE_LINE_NULL_VALUE\");\n\t\t\t}\n\t\t}\n\t\t// Report it\n\t\tbugReporter.reportBug(bugInstance);\n\t}","id":95608,"modified_method":"public void foundGuaranteedNullDeref(\n\t\t\t@NonNull Set<Location> assignedNullLocationSet,\n\t\t\t@NonNull Set<Location> derefLocationSet,\n\t\t\tSortedSet<Location> doomedLocations,\n\t\t\tValueNumber refValue, boolean alwaysOnExceptionPath, boolean npeIfStatementCovered) {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Found guaranteed null deref in \" + method.getName());\n\t\t\tfor(Location loc : doomedLocations)\n\t\t\t\tSystem.out.println(\"Doomed at \" + loc);\n\t\t}\n\t\t\n\t\tString bugType = alwaysOnExceptionPath\n\t\t\t? \"NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH\"\n\t\t\t: \"NP_GUARANTEED_DEREF\";\n\t\tint priority = alwaysOnExceptionPath ? NORMAL_PRIORITY : HIGH_PRIORITY;\n\t\tif (!npeIfStatementCovered) priority++;\n\t\t\n\t\t// Create BugInstance\n\t\tBugInstance bugInstance = new BugInstance(this, bugType, priority)\n\t\t\t.addClassAndMethod(classContext.getJavaClass(), method);\n\t\t\n\t\t// Add Locations in the set of locations at least one of which\n\t\t// is guaranteed to be dereferenced\n\t\tTreeSet<Location> sortedDerefLocationSet = new TreeSet<Location>(derefLocationSet);\n\t\tfor (Location loc : sortedDerefLocationSet) {\n\t\t\tbugInstance.addSourceLine(classContext, method, loc).describe(\"SOURCE_LINE_DEREF\");\n\t\t}\n\n\t\tif (!doomedLocations.isEmpty()) {\n\t\t\tfor (Location loc : doomedLocations) \n\t\t\t\tbugInstance.addSourceLine(classContext, method, loc).describe(\"SOURCE_LINE_NULL_VALUE\");\n\t\t\n\t\t\t// bugInstance.addSourceLine(classContext, method, doomedLocations.first()).describe(\"SOURCE_LINE_NULL_VALUE\");\n\t\t}\n\t\telse {\n\t\t\t// Add Locations where the value was observed to become null\n\t\t\tTreeSet<Location> sortedAssignedNullLocationSet = new TreeSet<Location>(assignedNullLocationSet);\n\t\t\tfor (Location loc : sortedAssignedNullLocationSet) {\n\t\t\t\tbugInstance.addSourceLine(classContext, method, loc).describe(\"SOURCE_LINE_NULL_VALUE\");\n\t\t\t}\n\t\t}\n\t\t// Report it\n\t\tbugReporter.reportBug(bugInstance);\n\t}","commit_id":"bdf5973a8a092b7c9811906545fc644a6ee270e2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static Location getFirstLocation(@NonNull BasicBlock basicBlock) {\n\t\treturn new Location(basicBlock.getFirstInstruction(), basicBlock);\n\t}","id":95609,"modified_method":"public static Location getFirstLocation(@NonNull BasicBlock basicBlock) {\n\t\tInstructionHandle location = basicBlock.getFirstInstruction();\n\t\tif (location == null)\n\t\t\treturn null;\n\t\treturn new Location(location, basicBlock);\n\t}","commit_id":"bdf5973a8a092b7c9811906545fc644a6ee270e2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static Location getLastLocation(@NonNull BasicBlock basicBlock) {\n\t\tInstructionHandle lastInstruction = basicBlock.getLastInstruction();\n\t\tif (lastInstruction == null)\n\t\t\tlastInstruction = basicBlock.getExceptionThrower();\n\t\tif (lastInstruction == null)\n\t\t\tlastInstruction = basicBlock.getFirstInstruction();\n\t\tif (lastInstruction == null)\n\t\t\treturn null;\n\t\treturn new Location(lastInstruction, basicBlock);\n\t}","id":95610,"modified_method":"public static Location getLastLocation(@NonNull BasicBlock basicBlock) {\n\t\tInstructionHandle lastInstruction = basicBlock.getLastInstruction();\n\t\t/*\n\t\tif (lastInstruction == null)\n\t\t\tlastInstruction = basicBlock.getExceptionThrower();\n\t\tif (lastInstruction == null)\n\t\t\tlastInstruction = basicBlock.getFirstInstruction();\n\t\t*/\n\t\tif (lastInstruction == null)\n\t\t\treturn null;\n\t\treturn new Location(lastInstruction, basicBlock);\n\t}","commit_id":"bdf5973a8a092b7c9811906545fc644a6ee270e2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Note the locations where a known-null value is unconditionally\n\t * dereferenced.\n\t * @param thisLocation TODO\n\t * @param bugLocations TODO\n\t * @param nullValueGuaranteedDerefMap map of null values to sets of Locations where they are derefed\n\t * @param derefSet                    set of values known to be unconditionally dereferenced\n\t * @param isNullValue                 the null value\n\t * @param valueNumber                 the value number of the null value\n\t */\n\tprivate void noteUnconditionallyDereferencedNullValue(Location thisLocation, Map<ValueNumber, SortedSet<Location>> bugLocations, Map<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap, UnconditionalValueDerefSet derefSet, IsNullValue isNullValue, ValueNumber valueNumber) {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"%%% HIT for value number \" + valueNumber);\n\t\t}\n\t\t\n\t\t// OK, we have a null value that is unconditionally\n\t\t// derferenced.  Make a note of the locations where it\n\t\t// will be dereferenced.\n\t\tNullValueUnconditionalDeref thisNullValueDeref = nullValueGuaranteedDerefMap.get(valueNumber);\n\t\tif (thisNullValueDeref == null) {\n\t\t\tthisNullValueDeref = new NullValueUnconditionalDeref();\n\t\t\tnullValueGuaranteedDerefMap.put(valueNumber, thisNullValueDeref);\n\t\t}\n\t\tthisNullValueDeref.add(isNullValue, derefSet.getUnconditionalDerefLocationSet(valueNumber));\n\t\n\t\tif (thisLocation != null) {\n\t\t\tSortedSet<Location> locationsForThisBug = bugLocations.get(valueNumber);\n\n\t\t\tif (locationsForThisBug == null) {\n\t\t\t\tlocationsForThisBug = new TreeSet<Location>();\n\t\t\t\tbugLocations.put(valueNumber, locationsForThisBug);\n\t\t\t}\n\t\t\tlocationsForThisBug.add(thisLocation);\n\t\t}\n\t}","id":95611,"modified_method":"/**\n\t * Note the locations where a known-null value is unconditionally\n\t * dereferenced.\n\t * @param thisLocation TODO\n\t * @param bugLocations TODO\n\t * @param nullValueGuaranteedDerefMap map of null values to sets of Locations where they are derefed\n\t * @param derefSet                    set of values known to be unconditionally dereferenced\n\t * @param isNullValue                 the null value\n\t * @param valueNumber                 the value number of the null value\n\t */\n\tprivate void noteUnconditionallyDereferencedNullValue(Location thisLocation, Map<ValueNumber, SortedSet<Location>> bugLocations, Map<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap, UnconditionalValueDerefSet derefSet, IsNullValue isNullValue, ValueNumber valueNumber) {\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"%%% HIT for value number \" + valueNumber + \" @ \" + thisLocation);\n\t\t}\n\t\t\n\t\t// OK, we have a null value that is unconditionally\n\t\t// derferenced.  Make a note of the locations where it\n\t\t// will be dereferenced.\n\t\tNullValueUnconditionalDeref thisNullValueDeref = nullValueGuaranteedDerefMap.get(valueNumber);\n\t\tif (thisNullValueDeref == null) {\n\t\t\tthisNullValueDeref = new NullValueUnconditionalDeref();\n\t\t\tnullValueGuaranteedDerefMap.put(valueNumber, thisNullValueDeref);\n\t\t}\n\t\tthisNullValueDeref.add(isNullValue, derefSet.getUnconditionalDerefLocationSet(valueNumber));\n\t\n\t\tif (thisLocation != null) {\n\t\t\tSortedSet<Location> locationsForThisBug = bugLocations.get(valueNumber);\n\n\t\t\tif (locationsForThisBug == null) {\n\t\t\t\tlocationsForThisBug = new TreeSet<Location>();\n\t\t\t\tbugLocations.put(valueNumber, locationsForThisBug);\n\t\t\t}\n\t\t\tlocationsForThisBug.add(thisLocation);\n\t\t}\n\t}","commit_id":"bdf5973a8a092b7c9811906545fc644a6ee270e2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Examine null values.\n\t * Report any that are guaranteed to be dereferenced on\n\t * non-implicit-exception paths.\n\t * \n\t * @throws CFGBuilderException \n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void examineNullValues() throws CFGBuilderException, DataflowAnalysisException {\n\t\tSet<LocationWhereValueBecomesNull> locationWhereValueBecomesNullSet =\n\t\t\tinvDataflow.getAnalysis().getLocationWhereValueBecomesNullSet();\n\n\t\t// For each value number that is null somewhere in the\n\t\t// method, collect the set of locations where it becomes null.\n\t\t// FIXME: we may see some locations that are not guaranteed to be dereferenced (how to fix this?)\n\t\tMap<ValueNumber, Set<Location>> nullValueAssignmentMap =\n\t\t\tnew HashMap<ValueNumber, Set<Location>>();\n\t\tfor (LocationWhereValueBecomesNull lwvbn : locationWhereValueBecomesNullSet) {\n\t\t\tSet<Location> locationSet = nullValueAssignmentMap.get(lwvbn.getValueNumber());\n\t\t\tif (locationSet == null) {\n\t\t\t\tlocationSet = new HashSet<Location>();\n\t\t\t\tnullValueAssignmentMap.put(lwvbn.getValueNumber(), locationSet);\n\t\t\t}\n\t\t\tlocationSet.add(lwvbn.getLocation());\n\t\t}\n\t\tMap<ValueNumber, SortedSet<Location>> bugLocationMap =\n\t\t\tnew HashMap<ValueNumber, SortedSet<Location>>();\n\t\t// Inspect the method for locations where a null value is guaranteed to\n\t\t// be dereferenced.  Add the dereference locations\n\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap =\n\t\t\tnew HashMap<ValueNumber, NullValueUnconditionalDeref>();\n\t\t\n\t\t// Check every location\n\t\tfor (Iterator<Location> i = classContext.getCFG(method).locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"At location \" + location);\n\t\t\t}\n\t\t\t\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n\t\t\t\t\tbugLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n\t\t\t\t\tvnaDataflow.getFactAtLocation(location), invDataflow.getFactAtLocation(location), uvdDataflow.getFactAfterLocation(location));\n\t\t}\n\t\tHashSet<ValueNumber> npeIfStatementCovered = new HashSet(nullValueGuaranteedDerefMap.keySet());\n\t\t\n\t\t// Check every non-exception control edge\n\t\tfor (Iterator<Edge> i = classContext.getCFG(method).edgeIterator(); i.hasNext();) {\n\t\t\tEdge edge = i.next();\n\t\t\t\n\t\t\tif (edge.isExceptionEdge()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"On edge \" + edge.formatAsString(false));\n\t\t\t}\n\t\t\t\n\t\t\tValueNumberFrame vnaFact = vnaDataflow.getResultFact(edge.getSource());\n\t\t\tIsNullValueFrame invFact = invDataflow.getFactOnEdge(edge);\n\t\t\tUnconditionalValueDerefSet uvdFact = uvdDataflow.getFactOnEdge(edge);\n\t\t\tLocation location = Location.getLastLocation(edge.getTarget());\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n\t\t\t\t\tbugLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n\t\t\t\t\tvnaFact, invFact, uvdFact);\n\t\t}\n\t\t\n\t\t// Report \n\t\tfor (Map.Entry<ValueNumber, NullValueUnconditionalDeref> e  : nullValueGuaranteedDerefMap.entrySet()) {\n\t\t\tValueNumber valueNumber = e.getKey();\n\t\t\tSet<Location> derefLocationSet = e.getValue().getDerefLocationSet();\n\t\t\tSet<Location> assignedNullLocationSet = nullValueAssignmentMap.get(valueNumber);\n\t\t\tif (assignedNullLocationSet == null) {\n\t\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\t\tString where = classContext.getJavaClass().getClassName() + \".\" + method.getName() + \":\" + method.getSignature();\n\t\t\t\t\tSystem.out.println(\"Problem at \" + where);\n\t\t\t\t\tfor (Location loc : derefLocationSet) {\n\t\t\t\t\t\tSystem.out.println(\"Dereference at \" + loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert false: \"No assigned NullLocationSet for \" + valueNumber + \" in \" + nullValueAssignmentMap.keySet();\n\t\t\t\tassignedNullLocationSet = Collections.EMPTY_SET;\n\t\t\t}\n\t\t\tcollector.foundGuaranteedNullDeref(\n\t\t\t\t\tassignedNullLocationSet,\n\t\t\t\t\tderefLocationSet,\n\t\t\t\t\tbugLocationMap.get(valueNumber),\n\t\t\t\t\tvalueNumber, e.getValue().isAlwaysOnExceptionPath(), \n\t\t\t\t\tnpeIfStatementCovered.contains(valueNumber));\n\t\t}\n\t}","id":95612,"modified_method":"/**\n\t * Examine null values.\n\t * Report any that are guaranteed to be dereferenced on\n\t * non-implicit-exception paths.\n\t * \n\t * @throws CFGBuilderException \n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void examineNullValues() throws CFGBuilderException, DataflowAnalysisException {\n\t\tSet<LocationWhereValueBecomesNull> locationWhereValueBecomesNullSet =\n\t\t\tinvDataflow.getAnalysis().getLocationWhereValueBecomesNullSet();\n\n\t\t// For each value number that is null somewhere in the\n\t\t// method, collect the set of locations where it becomes null.\n\t\t// FIXME: we may see some locations that are not guaranteed to be dereferenced (how to fix this?)\n\t\tMap<ValueNumber, Set<Location>> nullValueAssignmentMap =\n\t\t\tnew HashMap<ValueNumber, Set<Location>>();\n\t\tfor (LocationWhereValueBecomesNull lwvbn : locationWhereValueBecomesNullSet) {\n\t\t\tSet<Location> locationSet = nullValueAssignmentMap.get(lwvbn.getValueNumber());\n\t\t\tif (locationSet == null) {\n\t\t\t\tlocationSet = new HashSet<Location>();\n\t\t\t\tnullValueAssignmentMap.put(lwvbn.getValueNumber(), locationSet);\n\t\t\t}\n\t\t\tlocationSet.add(lwvbn.getLocation());\n\t\t}\n\t\tMap<ValueNumber, SortedSet<Location>> bugLocationMap =\n\t\t\tnew HashMap<ValueNumber, SortedSet<Location>>();\n\t\t// Inspect the method for locations where a null value is guaranteed to\n\t\t// be dereferenced.  Add the dereference locations\n\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap =\n\t\t\tnew HashMap<ValueNumber, NullValueUnconditionalDeref>();\n\t\t\n\t\t// Check every location\n\t\tfor (Iterator<Location> i = classContext.getCFG(method).locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"At location \" + location);\n\t\t\t}\n\t\t\t\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n\t\t\t\t\tbugLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n\t\t\t\t\tvnaDataflow.getFactAtLocation(location), invDataflow.getFactAtLocation(location), uvdDataflow.getFactAfterLocation(location));\n\t\t}\n\t\tHashSet<ValueNumber> npeIfStatementCovered = new HashSet(nullValueGuaranteedDerefMap.keySet());\n\t\t\n\t\t// Check every non-exception control edge\n\t\tfor (Iterator<Edge> i = classContext.getCFG(method).edgeIterator(); i.hasNext();) {\n\t\t\tEdge edge = i.next();\n\t\t\t\n\t\t\tif (edge.isExceptionEdge()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\tSystem.out.println(\"On edge \" + edge.formatAsString(false));\n\t\t\t}\n\t\t\t\n\t\t\tValueNumberFrame vnaFact = vnaDataflow.getResultFact(edge.getSource());\n\t\t\tIsNullValueFrame invFact = invDataflow.getFactOnEdge(edge);\n\t\t\tUnconditionalValueDerefSet uvdFact = uvdDataflow.getFactOnEdge(edge);\n\t\t\tLocation location = Location.getLastLocation(edge.getSource());\n\t\t\tcheckForUnconditionallyDereferencedNullValues(\n\t\t\t\t\tlocation,\n\t\t\t\t\tbugLocationMap,\n\t\t\t\t\tnullValueGuaranteedDerefMap,\n\t\t\t\t\tvnaFact, invFact, uvdFact);\n\t\t}\n\t\t\n\t\t// Report \n\t\tfor (Map.Entry<ValueNumber, NullValueUnconditionalDeref> e  : nullValueGuaranteedDerefMap.entrySet()) {\n\t\t\tValueNumber valueNumber = e.getKey();\n\t\t\tSet<Location> derefLocationSet = e.getValue().getDerefLocationSet();\n\t\t\tSet<Location> assignedNullLocationSet = nullValueAssignmentMap.get(valueNumber);\n\t\t\tif (assignedNullLocationSet == null) {\n\t\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\t\tString where = classContext.getJavaClass().getClassName() + \".\" + method.getName() + \":\" + method.getSignature();\n\t\t\t\t\tSystem.out.println(\"Problem at \" + where);\n\t\t\t\t\tfor (Location loc : derefLocationSet) {\n\t\t\t\t\t\tSystem.out.println(\"Dereference at \" + loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert false: \"No assigned NullLocationSet for \" + valueNumber + \" in \" + nullValueAssignmentMap.keySet();\n\t\t\t\tassignedNullLocationSet = Collections.EMPTY_SET;\n\t\t\t}\n\t\t\tcollector.foundGuaranteedNullDeref(\n\t\t\t\t\tassignedNullLocationSet,\n\t\t\t\t\tderefLocationSet,\n\t\t\t\t\tbugLocationMap.get(valueNumber),\n\t\t\t\t\tvalueNumber, e.getValue().isAlwaysOnExceptionPath(), \n\t\t\t\t\tnpeIfStatementCovered.contains(valueNumber));\n\t\t}\n\t}","commit_id":"bdf5973a8a092b7c9811906545fc644a6ee270e2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void findSwitchDuplicates(CFG cfg, Method method, BasicBlock bb) {\t\t\n\t\tIterator<Edge> iei = cfg.outgoingEdgeIterator(bb);\n\t\t\t\t\n\t\tint[] switchPos = new int[cfg.getNumOutgoingEdges(bb)+1];\n\t\tint idx = 0;\n\t\t\n\t\twhile (iei.hasNext()) {\n\t\t\tEdge e = iei.next();\n\t\t\tif (EdgeTypes.SWITCH_EDGE == e.getType()) {\n\t\t\t\tBasicBlock target = e.getTarget();\n\t\t\t\tswitchPos[idx++] = target.getFirstInstruction().getPosition();\n\t\t\t} else if (EdgeTypes.SWITCH_DEFAULT_EDGE == e.getType()) {\n\t\t\t\tBasicBlock target = e.getTarget();\n\t\t\t\tswitchPos[idx++] = target.getFirstInstruction().getPosition();\n\t\t\t} else\n\t\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrays.sort(switchPos);\n\t\t\n\t\tif (switchPos.length < 2)\n\t\t\treturn;\n\t\t\t\t\t\t\n\t\tfor (int i = 0; i < switchPos.length-2; i++) {\n\t\t\tint s1Length = switchPos[i+1] - switchPos[i];\n\t\t\tif (s1Length == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tbyte[] s1Bytes = null;\n\t\t\t\n\t\t\tfor (int j = i+1; j < switchPos.length-1; j++) {\n\t\t\t\tint s2Length = switchPos[j+1] - switchPos[j];\n\t\t\t\tif (s2Length == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (s1Length != s2Length)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (s1Bytes == null)\n\t\t\t\t\ts1Bytes = getCodeBytes(method, switchPos[i], switchPos[i+1]);\n\t\t\t\t\t\t\t\t\n\t\t\t\tbyte[] s2Bytes = getCodeBytes(method, switchPos[j], switchPos[j+1]);\n\t\t\t\t\n\t\t\t\tif (!Arrays.equals(s1Bytes, s2Bytes))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DB_DUPLICATE_BRANCHES\", LOW_PRIORITY)\n\t\t\t\t\t\t.addClass(classContext.getJavaClass())\n\t\t\t\t\t\t.addMethod(classContext.getJavaClass().getClassName(), method.getName(), method.getSignature())\n\t\t\t\t\t\t.addSourceLineRange(this, \n\t\t\t\t\t\t\t\tswitchPos[i],\n\t\t\t\t\t\t\t\tswitchPos[i+1]-1)\n\t\t\t\t\t\t.addSourceLineRange(this, \n\t\t\t\t\t\t\t\tswitchPos[j],\n\t\t\t\t\t\t\t\tswitchPos[j+1]-1));\n\t\t\t\tj = switchPos.length;\n\t\t\t}\n\t\t}\n\t}","id":95613,"modified_method":"private void findSwitchDuplicates(CFG cfg, Method method, BasicBlock bb) {\t\t\n\t\tIterator<Edge> iei = cfg.outgoingEdgeIterator(bb);\n\t\t\t\t\n\t\tint[] switchPos = new int[cfg.getNumOutgoingEdges(bb)+1];\n\t\tint idx = 0;\n\t\t\n\t\twhile (iei.hasNext()) {\n\t\t\tEdge e = iei.next();\n\t\t\tif (EdgeTypes.SWITCH_EDGE == e.getType()) {\n\t\t\t\tBasicBlock target = e.getTarget();\n\t\t\t\tInstructionHandle firstIns = target.getFirstInstruction();\n\t\t\t\tif (firstIns == null)\n\t\t\t\t\treturn;\n\t\t\t\tswitchPos[idx++] = firstIns.getPosition();\n\t\t\t} else if (EdgeTypes.SWITCH_DEFAULT_EDGE == e.getType()) {\n\t\t\t\tBasicBlock target = e.getTarget();\n\t\t\t\tInstructionHandle firstIns = target.getFirstInstruction();\n\t\t\t\tif (firstIns == null)\n\t\t\t\t\treturn;\n\t\t\t\tswitchPos[idx++] = firstIns.getPosition();\n\t\t\t} else\n\t\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrays.sort(switchPos);\n\t\t\n\t\tif (switchPos.length < 2)\n\t\t\treturn;\n\t\t\t\t\t\t\n\t\tfor (int i = 0; i < switchPos.length-2; i++) {\n\t\t\tint s1Length = switchPos[i+1] - switchPos[i];\n\t\t\tif (s1Length == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tbyte[] s1Bytes = null;\n\t\t\t\n\t\t\tfor (int j = i+1; j < switchPos.length-1; j++) {\n\t\t\t\tint s2Length = switchPos[j+1] - switchPos[j];\n\t\t\t\tif (s2Length == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (s1Length != s2Length)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (s1Bytes == null)\n\t\t\t\t\ts1Bytes = getCodeBytes(method, switchPos[i], switchPos[i+1]);\n\t\t\t\t\t\t\t\t\n\t\t\t\tbyte[] s2Bytes = getCodeBytes(method, switchPos[j], switchPos[j+1]);\n\t\t\t\t\n\t\t\t\tif (!Arrays.equals(s1Bytes, s2Bytes))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DB_DUPLICATE_BRANCHES\", LOW_PRIORITY)\n\t\t\t\t\t\t.addClass(classContext.getJavaClass())\n\t\t\t\t\t\t.addMethod(classContext.getJavaClass().getClassName(), method.getName(), method.getSignature())\n\t\t\t\t\t\t.addSourceLineRange(this, \n\t\t\t\t\t\t\t\tswitchPos[i],\n\t\t\t\t\t\t\t\tswitchPos[i+1]-1)\n\t\t\t\t\t\t.addSourceLineRange(this, \n\t\t\t\t\t\t\t\tswitchPos[j],\n\t\t\t\t\t\t\t\tswitchPos[j+1]-1));\n\t\t\t\tj = switchPos.length;\n\t\t\t}\n\t\t}\n\t}","commit_id":"cdb3872ca7acf26cdaa8fc74f5dc9dd3d25e2af2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void onResume() {\n        long viewID = currentViewId();\n        Message msg = new Message(null, localAddress, null);\n        msg.setFlag(Message.OOB);\n        msg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH, viewID));\n        down_prot.down(new Event(Event.MSG, msg));\n        if(log.isDebugEnabled())\n            log.debug(\"Received RESUME at \" + localAddress + \", sent STOP_FLUSH to all\");\n    }","id":95614,"modified_method":"private void onResume() {\n        long viewID = currentViewId();\n        Message msg = new Message(null, localAddress, null);    \n        //Cannot be OOB since START_FLUSH is not OOB\n        //we have to FIFO order two subsequent flushes       \n        msg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH, viewID));\n        down_prot.down(new Event(Event.MSG, msg));\n        if(log.isDebugEnabled())\n            log.debug(\"Received RESUME at \" + localAddress + \", sent STOP_FLUSH to all\");\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushOk(Address address, long viewID) {\n\n        boolean flushOkCompleted = false;\n        boolean amIParticipant = false;\n        synchronized(sharedLock){\n            amIParticipant = flushMembers.contains(address);\n            flushOkSet.add(address);\n            flushOkCompleted = flushOkSet.containsAll(flushMembers);\n            if(log.isDebugEnabled())\n                log.debug(\"At \" + localAddress\n                          + \" FLUSH_OK from \"\n                          + address\n                          + \",completed \"\n                          + flushOkCompleted\n                          + \",  flushOkSet \"\n                          + flushOkSet);\n        }\n\n        if(flushOkCompleted && amIParticipant){\n            synchronized(blockMutex){\n                isBlockingFlushDown = true;\n            }\n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID);\n            fh.addDigest(digest);\n            Message m = new Message(flushCoordinator);\n            m.putHeader(getName(), fh);\n            if(log.isDebugEnabled())\n                log.debug(localAddress + \" is blocking FLUSH.down(). Sending FLUSH_COMPLETED message to \"\n                          + flushCoordinator);\n            down_prot.down(new Event(Event.MSG, m));\n\n        }\n    }","id":95615,"modified_method":"private void onFlushOk(Address address, long viewID) {\n\n        boolean flushOkCompleted = false;\n        boolean amIParticipant = false;\n        Message m = null;\n        synchronized(sharedLock){\n            amIParticipant = flushMembers.contains(address);\n            flushOkSet.add(address);\n            flushOkCompleted = flushOkSet.containsAll(flushMembers);\n            if(flushOkCompleted){\n                m = new Message(flushCoordinator);\n            }\n            if(log.isDebugEnabled())\n                log.debug(\"At \" + localAddress\n                          + \" FLUSH_OK from \"\n                          + address\n                          + \",completed \"\n                          + flushOkCompleted\n                          + \",  flushOkSet \"\n                          + flushOkSet);\n        }\n\n        if(flushOkCompleted && amIParticipant){\n            synchronized(blockMutex){\n                isBlockingFlushDown = true;\n            }\n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID);\n            fh.addDigest(digest);\n            m.putHeader(getName(), fh);\n            if(log.isDebugEnabled())\n                log.debug(localAddress + \" is blocking FLUSH.down(). Sending FLUSH_COMPLETED message to \"\n                          + flushCoordinator);\n            down_prot.down(new Event(Event.MSG, m));\n\n        }\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Create a copy of view which contains only members which are present in\n     * hosts. Call viewAccepted() on the MuxChannel which corresponds with\n     * service. If no members are removed or added from/to view, this is a\n     * no-op.\n     * \n     * @param hosts\n     *                List<Address>\n     * @return the servicd view (a modified copy of the real view), or null if\n     *         the view was not modified\n     */\n    private View generateServiceView(List<Address> hosts) {\n        if(view == null) {\n            Vector<Address> tmp=new Vector<Address>();\n            tmp.add(local_addr);\n            view= new View(new ViewId(local_addr), tmp);\n        }\n        Vector<Address> members=new Vector<Address>(view.getMembers());\n        members.retainAll(hosts);\n        return new View(view.getVid(), members);\n    }","id":95616,"modified_method":"/**\n     * Create a copy of view which contains only members which are present in\n     * hosts. Call viewAccepted() on the MuxChannel which corresponds with\n     * service. If no members are removed or added from/to view, this is a\n     * no-op.\n     * \n     * @param hosts\n     *                List<Address>\n     * @return the servicd view (a modified copy of the real view), or null if\n     *         the view was not modified\n     */\n    private View generateServiceView(List<Address> hosts) {\n        if(view == null) {\n            Vector<Address> tmp=new Vector<Address>();\n            tmp.add(getLocalAddress());\n            view= new View(new ViewId(getLocalAddress()), tmp);\n        }\n        Vector<Address> members=new Vector<Address>(view.getMembers());\n        members.retainAll(hosts);\n        return new View(view.getVid(), members);\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendServiceUpMessage(String service, Address host,boolean bypassFlush) throws Exception {\n        sendServiceMessage(ServiceInfo.SERVICE_UP, service, host,bypassFlush, null);\n        if(local_addr != null && host != null && local_addr.equals(host))\n            handleServiceUp(service, host, false);\n    }","id":95617,"modified_method":"public void sendServiceUpMessage(String service, Address host,boolean bypassFlush) throws Exception {\n        //we have to make this service message non OOB since we have\n        //to FIFO order service messages and BLOCK/UNBLOCK messages        \n        sendServiceMessage(ServiceInfo.SERVICE_UP, service, host,bypassFlush, null,false);        \n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Fetches the service states from everyone else in the cluster. Once all\n     * states have been received and inserted into service_state, compute a\n     * service view (a copy of MergeView) for each service and pass it up\n     * \n     * @param view\n     */\n    private void handleMergeView(MergeView view) throws Exception {\n        long time_to_wait=SERVICES_RSP_TIMEOUT, start;\n        int num_members=view.size(); // include myself\n        Map<Address, Set<String>> copy=null;\n\n        byte[] data=Util.objectToByteBuffer(new HashSet<String>(services.keySet()));\n        sendServiceMessage(ServiceInfo.LIST_SERVICES_RSP, null, channel.getLocalAddress(), true, data);\n\n        synchronized(service_responses) {\n            start=System.currentTimeMillis();\n            try {\n                while(time_to_wait > 0 && numResponses(service_responses) < num_members) {\n                    service_responses.wait(time_to_wait);\n                    time_to_wait-=System.currentTimeMillis() - start;\n                }\n                copy=new HashMap<Address, Set<String>>(service_responses);\n            }\n            catch(Exception ex) {\n                if(log.isErrorEnabled())\n                    log.error(\"failed fetching a list of services from other members in the cluster, cannot handle merge view \" + view, ex);\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"merging service state, my service_state: \" + service_state + \", received responses: \" + copy);\n\n        // merges service_responses with service_state and emits MergeViews for the services affected (MuxChannel)\n        mergeServiceState(view, copy);\n        service_responses.clear();       \n    }","id":95618,"modified_method":"/**\n     * Fetches the service states from everyone else in the cluster. Once all\n     * states have been received and inserted into service_state, compute a\n     * service view (a copy of MergeView) for each service and pass it up\n     * \n     * @param view\n     */\n    private void handleMergeView(MergeView view) throws Exception {\n        long time_to_wait=SERVICES_RSP_TIMEOUT, start;\n        int num_members=view.size(); // include myself\n        Map<Address, Set<String>> copy=null;\n\n        byte[] data=Util.objectToByteBuffer(new HashSet<String>(services.keySet()));\n        \n        //we have to make this message OOB since we are running on a thread \n        //propelling a regular synchronous message call to install a new view \n        sendServiceMessage(ServiceInfo.LIST_SERVICES_RSP, null, channel.getLocalAddress(), true, data,true);\n\n        synchronized(service_responses) {\n            start=System.currentTimeMillis();\n            try {\n                while(time_to_wait > 0 && numResponses(service_responses) < num_members) {\n                    service_responses.wait(time_to_wait);\n                    time_to_wait-=System.currentTimeMillis() - start;\n                }\n                copy=new HashMap<Address, Set<String>>(service_responses);\n            }\n            catch(Exception ex) {\n                if(log.isErrorEnabled())\n                    log.error(\"failed fetching a list of services from other members in the cluster, cannot handle merge view \" + view, ex);\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"merging service state, my service_state: \" + service_state + \", received responses: \" + copy);\n\n        // merges service_responses with service_state and emits MergeViews for the services affected (MuxChannel)\n        mergeServiceState(view, copy);\n        service_responses.clear();       \n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"public Multiplexer(JChannel channel) {\n        this.channel=channel;\n        this.channel.setUpHandler(this);\n        this.channel.setOpt(Channel.BLOCK, Boolean.TRUE); // we want to handle BLOCK events ourselves\n        flush_present=isFlushPresent(); \n        \n        //threadpool is enabled by default\n        if(Global.getPropertyAsBoolean(Global.MUX_ENABLED, true)){\n            thread_pool=createThreadPool();\n        }\n    }","id":95619,"modified_method":"public Multiplexer(JChannel channel) {\n        this.channel=channel;\n        this.channel.setUpHandler(this);\n        this.channel.setOpt(Channel.BLOCK, Boolean.TRUE); // we want to handle BLOCK events ourselves                \n        \n        //thread pool is enabled by default\n        boolean use_thread_pool = Global.getPropertyAsBoolean(Global.MUX_ENABLED, true);\n        if(use_thread_pool){\n            thread_pool=createThreadPool();\n        }\n        else{\n            thread_pool=null;\n        }\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Remove mux header and dispatch to correct MuxChannel\n     * @param evt\n     * @return\n     */\n    public Object up(final Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                final Message msg=(Message)evt.getArg();\n                final MuxHeader hdr=(MuxHeader)msg.getHeader(NAME);\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return null;\n                }\n\n                Address sender=msg.getSrc();\n                if(hdr.info != null) { // it is a service state request - not a default multiplex request\n                    try {\n                        handleServiceStateRequest(hdr.info, sender);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failure in handling service state request\", e);\n                    }\n                    break;\n                }\n\n                MuxChannel mux_ch=services.get(hdr.id);\n                if(mux_ch == null) {\n                    return null;\n                }\n                return passToMuxChannel(mux_ch, evt, fifo_queue, sender, hdr.id, false); // don't block !\n\n            case Event.VIEW_CHANGE:\n                Vector<Address> old_members=view != null? view.getMembers() : null;\n                view=(View)evt.getArg();\n                Vector<Address> new_members=view != null? view.getMembers() : null;\n                Vector<Address> left_members=Util.determineLeftMembers(old_members, new_members);\n\n                if(view instanceof MergeView) {\n                    final MergeView temp_merge_view=(MergeView)view.clone();\n                    if(log.isTraceEnabled())\n                        log.trace(\"received a MergeView: \" + temp_merge_view + \", adjusting the service view\");                    \n                    try {                        \n                        handleMergeView(temp_merge_view);                        \n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed handling merge view\", e);\n                    }                                       \n                }\n                else { // regular view\n                    synchronized(service_responses) {\n                        service_responses.clear();\n                    }\n                    HashMap<String,List<Address>> payload = (HashMap<String, List<Address>>) view.getPayload(\"service_state\");                                      \n                    if(payload != null){\n                        synchronized(service_state){                           \n                            service_state.putAll(payload);\n                        }\n                    }\n                    \n                }\n                if(!left_members.isEmpty())\n                    adjustServiceViews(left_members);\n                break;\n                \n            case Event.PREPARE_VIEW:\n                View prepare_view=(View)evt.getArg();                  \n                old_members=view != null? view.getMembers() : new Vector<Address>();                \n                \n                Vector <Address> added_members =  new Vector<Address>(prepare_view.getMembers());\n                added_members.removeAll(old_members);\n                \n                if(!added_members.isEmpty()){                    \n                    synchronized(service_state){\n                        prepare_view.addPayload(\"service_state\", service_state);    \n                    }                    \n                }\n                break;\n                \n\n            case Event.SUSPECT:\n                Address suspected_mbr=(Address)evt.getArg();\n\n                synchronized(service_responses) {\n                    service_responses.put(suspected_mbr, null);\n                    service_responses.notifyAll();\n                }\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n            case Event.STATE_TRANSFER_OUTPUTSTREAM:\n                return handleStateRequest(evt);\n\n            case Event.GET_STATE_OK:\n            case Event.STATE_TRANSFER_INPUTSTREAM:\n                handleStateResponse(evt);\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.BLOCK:\n                blocked=true;\n                if(!services.isEmpty()) {\n                    passToAllMuxChannels(evt, true, true); // do block and bypass the thread pool\n                }\n                waitUntilThreadPoolHasNoRunningTasks(1000);\n                return null;\n\n            case Event.UNBLOCK: // process queued-up MergeViews\n                if(blocked)\n                    blocked=false;\n                passToAllMuxChannels(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n        return null;\n    }","id":95620,"modified_method":"/**\n     * Remove mux header and dispatch to correct MuxChannel\n     * @param evt\n     * @return\n     */\n    public Object up(final Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                final Message msg=(Message)evt.getArg();\n                final MuxHeader hdr=(MuxHeader)msg.getHeader(NAME);\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return null;\n                }\n\n                Address sender=msg.getSrc();\n                if(hdr.info != null) { // it is a service state request - not a default multiplex request\n                    try {\n                        handleServiceStateRequest(hdr.info, sender);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failure in handling service state request\", e);\n                    }\n                    break;\n                }\n\n                MuxChannel mux_ch=services.get(hdr.id);\n                if(mux_ch == null) {\n                    return null;\n                }\n                return passToMuxChannel(mux_ch, evt, fifo_queue, sender, hdr.id, false); // don't block !\n\n            case Event.VIEW_CHANGE:\n                Vector<Address> old_members=view != null? view.getMembers() : null;\n                view=(View)evt.getArg();\n                Vector<Address> new_members=view != null? view.getMembers() : null;\n                Vector<Address> left_members=Util.determineLeftMembers(old_members, new_members);\n\n                if(view instanceof MergeView) {\n                    final MergeView temp_merge_view=(MergeView)view.clone();\n                    if(log.isTraceEnabled())\n                        log.trace(\"received a MergeView: \" + temp_merge_view + \", adjusting the service view\");                    \n                    try {                        \n                        handleMergeView(temp_merge_view);                        \n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed handling merge view\", e);\n                    }                                       \n                }\n                else { // regular view\n                    synchronized(service_responses) {\n                        service_responses.clear();\n                    }\n                    HashMap<String,List<Address>> payload = (HashMap<String, List<Address>>) view.getPayload(\"service_state\");                                      \n                    if(payload != null){\n                        synchronized(service_state){                           \n                            service_state.putAll(payload);\n                        }\n                    }\n                    \n                }\n                for(Address member:left_members){\n                   try{\n                       adjustServiceView(member);\n                   }catch(Throwable t){\n                       if(log.isErrorEnabled())\n                           log.error(\"failed adjusting service views\", t);\n                   }\n                }                \n                break;\n                \n            case Event.PREPARE_VIEW:\n                View prepare_view=(View)evt.getArg();                  \n                old_members=view != null? view.getMembers() : new Vector<Address>();                \n                \n                Vector <Address> added_members =  new Vector<Address>(prepare_view.getMembers());\n                added_members.removeAll(old_members);\n                \n                if(!added_members.isEmpty()){                    \n                    synchronized(service_state){\n                        prepare_view.addPayload(\"service_state\", service_state);    \n                    }                    \n                }\n                break;\n                \n\n            case Event.SUSPECT:\n                Address suspected_mbr=(Address)evt.getArg();\n\n                synchronized(service_responses) {\n                    service_responses.put(suspected_mbr, null);\n                    service_responses.notifyAll();\n                }\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n            case Event.STATE_TRANSFER_OUTPUTSTREAM:\n                return handleStateRequest(evt);\n\n            case Event.GET_STATE_OK:\n            case Event.STATE_TRANSFER_INPUTSTREAM:\n                handleStateResponse(evt);\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:                \n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.BLOCK:\n                blocked=true;\n                if(!services.isEmpty()) {\n                    passToAllMuxChannels(evt, true, true); // do block and bypass the thread pool\n                }\n                waitUntilThreadPoolHasNoRunningTasks(1000);\n                return null;\n\n            case Event.UNBLOCK: // process queued-up MergeViews\n                if(blocked)\n                    blocked=false;\n                passToAllMuxChannels(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n        return null;\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleServiceDown(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean removed=false;\n\n        // discard if we sent this message\n        if(received && host != null && local_addr != null && local_addr.equals(host)) {\n            return;\n        }\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null)\n                return;\n            removed=hosts.remove(host);\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(removed){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);               \n                if(ch.isConnected())\n                    passToMuxChannel(ch, view_evt, fifo_queue, null, service, false);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }\n\n        Address local_address=getLocalAddress();\n        if(local_address != null && host != null && host.equals(local_address))\n            unregister(service);\n    }","id":95621,"modified_method":"private void handleServiceDown(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean removed=false;\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null)\n                return;\n            removed=hosts.remove(host);\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(removed){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null && ch.isConnected()){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);  \n                //we cannot pass service message to thread pool since we have\n                //to FIFO order service messages with BLOCK/UNBLOCK messages\n                //therefore all of them have to bypass thread pool\n                \n                passToMuxChannel(ch, view_evt, fifo_queue, null, service, false,true);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }\n\n        Address local_address=getLocalAddress();\n        if(local_address != null && host != null && host.equals(local_address))\n            unregister(service);\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private void adjustServiceView(Address host) {\n\n        synchronized(service_state){\n            for(Iterator<Map.Entry<String, List<Address>>> it = service_state.entrySet().iterator();it.hasNext();){\n                Map.Entry<String, List<Address>> entry = it.next();\n                String service = entry.getKey();\n                List<Address> hosts = entry.getValue();\n                if(hosts == null)\n                    continue;\n\n                if(hosts.remove(host)){\n                    // make a copy so we don't modify hosts in\n                    // generateServiceView()\n                    View service_view = generateServiceView(new ArrayList<Address>(hosts));\n                    MuxChannel ch = services.get(service);\n                    if(ch != null){\n                        Event view_evt = new Event(Event.VIEW_CHANGE, service_view);    \n                        if(ch.isConnected())\n                            passToMuxChannel(ch, view_evt, fifo_queue, null, service, false);\n                    }else{\n                        if(log.isTraceEnabled())\n                            log.trace(\"service \" + service\n                                      + \" not found, cannot dispatch service view \"\n                                      + service_view);\n                    }\n                }\n                Address local_address = getLocalAddress();\n                if(local_address != null && host != null && host.equals(local_address))\n                    unregister(service);\n            }\n        }\n    }","id":95622,"modified_method":"private void adjustServiceView(Address host) {\n\n        synchronized(service_state){\n            for(Iterator<Map.Entry<String, List<Address>>> it = service_state.entrySet().iterator();it.hasNext();){\n                Map.Entry<String, List<Address>> entry = it.next();\n                String service = entry.getKey();\n                List<Address> hosts = entry.getValue();\n                if(hosts == null)\n                    continue;\n\n                if(hosts.remove(host)){\n                    // make a copy so we don't modify hosts in\n                    // generateServiceView()\n                    View service_view = generateServiceView(new ArrayList<Address>(hosts));\n                    MuxChannel ch = services.get(service);\n                    if(ch != null && ch.isConnected()){\n                        Event view_evt = new Event(Event.VIEW_CHANGE, service_view);    \n                        passToMuxChannel(ch, view_evt, fifo_queue, null, service, false, true);\n                    }else{\n                        if(log.isTraceEnabled())\n                            log.trace(\"service \" + service\n                                      + \" not found, cannot dispatch service view \"\n                                      + service_view);\n                    }\n                }\n                Address local_address = getLocalAddress();\n                if(local_address != null && host != null && host.equals(local_address))\n                    unregister(service);\n            }\n        }\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private Address getLocalAddress() {\n        if(local_addr != null)\n            return local_addr;\n        if(channel != null)\n            local_addr=channel.getLocalAddress();\n        return local_addr;\n    }","id":95623,"modified_method":"private Address getLocalAddress() {       \n        if(channel != null)\n            return channel.getLocalAddress();\n        \n        return null;\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendServiceDownMessage(String service, Address host,boolean bypassFlush) throws Exception {\n        sendServiceMessage(ServiceInfo.SERVICE_DOWN, service, host,bypassFlush, null);\n        if(local_addr != null && host != null && local_addr.equals(host))\n            handleServiceDown(service, host, false);\n    }","id":95624,"modified_method":"public void sendServiceDownMessage(String service, Address host,boolean bypassFlush) throws Exception {\n       //we have to make this service message non OOB since we have\n       //to FIFO order service messages and BLOCK/UNBLOCK messages        \n       sendServiceMessage(ServiceInfo.SERVICE_DOWN, service, host,bypassFlush, null,false);       \n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendServiceMessage(byte type, String service, Address host,boolean bypassFlush, byte[] payload) throws Exception {\n        if(host == null)\n            host=getLocalAddress();\n        if(host == null) {\n            if(log.isWarnEnabled()) {\n                log.warn(\"local_addr is null, cannot send ServiceInfo.\" + ServiceInfo.typeToString(type) + \" message\");\n            }\n            return;\n        }\n\n        ServiceInfo si=new ServiceInfo(type, service, host, payload);\n        MuxHeader hdr=new MuxHeader(si);\n        Message service_msg=new Message();\n        service_msg.setFlag(Message.OOB);\n        service_msg.putHeader(NAME, hdr);\n        if(bypassFlush && flush_present)\n           service_msg.putHeader(FLUSH.NAME, new FLUSH.FlushHeader(FLUSH.FlushHeader.FLUSH_BYPASS));\n        \n        channel.send(service_msg);\n    }","id":95625,"modified_method":"private void sendServiceMessage(byte type, String service, Address host,boolean bypassFlush, byte[] payload, boolean oob) throws Exception {\n        if(host == null)\n            host=getLocalAddress();\n        if(host == null) {\n            if(log.isWarnEnabled()) {\n                log.warn(\"local_addr is null, cannot send ServiceInfo.\" + ServiceInfo.typeToString(type) + \" message\");\n            }\n            return;\n        }\n\n        ServiceInfo si=new ServiceInfo(type, service, host, payload);\n        MuxHeader hdr=new MuxHeader(si);\n        Message service_msg=new Message();           \n        \n        if(oob)\n           service_msg.setFlag(Message.OOB);\n        service_msg.putHeader(NAME, hdr);\n        if(bypassFlush && channel.flushSupported())\n           service_msg.putHeader(FLUSH.NAME, new FLUSH.FlushHeader(FLUSH.FlushHeader.FLUSH_BYPASS));\n        \n        channel.send(service_msg);\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleServiceUp(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean added=false;\n\n        // discard if we sent this message\n        if(received && host != null && local_addr != null && local_addr.equals(host)) {\n            return;\n        }\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null) {\n                hosts=new ArrayList<Address>();\n                service_state.put(service,  hosts);\n            }\n            if(!hosts.contains(host)) {\n                hosts.add(host);\n                added=true;\n            }\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(added){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);\n                passToMuxChannel(ch, view_evt, fifo_queue, null, service, false);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }        \n    }","id":95626,"modified_method":"private void handleServiceUp(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean added=false;\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null) {\n                hosts=new ArrayList<Address>();\n                service_state.put(service,  hosts);\n            }\n            if(!hosts.contains(host)) {\n                hosts.add(host);\n                added=true;\n            }\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(added){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);     \n                //we cannot pass service message to thread pool since we have\n                //to FIFO order service messages with BLOCK/UNBLOCK messages\n                //therefore all of them have to bypass thread pool\n                passToMuxChannel(ch, view_evt, fifo_queue, null, service, false,true);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }        \n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStateResponse(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        MuxChannel mux_ch;\n        Address state_sender=info.target;\n\n        String appl_id, substate_id, tmp;\n        tmp=info.state_id;\n\n        if(tmp == null) {\n            if(log.isTraceEnabled())\n                log.trace(\"state is null, not passing up: \" + info);\n            return;\n        }\n\n        int index=tmp.indexOf(SEPARATOR);\n        if(index > -1) {\n            appl_id=tmp.substring(0, index);\n            substate_id=tmp.substring(index+SEPARATOR_LEN);\n        }\n        else {\n            appl_id=tmp;\n            substate_id=null;\n        }\n\n        mux_ch=services.get(appl_id);\n        if(mux_ch == null) {\n            log.error(\"didn't find service with ID=\" + appl_id + \" to fetch state from\");\n        }\n        else {\n            StateTransferInfo tmp_info=info.copy();\n            tmp_info.state_id=substate_id;\n            Event tmpEvt=new Event(evt.getType(), tmp_info);\n            passToMuxChannel(mux_ch, tmpEvt, fifo_queue, state_sender, appl_id, false);\n        }\n    }","id":95627,"modified_method":"private void handleStateResponse(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        MuxChannel mux_ch;\n        Address state_sender=info.target;\n\n        String appl_id, substate_id, tmp;\n        tmp=info.state_id;\n\n        if(tmp == null) {\n            if(log.isTraceEnabled())\n                log.trace(\"state is null, not passing up: \" + info);\n            return;\n        }\n\n        int index=tmp.indexOf(SEPARATOR);\n        if(index > -1) {\n            appl_id=tmp.substring(0, index);\n            substate_id=tmp.substring(index+SEPARATOR_LEN);\n        }\n        else {\n            appl_id=tmp;\n            substate_id=null;\n        }\n\n        mux_ch=services.get(appl_id);\n        if (mux_ch == null){\n           log.error(\"State receiver \" + channel.getLocalAddress()\n                 + \" does not have service with id \" + appl_id);\n        }\n        else {\n            StateTransferInfo tmp_info=info.copy();\n            tmp_info.state_id=substate_id;\n            Event tmpEvt=new Event(evt.getType(), tmp_info);\n            passToMuxChannel(mux_ch, tmpEvt, fifo_queue, state_sender, appl_id, false);\n        }\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private Object handleStateRequest(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        String id=info.state_id;\n        String original_id=id;\n        Address requester=info.target; // the sender of the state request\n\n        try {\n            int index=id.indexOf(SEPARATOR);\n            if(index > -1) {\n                info.state_id=id.substring(index + SEPARATOR_LEN);\n                id=id.substring(0, index);  // similar reuse as above...\n            }\n            else {\n                info.state_id=null;\n            }\n\n            MuxChannel mux_ch=services.get(id);\n            if(mux_ch == null)\n                throw new IllegalArgumentException(\"didn't find service with ID=\" + id + \" to fetch state from\");\n\n            // state_id will be null, get regular state from the service named state_id\n            StateTransferInfo ret=(StateTransferInfo)passToMuxChannel(mux_ch, evt, fifo_queue, requester, id, true);\n            if(ret != null)\n        \tret.state_id=original_id;\n            return ret;\n        }\n        catch(Throwable ex) {\n            if(log.isErrorEnabled())\n                log.error(\"failed returning the application state, will return null\", ex);\n            return new StateTransferInfo(null, original_id, 0L, null);\n        }\n    }","id":95628,"modified_method":"private Object handleStateRequest(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        String id=info.state_id;\n        String original_id=id;\n        Address requester=info.target; // the sender of the state request\n\n        try {\n            int index=id.indexOf(SEPARATOR);\n            if(index > -1) {\n                info.state_id=id.substring(index + SEPARATOR_LEN);\n                id=id.substring(0, index);  // similar reuse as above...\n            }\n            else {\n                info.state_id=null;\n            }\n\n            MuxChannel mux_ch=services.get(id);\n            if(mux_ch == null)\n                throw new IllegalArgumentException(\"State provider \"\n                  + channel.getLocalAddress()\n                  + \" does not have service with id \" + id);\n\n            // state_id will be null, get regular state from the service named state_id\n            StateTransferInfo ret=(StateTransferInfo)passToMuxChannel(mux_ch, evt, fifo_queue, requester, id, true);\n            if(ret != null)\n        \tret.state_id=original_id;\n            return ret;\n        }\n        catch(Throwable ex) {\n            if(log.isErrorEnabled())\n                log.error(\"failed returning the application state, will return null\", ex);\n            return new StateTransferInfo(null, original_id, 0L, null);\n        }\n    }","commit_id":"05d190f47fcf3730007d4e5939d01c52edc22172","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onResume() {\n        long viewID = currentViewId();\n        Message msg = new Message(null, localAddress, null);\n        msg.setFlag(Message.OOB);\n        msg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH, viewID));\n        down_prot.down(new Event(Event.MSG, msg));\n        if(log.isDebugEnabled())\n            log.debug(\"Received RESUME at \" + localAddress + \", sent STOP_FLUSH to all\");\n    }","id":95629,"modified_method":"private void onResume() {\n        long viewID = currentViewId();\n        Message msg = new Message(null, localAddress, null);    \n        //Cannot be OOB since START_FLUSH is not OOB\n        //we have to FIFO order two subsequent flushes       \n        msg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH, viewID));\n        down_prot.down(new Event(Event.MSG, msg));\n        if(log.isDebugEnabled())\n            log.debug(\"Received RESUME at \" + localAddress + \", sent STOP_FLUSH to all\");\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushOk(Address address, long viewID) {\n\n        boolean flushOkCompleted = false;\n        boolean amIParticipant = false;\n        synchronized(sharedLock){\n            amIParticipant = flushMembers.contains(address);\n            flushOkSet.add(address);\n            flushOkCompleted = flushOkSet.containsAll(flushMembers);\n            if(log.isDebugEnabled())\n                log.debug(\"At \" + localAddress\n                          + \" FLUSH_OK from \"\n                          + address\n                          + \",completed \"\n                          + flushOkCompleted\n                          + \",  flushOkSet \"\n                          + flushOkSet);\n        }\n\n        if(flushOkCompleted && amIParticipant){\n            synchronized(blockMutex){\n                isBlockingFlushDown = true;\n            }\n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID);\n            fh.addDigest(digest);\n            Message m = new Message(flushCoordinator);\n            m.putHeader(getName(), fh);\n            if(log.isDebugEnabled())\n                log.debug(localAddress + \" is blocking FLUSH.down(). Sending FLUSH_COMPLETED message to \"\n                          + flushCoordinator);\n            down_prot.down(new Event(Event.MSG, m));\n\n        }\n    }","id":95630,"modified_method":"private void onFlushOk(Address address, long viewID) {\n\n        boolean flushOkCompleted = false;\n        boolean amIParticipant = false;\n        Message m = null;\n        synchronized(sharedLock){\n            amIParticipant = flushMembers.contains(address);\n            flushOkSet.add(address);\n            flushOkCompleted = flushOkSet.containsAll(flushMembers);\n            if(flushOkCompleted){\n                m = new Message(flushCoordinator);\n            }\n            if(log.isDebugEnabled())\n                log.debug(\"At \" + localAddress\n                          + \" FLUSH_OK from \"\n                          + address\n                          + \",completed \"\n                          + flushOkCompleted\n                          + \",  flushOkSet \"\n                          + flushOkSet);\n        }\n\n        if(flushOkCompleted && amIParticipant){\n            synchronized(blockMutex){\n                isBlockingFlushDown = true;\n            }\n            Digest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n            FlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID);\n            fh.addDigest(digest);\n            m.putHeader(getName(), fh);\n            if(log.isDebugEnabled())\n                log.debug(localAddress + \" is blocking FLUSH.down(). Sending FLUSH_COMPLETED message to \"\n                          + flushCoordinator);\n            down_prot.down(new Event(Event.MSG, m));\n\n        }\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"public Multiplexer(JChannel channel) {\n        this.channel=channel;\n        this.channel.setUpHandler(this);\n        this.channel.setOpt(Channel.BLOCK, Boolean.TRUE); // we want to handle BLOCK events ourselves\n        flush_present=isFlushPresent(); \n        \n        //threadpool is enabled by default\n        if(Global.getPropertyAsBoolean(Global.MUX_ENABLED, true)){\n            thread_pool=createThreadPool();\n        }\n    }","id":95631,"modified_method":"public Multiplexer(JChannel channel) {\n        this.channel=channel;\n        this.channel.setUpHandler(this);\n        this.channel.setOpt(Channel.BLOCK, Boolean.TRUE); // we want to handle BLOCK events ourselves                \n        \n        //thread pool is enabled by default\n        boolean use_thread_pool = Global.getPropertyAsBoolean(Global.MUX_ENABLED, true);\n        if(use_thread_pool){\n            thread_pool=createThreadPool();\n        }\n        else{\n            thread_pool=null;\n        }\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Remove mux header and dispatch to correct MuxChannel\n     * @param evt\n     * @return\n     */\n    public Object up(final Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                final Message msg=(Message)evt.getArg();\n                final MuxHeader hdr=(MuxHeader)msg.getHeader(NAME);\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return null;\n                }\n\n                Address sender=msg.getSrc();\n                if(hdr.info != null) { // it is a service state request - not a default multiplex request\n                    try {\n                        handleServiceStateRequest(hdr.info, sender);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failure in handling service state request\", e);\n                    }\n                    break;\n                }\n\n                MuxChannel mux_ch=services.get(hdr.id);\n                if(mux_ch == null) {\n                    return null;\n                }\n                return passToMuxChannel(mux_ch, evt, fifo_queue, sender, hdr.id, false); // don't block !\n\n            case Event.VIEW_CHANGE:\n                Vector<Address> old_members=view != null? view.getMembers() : null;\n                view=(View)evt.getArg();\n                Vector<Address> new_members=view != null? view.getMembers() : null;\n                Vector<Address> left_members=Util.determineLeftMembers(old_members, new_members);\n\n                if(view instanceof MergeView) {\n                    final MergeView temp_merge_view=(MergeView)view.clone();\n                    if(log.isTraceEnabled())\n                        log.trace(\"received a MergeView: \" + temp_merge_view + \", adjusting the service view\");                    \n                    try {                        \n                        handleMergeView(temp_merge_view);                        \n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed handling merge view\", e);\n                    }                                       \n                }\n                else { // regular view\n                    synchronized(service_responses) {\n                        service_responses.clear();\n                    }\n                    HashMap<String,List<Address>> payload = (HashMap<String, List<Address>>) view.getPayload(\"service_state\");                                      \n                    if(payload != null){\n                        synchronized(service_state){                           \n                            service_state.putAll(payload);\n                        }\n                    }\n                    \n                }\n                if(!left_members.isEmpty())\n                    adjustServiceViews(left_members);\n                break;\n                \n            case Event.PREPARE_VIEW:\n                View prepare_view=(View)evt.getArg();                  \n                old_members=view != null? view.getMembers() : new Vector<Address>();                \n                \n                Vector <Address> added_members =  new Vector<Address>(prepare_view.getMembers());\n                added_members.removeAll(old_members);\n                \n                if(!added_members.isEmpty()){                    \n                    synchronized(service_state){\n                        prepare_view.addPayload(\"service_state\", service_state);    \n                    }                    \n                }\n                break;\n                \n\n            case Event.SUSPECT:\n                Address suspected_mbr=(Address)evt.getArg();\n\n                synchronized(service_responses) {\n                    service_responses.put(suspected_mbr, null);\n                    service_responses.notifyAll();\n                }\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n            case Event.STATE_TRANSFER_OUTPUTSTREAM:\n                return handleStateRequest(evt);\n\n            case Event.GET_STATE_OK:\n            case Event.STATE_TRANSFER_INPUTSTREAM:\n                handleStateResponse(evt);\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.BLOCK:\n                blocked=true;\n                if(!services.isEmpty()) {\n                    passToAllMuxChannels(evt, true, true); // do block and bypass the thread pool\n                }\n                waitUntilThreadPoolHasNoRunningTasks(1000);\n                return null;\n\n            case Event.UNBLOCK: // process queued-up MergeViews\n                if(blocked)\n                    blocked=false;\n                passToAllMuxChannels(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n        return null;\n    }","id":95632,"modified_method":"/**\n     * Remove mux header and dispatch to correct MuxChannel\n     * @param evt\n     * @return\n     */\n    public Object up(final Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                final Message msg=(Message)evt.getArg();\n                final MuxHeader hdr=(MuxHeader)msg.getHeader(NAME);\n                if(hdr == null) {\n                    log.error(\"MuxHeader not present - discarding message \" + msg);\n                    return null;\n                }\n\n                Address sender=msg.getSrc();\n                if(hdr.info != null) { // it is a service state request - not a default multiplex request\n                    try {\n                        handleServiceStateRequest(hdr.info, sender);\n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failure in handling service state request\", e);\n                    }\n                    break;\n                }\n\n                MuxChannel mux_ch=services.get(hdr.id);\n                if(mux_ch == null) {\n                    return null;\n                }\n                return passToMuxChannel(mux_ch, evt, fifo_queue, sender, hdr.id, false); // don't block !\n\n            case Event.VIEW_CHANGE:\n                Vector<Address> old_members=view != null? view.getMembers() : null;\n                view=(View)evt.getArg();\n                Vector<Address> new_members=view != null? view.getMembers() : null;\n                Vector<Address> left_members=Util.determineLeftMembers(old_members, new_members);\n\n                if(view instanceof MergeView) {\n                    final MergeView temp_merge_view=(MergeView)view.clone();\n                    if(log.isTraceEnabled())\n                        log.trace(\"received a MergeView: \" + temp_merge_view + \", adjusting the service view\");                    \n                    try {                        \n                        handleMergeView(temp_merge_view);                        \n                    }\n                    catch(Exception e) {\n                        if(log.isErrorEnabled())\n                            log.error(\"failed handling merge view\", e);\n                    }                                       \n                }\n                else { // regular view\n                    synchronized(service_responses) {\n                        service_responses.clear();\n                    }\n                    HashMap<String,List<Address>> payload = (HashMap<String, List<Address>>) view.getPayload(\"service_state\");                                      \n                    if(payload != null){\n                        synchronized(service_state){                           \n                            service_state.putAll(payload);\n                        }\n                    }\n                    \n                }\n                for(Address member:left_members){\n                   try{\n                       adjustServiceView(member);\n                   }catch(Throwable t){\n                       if(log.isErrorEnabled())\n                           log.error(\"failed adjusting service views\", t);\n                   }\n                }                \n                break;\n                \n            case Event.PREPARE_VIEW:\n                View prepare_view=(View)evt.getArg();                  \n                old_members=view != null? view.getMembers() : new Vector<Address>();                \n                \n                Vector <Address> added_members =  new Vector<Address>(prepare_view.getMembers());\n                added_members.removeAll(old_members);\n                \n                if(!added_members.isEmpty()){                    \n                    synchronized(service_state){\n                        prepare_view.addPayload(\"service_state\", service_state);    \n                    }                    \n                }\n                break;\n                \n\n            case Event.SUSPECT:\n                Address suspected_mbr=(Address)evt.getArg();\n\n                synchronized(service_responses) {\n                    service_responses.put(suspected_mbr, null);\n                    service_responses.notifyAll();\n                }\n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.GET_APPLSTATE:\n            case Event.STATE_TRANSFER_OUTPUTSTREAM:\n                return handleStateRequest(evt);\n\n            case Event.GET_STATE_OK:\n            case Event.STATE_TRANSFER_INPUTSTREAM:\n                handleStateResponse(evt);\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:                \n                passToAllMuxChannels(evt);\n                break;\n\n            case Event.BLOCK:\n                blocked=true;\n                if(!services.isEmpty()) {\n                    passToAllMuxChannels(evt, true, true); // do block and bypass the thread pool\n                }\n                waitUntilThreadPoolHasNoRunningTasks(1000);\n                return null;\n\n            case Event.UNBLOCK: // process queued-up MergeViews\n                if(blocked)\n                    blocked=false;\n                passToAllMuxChannels(evt);\n                break;\n\n            default:\n                passToAllMuxChannels(evt);\n                break;\n        }\n        return null;\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleServiceDown(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean removed=false;\n\n        // discard if we sent this message\n        if(received && host != null && local_addr != null && local_addr.equals(host)) {\n            return;\n        }\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null)\n                return;\n            removed=hosts.remove(host);\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(removed){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);               \n                if(ch.isConnected())\n                    passToMuxChannel(ch, view_evt, fifo_queue, null, service, false);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }\n\n        Address local_address=getLocalAddress();\n        if(local_address != null && host != null && host.equals(local_address))\n            unregister(service);\n    }","id":95633,"modified_method":"private void handleServiceDown(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean removed=false;\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null)\n                return;\n            removed=hosts.remove(host);\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(removed){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null && ch.isConnected()){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);  \n                //we cannot pass service message to thread pool since we have\n                //to FIFO order service messages with BLOCK/UNBLOCK messages\n                //therefore all of them have to bypass thread pool\n                \n                passToMuxChannel(ch, view_evt, fifo_queue, null, service, false,true);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }\n\n        Address local_address=getLocalAddress();\n        if(local_address != null && host != null && host.equals(local_address))\n            unregister(service);\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private Object handleStateRequest(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        String id=info.state_id;\n        String original_id=id;\n        Address requester=info.target; // the sender of the state request\n\n        try {\n            int index=id.indexOf(SEPARATOR);\n            if(index > -1) {\n                info.state_id=id.substring(index + SEPARATOR_LEN);\n                id=id.substring(0, index);  // similar reuse as above...\n            }\n            else {\n                info.state_id=null;\n            }\n\n            MuxChannel mux_ch=services.get(id);\n            if(mux_ch == null)\n                throw new IllegalArgumentException(\"didn't find service with ID=\" + id + \" to fetch state from\");\n\n            // state_id will be null, get regular state from the service named state_id\n            StateTransferInfo ret=(StateTransferInfo)passToMuxChannel(mux_ch, evt, fifo_queue, requester, id, true);\n            if(ret != null)\n        \tret.state_id=original_id;\n            return ret;\n        }\n        catch(Throwable ex) {\n            if(log.isErrorEnabled())\n                log.error(\"failed returning the application state, will return null\", ex);\n            return new StateTransferInfo(null, original_id, 0L, null);\n        }\n    }","id":95634,"modified_method":"private Object handleStateRequest(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        String id=info.state_id;\n        String original_id=id;\n        Address requester=info.target; // the sender of the state request\n\n        try {\n            int index=id.indexOf(SEPARATOR);\n            if(index > -1) {\n                info.state_id=id.substring(index + SEPARATOR_LEN);\n                id=id.substring(0, index);  // similar reuse as above...\n            }\n            else {\n                info.state_id=null;\n            }\n\n            MuxChannel mux_ch=services.get(id);\n            if(mux_ch == null)\n                throw new IllegalArgumentException(\"State provider \"\n                  + channel.getLocalAddress()\n                  + \" does not have service with id \" + id);\n\n            // state_id will be null, get regular state from the service named state_id\n            StateTransferInfo ret=(StateTransferInfo)passToMuxChannel(mux_ch, evt, fifo_queue, requester, id, true);\n            if(ret != null)\n        \tret.state_id=original_id;\n            return ret;\n        }\n        catch(Throwable ex) {\n            if(log.isErrorEnabled())\n                log.error(\"failed returning the application state, will return null\", ex);\n            return new StateTransferInfo(null, original_id, 0L, null);\n        }\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private Address getLocalAddress() {\n        if(local_addr != null)\n            return local_addr;\n        if(channel != null)\n            local_addr=channel.getLocalAddress();\n        return local_addr;\n    }","id":95635,"modified_method":"private Address getLocalAddress() {       \n        if(channel != null)\n            return channel.getLocalAddress();\n        \n        return null;\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Fetches the service states from everyone else in the cluster. Once all\n     * states have been received and inserted into service_state, compute a\n     * service view (a copy of MergeView) for each service and pass it up\n     * \n     * @param view\n     */\n    private void handleMergeView(MergeView view) throws Exception {\n        long time_to_wait=SERVICES_RSP_TIMEOUT, start;\n        int num_members=view.size(); // include myself\n        Map<Address, Set<String>> copy=null;\n\n        byte[] data=Util.objectToByteBuffer(new HashSet<String>(services.keySet()));\n        sendServiceMessage(ServiceInfo.LIST_SERVICES_RSP, null, channel.getLocalAddress(), true, data);\n\n        synchronized(service_responses) {\n            start=System.currentTimeMillis();\n            try {\n                while(time_to_wait > 0 && numResponses(service_responses) < num_members) {\n                    service_responses.wait(time_to_wait);\n                    time_to_wait-=System.currentTimeMillis() - start;\n                }\n                copy=new HashMap<Address, Set<String>>(service_responses);\n            }\n            catch(Exception ex) {\n                if(log.isErrorEnabled())\n                    log.error(\"failed fetching a list of services from other members in the cluster, cannot handle merge view \" + view, ex);\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"merging service state, my service_state: \" + service_state + \", received responses: \" + copy);\n\n        // merges service_responses with service_state and emits MergeViews for the services affected (MuxChannel)\n        mergeServiceState(view, copy);\n        service_responses.clear();       \n    }","id":95636,"modified_method":"/**\n     * Fetches the service states from everyone else in the cluster. Once all\n     * states have been received and inserted into service_state, compute a\n     * service view (a copy of MergeView) for each service and pass it up\n     * \n     * @param view\n     */\n    private void handleMergeView(MergeView view) throws Exception {\n        long time_to_wait=SERVICES_RSP_TIMEOUT, start;\n        int num_members=view.size(); // include myself\n        Map<Address, Set<String>> copy=null;\n\n        byte[] data=Util.objectToByteBuffer(new HashSet<String>(services.keySet()));\n        \n        //we have to make this message OOB since we are running on a thread \n        //propelling a regular synchronous message call to install a new view \n        sendServiceMessage(ServiceInfo.LIST_SERVICES_RSP, null, channel.getLocalAddress(), true, data,true);\n\n        synchronized(service_responses) {\n            start=System.currentTimeMillis();\n            try {\n                while(time_to_wait > 0 && numResponses(service_responses) < num_members) {\n                    service_responses.wait(time_to_wait);\n                    time_to_wait-=System.currentTimeMillis() - start;\n                }\n                copy=new HashMap<Address, Set<String>>(service_responses);\n            }\n            catch(Exception ex) {\n                if(log.isErrorEnabled())\n                    log.error(\"failed fetching a list of services from other members in the cluster, cannot handle merge view \" + view, ex);\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"merging service state, my service_state: \" + service_state + \", received responses: \" + copy);\n\n        // merges service_responses with service_state and emits MergeViews for the services affected (MuxChannel)\n        mergeServiceState(view, copy);\n        service_responses.clear();       \n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Create a copy of view which contains only members which are present in\n     * hosts. Call viewAccepted() on the MuxChannel which corresponds with\n     * service. If no members are removed or added from/to view, this is a\n     * no-op.\n     * \n     * @param hosts\n     *                List<Address>\n     * @return the servicd view (a modified copy of the real view), or null if\n     *         the view was not modified\n     */\n    private View generateServiceView(List<Address> hosts) {\n        if(view == null) {\n            Vector<Address> tmp=new Vector<Address>();\n            tmp.add(local_addr);\n            view= new View(new ViewId(local_addr), tmp);\n        }\n        Vector<Address> members=new Vector<Address>(view.getMembers());\n        members.retainAll(hosts);\n        return new View(view.getVid(), members);\n    }","id":95637,"modified_method":"/**\n     * Create a copy of view which contains only members which are present in\n     * hosts. Call viewAccepted() on the MuxChannel which corresponds with\n     * service. If no members are removed or added from/to view, this is a\n     * no-op.\n     * \n     * @param hosts\n     *                List<Address>\n     * @return the servicd view (a modified copy of the real view), or null if\n     *         the view was not modified\n     */\n    private View generateServiceView(List<Address> hosts) {\n        if(view == null) {\n            Vector<Address> tmp=new Vector<Address>();\n            tmp.add(getLocalAddress());\n            view= new View(new ViewId(getLocalAddress()), tmp);\n        }\n        Vector<Address> members=new Vector<Address>(view.getMembers());\n        members.retainAll(hosts);\n        return new View(view.getVid(), members);\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendServiceDownMessage(String service, Address host,boolean bypassFlush) throws Exception {\n        sendServiceMessage(ServiceInfo.SERVICE_DOWN, service, host,bypassFlush, null);\n        if(local_addr != null && host != null && local_addr.equals(host))\n            handleServiceDown(service, host, false);\n    }","id":95638,"modified_method":"public void sendServiceDownMessage(String service, Address host,boolean bypassFlush) throws Exception {\n       //we have to make this service message non OOB since we have\n       //to FIFO order service messages and BLOCK/UNBLOCK messages        \n       sendServiceMessage(ServiceInfo.SERVICE_DOWN, service, host,bypassFlush, null,false);       \n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private void adjustServiceView(Address host) {\n\n        synchronized(service_state){\n            for(Iterator<Map.Entry<String, List<Address>>> it = service_state.entrySet().iterator();it.hasNext();){\n                Map.Entry<String, List<Address>> entry = it.next();\n                String service = entry.getKey();\n                List<Address> hosts = entry.getValue();\n                if(hosts == null)\n                    continue;\n\n                if(hosts.remove(host)){\n                    // make a copy so we don't modify hosts in\n                    // generateServiceView()\n                    View service_view = generateServiceView(new ArrayList<Address>(hosts));\n                    MuxChannel ch = services.get(service);\n                    if(ch != null){\n                        Event view_evt = new Event(Event.VIEW_CHANGE, service_view);    \n                        if(ch.isConnected())\n                            passToMuxChannel(ch, view_evt, fifo_queue, null, service, false);\n                    }else{\n                        if(log.isTraceEnabled())\n                            log.trace(\"service \" + service\n                                      + \" not found, cannot dispatch service view \"\n                                      + service_view);\n                    }\n                }\n                Address local_address = getLocalAddress();\n                if(local_address != null && host != null && host.equals(local_address))\n                    unregister(service);\n            }\n        }\n    }","id":95639,"modified_method":"private void adjustServiceView(Address host) {\n\n        synchronized(service_state){\n            for(Iterator<Map.Entry<String, List<Address>>> it = service_state.entrySet().iterator();it.hasNext();){\n                Map.Entry<String, List<Address>> entry = it.next();\n                String service = entry.getKey();\n                List<Address> hosts = entry.getValue();\n                if(hosts == null)\n                    continue;\n\n                if(hosts.remove(host)){\n                    // make a copy so we don't modify hosts in\n                    // generateServiceView()\n                    View service_view = generateServiceView(new ArrayList<Address>(hosts));\n                    MuxChannel ch = services.get(service);\n                    if(ch != null && ch.isConnected()){\n                        Event view_evt = new Event(Event.VIEW_CHANGE, service_view);    \n                        passToMuxChannel(ch, view_evt, fifo_queue, null, service, false, true);\n                    }else{\n                        if(log.isTraceEnabled())\n                            log.trace(\"service \" + service\n                                      + \" not found, cannot dispatch service view \"\n                                      + service_view);\n                    }\n                }\n                Address local_address = getLocalAddress();\n                if(local_address != null && host != null && host.equals(local_address))\n                    unregister(service);\n            }\n        }\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendServiceMessage(byte type, String service, Address host,boolean bypassFlush, byte[] payload) throws Exception {\n        if(host == null)\n            host=getLocalAddress();\n        if(host == null) {\n            if(log.isWarnEnabled()) {\n                log.warn(\"local_addr is null, cannot send ServiceInfo.\" + ServiceInfo.typeToString(type) + \" message\");\n            }\n            return;\n        }\n\n        ServiceInfo si=new ServiceInfo(type, service, host, payload);\n        MuxHeader hdr=new MuxHeader(si);\n        Message service_msg=new Message();\n        service_msg.setFlag(Message.OOB);\n        service_msg.putHeader(NAME, hdr);\n        if(bypassFlush && flush_present)\n           service_msg.putHeader(FLUSH.NAME, new FLUSH.FlushHeader(FLUSH.FlushHeader.FLUSH_BYPASS));\n        \n        channel.send(service_msg);\n    }","id":95640,"modified_method":"private void sendServiceMessage(byte type, String service, Address host,boolean bypassFlush, byte[] payload, boolean oob) throws Exception {\n        if(host == null)\n            host=getLocalAddress();\n        if(host == null) {\n            if(log.isWarnEnabled()) {\n                log.warn(\"local_addr is null, cannot send ServiceInfo.\" + ServiceInfo.typeToString(type) + \" message\");\n            }\n            return;\n        }\n\n        ServiceInfo si=new ServiceInfo(type, service, host, payload);\n        MuxHeader hdr=new MuxHeader(si);\n        Message service_msg=new Message();           \n        \n        if(oob)\n           service_msg.setFlag(Message.OOB);\n        service_msg.putHeader(NAME, hdr);\n        if(bypassFlush && channel.flushSupported())\n           service_msg.putHeader(FLUSH.NAME, new FLUSH.FlushHeader(FLUSH.FlushHeader.FLUSH_BYPASS));\n        \n        channel.send(service_msg);\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendServiceUpMessage(String service, Address host,boolean bypassFlush) throws Exception {\n        sendServiceMessage(ServiceInfo.SERVICE_UP, service, host,bypassFlush, null);\n        if(local_addr != null && host != null && local_addr.equals(host))\n            handleServiceUp(service, host, false);\n    }","id":95641,"modified_method":"public void sendServiceUpMessage(String service, Address host,boolean bypassFlush) throws Exception {\n        //we have to make this service message non OOB since we have\n        //to FIFO order service messages and BLOCK/UNBLOCK messages        \n        sendServiceMessage(ServiceInfo.SERVICE_UP, service, host,bypassFlush, null,false);        \n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStateResponse(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        MuxChannel mux_ch;\n        Address state_sender=info.target;\n\n        String appl_id, substate_id, tmp;\n        tmp=info.state_id;\n\n        if(tmp == null) {\n            if(log.isTraceEnabled())\n                log.trace(\"state is null, not passing up: \" + info);\n            return;\n        }\n\n        int index=tmp.indexOf(SEPARATOR);\n        if(index > -1) {\n            appl_id=tmp.substring(0, index);\n            substate_id=tmp.substring(index+SEPARATOR_LEN);\n        }\n        else {\n            appl_id=tmp;\n            substate_id=null;\n        }\n\n        mux_ch=services.get(appl_id);\n        if(mux_ch == null) {\n            log.error(\"didn't find service with ID=\" + appl_id + \" to fetch state from\");\n        }\n        else {\n            StateTransferInfo tmp_info=info.copy();\n            tmp_info.state_id=substate_id;\n            Event tmpEvt=new Event(evt.getType(), tmp_info);\n            passToMuxChannel(mux_ch, tmpEvt, fifo_queue, state_sender, appl_id, false);\n        }\n    }","id":95642,"modified_method":"private void handleStateResponse(Event evt) {\n        StateTransferInfo info=(StateTransferInfo)evt.getArg();\n        MuxChannel mux_ch;\n        Address state_sender=info.target;\n\n        String appl_id, substate_id, tmp;\n        tmp=info.state_id;\n\n        if(tmp == null) {\n            if(log.isTraceEnabled())\n                log.trace(\"state is null, not passing up: \" + info);\n            return;\n        }\n\n        int index=tmp.indexOf(SEPARATOR);\n        if(index > -1) {\n            appl_id=tmp.substring(0, index);\n            substate_id=tmp.substring(index+SEPARATOR_LEN);\n        }\n        else {\n            appl_id=tmp;\n            substate_id=null;\n        }\n\n        mux_ch=services.get(appl_id);\n        if (mux_ch == null){\n           log.error(\"State receiver \" + channel.getLocalAddress()\n                 + \" does not have service with id \" + appl_id);\n        }\n        else {\n            StateTransferInfo tmp_info=info.copy();\n            tmp_info.state_id=substate_id;\n            Event tmpEvt=new Event(evt.getType(), tmp_info);\n            passToMuxChannel(mux_ch, tmpEvt, fifo_queue, state_sender, appl_id, false);\n        }\n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleServiceUp(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean added=false;\n\n        // discard if we sent this message\n        if(received && host != null && local_addr != null && local_addr.equals(host)) {\n            return;\n        }\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null) {\n                hosts=new ArrayList<Address>();\n                service_state.put(service,  hosts);\n            }\n            if(!hosts.contains(host)) {\n                hosts.add(host);\n                added=true;\n            }\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(added){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);\n                passToMuxChannel(ch, view_evt, fifo_queue, null, service, false);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }        \n    }","id":95643,"modified_method":"private void handleServiceUp(String service, Address host, boolean received) {\n        List<Address>    hosts, hosts_copy;\n        boolean added=false;\n\n        synchronized(service_state) {\n            hosts=service_state.get(service);\n            if(hosts == null) {\n                hosts=new ArrayList<Address>();\n                service_state.put(service,  hosts);\n            }\n            if(!hosts.contains(host)) {\n                hosts.add(host);\n                added=true;\n            }\n            hosts_copy=new ArrayList<Address>(hosts); // make a copy so we don't modify hosts in generateServiceView()\n        }\n\n        if(added){\n            View service_view = generateServiceView(hosts_copy);\n            MuxChannel ch = services.get(service);\n            if(ch != null){\n                Event view_evt = new Event(Event.VIEW_CHANGE, service_view);     \n                //we cannot pass service message to thread pool since we have\n                //to FIFO order service messages with BLOCK/UNBLOCK messages\n                //therefore all of them have to bypass thread pool\n                passToMuxChannel(ch, view_evt, fifo_queue, null, service, false,true);\n            }else{\n                if(log.isTraceEnabled())\n                    log.trace(\"service \" + service\n                              + \" not found, cannot dispatch service view \"\n                              + service_view);\n            }\n        }        \n    }","commit_id":"75a05953a03bf2b33877934106122c97099e59aa","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void populateModules( DecorationModel decorationModel, Locale locale, boolean keepInheritedRefs )\n        throws MojoExecutionException\n    {\n        Menu menu = decorationModel.getMenuRef( \"modules\" );\n\n        if ( menu != null )\n        {\n            if ( !keepInheritedRefs || !menu.isInheritAsRef() )\n            {\n                // we require child modules and reactors to process module menu\n                if ( project.getModules().size() > 0 )\n                {\n                    List projects = this.reactorProjects;\n\n                    menu.setName( i18n.getString( \"site-plugin\", locale, \"report.menu.projectmodules\" ) );\n\n                    if ( projects.size() == 1 )\n                    {\n                        getLog().debug( \"Attempting to source module information from local filesystem\" );\n\n                        // Not running reactor - search for the projects manually\n                        List models = new ArrayList( project.getModules().size() );\n                        for ( Iterator i = project.getModules().iterator(); i.hasNext(); )\n                        {\n                            String module = (String) i.next();\n                            Model model;\n                            File f = new File( project.getBasedir(), module + \"/pom.xml\" );\n                            if ( f.exists() )\n                            {\n                                try\n                                {\n                                    model = mavenProjectBuilder.build( f, localRepository, null ).getModel();\n                                }\n                                catch ( ProjectBuildingException e )\n                                {\n                                    throw new MojoExecutionException( \"Unable to read local module-POM\", e );\n                                }\n                            }\n                            else\n                            {\n                                getLog().warn( \"No filesystem module-POM available\" );\n\n                                model = new Model();\n                                model.setName( module );\n                                model.setUrl( module );\n                            }\n                            models.add( model );\n                        }\n                        populateModulesMenuItemsFromModels( models, menu );\n                    }\n                    else\n                    {\n                        populateModulesMenuItemsFromReactorProjects( menu );\n                    }\n                }\n                else\n                {\n                    decorationModel.removeMenuRef( \"modules\" );\n                }\n            }\n        }\n    }","id":95644,"modified_method":"protected void populateModules( DecorationModel decorationModel, Locale locale, boolean keepInheritedRefs )\n        throws MojoExecutionException\n    {\n        Menu menu = decorationModel.getMenuRef( \"modules\" );\n\n        if ( menu != null )\n        {\n            if ( !keepInheritedRefs || !menu.isInheritAsRef() )\n            {\n                // we require child modules and reactors to process module menu\n                if ( project.getModules().size() > 0 )\n                {\n                    List projects = this.reactorProjects;\n\n                    if ( menu.getName() == null )\n                    {\n                        menu.setName( i18n.getString( \"site-plugin\", locale, \"report.menu.projectmodules\" ) );\n                    }\n\n                    if ( projects.size() == 1 )\n                    {\n                        getLog().debug( \"Attempting to source module information from local filesystem\" );\n\n                        // Not running reactor - search for the projects manually\n                        List models = new ArrayList( project.getModules().size() );\n                        for ( Iterator i = project.getModules().iterator(); i.hasNext(); )\n                        {\n                            String module = (String) i.next();\n                            Model model;\n                            File f = new File( project.getBasedir(), module + \"/pom.xml\" );\n                            if ( f.exists() )\n                            {\n                                try\n                                {\n                                    model = mavenProjectBuilder.build( f, localRepository, null ).getModel();\n                                }\n                                catch ( ProjectBuildingException e )\n                                {\n                                    throw new MojoExecutionException( \"Unable to read local module-POM\", e );\n                                }\n                            }\n                            else\n                            {\n                                getLog().warn( \"No filesystem module-POM available\" );\n\n                                model = new Model();\n                                model.setName( module );\n                                model.setUrl( module );\n                            }\n                            models.add( model );\n                        }\n                        populateModulesMenuItemsFromModels( models, menu );\n                    }\n                    else\n                    {\n                        populateModulesMenuItemsFromReactorProjects( menu );\n                    }\n                }\n                else\n                {\n                    decorationModel.removeMenuRef( \"modules\" );\n                }\n            }\n        }\n    }","commit_id":"5452761c2d71c035970fa26207c298cffe4bc8fa","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void populateProjectParentMenu( DecorationModel decorationModel, Locale locale,\n                                              MavenProject parentProject, boolean keepInheritedRefs )\n    {\n        Menu menu = decorationModel.getMenuRef( \"parent\" );\n\n        if ( menu != null )\n        {\n            if ( !keepInheritedRefs || !menu.isInheritAsRef() )\n            {\n                String parentUrl = parentProject.getUrl();\n\n                if ( parentUrl != null )\n                {\n                    if ( parentUrl.endsWith( \"/\" ) )\n                    {\n                        parentUrl += \"index.html\";\n                    }\n                    else\n                    {\n                        parentUrl += \"/index.html\";\n                    }\n\n                    parentUrl = getRelativePath( parentUrl, project.getUrl() );\n\n                    menu.setName( i18n.getString( \"site-plugin\", locale, \"report.menu.parentproject\" ) );\n\n                    MenuItem item = new MenuItem();\n                    item.setName( parentProject.getName() );\n                    item.setHref( parentUrl );\n                    menu.addItem( item );\n                }\n                else\n                {\n                    decorationModel.removeMenuRef( \"parent\" );\n                }\n            }\n        }\n    }","id":95645,"modified_method":"protected void populateProjectParentMenu( DecorationModel decorationModel, Locale locale,\n                                              MavenProject parentProject, boolean keepInheritedRefs )\n    {\n        Menu menu = decorationModel.getMenuRef( \"parent\" );\n\n        if ( menu != null )\n        {\n            if ( !keepInheritedRefs || !menu.isInheritAsRef() )\n            {\n                String parentUrl = parentProject.getUrl();\n\n                if ( parentUrl != null )\n                {\n                    if ( parentUrl.endsWith( \"/\" ) )\n                    {\n                        parentUrl += \"index.html\";\n                    }\n                    else\n                    {\n                        parentUrl += \"/index.html\";\n                    }\n\n                    parentUrl = getRelativePath( parentUrl, project.getUrl() );\n\n                    if ( menu.getName() == null )\n                    {\n                        menu.setName( i18n.getString( \"site-plugin\", locale, \"report.menu.parentproject\" ) );\n                    }\n\n                    MenuItem item = new MenuItem();\n                    item.setName( parentProject.getName() );\n                    item.setHref( parentUrl );\n                    menu.addItem( item );\n                }\n                else\n                {\n                    decorationModel.removeMenuRef( \"parent\" );\n                }\n            }\n        }\n    }","commit_id":"5452761c2d71c035970fa26207c298cffe4bc8fa","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n\t * Servlets and Filters are treated essentially the same with Wicket. This is the entry point\n\t * for both of them.\n\t * \n\t * @see #init(FilterConfig)\n\t * \n\t * @param isServlet\n\t *            True if Servlet, false if Filter\n\t * @param filterConfig\n\t * @throws ServletException\n\t */\n\tpublic void init(final boolean isServlet, final FilterConfig filterConfig)\n\t\tthrows ServletException\n\t{\n\t\tthis.filterConfig = filterConfig;\n\t\tthis.isServlet = isServlet;\n\t\tinitIgnorePaths(filterConfig);\n\n\t\tfinal ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n\t\tfinal ClassLoader newClassLoader = getClassLoader();\n\t\ttry\n\t\t{\n\t\t\tif (previousClassLoader != newClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(newClassLoader);\n\t\t\t}\n\n\t\t\t// locate application instance unless it was already specified during construction\n\t\t\tif (application == null)\n\t\t\t{\n\t\t\t\tapplicationFactory = getApplicationFactory();\n\t\t\t\tapplication = applicationFactory.createApplication(this);\n\t\t\t}\n\n\t\t\tapplication.setName(filterConfig.getFilterName());\n\t\t\tapplication.setWicketFilter(this);\n\n\t\t\t// Allow the filterPath to be preset via setFilterPath()\n\t\t\tString configureFilterPath = getFilterPath();\n\n\t\t\tif (configureFilterPath == null)\n\t\t\t{\n\t\t\t\tconfigureFilterPath = getFilterPathFromConfig(filterConfig);\n\n\t\t\t\tif (configureFilterPath == null)\n\t\t\t\t{\n\t\t\t\t\tconfigureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);\n\n\t\t\t\t\tif (configureFilterPath == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tconfigureFilterPath = getFilterPathFromAnnotation(isServlet);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (configureFilterPath != null)\n\t\t\t\t{\n\t\t\t\t\tsetFilterPath(configureFilterPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getFilterPath() == null)\n\t\t\t{\n\t\t\t\tlog.warn(\"Unable to determine filter path from filter init-param, web.xml, \"\n\t\t\t\t\t+ \"or servlet 3.0 annotations. Assuming user will set filter path \"\n\t\t\t\t\t+ \"manually by calling setFilterPath(String)\");\n\t\t\t}\n\n\t\t\tThreadContext.setApplication(application);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tapplication.initApplication();\n\n\t\t\t\t// Give the application the option to log that it is started\n\t\t\t\tapplication.logStarted();\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tThreadContext.detach();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\t// #destroy() might not be called by the web container when #init() fails,\n\t\t\t// so destroy now\n\t\t\tlog.error(String.format(\"The initialization of an application with name '%s' has failed.\",\n\t\t\t\t\tfilterConfig.getFilterName()), e);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdestroy();\n\t\t\t}\n\t\t\tcatch (Exception destroyException)\n\t\t\t{\n\t\t\t\tlog.error(\"Unable to destroy after initialization failure\", destroyException);\n\t\t\t}\n\n\t\t\tthrow new ServletException(e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (newClassLoader != previousClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(previousClassLoader);\n\t\t\t}\n\t\t}\n\t}","id":95646,"modified_method":"/**\n\t * Servlets and Filters are treated essentially the same with Wicket. This is the entry point\n\t * for both of them.\n\t * \n\t * @see #init(FilterConfig)\n\t * \n\t * @param isServlet\n\t *            True if Servlet, false if Filter\n\t * @param filterConfig\n\t * @throws ServletException\n\t */\n\tpublic void init(final boolean isServlet, final FilterConfig filterConfig)\n\t\tthrows ServletException\n\t{\n\t\tthis.filterConfig = filterConfig;\n\t\tthis.isServlet = isServlet;\n\t\tinitIgnorePaths(filterConfig);\n\n\t\tfinal ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n\t\tfinal ClassLoader newClassLoader = getClassLoader();\n\t\ttry\n\t\t{\n\t\t\tif (previousClassLoader != newClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(newClassLoader);\n\t\t\t}\n\n\t\t\t// locate application instance unless it was already specified during construction\n\t\t\tif (application == null)\n\t\t\t{\n\t\t\t\tapplicationFactory = getApplicationFactory();\n\t\t\t\tapplication = applicationFactory.createApplication(this);\n\t\t\t}\n\n\t\t\tif (application.getName() == null)\n\t\t\t{\n\t\t\t\tapplication.setName(filterConfig.getFilterName());\n\t\t\t}\n\t\t\tapplication.setWicketFilter(this);\n\n\t\t\t// Allow the filterPath to be preset via setFilterPath()\n\t\t\tString configureFilterPath = getFilterPath();\n\n\t\t\tif (configureFilterPath == null)\n\t\t\t{\n\t\t\t\tconfigureFilterPath = getFilterPathFromConfig(filterConfig);\n\n\t\t\t\tif (configureFilterPath == null)\n\t\t\t\t{\n\t\t\t\t\tconfigureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);\n\n\t\t\t\t\tif (configureFilterPath == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tconfigureFilterPath = getFilterPathFromAnnotation(isServlet);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (configureFilterPath != null)\n\t\t\t\t{\n\t\t\t\t\tsetFilterPath(configureFilterPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getFilterPath() == null)\n\t\t\t{\n\t\t\t\tlog.warn(\"Unable to determine filter path from filter init-param, web.xml, \"\n\t\t\t\t\t+ \"or servlet 3.0 annotations. Assuming user will set filter path \"\n\t\t\t\t\t+ \"manually by calling setFilterPath(String)\");\n\t\t\t}\n\n\t\t\tThreadContext.setApplication(application);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tapplication.initApplication();\n\n\t\t\t\t// Give the application the option to log that it is started\n\t\t\t\tapplication.logStarted();\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tThreadContext.detach();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\t// #destroy() might not be called by the web container when #init() fails,\n\t\t\t// so destroy now\n\t\t\tlog.error(String.format(\"The initialization of an application with name '%s' has failed.\",\n\t\t\t\t\tfilterConfig.getFilterName()), e);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdestroy();\n\t\t\t}\n\t\t\tcatch (Exception destroyException)\n\t\t\t{\n\t\t\t\tlog.error(\"Unable to destroy after initialization failure\", destroyException);\n\t\t\t}\n\n\t\t\tthrow new ServletException(e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (newClassLoader != previousClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(previousClassLoader);\n\t\t\t}\n\t\t}\n\t}","commit_id":"792a0a4138aad61dfe63c8bace96648878767003","url":"https://github.com/apache/wicket"},{"original_method":"private void addCallToSuperMethod(@NotNull List<JsExpression> arguments, JsFunction initializer) {\n        JsName ref = context().scope().declareName(Namer.CALLEE_NAME);\n        initializer.setName(ref);\n        JsInvocation call = new JsInvocation(Namer.getFunctionCallRef(Namer.superMethodNameRef(ref)));\n        call.getArguments().add(JsLiteral.THIS);\n        call.getArguments().addAll(arguments);\n        initializerStatements.add(0, call.makeStmt());\n    }","id":95647,"modified_method":"private void addCallToSuperMethod(@NotNull List<JsExpression> arguments, JsFunction initializer) {\n        if (initializer.getName() == null) {\n            JsName ref = context().scope().declareName(Namer.CALLEE_NAME);\n            initializer.setName(ref);\n        }\n\n        JsInvocation call = new JsInvocation(Namer.getFunctionCallRef(Namer.superMethodNameRef(initializer.getName())));\n        call.getArguments().add(JsLiteral.THIS);\n        call.getArguments().addAll(arguments);\n        initializerStatements.add(0, call.makeStmt());\n    }","commit_id":"e7eb35b169e2b428831d6f8cbe2c92cb4c583081","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static JsFunction createInitFunction(KtClassOrObject declaration, TranslationContext context) {\n        //TODO: it's inconsistent that we have scope for class and function for constructor, currently have problems implementing better way\n        ClassDescriptor classDescriptor = getClassDescriptor(context.bindingContext(), declaration);\n        ConstructorDescriptor primaryConstructor = classDescriptor.getUnsubstitutedPrimaryConstructor();\n\n        if (primaryConstructor != null) {\n            return context.getFunctionObject(primaryConstructor);\n        }\n        else {\n            return new JsFunction(context.scope(), new JsBlock(), \"fake constructor for \" + classDescriptor.getName().asString());\n        }\n    }","id":95648,"modified_method":"@NotNull\n    private static JsFunction createInitFunction(KtClassOrObject declaration, TranslationContext context) {\n        //TODO: it's inconsistent that we have scope for class and function for constructor, currently have problems implementing better way\n        ClassDescriptor classDescriptor = getClassDescriptor(context.bindingContext(), declaration);\n        ConstructorDescriptor primaryConstructor = classDescriptor.getUnsubstitutedPrimaryConstructor();\n\n        Name name = classDescriptor.getName();\n\n        JsFunction ctorFunction;\n        if (primaryConstructor != null) {\n            ctorFunction = context.getFunctionObject(primaryConstructor);\n        }\n        else {\n            ctorFunction = new JsFunction(context.scope(), new JsBlock(), \"fake constructor for \" + name.asString());\n        }\n\n        // TODO use name from JsName when class annotated by that\n        if (!name.isSpecial()) {\n            ctorFunction.setName(ctorFunction.getScope().declareName(name.asString()));\n        }\n\n        return ctorFunction;\n    }","commit_id":"e7eb35b169e2b428831d6f8cbe2c92cb4c583081","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private Object readDslObject()\n\t\t\tthrows DSLException {\n\t\ttry {\n\t\t\tinit();\n\t\t} catch (final IOException e) {\n\t\t\tthrow new DSLException(\"Failed to initialize DSL Reader: \" + e.getMessage(), e);\n\t\t}\n\n\t\tLinkedHashMap<Object, Object> properties = null;\n\t\ttry {\n\t\t\tproperties = createDSLProperties();\n\t\t} catch (final Exception e) {\n\t\t\t// catching exception here, as groovy config slurper may throw just\n\t\t\t// about anything\n\t\t\tthrow new IllegalArgumentException(\"Failed to load properties file \" + this.propertiesFile, e);\n\t\t}\n\n\t\tClusterInfo clusterInfoToUseInGsc = this.clusterInfo;\n\t\tif (clusterInfoToUseInGsc == null) {\n\t\t\tclusterInfoToUseInGsc = new ClusterInfo(null, 1, 0, 1, 0);\n\t\t}\n\n\t\t// create an uninitialized service context\n\t\tif (this.createServiceContext) {\n\t\t\tif (isRunningInGSC) {\n\t\t\t\tthis.context = new ServiceContextImpl(clusterInfoToUseInGsc);\n\t\t\t} else {\n\t\t\t\tthis.context = new ServiceContextImpl(new ClusterInfo(null, 1, 0, 1, 0));\n\t\t\t}\n\n\t\t}\n\t\t// create the groovy shell, loaded with our settings\n\t\tfinal GroovyShell gs = createGroovyShell(properties);\n\t\tfinal Object result = evaluateGroovyScript(gs);\n\n\t\tif (this.createServiceContext) {\n\t\t\tif (!(result instanceof Service)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The DSL reader cannot create a service context to a DSL that does not evaluate to a Sevice. \"\n\t\t\t\t\t\t\t\t+ \"Set the 'createServiceContext' option to false if you do not need a service conext\");\n\t\t\t}\n\n\t\t\tif (isRunningInGSC) {\n\t\t\t\tclusterInfoToUseInGsc.setName(ServiceUtils.getAbsolutePUName(\n\t\t\t\t\t\tCloudifyConstants.DEFAULT_APPLICATION_NAME, ((Service) result).getName()));\n\t\t\t\tthis.context.init((Service) result, admin, workDir.getAbsolutePath(), clusterInfoToUseInGsc);\n\t\t\t} else {\n\t\t\t\tthis.context.initInIntegratedContainer((Service) result, workDir.getAbsolutePath());\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t}","id":95649,"modified_method":"private Object readDslObject()\n\t\t\tthrows DSLException {\n\t\ttry {\n\t\t\tinit();\n\t\t} catch (final IOException e) {\n\t\t\tthrow new DSLException(\"Failed to initialize DSL Reader: \" + e.getMessage(), e);\n\t\t}\n\n\t\tLinkedHashMap<Object, Object> properties = null;\n\t\ttry {\n\t\t\tproperties = createDSLProperties();\n\t\t} catch (final Exception e) {\n\t\t\t// catching exception here, as groovy config slurper may throw just\n\t\t\t// about anything\n\t\t\tthrow new IllegalArgumentException(\"Failed to load properties file \" + this.propertiesFile, e);\n\t\t}\n\n\t\tClusterInfo clusterInfoToUseInGsc = this.clusterInfo;\n\t\tif (clusterInfoToUseInGsc == null) {\n\t\t\tclusterInfoToUseInGsc = new ClusterInfo(null, 1, 0, 1, 0);\n\t\t}\n\n\t\t// create an uninitialized service context\n\t\tif (this.createServiceContext) {\n\t\t\tif (isRunningInGSC) {\n\t\t\t\tthis.context = new ServiceContextImpl(clusterInfoToUseInGsc);\n\t\t\t} else {\n\t\t\t\tthis.context = new ServiceContextImpl(new ClusterInfo(null, 1, 0, 1, 0));\n\t\t\t}\n\n\t\t}\n\t\t// create the groovy shell, loaded with our settings\n\t\tfinal GroovyShell gs = createGroovyShell(properties);\n\t\tfinal Object result = evaluateGroovyScript(gs);\n\n\t\tif (this.createServiceContext) {\n\t\t\tif (!(result instanceof Service)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"The DSL reader cannot create a service context to a DSL that does not evaluate to a Sevice. \"\n\t\t\t\t\t\t\t\t+ \"Set the 'createServiceContext' option to false if you do not need a service conext\");\n\t\t\t}\n\n\t\t\tif (isRunningInGSC) {\n\t\t\t\tif (clusterInfoToUseInGsc.getName() == null) {\n\t\t\t\t\tclusterInfoToUseInGsc.setName(ServiceUtils.getAbsolutePUName(\n\t\t\t\t\t\t\tCloudifyConstants.DEFAULT_APPLICATION_NAME, ((Service) result).getName()));\n\t\t\t\t}\n\t\t\t\tthis.context.init((Service) result, admin, workDir.getAbsolutePath(), clusterInfoToUseInGsc);\n\t\t\t} else {\n\t\t\t\tthis.context.initInIntegratedContainer((Service) result, workDir.getAbsolutePath());\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t}","commit_id":"9337e4c7002aece06f1ece024d9fa305322604c7","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n    public Set<SModel> getAutoImportedModels(Language contextLanguage, SModel model) {\n      Set<SModel> result = new LinkedHashSet<SModel>();\n\n      LanguageAspect aspect = Language.getModelAspect(model);\n\n      if (aspect != LanguageAspect.STRUCTURE && contextLanguage.getStructureModelDescriptor() != null) {\n        result.add(contextLanguage.getStructureModelDescriptor());\n      }\n\n//      if (aspect != LanguageAspect.CONSTRAINTS && LanguageAspect.CONSTRAINTS.get(contextLanguage) != null) {\n//        result.add(LanguageAspect.CONSTRAINTS.get(contextLanguage));\n//      }\n\n      if (aspect != LanguageAspect.BEHAVIOR && LanguageAspect.BEHAVIOR.get(contextLanguage) != null) {\n        result.add(LanguageAspect.BEHAVIOR.get(contextLanguage));\n      }\n\n      for (Language extended : ModuleUtil.refsToLanguages(contextLanguage.getExtendedLanguageRefs())) {\n        SModelDescriptor structure = LanguageAspect.STRUCTURE.get(extended);\n        if (structure != null) {\n          result.add(structure);\n        }\n//        if (LanguageAspect.CONSTRAINTS.get(extended) != null) {\n//          result.add(LanguageAspect.CONSTRAINTS.get(extended));\n//        }\n\n        if (aspect != null && aspect.get(extended) != null) {\n          result.add(aspect.get(extended));\n        }\n      }\n\n      return result;\n    }","id":95650,"modified_method":"@Override\n    public Set<SModel> getAutoImportedModels(Language contextLanguage, SModel model) {\n      Set<SModel> result = new LinkedHashSet<SModel>();\n\n      LanguageAspect aspect = Language.getModelAspect(model);\n\n      if (aspect != LanguageAspect.STRUCTURE && contextLanguage.getStructureModelDescriptor() != null) {\n        result.add(contextLanguage.getStructureModelDescriptor());\n      }\n\n      for (Language extended : ModuleUtil.refsToLanguages(contextLanguage.getExtendedLanguageRefs())) {\n        SModelDescriptor structure = LanguageAspect.STRUCTURE.get(extended);\n        if (structure != null) {\n          result.add(structure);\n        }\n\n        if (aspect != null && aspect.get(extended) != null) {\n          result.add(aspect.get(extended));\n        }\n      }\n\n      return result;\n    }","commit_id":"84f57c5cc03640c3fe7ba65bf863b9a0634f7350","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Set<Language> getAutoImportedLanguages(Language contextLanguage, SModel model) {\n      Set<Language> result = new LinkedHashSet<Language>();\n\n      LanguageAspect aspect = Language.getModelAspect(model);\n      if (aspect != null) {\n        result.add(ScopeOperations.resolveLanguage(GlobalScope.getInstance(), aspect.getMainLanguage()));\n      }\n\n      return result;\n    }","id":95651,"modified_method":"@Override\n    public Set<Language> getAutoImportedLanguages(Language contextLanguage, SModel model) {\n      LanguageAspect aspect = Language.getModelAspect(model);\n      if (aspect != null) {\n        return Collections.singleton(ScopeOperations.resolveLanguage(GlobalScope.getInstance(), aspect.getMainLanguage()));\n      } else {\n        return Collections.emptySet();\n      }\n    }","commit_id":"84f57c5cc03640c3fe7ba65bf863b9a0634f7350","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * sorts by group:name:version mostly.\n     * If requested matches selected then it will override the version comparison\n     * so that the dependency that was selected is more prominent.\n     */\n    public static Collection<DependencyResult> sort(Collection<DependencyResult> input) {\n        //dependencies with the same 'requested' should be presented in a single tree\n        final Set<ModuleVersionSelector> uniqueRequested = new HashSet<ModuleVersionSelector>();\n        List<DependencyResult> out = CollectionUtils.filter(input, new LinkedList<DependencyResult>(), new Spec<DependencyResult>() {\n            public boolean isSatisfiedBy(DependencyResult element) {\n                return uniqueRequested.add(element.getRequested());\n            }\n        });\n        Collections.sort(out, new DependencyComparator());\n        return out;\n    }","id":95652,"modified_method":"/**\n     * sorts by group:name:version mostly.\n     * If requested matches selected then it will override the version comparison\n     * so that the dependency that was selected is more prominent.\n     */\n    public static Collection<DependencyResult> sort(Collection<DependencyResult> input) {\n        List<DependencyResult> out = new ArrayList<DependencyResult>(input);\n        Collections.sort(out, new DependencyComparator());\n        return out;\n    }","commit_id":"172d5cbfbc410456dc43c03e67b964015ea40c5b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleVersionSelector getRequested() {\n        return dependency.getRequested();\n    }","id":95653,"modified_method":"@Override\n    public ModuleVersionSelector getRequested() {\n        return dependency.getRequested();\n    }","commit_id":"172d5cbfbc410456dc43c03e67b964015ea40c5b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleVersionIdentifier getActual() {\n        return dependency.getSelected().getId();\n    }","id":95654,"modified_method":"@Override\n    public ModuleVersionIdentifier getActual() {\n        return dependency.getSelected().getId();\n    }","commit_id":"172d5cbfbc410456dc43c03e67b964015ea40c5b","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<RenderableDependency> getChildren() {\n        Set<RenderableDependency> out = new LinkedHashSet<RenderableDependency>();\n        for (DependencyResult d : dependency.getSelected().getDependents()) {\n            //we want only the dependents that match the requested\n            if (d.getRequested().equals(dependency.getRequested())) {\n                out.add(new InvertedRenderableModuleResult(d.getFrom()));\n            }\n        }\n\n        return out;\n    }","id":95655,"modified_method":"public Set<? extends RenderableDependency> getChildren() {\n        return Collections.singleton(new InvertedRenderableModuleResult(dependency.getFrom()));\n    }","commit_id":"172d5cbfbc410456dc43c03e67b964015ea40c5b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleVersionSelector getRequested() {\n        return dependency.getRequested();\n    }","id":95656,"modified_method":"@Override\n    public ModuleVersionSelector getRequested() {\n        return dependency.getRequested();\n    }","commit_id":"172d5cbfbc410456dc43c03e67b964015ea40c5b","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<RenderableDependency> getChildren() {\n        Set<RenderableDependency> out = new LinkedHashSet<RenderableDependency>();\n        for (DependencyResult d : dependency.getSelected().getDependents()) {\n            //we want only the dependents that match the requested\n            if (d.getRequested().equals(dependency.getRequested())) {\n                out.add(new InvertedRenderableModuleResult(d.getFrom()));\n            }\n        }\n\n        return out;\n    }","id":95657,"modified_method":"public Set<? extends RenderableDependency> getChildren() {\n        return Collections.singleton(new InvertedRenderableModuleResult(dependency.getFrom()));\n    }","commit_id":"172d5cbfbc410456dc43c03e67b964015ea40c5b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ModuleVersionIdentifier getActual() {\n        return actual;\n    }","id":95658,"modified_method":"@Override\n    public ModuleVersionIdentifier getActual() {\n        return actual;\n    }","commit_id":"172d5cbfbc410456dc43c03e67b964015ea40c5b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public Set<String> supportedBackends() {\n        HashSet<String> result = new HashSet<String>();\n        result.add(Backend.Java.nativeAnnotation);\n        result.add(Backend.None.nativeAnnotation);\n        return result;\n    }","id":95659,"modified_method":"@Override\n    public Set<String> supportedBackends() {\n        return Collections.singleton(Backend.Java.nativeAnnotation);\n    }","commit_id":"ab17da1fe91d84d1c818ba991f5187e1fe512a4f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void withStream(List<String> stream, final List<String> activeFilters) {\n        activeFilters.addAll(stream.stream().filter(String::isEmpty).collect(Collectors.toList()));\n    }","id":95660,"modified_method":"private void withStream(List<String> stream, final List<String> activeFilters) {\n        stream.stream().filter(String::isEmpty).forEach(activeFilters::add);\n    }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void collectNames(List<Person> persons){\n    List<String> names = foo();\n      names.addAll(persons.stream().map(Person::getName).collect(Collectors.toList()));\n  }","id":95661,"modified_method":"void collectNames(List<Person> persons){\n    List<String> names = foo();\n      persons.stream().map(Person::getName).forEach(names::add);\n  }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void collectNames(List<Person> persons){\n      names.addAll(persons.stream().map(Person::getName).collect(Collectors.toList()));\n  }","id":95662,"modified_method":"void collectNames(List<Person> persons){\n      persons.stream().map(Person::getName).forEach(names::add);\n  }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void collectNames(List<Person> persons, Set<String> names){\n      names.addAll(persons.stream().map(Person::getName).collect(Collectors.toList()));\n  }","id":95663,"modified_method":"void collectNames(List<Person> persons, Set<String> names){\n      persons.stream().map(Person::getName).forEach(names::add);\n  }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void collectNames(List<Person> persons){\n    List<String> names = new ArrayList<>(), otherNames = new ArrayList<>(names);\n      names.addAll(persons.stream().map(Person::getName).collect(Collectors.toList()));\n  }","id":95664,"modified_method":"void collectNames(List<Person> persons){\n    List<String> names = new ArrayList<>(), otherNames = new ArrayList<>(names);\n      persons.stream().map(Person::getName).forEach(names::add);\n  }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void collectNames(List<Person> persons){\n      addAll(persons.stream().map(Person::getName).collect(Collectors.toList()));\n  }","id":95665,"modified_method":"void collectNames(List<Person> persons){\n      persons.stream().map(Person::getName).forEach(this::add);\n  }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void some(List<String> from, List<Integer> to) {\n      to.addAll(from.stream().map(String::length).collect(Collectors.toList()));\n  }","id":95666,"modified_method":"public void some(List<String> from, List<Integer> to) {\n      from.stream().map(String::length).forEach(to::add);\n  }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    void migrate(@NotNull Project project,\n                 @NotNull ProblemDescriptor descriptor,\n                 @NotNull PsiForeachStatement foreachStatement,\n                 @NotNull PsiExpression iteratedValue,\n                 @NotNull PsiStatement body,\n                 @NotNull TerminalBlock tb,\n                 @NotNull List<String> intermediateOps) {\n      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n      final PsiType iteratedValueType = iteratedValue.getType();\n      final PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n\n      if (methodCallExpression == null) return;\n\n      restoreComments(foreachStatement, body);\n      if (intermediateOps.isEmpty() && isAddAllCall(tb)) {\n        final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n        final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() : \"\";\n        final String collectionText =\n          iteratedValueType instanceof PsiArrayType ? \"java.util.Arrays.asList(\" + iteratedValue.getText() + \")\" :\n          getIteratedValueText(iteratedValue);\n        final String callText = StringUtil.getQualifiedName(qualifierText, \"addAll(\" + collectionText + \");\");\n        PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n        simplifyAndFormat(project, result);\n        return;\n      }\n      intermediateOps\n        .add(createMapperFunctionalExpressionText(tb.getVariable(), methodCallExpression.getArgumentList().getExpressions()[0]));\n      final StringBuilder builder = generateStream(iteratedValue, intermediateOps);\n\n      builder.append(\".collect(java.util.stream.Collectors.\");\n      final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n      if (qualifierExpression instanceof PsiReferenceExpression) {\n        final PsiElement resolve = ((PsiReferenceExpression)qualifierExpression).resolve();\n        if (resolve instanceof PsiLocalVariable) {\n          PsiLocalVariable var = (PsiLocalVariable)resolve;\n          if (isDeclarationJustBefore(var, foreachStatement)) {\n            final PsiExpression initializer = var.getInitializer();\n            if (initializer instanceof PsiNewExpression) {\n              final PsiExpressionList argumentList = ((PsiNewExpression)initializer).getArgumentList();\n              if (argumentList != null && argumentList.getExpressions().length == 0) {\n                final String callText = builder.toString() + createInitializerReplacementText(var.getType(), initializer) + \")\";\n                PsiElement result = initializer.replace(elementFactory.createExpressionFromText(callText, null));\n                simplifyAndFormat(project, result);\n                foreachStatement.delete();\n                return;\n              }\n            }\n          }\n        }\n      }\n      final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() : \"\";\n      final String callText = StringUtil.getQualifiedName(qualifierText, \"addAll(\" + builder.toString() + \"toList()));\");\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n      simplifyAndFormat(project, result);\n    }","id":95667,"modified_method":"protected ReplaceWithCollectFix(String methodName) {\n      myMethodName = methodName;\n    }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    return new JavaElementVisitor() {\n      @Override\n      public void visitForeachStatement(PsiForeachStatement statement) {\n        super.visitForeachStatement(statement);\n        if (PsiUtil.getLanguageLevel(statement).isAtLeast(LanguageLevel.JDK_1_8)) {\n          final PsiExpression iteratedValue = statement.getIteratedValue();\n          final PsiStatement body = statement.getBody();\n          if (iteratedValue != null && body != null) {\n            final PsiType iteratedValueType = iteratedValue.getType();\n            final PsiClass iteratorClass = PsiUtil.resolveClassInClassTypeOnly(iteratedValueType);\n            PsiClass collectionClass = null;\n            final boolean isArray;\n            if(iteratedValueType instanceof PsiArrayType) {\n              // Do not handle primitive types now\n              if(((PsiArrayType)iteratedValueType).getComponentType() instanceof PsiPrimitiveType) return;\n              isArray = true;\n            } else {\n              collectionClass = JavaPsiFacade.getInstance(body.getProject()).findClass(CommonClassNames.JAVA_UTIL_COLLECTION, statement.getResolveScope());\n              if (collectionClass != null && InheritanceUtil.isInheritorOrSelf(iteratorClass, collectionClass, true)) {\n                isArray = false;\n              } else return;\n            }\n            try {\n              final ControlFlow controlFlow = ControlFlowFactory.getInstance(holder.getProject())\n                .getControlFlow(body, LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());\n              int startOffset = controlFlow.getStartOffset(body);\n              int endOffset = controlFlow.getEndOffset(body);\n              final Collection<PsiStatement> exitPoints = ControlFlowUtil\n                .findExitPointsAndStatements(controlFlow, startOffset, endOffset, new IntArrayList(), PsiContinueStatement.class,\n                                             PsiBreakStatement.class, PsiReturnStatement.class, PsiThrowStatement.class);\n              if (exitPoints.isEmpty()) {\n\n                if (ExceptionUtil.getThrownCheckedExceptions(new PsiElement[]{body}).isEmpty()) {\n                  TerminalBlock tb = TerminalBlock.from(statement.getIterationParameter(), body);\n                  List<Operation> operations = tb.extractOperations();\n\n                  final List<PsiVariable> nonFinalVariables = ControlFlowUtil.getUsedVariables(controlFlow, startOffset, endOffset)\n                    .stream().filter(variable -> !HighlightControlFlowUtil.isEffectivelyFinal(variable, body, null))\n                    .collect(Collectors.toList());\n\n                  if(getIncrementedVariable(tb, operations, nonFinalVariables) != null) {\n                    holder.registerProblem(iteratedValue, \"Can be replaced with count() call\",\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           new ReplaceWithCountFix());\n                  }\n                  if(getAccumulatedVariable(tb, operations, nonFinalVariables) != null) {\n                    holder.registerProblem(iteratedValue, \"Can be replaced with sum() call\",\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           new ReplaceWithSumFix());\n                  }\n                  if(!nonFinalVariables.isEmpty()) {\n                    return;\n                  }\n                  if ((isArray || !isRawSubstitution(iteratedValueType, collectionClass)) && isCollectCall(tb, operations)) {\n                    boolean addAll = operations.isEmpty() && isAddAllCall(tb);\n                    holder.registerProblem(iteratedValue, \"Can be replaced with \" + (addAll ? \"addAll call\" : \"collect call\"),\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           addAll ? new ReplaceWithAddAllFix() : new ReplaceWithCollectFix());\n                  }\n                  // do not replace for(T e : arr) {} with Arrays.stream(arr).forEach(e -> {}) even if flag is set\n                  else if (!operations.isEmpty() ||\n                           (!isArray && (REPLACE_TRIVIAL_FOREACH || !isTrivial(body, statement.getIterationParameter())))) {\n                    final List<LocalQuickFix> fixes = new ArrayList<>();\n                    fixes.add(new ReplaceWithForeachCallFix(\"forEach\"));\n                    if (!operations.isEmpty()) {\n                      //for .stream()\n                      fixes.add(new ReplaceWithForeachCallFix(\"forEachOrdered\"));\n                    }\n                    holder.registerProblem(iteratedValue, \"Can be replaced with foreach call\",\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           fixes.toArray(new LocalQuickFix[fixes.size()]));\n                  }\n                }\n              }\n            }\n            catch (AnalysisCanceledException ignored) {\n            }\n          }\n        }\n      }\n\n      private boolean isRawSubstitution(PsiType iteratedValueType, PsiClass collectionClass) {\n        return iteratedValueType instanceof PsiClassType && PsiUtil\n          .isRawSubstitutor(collectionClass, TypeConversionUtil.getSuperClassSubstitutor(collectionClass, (PsiClassType)iteratedValueType));\n      }\n    };\n  }","id":95668,"modified_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    return new JavaElementVisitor() {\n      @Override\n      public void visitForeachStatement(PsiForeachStatement statement) {\n        super.visitForeachStatement(statement);\n        if (PsiUtil.getLanguageLevel(statement).isAtLeast(LanguageLevel.JDK_1_8)) {\n          final PsiExpression iteratedValue = statement.getIteratedValue();\n          final PsiStatement body = statement.getBody();\n          if (iteratedValue != null && body != null) {\n            final PsiType iteratedValueType = iteratedValue.getType();\n            final PsiClass iteratorClass = PsiUtil.resolveClassInClassTypeOnly(iteratedValueType);\n            PsiClass collectionClass = null;\n            final boolean isArray;\n            if(iteratedValueType instanceof PsiArrayType) {\n              // Do not handle primitive types now\n              if(((PsiArrayType)iteratedValueType).getComponentType() instanceof PsiPrimitiveType) return;\n              isArray = true;\n            } else {\n              collectionClass = JavaPsiFacade.getInstance(body.getProject()).findClass(CommonClassNames.JAVA_UTIL_COLLECTION, statement.getResolveScope());\n              if (collectionClass != null && InheritanceUtil.isInheritorOrSelf(iteratorClass, collectionClass, true)) {\n                isArray = false;\n              } else return;\n            }\n            try {\n              final ControlFlow controlFlow = ControlFlowFactory.getInstance(holder.getProject())\n                .getControlFlow(body, LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());\n              int startOffset = controlFlow.getStartOffset(body);\n              int endOffset = controlFlow.getEndOffset(body);\n              final Collection<PsiStatement> exitPoints = ControlFlowUtil\n                .findExitPointsAndStatements(controlFlow, startOffset, endOffset, new IntArrayList(), PsiContinueStatement.class,\n                                             PsiBreakStatement.class, PsiReturnStatement.class, PsiThrowStatement.class);\n              if (exitPoints.isEmpty()) {\n\n                if (ExceptionUtil.getThrownCheckedExceptions(new PsiElement[]{body}).isEmpty()) {\n                  TerminalBlock tb = TerminalBlock.from(statement.getIterationParameter(), body);\n                  List<Operation> operations = tb.extractOperations();\n\n                  final List<PsiVariable> nonFinalVariables = ControlFlowUtil.getUsedVariables(controlFlow, startOffset, endOffset)\n                    .stream().filter(variable -> !HighlightControlFlowUtil.isEffectivelyFinal(variable, body, null))\n                    .collect(Collectors.toList());\n\n                  if(getIncrementedVariable(tb, operations, nonFinalVariables) != null) {\n                    holder.registerProblem(iteratedValue, \"Can be replaced with count() call\",\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           new ReplaceWithCountFix());\n                  }\n                  if(getAccumulatedVariable(tb, operations, nonFinalVariables) != null) {\n                    holder.registerProblem(iteratedValue, \"Can be replaced with sum() call\",\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           new ReplaceWithSumFix());\n                  }\n                  if(!nonFinalVariables.isEmpty()) {\n                    return;\n                  }\n                  if ((isArray || !isRawSubstitution(iteratedValueType, collectionClass)) && isCollectCall(tb, operations)) {\n                    boolean addAll = operations.isEmpty() && isAddAllCall(tb);\n                    String methodName;\n                    if(addAll) {\n                      methodName = \"addAll\";\n                    } else {\n                      PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n                      if(methodCallExpression != null && extractReplaceableCollectionInitializer(\n                        methodCallExpression.getMethodExpression().getQualifierExpression(), statement) != null) {\n                        methodName = \"collect\";\n                      } else {\n                        methodName = \"forEach\";\n                      }\n                    }\n                    holder.registerProblem(iteratedValue, \"Can be replaced with \" + methodName + \" call\",\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           new ReplaceWithCollectFix(methodName));\n                  }\n                  // do not replace for(T e : arr) {} with Arrays.stream(arr).forEach(e -> {}) even if flag is set\n                  else if (!operations.isEmpty() ||\n                           (!isArray && (REPLACE_TRIVIAL_FOREACH || !isTrivial(body, statement.getIterationParameter())))) {\n                    final List<LocalQuickFix> fixes = new ArrayList<>();\n                    fixes.add(new ReplaceWithForeachCallFix(\"forEach\"));\n                    if (!operations.isEmpty()) {\n                      //for .stream()\n                      fixes.add(new ReplaceWithForeachCallFix(\"forEachOrdered\"));\n                    }\n                    holder.registerProblem(iteratedValue, \"Can be replaced with foreach call\",\n                                           ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                           fixes.toArray(new LocalQuickFix[fixes.size()]));\n                  }\n                }\n              }\n            }\n            catch (AnalysisCanceledException ignored) {\n            }\n          }\n        }\n      }\n\n      private boolean isRawSubstitution(PsiType iteratedValueType, PsiClass collectionClass) {\n        return iteratedValueType instanceof PsiClassType && PsiUtil\n          .isRawSubstitutor(collectionClass, TypeConversionUtil.getSuperClassSubstitutor(collectionClass, (PsiClassType)iteratedValueType));\n      }\n    };\n  }","commit_id":"55c8f0cf46696992b8897849dbd6ae9d897d8813","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @param part Partition.\n     * @param key Key for the event.\n     * @param evtNodeId Event node ID.\n     * @param xid Transaction ID.\n     * @param lockId Lock ID.\n     * @param type Event type.\n     * @param newVal New value.\n     * @param hasNewVal Whether new value is present or not.\n     * @param oldVal Old value.\n     * @param hasOldVal Whether old value is present or not.\n     * @param subjId Subject ID.\n     * @param cloClsName Closure class name.\n     * @param taskName Task class name.\n     */\n    public void addEvent(\n        int part,\n        KeyCacheObject key,\n        UUID evtNodeId,\n        @Nullable IgniteUuid xid,\n        @Nullable Object lockId,\n        int type,\n        @Nullable CacheObject newVal,\n        boolean hasNewVal,\n        @Nullable CacheObject oldVal,\n        boolean hasOldVal,\n        UUID subjId,\n        @Nullable String cloClsName,\n        @Nullable String taskName,\n        boolean keepPortable\n    ) {\n        assert key != null || type == EVT_CACHE_STARTED || type == EVT_CACHE_STOPPED;\n\n        if (!cctx.events().isRecordable(type))\n            LT.warn(log, null, \"Added event without checking if event is recordable: \" + U.gridEventName(type));\n\n        // Events are not fired for internal entry.\n        if (key == null || !key.internal()) {\n            ClusterNode evtNode = cctx.discovery().node(evtNodeId);\n\n            if (evtNode == null)\n                evtNode = findNodeInHistory(evtNodeId);\n\n            if (evtNode == null)\n                LT.warn(log, null, \"Failed to find event node in grid topology history \" +\n                    \"(try to increase topology history size configuration property of configured \" +\n                    \"discovery SPI): \" + evtNodeId);\n\n            cctx.gridEvents().record(new CacheEvent(cctx.name(),\n                cctx.localNode(),\n                evtNode,\n                \"Cache event.\",\n                type,\n                part,\n                cctx.isNear(),\n                cctx.cacheObjectContext().unwrapPortableIfNeeded(key, keepPortable, false),\n                xid,\n                lockId,\n                cctx.cacheObjectContext().unwrapPortableIfNeeded(newVal, keepPortable, false),\n                hasNewVal,\n                cctx.cacheObjectContext().unwrapPortableIfNeeded(oldVal, keepPortable, false),\n                hasOldVal,\n                subjId,\n                cloClsName,\n                taskName));\n        }\n    }","id":95669,"modified_method":"/**\n     * @param part Partition.\n     * @param key Key for the event.\n     * @param evtNodeId Event node ID.\n     * @param xid Transaction ID.\n     * @param lockId Lock ID.\n     * @param type Event type.\n     * @param newVal New value.\n     * @param hasNewVal Whether new value is present or not.\n     * @param oldVal Old value.\n     * @param hasOldVal Whether old value is present or not.\n     * @param subjId Subject ID.\n     * @param cloClsName Closure class name.\n     * @param taskName Task class name.\n     */\n    public void addEvent(\n        int part,\n        KeyCacheObject key,\n        UUID evtNodeId,\n        @Nullable IgniteUuid xid,\n        @Nullable Object lockId,\n        int type,\n        @Nullable CacheObject newVal,\n        boolean hasNewVal,\n        @Nullable CacheObject oldVal,\n        boolean hasOldVal,\n        UUID subjId,\n        @Nullable String cloClsName,\n        @Nullable String taskName,\n        boolean keepPortable\n    ) {\n        assert key != null || type == EVT_CACHE_STARTED || type == EVT_CACHE_STOPPED;\n\n        if (!cctx.events().isRecordable(type))\n            LT.warn(log, null, \"Added event without checking if event is recordable: \" + U.gridEventName(type));\n\n        // Events are not fired for internal entry.\n        if (key == null || !key.internal()) {\n            ClusterNode evtNode = cctx.discovery().node(evtNodeId);\n\n            if (evtNode == null)\n                evtNode = findNodeInHistory(evtNodeId);\n\n            if (evtNode == null)\n                LT.warn(log, null, \"Failed to find event node in grid topology history \" +\n                    \"(try to increase topology history size configuration property of configured \" +\n                    \"discovery SPI): \" + evtNodeId);\n\n            keepPortable = keepPortable || forceKeepBinary;\n\n            Object key0;\n            Object val0;\n            Object oldVal0;\n\n            try {\n                key0 = cctx.cacheObjectContext().unwrapPortableIfNeeded(key, keepPortable, false);\n                val0 = cctx.cacheObjectContext().unwrapPortableIfNeeded(newVal, keepPortable, false);\n                oldVal0 = cctx.cacheObjectContext().unwrapPortableIfNeeded(oldVal, keepPortable, false);\n            }\n            catch (Exception e) {\n                if (!cctx.cacheObjectContext().processor().isPortableEnabled(cctx.config()))\n                    throw e;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Failed to unmarshall cache object value for the event notification: \" + e);\n\n                if (!forceKeepBinary)\n                    LT.warn(log, null, \"Failed to unmarshall cache object value for the event notification \" +\n                        \"(all further notifications will keep binary object format).\");\n\n                forceKeepBinary = true;\n\n                key0 = cctx.cacheObjectContext().unwrapPortableIfNeeded(key, true, false);\n                val0 = cctx.cacheObjectContext().unwrapPortableIfNeeded(newVal, true, false);\n                oldVal0 = cctx.cacheObjectContext().unwrapPortableIfNeeded(oldVal, true, false);\n            }\n\n            cctx.gridEvents().record(new CacheEvent(cctx.name(),\n                cctx.localNode(),\n                evtNode,\n                \"Cache event.\",\n                type,\n                part,\n                cctx.isNear(),\n                key0,\n                xid,\n                lockId,\n                val0,\n                hasNewVal,\n                oldVal0,\n                hasOldVal,\n                subjId,\n                cloClsName,\n                taskName));\n        }\n    }","commit_id":"809a44260d10fb394767ebb1df66857c22cc8cbd","url":"https://github.com/apache/ignite"},{"original_method":"@Nullable\n  protected static PsiStatement getSurroundingStatement(@NotNull PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (parent instanceof PsiIfStatement) {\n      final PsiIfStatement ifStatement = (PsiIfStatement)parent;\n      if (isBetweenThen(ifStatement, element)) {\n        return ifStatement.getThenBranch();\n      }\n\n      if (isBetweenElse(ifStatement, element)) {\n        return ifStatement.getElseBranch();\n      }\n    }\n    if (parent instanceof PsiWhileStatement) {\n      return ((PsiWhileStatement)parent).getBody();\n    }\n    if (parent instanceof PsiDoWhileStatement) {\n      return ((PsiDoWhileStatement)parent).getBody();\n    }\n    if (parent instanceof PsiForStatement) {\n      return ((PsiForStatement)parent).getBody();\n    }\n    if (parent instanceof PsiForeachStatement) {\n      return ((PsiForeachStatement)parent).getBody();\n    }\n    return null;\n  }","id":95670,"modified_method":"@Nullable\n  protected static PsiStatement getSurroundingStatement(@NotNull PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (parent instanceof PsiIfStatement) {\n      final PsiIfStatement ifStatement = (PsiIfStatement)parent;\n      final PsiStatement thenBranch = ifStatement.getThenBranch();\n      final int offset = element.getTextOffset();\n      if (thenBranch != null && offset > thenBranch.getTextOffset()) {\n        final PsiKeyword elseElement = ifStatement.getElseElement();\n        if (elseElement == null || offset < elseElement.getTextOffset()) {\n          // no 'else' branch or after 'then' branch but before 'else' keyword\n          return null;\n        }\n        return ifStatement.getElseBranch();\n      }\n      return thenBranch;\n    }\n    if (parent instanceof PsiLoopStatement) {\n      return ((PsiLoopStatement)parent).getBody();\n    }\n    return null;\n  }","commit_id":"0cb01271b64220484a03c3c8bab2bd979c4fae2d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void dispatchEvent(AWTEvent e) {\n    if (!appIsLoaded()) {\n      super.dispatchEvent(e);\n      return;\n    }\n\n    fixNonEnglishKeyboardLayouts(e);\n\n    e = InertialMouseRouter.changeSourceIfNeeded(e);\n\n    e = mapEvent(e);\n\n    boolean wasInputEvent = myIsInInputEvent;\n    myIsInInputEvent = e instanceof InputEvent || e instanceof InputMethodEvent || e instanceof WindowEvent || e instanceof ActionEvent;\n    AWTEvent oldEvent = myCurrentEvent;\n    myCurrentEvent = e;\n\n    try {\n      _dispatchEvent(e, false);\n    }\n    catch (Throwable t) {\n      if (!myToolkitBugsProcessor.process(t)) {\n        PluginManager.processException(t);\n      }\n    }\n    finally {\n      myIsInInputEvent = wasInputEvent;\n      myCurrentEvent = oldEvent;\n\n      for (EventDispatcher each : myPostProcessors) {\n        each.dispatch(e);\n      }\n\n      if (e instanceof KeyEvent) {\n        maybeReady();\n      }\n    }\n  }","id":95671,"modified_method":"@Override\n  public void dispatchEvent(AWTEvent e) {\n    if (!appIsLoaded()) {\n      try {\n        super.dispatchEvent(e);\n      }\n      catch (Throwable t) {\n        processException(t);\n      }\n      return;\n    }\n\n    fixNonEnglishKeyboardLayouts(e);\n\n    e = InertialMouseRouter.changeSourceIfNeeded(e);\n\n    e = mapEvent(e);\n\n    boolean wasInputEvent = myIsInInputEvent;\n    myIsInInputEvent = e instanceof InputEvent || e instanceof InputMethodEvent || e instanceof WindowEvent || e instanceof ActionEvent;\n    AWTEvent oldEvent = myCurrentEvent;\n    myCurrentEvent = e;\n\n    try {\n      _dispatchEvent(e, false);\n    }\n    catch (Throwable t) {\n      processException(t);\n    }\n    finally {\n      myIsInInputEvent = wasInputEvent;\n      myCurrentEvent = oldEvent;\n\n      for (EventDispatcher each : myPostProcessors) {\n        each.dispatch(e);\n      }\n\n      if (e instanceof KeyEvent) {\n        maybeReady();\n      }\n    }\n  }","commit_id":"6203cb3dab4260f5767f28b388abba2428d5806b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void defaultDispatchEvent(final AWTEvent e) {\n    try {\n      myDispatchingFocusEvent = e instanceof FocusEvent;\n\n      maybeReady();\n      fixStickyAlt(e);\n\n      super.dispatchEvent(e);\n    }\n    catch (Throwable t) {\n      if (!myToolkitBugsProcessor.process(t)) {\n        PluginManager.processException(t);\n      }\n    }\n    finally {\n      myDispatchingFocusEvent = false;\n    }\n  }","id":95672,"modified_method":"private void defaultDispatchEvent(final AWTEvent e) {\n    try {\n      myDispatchingFocusEvent = e instanceof FocusEvent;\n\n      maybeReady();\n      fixStickyAlt(e);\n\n      super.dispatchEvent(e);\n    }\n    catch (Throwable t) {\n      processException(t);\n    }\n    finally {\n      myDispatchingFocusEvent = false;\n    }\n  }","commit_id":"6203cb3dab4260f5767f28b388abba2428d5806b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static StartupAbortedException findCause(Throwable t) {\n    while (t != null) {\n      if (t instanceof StartupAbortedException) {\n        return (StartupAbortedException)t;\n      }\n      t = t.getCause();\n    }\n    return null;\n  }","id":95673,"modified_method":"private static <T extends Throwable> T findCause(Throwable t, Class<T> clazz) {\n    while (t != null) {\n      if (clazz.isInstance(t)) {\n        return clazz.cast(t);\n      }\n      t = t.getCause();\n    }\n    return null;\n  }","commit_id":"6203cb3dab4260f5767f28b388abba2428d5806b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void processException(Throwable t) {\n    if (!IdeaApplication.isLoaded()) {\n      @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\") StartupAbortedException se = findCause(t);\n      if (se == null) se = new StartupAbortedException(t);\n\n      if (se.logError()) {\n        try {\n          if (Logger.isInitialized() && !(t instanceof ProcessCanceledException)) {\n            getLogger().error(t);\n          }\n        }\n        catch (Throwable ignore) { }\n\n        Main.showMessage(\"Start Failed\", t);\n      }\n\n      System.exit(se.exitCode());\n    }\n    else if (!(t instanceof ProcessCanceledException)) {\n      getLogger().error(t);\n    }\n  }","id":95674,"modified_method":"public static void processException(Throwable t) {\n    if (!IdeaApplication.isLoaded()) {\n      @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\") StartupAbortedException se = findCause(t, StartupAbortedException.class);\n      if (se == null) se = new StartupAbortedException(t);\n      @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\") PluginException pe = findCause(t, PluginException.class);\n      PluginId pluginId = pe != null ? pe.getPluginId() : null;\n\n      if (Logger.isInitialized() && !(t instanceof ProcessCanceledException)) {\n        try {\n          getLogger().error(t);\n        }\n        catch (Throwable ignore) { }\n      }\n\n      if (pluginId != null && !CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n        disablePlugin(pluginId.getIdString());\n\n        StringWriter message = new StringWriter();\n        message.append(\"Plugin '\").append(pluginId.getIdString()).append(\"' failed to initialize and will be disabled. \");\n        message.append(\" Please restart \").append(ApplicationNamesInfo.getInstance().getFullProductName()).append('.');\n        message.append(\"\\n\\n\");\n        pe.getCause().printStackTrace(new PrintWriter(message));\n\n        Main.showMessage(\"Plugin Error\", message.toString(), false);\n        System.exit(Main.PLUGIN_ERROR);\n      }\n      else {\n        Main.showMessage(\"Start Failed\", t);\n        System.exit(se.exitCode());\n      }\n    }\n    else if (!(t instanceof ProcessCanceledException)) {\n      getLogger().error(t);\n    }\n  }","commit_id":"6203cb3dab4260f5767f28b388abba2428d5806b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void handleComponentError(Throwable t, @Nullable String componentClassName, @Nullable ComponentConfig config) {\n    Application app = ApplicationManager.getApplication();\n    if (app != null && app.isUnitTestMode()) {\n      if (t instanceof Error) throw (Error)t;\n      if (t instanceof RuntimeException) throw (RuntimeException)t;\n      throw new RuntimeException(t);\n    }\n\n    if (t instanceof StartupAbortedException) {\n      throw (StartupAbortedException)t;\n    }\n\n    PluginId pluginId = null;\n    if (config != null) {\n      pluginId = config.getPluginId();\n    }\n    if (pluginId == null || CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      if (componentClassName != null) {\n        pluginId = getPluginByClassName(componentClassName);\n      }\n    }\n    if (pluginId == null || CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      if (t instanceof PicoPluginExtensionInitializationException) {\n        pluginId = ((PicoPluginExtensionInitializationException)t).getPluginId();\n      }\n    }\n\n    if (pluginId != null && !CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      getLogger().warn(t);\n\n      disablePlugin(pluginId.getIdString());\n\n      StringWriter message = new StringWriter();\n      message.append(\"Plugin '\").append(pluginId.getIdString()).append(\"' failed to initialize and will be disabled. \");\n      message.append(\" Please restart \").append(ApplicationNamesInfo.getInstance().getFullProductName()).append('.');\n      message.append(\"\\n\\n\");\n      t.printStackTrace(new PrintWriter(message));\n      Main.showMessage(\"Plugin Error\", message.toString(), false);\n\n      throw new StartupAbortedException(t).exitCode(Main.PLUGIN_ERROR).logError(false);\n    }\n    else {\n      throw new StartupAbortedException(\"Fatal error initializing '\" + componentClassName + \"'\", t);\n    }\n  }","id":95675,"modified_method":"public static void handleComponentError(Throwable t, @Nullable String componentClassName, @Nullable ComponentConfig config) {\n    Application app = ApplicationManager.getApplication();\n    if (app != null && app.isUnitTestMode()) {\n      if (t instanceof Error) throw (Error)t;\n      if (t instanceof RuntimeException) throw (RuntimeException)t;\n      throw new RuntimeException(t);\n    }\n\n    if (t instanceof StartupAbortedException) {\n      throw (StartupAbortedException)t;\n    }\n\n    PluginId pluginId = null;\n    if (config != null) {\n      pluginId = config.getPluginId();\n    }\n    if (pluginId == null || CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      if (componentClassName != null) {\n        pluginId = getPluginByClassName(componentClassName);\n      }\n    }\n    if (pluginId == null || CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      if (t instanceof PicoPluginExtensionInitializationException) {\n        pluginId = ((PicoPluginExtensionInitializationException)t).getPluginId();\n      }\n    }\n\n    if (pluginId != null && !CORE_PLUGIN_ID.equals(pluginId.getIdString())) {\n      throw new StartupAbortedException(new PluginException(t, pluginId));\n    }\n    else {\n      throw new StartupAbortedException(\"Fatal error initializing '\" + componentClassName + \"'\", t);\n    }\n  }","commit_id":"6203cb3dab4260f5767f28b388abba2428d5806b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Main entry point for the import of a file hierarchy.\n   * Instantiates the engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      builder.startElem(DEEPFS, atts.reset());\n      \n      for(final File f : root ? File.listRoots() :\n        new File[] { new File(io.path()).getCanonicalFile() }) {\n        \n        preStack[0] = builder.startElem(DIR, atts(f, true));\n        sizeStack[0] = 0;\n        parse(f);\n        builder.endElem(DIR);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      \n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","id":95676,"modified_method":"/**\n   * Main entry point for the import of a file hierarchy.\n   * Instantiates the engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    backingroot = backingroot + \"/\" + io.name();\n    if (!new File(backingroot).mkdir())\n      throw new IOException(BACKINGEXISTS + backingroot);\n    \n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      builder.startElem(DEEPFS, atts.reset());\n      \n      for(final File f : root ? File.listRoots() :\n        new File[] { new File(io.path()).getCanonicalFile() }) {\n        \n        importroot = f.getAbsolutePath().length();\n        \n        preStack[0] = builder.startElem(DIR, atts(f, true));\n        sizeStack[0] = 0;\n        parse(f);\n        builder.endElem(DIR);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      \n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","commit_id":"face6fcb2033b8f8e6870950dc4f051975c20e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Visits files in a directory or steps further down.\n   * @param d the directory to be visited.\n   * @throws IOException I/O exception\n   */\n  private void parse(final File d) throws IOException {\n    final File[] files = d.listFiles();\n    if(files == null) return;\n\n    for(final File f : files) {\n      if(!valid(f)) continue;\n\n      if(f.isDirectory()) {\n        dir(f);\n      } else {\n        file(f);\n      }\n    }\n  }","id":95677,"modified_method":"/**\n   * Visits files in a directory or steps further down.\n   * @param d the directory to be visited.\n   * @throws IOException I/O exception\n   */\n  private void parse(final File d) throws IOException {\n    final File[] files = d.listFiles();\n    if(files == null) return;\n\n    for(final File f : files) {\n      if(!valid(f)) continue;\n\n      if(f.isDirectory()) {\n        if (wbacking)\n          new File(backingroot\n            + f.getAbsolutePath().substring(importroot)).mkdir();\n        dir(f);\n      } else {\n        if (wbacking)\n          copy(f.getAbsoluteFile(), new File(backingroot\n            + f.getAbsolutePath().substring(importroot)));\n        file(f);\n      }\n    }\n  }","commit_id":"face6fcb2033b8f8e6870950dc4f051975c20e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void dispose() {\r\n    GUIProp.maxstate = getExtendedState() == MAXIMIZED_BOTH;\r\n    if(!GUIProp.maxstate) {\r\n      GUIProp.guiloc[0] = getX();\r\n      GUIProp.guiloc[1] = getY();\r\n      GUIProp.guisize[0] = getWidth();\r\n      GUIProp.guisize[1] = getHeight();\r\n    }\r\n    query.quit();\r\n    if(help != null) help.close();\r\n    context.close();\r\n    GUIProp.write();\r\n    Prop.write();\r\n    super.dispose();\r\n    System.exit(0);\r\n  }","id":95678,"modified_method":"@Override\r\n  public void dispose() {\r\n    GUIProp.maxstate = getExtendedState() == MAXIMIZED_BOTH;\r\n    if(!GUIProp.maxstate) {\r\n      GUIProp.guiloc[0] = getX();\r\n      GUIProp.guiloc[1] = getY();\r\n      GUIProp.guisize[0] = getWidth();\r\n      GUIProp.guisize[1] = getHeight();\r\n    }\r\n    boolean fs = context.data() != null && context.data().fs != null;\r\n    query.quit();\r\n    if(help != null) help.close();\r\n    if(!fs) context.close();\r\n    GUIProp.write();\r\n    Prop.write();\r\n    super.dispose();\r\n    if(!fs) System.exit(0);\r\n  }","commit_id":"face6fcb2033b8f8e6870950dc4f051975c20e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param build builder reference\n   * @param doc document name\n   */\n  public SAX2Data(final Builder build, final String doc) {\n    builder = build;\n    name = doc;\n  }","id":95679,"modified_method":"/**\n   * Constructor.\n   * @param build builder reference\n   * @param xml document name\n   */\n  public SAX2Data(final Builder build, final String xml) {\n    builder = build;\n    name = xml;\n  }","commit_id":"face6fcb2033b8f8e6870950dc4f051975c20e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void startDocument() throws SAXException {\n    try {\n      builder.startDoc(token(name));\n    } catch(final IOException ex) {\n      error(ex);\n    }\n  }","id":95680,"modified_method":"@Override\n  public void startDocument() throws SAXException {\n    try {\n      if(doc) builder.startDoc(token(name));\n    } catch(final IOException ex) {\n      error(ex);\n    }\n  }","commit_id":"face6fcb2033b8f8e6870950dc4f051975c20e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void endDocument() throws SAXException {\n    try {\n      builder.endDoc();\n    } catch(final IOException ex) {\n      error(ex);\n    }\n  }","id":95681,"modified_method":"@Override\n  public void endDocument() throws SAXException {\n    try {\n      if(doc) builder.endDoc();\n    } catch(final IOException ex) {\n      error(ex);\n    }\n  }","commit_id":"face6fcb2033b8f8e6870950dc4f051975c20e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void parse(final Builder build) throws IOException {\r\n    try {\r\n      XMLReader r = source.getXMLReader();\r\n      if(r == null) {\r\n        final SAXParserFactory f = SAXParserFactory.newInstance();\r\n        f.setNamespaceAware(true);\r\n        f.setValidating(false);\r\n        r = f.newSAXParser().getXMLReader();\r\n      }\r\n      sax = new SAX2Data(build, io.name());\r\n      r.setDTDHandler(sax);\r\n      r.setContentHandler(sax);\r\n      r.setProperty(\"http://xml.org/sax/properties/lexical-handler\", sax);\r\n      r.setErrorHandler(sax);\r\n\r\n      final InputSource is = source.getInputSource();\r\n      if(is != null) r.parse(is);\r\n      else r.parse(source.getSystemId());\r\n\r\n    } catch(final SAXParseException ex) {\r\n      final String msg = BaseX.info(SCANPOS, ex.getSystemId(),\r\n          ex.getLineNumber(), ex.getColumnNumber()) + \": \" + ex.getMessage();\r\n      final IOException ioe = new IOException(msg);\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    } catch(final ProgressException ex) {\r\n      throw ex;\r\n    } catch(final Exception ex) {\r\n      final IOException ioe = new IOException(ex.getMessage());\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    }\r\n  }","id":95682,"modified_method":"@Override\r\n  public void parse(final Builder build) throws IOException {\r\n    try {\r\n      XMLReader r = source.getXMLReader();\r\n      if(r == null) {\r\n        final SAXParserFactory f = SAXParserFactory.newInstance();\r\n        f.setNamespaceAware(true);\r\n        f.setValidating(false);\r\n        r = f.newSAXParser().getXMLReader();\r\n      }\r\n      sax = new SAX2Data(build, io.name());\r\n      sax.doc = doc;\r\n      r.setDTDHandler(sax);\r\n      r.setContentHandler(sax);\r\n      r.setProperty(\"http://xml.org/sax/properties/lexical-handler\", sax);\r\n      r.setErrorHandler(sax);\r\n\r\n      final InputSource is = source.getInputSource();\r\n      if(is != null) r.parse(is);\r\n      else r.parse(source.getSystemId());\r\n\r\n    } catch(final SAXParseException ex) {\r\n      final String msg = BaseX.info(SCANPOS, ex.getSystemId(),\r\n          ex.getLineNumber(), ex.getColumnNumber()) + \": \" + ex.getMessage();\r\n      final IOException ioe = new IOException(msg);\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    } catch(final ProgressException ex) {\r\n      throw ex;\r\n    } catch(final Exception ex) {\r\n      final IOException ioe = new IOException(ex.getMessage());\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    }\r\n  }","commit_id":"face6fcb2033b8f8e6870950dc4f051975c20e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Option(name = \"e\", longName = \"errors\", description = \"Output full execution error messages\")\n   public void setErrors(boolean exceptionTrace)\n   {\n      this.errors = exceptionTrace;\n   }","id":95683,"modified_method":"@Option(name = \"--errors\", aliases = { \"-e\" }, usage = \"Output full execution error messages\")\n   public void setErrors(boolean errors)\n   {\n      this.errors = errors;\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void main(String[] args) throws Exception\n   {\n      CreateIterationTask task = new CreateIterationTask();\n      task.processArgs(args, GlobalOptions.EMPTY);\n   }","id":95684,"modified_method":"public static void main(String[] args) throws Exception\n   {\n      CreateIterationTask task = new CreateIterationTask();\n      ArgsUtil.processArgs(task, args, GlobalOptions.EMPTY);\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Option(name = \"e\", longName = \"errors\", description = \"Output full execution error messages\")\n   public void setErrors(boolean exceptionTrace)\n   {\n      this.errors = exceptionTrace;\n   }","id":95685,"modified_method":"@Option(name = \"--errors\", aliases = { \"-e\" }, usage = \"Output full execution error messages\")\n   public void setErrors(boolean errors)\n   {\n      this.errors = errors;\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void main(String[] args) throws Exception\n   {\n      CreateProjectTask task = new CreateProjectTask();\n      task.processArgs(args, GlobalOptions.EMPTY);\n   }","id":95686,"modified_method":"public static void main(String[] args) throws Exception\n   {\n      CreateProjectTask task = new CreateProjectTask();\n      ArgsUtil.processArgs(task, args, GlobalOptions.EMPTY);\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Option(name = \"e\", longName = \"errors\", description = \"Output full execution error messages\")\n   public void setErrors(boolean exceptionTrace)\n   {\n      this.errors = exceptionTrace;\n   }","id":95687,"modified_method":"@Option(name = \"--errors\", aliases = { \"-e\" }, usage = \"Output full execution error messages\")\n   public void setErrors(boolean errors)\n   {\n      this.errors = errors;\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void main(String[] args) throws Exception\n   {\n      DownloadPoTask download = new DownloadPoTask();\n      download.processArgs(args, GlobalOptions.EMPTY);\n   }","id":95688,"modified_method":"public static void main(String[] args) throws Exception\n   {\n      DownloadPoTask task = new DownloadPoTask();\n      ArgsUtil.processArgs(task, args, GlobalOptions.EMPTY);\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Option(name = \"h\", longName = \"help\", description = \"Display this help and exit\")\n   public void setHelp(boolean help)\n   {\n      this.help = help;\n   }","id":95689,"modified_method":"@Option(name = \"--help\", aliases = { \"-h\", \"-help\" }, usage = \"Display this help and exit\")\n   public void setHelp(boolean help)\n   {\n      this.help = help;\n      parser.stopOptionParsing(); // no point in validating other options now\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void processArgs() throws Exception\n   {\n      if (version)\n      {\n         Utility.printJarVersion(System.out);\n         System.exit(0);\n      }\n      if (arguments.isEmpty())\n      {\n         help(System.out);\n         System.exit(0);\n      }\n      String command = arguments.remove(0);\n      if (command.equals(\"help\"))\n      {\n         help = true;\n      }\n      String[] otherArgs = arguments.toArray(new String[0]);\n      try\n      {\n         if (command.equals(\"upload\"))\n         {\n            Subcommand upload = new UploadPoTask();\n            upload.processArgs(otherArgs, getGlobalOptions());\n         }\n         else if (command.equals(\"download\"))\n         {\n            Subcommand download = new DownloadPoTask();\n            download.processArgs(otherArgs, getGlobalOptions());\n         }\n         else if (command.equals(\"createproj\"))\n         {\n            Subcommand cmd = new CreateProjectTask();\n            cmd.processArgs(otherArgs, getGlobalOptions());\n         }\n         else if (command.equals(\"createiter\"))\n         {\n            Subcommand cmd = new CreateIterationTask();\n            cmd.processArgs(otherArgs, getGlobalOptions());\n         }\n         else if (command.equals(\"putuser\")) \n         {\n            Subcommand cmd = new PutUserTask();\n            cmd.processArgs(otherArgs, getGlobalOptions());\n         }\n         else\n         {\n            help(System.out);\n         }\n      }\n      catch (Exception e)\n      {\n         Utility.handleException(e, errors);\n      }\n   }","id":95690,"modified_method":"private void processArgs(String[] args) throws Exception\n   {\n      try\n      {\n         parser.parseArgument(args);\n      }\n      catch (CmdLineException e)\n      {\n         if (!getHelp() && args.length != 0)\n         {\n            System.err.println(e.getMessage());\n            printHelp(System.err);\n            System.exit(1);\n         }\n      }\n      if (getHelp() && command == null)\n      {\n         printHelp(System.out);\n         return;\n      }\n      if (version)\n      {\n         Utility.printJarVersion(System.out);\n         return;\n      }\n      if (\"help\".equals(command))\n      {\n         setHelp(true);\n         command = null;\n         if (arguments.size() != 0)\n            command = arguments.remove(0);\n      }\n      if (command == null)\n      {\n         printHelp(System.out);\n         return;\n      }\n      String[] otherArgs = arguments.toArray(new String[0]);\n      try\n      {\n         Class<? extends Subcommand> taskClass = commandMap.get(command);\n         if (taskClass == null)\n         {\n            System.err.println(\"Unknown command '\" + command + \"'\");\n            printHelp(System.err);\n            System.exit(1);\n         }\n         else\n         {\n            Subcommand task = taskClass.newInstance();\n            ArgsUtil.processArgs(task, otherArgs, getGlobalOptions());\n         }\n      }\n      catch (Exception e)\n      {\n         Utility.handleException(e, errors);\n      }\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @param args\n    * @throws Exception\n    */\n   public static void main(String[] args) throws Exception\n   {\n      PoTool tool = new PoTool();\n      ArgumentProcessor<PoTool> argProcessor = ArgumentProcessor.newInstance(PoTool.class);\n      argProcessor.process(args, tool);\n      tool.processArgs();\n   }","id":95691,"modified_method":"public static void main(String[] args) throws Exception\n   {\n      // System.out.println(Arrays.asList(args));\n      PoTool tool = new PoTool();\n      tool.processArgs(args);\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static void help(PrintStream out) throws IOException\n   {\n      out.println(\"[USAGE]\");\n      out.println(\"  flies-publican [-e/--errors] upload/download/createproj/createiter [options] [args]\");\n      out.println(\"  For 'upload' help: flies-publican upload --help\");\n      out.println(\"  For 'download' help: flies-publican download --help\");\n      out.println(\"  For 'createproj' help: flies-publican createproj --help\");\n      out.println(\"  For 'createiter' help: flies-publican createiter --help\");\n\t\tout.println(\"  For 'putuser' help: flies-publican putuser --help\");\n      out.println(\"\");\n      out.println();\n   }","id":95692,"modified_method":"private void printHelp(PrintStream out) throws IOException\n   {\n      out.println(\"Usage: \" + getCommandName() + \" [OPTION]... <command> [COMMANDOPTION]...\");\n      out.println(getCommandDescription());\n      out.println();\n      parser.printUsage(out);\n      out.println();\n      out.println(\"Type '\" + getCommandName() + \" help <command>' for help on a specific command.\");\n      out.println();\n      out.println(\"Available commands:\");\n      for (String cmd : commandMap.keySet())\n      {\n         out.println(\"  \" + cmd);\n      }\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Option(name = \"e\", longName = \"errors\", description = \"Output full execution error messages\")\n   public void setErrors(boolean exceptionTrace)\n   {\n      this.errors = exceptionTrace;\n   }","id":95693,"modified_method":"@Option(name = \"--errors\", aliases = { \"-e\" }, usage = \"Output full execution error messages\")\n   public void setErrors(boolean errors)\n   {\n      this.errors = errors;\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void main(String[] args) throws Exception\n   {\n      PutUserTask task = new PutUserTask();\n      task.processArgs(args, GlobalOptions.EMPTY);\n   }","id":95694,"modified_method":"public static void main(String[] args) throws Exception\n   {\n      PutUserTask task = new PutUserTask();\n      ArgsUtil.processArgs(task, args, GlobalOptions.EMPTY);\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Option(name = \"e\", longName = \"errors\", description = \"Output full execution error messages\")\n   public void setErrors(boolean exceptionTrace)\n   {\n      this.errors = exceptionTrace;\n   }","id":95695,"modified_method":"@Option(name = \"--errors\", aliases = { \"-e\" }, usage = \"Output full execution error messages\")\n   public void setErrors(boolean errors)\n   {\n      this.errors = errors;\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void main(String[] args) throws Exception\n   {\n      UploadPoTask upload = new UploadPoTask();\n      upload.processArgs(args, GlobalOptions.EMPTY);\n   }","id":95696,"modified_method":"public static void main(String[] args) throws Exception\n   {\n      UploadPoTask task = new UploadPoTask();\n      ArgsUtil.processArgs(task, args, GlobalOptions.EMPTY);\n   }","commit_id":"0421f27f436c18915dc67873a9447e6c9641fbde","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n   *\n   * @param train training data from which the model is built (for epoch counting only)\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param timeStart start time in milliseconds, used to report training speed\n   * @param job_key key of the owning job\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame train, Frame ftrain, Frame ftest, long timeStart, Key job_key) {\n    epoch_counter = (float)model_info().get_processed_total()/train.numRows();\n    run_time = (System.currentTimeMillis()-start_time);\n    boolean keep_running = (epoch_counter < model_info().get_params().epochs);\n    _now = System.currentTimeMillis();\n    final long sinceLastScore = _now-_timeLastScoreStart;\n    final long sinceLastPrint = _now-_timeLastPrintStart;\n    final long samples = model_info().get_processed_total();\n    if (sinceLastPrint > model_info().get_params().score_interval*1000) {\n      _timeLastPrintStart = _now;\n      Log.info(\"Training time: \" + PrettyPrint.msecs(_now - start_time, true)\n              + \". Processed \" + String.format(\"%,d\", samples) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n              + \" Speed: \" + String.format(\"%.3f\", (double)samples/((_now - start_time)/1000.)) + \" samples/sec.\");\n    }\n    // this is potentially slow - only do every so often\n    if( !keep_running ||\n            (sinceLastScore > model_info().get_params().score_interval*1000 //don't score too often\n        &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < model_info().get_params().score_duty_cycle) ) { //duty cycle\n      final boolean printme = !model_info().get_params().quiet_mode;\n      if (printme) Log.info(\"Scoring the model.\");\n      _timeLastScoreStart = _now;\n      // compute errors\n      Errors err = new Errors();\n      err.classification = isClassifier();\n      assert(err.classification == model_info().get_params().classification);\n      err.training_time_ms = _now - timeStart;\n      err.epoch_counter = epoch_counter;\n      err.validation = ftest != null;\n      err.training_samples = model_info().get_processed_total();\n      err.score_training_samples = ftrain.numRows();\n      err.train_confusion_matrix = new ConfusionMatrix();\n      final Frame trainPredict = score(ftrain, false);\n      final double trainErr = calcError(ftrain, trainPredict, \"Scoring on training data:\", printme, err.train_confusion_matrix);\n      if (err.classification && nclasses()==2) {\n        err.trainAUC = new AUC();\n        err.trainAUC.actual = ftrain;\n        err.trainAUC.vactual = ftrain.lastVec();\n        err.trainAUC.predict = trainPredict;\n        err.trainAUC.vpredict = trainPredict.lastVec();\n        err.trainAUC.serve();\n      }\n      trainPredict.delete();\n      if (err.classification) err.train_err = err.trainAUC != null ? err.trainAUC.err() : trainErr;\n      else err.train_mse = trainErr;\n\n      if (err.validation) {\n        assert ftest != null;\n        err.score_validation_samples = ftest.numRows();\n        err.valid_confusion_matrix = new ConfusionMatrix();\n        final Frame validPredict = score(ftest, false);\n        final double validErr = calcError(ftest, validPredict, \"Scoring on validation data:\", printme, err.valid_confusion_matrix);\n        if (err.classification && nclasses()==2) {\n          err.validAUC = new AUC();\n          err.validAUC.actual = ftest;\n          err.validAUC.vactual = ftest.lastVec();\n          err.validAUC.predict = validPredict;\n          err.validAUC.vpredict = validPredict.lastVec();\n          err.validAUC.serve();\n        }\n        validPredict.delete();\n        if (err.classification) err.valid_err = err.validAUC != null ? err.validAUC.err() : validErr;\n        else err.valid_mse = validErr;\n      }\n\n      // remove thresholds from all the previous AUC results to keep output JSON small\n      if (errors.length > 1) {\n        if (errors[errors.length-1].trainAUC != null) errors[errors.length-1].trainAUC.thresholds = null;\n        if (errors[errors.length-1].validAUC != null) errors[errors.length-1].validAUC.thresholds = null;\n      }\n\n      // only keep confusion matrices for the last step if there are fewer than specified number of output classes\n      if (err.train_confusion_matrix.cm != null\n              && err.train_confusion_matrix.cm.length >= model_info().get_params().max_confusion_matrix_size) {\n        err.train_confusion_matrix = null;\n        err.valid_confusion_matrix = null;\n      }\n\n      // enlarge the error array by one, push latest score back\n      if (errors == null) {\n         errors = new Errors[]{err};\n      } else {\n        Errors[] err2 = new Errors[errors.length+1];\n        System.arraycopy(errors, 0, err2, 0, errors.length);\n        err2[err2.length-1] = err;\n        errors = err2;\n      }\n      _timeLastScoreEnd = System.currentTimeMillis();\n      // print the freshly scored model to ASCII\n      for (String s : toString().split(\"\\n\")) Log.info(s);\n      if (printme) Log.info(\"Scoring time: \" + PrettyPrint.msecs(System.currentTimeMillis() - _now, true));\n    }\n    if (model_info().unstable()) {\n      Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n      Log.err(\"Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\");\n      keep_running = false;\n    } else if (ftest == null &&\n            (model_info().get_params().classification && errors[errors.length-1].train_err <= model_info().get_params().classification_stop)\n        || (!model_info().get_params().classification && errors[errors.length-1].train_mse <= model_info().get_params().regression_stop)\n            ) {\n      Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n      keep_running = false;\n    } else if (ftest != null &&\n            (model_info().get_params().classification && errors[errors.length-1].valid_err <= model_info().get_params().classification_stop)\n        || (!model_info().get_params().classification && errors[errors.length-1].valid_mse <= model_info().get_params().regression_stop)\n            ) {\n      Log.info(\"Achieved requested predictive accuracy on the validation data. Model building completed.\");\n      keep_running = false;\n    }\n    update(job_key);\n//    System.out.println(this);\n    return keep_running;\n  }","id":95697,"modified_method":"/**\n   *\n   * @param train training data from which the model is built (for epoch counting only)\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param timeStart start time in milliseconds, used to report training speed\n   * @param job_key key of the owning job\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame train, Frame ftrain, Frame ftest, long timeStart, Key job_key) {\n    epoch_counter = (float)model_info().get_processed_total()/train.numRows();\n    run_time = (System.currentTimeMillis()-start_time);\n    boolean keep_running = (epoch_counter < model_info().get_params().epochs);\n    _now = System.currentTimeMillis();\n    final long sinceLastScore = _now-_timeLastScoreStart;\n    final long sinceLastPrint = _now-_timeLastPrintStart;\n    final long samples = model_info().get_processed_total();\n    if (sinceLastPrint > model_info().get_params().score_interval*1000) {\n      _timeLastPrintStart = _now;\n      Log.info(\"Training time: \" + PrettyPrint.msecs(_now - start_time, true)\n              + \". Processed \" + String.format(\"%,d\", samples) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n              + \" Speed: \" + String.format(\"%.3f\", (double)samples/((_now - start_time)/1000.)) + \" samples/sec.\");\n    }\n    // this is potentially slow - only do every so often\n    if( !keep_running ||\n            (sinceLastScore > model_info().get_params().score_interval*1000 //don't score too often\n        &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < model_info().get_params().score_duty_cycle) ) { //duty cycle\n      final boolean printme = !model_info().get_params().quiet_mode;\n      if (printme) Log.info(\"Scoring the model.\");\n      _timeLastScoreStart = _now;\n      // compute errors\n      Errors err = new Errors();\n      err.classification = isClassifier();\n      assert(err.classification == model_info().get_params().classification);\n      err.training_time_ms = _now - timeStart;\n      err.epoch_counter = epoch_counter;\n      err.validation = ftest != null;\n      err.training_samples = model_info().get_processed_total();\n      err.score_training_samples = ftrain.numRows();\n      err.train_confusion_matrix = new ConfusionMatrix();\n      if (err.classification && nclasses()==2) err.trainAUC = new AUC();\n      final Frame trainPredict = score(ftrain, false);\n      final double trainErr = calcError(ftrain, trainPredict, \"training\", printme, err.train_confusion_matrix, err.trainAUC);\n      trainPredict.delete();\n\n      if (err.classification) err.train_err = err.trainAUC != null ? err.trainAUC.err() : trainErr;\n      else err.train_mse = trainErr;\n\n      if (err.validation) {\n        assert ftest != null;\n        err.score_validation_samples = ftest.numRows();\n        err.valid_confusion_matrix = new ConfusionMatrix();\n        if (err.classification && nclasses()==2) err.validAUC = new AUC();\n        final Frame validPredict = score(ftest, false);\n        final double validErr = calcError(ftest, validPredict, \"validation\", printme, err.valid_confusion_matrix, err.validAUC);\n        validPredict.delete();\n        if (err.classification) err.valid_err = err.validAUC != null ? err.validAUC.err() : validErr;\n        else err.valid_mse = validErr;\n      }\n\n      // remove thresholds from all the previous AUC results to keep output JSON small\n      if (errors.length > 1) {\n        if (errors[errors.length-1].trainAUC != null) errors[errors.length-1].trainAUC.thresholds = null;\n        if (errors[errors.length-1].validAUC != null) errors[errors.length-1].validAUC.thresholds = null;\n      }\n\n      // only keep confusion matrices for the last step if there are fewer than specified number of output classes\n      if (err.train_confusion_matrix.cm != null\n              && err.train_confusion_matrix.cm.length >= model_info().get_params().max_confusion_matrix_size) {\n        err.train_confusion_matrix = null;\n        err.valid_confusion_matrix = null;\n      }\n\n      // enlarge the error array by one, push latest score back\n      if (errors == null) {\n         errors = new Errors[]{err};\n      } else {\n        Errors[] err2 = new Errors[errors.length+1];\n        System.arraycopy(errors, 0, err2, 0, errors.length);\n        err2[err2.length-1] = err;\n        errors = err2;\n      }\n      _timeLastScoreEnd = System.currentTimeMillis();\n      // print the freshly scored model to ASCII\n      for (String s : toString().split(\"\\n\")) Log.info(s);\n      if (printme) Log.info(\"Scoring time: \" + PrettyPrint.msecs(System.currentTimeMillis() - _now, true));\n    }\n    if (model_info().unstable()) {\n      Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n      Log.err(\"Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\");\n      keep_running = false;\n    } else if (ftest == null &&\n            (model_info().get_params().classification && errors[errors.length-1].train_err <= model_info().get_params().classification_stop)\n        || (!model_info().get_params().classification && errors[errors.length-1].train_mse <= model_info().get_params().regression_stop)\n            ) {\n      Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n      keep_running = false;\n    } else if (ftest != null &&\n            (model_info().get_params().classification && errors[errors.length-1].valid_err <= model_info().get_params().classification_stop)\n        || (!model_info().get_params().classification && errors[errors.length-1].valid_mse <= model_info().get_params().regression_stop)\n            ) {\n      Log.info(\"Achieved requested predictive accuracy on the validation data. Model building completed.\");\n      keep_running = false;\n    }\n    update(job_key);\n//    System.out.println(this);\n    return keep_running;\n  }","commit_id":"63e86529cb5acbf822d2863ffdcbec696111113c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public double calcError(Frame ftest, Frame fpreds, String label, boolean printCM, ConfusionMatrix CM) {\n    if (CM == null) CM = new ConfusionMatrix();\n    CM.actual = ftest;\n    CM.vactual = ftest.lastVec();\n    CM.predict = fpreds;\n    CM.vpredict = fpreds.vecs()[0];\n    CM.serve();\n    StringBuilder sb = new StringBuilder();\n    final double error = CM.toASCII(sb); //either classification error or MSE\n    if (printCM && (CM.cm==null || CM.cm.length <= model_info().get_params().max_confusion_matrix_size)) {\n      Log.info(label);\n      for (String s : sb.toString().split(\"\\n\")) Log.info(s);\n    }\n    return error;\n  }","id":95698,"modified_method":"public double calcError(Frame ftest, Frame fpreds, String label, boolean printCM, ConfusionMatrix cm, AUC auc) {\n    StringBuilder sb = new StringBuilder();\n    double error;\n    if (auc != null) {\n      auc.actual = ftest;\n      auc.vactual = ftest.lastVec();\n      auc.predict = fpreds;\n      auc.vpredict = fpreds.lastVec();\n      auc.serve();\n      error = auc.toASCII(sb);\n    } else {\n      if (cm == null) cm = new ConfusionMatrix();\n      cm.actual = ftest;\n      cm.vactual = ftest.lastVec();\n      cm.predict = fpreds;\n      cm.vpredict = fpreds.vecs()[0];\n      cm.serve();\n      error = cm.toASCII(sb); //either classification error or MSE\n    }\n    if (printCM && (cm.cm==null /*regression*/ || cm.cm.length <= model_info().get_params().max_confusion_matrix_size)) {\n      Log.info(\"Scoring on \" + label + \" data:\");\n      for (String s : sb.toString().split(\"\\n\")) Log.info(s);\n    }\n    return error;\n  }","commit_id":"63e86529cb5acbf822d2863ffdcbec696111113c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void compare() throws Exception {\n\n    for (int repeat = 0; repeat < 1; ++repeat) {\n      // Testing different things\n      // Note: Microsoft reference implementation is only for Tanh + MSE, rectifier and MCE are implemented by 0xdata (trivial).\n      // Note: Initial weight distributions are copied, but what is tested is the stability behavior.\n\n      NN.Activation[] activations = { NN.Activation.Tanh, NN.Activation.Rectifier };\n      NN.Loss[] losses = { NN.Loss.MeanSquare, NN.Loss.CrossEntropy };\n      NN.InitialWeightDistribution[] dists = {\n//              NN.InitialWeightDistribution.Normal,\n//              NN.InitialWeightDistribution.Uniform,\n              NN.InitialWeightDistribution.UniformAdaptive\n      };\n      double[] initial_weight_scales = { 1e-4 + new Random().nextDouble() };\n      double[] holdout_ratios = { 0.1 + new Random().nextDouble() * 0.8 };\n      double[] momenta = { new Random().nextDouble() * 0.99 };\n      int[] hiddens = { 1, 2 + new Random().nextInt(50) };\n      int[] epochs = { 1, 2 + new Random().nextInt(50) };\n      double[] rates = { 0.01, 1e-5 + new Random().nextDouble() * .1 };\n\n      int num_runs = 0;\n      for (NN.Activation activation : activations) {\n        for (NN.Loss loss : losses) {\n          for (NN.InitialWeightDistribution dist : dists) {\n            for (double scale : initial_weight_scales) {\n              for (double holdout_ratio : holdout_ratios) {\n                for (double momentum : momenta) {\n                  for (int hidden : hiddens) {\n                    for (int epoch : epochs) {\n                      for (double rate : rates) {\n                        long seed = new Random().nextLong();\n                        Log.info(\"\");\n                        Log.info(\"STARTING.\");\n                        Log.info(\"Running with \" + activation.name() + \" activation function and \" + loss.name() + \" loss function.\");\n                        Log.info(\"Initialization with \" + dist.name() + \" distribution and \" + scale + \" scale, holdout ratio \" + holdout_ratio);\n                        Log.info(\"Using \" + hidden + \" hidden layers and momentum: \" + momentum);\n                        Log.info(\"Using seed \" + seed);\n\n                        Key file = NFSFileVec.make(find_test_file(PATH));\n                        Frame frame = ParseDataset2.parse(Key.make(\"iris_nn2\"), new Key[] { file });\n\n                        Frame fr = null;\n                        NN p;\n                        Random rand;\n\n                        int trial = 0;\n                        FrameTask.DataInfo dinfo;\n                        do {\n                          Log.info(\"Trial #\" + ++trial);\n                          if (_train != null) _train.delete();\n                          if (_test != null) _test.delete();\n                          if (fr != null) fr.delete();\n\n                          rand = Utils.getDeterRNG(seed);\n\n                          double[][] rows = new double[(int) frame.numRows()][frame.numCols()];\n                          String[] names = new String[frame.numCols()];\n                          for( int c = 0; c < frame.numCols(); c++ ) {\n                            names[c] = \"ColumnName\" + c;\n                            for( int r = 0; r < frame.numRows(); r++ )\n                              rows[r][c] = frame.vecs()[c].at(r);\n                          }\n\n                          for( int i = rows.length - 1; i >= 0; i-- ) {\n                            int shuffle = rand.nextInt(i + 1);\n                            double[] row = rows[shuffle];\n                            rows[shuffle] = rows[i];\n                            rows[i] = row;\n                          }\n\n                          int limit = (int) (frame.numRows() * holdout_ratio);\n                          _train = frame(names, Utils.subarray(rows, 0, limit));\n                          _test = frame(names, Utils.subarray(rows, limit, (int) frame.numRows() - limit));\n\n                          p = new NN();\n                          p.source = _train;\n                          p.response = _train.lastVec();\n                          p.ignored_cols = null;\n                          p.ignore_const_cols = true;\n                          fr = FrameTask.DataInfo.prepareFrame(p.source, p.response, p.ignored_cols, true, p.ignore_const_cols);\n                          dinfo = new FrameTask.DataInfo(fr, 1, true);\n                        }\n                        // must have all output classes in training data (since that's what the reference implementation has hardcoded)\n                        while (dinfo._adaptedFrame.lastVec().domain().length < 3);\n\n                        // use the same seed for the reference implementation\n                        NeuralNetMLPReference2 ref = new NeuralNetMLPReference2();\n                        ref.init(activation, Utils.getDeterRNG(seed), holdout_ratio, hidden);\n\n                        p.seed = seed;\n                        p.hidden = new int[]{hidden};\n                        p.rate = rate / (1 - momentum); //adapt to (1-m) correction that's done inside (only for constant momentum!)\n                        p.activation = activation;\n                        p.max_w2 = Double.MAX_VALUE;\n                        p.epochs = epoch;\n                        p.input_dropout_ratio = 0;\n                        p.rate_annealing = 0; //do not change - not implemented in reference\n                        p.l1 = 0;\n                        p.loss = loss;\n                        p.l2 = 0;\n                        p.momentum_stable = momentum; //reference only supports constant momentum\n                        p.momentum_start = p.momentum_stable; //do not change - not implemented in reference\n                        p.momentum_ramp = 0; //do not change - not implemented in reference\n                        p.initial_weight_distribution = dist;\n                        p.initial_weight_scale = scale;\n                        p.classification = true;\n                        p.diagnostics = true;\n                        p.validation = null;\n                        p.quiet_mode = true;\n                        p.fast_mode = false; //to be the same as reference\n//                      p.fast_mode = true; //to be the same as old NeuralNet code\n                        p.nesterov_accelerated_gradient = false; //to be the same as reference\n//                        p.nesterov_accelerated_gradient = true; //to be the same as old NeuralNet code\n                        p.mini_batch = 0; //sync once per period\n                        p.ignore_const_cols = false;\n                        p.shuffle_training_data = false;\n                        p.classification_stop = -1; //don't stop early -> need to compare against reference, which doesn't stop either\n                        p.force_load_balance = false; //keep just 1 chunk for reproducibility\n                        NNModel mymodel = p.initModel(); //randomize weights, but don't start training yet\n\n                        Neurons[] neurons = NNTask.makeNeuronsForTraining(mymodel.model_info());\n\n                        // use the same random weights for the reference implementation\n                        Neurons l = neurons[1];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                            ref._nn.ihWeights[i][o] = l._w[o * l._previous._a.length + i];\n                          }\n                          ref._nn.hBiases[o] = l._b[o];\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                        }\n                        l = neurons[2];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                            ref._nn.hoWeights[i][o] = l._w[o * l._previous._a.length + i];\n                          }\n                          ref._nn.oBiases[o] = l._b[o];\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                        }\n\n                        // Train the Reference\n                        ref.train((int)p.epochs, rate, p.momentum_stable, loss);\n\n                        // Train H2O\n                        mymodel = p.trainModel(mymodel);\n\n                        /**\n                         * Tolerances (super tight -> expect the same double/float precision math inside both algos)\n                         */\n                        final double abseps = 1e-13;\n                        final double releps = 1e-13;\n\n                        /**\n                         * Compare weights and biases in hidden layer\n                         */\n                        neurons = NNTask.makeNeuronsForTesting(mymodel.model_info()); //link the weights to the neurons, for easy access\n                        l = neurons[1];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n                            double a = ref._nn.ihWeights[i][o];\n                            double b = l._w[o * l._previous._a.length + i];\n                            compareVal(a, b, abseps, releps);\n//                          System.out.println(\"weight[\" + o + \"]=\" + b);\n                          }\n                          double ba = ref._nn.hBiases[o];\n                          double bb = l._b[o];\n                          compareVal(ba, bb, abseps, releps);\n                        }\n                        Log.info(\"Weights and biases for hidden layer: PASS\");\n\n                        /**\n                         * Compare weights and biases for output layer\n                         */\n                        l = neurons[2];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n                            double a = ref._nn.hoWeights[i][o];\n                            double b = l._w[o * l._previous._a.length + i];\n                            compareVal(a, b, abseps, releps);\n                          }\n                          double ba = ref._nn.oBiases[o];\n                          double bb = l._b[o];\n                          compareVal(ba, bb, abseps, releps);\n                        }\n                        Log.info(\"Weights and biases for output layer: PASS\");\n\n                        /**\n                         * Compare predictions\n                         * Note: Reference and H2O each do their internal data normalization,\n                         * so we must use their \"own\" test data, which is assumed to be created correctly.\n                         */\n                        // H2O predictions\n                        Frame fpreds = mymodel.score(_test); //[0] is label, [1]...[4] are the probabilities\n\n                        for (int i=0; i<_test.numRows(); ++i) {\n                          // Reference predictions\n                          double[] xValues = new double[neurons[0]._a.length];\n                          System.arraycopy(ref._testData[i], 0, xValues, 0, xValues.length);\n                          double[] ref_preds = ref._nn.ComputeOutputs(xValues);\n\n                          // find the label\n                          // do the same as H2O here (compare float values and break ties based on row number)\n                          float[] preds = new float[ref_preds.length+1];\n                          for (int j=0; j<ref_preds.length; ++j) preds[j+1] = (float)ref_preds[j];\n                          preds[0] = getPrediction(preds, i);\n\n                          // compare predicted label\n                          Assert.assertTrue(preds[0] == (int) fpreds.vecs()[0].at(i));\n                          // compare predicted probabilities\n                          for (int j=0; j<ref_preds.length; ++j) {\n                            compareVal((float)(ref_preds[j]), fpreds.vecs()[1+j].at(i), abseps, releps);\n                          }\n                        }\n                        fpreds.delete();\n                        Log.info(\"Predicted values: PASS\");\n\n                        /**\n                         * Compare (self-reported) scoring\n                         */\n                        final double trainErr = ref._nn.Accuracy(ref._trainData);\n                        final double testErr = ref._nn.Accuracy(ref._testData);\n                        final Frame trainPredict = mymodel.score(_train, false);\n                        final double myTrainErr = mymodel.calcError(_train, trainPredict, \"Final training error:\", true, null);\n                        final Frame testPredict = mymodel.score(_test, false);\n                        final double myTestErr = mymodel.calcError(_test, testPredict, \"Final testing error:\",  true, null);\n                        Log.info(\"H2O  training error : \" + myTrainErr*100 + \"%, test error: \" + myTestErr*100 + \"%\");\n                        Log.info(\"REF  training error : \" + trainErr*100 + \"%, test error: \" + testErr*100 + \"%\");\n                        compareVal(trainErr, myTrainErr, abseps, releps);\n                        compareVal(testErr,  myTestErr,  abseps, releps);\n                        Log.info(\"Scoring: PASS\");\n\n                        // cleanup\n                        mymodel.delete();\n                        _train.delete();\n                        _test.delete();\n                        frame.delete();\n                        fr.delete();\n                        p.delete();\n                        trainPredict.delete();\n                        testPredict.delete();\n\n                        num_runs++;\n                        Log.info(\"Parameters combination \" + num_runs + \": PASS\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }","id":95699,"modified_method":"@Test public void compare() throws Exception {\n\n    for (int repeat = 0; repeat < 1; ++repeat) {\n      // Testing different things\n      // Note: Microsoft reference implementation is only for Tanh + MSE, rectifier and MCE are implemented by 0xdata (trivial).\n      // Note: Initial weight distributions are copied, but what is tested is the stability behavior.\n\n      NN.Activation[] activations = { NN.Activation.Tanh, NN.Activation.Rectifier };\n      NN.Loss[] losses = { NN.Loss.MeanSquare, NN.Loss.CrossEntropy };\n      NN.InitialWeightDistribution[] dists = {\n//              NN.InitialWeightDistribution.Normal,\n//              NN.InitialWeightDistribution.Uniform,\n              NN.InitialWeightDistribution.UniformAdaptive\n      };\n      double[] initial_weight_scales = { 1e-4 + new Random().nextDouble() };\n      double[] holdout_ratios = { 0.1 + new Random().nextDouble() * 0.8 };\n      double[] momenta = { new Random().nextDouble() * 0.99 };\n      int[] hiddens = { 1, 2 + new Random().nextInt(50) };\n      int[] epochs = { 1, 2 + new Random().nextInt(50) };\n      double[] rates = { 0.01, 1e-5 + new Random().nextDouble() * .1 };\n\n      int num_runs = 0;\n      for (NN.Activation activation : activations) {\n        for (NN.Loss loss : losses) {\n          for (NN.InitialWeightDistribution dist : dists) {\n            for (double scale : initial_weight_scales) {\n              for (double holdout_ratio : holdout_ratios) {\n                for (double momentum : momenta) {\n                  for (int hidden : hiddens) {\n                    for (int epoch : epochs) {\n                      for (double rate : rates) {\n                        long seed = new Random().nextLong();\n                        Log.info(\"\");\n                        Log.info(\"STARTING.\");\n                        Log.info(\"Running with \" + activation.name() + \" activation function and \" + loss.name() + \" loss function.\");\n                        Log.info(\"Initialization with \" + dist.name() + \" distribution and \" + scale + \" scale, holdout ratio \" + holdout_ratio);\n                        Log.info(\"Using \" + hidden + \" hidden layers and momentum: \" + momentum);\n                        Log.info(\"Using seed \" + seed);\n\n                        Key file = NFSFileVec.make(find_test_file(PATH));\n                        Frame frame = ParseDataset2.parse(Key.make(\"iris_nn2\"), new Key[] { file });\n\n                        Frame fr = null;\n                        NN p;\n                        Random rand;\n\n                        int trial = 0;\n                        FrameTask.DataInfo dinfo;\n                        do {\n                          Log.info(\"Trial #\" + ++trial);\n                          if (_train != null) _train.delete();\n                          if (_test != null) _test.delete();\n                          if (fr != null) fr.delete();\n\n                          rand = Utils.getDeterRNG(seed);\n\n                          double[][] rows = new double[(int) frame.numRows()][frame.numCols()];\n                          String[] names = new String[frame.numCols()];\n                          for( int c = 0; c < frame.numCols(); c++ ) {\n                            names[c] = \"ColumnName\" + c;\n                            for( int r = 0; r < frame.numRows(); r++ )\n                              rows[r][c] = frame.vecs()[c].at(r);\n                          }\n\n                          for( int i = rows.length - 1; i >= 0; i-- ) {\n                            int shuffle = rand.nextInt(i + 1);\n                            double[] row = rows[shuffle];\n                            rows[shuffle] = rows[i];\n                            rows[i] = row;\n                          }\n\n                          int limit = (int) (frame.numRows() * holdout_ratio);\n                          _train = frame(names, Utils.subarray(rows, 0, limit));\n                          _test = frame(names, Utils.subarray(rows, limit, (int) frame.numRows() - limit));\n\n                          p = new NN();\n                          p.source = _train;\n                          p.response = _train.lastVec();\n                          p.ignored_cols = null;\n                          p.ignore_const_cols = true;\n                          fr = FrameTask.DataInfo.prepareFrame(p.source, p.response, p.ignored_cols, true, p.ignore_const_cols);\n                          dinfo = new FrameTask.DataInfo(fr, 1, true);\n                        }\n                        // must have all output classes in training data (since that's what the reference implementation has hardcoded)\n                        while (dinfo._adaptedFrame.lastVec().domain().length < 3);\n\n                        // use the same seed for the reference implementation\n                        NeuralNetMLPReference2 ref = new NeuralNetMLPReference2();\n                        ref.init(activation, Utils.getDeterRNG(seed), holdout_ratio, hidden);\n\n                        p.seed = seed;\n                        p.hidden = new int[]{hidden};\n                        p.rate = rate / (1 - momentum); //adapt to (1-m) correction that's done inside (only for constant momentum!)\n                        p.activation = activation;\n                        p.max_w2 = Double.MAX_VALUE;\n                        p.epochs = epoch;\n                        p.input_dropout_ratio = 0;\n                        p.rate_annealing = 0; //do not change - not implemented in reference\n                        p.l1 = 0;\n                        p.loss = loss;\n                        p.l2 = 0;\n                        p.momentum_stable = momentum; //reference only supports constant momentum\n                        p.momentum_start = p.momentum_stable; //do not change - not implemented in reference\n                        p.momentum_ramp = 0; //do not change - not implemented in reference\n                        p.initial_weight_distribution = dist;\n                        p.initial_weight_scale = scale;\n                        p.classification = true;\n                        p.diagnostics = true;\n                        p.validation = null;\n                        p.quiet_mode = true;\n                        p.fast_mode = false; //to be the same as reference\n//                      p.fast_mode = true; //to be the same as old NeuralNet code\n                        p.nesterov_accelerated_gradient = false; //to be the same as reference\n//                        p.nesterov_accelerated_gradient = true; //to be the same as old NeuralNet code\n                        p.mini_batch = 0; //sync once per period\n                        p.ignore_const_cols = false;\n                        p.shuffle_training_data = false;\n                        p.classification_stop = -1; //don't stop early -> need to compare against reference, which doesn't stop either\n                        p.force_load_balance = false; //keep just 1 chunk for reproducibility\n                        NNModel mymodel = p.initModel(); //randomize weights, but don't start training yet\n\n                        Neurons[] neurons = NNTask.makeNeuronsForTraining(mymodel.model_info());\n\n                        // use the same random weights for the reference implementation\n                        Neurons l = neurons[1];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                            ref._nn.ihWeights[i][o] = l._w[o * l._previous._a.length + i];\n                          }\n                          ref._nn.hBiases[o] = l._b[o];\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                        }\n                        l = neurons[2];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                            ref._nn.hoWeights[i][o] = l._w[o * l._previous._a.length + i];\n                          }\n                          ref._nn.oBiases[o] = l._b[o];\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                        }\n\n                        // Train the Reference\n                        ref.train((int)p.epochs, rate, p.momentum_stable, loss);\n\n                        // Train H2O\n                        mymodel = p.trainModel(mymodel);\n\n                        /**\n                         * Tolerances (super tight -> expect the same double/float precision math inside both algos)\n                         */\n                        final double abseps = 1e-13;\n                        final double releps = 1e-13;\n\n                        /**\n                         * Compare weights and biases in hidden layer\n                         */\n                        neurons = NNTask.makeNeuronsForTesting(mymodel.model_info()); //link the weights to the neurons, for easy access\n                        l = neurons[1];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n                            double a = ref._nn.ihWeights[i][o];\n                            double b = l._w[o * l._previous._a.length + i];\n                            compareVal(a, b, abseps, releps);\n//                          System.out.println(\"weight[\" + o + \"]=\" + b);\n                          }\n                          double ba = ref._nn.hBiases[o];\n                          double bb = l._b[o];\n                          compareVal(ba, bb, abseps, releps);\n                        }\n                        Log.info(\"Weights and biases for hidden layer: PASS\");\n\n                        /**\n                         * Compare weights and biases for output layer\n                         */\n                        l = neurons[2];\n                        for( int o = 0; o < l._a.length; o++ ) {\n                          for( int i = 0; i < l._previous._a.length; i++ ) {\n                            double a = ref._nn.hoWeights[i][o];\n                            double b = l._w[o * l._previous._a.length + i];\n                            compareVal(a, b, abseps, releps);\n                          }\n                          double ba = ref._nn.oBiases[o];\n                          double bb = l._b[o];\n                          compareVal(ba, bb, abseps, releps);\n                        }\n                        Log.info(\"Weights and biases for output layer: PASS\");\n\n                        /**\n                         * Compare predictions\n                         * Note: Reference and H2O each do their internal data normalization,\n                         * so we must use their \"own\" test data, which is assumed to be created correctly.\n                         */\n                        // H2O predictions\n                        Frame fpreds = mymodel.score(_test); //[0] is label, [1]...[4] are the probabilities\n\n                        for (int i=0; i<_test.numRows(); ++i) {\n                          // Reference predictions\n                          double[] xValues = new double[neurons[0]._a.length];\n                          System.arraycopy(ref._testData[i], 0, xValues, 0, xValues.length);\n                          double[] ref_preds = ref._nn.ComputeOutputs(xValues);\n\n                          // find the label\n                          // do the same as H2O here (compare float values and break ties based on row number)\n                          float[] preds = new float[ref_preds.length+1];\n                          for (int j=0; j<ref_preds.length; ++j) preds[j+1] = (float)ref_preds[j];\n                          preds[0] = getPrediction(preds, i);\n\n                          // compare predicted label\n                          Assert.assertTrue(preds[0] == (int) fpreds.vecs()[0].at(i));\n                          // compare predicted probabilities\n                          for (int j=0; j<ref_preds.length; ++j) {\n                            compareVal((float)(ref_preds[j]), fpreds.vecs()[1+j].at(i), abseps, releps);\n                          }\n                        }\n                        fpreds.delete();\n                        Log.info(\"Predicted values: PASS\");\n\n                        /**\n                         * Compare (self-reported) scoring\n                         */\n                        final double trainErr = ref._nn.Accuracy(ref._trainData);\n                        final double testErr = ref._nn.Accuracy(ref._testData);\n                        final Frame trainPredict = mymodel.score(_train, false);\n                        final double myTrainErr = mymodel.calcError(_train, trainPredict, \"Final training error:\", true, null, null);\n                        final Frame testPredict = mymodel.score(_test, false);\n                        final double myTestErr = mymodel.calcError(_test, testPredict, \"Final testing error:\",  true, null, null);\n                        Log.info(\"H2O  training error : \" + myTrainErr*100 + \"%, test error: \" + myTestErr*100 + \"%\");\n                        Log.info(\"REF  training error : \" + trainErr*100 + \"%, test error: \" + testErr*100 + \"%\");\n                        compareVal(trainErr, myTrainErr, abseps, releps);\n                        compareVal(testErr,  myTestErr,  abseps, releps);\n                        Log.info(\"Scoring: PASS\");\n\n                        // cleanup\n                        mymodel.delete();\n                        _train.delete();\n                        _test.delete();\n                        frame.delete();\n                        fr.delete();\n                        p.delete();\n                        trainPredict.delete();\n                        testPredict.delete();\n\n                        num_runs++;\n                        Log.info(\"Parameters combination \" + num_runs + \": PASS\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"63e86529cb5acbf822d2863ffdcbec696111113c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n     * Converts the host of an URI to Punycode.<p>\n     *\n     * This is needed when we want to do redirects to hosts with host names containing international characters like umlauts.<p>\n     *\n     * @param uriString the URI\n     * @return the converted URI\n     */\n    public static String convertHostToPunycode(String uriString) {\n\n        if (uriString.indexOf(\":\") >= 0) {\n            try {\n                URI uri = new URI(uriString);\n                String authority = uri.getAuthority(); // getHost won't work when we have special characters\n                URI uriWithCorrectedHost = new URI(\n                    uri.getScheme(),\n                    IDN.toASCII(authority),\n                    uri.getPath(),\n                    uri.getQuery(),\n                    uri.getFragment());\n                uriString = uriWithCorrectedHost.toASCIIString();\n            } catch (URISyntaxException e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        return uriString;\n    }","id":95700,"modified_method":"/**\n     * Converts the host of an URI to Punycode.<p>\n     *\n     * This is needed when we want to do redirects to hosts with host names containing international characters like umlauts.<p>\n     *\n     * @param uriString the URI\n     * @return the converted URI\n     */\n    public static String convertHostToPunycode(String uriString) {\n\n        if (uriString.indexOf(\":\") >= 0) {\n            try {\n                URI uri = new URI(uriString);\n                String authority = uri.getAuthority(); // getHost won't work when we have special characters\n                int colonPos = authority.indexOf(':');\n                if (colonPos >= 0) {\n                    authority = IDN.toASCII(authority.substring(0, colonPos)) + authority.substring(colonPos);\n                } else {\n                    authority = IDN.toASCII(authority);\n                }\n                URI uriWithCorrectedHost = new URI(\n                    uri.getScheme(),\n                    authority,\n                    uri.getPath(),\n                    uri.getQuery(),\n                    uri.getFragment());\n                uriString = uriWithCorrectedHost.toASCIIString();\n            } catch (URISyntaxException e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        return uriString;\n    }","commit_id":"b7ccf2e2505cffcf11025a3ef0f26e54e2abd7a5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Converts the host of an URI to Punycode.<p>\n     *\n     * This is needed when we want to do redirects to hosts with host names containing international characters like umlauts.<p>\n     *\n     * @param uriString the URI\n     * @return the converted URI\n     */\n    public static String convertHostToPunycode(String uriString) {\n\n        if (uriString.indexOf(\":\") >= 0) {\n            try {\n                URI uri = new URI(uriString);\n                String authority = uri.getAuthority(); // getHost won't work when we have special characters\n                URI uriWithCorrectedHost = new URI(\n                    uri.getScheme(),\n                    IDN.toASCII(authority),\n                    uri.getPath(),\n                    uri.getQuery(),\n                    uri.getFragment());\n                uriString = uriWithCorrectedHost.toASCIIString();\n            } catch (URISyntaxException e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        return uriString;\n    }","id":95701,"modified_method":"/**\n     * Converts the host of an URI to Punycode.<p>\n     *\n     * This is needed when we want to do redirects to hosts with host names containing international characters like umlauts.<p>\n     *\n     * @param uriString the URI\n     * @return the converted URI\n     */\n    public static String convertHostToPunycode(String uriString) {\n\n        if (uriString.indexOf(\":\") >= 0) {\n            try {\n                URI uri = new URI(uriString);\n                String authority = uri.getAuthority(); // getHost won't work when we have special characters\n                int colonPos = authority.indexOf(':');\n                if (colonPos >= 0) {\n                    authority = IDN.toASCII(authority.substring(0, colonPos)) + authority.substring(colonPos);\n                } else {\n                    authority = IDN.toASCII(authority);\n                }\n                URI uriWithCorrectedHost = new URI(\n                    uri.getScheme(),\n                    authority,\n                    uri.getPath(),\n                    uri.getQuery(),\n                    uri.getFragment());\n                uriString = uriWithCorrectedHost.toASCIIString();\n            } catch (URISyntaxException e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        return uriString;\n    }","commit_id":"270679c0295fb86b0497dd4f7ccff2c35798cdb1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void record(String session, RecordEvent message) {\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tjedis.hmset(\"recording\" + COLON + session + COLON + msgid, message.toMap());\r\n\t\tjedis.rpush(\"meeting\" + COLON + session + COLON + \"recordings\", msgid.toString());\t\t\t\t\t\t\r\n\t}","id":95702,"modified_method":"private void record(String session, RecordEvent message) {\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tString key = \"recording\" + COLON + session + COLON + msgid;\r\n\t\tjedis.hmset(key, message.toMap());\r\n\t\t/**\r\n\t\t * We set the key to expire after 14 days as we are still\r\n\t\t * recording the event into redis even if the meeting is not\r\n\t\t * recorded. (ralam sept 23, 2015) \r\n\t\t */\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t\tkey = \"meeting\" + COLON + session + COLON + \"recordings\";\r\n\t\tjedis.rpush(key, msgid.toString());\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t}","commit_id":"4d27b460ae2c55033a0dcf265a1fd8fef7911e9a","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void record(String meetingId, Map<String, String> event) {\t\t\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tjedis.hmset(\"recording:\" + meetingId + COLON + msgid, event);\r\n\t\tjedis.rpush(\"meeting:\" + meetingId + COLON + \"recordings\", msgid.toString());\t\t\t\t\t\t\r\n\t}","id":95703,"modified_method":"public void record(String meetingId, Map<String, String> event) {\t\t\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tString key = \"recording:\" + meetingId + COLON + msgid;\r\n\t\tjedis.hmset(key, event);\r\n\t\t/**\r\n\t\t * We set the key to expire after 14 days as we are still\r\n\t\t * recording the event into redis even if the meeting is not\r\n\t\t * recorded. (ralam sept 23, 2015) \r\n\t\t */\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t\tkey = \"meeting:\" + meetingId + COLON + \"recordings\";\r\n\t\tjedis.rpush(key, msgid.toString());\t\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t}","commit_id":"4d27b460ae2c55033a0dcf265a1fd8fef7911e9a","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public EventRecorder(String host, int port){\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\t\t\r\n\t}","id":95704,"modified_method":"public EventRecorder(String host, int port, int keyExpiry){\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\t\t\r\n\t\tthis.keyExpiry = keyExpiry;\r\n\t}","commit_id":"f501fb5803d4b9e9b65cf94c3aeac655d857c847","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void record(String session, RecordEvent message) {\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tString key = \"recording\" + COLON + session + COLON + msgid;\r\n\t\tjedis.hmset(key, message.toMap());\r\n\t\t/**\r\n\t\t * We set the key to expire after 14 days as we are still\r\n\t\t * recording the event into redis even if the meeting is not\r\n\t\t * recorded. (ralam sept 23, 2015) \r\n\t\t */\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t\tkey = \"meeting\" + COLON + session + COLON + \"recordings\";\r\n\t\tjedis.rpush(key, msgid.toString());\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t}","id":95705,"modified_method":"private void record(String session, RecordEvent message) {\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tString key = \"recording\" + COLON + session + COLON + msgid;\r\n\t\tjedis.hmset(key, message.toMap());\r\n\t\t/**\r\n\t\t * We set the key to expire after 14 days as we are still\r\n\t\t * recording the event into redis even if the meeting is not\r\n\t\t * recorded. (ralam sept 23, 2015) \r\n\t\t */\r\n\t\tjedis.expire(key, keyExpiry);\r\n\t\tkey = \"meeting\" + COLON + session + COLON + \"recordings\";\r\n\t\tjedis.rpush(key, msgid.toString());\r\n\t\tjedis.expire(key, keyExpiry);\r\n\t}","commit_id":"f501fb5803d4b9e9b65cf94c3aeac655d857c847","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void record(String meetingId, Map<String, String> event) {\t\t\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tString key = \"recording:\" + meetingId + COLON + msgid;\r\n\t\tjedis.hmset(key, event);\r\n\t\t/**\r\n\t\t * We set the key to expire after 14 days as we are still\r\n\t\t * recording the event into redis even if the meeting is not\r\n\t\t * recorded. (ralam sept 23, 2015) \r\n\t\t */\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t\tkey = \"meeting:\" + meetingId + COLON + \"recordings\";\r\n\t\tjedis.rpush(key, msgid.toString());\t\r\n\t\tjedis.expire(key, 14*24*60*60 /*14days*/);\r\n\t}","id":95706,"modified_method":"public void record(String meetingId, Map<String, String> event) {\t\t\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tString key = \"recording:\" + meetingId + COLON + msgid;\r\n\t\tjedis.hmset(key, event);\r\n\t\t/**\r\n\t\t * We set the key to expire after 14 days as we are still\r\n\t\t * recording the event into redis even if the meeting is not\r\n\t\t * recorded. (ralam sept 23, 2015) \r\n\t\t */\r\n\t\tjedis.expire(key, keyExpiry);\r\n\t\tkey = \"meeting:\" + meetingId + COLON + \"recordings\";\r\n\t\tjedis.rpush(key, msgid.toString());\t\r\n\t\tjedis.expire(key, keyExpiry);\r\n\t}","commit_id":"f501fb5803d4b9e9b65cf94c3aeac655d857c847","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public EventRecordingService(String host, int port) {\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\r\n\t}","id":95707,"modified_method":"public EventRecordingService(String host, int port, int keyExpiry) {\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\r\n\t\tthis.keyExpiry = keyExpiry;\r\n\t}","commit_id":"f501fb5803d4b9e9b65cf94c3aeac655d857c847","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public RedisDispatcher(String host, int port, String password) {\r\n\t\tGenericObjectPoolConfig config = new GenericObjectPoolConfig();\r\n\t\tconfig.setMaxTotal(32);\r\n\t\tconfig.setMaxIdle(8);\r\n\t\tconfig.setMinIdle(1);\r\n\t\tconfig.setTestOnBorrow(true);\r\n\t\tconfig.setTestOnReturn(true);\r\n\t\tconfig.setTestWhileIdle(true);\r\n\t\tconfig.setNumTestsPerEvictionRun(12);\r\n\t\tconfig.setMaxWaitMillis(5000);\r\n\t\tconfig.setTimeBetweenEvictionRunsMillis(60000);\r\n\t\tconfig.setBlockWhenExhausted(true);\r\n\t\t\r\n\t\t// Set the name of this client to be able to distinguish when doing\r\n\t\t// CLIENT LIST on redis-cli\r\n\t\tredisPool = new JedisPool(config, host, port, Protocol.DEFAULT_TIMEOUT, null,\r\n\t\t        Protocol.DEFAULT_DATABASE, \"BbbAppsAkkaRec\");\r\n\t}","id":95708,"modified_method":"public RedisDispatcher(String host, int port, String password, int keysExpiresInSec) {\r\n\t\tGenericObjectPoolConfig config = new GenericObjectPoolConfig();\r\n\t\tconfig.setMaxTotal(32);\r\n\t\tconfig.setMaxIdle(8);\r\n\t\tconfig.setMinIdle(1);\r\n\t\tconfig.setTestOnBorrow(true);\r\n\t\tconfig.setTestOnReturn(true);\r\n\t\tconfig.setTestWhileIdle(true);\r\n\t\tconfig.setNumTestsPerEvictionRun(12);\r\n\t\tconfig.setMaxWaitMillis(5000);\r\n\t\tconfig.setTimeBetweenEvictionRunsMillis(60000);\r\n\t\tconfig.setBlockWhenExhausted(true);\r\n\t\t\r\n\t\tthis.keysExpiresInSec = keysExpiresInSec;\r\n\t\t\r\n\t\t// Set the name of this client to be able to distinguish when doing\r\n\t\t// CLIENT LIST on redis-cli\r\n\t\tredisPool = new JedisPool(config, host, port, Protocol.DEFAULT_TIMEOUT, null,\r\n\t\t        Protocol.DEFAULT_DATABASE, \"BbbAppsAkkaRec\");\r\n\t}","commit_id":"f501fb5803d4b9e9b65cf94c3aeac655d857c847","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n\tpublic void record(String session, RecordEvent message) {\t\t\r\n\t\tJedis jedis = redisPool.getResource();\r\n\t\ttry {\r\n\t\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\t\tjedis.hmset(\"recording\" + COLON + session + COLON + msgid, message.toMap());\r\n\t\t\tjedis.rpush(\"meeting\" + COLON + session + COLON + \"recordings\", msgid.toString());\r\n\t\t} finally {\r\n\t\t\tjedis.close();\r\n\t\t}\t\t\t\t\t\t\r\n\t}","id":95709,"modified_method":"@Override\r\n\tpublic void record(String session, RecordEvent message) {\t\t\r\n\t\tJedis jedis = redisPool.getResource();\r\n\t\ttry {\r\n\t\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\t\tString key = \"recording\" + COLON + session + COLON + msgid;\r\n\t\t\tjedis.hmset(key, message.toMap());\r\n\t\t\tjedis.expire(key, keysExpiresInSec);\r\n\t\t\tkey = \"meeting\" + COLON + session + COLON + \"recordings\";\r\n\t\t\tjedis.rpush(key, msgid.toString());\r\n\t\t\tjedis.expire(key, keysExpiresInSec);\r\n\t\t} finally {\r\n\t\t\tjedis.close();\r\n\t\t}\t\t\t\t\t\t\r\n\t}","commit_id":"f501fb5803d4b9e9b65cf94c3aeac655d857c847","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@NotNull\n  public static List<String> toCommandLine(@NotNull String command, @NotNull List<String> parameters, @NotNull Platform platform) {\n    List<String> commandLine = ContainerUtil.newArrayListWithCapacity(parameters.size() + 1);\n\n    commandLine.add(FileUtilRt.toSystemDependentName(command, platform.fileSeparator));\n\n    boolean isWindows = platform == Platform.WINDOWS;\n    boolean winShell = isWindows && isWinShell(command, parameters);\n\n    for (String parameter : parameters) {\n      if (isWindows) {\n        if (parameter.contains(\"\\\"\")) {\n          parameter = StringUtil.replace(parameter, \"\\\"\", \"\\\\\\\"\");\n        }\n        else if (parameter.isEmpty()) {\n          parameter = \"\\\"\\\"\";\n        }\n      }\n\n      if (winShell && StringUtil.containsAnyChar(parameter, WIN_SHELL_SPECIALS)) {\n        parameter = quote(parameter, SPECIAL_QUOTE);\n      }\n\n      if (isQuoted(parameter, SPECIAL_QUOTE)) {\n        parameter = quote(parameter.substring(1, parameter.length() - 1), '\"');\n      }\n\n      commandLine.add(parameter);\n    }\n\n    return commandLine;\n  }","id":95710,"modified_method":"@NotNull\n  public static List<String> toCommandLine(@NotNull String command, @NotNull List<String> parameters, @NotNull Platform platform) {\n    List<String> commandLine = ContainerUtil.newArrayListWithCapacity(parameters.size() + 1);\n\n    commandLine.add(FileUtilRt.toSystemDependentName(command, platform.fileSeparator));\n\n    boolean isWindows = platform == Platform.WINDOWS;\n    boolean winShell = isWindows && isWinShell(command);\n\n    for (String parameter : parameters) {\n      if (isWindows) {\n        if (parameter.contains(\"\\\"\")) {\n          parameter = StringUtil.replace(parameter, \"\\\"\", \"\\\\\\\"\");\n        }\n        else if (parameter.isEmpty()) {\n          parameter = \"\\\"\\\"\";\n        }\n      }\n\n      if (winShell && StringUtil.containsAnyChar(parameter, WIN_SHELL_SPECIALS)) {\n        parameter = quote(parameter, SPECIAL_QUOTE);\n      }\n\n      if (isQuoted(parameter, SPECIAL_QUOTE)) {\n        parameter = quote(parameter.substring(1, parameter.length() - 1), '\"');\n      }\n\n      commandLine.add(parameter);\n    }\n\n    return commandLine;\n  }","commit_id":"40420a048fc541cb3ed5e4fd3303b79b0abec213","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isWinShell(@NotNull String command, @NotNull List<String> parameters) {\n    if (command.endsWith(\".cmd\") || command.endsWith(\".bat\")) {\n      return true;\n    }\n    return (\"cmd\".equalsIgnoreCase(command) || \"cmd.exe\".equalsIgnoreCase(command)) &&\n           parameters.size() > 1 && \"/c\".equalsIgnoreCase(parameters.get(0));\n  }","id":95711,"modified_method":"private static boolean isWinShell(@NotNull String command) {\n    return endsWithIgnoreCase(command, \".cmd\") || endsWithIgnoreCase(command, \".bat\") ||\n           \"cmd\".equalsIgnoreCase(command) || \"cmd.exe\".equalsIgnoreCase(command);\n  }","commit_id":"40420a048fc541cb3ed5e4fd3303b79b0abec213","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isWinShell(String command) {\n    if (command.endsWith(\".cmd\") || command.endsWith(\".bat\")) {\n      return true;\n    }\n    return (\"cmd\".equalsIgnoreCase(command) || \"cmd.exe\".equalsIgnoreCase(command)) &&\n           myParameters.size() > 1 && \"/c\".equalsIgnoreCase(myParameters.get(0).toString());\n  }","id":95712,"modified_method":"private static boolean isWinShell(String command) {\n    return endsWithIgnoreCase(command, \".cmd\") || endsWithIgnoreCase(command, \".bat\") ||\n           \"cmd\".equalsIgnoreCase(command) || \"cmd.exe\".equalsIgnoreCase(command);\n  }","commit_id":"40420a048fc541cb3ed5e4fd3303b79b0abec213","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ClassSymbol loadClass(String pkgName, String className) {\n        ClassSymbol moduleClass = null;\n        try{\n            PackageSymbol javaPkg = reader.enterPackage(names.fromString(pkgName));\n            javaPkg.complete();\n            moduleClass = lookupClassSymbol(className);\n        }catch(CompletionFailure x){\n            System.err.println(\"Failed to complete \"+className);\n        }\n        return moduleClass;\n    }","id":95713,"modified_method":"private ClassSymbol loadClass(String pkgName, String className) {\n        ClassSymbol moduleClass = null;\n        try{\n            PackageSymbol javaPkg = pkgName.equals(\"\") ? syms().unnamedPackage : reader.enterPackage(names.fromString(pkgName));\n            javaPkg.complete();\n            moduleClass = lookupClassSymbol(className);\n        }catch(CompletionFailure x){\n            System.err.println(\"Failed to complete \"+className);\n        }\n        return moduleClass;\n    }","commit_id":"1cdd27ea6d7386cac73937c48d795c64f3f50cd7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"void loadPackage(String packageName) {\n        // abort if we already loaded it\n        if(!loadedPackages.add(packageName))\n            return;\n        PackageSymbol ceylonPkg = reader.enterPackage(names.fromString(packageName));\n        ceylonPkg.complete();\n        /*\n         * Eventually this will go away as we get a hook from the typechecker to load on demand, but\n         * for now the typechecker requires at least ceylon.language to be loaded \n         */\n        for(Symbol m : ceylonPkg.members().getElements()){\n            if(!(m instanceof ClassSymbol))\n                return;\n            ClassSymbol enclosingClass = getEnclosing((ClassSymbol) m);\n            if(enclosingClass.classfile.getKind() != Kind.SOURCE)\n                convertToDeclaration(lookupClassSymbol(m.getQualifiedName().toString()), DeclarationType.VALUE);\n        }\n    }","id":95714,"modified_method":"void loadPackage(String packageName) {\n        // abort if we already loaded it\n        if(!loadedPackages.add(packageName))\n            return;\n        PackageSymbol ceylonPkg = packageName.equals(\"\") ? syms().unnamedPackage : reader.enterPackage(names.fromString(packageName));\n        ceylonPkg.complete();\n        /*\n         * Eventually this will go away as we get a hook from the typechecker to load on demand, but\n         * for now the typechecker requires at least ceylon.language to be loaded \n         */\n        for(Symbol m : ceylonPkg.members().getElements()){\n            if(!(m instanceof ClassSymbol))\n                return;\n            ClassSymbol enclosingClass = getEnclosing((ClassSymbol) m);\n            if(enclosingClass.classfile.getKind() != Kind.SOURCE)\n                convertToDeclaration(lookupClassSymbol(m.getQualifiedName().toString()), DeclarationType.VALUE);\n        }\n    }","commit_id":"1cdd27ea6d7386cac73937c48d795c64f3f50cd7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public Declaration getDirectMember(String name) {\n        String pkgName = getQualifiedNameString();\n        // we need its package ready first\n        PackageSymbol javaPkg = reader.enterPackage(names.fromString(pkgName ));\n        javaPkg.complete();\n        String className = getQualifiedName(pkgName, name);\n        ClassSymbol classSymbol = modelLoader.lookupClassSymbol(className);\n        // only get it from the classpath if we're not compiling it\n        if(classSymbol != null && classSymbol.classfile.getKind() != Kind.SOURCE)\n            return modelLoader.convertToDeclaration(className, DeclarationType.VALUE);\n        return super.getDirectMember(name);\n    }","id":95715,"modified_method":"@Override\n    public Declaration getDirectMember(String name) {\n        String pkgName = getQualifiedNameString();\n        // we need its package ready first\n        \n        PackageSymbol javaPkg = null;\n        if (pkgName.equals(\"\")) {\n            javaPkg = modelLoader.syms().unnamedPackage;\n        }\n        else {\n            javaPkg = reader.enterPackage(names.fromString(pkgName ));\n        }\n        \n        javaPkg.complete();\n        String className = getQualifiedName(pkgName, name);\n        ClassSymbol classSymbol = modelLoader.lookupClassSymbol(className);\n        // only get it from the classpath if we're not compiling it\n        if(classSymbol != null && classSymbol.classfile.getKind() != Kind.SOURCE)\n            return modelLoader.convertToDeclaration(className, DeclarationType.VALUE);\n        return super.getDirectMember(name);\n    }","commit_id":"1ef4725a8a3c3ef58be8cf4039acb080df92dbbf","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static CustomParser.PSetupGuess guessSetup(byte[] bits, ParserSetup setup, boolean checkHeader) {\n    ArrayList<String> lines = new ArrayList();\n    int offset = 0;\n    while (offset < bits.length && lines.size() < 10) {\n      int lineStart = offset;\n      while ((offset < bits.length) && (bits[offset] != CHAR_CR) && (bits[offset] != CHAR_LF)) ++offset;\n      int lineEnd = offset;\n      ++offset;\n      if ((offset < bits.length) && (bits[offset] == CHAR_LF)) ++offset;\n      if (bits[lineStart] == '#') continue; // Ignore      comment lines\n      if (bits[lineStart] == '@') continue; // Ignore ARFF comment lines\n      if (lineEnd>lineStart)\n        lines.add(new String(bits,lineStart, lineEnd-lineStart));\n    }\n    if(lines.isEmpty())\n      return new PSetupGuess(new ParserSetup(ParserType.AUTO,CsvParser.AUTO_SEP,0,false,null),0,0,null,null);\n    boolean hasHeader = false;\n    byte sep = setup._separator;\n    final String [][] data = new String[lines.size()][];\n    if( lines.size() < 2 ) {\n      if(sep == AUTO_SEP){\n        if(lines.get(0).split(\",\").length > 2)\n          sep = (byte)',';\n        else if(lines.get(0).split(\" \").length > 2)\n          sep = ' ';\n        else {\n          data[0] = new String[]{lines.get(0)};\n          return new PSetupGuess(new ParserSetup(ParserType.CSV,CsvParser.AUTO_SEP,1,false,null),lines.size(),0,data,new String[]{\"Failed to guess separator.\"});\n        }\n      }\n      if(lines.size() == 1)\n        data[0] = determineTokens(lines.get(0), sep);\n      hasHeader = (checkHeader && allStrings(data[0])) || setup._header;\n    } else {\n      if(setup._separator == AUTO_SEP) // first guess the separator\n        sep = guessSeparator(lines.get(0), lines.get(1));\n      for(int i = 0; i < lines.size(); ++i)\n        data[i] = determineTokens(lines.get(i), sep);\n      // we do not have enough lines to decide\n      if(checkHeader){\n        assert !setup._header;\n        assert setup._columnNames == null;\n        hasHeader = hasHeader(data[0],data[1]);\n      } else if(setup._header){\n        if(setup._columnNames != null){ // we know what the header looks like, check if the current file has matching header\n          hasHeader = data[0].length == setup._columnNames.length;\n          for(int i = 0; hasHeader && i < data[0].length; ++i)\n            hasHeader = data[0][i].equalsIgnoreCase(setup._columnNames[i]);\n        } else // otherwise we're told to take the first line as header whatever it might be\n          hasHeader = true;\n      }\n    }\n    int ncols = (setup._ncols > 0)?setup._ncols:data[0].length;\n    ParserSetup resSetup = new ParserSetup(ParserType.CSV, sep, ncols,hasHeader, hasHeader?data[0]:null);\n    ArrayList<String> errors = new ArrayList<String>();\n    int ilines = 0;\n    for(int i = 0; i < data.length; ++i){\n      if(data[i].length != resSetup._ncols){\n        errors.add(\"error at line \" + i + \" : incompatoble line length. Got \" + data[i].length + \" columns.\");\n        ++ilines;\n      }\n    }\n    String [] err = null;\n    if(!errors.isEmpty()){\n      err = new String[errors.size()];\n      errors.toArray(err);\n    }\n    return new PSetupGuess(resSetup,lines.size()-ilines,ilines,data,err);\n  }","id":95716,"modified_method":"public static CustomParser.PSetupGuess guessSetup(byte[] bits, ParserSetup setup, boolean checkHeader) {\n    ArrayList<String> lines = new ArrayList();\n    int offset = 0;\n    while (offset < bits.length && lines.size() < 10) {\n      int lineStart = offset;\n      while ((offset < bits.length) && (bits[offset] != CHAR_CR) && (bits[offset] != CHAR_LF)) ++offset;\n      int lineEnd = offset;\n      ++offset;\n      if ((offset < bits.length) && (bits[offset] == CHAR_LF)) ++offset;\n      if (bits[lineStart] == '#') continue; // Ignore      comment lines\n      if (bits[lineStart] == '@') continue; // Ignore ARFF comment lines\n      if (lineEnd>lineStart){\n        String str = new String(bits, lineStart,lineEnd-lineStart).trim();\n        if(!str.isEmpty())lines.add(str);\n      }\n    }\n    if(lines.isEmpty())\n      return new PSetupGuess(new ParserSetup(ParserType.AUTO,CsvParser.AUTO_SEP,0,false,null),0,0,null,null);\n    boolean hasHeader = false;\n    byte sep = setup._separator;\n    final String [][] data = new String[lines.size()][];\n    if( lines.size() < 2 ) {\n      if(sep == AUTO_SEP){\n        if(lines.get(0).split(\",\").length > 2)\n          sep = (byte)',';\n        else if(lines.get(0).split(\" \").length > 2)\n          sep = ' ';\n        else {\n          data[0] = new String[]{lines.get(0)};\n          return new PSetupGuess(new ParserSetup(ParserType.CSV,CsvParser.AUTO_SEP,1,false,null),lines.size(),0,data,new String[]{\"Failed to guess separator.\"});\n        }\n      }\n      if(lines.size() == 1)\n        data[0] = determineTokens(lines.get(0), sep);\n      hasHeader = (checkHeader && allStrings(data[0])) || setup._header;\n    } else {\n      if(setup._separator == AUTO_SEP) // first guess the separator\n        sep = guessSeparator(lines.get(0), lines.get(1));\n      for(int i = 0; i < lines.size(); ++i)\n        data[i] = determineTokens(lines.get(i), sep);\n      // we do not have enough lines to decide\n      if(checkHeader){\n        assert !setup._header;\n        assert setup._columnNames == null;\n        hasHeader = hasHeader(data[0],data[1]);\n      } else if(setup._header){\n        if(setup._columnNames != null){ // we know what the header looks like, check if the current file has matching header\n          hasHeader = data[0].length == setup._columnNames.length;\n          for(int i = 0; hasHeader && i < data[0].length; ++i)\n            hasHeader = data[0][i].equalsIgnoreCase(setup._columnNames[i]);\n        } else // otherwise we're told to take the first line as header whatever it might be\n          hasHeader = true;\n      }\n    }\n    int ncols = (setup._ncols > 0)?setup._ncols:data[0].length;\n    ParserSetup resSetup = new ParserSetup(ParserType.CSV, sep, ncols,hasHeader, hasHeader?data[0]:null);\n    ArrayList<String> errors = new ArrayList<String>();\n    int ilines = 0;\n    for(int i = 0; i < data.length; ++i){\n      if(data[i].length != resSetup._ncols){\n        errors.add(\"error at line \" + i + \" : incompatoble line length. Got \" + data[i].length + \" columns.\");\n        ++ilines;\n      }\n    }\n    String [] err = null;\n    if(!errors.isEmpty()){\n      err = new String[errors.size()];\n      errors.toArray(err);\n    }\n    return new PSetupGuess(resSetup,lines.size()-ilines,ilines,data,err);\n  }","commit_id":"7acc4b03f9b479c5be794b208ed304261c2610e4","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private Callable<Boolean> createDeferredSetup(final String file_path,\n                                                  final String file_nonce,\n                                                  final long txnId,\n                                                  final Map<Integer, Long> partitionTransactionIds,\n                                                  final Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n                                                  final SystemProcedureExecutionContext context,\n                                                  final Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n                                                  final Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n                                                  final long timestamp,\n                                                  final AtomicInteger numTables,\n                                                  final SnapshotRegistry.Snapshot snapshotRecord,\n                                                  final ArrayList<SnapshotTableTask> partitionedSnapshotTasks,\n                                                  final ArrayList<SnapshotTableTask> replicatedSnapshotTasks)\n    {\n        return new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception\n            {\n                NativeSnapshotWritePlan.createFileBasedCompletionTasks(file_path, file_nonce,\n                        txnId, partitionTransactionIds, remoteDCLastIds, context, exportSequenceNumbers, drTupleStreamInfo, null, timestamp,\n                        context.getNumberOfPartitions());\n\n                for (SnapshotTableTask task : replicatedSnapshotTasks) {\n                    final SnapshotDataTarget target = createDataTargetForTable(file_path, file_nonce,\n                            context.getHostId(), numTables, snapshotRecord, task.m_table);\n                    task.setTarget(target);\n                }\n\n                for (SnapshotTableTask task : partitionedSnapshotTasks) {\n                    final SnapshotDataTarget target = createDataTargetForTable(file_path, file_nonce,\n                            context.getHostId(), numTables, snapshotRecord, task.m_table);\n                    task.setTarget(target);\n                }\n\n                return true;\n            }\n        };\n    }","id":95717,"modified_method":"private Callable<Boolean> createDeferredSetup(final String file_path,\n                                                  final String file_nonce,\n                                                  final Table[] tables,\n                                                  final long txnId,\n                                                  final Map<Integer, Long> partitionTransactionIds,\n                                                  final Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n                                                  final SystemProcedureExecutionContext context,\n                                                  final Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n                                                  final Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n                                                  final long timestamp,\n                                                  final AtomicInteger numTables,\n                                                  final SnapshotRegistry.Snapshot snapshotRecord,\n                                                  final ArrayList<SnapshotTableTask> partitionedSnapshotTasks,\n                                                  final ArrayList<SnapshotTableTask> replicatedSnapshotTasks)\n    {\n        return new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception\n            {\n                NativeSnapshotWritePlan.createFileBasedCompletionTasks(file_path, file_nonce,\n                        txnId, partitionTransactionIds, remoteDCLastIds, context, exportSequenceNumbers, drTupleStreamInfo, null, timestamp,\n                        context.getNumberOfPartitions(), tables);\n\n                for (SnapshotTableTask task : replicatedSnapshotTasks) {\n                    final SnapshotDataTarget target = createDataTargetForTable(file_path, file_nonce,\n                            context.getHostId(), numTables, snapshotRecord, task.m_table);\n                    task.setTarget(target);\n                }\n\n                for (SnapshotTableTask task : partitionedSnapshotTasks) {\n                    final SnapshotDataTarget target = createDataTargetForTable(file_path, file_nonce,\n                            context.getHostId(), numTables, snapshotRecord, task.m_table);\n                    task.setTarget(target);\n                }\n\n                return true;\n            }\n        };\n    }","commit_id":"074afdca8d2e4668e2c275f3e324ea04d7ca4e18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public Callable<Boolean> createSetup(\n            String file_path, String file_nonce,\n            long txnId, Map<Integer, Long> partitionTransactionIds,\n            Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n            JSONObject jsData, SystemProcedureExecutionContext context,\n            final VoltTable result,\n            Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n            Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n            SiteTracker tracker,\n            HashinatorSnapshotData hashinatorData,\n            long timestamp)\n    {\n        assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.isEmpty());\n\n        /*\n         * List of partitions to include if this snapshot is\n         * going to be deduped. Attempts to break up the work\n         * by seeding and RNG selecting\n         * a random replica to do the work. Will not work in failure\n         * cases, but we don't use dedupe when we want durability.\n         */\n        List<Long> sitesToInclude = CSVSnapshotWritePlan.computeDedupedLocalSites(txnId, tracker);\n        // If there's no work to do on this host, just claim success and get out:\n        if (sitesToInclude.isEmpty() && !tracker.isFirstHost()) {\n            return null;\n        }\n\n        final List<Table> tables = SnapshotUtil.getTablesToSave(context.getDatabase());\n        final AtomicInteger numTables = new AtomicInteger(tables.size());\n        final SnapshotRegistry.Snapshot snapshotRecord =\n            SnapshotRegistry.startSnapshot(\n                    txnId,\n                    context.getHostId(),\n                    file_path,\n                    file_nonce,\n                    SnapshotFormat.CSV,\n                    tables.toArray(new Table[0]));\n\n        boolean noTargetsCreated = true;\n\n        final ArrayList<SnapshotTableTask> partitionedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        final ArrayList<SnapshotTableTask> replicatedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        for (final Table table : tables)\n        {\n            /*\n             * For a deduped csv snapshot, only produce the replicated tables on the \"leader\"\n             * host.\n             */\n            if (table.getIsreplicated() && !tracker.isFirstHost()) {\n                snapshotRecord.removeTable(table.getTypeName());\n                // We'll expect one less table in the global table count\n                // in order to be done, too (ENG-4802)\n                numTables.decrementAndGet();\n                continue;\n            }\n\n            List<SnapshotDataFilter> filters = new ArrayList<SnapshotDataFilter>();\n            filters.add(new CSVSnapshotFilter(CatalogUtil.getVoltTable(table), ',', null));\n\n            final SnapshotTableTask task =\n                    new SnapshotTableTask(\n                            table,\n                            filters.toArray(new SnapshotDataFilter[filters.size()]),\n                            null,\n                            false);\n\n            if (table.getIsreplicated()) {\n                replicatedSnapshotTasks.add(task);\n            } else {\n                partitionedSnapshotTasks.add(task);\n            }\n\n            noTargetsCreated = false;\n            result.addRow(context.getHostId(),\n                    CoreUtils.getHostnameOrAddress(),\n                    table.getTypeName(),\n                    \"SUCCESS\",\n                    \"\");\n        }\n\n        if (noTargetsCreated) {\n            SnapshotRegistry.discardSnapshot(snapshotRecord);\n        }\n\n        // CSV snapshots do the partitioned work only on the specified sites for de-duping,\n        // but since we've pre-filtered the replicated task list to only contain entries on\n        // one node, we can go ahead and distribute them across all of the sites on that node.\n        placePartitionedTasks(partitionedSnapshotTasks, sitesToInclude);\n        placeReplicatedTasks(replicatedSnapshotTasks, tracker.getSitesForHost(context.getHostId()));\n\n        // All IO work will be deferred and be run on the dedicated snapshot IO thread\n        return createDeferredSetup(file_path, file_nonce, txnId, partitionTransactionIds,\n                remoteDCLastIds, context,\n                exportSequenceNumbers, drTupleStreamInfo, timestamp, numTables, snapshotRecord,\n                partitionedSnapshotTasks, replicatedSnapshotTasks);\n    }","id":95718,"modified_method":"@Override\n    public Callable<Boolean> createSetup(\n            String file_path, String file_nonce,\n            long txnId, Map<Integer, Long> partitionTransactionIds,\n            Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n            JSONObject jsData, SystemProcedureExecutionContext context,\n            final VoltTable result,\n            Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n            Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n            SiteTracker tracker,\n            HashinatorSnapshotData hashinatorData,\n            long timestamp)\n    {\n        assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.isEmpty());\n\n        /*\n         * List of partitions to include if this snapshot is\n         * going to be deduped. Attempts to break up the work\n         * by seeding and RNG selecting\n         * a random replica to do the work. Will not work in failure\n         * cases, but we don't use dedupe when we want durability.\n         */\n        List<Long> sitesToInclude = CSVSnapshotWritePlan.computeDedupedLocalSites(txnId, tracker);\n        // If there's no work to do on this host, just claim success and get out:\n        if (sitesToInclude.isEmpty() && !tracker.isFirstHost()) {\n            return null;\n        }\n\n        final SnapshotRequestConfig config = new SnapshotRequestConfig(jsData, context.getDatabase());\n        final AtomicInteger numTables = new AtomicInteger(config.tables.length);\n        final SnapshotRegistry.Snapshot snapshotRecord =\n            SnapshotRegistry.startSnapshot(\n                    txnId,\n                    context.getHostId(),\n                    file_path,\n                    file_nonce,\n                    SnapshotFormat.CSV,\n                    config.tables);\n\n        boolean noTargetsCreated = true;\n\n        final ArrayList<SnapshotTableTask> partitionedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        final ArrayList<SnapshotTableTask> replicatedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        for (final Table table : config.tables)\n        {\n            /*\n             * For a deduped csv snapshot, only produce the replicated tables on the \"leader\"\n             * host.\n             */\n            if (table.getIsreplicated() && !tracker.isFirstHost()) {\n                snapshotRecord.removeTable(table.getTypeName());\n                // We'll expect one less table in the global table count\n                // in order to be done, too (ENG-4802)\n                numTables.decrementAndGet();\n                continue;\n            }\n\n            List<SnapshotDataFilter> filters = new ArrayList<SnapshotDataFilter>();\n            filters.add(new CSVSnapshotFilter(CatalogUtil.getVoltTable(table), ',', null));\n\n            final SnapshotTableTask task =\n                    new SnapshotTableTask(\n                            table,\n                            filters.toArray(new SnapshotDataFilter[filters.size()]),\n                            null,\n                            false);\n\n            if (table.getIsreplicated()) {\n                replicatedSnapshotTasks.add(task);\n            } else {\n                partitionedSnapshotTasks.add(task);\n            }\n\n            noTargetsCreated = false;\n            result.addRow(context.getHostId(),\n                    CoreUtils.getHostnameOrAddress(),\n                    table.getTypeName(),\n                    \"SUCCESS\",\n                    \"\");\n        }\n\n        if (noTargetsCreated) {\n            SnapshotRegistry.discardSnapshot(snapshotRecord);\n        }\n\n        // CSV snapshots do the partitioned work only on the specified sites for de-duping,\n        // but since we've pre-filtered the replicated task list to only contain entries on\n        // one node, we can go ahead and distribute them across all of the sites on that node.\n        placePartitionedTasks(partitionedSnapshotTasks, sitesToInclude);\n        placeReplicatedTasks(replicatedSnapshotTasks, tracker.getSitesForHost(context.getHostId()));\n\n        // All IO work will be deferred and be run on the dedicated snapshot IO thread\n        return createDeferredSetup(file_path, file_nonce, config.tables, txnId, partitionTransactionIds,\n                remoteDCLastIds, context,\n                exportSequenceNumbers, drTupleStreamInfo, timestamp, numTables, snapshotRecord,\n                partitionedSnapshotTasks, replicatedSnapshotTasks);\n    }","commit_id":"074afdca8d2e4668e2c275f3e324ea04d7ca4e18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static void createFileBasedCompletionTasks(\n            String file_path, String file_nonce,\n            long txnId, Map<Integer, Long> partitionTransactionIds,\n            Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n            SystemProcedureExecutionContext context,\n            Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n            Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n            HashinatorSnapshotData hashinatorData,\n            long timestamp, int newPartitionCount) throws IOException\n    {\n        final List<Table> tables = SnapshotUtil.getTablesToSave(context.getDatabase());\n        InstanceId instId = VoltDB.instance().getHostMessenger().getInstanceId();\n        long clusterCreateTime = VoltDB.instance().getClusterCreateTime();\n        Runnable completionTask = SnapshotUtil.writeSnapshotDigest(\n                txnId,\n                context.getCatalogCRC(),\n                file_path,\n                file_nonce,\n                tables,\n                context.getHostId(),\n                exportSequenceNumbers,\n                drTupleStreamInfo,\n                partitionTransactionIds,\n                remoteDCLastIds,\n                instId,\n                timestamp,\n                clusterCreateTime,\n                newPartitionCount);\n        if (completionTask != null) {\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n        }\n        if (hashinatorData != null) {\n            completionTask = SnapshotUtil.writeHashinatorConfig(\n                    instId, file_path, file_nonce, context.getHostId(), hashinatorData);\n            if (completionTask != null) {\n                SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n            }\n        }\n        completionTask = SnapshotUtil.writeSnapshotCatalog(file_path, file_nonce);\n        if (completionTask != null) {\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n        }\n        completionTask = SnapshotUtil.writeSnapshotCompletion(file_path, file_nonce, context.getHostId(), SNAP_LOG);\n        if (completionTask != null) {\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n        }\n    }","id":95719,"modified_method":"static void createFileBasedCompletionTasks(\n            String file_path, String file_nonce,\n            long txnId, Map<Integer, Long> partitionTransactionIds,\n            Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n            SystemProcedureExecutionContext context,\n            Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n            Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n            HashinatorSnapshotData hashinatorData,\n            long timestamp, int newPartitionCount,\n            Table[] tables) throws IOException\n    {\n        InstanceId instId = VoltDB.instance().getHostMessenger().getInstanceId();\n        long clusterCreateTime = VoltDB.instance().getClusterCreateTime();\n        Runnable completionTask = SnapshotUtil.writeSnapshotDigest(\n                txnId,\n                context.getCatalogCRC(),\n                file_path,\n                file_nonce,\n                Arrays.asList(tables),\n                context.getHostId(),\n                exportSequenceNumbers,\n                drTupleStreamInfo,\n                partitionTransactionIds,\n                remoteDCLastIds,\n                instId,\n                timestamp,\n                clusterCreateTime,\n                newPartitionCount);\n        if (completionTask != null) {\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n        }\n        if (hashinatorData != null) {\n            completionTask = SnapshotUtil.writeHashinatorConfig(\n                    instId, file_path, file_nonce, context.getHostId(), hashinatorData);\n            if (completionTask != null) {\n                SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n            }\n        }\n        completionTask = SnapshotUtil.writeSnapshotCatalog(file_path, file_nonce);\n        if (completionTask != null) {\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n        }\n        completionTask = SnapshotUtil.writeSnapshotCompletion(file_path, file_nonce, context.getHostId(), SNAP_LOG);\n        if (completionTask != null) {\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(completionTask);\n        }\n    }","commit_id":"074afdca8d2e4668e2c275f3e324ea04d7ca4e18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"Callable<Boolean> createSetupInternal(String file_path,\n                                                    String file_nonce,\n                                                    long txnId,\n                                                    Map<Integer, Long> partitionTransactionIds,\n                                                    Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n                                                    JSONObject jsData,\n                                                    SystemProcedureExecutionContext context,\n                                                    final VoltTable result,\n                                                    Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n                                                    Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n                                                    SiteTracker tracker,\n                                                    HashinatorSnapshotData hashinatorData,\n                                                    long timestamp,\n                                                    int newPartitionCount)\n    {\n        assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.isEmpty());\n\n        if (TheHashinator.getConfiguredHashinatorType() == HashinatorType.ELASTIC && hashinatorData == null) {\n            throw new RuntimeException(\"No hashinator data provided for elastic hashinator type.\");\n        }\n\n        final SnapshotRequestConfig config = new SnapshotRequestConfig(jsData, context.getDatabase());\n        final Table[] tableArray;\n        if (config.tables.length == 0) {\n            tableArray = SnapshotUtil.getTablesToSave(context.getDatabase()).toArray(new Table[0]);\n        }\n        else {\n            tableArray = config.tables;\n        }\n        m_snapshotRecord =\n            SnapshotRegistry.startSnapshot(\n                    txnId,\n                    context.getHostId(),\n                    file_path,\n                    file_nonce,\n                    SnapshotFormat.NATIVE,\n                    tableArray);\n\n        final ArrayList<SnapshotTableTask> partitionedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        final ArrayList<SnapshotTableTask> replicatedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        for (final Table table : tableArray) {\n            final SnapshotTableTask task =\n                    new SnapshotTableTask(\n                            table,\n                            new SnapshotDataFilter[0],\n                            null,\n                            false);\n\n            SNAP_LOG.debug(\"ADDING TASK: \" + task);\n\n            if (table.getIsreplicated()) {\n                replicatedSnapshotTasks.add(task);\n            } else {\n                partitionedSnapshotTasks.add(task);\n            }\n\n            result.addRow(context.getHostId(),\n                    CoreUtils.getHostnameOrAddress(),\n                    table.getTypeName(),\n                    \"SUCCESS\",\n                    \"\");\n        }\n\n        if (tableArray.length > 0 && replicatedSnapshotTasks.isEmpty() && partitionedSnapshotTasks.isEmpty()) {\n            SnapshotRegistry.discardSnapshot(m_snapshotRecord);\n        }\n\n        // Native snapshots place the partitioned tasks on every site and round-robin the\n        // replicated tasks across all the sites on every host\n        placePartitionedTasks(partitionedSnapshotTasks, tracker.getSitesForHost(context.getHostId()));\n        placeReplicatedTasks(replicatedSnapshotTasks, tracker.getSitesForHost(context.getHostId()));\n\n        boolean isTruncationSnapshot = true;\n        if (jsData != null) {\n            isTruncationSnapshot = jsData.has(\"truncReqId\");\n        }\n\n        // All IO work will be deferred and be run on the dedicated snapshot IO thread\n        return createDeferredSetup(file_path, file_nonce, txnId, partitionTransactionIds,\n                remoteDCLastIds, context,\n                exportSequenceNumbers, drTupleStreamInfo, tracker, hashinatorData, timestamp,\n                newPartitionCount, tableArray, m_snapshotRecord, partitionedSnapshotTasks,\n                replicatedSnapshotTasks, isTruncationSnapshot);\n    }","id":95720,"modified_method":"Callable<Boolean> createSetupInternal(String file_path,\n                                                    String file_nonce,\n                                                    long txnId,\n                                                    Map<Integer, Long> partitionTransactionIds,\n                                                    Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n                                                    JSONObject jsData,\n                                                    SystemProcedureExecutionContext context,\n                                                    final VoltTable result,\n                                                    Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n                                                    Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n                                                    SiteTracker tracker,\n                                                    HashinatorSnapshotData hashinatorData,\n                                                    long timestamp,\n                                                    int newPartitionCount)\n    {\n        assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.isEmpty());\n\n        if (TheHashinator.getConfiguredHashinatorType() == HashinatorType.ELASTIC && hashinatorData == null) {\n            throw new RuntimeException(\"No hashinator data provided for elastic hashinator type.\");\n        }\n\n        final SnapshotRequestConfig config = new SnapshotRequestConfig(jsData, context.getDatabase());\n        m_snapshotRecord =\n            SnapshotRegistry.startSnapshot(\n                    txnId,\n                    context.getHostId(),\n                    file_path,\n                    file_nonce,\n                    SnapshotFormat.NATIVE,\n                    config.tables);\n\n        final ArrayList<SnapshotTableTask> partitionedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        final ArrayList<SnapshotTableTask> replicatedSnapshotTasks =\n            new ArrayList<SnapshotTableTask>();\n        for (final Table table : config.tables) {\n            final SnapshotTableTask task =\n                    new SnapshotTableTask(\n                            table,\n                            new SnapshotDataFilter[0],\n                            null,\n                            false);\n\n            SNAP_LOG.debug(\"ADDING TASK: \" + task);\n\n            if (table.getIsreplicated()) {\n                replicatedSnapshotTasks.add(task);\n            } else {\n                partitionedSnapshotTasks.add(task);\n            }\n\n            result.addRow(context.getHostId(),\n                    CoreUtils.getHostnameOrAddress(),\n                    table.getTypeName(),\n                    \"SUCCESS\",\n                    \"\");\n        }\n\n        if (config.tables.length > 0 && replicatedSnapshotTasks.isEmpty() && partitionedSnapshotTasks.isEmpty()) {\n            SnapshotRegistry.discardSnapshot(m_snapshotRecord);\n        }\n\n        // Native snapshots place the partitioned tasks on every site and round-robin the\n        // replicated tasks across all the sites on every host\n        placePartitionedTasks(partitionedSnapshotTasks, tracker.getSitesForHost(context.getHostId()));\n        placeReplicatedTasks(replicatedSnapshotTasks, tracker.getSitesForHost(context.getHostId()));\n\n        boolean isTruncationSnapshot = true;\n        if (jsData != null) {\n            isTruncationSnapshot = jsData.has(\"truncReqId\");\n        }\n\n        // All IO work will be deferred and be run on the dedicated snapshot IO thread\n        return createDeferredSetup(file_path, file_nonce, txnId, partitionTransactionIds,\n                remoteDCLastIds, context,\n                exportSequenceNumbers, drTupleStreamInfo, tracker, hashinatorData, timestamp,\n                newPartitionCount, config.tables, m_snapshotRecord, partitionedSnapshotTasks,\n                replicatedSnapshotTasks, isTruncationSnapshot);\n    }","commit_id":"074afdca8d2e4668e2c275f3e324ea04d7ca4e18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private Callable<Boolean> createDeferredSetup(final String file_path,\n                                                  final String file_nonce,\n                                                  final long txnId,\n                                                  final Map<Integer, Long> partitionTransactionIds,\n                                                  final Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n                                                  final SystemProcedureExecutionContext context,\n                                                  final Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n                                                  final Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n                                                  final SiteTracker tracker,\n                                                  final HashinatorSnapshotData hashinatorData,\n                                                  final long timestamp,\n                                                  final int newPartitionCount,\n                                                  final Table[] tables,\n                                                  final SnapshotRegistry.Snapshot snapshotRecord,\n                                                  final ArrayList<SnapshotTableTask> partitionedSnapshotTasks,\n                                                  final ArrayList<SnapshotTableTask> replicatedSnapshotTasks,\n                                                  final boolean isTruncationSnapshot)\n    {\n        return new Callable<Boolean>() {\n            private final HashMap<Integer, SnapshotDataTarget> m_createdTargets = Maps.newHashMap();\n\n            @Override\n            public Boolean call() throws Exception\n            {\n                final AtomicInteger numTables = new AtomicInteger(tables.length);\n\n                NativeSnapshotWritePlan.createFileBasedCompletionTasks(file_path, file_nonce,\n                        txnId, partitionTransactionIds, remoteDCLastIds, context, exportSequenceNumbers,\n                        drTupleStreamInfo,\n                        hashinatorData,\n                        timestamp,\n                        newPartitionCount);\n\n                for (SnapshotTableTask task : replicatedSnapshotTasks) {\n                    SnapshotDataTarget target = getSnapshotDataTarget(numTables, task);\n                    task.setTarget(target);\n                }\n\n                for (SnapshotTableTask task : partitionedSnapshotTasks) {\n                    SnapshotDataTarget target = getSnapshotDataTarget(numTables, task);\n                    task.setTarget(target);\n                }\n\n                if (isTruncationSnapshot) {\n                    // Only sync the DR Log on Native Snapshots\n                    SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(new Runnable() {\n                        @Override\n                        public void run()\n                        {\n                            context.forceAllDRNodeBuffersToDisk(false);\n                        }\n                    });\n                }\n                // Sync export buffer for all types of snapshot\n                SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(new Runnable() {\n                    @Override\n                    public void run()\n                    {\n                        ExportManager.sync(false);\n                    }\n                });\n\n                return true;\n            }\n\n            private SnapshotDataTarget getSnapshotDataTarget(AtomicInteger numTables, SnapshotTableTask task)\n                    throws IOException\n            {\n                SnapshotDataTarget target = m_createdTargets.get(task.m_table.getRelativeIndex());\n                if (target == null) {\n                    target = createDataTargetForTable(file_path, file_nonce, task.m_table, txnId,\n                            context.getHostId(), context.getCluster().getTypeName(),\n                            context.getDatabase().getTypeName(), context.getNumberOfPartitions(),\n                            context.getDatabase().getIsactiveactivedred(),\n                            tracker, timestamp, numTables, snapshotRecord);\n                    m_createdTargets.put(task.m_table.getRelativeIndex(), target);\n                }\n                return target;\n            }\n        };\n    }","id":95721,"modified_method":"private Callable<Boolean> createDeferredSetup(final String file_path,\n                                                  final String file_nonce,\n                                                  final long txnId,\n                                                  final Map<Integer, Long> partitionTransactionIds,\n                                                  final Map<Integer, Map<Integer, Pair<Long, Long>>> remoteDCLastIds,\n                                                  final SystemProcedureExecutionContext context,\n                                                  final Map<String, Map<Integer, Pair<Long, Long>>> exportSequenceNumbers,\n                                                  final Map<Integer, Pair<Long, Long>> drTupleStreamInfo,\n                                                  final SiteTracker tracker,\n                                                  final HashinatorSnapshotData hashinatorData,\n                                                  final long timestamp,\n                                                  final int newPartitionCount,\n                                                  final Table[] tables,\n                                                  final SnapshotRegistry.Snapshot snapshotRecord,\n                                                  final ArrayList<SnapshotTableTask> partitionedSnapshotTasks,\n                                                  final ArrayList<SnapshotTableTask> replicatedSnapshotTasks,\n                                                  final boolean isTruncationSnapshot)\n    {\n        return new Callable<Boolean>() {\n            private final HashMap<Integer, SnapshotDataTarget> m_createdTargets = Maps.newHashMap();\n\n            @Override\n            public Boolean call() throws Exception\n            {\n                final AtomicInteger numTables = new AtomicInteger(tables.length);\n\n                NativeSnapshotWritePlan.createFileBasedCompletionTasks(file_path, file_nonce,\n                        txnId, partitionTransactionIds, remoteDCLastIds, context, exportSequenceNumbers,\n                        drTupleStreamInfo,\n                        hashinatorData,\n                        timestamp,\n                        newPartitionCount,\n                        tables);\n\n                for (SnapshotTableTask task : replicatedSnapshotTasks) {\n                    SnapshotDataTarget target = getSnapshotDataTarget(numTables, task);\n                    task.setTarget(target);\n                }\n\n                for (SnapshotTableTask task : partitionedSnapshotTasks) {\n                    SnapshotDataTarget target = getSnapshotDataTarget(numTables, task);\n                    task.setTarget(target);\n                }\n\n                if (isTruncationSnapshot) {\n                    // Only sync the DR Log on Native Snapshots\n                    SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(new Runnable() {\n                        @Override\n                        public void run()\n                        {\n                            context.forceAllDRNodeBuffersToDisk(false);\n                        }\n                    });\n                }\n                // Sync export buffer for all types of snapshot\n                SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(new Runnable() {\n                    @Override\n                    public void run()\n                    {\n                        ExportManager.sync(false);\n                    }\n                });\n\n                return true;\n            }\n\n            private SnapshotDataTarget getSnapshotDataTarget(AtomicInteger numTables, SnapshotTableTask task)\n                    throws IOException\n            {\n                SnapshotDataTarget target = m_createdTargets.get(task.m_table.getRelativeIndex());\n                if (target == null) {\n                    target = createDataTargetForTable(file_path, file_nonce, task.m_table, txnId,\n                            context.getHostId(), context.getCluster().getTypeName(),\n                            context.getDatabase().getTypeName(), context.getNumberOfPartitions(),\n                            context.getDatabase().getIsactiveactivedred(),\n                            tracker, timestamp, numTables, snapshotRecord);\n                    m_createdTargets.put(task.m_table.getRelativeIndex(), target);\n                }\n                return target;\n            }\n        };\n    }","commit_id":"074afdca8d2e4668e2c275f3e324ea04d7ca4e18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void toJSONString(JSONStringer stringer) throws JSONException\n    {\n        if (tables != null) {\n            stringer.key(\"tableNames\");\n            stringer.array();\n            for (Table table : tables) {\n                stringer.value(table.getTypeName());\n            }\n            stringer.endArray();\n        }\n    }","id":95722,"modified_method":"public void toJSONString(JSONStringer stringer) throws JSONException\n    {\n        if (tables != null) {\n            stringer.key(\"tables\");\n            stringer.array();\n            for (Table table : tables) {\n                stringer.value(table.getTypeName());\n            }\n            stringer.endArray();\n        }\n    }","commit_id":"074afdca8d2e4668e2c275f3e324ea04d7ca4e18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private static Table[] getTablesToInclude(JSONObject jsData,\n                                              Database catalogDatabase)\n    {\n        final List<Table> tables = SnapshotUtil.getTablesToSave(catalogDatabase);\n        final Set<String> tableNamesToInclude = new HashSet<String>();\n\n        if (jsData != null) {\n            JSONArray tableNames = jsData.optJSONArray(\"tableNames\");\n            if (tableNames != null) {\n                for (int i = 0; i < tableNames.length(); i++) {\n                    try {\n                        tableNamesToInclude.add(tableNames.getString(i));\n                    } catch (JSONException e) {\n                        SNAP_LOG.warn(\"Unable to parse tables to include for stream snapshot\", e);\n                    }\n                }\n            }\n        }\n\n        ListIterator<Table> iter = tables.listIterator();\n        while (iter.hasNext()) {\n            Table table = iter.next();\n            if (!tableNamesToInclude.contains(table.getTypeName())) {\n                // If the table index is not in the list to include, remove it\n                iter.remove();\n            }\n        }\n\n        return tables.toArray(new Table[0]);\n    }","id":95723,"modified_method":"private static Table[] getTablesToInclude(JSONObject jsData,\n                                              Database catalogDatabase)\n    {\n        final List<Table> tables = SnapshotUtil.getTablesToSave(catalogDatabase);\n        final Set<String> tableNamesToInclude = new HashSet<String>();\n        final Set<String> tableNamesToExclude = new HashSet<>();\n\n        if (jsData != null) {\n            JSONArray tableNames = jsData.optJSONArray(\"tables\");\n            if (tableNames != null) {\n                for (int i = 0; i < tableNames.length(); i++) {\n                    try {\n                        final String s = tableNames.getString(i).trim().toUpperCase();\n                        if (!s.isEmpty()) {\n                            tableNamesToInclude.add(s);\n                        }\n                    } catch (JSONException e) {\n                        SNAP_LOG.warn(\"Unable to parse tables to include for snapshot\", e);\n                    }\n                }\n            }\n\n            JSONArray excludeTableNames = jsData.optJSONArray(\"skiptables\");\n            if (excludeTableNames != null) {\n                for (int i = 0; i < excludeTableNames.length(); i++) {\n                    try {\n                        final String s = excludeTableNames.getString(i).trim().toUpperCase();\n                        if (!s.isEmpty()) {\n                            tableNamesToExclude.add(s);\n                        }\n                    } catch (JSONException e) {\n                        SNAP_LOG.warn(\"Unable to parse tables to exclude for snapshot\", e);\n                    }\n                }\n            }\n        }\n\n        if (!tableNamesToInclude.isEmpty() || !tableNamesToExclude.isEmpty()) {\n            ListIterator<Table> iter = tables.listIterator();\n            while (iter.hasNext()) {\n                Table table = iter.next();\n                if ((!tableNamesToInclude.isEmpty() && !tableNamesToInclude.contains(table.getTypeName())) ||\n                    tableNamesToExclude.contains(table.getTypeName())) {\n                    // If the table index is not in the list to include or\n                    // is in the list to exclude, remove it\n                    iter.remove();\n                }\n            }\n        }\n\n        return tables.toArray(new Table[0]);\n    }","commit_id":"074afdca8d2e4668e2c275f3e324ea04d7ca4e18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static String processFilter(String filter, Set<String> quoted) {\n    String withoutQuoted = \"\";\n    int beg = 0;\n    final Matcher matcher = QUOTED.matcher(filter);\n    while (matcher.find()) {\n      final int start = matcher.start(1);\n      withoutQuoted += \" \" + filter.substring(beg, start);\n      beg = matcher.end(1);\n      quoted.add(filter.substring(start, beg));\n    }\n    return withoutQuoted + \" \" + filter.substring(beg);\n  }","id":95724,"modified_method":"public static String processFilter(String filter, Set<String> quoted) {\n    String withoutQuoted = \"\";\n    int beg = 0;\n    final Matcher matcher = QUOTED.matcher(filter);\n    while (matcher.find()) {\n      final int start = matcher.start(1);\n      withoutQuoted += \" \" + filter.substring(beg, start);\n      beg = matcher.end(1);\n      final String trimmed = filter.substring(start, beg).trim();\n      if (trimmed.length() > 0) {\n        quoted.add(trimmed);\n      }\n    }\n    return withoutQuoted + \" \" + filter.substring(beg);\n  }","commit_id":"bb748bbca0c67236685d4334dc8c0ead0d13be4f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * CSS Class for the select file button\n\t * \n\t * @return string value for 'selectFileButtonClass' binding\n\t */\n\tpublic String selectFileButtonClass() {\n\t\tif (_selectFileButtonClass == null) {\n\t\t\t_selectFileButtonClass = (String)valueForBinding(Keys.selectFileButtonClass);\n\t\t\tif (_selectFileButtonClass == null) {\n\t\t\t\t_selectFileButtonClass = \"Button ObjButton SelectFileObjButton\";\n\t\t\t}\n\t\t}\n\t\treturn _selectFileButtonClass;\n\t}","id":95725,"modified_method":"/**\n\t * CSS Class for the select file button\n\t * \n\t * @return string value for 'selectFileButtonClass' binding\n\t */\n\tpublic String selectFileButtonClass() {\n\t\tif (_selectFileButtonClass == null) {\n\t\t\t_selectFileButtonClass = stringValueForBinding(Keys.selectFileButtonClass, \"Button ObjButton SelectFileObjButton\");\n\t\t}\n\t\treturn _selectFileButtonClass;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Action called by the cancel upload button\n\t * \n\t * @return results of action\n\t */\n\tpublic WOActionResults cancelUpload() {\n\t\tif (this.uploadProgress() != null) {\n\t\t\tthis.uploadProgress().cancel();\n\t\t}\n\t\tstate = UploadState.CANCELED;\n\t\treturn null;\n\t}","id":95726,"modified_method":"/**\n\t * Action called by the cancel upload button\n\t */\n\tpublic void cancelUpload() {\n\t\tif (this.uploadProgress() != null) {\n\t\t\tthis.uploadProgress().cancel();\n\t\t}\n\t\tstate = UploadState.CANCELED;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Label for the select file button\n\t * \n\t * @return string value for 'selectFileLabel' binding\n\t */\n\tpublic String selectFileLabel() {\n\t\tif (_selectFileLabel == null) {\n\t\t\t_selectFileLabel = (String) valueForBinding(Keys.selectFileLabel);\n\t\t\tif (_selectFileLabel == null) {\n\t\t\t\t_selectFileLabel = \"Select File...\";\n\t\t\t}\n\t\t}\n\t\treturn _selectFileLabel;\n\t}","id":95727,"modified_method":"/**\n\t * Label for the select file button\n\t * \n\t * @return string value for 'selectFileLabel' binding\n\t */\n\tpublic String selectFileLabel() {\n\t\tif (_selectFileLabel == null) {\n\t\t\t_selectFileLabel = localizedStringForBinding(Keys.selectFileLabel, \"Select File...\");\n\t\t}\n\t\treturn _selectFileLabel;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * JS Function called when the AjaxUpload registers a change\n\t * \n\t * @return string JS Function called when the AjaxUpload registers a change\n\t */\n\tpublic String onChangeFunction() {\n\t\tString result = \"function(file, extension) { \" + innerUpdateContainerId() + \"Update(); }\";\n\t\treturn result;\n\t}","id":95728,"modified_method":"/**\n\t * JS Function called when the AjaxUpload registers a change\n\t * \n\t * @return string JS Function called when the AjaxUpload registers a change\n\t */\n\tpublic String onChangeFunction() {\n\t\tString result = \"function(file, extension) { AUP.prepare('\"+ id() +\"', file, extension); }\";\n\t\treturn result;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * JS Function string to cancel the iframe upload (by changing it's src url).\n\t * \n\t * @return string to cancel the iframe upload (by changing it's src url).\n\t */\n\tpublic String cancelFunction() {\n\t\tString script = \"AFU.cancelIFrame('\" + iframeId() + \"', '\" + cancelUrl() + \"')\";\n\t\treturn script;\n\t}","id":95729,"modified_method":"/**\n\t * JS function bound to the cancel button\n\t * \n\t * @return JS function bound to the cancel button\n\t */\n\tpublic String cancelUploadFunction() {\n\t\treturn String.format(\"AUP.cancel('%s');\", id());\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Action called by the clear button, resets the uploader for a new file selection\n\t * \n\t * @return results of action\n\t */\n\tpublic WOActionResults clearFileResults() {\n\t\tclearUploadProgress();\n\t\t_fileName = null;\n\t\t_clearUpload = true;\n\t\t_fileChosen = false;\n\t\treturn null;\n\t}","id":95730,"modified_method":"/**\n\t * Action called by the clear button, resets the uploader for a new file selection\n\t * \n\t */\n\tpublic void clearFileResults() {\n\t\tclearUploadProgress();\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Label for the cancel button\n\t * \n\t * @return string value for 'cancelLabel' binding\n\t */\n\tpublic String cancelLabel() {\n\t\tif (_cancelLabel == null) {\n\t\t\t_cancelLabel = (String) valueForBinding(Keys.cancelLabel);\n\t\t\tif (_cancelLabel == null) {\n\t\t\t\t_cancelLabel = \"Cancel\";\n\t\t\t}\n\t\t}\n\t\treturn _cancelLabel;\n\t}","id":95731,"modified_method":"/**\n\t * Label for the cancel button\n\t * \n\t * @return string value for 'cancelLabel' binding\n\t */\n\tpublic String cancelLabel() {\n\t\tif (_cancelLabel == null) {\n\t\t\t_cancelLabel = localizedStringForBinding(Keys.cancelLabel, \"Cancel\");\n\t\t}\n\t\treturn _cancelLabel;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults uploadSucceeded() {\n\t\tWOActionResults result = super.uploadSucceeded();\n\t\tif (ERXComponentUtilities.booleanValueForBinding(this, Keys.clearUploadProgressOnSuccess, false)) {\n\t\t\tclearUploadProgress();\n\t\t}\n\t\treturn result;\n\t}","id":95732,"modified_method":"/**\n\t * Hook for add-in action called when an upload succeeds.\n\t */\n\tpublic WOActionResults uploadSucceeded() {\n\t\tWOActionResults result = super.uploadSucceeded();\n\t\tclearUploadProgress();\n\t\treturn result;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Builds the array of AjaxUpload options\n\t * \n\t * @return array of AjaxUpload options\n\t */\n    protected NSArray<String> _ajaxUploadOptions() {\n    \tNSMutableArray<String> _options = new NSMutableArray<String>(\"action:'\" + uploadUrl() + \"'\");\n    \t\n    \t// add options\n    \t_options.addObject(\"data:{\" + ajaxUploadData() + \"}\");\n    \t_options.addObject(\"name:'\" + uploadName() + \"'\");\n    \t_options.add(\"iframeId:'\"+ iframeId() +\"'\");\n    \tif ( !autoSubmit().booleanValue() ) {\n    \t\t_options.add(\"onChange:\" + onChangeFunction());\n    \t\t_options.add(\"autoSubmit:false\");\n    \t}\n    \t_options.add(\"onSubmit:\" + onSubmitFunction());\n    \t_options.add(\"onComplete:\" + onCompleteFunction());\n    \treturn _options.immutableClone();\n    }","id":95733,"modified_method":"/**\n\t * Builds the array of AjaxUpload options\n\t * \n\t * @return array of AjaxUpload options\n\t */\n    protected NSArray<String> _ajaxUploadOptions() {\n    \tNSMutableArray<String> _options = new NSMutableArray<String>(\"action:'\" + uploadUrl() + \"'\");\n    \t\n    \t// add options\n    \t_options.addObject(\"data:{\" + ajaxUploadData() + \"}\");\n    \t_options.addObject(\"name:'\" + uploadName() + \"'\");\n    \t_options.add(\"iframeId:'\"+ iframeId() +\"'\");\n    \tif ( !autoSubmit().booleanValue() ) {\n    \t\t_options.add(\"onChange:\" + onChangeFunction());\n    \t\t_options.add(\"autoSubmit:false\");\n    \t}\n    \t_options.add(\"onSubmit:\" + onSubmitFunction());\n    \treturn _options.immutableClone();\n    }","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Label for the clear button\n\t * \n\t * @return string value for 'clearLabel' binding\n\t */\n\tpublic String clearLabel() {\n\t\tif (_clearLabel == null) {\n\t\t\t_clearLabel = (String) valueForBinding(Keys.clearLabel);\n\t\t\tif (_clearLabel == null) {\n\t\t\t\t_clearLabel = \"Clear\";\n\t\t\t}\n\t\t}\n\t\treturn _clearLabel;\n\t}","id":95734,"modified_method":"/**\n\t * Label for the clear button\n\t * \n\t * @return string value for 'clearLabel' binding\n\t */\n\tpublic String clearLabel() {\n\t\tif (_clearLabel == null) {\n\t\t\t_clearLabel = localizedStringForBinding(Keys.clearLabel, \"Clear\");\n\t\t}\n\t\treturn _clearLabel;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * CSS Class for the cancel upload button\n\t * \n\t * @return string value for 'cancelButtonClass' binding\n\t */\n\tpublic String cancelButtonClass() {\n\t\tif (_cancelButtonClass == null) {\n\t\t\t_cancelButtonClass = (String)valueForBinding(Keys.cancelButtonClass);\n\t\t\tif (_cancelButtonClass == null) {\n\t\t\t\t_cancelButtonClass = \"Button ObjButton CancelUploadObjButton\";\n\t\t\t}\n\t\t}\n\t\treturn _cancelButtonClass;\n\t}","id":95735,"modified_method":"/**\n\t * CSS Class for the cancel upload button\n\t * \n\t * @return string value for 'cancelButtonClass' binding\n\t */\n\tpublic String cancelButtonClass() {\n\t\tif (_cancelButtonClass == null) {\n\t\t\t_cancelButtonClass = stringValueForBinding(Keys.cancelButtonClass, \"Button ObjButton CancelUploadObjButton\");\n\t\t}\n\t\treturn _cancelButtonClass;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Label for the upload button\n\t * \n\t * @return string value for 'uploadLabel' binding\n\t */\n\tpublic String uploadLabel() {\n\t\tif (_uploadLabel == null) {\n\t\t\t_uploadLabel = (String) valueForBinding(Keys.uploadLabel);\n\t\t\tif (_uploadLabel == null) {\n\t\t\t\t_uploadLabel = \"Upload\";\n\t\t\t}\n\t\t}\n\t\treturn _uploadLabel;\n\t}","id":95736,"modified_method":"/**\n\t * Label for the upload button\n\t * \n\t * @return string value for 'uploadLabel' binding\n\t */\n\tpublic String uploadLabel() {\n\t\tif (_uploadLabel == null) {\n\t\t\t_uploadLabel = localizedStringForBinding(Keys.uploadLabel, \"Upload\");\n\t\t}\n\t\treturn _uploadLabel;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * CSS Class for the upload file button\n\t * \n\t * @return string value for 'uploadButtonClass' binding\n\t */\n\tpublic String uploadButtonClass() {\n\t\tif (_uploadButtonClass == null) {\n\t\t\t_uploadButtonClass = (String)valueForBinding(Keys.uploadButtonClass);\n\t\t\tif (_uploadButtonClass == null) {\n\t\t\t\t_uploadButtonClass = \"Button ObjButton UploadFileObjButton\";\n\t\t\t}\n\t\t}\n\t\treturn _uploadButtonClass;\n\t}","id":95737,"modified_method":"/**\n\t * CSS Class for the upload file button\n\t * \n\t * @return string value for 'uploadButtonClass' binding\n\t */\n\tpublic String uploadButtonClass() {\n\t\tif (_uploadButtonClass == null) {\n\t\t\t_uploadButtonClass = stringValueForBinding(Keys.uploadButtonClass, \"Button ObjButton UploadFileObjButton\");\n\t\t}\n\t\treturn _uploadButtonClass;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Unique identifier for the fileName container\n\t * \n\t * @return identifier for the fileName container\n\t */\n\tpublic String fileNameId() {\n\t\treturn \"AFUFN\" + id();\n\t}","id":95738,"modified_method":"/**\n\t * Unique identifier for the fileName container\n\t * \n\t * @return identifier for the fileName container\n\t */\n\tpublic String fileNameId() {\n\t\treturn \"AFUFileNameWrapper\" + id();\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns the value for the binding 'refreshTime'\n\t * \n\t * The binding takes milliseconds between refreshes, this returns seconds\n\t * \n\t * @return value of the 'refreshTime' binding converted to seconds\n\t */\n\tpublic String refreshTime() {\n\t\tif (_refreshTime == null) {\n\t\t\tdouble tempValue = ERXValueUtilities.doubleValueWithDefault(valueForBinding(Keys.refreshTime), 2000);\n\t\t\t_refreshTime = String.valueOf(tempValue / 1000);\n\t\t}\n\t\treturn _refreshTime;\n\t}","id":95739,"modified_method":"/**\n\t * Returns the value for the binding 'refreshTime'\n\t * \n\t * The binding takes milliseconds between refreshes, this returns seconds\n\t * \n\t * @return value of the 'refreshTime' binding converted to seconds\n\t */\n\tpublic String refreshTime() {\n\t\tif (_refreshTime == null) {\n\t\t\tdouble tempValue = ERXValueUtilities.intValueWithDefault(valueForBinding(Keys.refreshTime), 1000);\n\t\t\t_refreshTime = String.valueOf(tempValue);\n\t\t}\n\t\treturn _refreshTime;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns a closeHTTPSession DA action URL passed to the iframe to cancel the client-side upload\n\t * \n\t * @return url sent to the iframe to cancel\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic String cancelUrl() {\n\t\tNSDictionary queryParams = new NSDictionary(Boolean.FALSE, Keys.wosid);\n\t\tString url = ERXWOContext._directActionURL(context(), \"ERXDirectAction/closeHTTPSession\", queryParams, ERXRequest.isRequestSecure(context().request()));\n\t\tif (log.isDebugEnabled()) log.debug(\"URL: \" + url);\n\t\treturn url;\n\t}","id":95740,"modified_method":"/**\n\t * Returns a closeHTTPSession DA action URL passed to the iframe to cancel the client-side upload\n\t * \n\t * @return url sent to the iframe to cancel\n\t */\n\tpublic String cancelUrl() {\n\t\tNSDictionary<String,Boolean> queryParams = new NSDictionary<String,Boolean>(Boolean.FALSE, Keys.wosid);\n\t\tString url = ERXWOContext._directActionURL(context(), \"ERXDirectAction/closeHTTPSession\", queryParams, ERXRequest.isRequestSecure(context().request()));\n\t\tif (log.isDebugEnabled()) log.debug(\"URL: \" + url);\n\t\treturn url;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the script to initialize a new AjaxUpload JS object\n     * \n     * @return script to initialize a new AjaxUpload JS object\n     */\n\tpublic String ajaxUploadScript() {\n\t\tString result = \"AFU.create('\" + id() + \"', '\" + uploadButtonId() + \"', {\" + ajaxUploadOptions() + \"});\";\n\t\tif (log.isDebugEnabled()) log.debug(\"AFU Create Script: \" + result);\n\t\treturn result;\n\t}","id":95741,"modified_method":"/**\n     * Generates the script to initialize a new AjaxUpload JS object\n     * \n     * @return script to initialize a new AjaxUpload JS object\n     */\n\tpublic String ajaxUploadScript() {\n\t\tString result = \"AUP.add('\" + id() + \"', \" + ajaxProxyName() +\", {\" + ajaxUploadLabels() + \"}, {\" + options() + \"}, {\" + ajaxUploadOptions() + \"});\";\n\t\tif (log.isDebugEnabled()) log.debug(\"AFU Create Script: \" + result);\n\t\treturn result;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Helper to reset the uploader and unregister the AjaxProgress object\n\t */\n\tpublic void clearUploadProgress() {\n\t\tif (_progress != null) {\n\t\t\tAjaxUploadProgress.unregisterProgress(session(), _progress);\n\t\t}\n\t\t_progress = null;\n\t\t_uploadStarted = false;\n\t}","id":95742,"modified_method":"/**\n\t * Helper to reset the uploader and unregister the AjaxProgress object\n\t */\n\tpublic void clearUploadProgress() {\n\t\tif (_progress != null) {\n\t\t\tAjaxUploadProgress.unregisterProgress(session(), _progress);\n\t\t}\n\t\t_progress = null;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * JS Function called when the AjaxUploader submits\n\t * \n\t * @return string JS Function called when the AjaxUploader submits\n\t */\n\tpublic String onSubmitFunction() {\n\t\tString result = \"function(file, extension){ \" + startFunction() + \" }\";\n\t\treturn result;\n\t}","id":95743,"modified_method":"/**\n\t * JS Function called when the AjaxUploader submits\n\t * \n\t * @return string JS Function called when the AjaxUploader submits\n\t */\n\tpublic String onSubmitFunction() {\n\t\tString result = \"function(){ AUP.start('\" + id() + \"'); }\";\n\t\treturn result;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * JS Function called by the manual submit button.\n\t * \n\t * @return string JS Function called by the manual submit button.\n\t */\n\tpublic String submitUploadFunction() {\n\t\tString result = \"AFU.submit( '\" + id() + \"', '\" + innerUpdateContainerId() + \"')\";\n\t\treturn result;\n\t}","id":95744,"modified_method":"/**\n\t * JS function bound to the manual upload button\n\t * \n\t * @return JS function bound to the manul upload button\n\t */\n\tpublic String manualSubmitUploadFunction() {\n\t\treturn String.format(\"AUP.submit('%s');\", id());\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Controls whether the upload button is displayed (this only occurs when the autoSubmit binding is false)\n\t * \n\t * @return boolean controls whether the upload button is displayed\n\t */\n\tpublic boolean showUploadButton() {\n\t\treturn _progress == null && fileChosen() && !autoSubmit().booleanValue() && !showProgressBar();\n\t}","id":95745,"modified_method":"/**\n\t * Element id for the clear button\n\t * \n\t * @return id for the clear button\n\t */\n\tpublic String clearUploadButtonId() {\n\t\treturn String.format(\"AFUClearButton%s\", id());\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * CSS Class for the clear upload button\n\t * \n\t * @return string value for 'clearButtonClass' binding\n\t */\n\tpublic String clearButtonClass() {\n\t\tif (_clearButtonClass == null) {\n\t\t\t_clearButtonClass = (String)valueForBinding(Keys.clearButtonClass);\n\t\t\tif (_clearButtonClass == null) {\n\t\t\t\t_clearButtonClass = \"Button ObjButton ClearUploadObjButton\";\n\t\t\t}\n\t\t}\n\t\treturn _clearButtonClass;\n\t}","id":95746,"modified_method":"/**\n\t * CSS Class for the clear upload button\n\t * \n\t * @return string value for 'clearButtonClass' binding\n\t */\n\tpublic String clearButtonClass() {\n\t\tif (_clearButtonClass == null) {\n\t\t\t_clearButtonClass = stringValueForBinding(Keys.clearButtonClass, \"Button ObjButton ClearUploadObjButton\");\n\t\t}\n\t\treturn _clearButtonClass;\n\t}","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns a comma separated string of AjaxUpload options.\n     * \n     * @return comma separated string of AjaxUpload options.\n     */\n    public String ajaxUploadOptions() {\n    \treturn _ajaxUploadOptions().componentsJoinedByString(\", \");\n    }","id":95747,"modified_method":"/**\n     * Returns a comma separated string of AjaxUpload options.\n     * \n     * @return comma separated string of AjaxUpload options.\n     */\n    public String ajaxUploadOptions() {\n    \treturn _ajaxUploadOptions().componentsJoinedByString(\",\");\n    }","commit_id":"0d106c3c32b816eba62393ca5e7c6c58435bc918","url":"https://github.com/wocommunity/wonder"},{"original_method":"private boolean canInlineParmOrThisVariable(PsiExpression initializer,\n                                              boolean shouldBeFinal,\n                                              boolean strictlyFinal,\n                                              int accessCount,\n                                              boolean isAccessedForWriting) {\n    if (strictlyFinal) {\n      class CanAllLocalsBeDeclaredFinal extends PsiRecursiveElementVisitor {\n        boolean success = true;\n\n        public void visitReferenceExpression(PsiReferenceExpression expression) {\n          final PsiElement psiElement = expression.resolve();\n          if (psiElement instanceof PsiLocalVariable || psiElement instanceof PsiParameter) {\n            if (!RefactoringUtil.canBeDeclaredFinal((PsiVariable)psiElement)) {\n              success = false;\n            }\n          }\n        }\n\n        public void visitElement(PsiElement element) {\n          if (success) {\n            super.visitElement(element);\n          }\n        }\n      }\n\n      final CanAllLocalsBeDeclaredFinal canAllLocalsBeDeclaredFinal = new CanAllLocalsBeDeclaredFinal();\n      initializer.accept(canAllLocalsBeDeclaredFinal);\n      if (!canAllLocalsBeDeclaredFinal.success) return false;\n    }\n    if (initializer instanceof PsiReferenceExpression) {\n      PsiVariable refVar = (PsiVariable)((PsiReferenceExpression)initializer).resolve();\n      if (refVar == null) {\n        return !isAccessedForWriting;\n      }\n      if (refVar instanceof PsiField) {\n        if (isAccessedForWriting) return false;\n        /*\n        PsiField field = (PsiField)refVar;\n        if (isFieldNonModifiable(field)){\n          return true;\n        }\n        //TODO: other cases\n        return false;\n        */\n        return true; //TODO: \"suspicous\" places to review by user!\n      }\n      else {\n        if (isAccessedForWriting) {\n          if (refVar.hasModifierProperty(PsiModifier.FINAL) || shouldBeFinal) return false;\n          PsiReference[] refs = myManager.getSearchHelper().findReferences(refVar,\n                                                                           GlobalSearchScope.projectScope(\n                                                                           myProject),\n                                                                           false);\n          return refs.length == 1; //TODO: control flow\n        }\n        else {\n          if (shouldBeFinal) {\n            if (refVar.hasModifierProperty(PsiModifier.FINAL)) return true;\n            return RefactoringUtil.canBeDeclaredFinal(refVar);\n          }\n          return true;\n        }\n      }\n    }\n    else if (isAccessedForWriting) {\n      return false;\n    }\n    else if (initializer instanceof PsiCallExpression) {\n      if (accessCount > 1) return false;\n      final PsiExpressionList argumentList = ((PsiCallExpression)initializer).getArgumentList();\n      if (argumentList == null) return false;\n      final PsiExpression[] expressions = argumentList.getExpressions();\n      for (PsiExpression expression : expressions) {\n        if (!canInlineParmOrThisVariable(expression, shouldBeFinal, strictlyFinal, accessCount, false)) {\n          return false;\n        }\n      }\n      return true; //TODO: \"suspicous\" places to review by user!\n    }\n    else if (initializer instanceof PsiLiteralExpression) {\n      return true;\n    }\n    else if (initializer instanceof PsiArrayAccessExpression) {\n      final PsiExpression arrayExpression = ((PsiArrayAccessExpression)initializer).getArrayExpression();\n      final PsiExpression indexExpression = ((PsiArrayAccessExpression)initializer).getIndexExpression();\n      return canInlineParmOrThisVariable(arrayExpression, shouldBeFinal, strictlyFinal, accessCount, false)\n             && canInlineParmOrThisVariable(indexExpression, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiParenthesizedExpression) {\n      PsiExpression expr = ((PsiParenthesizedExpression)initializer).getExpression();\n      if (expr == null) return true;\n      return canInlineParmOrThisVariable(expr, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiTypeCastExpression) {\n      PsiExpression operand = ((PsiTypeCastExpression)initializer).getOperand();\n      if (operand == null) return false;\n      return canInlineParmOrThisVariable(operand, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiBinaryExpression) {\n      PsiBinaryExpression binExpr = (PsiBinaryExpression)initializer;\n      PsiExpression lOperand = binExpr.getLOperand();\n      PsiExpression rOperand = binExpr.getROperand();\n      if (rOperand == null) return false;\n      return canInlineParmOrThisVariable(lOperand, shouldBeFinal, strictlyFinal, accessCount, false)\n             && canInlineParmOrThisVariable(rOperand, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiClassObjectAccessExpression) {\n      return true;\n    }\n    else if (initializer instanceof PsiThisExpression) {\n      return true;\n    }\n    else if (initializer instanceof PsiSuperExpression) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }","id":95748,"modified_method":"private boolean canInlineParmOrThisVariable(PsiExpression initializer,\n                                              boolean shouldBeFinal,\n                                              boolean strictlyFinal,\n                                              int accessCount,\n                                              boolean isAccessedForWriting) {\n    if (strictlyFinal) {\n      class CanAllLocalsBeDeclaredFinal extends PsiRecursiveElementVisitor {\n        boolean success = true;\n\n        public void visitReferenceExpression(PsiReferenceExpression expression) {\n          final PsiElement psiElement = expression.resolve();\n          if (psiElement instanceof PsiLocalVariable || psiElement instanceof PsiParameter) {\n            if (!RefactoringUtil.canBeDeclaredFinal((PsiVariable)psiElement)) {\n              success = false;\n            }\n          }\n        }\n\n        public void visitElement(PsiElement element) {\n          if (success) {\n            super.visitElement(element);\n          }\n        }\n      }\n\n      final CanAllLocalsBeDeclaredFinal canAllLocalsBeDeclaredFinal = new CanAllLocalsBeDeclaredFinal();\n      initializer.accept(canAllLocalsBeDeclaredFinal);\n      if (!canAllLocalsBeDeclaredFinal.success) return false;\n    }\n    if (initializer instanceof PsiReferenceExpression) {\n      PsiVariable refVar = (PsiVariable)((PsiReferenceExpression)initializer).resolve();\n      if (refVar == null) {\n        return !isAccessedForWriting;\n      }\n      if (refVar instanceof PsiField) {\n        if (isAccessedForWriting) return false;\n        /*\n        PsiField field = (PsiField)refVar;\n        if (isFieldNonModifiable(field)){\n          return true;\n        }\n        //TODO: other cases\n        return false;\n        */\n        return true; //TODO: \"suspicous\" places to review by user!\n      }\n      else {\n        if (isAccessedForWriting) {\n          if (refVar.hasModifierProperty(PsiModifier.FINAL) || shouldBeFinal) return false;\n          PsiReference[] refs = myManager.getSearchHelper().findReferences(refVar,\n                                                                           GlobalSearchScope.projectScope(\n                                                                           myProject),\n                                                                           false);\n          return refs.length == 1; //TODO: control flow\n        }\n        else {\n          if (shouldBeFinal) {\n            return refVar.hasModifierProperty(PsiModifier.FINAL) || RefactoringUtil.canBeDeclaredFinal(refVar);\n          }\n          return true;\n        }\n      }\n    }\n    else if (isAccessedForWriting) {\n      return false;\n    }\n    else if (initializer instanceof PsiCallExpression) {\n      if (accessCount > 1) return false;\n      final PsiExpressionList argumentList = ((PsiCallExpression)initializer).getArgumentList();\n      if (argumentList == null) return false;\n      final PsiExpression[] expressions = argumentList.getExpressions();\n      for (PsiExpression expression : expressions) {\n        if (!canInlineParmOrThisVariable(expression, shouldBeFinal, strictlyFinal, accessCount, false)) {\n          return false;\n        }\n      }\n      return true; //TODO: \"suspicous\" places to review by user!\n    }\n    else if (initializer instanceof PsiLiteralExpression) {\n      return true;\n    }\n    else if (initializer instanceof PsiArrayAccessExpression) {\n      final PsiExpression arrayExpression = ((PsiArrayAccessExpression)initializer).getArrayExpression();\n      final PsiExpression indexExpression = ((PsiArrayAccessExpression)initializer).getIndexExpression();\n      return canInlineParmOrThisVariable(arrayExpression, shouldBeFinal, strictlyFinal, accessCount, false)\n             && canInlineParmOrThisVariable(indexExpression, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiParenthesizedExpression) {\n      PsiExpression expr = ((PsiParenthesizedExpression)initializer).getExpression();\n      return expr == null || canInlineParmOrThisVariable(expr, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiTypeCastExpression) {\n      PsiExpression operand = ((PsiTypeCastExpression)initializer).getOperand();\n      return operand != null && canInlineParmOrThisVariable(operand, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiBinaryExpression) {\n      PsiBinaryExpression binExpr = (PsiBinaryExpression)initializer;\n      PsiExpression lOperand = binExpr.getLOperand();\n      PsiExpression rOperand = binExpr.getROperand();\n      return rOperand != null\n             && canInlineParmOrThisVariable(lOperand, shouldBeFinal, strictlyFinal, accessCount, false) &&\n             canInlineParmOrThisVariable(rOperand, shouldBeFinal, strictlyFinal, accessCount, false);\n    }\n    else if (initializer instanceof PsiClassObjectAccessExpression) {\n      return true;\n    }\n    else if (initializer instanceof PsiThisExpression) {\n      return true;\n    }\n    else if (initializer instanceof PsiSuperExpression) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }","commit_id":"9e26b08c7651138b6935033d9890eeb0dabf8eb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void inlineMethodCall(PsiReferenceExpression ref) throws IncorrectOperationException {\n    ChangeContextUtil.encodeContextInfo(myMethod, false);\n    myMethodCopy = (PsiMethod)myMethod.copy();\n    ChangeContextUtil.clearContextInfo(myMethod);\n\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)ref.getParent();\n\n    PsiSubstitutor callSubstitutor = getCallSubstitutor(methodCall);\n    BlockData blockData = prepareBlock(ref, callSubstitutor, methodCall.getArgumentList());\n    solveVariableNameConflicts(blockData.block, ref);\n    if (callSubstitutor != PsiSubstitutor.EMPTY) {\n      substituteMethodTypeParams(blockData.block, callSubstitutor);\n    }\n    addParmAndThisVarInitializers(blockData, methodCall);\n\n    PsiElement anchor = RefactoringUtil.getParentStatement(methodCall, true);\n    if (anchor == null) return;\n    PsiElement anchorParent = anchor.getParent();\n    PsiLocalVariable thisVar = null;\n    PsiLocalVariable[] parmVars = new PsiLocalVariable[blockData.parmVars.length];\n    PsiLocalVariable resultVar = null;\n    PsiStatement[] statements = blockData.block.getStatements();\n    if (statements.length > 0) {\n      int last = statements.length - 1;\n      /*PsiElement first = statements[0];\n      PsiElement last = statements[statements.length - 1];*/\n\n      if (statements.length > 0 && statements[statements.length - 1]instanceof PsiReturnStatement) {\n        last--;\n      }\n\n      int first = 0;\n      if (first <= last) {\n        PsiElement firstAdded = anchorParent.addRangeBefore(statements[first], statements[last], anchor);\n\n        PsiElement current = firstAdded.getPrevSibling();\n        if (blockData.thisVar != null) {\n          PsiDeclarationStatement statement = PsiTreeUtil.getNextSiblingOfType(current, PsiDeclarationStatement.class);\n          thisVar = (PsiLocalVariable)statement.getDeclaredElements()[0];\n          current = statement;\n        }\n        for (int i = 0; i < parmVars.length; i++) {\n          PsiDeclarationStatement statement = PsiTreeUtil.getNextSiblingOfType(current, PsiDeclarationStatement.class);\n          parmVars[i] = (PsiLocalVariable)statement.getDeclaredElements()[0];\n          current = statement;\n        }\n        if (blockData.resultVar != null) {\n          PsiDeclarationStatement statement = PsiTreeUtil.getNextSiblingOfType(current, PsiDeclarationStatement.class);\n          resultVar = (PsiLocalVariable)statement.getDeclaredElements()[0];\n        }\n      }\n      if (statements.length > 0) {\n        final PsiStatement lastStatement = statements[statements.length - 1];\n        if (lastStatement instanceof PsiReturnStatement) {\n          final PsiExpression returnValue = ((PsiReturnStatement)lastStatement).getReturnValue();\n          while (returnValue instanceof PsiReferenceExpression) ((PsiReferenceExpression)returnValue).getQualifierExpression();\n          if (returnValue != null && PsiUtil.isStatement(returnValue)) {\n            PsiExpressionStatement exprStatement = (PsiExpressionStatement)myFactory.createStatementFromText(\"a;\", null);\n            exprStatement.getExpression().replace(returnValue);\n            anchorParent.addBefore(exprStatement, anchor);\n          }\n        }\n      }\n    }\n\n    if (methodCall.getParent()instanceof PsiExpressionStatement) {\n      methodCall.getParent().delete();\n    }\n    else {\n      if (blockData.resultVar != null) {\n        PsiExpression expr = myFactory.createExpressionFromText(blockData.resultVar.getName(), null);\n        methodCall.replace(expr);\n      }\n      else {\n        //??\n      }\n    }\n\n    PsiClass thisClass = myMethod.getContainingClass();\n    PsiExpression thisAccessExpr;\n    if (thisVar != null) {\n      if (!canInlineParmOrThisVariable(thisVar, false)) {\n        thisAccessExpr = myFactory.createExpressionFromText(thisVar.getName(), null);\n      } else {\n        thisAccessExpr = thisVar.getInitializer();\n      }\n    }\n    else {\n      thisAccessExpr = null;\n    }\n    ChangeContextUtil.decodeContextInfo(anchorParent, thisClass, thisAccessExpr);\n\n    if (thisVar != null) {\n      inlineParmOrThisVariable(thisVar, false);\n    }\n    final PsiParameter[] parameters = myMethod.getParameterList().getParameters();\n    for (int i = 0; i < parmVars.length; i++) {\n      final boolean strictlyFinal;\n      final PsiParameter parameter = parameters[i];\n      if (parameter.hasModifierProperty(PsiModifier.FINAL)) {\n        strictlyFinal = isStrictlyFinal(parameter);\n      }\n      else {\n        strictlyFinal = false;\n      }\n      inlineParmOrThisVariable(parmVars[i], strictlyFinal);\n    }\n    if (resultVar != null) {\n      inlineResultVariable(resultVar);\n    }\n\n    ChangeContextUtil.clearContextInfo(anchorParent);\n  }","id":95749,"modified_method":"private void inlineMethodCall(PsiReferenceExpression ref) throws IncorrectOperationException {\n    ChangeContextUtil.encodeContextInfo(myMethod, false);\n    myMethodCopy = (PsiMethod)myMethod.copy();\n    ChangeContextUtil.clearContextInfo(myMethod);\n\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)ref.getParent();\n\n    PsiSubstitutor callSubstitutor = getCallSubstitutor(methodCall);\n    BlockData blockData = prepareBlock(ref, callSubstitutor, methodCall.getArgumentList());\n    solveVariableNameConflicts(blockData.block, ref);\n    if (callSubstitutor != PsiSubstitutor.EMPTY) {\n      substituteMethodTypeParams(blockData.block, callSubstitutor);\n    }\n    addParmAndThisVarInitializers(blockData, methodCall);\n\n    PsiElement anchor = RefactoringUtil.getParentStatement(methodCall, true);\n    if (anchor == null) return;\n    PsiElement anchorParent = anchor.getParent();\n    PsiLocalVariable thisVar = null;\n    PsiLocalVariable[] parmVars = new PsiLocalVariable[blockData.parmVars.length];\n    PsiLocalVariable resultVar = null;\n    PsiStatement[] statements = blockData.block.getStatements();\n    if (statements.length > 0) {\n      int last = statements.length - 1;\n      /*PsiElement first = statements[0];\n      PsiElement last = statements[statements.length - 1];*/\n\n      if (statements.length > 0 && statements[statements.length - 1]instanceof PsiReturnStatement) {\n        last--;\n      }\n\n      int first = 0;\n      if (first <= last) {\n        PsiElement firstAdded = anchorParent.addRangeBefore(statements[first], statements[last], anchor);\n\n        PsiElement current = firstAdded.getPrevSibling();\n        if (blockData.thisVar != null) {\n          PsiDeclarationStatement statement = PsiTreeUtil.getNextSiblingOfType(current, PsiDeclarationStatement.class);\n          thisVar = (PsiLocalVariable)statement.getDeclaredElements()[0];\n          current = statement;\n        }\n        for (int i = 0; i < parmVars.length; i++) {\n          PsiDeclarationStatement statement = PsiTreeUtil.getNextSiblingOfType(current, PsiDeclarationStatement.class);\n          parmVars[i] = (PsiLocalVariable)statement.getDeclaredElements()[0];\n          current = statement;\n        }\n        if (blockData.resultVar != null) {\n          PsiDeclarationStatement statement = PsiTreeUtil.getNextSiblingOfType(current, PsiDeclarationStatement.class);\n          resultVar = (PsiLocalVariable)statement.getDeclaredElements()[0];\n        }\n      }\n      if (statements.length > 0) {\n        final PsiStatement lastStatement = statements[statements.length - 1];\n        if (lastStatement instanceof PsiReturnStatement) {\n          final PsiExpression returnValue = ((PsiReturnStatement)lastStatement).getReturnValue();\n          if (returnValue != null && PsiUtil.isStatement(returnValue)) {\n            PsiExpressionStatement exprStatement = (PsiExpressionStatement)myFactory.createStatementFromText(\"a;\", null);\n            exprStatement.getExpression().replace(returnValue);\n            anchorParent.addBefore(exprStatement, anchor);\n          }\n        }\n      }\n    }\n\n    if (methodCall.getParent()instanceof PsiExpressionStatement) {\n      methodCall.getParent().delete();\n    }\n    else {\n      if (blockData.resultVar != null) {\n        PsiExpression expr = myFactory.createExpressionFromText(blockData.resultVar.getName(), null);\n        methodCall.replace(expr);\n      }\n      else {\n        //??\n      }\n    }\n\n    PsiClass thisClass = myMethod.getContainingClass();\n    PsiExpression thisAccessExpr;\n    if (thisVar != null) {\n      if (!canInlineParmOrThisVariable(thisVar, false)) {\n        thisAccessExpr = myFactory.createExpressionFromText(thisVar.getName(), null);\n      } else {\n        thisAccessExpr = thisVar.getInitializer();\n      }\n    }\n    else {\n      thisAccessExpr = null;\n    }\n    ChangeContextUtil.decodeContextInfo(anchorParent, thisClass, thisAccessExpr);\n\n    if (thisVar != null) {\n      inlineParmOrThisVariable(thisVar, false);\n    }\n    final PsiParameter[] parameters = myMethod.getParameterList().getParameters();\n    for (int i = 0; i < parmVars.length; i++) {\n      final PsiParameter parameter = parameters[i];\n      final boolean strictlyFinal = parameter.hasModifierProperty(PsiModifier.FINAL) && isStrictlyFinal(parameter);\n      inlineParmOrThisVariable(parmVars[i], strictlyFinal);\n    }\n    if (resultVar != null) {\n      inlineResultVariable(resultVar);\n    }\n\n    ChangeContextUtil.clearContextInfo(anchorParent);\n  }","commit_id":"9e26b08c7651138b6935033d9890eeb0dabf8eb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages) {\n    UsageInfo[] usagesIn = refUsages.get();\n    ArrayList<String> conflicts = new ArrayList<String>();\n\n    if (!myInlineThisOnly) {\n      final PsiMethod[] superMethods = myMethod.findSuperMethods();\n      for (PsiMethod method : superMethods) {\n        final String message = method.hasModifierProperty(PsiModifier.ABSTRACT)\n                               ? RefactoringBundle\n          .message(\"inlined.method.implements.method.from.0\", method.getContainingClass().getQualifiedName())\n                               : RefactoringBundle\n                                 .message(\"inlined.method.overrides.method.from.0\", method.getContainingClass().getQualifiedName());\n        conflicts.add(message);\n      }\n    }\n\n    final ReferencedElementsCollector collector = new ReferencedElementsCollector();\n    myMethod.accept(collector);\n    final Map<PsiMember, Set<PsiMember>> containersToReferenced = getInaccessible(collector.myReferencedMembers, usagesIn);\n\n    final Set<PsiMember> containers = containersToReferenced.keySet();\n    for (PsiMember container : containers) {\n      Set<PsiMember> referencedInaccessible = containersToReferenced.get(container);\n      for (PsiMember referenced : referencedInaccessible) {\n        String message = RefactoringBundle.message(\"0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1\",\n                                                   ConflictsUtil.getDescription(referenced, true), ConflictsUtil.getDescription(container, true));\n        conflicts.add(ConflictsUtil.capitalize(message));\n      }\n    }\n\n    if (conflicts.size() > 0) {\n      ConflictsDialog dialog = new ConflictsDialog(myProject, conflicts);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return false;\n      }\n    }\n\n    if (!myInlineThisOnly) {\n      if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject, myMethod)) return false;\n    }\n\n    prepareSuccessful();\n    RefactoringUtil.sortDepthFirstRightLeftOrder(usagesIn);\n    return true;\n  }","id":95750,"modified_method":"protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages) {\n    UsageInfo[] usagesIn = refUsages.get();\n    ArrayList<String> conflicts = new ArrayList<String>();\n\n    if (!myInlineThisOnly) {\n      final PsiMethod[] superMethods = myMethod.findSuperMethods();\n      for (PsiMethod method : superMethods) {\n        final String message = method.hasModifierProperty(PsiModifier.ABSTRACT)\n                               ? RefactoringBundle\n          .message(\"inlined.method.implements.method.from.0\", method.getContainingClass().getQualifiedName())\n                               : RefactoringBundle\n                                 .message(\"inlined.method.overrides.method.from.0\", method.getContainingClass().getQualifiedName());\n        conflicts.add(message);\n      }\n    }\n\n    final ReferencedElementsCollector collector = new ReferencedElementsCollector();\n    myMethod.accept(collector);\n    final Map<PsiMember, Set<PsiMember>> containersToReferenced = getInaccessible(collector.myReferencedMembers, usagesIn);\n\n    final Set<PsiMember> containers = containersToReferenced.keySet();\n    for (PsiMember container : containers) {\n      Set<PsiMember> referencedInaccessible = containersToReferenced.get(container);\n      for (PsiMember referenced : referencedInaccessible) {\n        String message = RefactoringBundle.message(\"0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1\",\n                                                   ConflictsUtil.getDescription(referenced, true), ConflictsUtil.getDescription(container, true));\n        conflicts.add(ConflictsUtil.capitalize(message));\n      }\n    }\n\n    if (!conflicts.isEmpty()) {\n      ConflictsDialog dialog = new ConflictsDialog(myProject, conflicts);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return false;\n      }\n    }\n\n    if (!myInlineThisOnly) {\n      if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject, myMethod)) return false;\n    }\n\n    prepareSuccessful();\n    RefactoringUtil.sortDepthFirstRightLeftOrder(usagesIn);\n    return true;\n  }","commit_id":"9e26b08c7651138b6935033d9890eeb0dabf8eb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean syncNeeded(final PsiReferenceExpression ref) {\n    if (!myMethod.hasModifierProperty(PsiModifier.SYNCHRONIZED)) return false;\n    final PsiMethod containingMethod = Util.getContainingMethod(ref);\n    if (containingMethod == null) return true;\n    if (!containingMethod.hasModifierProperty(PsiModifier.SYNCHRONIZED)) return true;\n    final PsiClass sourceContainingClass = myMethod.getContainingClass();\n    final PsiClass targetContainingClass = containingMethod.getContainingClass();\n    if (sourceContainingClass.equals (targetContainingClass)) return false;\n    return true;\n  }","id":95751,"modified_method":"private boolean syncNeeded(final PsiReferenceExpression ref) {\n    if (!myMethod.hasModifierProperty(PsiModifier.SYNCHRONIZED)) return false;\n    final PsiMethod containingMethod = Util.getContainingMethod(ref);\n    if (containingMethod == null) return true;\n    if (!containingMethod.hasModifierProperty(PsiModifier.SYNCHRONIZED)) return true;\n    final PsiClass sourceContainingClass = myMethod.getContainingClass();\n    final PsiClass targetContainingClass = containingMethod.getContainingClass();\n    return !sourceContainingClass.equals(targetContainingClass);\n  }","commit_id":"9e26b08c7651138b6935033d9890eeb0dabf8eb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void inlineConstructorCall(PsiCall constructorCall) {\n    final PsiMethod oldConstructor = constructorCall.resolveMethod();\n    LOG.assertTrue (oldConstructor != null);\n    final PsiManager manager = oldConstructor.getManager();\n    final PsiExpression[] instanceCreationArguments = constructorCall.getArgumentList().getExpressions();\n    final PsiParameter[] parameters = oldConstructor.getParameterList().getParameters();\n    LOG.assertTrue (parameters.length == instanceCreationArguments.length);\n\n    PsiStatement[] statements = oldConstructor.getBody().getStatements();\n    LOG.assertTrue (statements.length == 1 && statements[0] instanceof PsiExpressionStatement);\n    PsiExpression expression = ((PsiExpressionStatement)statements[0]).getExpression();\n    LOG.assertTrue (expression instanceof PsiMethodCallExpression);\n\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression.copy();\n    final PsiExpression[] args = methodCall.getArgumentList().getExpressions();\n    for (PsiExpression arg : args) {\n      replaceParameterReferences(arg, oldConstructor, instanceCreationArguments);\n    }\n\n    try {\n      constructorCall.getArgumentList().replace(methodCall.getArgumentList());\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":95752,"modified_method":"private static void inlineConstructorCall(PsiCall constructorCall) {\n    final PsiMethod oldConstructor = constructorCall.resolveMethod();\n    LOG.assertTrue (oldConstructor != null);\n    final PsiExpression[] instanceCreationArguments = constructorCall.getArgumentList().getExpressions();\n    final PsiParameter[] parameters = oldConstructor.getParameterList().getParameters();\n    LOG.assertTrue (parameters.length == instanceCreationArguments.length);\n\n    PsiStatement[] statements = oldConstructor.getBody().getStatements();\n    LOG.assertTrue (statements.length == 1 && statements[0] instanceof PsiExpressionStatement);\n    PsiExpression expression = ((PsiExpressionStatement)statements[0]).getExpression();\n    LOG.assertTrue (expression instanceof PsiMethodCallExpression);\n\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression)expression.copy();\n    final PsiExpression[] args = methodCall.getArgumentList().getExpressions();\n    for (PsiExpression arg : args) {\n      replaceParameterReferences(arg, oldConstructor, instanceCreationArguments);\n    }\n\n    try {\n      constructorCall.getArgumentList().replace(methodCall.getArgumentList());\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"9e26b08c7651138b6935033d9890eeb0dabf8eb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest() throws Exception {\n    String name = getTestName(false);\n    String fileName = \"/refactoring/inlineMethod/\" + name + \".java\";\n    configureByFile(fileName);\n    performAction();\n    checkResultByFile(fileName + \".after\");\n  }","id":95753,"modified_method":"private void doTest() throws Exception {\n    String name = getTestName(false);\n    @NonNls String fileName = \"/refactoring/inlineMethod/\" + name + \".java\";\n    configureByFile(fileName);\n    performAction();\n    checkResultByFile(fileName + \".after\");\n  }","commit_id":"9e26b08c7651138b6935033d9890eeb0dabf8eb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void performAction() throws Exception{\n    PsiElement element = TargetElementUtil.findTargetElement(myEditor,\n            TargetElementUtil.ELEMENT_NAME_ACCEPTED | TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED);\n    final PsiReference ref = myFile.findReferenceAt(myEditor.getCaretModel().getOffset());\n    PsiReferenceExpression refExpr = ref instanceof PsiReferenceExpression ? ((PsiReferenceExpression)ref) : null;\n    assertTrue(element instanceof PsiMethod);\n    final boolean condition = InlineMethodProcessor.checkBadReturns((PsiMethod) element);\n    assertFalse(\"Bad returns found\", condition);\n    PsiMethod method = (PsiMethod)element;\n    InlineOptions options = new MockInlineMethodOptions();\n    final InlineMethodProcessor processor = new InlineMethodProcessor(myProject, method, refExpr, myEditor, options.isInlineThisOnly());\n    processor.run();\n  }","id":95754,"modified_method":"private void performAction() {\n    PsiElement element = TargetElementUtil.findTargetElement(myEditor,\n            TargetElementUtil.ELEMENT_NAME_ACCEPTED | TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED);\n    final PsiReference ref = myFile.findReferenceAt(myEditor.getCaretModel().getOffset());\n    PsiReferenceExpression refExpr = ref instanceof PsiReferenceExpression ? (PsiReferenceExpression)ref : null;\n    assertTrue(element instanceof PsiMethod);\n    final boolean condition = InlineMethodProcessor.checkBadReturns((PsiMethod) element);\n    assertFalse(\"Bad returns found\", condition);\n    PsiMethod method = (PsiMethod)element;\n    InlineOptions options = new MockInlineMethodOptions();\n    final InlineMethodProcessor processor = new InlineMethodProcessor(myProject, method, refExpr, myEditor, options.isInlineThisOnly());\n    processor.run();\n  }","commit_id":"9e26b08c7651138b6935033d9890eeb0dabf8eb3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Get the anonymous user id.\n   * @return the anonymous user id.\n   */\n  public String getAnonymousId(){\n    String agentS=\"\";\n    BackingBean bean = (BackingBean) ContextUtil.lookupBean(\"backingbean\");\n    if (bean != null && !bean.getProp1().equals(\"prop1\"))\n        agentS = bean.getProp1();\n    return agentS;\n  }","id":95755,"modified_method":"/**\n   * Get the anonymous user id.\n   * @return the anonymous user id.\n   */\n  public String getAnonymousId(){\n    String agentS=\"\";\n    BackingBean bean = lookupBackingBean();\n    if (bean != null && !bean.getProp1().equals(\"prop1\"))\n        agentS = bean.getProp1();\n    return agentS;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Can be called statically from AgentFacade from an instance\n   * @param agentString the agent string for an agent\n   * @return role string\n   */\n  public String getRole(String agentString)\n  {\n    String role = \"anonymous_access\";\n    String thisSiteId = ToolManager.getCurrentPlacement().getContext();\n    String realmName = \"/site/\" + thisSiteId;\n    Role userRole=null;\n    if (thisSiteId == null)\n      return role;\n\n    try\n    {\n      Realm siteRealm = RealmService.getRealm(realmName);\n      if (siteRealm!=null)\n      userRole = siteRealm.getUserRole(agentString);\n      if (userRole!=null)\n        role = userRole.getId();\n      log.debug(realmName + \":\" + role);\n    }\n    catch(Exception e)\n    {\n      System.out.println(e.getMessage());\n    }\n    return role;\n  }","id":95756,"modified_method":"/**\n   * Can be called statically from AgentFacade from an instance\n   * @param agentString the agent string for an agent\n   * @return role string\n   */\n  public String getRole(String agentString)\n  {\n    String role = \"anonymous_access\";\n    String thisSiteId = null;\n    try\n    {\n      thisSiteId = ToolManager.getCurrentPlacement().getContext();\n    }\n    catch (Exception ex)\n    {\n      log.warn(\"Failure to get site id from ToolManager.  \\n\" +\n               \"Need to fix if not running in unit test.\");\n      log.warn(ex);\n    }\n    if (thisSiteId == null)\n      return role;\n\n    String realmName = \"/site/\" + thisSiteId;\n    Role userRole=null;\n\n    try\n    {\n      Realm siteRealm = RealmService.getRealm(realmName);\n      if (siteRealm!=null)\n      userRole = siteRealm.getUserRole(agentString);\n      if (userRole!=null)\n        role = userRole.getId();\n      log.debug(realmName + \":\" + role);\n    }\n    catch(Exception e)\n    {\n      System.out.println(e.getMessage());\n    }\n    return role;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Get the site name.\n   * @param siteId  site id\n   * @return the site name.\n   */\n  public String getSiteName(String siteId){\n   String siteName=null;\n   try{\n      siteName = SiteService.getSite(siteId).getTitle();\n      log.debug(\"**** siteName=\"+siteName);\n    }\n    catch (Exception e){\n      System.out.println(e.getMessage());\n    }\n    return siteName;\n  }","id":95757,"modified_method":"/**\n   * Get the site name.\n   * @param siteId  site id\n   * @return the site name.\n   */\n  public String getSiteName(String siteId){\n   String siteName=null;\n   try{\n      siteName = SiteService.getSite(siteId).getTitle();\n      log.info(\"**** siteName=\"+siteName);\n    }\n    catch (Exception ex){\n      log.warn(ex);\n      log.warn(\"SiteService not available.  \" +\n               \"This needs to be fixed if you are not running a unit test.\");\n    }\n    return siteName;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Get the agent string.\n   * @param req the HttpServletRequest\n   * @param res the HttpServletResponse\n   * @return the agent string.\n   */\n  public String getAgentString(HttpServletRequest req, HttpServletResponse res){\n    String agentS=\"\";\n    // this is a sign that an unauthenticated person is trying to access the application\n    // 'cos sakai doesn't know about them-daisyf\n    if (UserDirectoryService.getCurrentUser().getId()==null || (\"\").equals(UserDirectoryService.getCurrentUser().getId())){\n      BackingBean bean = (BackingBean) ContextUtil.lookupBeanFromExternalServlet(\n        \"backingbean\", req, res);\n      if (bean != null && !bean.getProp1().equals(\"prop1\"))\n        agentS = bean.getProp1();\n    }\n    else {\n      agentS = UserDirectoryService.getCurrentUser().getId();\n    }\n    System.out.println(\"** getAgentString() =\"+agentS);\n    return agentS;\n  }","id":95758,"modified_method":"/**\n   * Get the agent string.\n   * @param req the HttpServletRequest\n   * @param res the HttpServletResponse\n   * @return the agent string.\n   */\n  public String getAgentString(HttpServletRequest req, HttpServletResponse res){\n    String agentS=\"\";\n    // this is a sign that an unauthenticated person is trying to access the application\n    // 'cos sakai doesn't know about them-daisyf\n    try\n    {\n      User user = UserDirectoryService.getCurrentUser();\n\n      if (user == null || user.getId() == null ||\n          (\"\").equals(user.getId()))\n      {\n        BackingBean bean = lookupBackingBean(req, res);\n        if (bean != null && !bean.getProp1().equals(\"prop1\"))\n        {\n          agentS = bean.getProp1();\n        }\n      }\n      else\n      {\n        agentS = user.getId();\n      }\n    }\n    catch (Exception ex)\n    {\n      log.warn(ex);\n    }\n    System.out.println(\"** getAgentString() =\"+agentS);\n    return agentS;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Create anonymous user and return the anonymous user id.\n   * @return the anonymous user id.\n   */\n\n  public String createAnonymous(){\n    String anonymousId = \"anonymous_\";\n    try\n    {\n      BackingBean bean = (BackingBean) ContextUtil.lookupBean(\"backingbean\");\n      anonymousId += (new java.util.Date()).getTime();\n      bean.setProp1(anonymousId);\n    }\n    catch (Exception ex)\n    {\n      // leave... ...mostly for unit testing\n    }\n    return anonymousId;\n  }","id":95759,"modified_method":"/**\n   * Create anonymous user and return the anonymous user id.\n   * @return the anonymous user id.\n   */\n\n  public String createAnonymous(){\n    String anonymousId = \"anonymous_\";\n    try\n    {\n      BackingBean bean = lookupBackingBean();\n      anonymousId += (new java.util.Date()).getTime();\n      bean.setProp1(anonymousId);\n    }\n    catch (Exception ex)\n    {\n      // leave... ...mostly for unit testing\n    }\n    return anonymousId;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Right now gets from faces context.\n   * @return\n   */\n  private DeliveryBean lookupDeliveryBean()\n  {\n    DeliveryBean delivery = null;\n    try\n    {\n      delivery = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n    }\n    catch (Exception ex)\n    {\n      log.warn(\"Delivery been not available.  \" +\n               \"This needs to be fixed if you are not running a unit test.\");\n    }\n    return delivery;\n  }","id":95760,"modified_method":"/**\n   * Right now gets from faces context.\n   * @return\n   */\n  private DeliveryBean lookupDeliveryBean()\n  {\n    DeliveryBean delivery = null;\n    try\n    {\n      delivery = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n    }\n    catch (Exception ex)\n    {\n      log.warn(\"Delivery bean not available.  \" +\n               \"This needs to be fixed if you are not running a unit test.\");\n    }\n    return delivery;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Check the agent {agentId} authorized to do {function} to {qualifier}?\n   * @param agentId the agent id.\n   * @param functionId the function to be performed.\n   * @param qualifierId the target of the function.\n   * @return true if the agent checks out for function-> qualifier\n   */\n\n  public boolean checkAuthorization(final String agentId,\n      final String functionId, final String qualifierId)\n  {\n    if (functionId == null || qualifierId == null)\n    {\n      throw new IllegalArgumentException(\"Null Argument\");\n    }\n    final String queryAgentId = org.sakaiproject.service.framework.portal.cover.PortalService.getCurrentSiteId();\n\n    HibernateCallback hcb = new HibernateCallback()\n    {\n      public Object doInHibernate(Session session) throws HibernateException,\n          SQLException\n      {\n        Query query = session.createQuery(res.getString(\"HQL_QUERY_CHECK_AUTHZ\"));\n        if (agentId == null)\n        {\n          query.setString(res.getString(\"a_id\"), queryAgentId);\n        }\n        else\n        {\n          query.setString(res.getString(\"a_id\"), agentId);\n        }\n        query.setString(res.getString(\"f_id\"), functionId);\n        query.setString(res.getString(\"q_id\"), qualifierId);\n\n        log.info(\"query=\" + query);\n        return query.uniqueResult();\n      }\n    };\n    Object result = (AuthorizationData)getHibernateTemplate().execute(hcb);\n\n    if(result != null)\n      return true;\n    else\n      return false;\n  }","id":95761,"modified_method":"/**\n   * Check the agent {agentId} authorized to do {function} to {qualifier}?\n   * @param agentId the agent id.\n   * @param functionId the function to be performed.\n   * @param qualifierId the target of the function.\n   * @return true if the agent checks out for function-> qualifier\n   */\n\n  public boolean checkAuthorization(final String agentId,\n      final String functionId, final String qualifierId)\n  {\n    if (functionId == null || qualifierId == null)\n    {\n      throw new IllegalArgumentException(\"Null Argument\");\n    }\n    final String queryAgentId = lookupSiteIdFromCoverPortalService();\n    if (queryAgentId==null) return false;\n\n    HibernateCallback hcb = new HibernateCallback()\n    {\n      public Object doInHibernate(Session session) throws HibernateException,\n          SQLException\n      {\n        Query query = session.createQuery(res.getString(\"HQL_QUERY_CHECK_AUTHZ\"));\n        if (agentId == null)\n        {\n          query.setString(res.getString(\"a_id\"), queryAgentId);\n        }\n        else\n        {\n          query.setString(res.getString(\"a_id\"), agentId);\n        }\n        query.setString(res.getString(\"f_id\"), functionId);\n        query.setString(res.getString(\"q_id\"), qualifierId);\n\n        log.info(\"query=\" + query);\n        return query.uniqueResult();\n      }\n    };\n    Object result = (AuthorizationData)getHibernateTemplate().execute(hcb);\n\n    if(result != null)\n      return true;\n    else\n      return false;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Is the agent {agentId} authorized to do {function} to {qualifier}?\n   * @param agentId the agent id.\n   * @param functionId the function to be performed.\n   * @param qualifierId the target of the function.\n   * @return true if authorized, false otherwise.\n   */\n  public boolean isAuthorized(final String agentId,\n                              final String functionId, final String qualifierId)\n  {\n    String query =\n      res.getString(\"select_authdata_f_id_q_id\");\n    log.info(\"query=\" + query);\n    List authorizationList = getHibernateTemplate().find(query,\n      new Object[]\n      {functionId, qualifierId}\n      ,\n      new net.sf.hibernate.type.Type[]\n      {Hibernate.STRING, Hibernate.STRING});\n\n    String currentSiteId = null;\n    DeliveryBean delivery = (DeliveryBean) ContextUtil.lookupBean(res.getString(\"delivery\"));\n    if (!delivery.getAccessViaUrl())\n    {\n      currentSiteId = org.sakaiproject.service.framework.portal.cover.\n        PortalService.getCurrentSiteId();\n    }\n    if (currentSiteId == null)\n    {\n      return false; // user doesn't login via any site if they are using published url-daisyf\n    }\n\n    String currentAgentId = UserDirectoryService.getCurrentUser().getId();\n    for (int i = 0; i < authorizationList.size(); i++)\n    {\n      AuthorizationData a = (AuthorizationData) authorizationList.get(i);\n      String siteId = a.getAgentIdString();\n      if ( (res.getString(\"AUTH\")).equals(siteId) && (currentAgentId != null))\n      {\n        return true;\n      }\n      else if ( (res.getString(\"ANON\")).equals(siteId))\n      {\n        return true;\n      }\n      else if (currentSiteId.equals(siteId))\n      {\n        return true;\n      }\n    }\n    return false;\n  }","id":95762,"modified_method":"/**\n   * Is the agent {agentId} authorized to do {function} to {qualifier}?\n   * @param agentId the agent id.\n   * @param functionId the function to be performed.\n   * @param qualifierId the target of the function.\n   * @return true if authorized, false otherwise.\n   */\n  public boolean isAuthorized(final String agentId,\n                              final String functionId, final String qualifierId)\n  {\n    String query =\n      res.getString(\"select_authdata_f_id_q_id\");\n    log.info(\"query=\" + query);\n    List authorizationList = getHibernateTemplate().find(query,\n      new Object[]\n      {functionId, qualifierId}\n      ,\n      new net.sf.hibernate.type.Type[]\n      {Hibernate.STRING, Hibernate.STRING});\n\n    String currentSiteId = null;\n    DeliveryBean delivery = lookupDeliveryBean();\n    if (delivery!=null && !delivery.getAccessViaUrl())\n    {\n      currentSiteId = lookupSiteIdFromCoverPortalService();\n\n      org.sakaiproject.service.framework.portal.cover.\n        PortalService.getCurrentSiteId();\n    }\n    if (currentSiteId == null)\n    {\n      return false; // user doesn't login via any site if they are using published url-daisyf\n    }\n\n    String currentAgentId = UserDirectoryService.getCurrentUser().getId();\n    for (int i = 0; i < authorizationList.size(); i++)\n    {\n      AuthorizationData a = (AuthorizationData) authorizationList.get(i);\n      String siteId = a.getAgentIdString();\n      if ( (res.getString(\"AUTH\")).equals(siteId) && (currentAgentId != null))\n      {\n        return true;\n      }\n      else if ( (res.getString(\"ANON\")).equals(siteId))\n      {\n        return true;\n      }\n      else if (currentSiteId.equals(siteId))\n      {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"f10defd2dd1195cf499894bad00ca12952b1ff97","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Get current site id from within an external servlet.\n   * @param req the HttpServletRequest\n   * @param res the HttpServletResponse\n   * @return teh site id.\n   */\n  public String getCurrentSiteIdFromExternalServlet(HttpServletRequest req,  HttpServletResponse res){\n    // access via url => users does not login via any sites-daisyf\n    String currentSiteId = null;\n    DeliveryBean delivery = (DeliveryBean) ContextUtil.lookupBeanFromExternalServlet(\"delivery\",req, res);\n    if (delivery !=null){\n      delivery = (DeliveryBean) delivery;\n      currentSiteId = ToolManager.getCurrentPlacement().getContext();\n    }\n    return currentSiteId;\n  }","id":95763,"modified_method":"/**\n   * Get current site id from within an external servlet.\n   * @param req the HttpServletRequest\n   * @param res the HttpServletResponse\n   * @return teh site id.\n   */\n  public String getCurrentSiteIdFromExternalServlet(HttpServletRequest req,  HttpServletResponse res){\n    // access via url => users does not login via any sites-daisyf\n    String currentSiteId = null;\n    DeliveryBean delivery =  lookupDeliveryBean();\n    if (delivery!=null && !delivery.getAccessViaUrl())\n    {\n        currentSiteId = ToolManager.getCurrentPlacement().getContext();\n    }\n    return currentSiteId;\n  }","commit_id":"0a09cf62eea7b05d2bc043820be052e6833ccc64","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Get the agent string.\n   * @return the agent string.\n   */\n  public String getAgentString(){\n    String agentS=\"\";\n    // this is anonymous user sign 'cos sakai doesn't know about them-daisyf\n    if (UserDirectoryService.getCurrentUser().getId()==null || (\"\").equals(UserDirectoryService.getCurrentUser().getId())){\n      agentS = getAnonymousId();\n    }\n    else {\n      agentS = UserDirectoryService.getCurrentUser().getId();\n    }\n    log.debug(\"** getAgentString() =\"+agentS);\n    return agentS;\n  }","id":95764,"modified_method":"/**\n   * Get the agent string.\n   * @return the agent string.\n   */\n  public String getAgentString(){\n    String agentS=\"\";\n    // this is anonymous user sign 'cos sakai doesn't know about them-daisyf\n    try\n    {\n      User user = UserDirectoryService.getCurrentUser();\n\n      if (user ==  null || user.getId() == null ||\n          (\"\").equals(user.getId()))\n      {\n        agentS = getAnonymousId();\n      }\n      else\n      {\n        agentS = user.getId();\n      }\n    }\n    catch (Exception ex)\n    {\n      log.warn(ex);\n    }\n    log.debug(\"** getAgentString() =\"+agentS);\n    return agentS;\n  }","commit_id":"0a09cf62eea7b05d2bc043820be052e6833ccc64","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Get the current site id.\n   * @return the site id.\n   */\n  public String getCurrentSiteId(){\n    // access via url => users does not login via any sites\n    String currentSiteId = null;\n    DeliveryBean delivery = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n    if (delivery !=null){\n      delivery = (DeliveryBean) delivery;\n      if (!delivery.getAccessViaUrl()){\n        currentSiteId = ToolManager.getCurrentPlacement().getContext();\n      }\n    }\n    return currentSiteId;\n  }","id":95765,"modified_method":"/**\n   * Get the current site id.\n   * @return the site id.\n   */\n  public String getCurrentSiteId(){\n    // access via url => users does not login via any sites\n    String currentSiteId = null;\n    DeliveryBean delivery =  lookupDeliveryBean();\n\n    if (delivery!=null && !delivery.getAccessViaUrl())\n    {\n        currentSiteId = ToolManager.getCurrentPlacement().getContext();\n    }\n    return currentSiteId;\n  }","commit_id":"0a09cf62eea7b05d2bc043820be052e6833ccc64","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Get the current site name.\n   * @return the site name.\n   */\n  public String getCurrentSiteName(){\n    // access via url => users does not login via any sites-daisyf\n    String currentSiteName = null;\n    DeliveryBean delivery = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n    if (!delivery.getAccessViaUrl()){\n      try{\n        currentSiteName = SiteService.getSite(getCurrentSiteId()).getTitle();\n      }\n      catch (Exception e){\n        System.out.println(e.getMessage());\n      }\n    }\n    return currentSiteName;\n  }","id":95766,"modified_method":"/**\n   * Get the current site name.\n   * @return the site name.\n   */\n  public String getCurrentSiteName(){\n    // access via url => users does not login via any sites-daisyf\n    String currentSiteName = null;\n    DeliveryBean delivery =  lookupDeliveryBean();\n    if (delivery!=null && !delivery.getAccessViaUrl()){\n      try{\n        currentSiteName = SiteService.getSite(getCurrentSiteId()).getTitle();\n      }\n      catch (Exception e){\n        System.out.println(e.getMessage());\n      }\n    }\n    return currentSiteName;\n  }","commit_id":"0a09cf62eea7b05d2bc043820be052e6833ccc64","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private synchronized boolean setupSaslConnection(final InputStream in2, \n        final OutputStream out2) \n        throws IOException {\n      try {\n        saslRpcClient = new SaslRpcClient(authMethod, token,\n            serverPrincipal);\n        return saslRpcClient.saslConnect(in2, out2);\n      } catch (javax.security.sasl.SaslException je) {\n        if (authMethod == AuthMethod.KERBEROS && \n            UserGroupInformation.isLoginKeytabBased()) {\n          //try re-login\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n          //try setting up the connection again\n          try {\n            disposeSasl();\n            saslRpcClient = new SaslRpcClient(authMethod, token,\n                serverPrincipal);\n            return saslRpcClient.saslConnect(in2, out2);\n          } catch (javax.security.sasl.SaslException jee) {\n            UserGroupInformation.\n            setLastUnsuccessfulAuthenticationAttemptTime\n            (System.currentTimeMillis());\n            LOG.warn(\"Couldn't setup connection for \" + \n                UserGroupInformation.getCurrentUser().getUserName() +\n                \" to \" + serverPrincipal + \" even after relogin.\");\n            throw jee;\n          }\n        } else throw je;\n      }\n    }","id":95767,"modified_method":"private synchronized boolean setupSaslConnection(final InputStream in2, \n        final OutputStream out2) \n        throws IOException {\n      try {\n        saslRpcClient = new SaslRpcClient(authMethod, token,\n            serverPrincipal);\n        return saslRpcClient.saslConnect(in2, out2);\n      } catch (javax.security.sasl.SaslException je) {\n        UserGroupInformation loginUser = UserGroupInformation.getLoginUser();\n        UserGroupInformation currentUser = UserGroupInformation.getCurrentUser();\n        UserGroupInformation realUser = currentUser.getRealUser();\n        if (authMethod == AuthMethod.KERBEROS && \n          //try setting up the connection again\n          UserGroupInformation.isLoginKeytabBased() &&\n          // relogin only in case it is the login user (e.g. JT)\n          // or superuser (like oozie).\n          ((currentUser != null && currentUser.equals(loginUser)) ||\n           (realUser != null && realUser.equals(loginUser)))) {\n          try {\n            //try re-login\n            loginUser.reloginFromKeytab();\n            disposeSasl();\n            saslRpcClient = new SaslRpcClient(authMethod, token,\n                serverPrincipal);\n            return saslRpcClient.saslConnect(in2, out2);\n          } catch (javax.security.sasl.SaslException jee) {\n            LOG.warn(\"Couldn't setup connection for \" + \n                loginUser.getUserName() +\n                \" to \" + serverPrincipal + \" even after relogin.\");\n            throw jee;\n          } catch (IOException ie) {\n            ie.initCause(je);\n            throw ie;\n          }\n        } \n        throw je;\n      }\n    }","commit_id":"a7aacdc2d66c6f80704d5ff11fc600acb61c8bf2","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Log a user in from a keytab file. Loads a user identity from a keytab\n   * file and login them in. They become the currently logged-in user.\n   * @param user the principal name to load from the keytab\n   * @param path the path to the keytab file\n   * @throws IOException if the keytab file can't be read\n   */\n  public synchronized\n  static void loginUserFromKeytab(String user,\n                                  String path\n                                  ) throws IOException {\n    if (!isSecurityEnabled())\n      return;\n\n    keytabFile = path;\n    keytabPrincipal = user;\n    try {\n      login = \n        new LoginContext(HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME);\n      login.login();\n      loginUser = new UserGroupInformation(login.getSubject());\n    } catch (LoginException le) {\n      throw new IOException(\"Login failure for \" + user + \" from keytab \" + \n                            path, le);\n    }\n  }","id":95768,"modified_method":"/**\n   * Log a user in from a keytab file. Loads a user identity from a keytab\n   * file and login them in. They become the currently logged-in user.\n   * @param user the principal name to load from the keytab\n   * @param path the path to the keytab file\n   * @throws IOException if the keytab file can't be read\n   */\n  public synchronized\n  static void loginUserFromKeytab(String user,\n                                  String path\n                                  ) throws IOException {\n    if (!isSecurityEnabled())\n      return;\n\n    keytabFile = path;\n    keytabPrincipal = user;\n    Subject subject = new Subject();\n    LoginContext login; \n    try {\n      login = \n        new LoginContext(HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME, subject);\n      login.login();\n      loginUser = new UserGroupInformation(subject);\n      loginUser.login = login;\n    } catch (LoginException le) {\n      throw new IOException(\"Login failure for \" + user + \" from keytab \" + \n                            path, le);\n    }\n  }","commit_id":"a7aacdc2d66c6f80704d5ff11fc600acb61c8bf2","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Re-Login a user in from a keytab file. Loads a user identity from a keytab\n   * file and login them in. They become the currently logged-in user. This\n   * method assumes that {@link #loginUserFromKeytab(String, String)} had \n   * happened already.\n   * The Subject field of this UserGroupInformation object is updated to have\n   * the new credentials.\n   * @throws IOException on a failure\n   */\n  public synchronized void reloginFromKeytab()\n  throws IOException {\n    if (!isSecurityEnabled())\n      return;\n    if (login == null || keytabFile == null) {\n      throw new IOException(\"loginUserFromKeyTab must be done first\");\n    }\n    if (System.currentTimeMillis() -lastUnsuccessfulAuthenticationAttemptTime <\n          MIN_TIME_BEFORE_RELOGIN) {\n      LOG.warn(\"Not attempting to re-login since the last re-login was \" +\n          \"attempted less than \" + (MIN_TIME_BEFORE_RELOGIN/1000) + \" seconds\"+\n          \" before.\");\n      return;\n    }\n    try {\n      LOG.info(\"Initiating logout for \" + getUserName());\n      //clear up the kerberos state. But the tokens are not cleared! As per \n      //the Java kerberos login module code, only the kerberos credentials\n      //are cleared\n      login.logout();\n      //login and also update the subject field of this instance to \n      //have the new credentials (pass it to the LoginContext constructor)\n      login = \n        new LoginContext(HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME, \n            getSubject());\n      LOG.info(\"Initiating re-login for \" + keytabPrincipal);\n      login.login();\n    } catch (LoginException le) {\n      throw new IOException(\"Login failure for \" + keytabPrincipal + \n          \" from keytab \" + keytabFile, le);\n    } \n  }","id":95769,"modified_method":"/**\n   * Re-Login a user in from a keytab file. Loads a user identity from a keytab\n   * file and login them in. They become the currently logged-in user. This\n   * method assumes that {@link #loginUserFromKeytab(String, String)} had \n   * happened already.\n   * The Subject field of this UserGroupInformation object is updated to have\n   * the new credentials.\n   * @throws IOException on a failure\n   */\n  public synchronized void reloginFromKeytab()\n  throws IOException {\n    if (!isSecurityEnabled())\n      return;\n    if (login == null || keytabFile == null) {\n      throw new IOException(\"loginUserFromKeyTab must be done first\");\n    }\n    long now = System.currentTimeMillis();\n    if (now - lastReloginTime < MIN_TIME_BEFORE_RELOGIN ) {\n      LOG.warn(\"Not attempting to re-login since the last re-login was \" +\n          \"attempted less than \" + (MIN_TIME_BEFORE_RELOGIN/1000) + \" seconds\"+\n          \" before.\");\n      return;\n    }\n    // register most recent relogin\n    lastReloginTime = System.currentTimeMillis();\n    try {\n      LOG.info(\"Initiating logout for \" + getUserName());\n      //clear up the kerberos state. But the tokens are not cleared! As per \n      //the Java kerberos login module code, only the kerberos credentials\n      //are cleared\n      login.logout();\n      //login and also update the subject field of this instance to \n      //have the new credentials (pass it to the LoginContext constructor)\n      login = \n        new LoginContext(HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME, \n            getSubject());\n      LOG.info(\"Initiating re-login for \" + keytabPrincipal);\n      login.login();\n    } catch (LoginException le) {\n      throw new IOException(\"Login failure for \" + keytabPrincipal + \n          \" from keytab \" + keytabFile, le);\n    } \n  }","commit_id":"a7aacdc2d66c6f80704d5ff11fc600acb61c8bf2","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Get the currently logged in user.\n   * @return the logged in user\n   * @throws IOException if login fails\n   */\n  public synchronized \n  static UserGroupInformation getLoginUser() throws IOException {\n    if (loginUser == null) {\n      try {\n        if (isSecurityEnabled()) {\n          login = new LoginContext(HadoopConfiguration.USER_KERBEROS_CONFIG_NAME);\n        } else {\n          login = new LoginContext(HadoopConfiguration.SIMPLE_CONFIG_NAME);\n        }\n        login.login();\n        loginUser = new UserGroupInformation(login.getSubject());\n        String tokenFile = System.getenv(HADOOP_TOKEN_FILE_LOCATION);\n        if (tokenFile != null && isSecurityEnabled()) {\n          TokenStorage.readTokensAndLoadInUGI(tokenFile, new Configuration(), loginUser);\n        }\n      } catch (LoginException le) {\n        throw new IOException(\"failure to login\", le);\n      }\n    }\n    return loginUser;\n  }","id":95770,"modified_method":"/**\n   * Get the currently logged in user.\n   * @return the logged in user\n   * @throws IOException if login fails\n   */\n  public synchronized \n  static UserGroupInformation getLoginUser() throws IOException {\n    if (loginUser == null) {\n      try {\n        Subject subject = new Subject();\n        loginUser = new UserGroupInformation(subject);\n        LoginContext login;\n        if (isSecurityEnabled()) {\n          login = new LoginContext(HadoopConfiguration.USER_KERBEROS_CONFIG_NAME,\n              subject);\n        } else {\n          login = new LoginContext(HadoopConfiguration.SIMPLE_CONFIG_NAME, \n              subject);\n        }\n        login.login();\n        loginUser.login = login;\n        loginUser = new UserGroupInformation(login.getSubject());\n        String tokenFile = System.getenv(HADOOP_TOKEN_FILE_LOCATION);\n        if (tokenFile != null && isSecurityEnabled()) {\n          TokenStorage.readTokensAndLoadInUGI(tokenFile, new Configuration(), loginUser);\n        }\n      } catch (LoginException le) {\n        throw new IOException(\"failure to login\", le);\n      }\n    }\n    return loginUser;\n  }","commit_id":"a7aacdc2d66c6f80704d5ff11fc600acb61c8bf2","url":"https://github.com/apache/hadoop"},{"original_method":"public void run()\n    {\n        while (!disposing.get()) {\n            if (connector.isStarted() && !disposing.get()) {\n                Socket socket = null;\n                try {\n                    socket = serverSocket.accept();\n                    TcpConnector connector = (TcpConnector) this.connector;\n                    socket.setReceiveBufferSize(connector.getBufferSize());\n                    socket.setSendBufferSize(connector.getBufferSize());\n                    socket.setSoTimeout(connector.getReceiveTimeout());\n                    logger.trace(\"Server socket Accepted on: \" + serverSocket.getLocalPort());\n                } catch (java.io.InterruptedIOException iie) {\n                    logger.debug(\"Interupted IO doing serverSocket.accept: \" + iie.getMessage());\n                } catch (Exception e) {\n                    if (!connector.isDisposed() && !disposing.get()) {\n                        logger.warn(\"Accept failed on socket: \" + e, e);\n                        handleException(new ConnectException(e, this));\n                    }\n                }\n                if (socket != null) {\n                    try {\n                        Work work = createWork(socket);\n                        try {\n                            getWorkManager().scheduleWork(work, WorkManager.IMMEDIATE, null, null);\n                        } catch (WorkException e) {\n                            logger.error(\"Tcp Server receiver Work was not processed: \" + e.getMessage(), e);\n                        }\n                    } catch (SocketException e) {\n                        handleException(e);\n                    }\n\n                }\n            }\n        }\n    }","id":95771,"modified_method":"public void run() {\n        while (!disposing.get()) {\n            if (connector.isStarted() && !disposing.get()) {\n                Socket socket = null;\n                try {\n                    socket = serverSocket.accept();\n                    TcpConnector connector = (TcpConnector) this.connector;\n                    if (connector.getBufferSize() != UMOConnector.INT_VALUE_NOT_SET && socket.getReceiveBufferSize() != connector.getBufferSize()) {\n                        socket.setReceiveBufferSize(connector.getBufferSize());\n                    }\n                    if (connector.getBufferSize() != UMOConnector.INT_VALUE_NOT_SET && socket.getSendBufferSize() != connector.getBufferSize()) {\n                        socket.setSendBufferSize(connector.getBufferSize());\n                    }\n                    if (connector.getReceiveTimeout() != UMOConnector.INT_VALUE_NOT_SET && socket.getSoTimeout() != connector.getReceiveTimeout()) {\n                        socket.setSoTimeout(connector.getReceiveTimeout());\n                    }\n                    socket.setTcpNoDelay(true);\n                    if (logger.isTraceEnabled()) logger.trace(\"Server socket Accepted on: \" + serverSocket.getLocalPort());\n                } catch (java.io.InterruptedIOException iie) {\n                    if (logger.isDebugEnabled()) logger.debug(\"Interupted IO doing serverSocket.accept: \" + iie.getMessage());\n                } catch (Exception e) {\n                    if (!connector.isDisposed() && !disposing.get()) {\n                        logger.warn(\"Accept failed on socket: \" + e, e);\n                        handleException(new ConnectException(e, this));\n                    }\n                }\n                if (socket != null) {\n                    try {\n                        Work work = createWork(socket);\n                        try {\n                            getWorkManager().scheduleWork(work, WorkManager.IMMEDIATE, null, null);\n                        } catch (WorkException e) {\n                            logger.error(\"Tcp Server receiver Work was not processed: \" + e.getMessage(), e);\n                        }\n                    } catch (IOException e) {\n                        handleException(e);\n                    }\n\n                }\n            }\n        }\n    }","commit_id":"64550d09651d46d19fc7567aec5431005eb63bdd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Work createWork(Socket socket) throws SocketException {\n        return new TcpWorker(socket);\n    }","id":95772,"modified_method":"protected Work createWork(Socket socket) throws IOException {\n        return new TcpWorker(socket);\n    }","commit_id":"64550d09651d46d19fc7567aec5431005eb63bdd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void dispose()\n        {\n            closed.set(true);\n            try {\n                if (socket != null && !socket.isClosed()) {\n                    logger.debug(\"Closing listener: \" + socket.getLocalSocketAddress().toString());\n                    socket.shutdownInput();\n                    socket.shutdownOutput();\n                    socket.close();\n                }\n            } catch (IOException e) {\n                logger.error(\"Socket close failed with: \" + e);\n            }\n            finally {\n                ((TcpConnector) connector).updateReceiveSocketsCount(false);\n            }\n        }","id":95773,"modified_method":"public void dispose() {\n            closed.set(true);\n            try {\n                if (socket != null && !socket.isClosed()) {\n                    if (logger.isDebugEnabled()) logger.debug(\"Closing listener: \" + socket.getLocalSocketAddress().toString());\n                    socket.close();\n                }\n            } catch (IOException e) {\n                logger.error(\"Socket close failed with: \" + e);\n            } finally {\n                ((TcpConnector) connector).updateReceiveSocketsCount(false);\n            }\n        }","commit_id":"64550d09651d46d19fc7567aec5431005eb63bdd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doInitialise() throws InitialisationException\n    {\n        super.doInitialise();\n        if(clientConnectionManager==null)\n        {\n            clientConnectionManager = new MultiThreadedHttpConnectionManager();\n            HttpConnectionManagerParams params = new HttpConnectionManagerParams();\n            if(getSendBufferSize()!= INT_VALUE_NOT_SET ) params.setSendBufferSize(getSendBufferSize());\n            if(getReceiveBufferSize()!= INT_VALUE_NOT_SET ) params.setReceiveBufferSize(getReceiveBufferSize());\n            if(getClientSoTimeout()!= INT_VALUE_NOT_SET ) params.setSoTimeout(getClientSoTimeout());\n            if(getSocketSoLinger()!= INT_VALUE_NOT_SET ) params.setLinger(getSocketSoLinger());\n\n            params.setTcpNoDelay(isSendTcpNoDelay());\n            params.setMaxTotalConnections(getDispatcherThreadingProfile().getMaxThreadsActive());\n        }\n    }","id":95774,"modified_method":"protected void doInitialise() throws InitialisationException\n    {\n        super.doInitialise();\n        if (clientConnectionManager == null)\n        {\n            clientConnectionManager = new MultiThreadedHttpConnectionManager();\n            HttpConnectionManagerParams params = new HttpConnectionManagerParams();\n            if (getSendBufferSize() != INT_VALUE_NOT_SET)\n            {\n                params.setSendBufferSize(getSendBufferSize());\n            }\n            if (getReceiveBufferSize() != INT_VALUE_NOT_SET)\n            {\n                params.setReceiveBufferSize(getReceiveBufferSize());\n            }\n            if (getClientSoTimeout() != INT_VALUE_NOT_SET)\n            {\n                params.setSoTimeout(getClientSoTimeout());\n            }\n            if (getSocketSoLinger() != INT_VALUE_NOT_SET)\n            {\n                params.setLinger(getSocketSoLinger());\n            }\n\n            params.setTcpNoDelay(isSendTcpNoDelay());\n            params.setMaxTotalConnections(getDispatcherThreadingProfile().getMaxThreadsActive());\n            params.setDefaultMaxConnectionsPerHost(getDispatcherThreadingProfile().getMaxThreadsActive());\n\n            clientConnectionManager.setParams(params);\n        }\n    }","commit_id":"e5663a5bc6a66545234fa282fba4008264b5ba14","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testProperties() throws Exception\n    {\n        HttpConnector c = (HttpConnector)getConnector();\n\n        c.setSendBufferSize(1024);\n        assertEquals(1024, c.getSendBufferSize());\n        c.setSendBufferSize(0);\n        assertEquals(TcpConnector.DEFAULT_BUFFER_SIZE, c.getSendBufferSize());\n\n        c.dispose();\n\n        // all kinds of timeouts are now being tested in TcpConnectorTestCase\n    }","id":95775,"modified_method":"public void testProperties() throws Exception\n    {\n        HttpConnector c = (HttpConnector) getConnector();\n\n        c.setSendBufferSize(1024);\n        assertEquals(1024, c.getSendBufferSize());\n        c.setSendBufferSize(0);\n        assertEquals(TcpConnector.DEFAULT_BUFFER_SIZE, c.getSendBufferSize());\n\n        int maxThreadsActive = c.getDispatcherThreadingProfile().getMaxThreadsActive();\n        HttpConnectionManagerParams params = c.getClientConnectionManager().getParams();\n        assertEquals(maxThreadsActive, params.getDefaultMaxConnectionsPerHost());\n        assertEquals(maxThreadsActive, params.getMaxTotalConnections());\n\n        c.dispose();\n\n        // all kinds of timeouts are now being tested in TcpConnectorTestCase\n    }","commit_id":"e5663a5bc6a66545234fa282fba4008264b5ba14","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void create() throws CreateException\n    {\n        try\n        {\n            Map props = new HashMap(component.getDescriptor().getProperties());\n            props.putAll(endpoint.getProperties());\n\n            // check if there is the namespace property on the component\n            String namespace = (String)component.getDescriptor().getProperties().get(\n                SoapConstants.SOAP_NAMESPACE_PROPERTY);\n\n            // check for namespace set as annotation\n            if (connector.isEnableJSR181Annotations())\n            {\n                WebAnnotations wa = (WebAnnotations)ClassUtils.instanciateClass(\n                    XFireConnector.CLASSNAME_ANNOTATIONS, null, this.getClass());\n                // at this point, the object hasn't been created in the descriptor so\n                // we have to retrieve the implementation classname and create a\n                // class for it\n                WebServiceAnnotation webServiceAnnotation = wa.getWebServiceAnnotation(Class.forName(((SimpleObjectFactory)component.getDescriptor()\n                    .getServiceFactory()).getObjectClassName()));\n                namespace = webServiceAnnotation.getTargetNamespace();\n            }\n\n            if ((namespace == null) || (namespace.equalsIgnoreCase(\"\")))\n            {\n                namespace = MapUtils.getString(props, \"namespace\", XFireConnector.DEFAULT_MULE_NAMESPACE_URI);\n            }\n\n            if (props.size() == 0)\n            {\n                // Xfire checks that properties are null rather than empty\n                props = null;\n            }\n            else\n            {\n                rewriteProperty(props, \"portType\");\n                rewriteProperty(props, \"style\");\n                rewriteProperty(props, \"use\");\n                rewriteProperty(props, \"createDefaultBindings\");\n                rewriteProperty(props, \"soap12Transports\");\n                rewriteProperty(props, \"soap11Transports\");\n                rewriteProperty(props, \"scope\");\n                rewriteProperty(props, \"schemas\");\n            }\n\n            serviceInterfaces = (List)component.getDescriptor().getProperties().get(\"serviceInterfaces\");\n            Class exposedInterface;\n\n            if (serviceInterfaces == null)\n            {\n                exposedInterface = component.getDescriptor().getServiceFactory().create().getClass();\n            }\n            else\n            {\n                String className = (String)serviceInterfaces.get(0);\n                exposedInterface = ClassUtils.loadClass(className, this.getClass());\n                logger.info(className + \" class was used to expose your service\");\n\n                if (serviceInterfaces.size() > 1)\n                {\n                    logger.info(\"Only the first class was used to expose your method\");\n                }\n            }\n\n            String wsdlUrl = (String)component.getDescriptor().getProperties().get(\n                SoapConstants.WSDL_URL_PROPERTY);\n\n            if (StringUtils.isBlank(wsdlUrl))\n            {\n                service = connector.getServiceFactory().create(exposedInterface,\n                    component.getDescriptor().getName(), namespace, props);\n            }\n            else\n            {\n                service = connector.getServiceFactory().create(exposedInterface,\n                    new QName(namespace, component.getDescriptor().getName()), new URL(wsdlUrl), props);\n            }\n\n            List inList = connector.getServerInHandlers();\n            if (inList != null)\n            {\n                for (int i = 0; i < inList.size(); i++)\n                {\n                    Class clazz = ClassUtils.loadClass(inList.get(i).toString(), this.getClass());\n                    Handler handler = (Handler)clazz.getConstructor(null).newInstance(null);\n                    service.addInHandler(handler);\n                }\n            }\n\n            boolean sync = endpoint.isSynchronous();\n            // default to synchronous if using http\n            if (endpoint.getEndpointURI().getScheme().startsWith(\"http\")\n                || endpoint.getEndpointURI().getScheme().startsWith(\"servlet\"))\n            {\n                sync = true;\n            }\n            service.setInvoker(new MuleInvoker(this, sync));\n        }\n        catch (Exception e)\n        {\n            throw new CreateException(e, this);\n        }\n    }","id":95776,"modified_method":"protected void create() throws CreateException\n    {\n        try\n        {\n            Map props = new HashMap(component.getDescriptor().getProperties());\n            props.putAll(endpoint.getProperties());\n\n            // check if there is the namespace property on the component\n            String namespace = (String) component.getDescriptor().getProperties().get(\n                SoapConstants.SOAP_NAMESPACE_PROPERTY);\n\n            // check for namespace set as annotation\n            if (connector.isEnableJSR181Annotations())\n            {\n                WebAnnotations wa = (WebAnnotations) ClassUtils.instanciateClass(\n                    XFireConnector.CLASSNAME_ANNOTATIONS, null, this.getClass());\n                // at this point, the object hasn't been created in the descriptor so\n                // we have to retrieve the implementation classname and create a\n                // class for it\n                WebServiceAnnotation webServiceAnnotation = wa.getWebServiceAnnotation(Class.forName(((SimpleObjectFactory)component.getDescriptor()\n                    .getServiceFactory()).getObjectClassName()));\n                namespace = webServiceAnnotation.getTargetNamespace();\n            }\n\n            if ((namespace == null) || (namespace.equalsIgnoreCase(\"\")))\n            {\n                namespace = MapUtils.getString(props, \"namespace\", XFireConnector.DEFAULT_MULE_NAMESPACE_URI);\n            }\n\n            //Convert createDefaultBindings string to boolean before rewriting as xfire property\n            if (props.get(\"createDefaultBindings\") != null)\n            {\n                props.put(\"createDefaultBindings\", Boolean.valueOf((String) props.get(\"createDefaultBindings\")));\n            }\n\n            if (props.size() == 0)\n            {\n                // Xfire checks that properties are null rather than empty\n                props = null;\n            }\n            else\n            {\n                rewriteProperty(props, \"portType\");\n                rewriteProperty(props, \"style\");\n                rewriteProperty(props, \"use\");\n                rewriteProperty(props, \"createDefaultBindings\");\n                rewriteProperty(props, \"soap12Transports\");\n                rewriteProperty(props, \"soap11Transports\");\n                rewriteProperty(props, \"scope\");\n                rewriteProperty(props, \"schemas\");\n            }\n\n            serviceInterfaces = (List)component.getDescriptor().getProperties().get(\"serviceInterfaces\");\n            Class exposedInterface;\n\n            if (serviceInterfaces == null)\n            {\n                exposedInterface = component.getDescriptor().getServiceFactory().create().getClass();\n            }\n            else\n            {\n                String className = (String) serviceInterfaces.get(0);\n                exposedInterface = ClassUtils.loadClass(className, this.getClass());\n                logger.info(className + \" class was used to expose your service\");\n\n                if (serviceInterfaces.size() > 1)\n                {\n                    logger.info(\"Only the first class was used to expose your method\");\n                }\n            }\n\n            String wsdlUrl = (String) component.getDescriptor().getProperties().get(\n                SoapConstants.WSDL_URL_PROPERTY);\n\n            if (StringUtils.isBlank(wsdlUrl))\n            {\n                service = connector.getServiceFactory().create(exposedInterface,\n                    component.getDescriptor().getName(), namespace, props);\n            }\n            else\n            {\n                service = connector.getServiceFactory().create(exposedInterface,\n                    new QName(namespace, component.getDescriptor().getName()), new URL(wsdlUrl), props);\n            }\n\n            List inList = connector.getServerInHandlers();\n            if (inList != null)\n            {\n                for (int i = 0; i < inList.size(); i++)\n                {\n                    Class clazz = ClassUtils.loadClass(inList.get(i).toString(), this.getClass());\n                    Handler handler = (Handler) clazz.getConstructor(null).newInstance(null);\n                    service.addInHandler(handler);\n                }\n            }\n\n            boolean sync = endpoint.isSynchronous();\n            // default to synchronous if using http\n            if (endpoint.getEndpointURI().getScheme().startsWith(\"http\")\n                || endpoint.getEndpointURI().getScheme().startsWith(\"servlet\"))\n            {\n                sync = true;\n            }\n            service.setInvoker(new MuleInvoker(this, sync));\n        }\n        catch (Exception e)\n        {\n            throw new CreateException(e, this);\n        }\n    }","commit_id":"e5663a5bc6a66545234fa282fba4008264b5ba14","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Socket initSocket(String endpoint) throws IOException, URISyntaxException\n    {\n        URI uri = new URI(endpoint);\n        int port = uri.getPort();\n        InetAddress inetAddress = InetAddress.getByName(uri.getHost());\n        Socket socket = createSocket(port, inetAddress);\n        socket.setReuseAddress(true);\n        socket.setReceiveBufferSize(connector.getBufferSize());\n        socket.setSendBufferSize(connector.getBufferSize());\n        socket.setSoTimeout(connector.getSendTimeout());\n        return socket;\n    }","id":95777,"modified_method":"protected Socket initSocket(String endpoint) throws IOException, URISyntaxException {\n        URI uri = new URI(endpoint);\n        int port = uri.getPort();\n        InetAddress inetAddress = InetAddress.getByName(uri.getHost());\n        Socket socket = createSocket(port, inetAddress);\n        socket.setReuseAddress(true);\n        if (connector.getBufferSize() != UMOConnector.INT_VALUE_NOT_SET && socket.getReceiveBufferSize() != connector.getBufferSize()) {\n            socket.setReceiveBufferSize(connector.getBufferSize());\n        }\n        if (connector.getBufferSize() != UMOConnector.INT_VALUE_NOT_SET && socket.getSendBufferSize() != connector.getBufferSize()) {\n            socket.setSendBufferSize(connector.getBufferSize());\n        }\n        if (connector.getReceiveTimeout() != UMOConnector.INT_VALUE_NOT_SET && socket.getSoTimeout() != connector.getReceiveTimeout()) {\n            socket.setSoTimeout(connector.getReceiveTimeout());\n        }\n        return socket;\n    }","commit_id":"5760d99ec5b6dd893d2b8fc8ddd657f183d29bdf","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSyncResponseOfBufferSize() throws Exception\n    {\n        TcpConnector tcp = (TcpConnector) MuleManager.getInstance().lookupConnector(\"tcpConnector\");\n        byte[] data = new byte[tcp.getBufferSize()];\n        UMOMessage message = send(data);\n        assertNotNull(message);\n        byte[] response = message.getPayloadAsBytes();\n        assertEquals(data.length, response.length);\n        assertTrue(Arrays.equals(data, response));\n    }","id":95778,"modified_method":"public void testSyncResponseOfBufferSize() throws Exception\n    {\n        TcpConnector tcp = (TcpConnector) MuleManager.getInstance().lookupConnector(\"tcpConnector\");\n        tcp.setBufferSize(1024 * 16);\n        byte[] data = new byte[tcp.getBufferSize()];\n        UMOMessage message = send(data);\n        assertNotNull(message);\n        byte[] response = message.getPayloadAsBytes();\n        assertEquals(data.length, response.length);\n        assertTrue(Arrays.equals(data, response));\n    }","commit_id":"5760d99ec5b6dd893d2b8fc8ddd657f183d29bdf","url":"https://github.com/mulesoft/mule"},{"original_method":"public void start() throws Exception\n   {      \n      up_prot.up(new Event(Event.CONFIG, map));     \n   }","id":95779,"modified_method":"public void start() throws Exception {\n\t\tHashMap map = new HashMap();\n\t\tmap.put(\"state_transfer\", Boolean.TRUE);\n\t\tmap.put(\"protocol_class\", getClass().getName());\n\t\tup_prot.up(new Event(Event.CONFIG, map));\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public void resetStats()\n   {\n      super.resetStats();\n      num_state_reqs = 0;\n      num_bytes_sent = 0;\n      avg_state_size = 0;\n   }","id":95780,"modified_method":"public void resetStats() {\n\t\tsuper.resetStats();\n\t\tnum_state_reqs.set(0);\n\t\tnum_bytes_sent.set(0);\n\t\tavg_state_size = 0;\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception\n   {\n      map.put(\"state_transfer\", Boolean.TRUE);\n      map.put(\"protocol_class\", getClass().getName());\n   }","id":95781,"modified_method":"public void init() throws Exception {}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"private void respondToStateRequester(boolean open_barrier)\n   {\n\n      // setup the plumbing if needed\n      if (spawner == null)\n      {\n         ServerSocket serverSocket = Util.createServerSocket(bind_addr, bind_port);\n         spawner = new StateProviderThreadSpawner(setupThreadPool(), serverSocket);\n         new Thread(Util.getGlobalThreadGroup(), spawner, \"StateProviderThreadSpawner\").start();\n      }\n\n       List<Message> responses=new LinkedList<Message>();\n      synchronized (state_requesters)\n      {\n         if (state_requesters.isEmpty())\n         {\n            if(log.isWarnEnabled())\n               log.warn(\"Should be responding to state requester, but there are no requesters !\");\n             if(open_barrier)\n                 down_prot.down(new Event(Event.OPEN_BARRIER));\n            return;\n         }\n\n         if (digest == null && isDigestNeeded())\n         {\n            if(log.isWarnEnabled())\n            {\n               log.warn(\"Should be responding to state requester, but there is no digest !\");\n            }\n         }\n         else if (digest != null && isDigestNeeded())\n         {\n            digest = digest.copy();\n         }\n\n         if (log.isDebugEnabled())\n            log.debug(\"Iterating state requesters \" + state_requesters);\n\n\n         for (Iterator it = state_requesters.keySet().iterator(); it.hasNext();)\n         {\n            String tmp_state_id = (String) it.next();\n            Set requesters = (Set) state_requesters.get(tmp_state_id);\n            for (Iterator iter = requesters.iterator(); iter.hasNext();)\n            {\n               Address requester = (Address) iter.next();\n               Message state_rsp = new Message(requester);\n               StateHeader hdr = new StateHeader(StateHeader.STATE_RSP, local_addr, spawner.getServerSocketAddress(),\n                     digest, tmp_state_id);\n               state_rsp.putHeader(NAME, hdr);\n                responses.add(state_rsp);\n            }\n         }\n      }\n\n       if(open_barrier)\n           down_prot.down(new Event(Event.OPEN_BARRIER));\n\n       for(Message msg: responses) {\n           if (log.isDebugEnabled())\n               log.debug(\"Responding to state requester \" + msg.getDest() + \" with address \"\n                       + spawner.getServerSocketAddress() + \" and digest \" + digest);\n           down_prot.down(new Event(Event.MSG, msg));\n           if (stats)\n           {\n               num_state_reqs++;\n           }\n       }\n\n   }","id":95782,"modified_method":"private void respondToStateRequester(boolean open_barrier) {\n\n\t\t// setup the plumbing if needed\n\t\tif(spawner == null){\n\t\t\tServerSocket serverSocket = Util.createServerSocket(bind_addr, bind_port);\n\t\t\tspawner = new StateProviderThreadSpawner(setupThreadPool(), serverSocket);\n\t\t\tnew Thread(Util.getGlobalThreadGroup(), spawner, \"StateProviderThreadSpawner\").start();\n\t\t}\n\n\t\tList<Message> responses = new LinkedList<Message>();\n\t\tDigest digest = null;\n\t\tsynchronized(state_requesters){\n\t\t\tif(state_requesters.isEmpty()){\n\t\t\t\tif(log.isWarnEnabled())\n\t\t\t\t\tlog.warn(\"Should be responding to state requester, but there are no requesters !\");\n\t\t\t\tif(open_barrier)\n\t\t\t\t\tdown_prot.down(new Event(Event.OPEN_BARRIER));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(isDigestNeeded()){\t\t\t\t\n\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"passing down GET_DIGEST\");\n\t\t\t\tdigest = (Digest) down_prot.down(Event.GET_DIGEST_EVT);\t\t\t\n\t\t\t}\n\n\t\t\tfor(Map.Entry<String, Set<Address>> entry:state_requesters.entrySet()){\n\t\t\t\tString stateId = entry.getKey();\n\t\t\t\tSet<Address> requesters = entry.getValue();\n\t\t\t\tfor(Address requester:requesters){\n\t\t\t\t\tMessage state_rsp = new Message(requester);\n\t\t\t\t\tStateHeader hdr = new StateHeader(StateHeader.STATE_RSP, local_addr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tspawner.getServerSocketAddress(), digest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstateId);\n\t\t\t\t\tstate_rsp.putHeader(NAME, hdr);\n\t\t\t\t\tresponses.add(state_rsp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(open_barrier)\n\t\t\tdown_prot.down(new Event(Event.OPEN_BARRIER));\n\n\t\tfor(Message msg:responses){\n\t\t\tif(log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Responding to state requester \" + msg.getDest() + \" with address \"\n\t\t\t\t\t\t+ spawner.getServerSocketAddress() + \" and digest \" + digest);\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\tif(stats){\n\t\t\t\tnum_state_reqs.incrementAndGet();\n\t\t\t}\n\t\t}\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"private Address determineCoordinator()\n   {\n      Address ret = null;\n      synchronized (members)\n      {\n         if (members != null && !members.isEmpty())\n         {\n            for (int i = 0; i < members.size(); i++)\n               if (!local_addr.equals(members.elementAt(i)))\n                  return (Address) members.elementAt(i);\n         }\n      }\n      return ret;\n   }","id":95783,"modified_method":"private Address determineCoordinator() {\t\t\n\t\tsynchronized(members){\n\t\t\tfor(Address member: members){\n\t\t\t\tif(!local_addr.equals(member)){\n\t\t\t\t\treturn member;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\treturn null;\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt)\n   {\n\n      switch (evt.getType())\n      {\n\n         case Event.TMP_VIEW :\n         case Event.VIEW_CHANGE :\n            handleViewChange((View) evt.getArg());\n            break;\n\n         case Event.GET_STATE :\n             StateTransferInfo info = (StateTransferInfo) evt.getArg();\n             Address target;\n            if (info.target == null)\n            {\n               target = determineCoordinator();\n            }\n            else\n            {\n               target = info.target;\n               if (target.equals(local_addr))\n               {\n                  if (log.isErrorEnabled())\n                     log.error(\"GET_STATE: cannot fetch state from myself !\");\n                  target = null;\n               }\n            }\n            if (target == null)\n            {\n               if (log.isDebugEnabled())\n                  log.debug(\"GET_STATE: first member (no state)\");\n               up_prot.up(new Event(Event.GET_STATE_OK, new StateTransferInfo()));\n            }\n            else\n            {\n               boolean successfulFlush = false;\n               if (flushProtocolInStack)\n               {\n\t        \t  Map atts = new HashMap();\t           \t\n\t           \t  atts.put(\"timeout\",new Long(4000)); \n\t              successfulFlush = (Boolean)up_prot.up(new Event(Event.SUSPEND,atts));\n               }\n               if (successfulFlush)\n               {\n               \t  if(log.isInfoEnabled())\t\n                  \tlog.info(\"Successful flush at \" + local_addr);\n               }\n               else\n               {\n                  if (flushProtocolInStack && log.isWarnEnabled())\n                  {\n                     log.warn(\"Could not get successful flush from \" + local_addr);\n                  }\n               }\n               Message state_req = new Message(target, null, null);\n               state_req.putHeader(NAME, new StateHeader(StateHeader.STATE_REQ, local_addr, info.state_id));\n               if (log.isDebugEnabled())\n                  log.debug(\"GET_STATE: asking \" + target + \" for state\");\n\n               // suspend sending and handling of mesage garbage collection gossip messages,\n               // fixes bugs #943480 and #938584). Wake up when state has been received\n               if (log.isDebugEnabled())\n                  log.debug(\"passing down a SUSPEND_STABLE event\");\n               down_prot.down(new Event(Event.SUSPEND_STABLE, new Long(info.timeout)));\n               waiting_for_state_response = true;             \n               down_prot.down(new Event(Event.MSG, state_req));\n            }\n            return null; // don't pass down any further !\n\n         case Event.STATE_TRANSFER_INPUTSTREAM_CLOSED :\n            if (flushProtocolInStack)\n            {\n            \tup_prot.up(new Event(Event.RESUME));\n            }\n\n            if (log.isDebugEnabled())\n               log.debug(\"STATE_TRANSFER_INPUTSTREAM_CLOSED received\");\n            //resume sending and handling of message garbage collection gossip messages,\n            // fixes bugs #943480 and #938584). Wakes up a previously suspended message garbage\n            // collection protocol (e.g. STABLE)\n            if (log.isDebugEnabled())\n               log.debug(\"passing down a RESUME_STABLE event\");\n            down_prot.down(new Event(Event.RESUME_STABLE));\n            return null;        \n         case Event.CONFIG :\n            Map config = (Map) evt.getArg();                     \n            if(config != null && config.containsKey(\"flush_supported\"))\n            {                             \n            \tflushProtocolInStack = true;                           \t                 \n            }\n            break;   \n            \n      }\n\n      return down_prot.down(evt); // pass on to the layer below us\n   }","id":95784,"modified_method":"public Object down(Event evt) {\n\n\t\tswitch(evt.getType()){\n\n\t\tcase Event.TMP_VIEW:\n\t\tcase Event.VIEW_CHANGE:\n\t\t\thandleViewChange((View) evt.getArg());\n\t\t\tbreak;\n\n\t\tcase Event.GET_STATE:\n\t\t\tStateTransferInfo info = (StateTransferInfo) evt.getArg();\n\t\t\tAddress target;\n\t\t\tif(info.target == null){\n\t\t\t\ttarget = determineCoordinator();\n\t\t\t}else{\n\t\t\t\ttarget = info.target;\n\t\t\t\tif(target.equals(local_addr)){\n\t\t\t\t\tif(log.isErrorEnabled())\n\t\t\t\t\t\tlog.error(\"GET_STATE: cannot fetch state from myself !\");\n\t\t\t\t\ttarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(target == null){\n\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"GET_STATE: first member (no state)\");\n\t\t\t\tup_prot.up(new Event(Event.GET_STATE_OK, new StateTransferInfo()));\n\t\t\t}else{\n\t\t\t\tboolean successfulFlush = false;\n\t\t\t\tif(flushProtocolInStack){\n\t\t\t\t\tMap atts = new HashMap();\n\t\t\t\t\tatts.put(\"timeout\", new Long(4000));\n\t\t\t\t\tsuccessfulFlush = (Boolean) up_prot.up(new Event(Event.SUSPEND, atts));\n\t\t\t\t}\n\t\t\t\tif(successfulFlush){\n\t\t\t\t\tif(log.isInfoEnabled())\n\t\t\t\t\t\tlog.info(\"Successful flush at \" + local_addr);\n\t\t\t\t}else{\n\t\t\t\t\tif(flushProtocolInStack && log.isWarnEnabled()){\n\t\t\t\t\t\tlog.warn(\"Could not get successful flush from \" + local_addr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessage state_req = new Message(target, null, null);\n\t\t\t\tstate_req.putHeader(NAME, new StateHeader(StateHeader.STATE_REQ, local_addr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo.state_id));\n\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"GET_STATE: asking \" + target + \n\t\t\t\t\t          \" for state, passing down a SUSPEND_STABLE event, timeout=\" + info.timeout);\n\t\t\t\t\t\n\t\t\t\tdown_prot.down(new Event(Event.SUSPEND_STABLE, new Long(info.timeout)));\n\t\t\t\twaiting_for_state_response = true;\n\t\t\t\tdown_prot.down(new Event(Event.MSG, state_req));\n\t\t\t}\n\t\t\treturn null; // don't pass down any further !\n\n\t\tcase Event.STATE_TRANSFER_INPUTSTREAM_CLOSED:\n\t\t\tif(flushProtocolInStack){\n\t\t\t\tup_prot.up(new Event(Event.RESUME));\n\t\t\t}\n\n\t\t\tif(log.isDebugEnabled())\n\t\t\t\tlog.debug(\"STATE_TRANSFER_INPUTSTREAM_CLOSED received,passing down a RESUME_STABLE event\");\n\t\t\n\t\t\tdown_prot.down(new Event(Event.RESUME_STABLE));\n\t\t\treturn null;\n\t\tcase Event.CONFIG:\n\t\t\tMap config = (Map) evt.getArg();\n\t\t\tif(config != null && config.containsKey(\"flush_supported\")){\n\t\t\t\tflushProtocolInStack = true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn down_prot.down(evt); // pass on to the layer below us\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public StateProviderThreadSpawner(ThreadPoolExecutor pool, ServerSocket stateServingSocket)\n      {\n         super();\n         this.pool = pool;\n         this.serverSocket = stateServingSocket;\n         this.address = new IpAddress(STREAMING_STATE_TRANSFER.this.bind_addr, serverSocket.getLocalPort());\n      }","id":95785,"modified_method":"public StateProviderThreadSpawner(ExecutorService pool,ServerSocket stateServingSocket){\n\t\t\tsuper();\n\t\t\tthis.pool = pool;\n\t\t\tthis.serverSocket = stateServingSocket;\n\t\t\tthis.address = new IpAddress(STREAMING_STATE_TRANSFER.this.bind_addr,\n\t\t\t\t\t\t\t\t\t\t\tserverSocket.getLocalPort());\n\t\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public long getNumberOfStateBytesSent()\n   {\n      return num_bytes_sent;\n   }","id":95786,"modified_method":"public long getNumberOfStateBytesSent() {\n\t\treturn num_bytes_sent.get();\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public Vector requiredDownServices()\n   {\n      Vector retval = new Vector();\n      retval.addElement(new Integer(Event.GET_DIGEST));\n      retval.addElement(new Integer(Event.SET_DIGEST));\n      return retval;\n   }","id":95787,"modified_method":"public Vector<Integer> requiredDownServices() {\n\t\tVector<Integer> retval = new Vector<Integer>();\n\t\tretval.addElement(new Integer(Event.GET_DIGEST));\n\t\tretval.addElement(new Integer(Event.SET_DIGEST));\n\t\treturn retval;\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close() throws IOException\n      {\n         if (log.isDebugEnabled())\n         {\n            log.debug(\"State writer \" + outputStreamOwner + \" is closing the socket \");\n         }\n         try\n         {\n            if (channelOwner != null && channelOwner.isConnected())\n            {\n               channelOwner.down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n            }           \n            outputStreamOwner.close();\n         }\n         catch (IOException e)\n         {\n            throw e;\n         }\n         finally\n         {\n            if (stats)\n            {\n               synchronized (state_requesters)\n               {\n                  num_bytes_sent += bytesWrittenCounter;\n                  avg_state_size = num_bytes_sent / (double) num_state_reqs;\n               }\n            }\n         }\n      }","id":95788,"modified_method":"public void close() throws IOException {\n\t\t\tif(log.isDebugEnabled()){\n\t\t\t\tlog.debug(\"State writer \" + outputStreamOwner + \" is closing the socket \");\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tif(channelOwner != null && channelOwner.isConnected()){\n\t\t\t\t\tchannelOwner.down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n\t\t\t\t}\n\t\t\t\toutputStreamOwner.close();\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow e;\n\t\t\t}finally{\n\t\t\t\tif(stats){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tavg_state_size = num_bytes_sent.addAndGet(bytesWrittenCounter) / num_state_reqs.doubleValue();\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"void removeFromStateRequesters(Address address, String state_id)\n   {\n      synchronized (state_requesters)\n      {\n         Set requesters = (Set) state_requesters.get(state_id);\n         if (requesters != null && !requesters.isEmpty())\n         {\n            boolean removed = requesters.remove(address);\n            if (log.isDebugEnabled())\n            {\n               log.debug(\"Attempted to clear \" + address + \" from requesters, successful=\" + removed);\n            }\n            if (requesters.isEmpty())\n            {\n               state_requesters.remove(state_id);\n               if (log.isDebugEnabled())\n               {\n                  log.debug(\"Cleared all requesters for state \" + state_id + \",state_requesters=\" + state_requesters);\n               }\n            }\n         }        \n      }\n   }","id":95789,"modified_method":"void removeFromStateRequesters(Address address, String state_id) {\n\t\tsynchronized(state_requesters){\n\t\t\tSet<Address> requesters = state_requesters.get(state_id);\n\t\t\tif(requesters != null && !requesters.isEmpty()){\n\t\t\t\tboolean removed = requesters.remove(address);\n\t\t\t\tif(log.isDebugEnabled()){\n\t\t\t\t\tlog.debug(\"Attempted to clear \" + address + \" from requesters, successful=\"\n\t\t\t\t\t\t\t+ removed);\n\t\t\t\t}\n\t\t\t\tif(requesters.isEmpty()){\n\t\t\t\t\tstate_requesters.remove(state_id);\n\t\t\t\t\tif(log.isDebugEnabled()){\n\t\t\t\t\t\tlog.debug(\"Cleared all requesters for state \" + state_id\n\t\t\t\t\t\t\t\t+ \",state_requesters=\" + state_requesters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getNumberOfStateRequests()\n   {\n      return num_state_reqs;\n   }","id":95790,"modified_method":"public int getNumberOfStateRequests() {\n\t\treturn num_state_reqs.get();\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v)\n   {\n      Address old_coord;\n      Vector new_members = v.getMembers();\n      boolean send_up_null_state_rsp = false;\n\n      synchronized (members)\n      {\n         old_coord = (Address) (!members.isEmpty()? members.firstElement() : null);\n         members.clear();\n         members.addAll(new_members);\n\n         // this handles the case where a coord dies during a state transfer; prevents clients from hanging forever\n         // Note this only takes a coordinator crash into account, a getState(target, timeout), where target is not\n         // null is not handled ! (Usually we get the state from the coordinator)\n         // http://jira.jboss.com/jira/browse/JGRP-148\n         if (waiting_for_state_response && old_coord != null && !members.contains(old_coord))\n         {\n            send_up_null_state_rsp = true;\n         }\n      }\n\n      if (send_up_null_state_rsp)\n      {\n         log.warn(\"discovered that the state provider (\" + old_coord\n               + \") crashed; will return null state to application\");\n      }\n   }","id":95791,"modified_method":"private void handleViewChange(View v) {\n\t\tAddress old_coord;\n\t\tVector<Address> new_members = v.getMembers();\n\t\tboolean send_up_null_state_rsp = false;\n\n\t\tsynchronized(members){\n\t\t\told_coord = (!members.isEmpty() ? members.firstElement() : null);\n\t\t\tmembers.clear();\n\t\t\tmembers.addAll(new_members);\n\t\t\t\n\t\t\tif(waiting_for_state_response && old_coord != null && !members.contains(old_coord)){\n\t\t\t\tsend_up_null_state_rsp = true;\n\t\t\t}\n\t\t}\n\n\t\tif(send_up_null_state_rsp){\n\t\t\tlog.warn(\"discovered that the state provider (\" + old_coord\n\t\t\t\t\t+ \") crashed; will return null state to application\");\n\t\t}\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStateReq(StateHeader hdr)\n   {\n      Object sender = hdr.sender;\n      if (sender == null)\n      {\n         if (log.isErrorEnabled())\n            log.error(\"sender is null !\");\n         return;\n      }\n      String id = hdr.state_id;\n      synchronized (state_requesters)\n      {\n         Set requesters = (Set) state_requesters.get(id);\n         if (requesters == null)\n         {\n            requesters = new HashSet();\n         }\n         requesters.add(sender);\n         state_requesters.put(id, requesters);\n      }\n\n       if(isDigestNeeded()) // FLUSH protocol is not present\n       {\n           down_prot.down(new Event(Event.CLOSE_BARRIER)); // drain (and block) incoming msgs until after state has been returned\n           digest = null;\n           if (log.isDebugEnabled())\n               log.debug(\"passing down GET_DIGEST\");\n           digest=(Digest)down_prot.down(Event.GET_DIGEST_EVT);\n       }\n       try {\n           respondToStateRequester(isDigestNeeded());\n       }\n       catch(Throwable t) {\n           if(log.isErrorEnabled())\n               log.error(\"failed fetching state from application\", t);\n           if(isDigestNeeded())\n               down_prot.down(new Event(Event.OPEN_BARRIER));\n       }\n   }","id":95792,"modified_method":"private void handleStateReq(StateHeader hdr) {\n\t\tAddress sender = hdr.sender;\n\t\tString id = hdr.state_id;\n\t\tif(sender == null){\n\t\t\tif(log.isErrorEnabled())\n\t\t\t\tlog.error(\"sender is null !\");\n\t\t\treturn;\n\t\t}\n\n\t\tsynchronized(state_requesters){\n\t\t\tSet<Address> requesters = state_requesters.get(id);\n\t\t\tif(requesters == null){\n\t\t\t\trequesters = new HashSet<Address>();\n\t\t\t}\n\t\t\trequesters.add(sender);\n\t\t\tstate_requesters.put(id, requesters);\n\t\t}\n\n\t\tif(isDigestNeeded()) // FLUSH protocol is not present\n\t\t{\n\t\t\tdown_prot.down(new Event(Event.CLOSE_BARRIER)); // drain (and block)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// incoming msgs\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// until after state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// has been returned\t\t\n\t\t}\n\t\ttry{\n\t\t\trespondToStateRequester(isDigestNeeded());\n\t\t}catch(Throwable t){\n\t\t\tif(log.isErrorEnabled())\n\t\t\t\tlog.error(\"failed fetching state from application\", t);\n\t\t\tif(isDigestNeeded())\n\t\t\t\tdown_prot.down(new Event(Event.OPEN_BARRIER));\n\t\t}\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run()\n      {\n         runner = Thread.currentThread();\n         for (; running;)\n         {\n            try\n            {\n               if (log.isDebugEnabled())\n                  log.debug(\"StateProviderThreadSpawner listening at \" + getServerSocketAddress() + \"...\");\n               if (log.isDebugEnabled())\n                  log.debug(\"Pool has \" + pool.getPoolSize() + \" active threads\");\n               final Socket socket = serverSocket.accept();\n               pool.execute(new Runnable()\n               {\n                  public void run()\n                  {\n                     if (log.isDebugEnabled())\n                        log.debug(\"Accepted request for state transfer from \" + socket.getInetAddress() + \":\"\n                              + socket.getPort() + \" handing of to PooledExecutor thread\");\n                     new StateProviderHandler().process(socket);\n                  }\n               });\n\n            }\n            catch (IOException e)\n            {\n               if(log.isWarnEnabled())\n               {\n                  //we get this exception when we close server socket\n                  //exclude that case\n                  if (serverSocket != null && !serverSocket.isClosed())\n                  {\n                     log.warn(\"Spawning socket from server socket finished abnormaly\", e);\n                  }\n               }\n            }\n         }\n      }","id":95793,"modified_method":"public void run() {\n\t\t\trunner = Thread.currentThread();\n\t\t\tfor(;running;){\n\t\t\t\ttry{\n\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(\"StateProviderThreadSpawner listening at \"\n\t\t\t\t\t\t\t\t+ getServerSocketAddress() + \"...\");\n\n\t\t\t\t\tfinal Socket socket = serverSocket.accept();\n\t\t\t\t\tpool.execute(new Runnable() {\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\t\t\tlog.debug(\"Accepted request for state transfer from \"\n\t\t\t\t\t\t\t\t\t\t+ socket.getInetAddress() + \":\" + socket.getPort()\n\t\t\t\t\t\t\t\t\t\t+ \" handing of to PooledExecutor thread\");\n\t\t\t\t\t\t\tnew StateProviderHandler().process(socket);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t}catch(IOException e){\n\t\t\t\t\tif(log.isWarnEnabled()){\n\t\t\t\t\t\t// we get this exception when we close server socket\n\t\t\t\t\t\t// exclude that case\n\t\t\t\t\t\tif(serverSocket != null && !serverSocket.isClosed()){\n\t\t\t\t\t\t\tlog.warn(\"Spawning socket from server socket finished abnormaly\", e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"private ThreadPoolExecutor setupThreadPool()\n   {\n      ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, max_pool, pool_thread_keep_alive, TimeUnit.MILLISECONDS,\n                                                             new LinkedBlockingQueue(10));\n      threadPool.setThreadFactory(new ThreadFactory()\n      {\n\n         public Thread newThread(final Runnable command)\n         {\n            synchronized (poolLock)\n            {\n               threadCounter++;\n            }\n            return new Thread(Util.getGlobalThreadGroup(), \"STREAMING_STATE_TRANSFER.poolid=\" + threadCounter)\n            {\n               public void run()\n               {\n                  if (log.isDebugEnabled())\n                  {\n                     log.debug(Thread.currentThread() + \" started.\");\n                  }\n                  command.run();\n                  if (log.isDebugEnabled())\n                  {\n                     log.debug(Thread.currentThread() + \" stopped.\");\n                  }\n               }\n            };\n         }\n\n      });\n      return threadPool;\n   }","id":95794,"modified_method":"private ThreadPoolExecutor setupThreadPool() {\n\t\tThreadPoolExecutor threadPool = new ThreadPoolExecutor(1,\n\t\t                                                       max_pool,\n\t\t                                                       pool_thread_keep_alive,\n\t\t                                                       TimeUnit.MILLISECONDS,\n\t\t                                                       new LinkedBlockingQueue<Runnable>(10));\n\t\tThreadFactory factory = new ThreadFactory() {\n\t\t\tpublic Thread newThread(final Runnable command) {\n\t\t\t\tThread thread = new Thread(Util.getGlobalThreadGroup(), command,\n\t\t\t\t\t\t\t\t\t\t\t\"STREAMING_STATE_TRANSFER state provider-\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ threadCounter.incrementAndGet());\t\t\t\t\n                return thread;\n\t\t\t}\n\t\t};\n\t\tthreadPool.setThreadFactory(factory);\n\t\treturn threadPool;\n\t}","commit_id":"0a1a194d1d772cf66b03c3fc85a8a2449f82cb10","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStateReq(StateHeader hdr)\n   {\n      Object sender = hdr.sender;\n      if (sender == null)\n      {\n         if (log.isErrorEnabled())\n            log.error(\"sender is null !\");\n         return;\n      }\n      String id = hdr.state_id;\n      synchronized (state_requesters)\n      {\n         boolean empty = state_requesters.isEmpty();\n         Set requesters = (Set) state_requesters.get(id);\n         if (requesters == null)\n         {\n            requesters = new HashSet();\n         }\n         requesters.add(sender);\n         state_requesters.put(id, requesters);\n\n         if (!isDigestNeeded())\n         {\n            respondToStateRequester();\n         }\n         else if (empty)\n         {\n            digest = null;\n            if (log.isDebugEnabled())\n               log.debug(\"passing down GET_DIGEST\");\n            down_prot.down(new Event(Event.GET_DIGEST));\n         }\n      }\n   }","id":95795,"modified_method":"private void handleStateReq(StateHeader hdr)\n   {\n      Object sender = hdr.sender;\n      if (sender == null)\n      {\n         if (log.isErrorEnabled())\n            log.error(\"sender is null !\");\n         return;\n      }\n      String id = hdr.state_id;\n      synchronized (state_requesters)\n      {\n         Set requesters = (Set) state_requesters.get(id);\n         if (requesters == null)\n         {\n            requesters = new HashSet();\n         }\n         requesters.add(sender);\n         state_requesters.put(id, requesters);\n      }\n\n       if(isDigestNeeded())\n       {\n           digest = null;\n           if (log.isDebugEnabled())\n               log.debug(\"passing down GET_DIGEST\");\n           digest=(Digest)down_prot.down(Event.GET_DIGEST_EVT);\n       }\n       respondToStateRequester();\n   }","commit_id":"5065990dd89a27f6af876e79b11ee7d3d4e0fbab","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStateReq(StateHeader hdr)\n   {\n      Object sender = hdr.sender;\n      if (sender == null)\n      {\n         if (log.isErrorEnabled())\n            log.error(\"sender is null !\");\n         return;\n      }\n      String id = hdr.state_id;\n      synchronized (state_requesters)\n      {\n         boolean empty = state_requesters.isEmpty();\n         Set requesters = (Set) state_requesters.get(id);\n         if (requesters == null)\n         {\n            requesters = new HashSet();\n         }\n         requesters.add(sender);\n         state_requesters.put(id, requesters);\n\n         if (!isDigestNeeded())\n         {\n            respondToStateRequester();\n         }\n         else if (empty)\n         {\n            digest = null;\n            if (log.isDebugEnabled())\n               log.debug(\"passing down GET_DIGEST\");\n            down_prot.down(new Event(Event.GET_DIGEST));\n         }\n      }\n   }","id":95796,"modified_method":"private void handleStateReq(StateHeader hdr)\n   {\n      Object sender = hdr.sender;\n      if (sender == null)\n      {\n         if (log.isErrorEnabled())\n            log.error(\"sender is null !\");\n         return;\n      }\n      String id = hdr.state_id;\n      synchronized (state_requesters)\n      {\n         Set requesters = (Set) state_requesters.get(id);\n         if (requesters == null)\n         {\n            requesters = new HashSet();\n         }\n         requesters.add(sender);\n         state_requesters.put(id, requesters);\n      }\n\n       if(isDigestNeeded())\n       {\n           digest = null;\n           if (log.isDebugEnabled())\n               log.debug(\"passing down GET_DIGEST\");\n           digest=(Digest)down_prot.down(Event.GET_DIGEST_EVT);\n       }\n       respondToStateRequester();\n   }","commit_id":"1bf675600b60d2c5f2cad8a1d78783cd6bcaca95","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception\n   {\n      map.put(\"state_transfer\", Boolean.TRUE);\n      map.put(\"protocol_class\", getClass().getName());\n   }","id":95797,"modified_method":"public void init() throws Exception {}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception\n   {      \n      up_prot.up(new Event(Event.CONFIG, map));     \n   }","id":95798,"modified_method":"public void start() throws Exception {\n\t\tHashMap map = new HashMap();\n\t\tmap.put(\"state_transfer\", Boolean.TRUE);\n\t\tmap.put(\"protocol_class\", getClass().getName());\n\t\tup_prot.up(new Event(Event.CONFIG, map));\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt)\n   {\n\n      switch (evt.getType())\n      {\n\n         case Event.TMP_VIEW :\n         case Event.VIEW_CHANGE :\n            handleViewChange((View) evt.getArg());\n            break;\n\n         case Event.GET_STATE :\n             StateTransferInfo info = (StateTransferInfo) evt.getArg();\n             Address target;\n            if (info.target == null)\n            {\n               target = determineCoordinator();\n            }\n            else\n            {\n               target = info.target;\n               if (target.equals(local_addr))\n               {\n                  if (log.isErrorEnabled())\n                     log.error(\"GET_STATE: cannot fetch state from myself !\");\n                  target = null;\n               }\n            }\n            if (target == null)\n            {\n               if (log.isDebugEnabled())\n                  log.debug(\"GET_STATE: first member (no state)\");\n               up_prot.up(new Event(Event.GET_STATE_OK, new StateTransferInfo()));\n            }\n            else\n            {\n               boolean successfulFlush = false;\n               if (flushProtocolInStack)\n               {\n\t        \t  Map atts = new HashMap();\t           \t\n\t           \t  atts.put(\"timeout\",new Long(4000)); \n\t              successfulFlush = (Boolean)up_prot.up(new Event(Event.SUSPEND,atts));\n               }\n               if (successfulFlush)\n               {\n               \t  if(log.isInfoEnabled())\t\n                  \tlog.info(\"Successful flush at \" + local_addr);\n               }\n               else\n               {\n                  if (flushProtocolInStack && log.isWarnEnabled())\n                  {\n                     log.warn(\"Could not get successful flush from \" + local_addr);\n                  }\n               }\n               Message state_req = new Message(target, null, null);\n               state_req.putHeader(NAME, new StateHeader(StateHeader.STATE_REQ, local_addr, info.state_id));\n               if (log.isDebugEnabled())\n                  log.debug(\"GET_STATE: asking \" + target + \" for state\");\n\n               // suspend sending and handling of mesage garbage collection gossip messages,\n               // fixes bugs #943480 and #938584). Wake up when state has been received\n               if (log.isDebugEnabled())\n                  log.debug(\"passing down a SUSPEND_STABLE event\");\n               down_prot.down(new Event(Event.SUSPEND_STABLE, new Long(info.timeout)));\n               waiting_for_state_response = true;             \n               down_prot.down(new Event(Event.MSG, state_req));\n            }\n            return null; // don't pass down any further !\n\n         case Event.STATE_TRANSFER_INPUTSTREAM_CLOSED :\n            if (flushProtocolInStack)\n            {\n            \tup_prot.up(new Event(Event.RESUME));\n            }\n\n            if (log.isDebugEnabled())\n               log.debug(\"STATE_TRANSFER_INPUTSTREAM_CLOSED received\");\n            //resume sending and handling of message garbage collection gossip messages,\n            // fixes bugs #943480 and #938584). Wakes up a previously suspended message garbage\n            // collection protocol (e.g. STABLE)\n            if (log.isDebugEnabled())\n               log.debug(\"passing down a RESUME_STABLE event\");\n            down_prot.down(new Event(Event.RESUME_STABLE));\n            return null;        \n         case Event.CONFIG :\n            Map config = (Map) evt.getArg();                     \n            if(config != null && config.containsKey(\"flush_supported\"))\n            {                             \n            \tflushProtocolInStack = true;                           \t                 \n            }\n            break;   \n            \n      }\n\n      return down_prot.down(evt); // pass on to the layer below us\n   }","id":95799,"modified_method":"public Object down(Event evt) {\n\n\t\tswitch(evt.getType()){\n\n\t\tcase Event.TMP_VIEW:\n\t\tcase Event.VIEW_CHANGE:\n\t\t\thandleViewChange((View) evt.getArg());\n\t\t\tbreak;\n\n\t\tcase Event.GET_STATE:\n\t\t\tStateTransferInfo info = (StateTransferInfo) evt.getArg();\n\t\t\tAddress target;\n\t\t\tif(info.target == null){\n\t\t\t\ttarget = determineCoordinator();\n\t\t\t}else{\n\t\t\t\ttarget = info.target;\n\t\t\t\tif(target.equals(local_addr)){\n\t\t\t\t\tif(log.isErrorEnabled())\n\t\t\t\t\t\tlog.error(\"GET_STATE: cannot fetch state from myself !\");\n\t\t\t\t\ttarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(target == null){\n\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"GET_STATE: first member (no state)\");\n\t\t\t\tup_prot.up(new Event(Event.GET_STATE_OK, new StateTransferInfo()));\n\t\t\t}else{\n\t\t\t\tboolean successfulFlush = false;\n\t\t\t\tif(flushProtocolInStack){\n\t\t\t\t\tMap atts = new HashMap();\n\t\t\t\t\tatts.put(\"timeout\", new Long(4000));\n\t\t\t\t\tsuccessfulFlush = (Boolean) up_prot.up(new Event(Event.SUSPEND, atts));\n\t\t\t\t}\n\t\t\t\tif(successfulFlush){\n\t\t\t\t\tif(log.isInfoEnabled())\n\t\t\t\t\t\tlog.info(\"Successful flush at \" + local_addr);\n\t\t\t\t}else{\n\t\t\t\t\tif(flushProtocolInStack && log.isWarnEnabled()){\n\t\t\t\t\t\tlog.warn(\"Could not get successful flush from \" + local_addr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessage state_req = new Message(target, null, null);\n\t\t\t\tstate_req.putHeader(NAME, new StateHeader(StateHeader.STATE_REQ, local_addr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo.state_id));\n\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"GET_STATE: asking \" + target + \n\t\t\t\t\t          \" for state, passing down a SUSPEND_STABLE event, timeout=\" + info.timeout);\n\t\t\t\t\t\n\t\t\t\tdown_prot.down(new Event(Event.SUSPEND_STABLE, new Long(info.timeout)));\n\t\t\t\twaiting_for_state_response = true;\n\t\t\t\tdown_prot.down(new Event(Event.MSG, state_req));\n\t\t\t}\n\t\t\treturn null; // don't pass down any further !\n\n\t\tcase Event.STATE_TRANSFER_INPUTSTREAM_CLOSED:\n\t\t\tif(flushProtocolInStack){\n\t\t\t\tup_prot.up(new Event(Event.RESUME));\n\t\t\t}\n\n\t\t\tif(log.isDebugEnabled())\n\t\t\t\tlog.debug(\"STATE_TRANSFER_INPUTSTREAM_CLOSED received,passing down a RESUME_STABLE event\");\n\t\t\n\t\t\tdown_prot.down(new Event(Event.RESUME_STABLE));\n\t\t\treturn null;\n\t\tcase Event.CONFIG:\n\t\t\tMap config = (Map) evt.getArg();\n\t\t\tif(config != null && config.containsKey(\"flush_supported\")){\n\t\t\t\tflushProtocolInStack = true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn down_prot.down(evt); // pass on to the layer below us\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"void removeFromStateRequesters(Address address, String state_id)\n   {\n      synchronized (state_requesters)\n      {\n         Set requesters = (Set) state_requesters.get(state_id);\n         if (requesters != null && !requesters.isEmpty())\n         {\n            boolean removed = requesters.remove(address);\n            if (log.isDebugEnabled())\n            {\n               log.debug(\"Attempted to clear \" + address + \" from requesters, successful=\" + removed);\n            }\n            if (requesters.isEmpty())\n            {\n               state_requesters.remove(state_id);\n               if (log.isDebugEnabled())\n               {\n                  log.debug(\"Cleared all requesters for state \" + state_id + \",state_requesters=\" + state_requesters);\n               }\n            }\n         }        \n      }\n   }","id":95800,"modified_method":"void removeFromStateRequesters(Address address, String state_id) {\n\t\tsynchronized(state_requesters){\n\t\t\tSet<Address> requesters = state_requesters.get(state_id);\n\t\t\tif(requesters != null && !requesters.isEmpty()){\n\t\t\t\tboolean removed = requesters.remove(address);\n\t\t\t\tif(log.isDebugEnabled()){\n\t\t\t\t\tlog.debug(\"Attempted to clear \" + address + \" from requesters, successful=\"\n\t\t\t\t\t\t\t+ removed);\n\t\t\t\t}\n\t\t\t\tif(requesters.isEmpty()){\n\t\t\t\t\tstate_requesters.remove(state_id);\n\t\t\t\t\tif(log.isDebugEnabled()){\n\t\t\t\t\t\tlog.debug(\"Cleared all requesters for state \" + state_id\n\t\t\t\t\t\t\t\t+ \",state_requesters=\" + state_requesters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"private Address determineCoordinator()\n   {\n      Address ret = null;\n      synchronized (members)\n      {\n         if (members != null && !members.isEmpty())\n         {\n            for (int i = 0; i < members.size(); i++)\n               if (!local_addr.equals(members.elementAt(i)))\n                  return (Address) members.elementAt(i);\n         }\n      }\n      return ret;\n   }","id":95801,"modified_method":"private Address determineCoordinator() {\t\t\n\t\tsynchronized(members){\n\t\t\tfor(Address member: members){\n\t\t\t\tif(!local_addr.equals(member)){\n\t\t\t\t\treturn member;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\treturn null;\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run()\n      {\n         runner = Thread.currentThread();\n         for (; running;)\n         {\n            try\n            {\n               if (log.isDebugEnabled())\n                  log.debug(\"StateProviderThreadSpawner listening at \" + getServerSocketAddress() + \"...\");\n               if (log.isDebugEnabled())\n                  log.debug(\"Pool has \" + pool.getPoolSize() + \" active threads\");\n               final Socket socket = serverSocket.accept();\n               pool.execute(new Runnable()\n               {\n                  public void run()\n                  {\n                     if (log.isDebugEnabled())\n                        log.debug(\"Accepted request for state transfer from \" + socket.getInetAddress() + \":\"\n                              + socket.getPort() + \" handing of to PooledExecutor thread\");\n                     new StateProviderHandler().process(socket);\n                  }\n               });\n\n            }\n            catch (IOException e)\n            {\n               if(log.isWarnEnabled())\n               {\n                  //we get this exception when we close server socket\n                  //exclude that case\n                  if (serverSocket != null && !serverSocket.isClosed())\n                  {\n                     log.warn(\"Spawning socket from server socket finished abnormaly\", e);\n                  }\n               }\n            }\n         }\n      }","id":95802,"modified_method":"public void run() {\n\t\t\trunner = Thread.currentThread();\n\t\t\tfor(;running;){\n\t\t\t\ttry{\n\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(\"StateProviderThreadSpawner listening at \"\n\t\t\t\t\t\t\t\t+ getServerSocketAddress() + \"...\");\n\n\t\t\t\t\tfinal Socket socket = serverSocket.accept();\n\t\t\t\t\tpool.execute(new Runnable() {\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\t\t\tlog.debug(\"Accepted request for state transfer from \"\n\t\t\t\t\t\t\t\t\t\t+ socket.getInetAddress() + \":\" + socket.getPort()\n\t\t\t\t\t\t\t\t\t\t+ \" handing of to PooledExecutor thread\");\n\t\t\t\t\t\t\tnew StateProviderHandler().process(socket);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t}catch(IOException e){\n\t\t\t\t\tif(log.isWarnEnabled()){\n\t\t\t\t\t\t// we get this exception when we close server socket\n\t\t\t\t\t\t// exclude that case\n\t\t\t\t\t\tif(serverSocket != null && !serverSocket.isClosed()){\n\t\t\t\t\t\t\tlog.warn(\"Spawning socket from server socket finished abnormaly\", e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v)\n   {\n      Address old_coord;\n      Vector new_members = v.getMembers();\n      boolean send_up_null_state_rsp = false;\n\n      synchronized (members)\n      {\n         old_coord = (Address) (!members.isEmpty()? members.firstElement() : null);\n         members.clear();\n         members.addAll(new_members);\n\n         // this handles the case where a coord dies during a state transfer; prevents clients from hanging forever\n         // Note this only takes a coordinator crash into account, a getState(target, timeout), where target is not\n         // null is not handled ! (Usually we get the state from the coordinator)\n         // http://jira.jboss.com/jira/browse/JGRP-148\n         if (waiting_for_state_response && old_coord != null && !members.contains(old_coord))\n         {\n            send_up_null_state_rsp = true;\n         }\n      }\n\n      if (send_up_null_state_rsp)\n      {\n         log.warn(\"discovered that the state provider (\" + old_coord\n               + \") crashed; will return null state to application\");\n      }\n   }","id":95803,"modified_method":"private void handleViewChange(View v) {\n\t\tAddress old_coord;\n\t\tVector<Address> new_members = v.getMembers();\n\t\tboolean send_up_null_state_rsp = false;\n\n\t\tsynchronized(members){\n\t\t\told_coord = (!members.isEmpty() ? members.firstElement() : null);\n\t\t\tmembers.clear();\n\t\t\tmembers.addAll(new_members);\n\t\t\t\n\t\t\tif(waiting_for_state_response && old_coord != null && !members.contains(old_coord)){\n\t\t\t\tsend_up_null_state_rsp = true;\n\t\t\t}\n\t\t}\n\n\t\tif(send_up_null_state_rsp){\n\t\t\tlog.warn(\"discovered that the state provider (\" + old_coord\n\t\t\t\t\t+ \") crashed; will return null state to application\");\n\t\t}\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getNumberOfStateRequests()\n   {\n      return num_state_reqs;\n   }","id":95804,"modified_method":"public int getNumberOfStateRequests() {\n\t\treturn num_state_reqs.get();\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public Vector requiredDownServices()\n   {\n      Vector retval = new Vector();\n      retval.addElement(new Integer(Event.GET_DIGEST));\n      retval.addElement(new Integer(Event.SET_DIGEST));\n      return retval;\n   }","id":95805,"modified_method":"public Vector<Integer> requiredDownServices() {\n\t\tVector<Integer> retval = new Vector<Integer>();\n\t\tretval.addElement(new Integer(Event.GET_DIGEST));\n\t\tretval.addElement(new Integer(Event.SET_DIGEST));\n\t\treturn retval;\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"private ThreadPoolExecutor setupThreadPool()\n   {\n      ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, max_pool, pool_thread_keep_alive, TimeUnit.MILLISECONDS,\n                                                             new LinkedBlockingQueue(10));\n      threadPool.setThreadFactory(new ThreadFactory()\n      {\n\n         public Thread newThread(final Runnable command)\n         {\n            synchronized (poolLock)\n            {\n               threadCounter++;\n            }\n            return new Thread(Util.getGlobalThreadGroup(), \"STREAMING_STATE_TRANSFER.poolid=\" + threadCounter)\n            {\n               public void run()\n               {\n                  if (log.isDebugEnabled())\n                  {\n                     log.debug(Thread.currentThread() + \" started.\");\n                  }\n                  command.run();\n                  if (log.isDebugEnabled())\n                  {\n                     log.debug(Thread.currentThread() + \" stopped.\");\n                  }\n               }\n            };\n         }\n\n      });\n      return threadPool;\n   }","id":95806,"modified_method":"private ThreadPoolExecutor setupThreadPool() {\n\t\tThreadPoolExecutor threadPool = new ThreadPoolExecutor(1,\n\t\t                                                       max_pool,\n\t\t                                                       pool_thread_keep_alive,\n\t\t                                                       TimeUnit.MILLISECONDS,\n\t\t                                                       new LinkedBlockingQueue<Runnable>(10));\n\t\tThreadFactory factory = new ThreadFactory() {\n\t\t\tpublic Thread newThread(final Runnable command) {\n\t\t\t\tThread thread = new Thread(Util.getGlobalThreadGroup(), command,\n\t\t\t\t\t\t\t\t\t\t\t\"STREAMING_STATE_TRANSFER state provider-\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ threadCounter.incrementAndGet());\t\t\t\t\n                return thread;\n\t\t\t}\n\t\t};\n\t\tthreadPool.setThreadFactory(factory);\n\t\treturn threadPool;\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public void close() throws IOException\n      {\n         if (log.isDebugEnabled())\n         {\n            log.debug(\"State writer \" + outputStreamOwner + \" is closing the socket \");\n         }\n         try\n         {\n            if (channelOwner != null && channelOwner.isConnected())\n            {\n               channelOwner.down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n            }           \n            outputStreamOwner.close();\n         }\n         catch (IOException e)\n         {\n            throw e;\n         }\n         finally\n         {\n            if (stats)\n            {\n               synchronized (state_requesters)\n               {\n                  num_bytes_sent += bytesWrittenCounter;\n                  avg_state_size = num_bytes_sent / (double) num_state_reqs;\n               }\n            }\n         }\n      }","id":95807,"modified_method":"public void close() throws IOException {\n\t\t\tif(log.isDebugEnabled()){\n\t\t\t\tlog.debug(\"State writer \" + outputStreamOwner + \" is closing the socket \");\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tif(channelOwner != null && channelOwner.isConnected()){\n\t\t\t\t\tchannelOwner.down(new Event(Event.STATE_TRANSFER_OUTPUTSTREAM_CLOSED));\n\t\t\t\t}\n\t\t\t\toutputStreamOwner.close();\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow e;\n\t\t\t}finally{\n\t\t\t\tif(stats){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tavg_state_size = num_bytes_sent.addAndGet(bytesWrittenCounter) / num_state_reqs.doubleValue();\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public void resetStats()\n   {\n      super.resetStats();\n      num_state_reqs = 0;\n      num_bytes_sent = 0;\n      avg_state_size = 0;\n   }","id":95808,"modified_method":"public void resetStats() {\n\t\tsuper.resetStats();\n\t\tnum_state_reqs.set(0);\n\t\tnum_bytes_sent.set(0);\n\t\tavg_state_size = 0;\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStateReq(StateHeader hdr)\n   {\n      Object sender = hdr.sender;\n      if (sender == null)\n      {\n         if (log.isErrorEnabled())\n            log.error(\"sender is null !\");\n         return;\n      }\n      String id = hdr.state_id;\n      synchronized (state_requesters)\n      {\n         Set requesters = (Set) state_requesters.get(id);\n         if (requesters == null)\n         {\n            requesters = new HashSet();\n         }\n         requesters.add(sender);\n         state_requesters.put(id, requesters);\n      }\n\n       if(isDigestNeeded()) // FLUSH protocol is not present\n       {\n           down_prot.down(new Event(Event.CLOSE_BARRIER)); // drain (and block) incoming msgs until after state has been returned\n           digest = null;\n           if (log.isDebugEnabled())\n               log.debug(\"passing down GET_DIGEST\");\n           digest=(Digest)down_prot.down(Event.GET_DIGEST_EVT);\n       }\n       try {\n           respondToStateRequester(isDigestNeeded());\n       }\n       catch(Throwable t) {\n           if(log.isErrorEnabled())\n               log.error(\"failed fetching state from application\", t);\n           if(isDigestNeeded())\n               down_prot.down(new Event(Event.OPEN_BARRIER));\n       }\n   }","id":95809,"modified_method":"private void handleStateReq(StateHeader hdr) {\n\t\tAddress sender = hdr.sender;\n\t\tString id = hdr.state_id;\n\t\tif(sender == null){\n\t\t\tif(log.isErrorEnabled())\n\t\t\t\tlog.error(\"sender is null !\");\n\t\t\treturn;\n\t\t}\n\n\t\tsynchronized(state_requesters){\n\t\t\tSet<Address> requesters = state_requesters.get(id);\n\t\t\tif(requesters == null){\n\t\t\t\trequesters = new HashSet<Address>();\n\t\t\t}\n\t\t\trequesters.add(sender);\n\t\t\tstate_requesters.put(id, requesters);\n\t\t}\n\n\t\tif(isDigestNeeded()) // FLUSH protocol is not present\n\t\t{\n\t\t\tdown_prot.down(new Event(Event.CLOSE_BARRIER)); // drain (and block)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// incoming msgs\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// until after state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// has been returned\t\t\n\t\t}\n\t\ttry{\n\t\t\trespondToStateRequester(isDigestNeeded());\n\t\t}catch(Throwable t){\n\t\t\tif(log.isErrorEnabled())\n\t\t\t\tlog.error(\"failed fetching state from application\", t);\n\t\t\tif(isDigestNeeded())\n\t\t\t\tdown_prot.down(new Event(Event.OPEN_BARRIER));\n\t\t}\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"private void respondToStateRequester(boolean open_barrier)\n   {\n\n      // setup the plumbing if needed\n      if (spawner == null)\n      {\n         ServerSocket serverSocket = Util.createServerSocket(bind_addr, bind_port);\n         spawner = new StateProviderThreadSpawner(setupThreadPool(), serverSocket);\n         new Thread(Util.getGlobalThreadGroup(), spawner, \"StateProviderThreadSpawner\").start();\n      }\n\n       List<Message> responses=new LinkedList<Message>();\n      synchronized (state_requesters)\n      {\n         if (state_requesters.isEmpty())\n         {\n            if(log.isWarnEnabled())\n               log.warn(\"Should be responding to state requester, but there are no requesters !\");\n             if(open_barrier)\n                 down_prot.down(new Event(Event.OPEN_BARRIER));\n            return;\n         }\n\n         if (digest == null && isDigestNeeded())\n         {\n            if(log.isWarnEnabled())\n            {\n               log.warn(\"Should be responding to state requester, but there is no digest !\");\n            }\n         }\n         else if (digest != null && isDigestNeeded())\n         {\n            digest = digest.copy();\n         }\n\n         if (log.isDebugEnabled())\n            log.debug(\"Iterating state requesters \" + state_requesters);\n\n\n         for (Iterator it = state_requesters.keySet().iterator(); it.hasNext();)\n         {\n            String tmp_state_id = (String) it.next();\n            Set requesters = (Set) state_requesters.get(tmp_state_id);\n            for (Iterator iter = requesters.iterator(); iter.hasNext();)\n            {\n               Address requester = (Address) iter.next();\n               Message state_rsp = new Message(requester);\n               StateHeader hdr = new StateHeader(StateHeader.STATE_RSP, local_addr, spawner.getServerSocketAddress(),\n                     digest, tmp_state_id);\n               state_rsp.putHeader(NAME, hdr);\n                responses.add(state_rsp);\n            }\n         }\n      }\n\n       if(open_barrier)\n           down_prot.down(new Event(Event.OPEN_BARRIER));\n\n       for(Message msg: responses) {\n           if (log.isDebugEnabled())\n               log.debug(\"Responding to state requester \" + msg.getDest() + \" with address \"\n                       + spawner.getServerSocketAddress() + \" and digest \" + digest);\n           down_prot.down(new Event(Event.MSG, msg));\n           if (stats)\n           {\n               num_state_reqs++;\n           }\n       }\n\n   }","id":95810,"modified_method":"private void respondToStateRequester(boolean open_barrier) {\n\n\t\t// setup the plumbing if needed\n\t\tif(spawner == null){\n\t\t\tServerSocket serverSocket = Util.createServerSocket(bind_addr, bind_port);\n\t\t\tspawner = new StateProviderThreadSpawner(setupThreadPool(), serverSocket);\n\t\t\tnew Thread(Util.getGlobalThreadGroup(), spawner, \"StateProviderThreadSpawner\").start();\n\t\t}\n\n\t\tList<Message> responses = new LinkedList<Message>();\n\t\tDigest digest = null;\n\t\tsynchronized(state_requesters){\n\t\t\tif(state_requesters.isEmpty()){\n\t\t\t\tif(log.isWarnEnabled())\n\t\t\t\t\tlog.warn(\"Should be responding to state requester, but there are no requesters !\");\n\t\t\t\tif(open_barrier)\n\t\t\t\t\tdown_prot.down(new Event(Event.OPEN_BARRIER));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(isDigestNeeded()){\t\t\t\t\n\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"passing down GET_DIGEST\");\n\t\t\t\tdigest = (Digest) down_prot.down(Event.GET_DIGEST_EVT);\t\t\t\n\t\t\t}\n\n\t\t\tfor(Map.Entry<String, Set<Address>> entry:state_requesters.entrySet()){\n\t\t\t\tString stateId = entry.getKey();\n\t\t\t\tSet<Address> requesters = entry.getValue();\n\t\t\t\tfor(Address requester:requesters){\n\t\t\t\t\tMessage state_rsp = new Message(requester);\n\t\t\t\t\tStateHeader hdr = new StateHeader(StateHeader.STATE_RSP, local_addr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tspawner.getServerSocketAddress(), digest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstateId);\n\t\t\t\t\tstate_rsp.putHeader(NAME, hdr);\n\t\t\t\t\tresponses.add(state_rsp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(open_barrier)\n\t\t\tdown_prot.down(new Event(Event.OPEN_BARRIER));\n\n\t\tfor(Message msg:responses){\n\t\t\tif(log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Responding to state requester \" + msg.getDest() + \" with address \"\n\t\t\t\t\t\t+ spawner.getServerSocketAddress() + \" and digest \" + digest);\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\tif(stats){\n\t\t\t\tnum_state_reqs.incrementAndGet();\n\t\t\t}\n\t\t}\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public long getNumberOfStateBytesSent()\n   {\n      return num_bytes_sent;\n   }","id":95811,"modified_method":"public long getNumberOfStateBytesSent() {\n\t\treturn num_bytes_sent.get();\n\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"public StateProviderThreadSpawner(ThreadPoolExecutor pool, ServerSocket stateServingSocket)\n      {\n         super();\n         this.pool = pool;\n         this.serverSocket = stateServingSocket;\n         this.address = new IpAddress(STREAMING_STATE_TRANSFER.this.bind_addr, serverSocket.getLocalPort());\n      }","id":95812,"modified_method":"public StateProviderThreadSpawner(ExecutorService pool,ServerSocket stateServingSocket){\n\t\t\tsuper();\n\t\t\tthis.pool = pool;\n\t\t\tthis.serverSocket = stateServingSocket;\n\t\t\tthis.address = new IpAddress(STREAMING_STATE_TRANSFER.this.bind_addr,\n\t\t\t\t\t\t\t\t\t\t\tserverSocket.getLocalPort());\n\t\t}","commit_id":"b93674c4041e4b7958c06c128d9a70e77dae7217","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n   * Maven can modify test directories during Sonar execution - see MavenPhaseExecutor.\n   */\n  public List<File> getTestDirs() {\n    return resolvePaths(project.getPom().getTestCompileSourceRoots());\n  }","id":95813,"modified_method":"/**\n   * Maven can modify test directories during Sonar execution - see MavenPhaseExecutor.\n   */\n  public List<File> getTestDirs() {\n    return ImmutableList.copyOf(Iterables.filter(resolvePaths(project.getPom().getTestCompileSourceRoots()), DIRECTORY_EXISTS));\n  }","commit_id":"70c03e6ac1e0f24277655f9e7666142d9418d270","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Maven can modify source directories during Sonar execution - see MavenPhaseExecutor.\n   */\n  public List<File> getSourceDirs() {\n    return resolvePaths(project.getPom().getCompileSourceRoots());\n  }","id":95814,"modified_method":"/**\n   * Maven can modify source directories during Sonar execution - see MavenPhaseExecutor.\n   */\n  public List<File> getSourceDirs() {\n    return ImmutableList.copyOf(Iterables.filter(resolvePaths(project.getPom().getCompileSourceRoots()), DIRECTORY_EXISTS));\n  }","commit_id":"70c03e6ac1e0f24277655f9e7666142d9418d270","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<File> getSourceDirs() {\n    if (pom != null) {\n      // Maven can modify source directories during Sonar execution - see MavenPhaseExecutor.\n      return resolvePaths(pom.getCompileSourceRoots());\n    } else {\n      return resolvePaths(def.getSourceDirs());\n    }\n  }","id":95815,"modified_method":"public List<File> getSourceDirs() {\n    List<File> unfiltered;\n    if (pom != null) {\n      // Maven can modify source directories during Sonar execution - see MavenPhaseExecutor.\n      unfiltered = resolvePaths(pom.getCompileSourceRoots());\n    } else {\n      unfiltered = resolvePaths(def.getSourceDirs());\n    }\n    return ImmutableList.copyOf(Iterables.filter(unfiltered, DIRECTORY_EXISTS));\n  }","commit_id":"70c03e6ac1e0f24277655f9e7666142d9418d270","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Maven can modify test directories during Sonar execution - see MavenPhaseExecutor.\n   */\n  public List<File> getTestDirs() {\n    if (pom != null) {\n      // Maven can modify test directories during Sonar execution - see MavenPhaseExecutor.\n      return resolvePaths(pom.getTestCompileSourceRoots());\n    } else {\n      return resolvePaths(def.getTestDirs());\n    }\n  }","id":95816,"modified_method":"/**\n   * Maven can modify test directories during Sonar execution - see MavenPhaseExecutor.\n   */\n  public List<File> getTestDirs() {\n    List<File> unfiltered;\n    if (pom != null) {\n      // Maven can modify test directories during Sonar execution - see MavenPhaseExecutor.\n      unfiltered = resolvePaths(pom.getTestCompileSourceRoots());\n    } else {\n      unfiltered = resolvePaths(def.getTestDirs());\n    }\n    return ImmutableList.copyOf(Iterables.filter(unfiltered, DIRECTORY_EXISTS));\n  }","commit_id":"70c03e6ac1e0f24277655f9e7666142d9418d270","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void createViolationFor(Resource resource, SMInputCursor violationCursor) throws XMLStreamException {\n    Rule rule = getRule(violationCursor);\n    Integer line = getLineIndex(violationCursor);\n    if (rule != null && resource != null) {\n      Violation violation = new Violation(rule, resource)\n          .setLineId(line)\n          .setMessage(messageFor(violationCursor));\n      context.saveViolation(violation);\n    }\n  }","id":95817,"modified_method":"private void createViolationFor(Resource resource, SMInputCursor violationCursor) throws XMLStreamException {\n    Rule rule = getRule(violationCursor);\n    Integer line = getLineIndex(violationCursor);\n    if (rule != null && resource != null) {\n      Violation violation = Violation.create(rule, resource)\n          .setLineId(line)\n          .setMessage(messageFor(violationCursor));\n      context.saveViolation(violation);\n    }\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void registerRule(Class aClass, BelongsToProfile belongsToProfile, RulesProfile profile, ValidationMessages validation) {\n    if (belongsToProfile != null) {\n      String ruleKey = AnnotationIntrospector.getCheckKey(aClass);\n      Rule rule = ruleFinder.findByKey(repositoryKey, ruleKey);\n      if (rule == null) {\n        validation.addErrorText(\"Rule not found: [repository=\" + repositoryKey + \", key=\" + ruleKey + \"]\");\n\n      } else {\n        RulePriority priority = null;\n        if (belongsToProfile.priority() != null) {\n          priority = RulePriority.fromCheckPriority(belongsToProfile.priority());\n        }\n        profile.activateRule(rule, priority);\n      }\n    }\n  }","id":95818,"modified_method":"private void registerRule(Class aClass, BelongsToProfile belongsToProfile, RulesProfile profile, ValidationMessages validation) {\n    if (belongsToProfile != null) {\n      String ruleKey = RuleAnnotationUtils.getRuleKey(aClass);\n      Rule rule = ruleFinder.findByKey(repositoryKey, ruleKey);\n      if (rule == null) {\n        validation.addErrorText(\"Rule not found: [repository=\" + repositoryKey + \", key=\" + ruleKey + \"]\");\n\n      } else {\n        RulePriority priority = null;\n        if (belongsToProfile.priority() != null) {\n          priority = RulePriority.fromCheckPriority(belongsToProfile.priority());\n        }\n        profile.activateRule(rule, priority);\n      }\n    }\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void addError(AuditEvent event) {\n    String ruleKey = getRuleKey(event);\n    if (ruleKey != null) {\n      Rule rule = ruleFinder.findByKey(CheckstyleConstants.REPOSITORY_KEY, ruleKey);\n      if (rule != null) {\n        initResource(event);\n        Violation violation = new Violation(rule, currentResource)\n            .setLineId(getLineId(event))\n            .setMessage(getMessage(event));\n        context.saveViolation(violation);\n      }\n    }\n  }","id":95819,"modified_method":"public void addError(AuditEvent event) {\n    String ruleKey = getRuleKey(event);\n    if (ruleKey != null) {\n      Rule rule = ruleFinder.findByKey(CheckstyleConstants.REPOSITORY_KEY, ruleKey);\n      if (rule != null) {\n        initResource(event);\n        Violation violation = Violation.create(rule, currentResource)\n            .setLineId(getLineId(event))\n            .setMessage(getMessage(event));\n        context.saveViolation(violation);\n      }\n    }\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void analyse(Project project, SensorContext context) {\n    File report = getFindbugsReportFile(project);\n    LOG.info(\"Findbugs output report: \" + report.getAbsolutePath());\n    FindbugsXmlReportParser reportParser = new FindbugsXmlReportParser(report);\n    List<FindbugsXmlReportParser.Violation> fbViolations = reportParser.getViolations();\n    for (FindbugsXmlReportParser.Violation fbViolation : fbViolations) {\n      Rule rule = ruleFinder.findByKey(FindbugsConstants.REPOSITORY_KEY, fbViolation.getType());\n      JavaFile resource = new JavaFile(fbViolation.getSonarJavaFileKey());\n      if (context.getResource(resource) != null) {\n        Violation violation = new Violation(rule, resource).setLineId(fbViolation.getStart()).setMessage(fbViolation.getLongMessage());\n        context.saveViolation(violation);\n      }\n    }\n  }","id":95820,"modified_method":"public void analyse(Project project, SensorContext context) {\n    File report = getFindbugsReportFile(project);\n    LOG.info(\"Findbugs output report: \" + report.getAbsolutePath());\n    FindbugsXmlReportParser reportParser = new FindbugsXmlReportParser(report);\n    List<FindbugsXmlReportParser.Violation> fbViolations = reportParser.getViolations();\n    for (FindbugsXmlReportParser.Violation fbViolation : fbViolations) {\n      Rule rule = ruleFinder.findByKey(FindbugsConstants.REPOSITORY_KEY, fbViolation.getType());\n      JavaFile resource = new JavaFile(fbViolation.getSonarJavaFileKey());\n      if (context.getResource(resource) != null) {\n        Violation violation = Violation.create(rule, resource).setLineId(fbViolation.getStart()).setMessage(fbViolation.getLongMessage());\n        context.saveViolation(violation);\n      }\n    }\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotFailWhenResolvingUnknownClassFromAbsolutePath() throws IOException {\n    List<File> sources = Arrays.asList(newDir(\"source1\"));\n    assertNull(JavaFile.fromAbsolutePath(absPath(\"/home/other/src/main/java/foo/bar/MyClass.java\"), sources, false));\n  }","id":95821,"modified_method":"@Test\n  public void shouldNotFailWhenResolvingUnknownClassFromAbsolutePath() throws IOException {\n    File source1 = newDir(\"source1\");\n    List<File> sources = Arrays.asList(source1);\n    assertNull(JavaFile.fromAbsolutePath(\"/home/other/src/main/java/foo/bar/MyClass.java\", sources, false));\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private File newDir(String relativePath) throws IOException {\n    File target = new File(\"target\", relativePath);\n    FileUtils.forceMkdir(target);\n    FileUtils.cleanDirectory(target);\n    return target;\n  }","id":95822,"modified_method":"private File newDir(String dirName) throws IOException {\n    return tempFolder.newFolder(dirName);\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldResolveClassFromAbsolutePath() throws IOException {\n    List<File> sources = Arrays.asList(newDir(\"source1\"), newDir(\"source2\"));\n    JavaFile javaFile = JavaFile.fromAbsolutePath(absPath(\"source2/foo/bar/MyFile.java\"), sources, false);\n    assertThat(\"foo.bar.MyFile\", is(javaFile.getKey()));\n    assertThat(javaFile.getLongName(), is(\"foo.bar.MyFile\"));\n    assertThat(javaFile.getName(), is(\"MyFile\"));\n    assertThat(javaFile.getParent().getKey(), is(\"foo.bar\"));\n  }","id":95823,"modified_method":"@Test\n  public void shouldResolveClassFromAbsolutePath() throws IOException {\n    File sources1 = newDir(\"source1\");\n    File sources2 = newDir(\"source2\");\n    List<File> sources = Arrays.asList(sources1, sources2);\n    JavaFile javaFile = JavaFile.fromAbsolutePath(absPath(sources2, \"foo/bar/MyFile.java\"), sources, false);\n    assertThat(\"foo.bar.MyFile\", is(javaFile.getKey()));\n    assertThat(javaFile.getLongName(), is(\"foo.bar.MyFile\"));\n    assertThat(javaFile.getName(), is(\"MyFile\"));\n    assertThat(javaFile.getParent().getKey(), is(\"foo.bar\"));\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void oneLevelPackage() throws IOException {\n    JavaFile clazz = new JavaFile(\"onelevel.MyFile\");\n    assertEquals(\"onelevel.MyFile\", clazz.getKey());\n    assertEquals(\"onelevel\", clazz.getParent().getKey());\n\n    clazz = new JavaFile(\"onelevel\", \"MyFile\");\n    assertEquals(\"onelevel.MyFile\", clazz.getKey());\n    assertEquals(\"onelevel\", clazz.getParent().getKey());\n\n    List<File> sources = Arrays.asList(newDir(\"sources\"));\n    JavaFile javaFile = JavaFile.fromAbsolutePath(absPath(\"sources/onelevel/MyFile.java\"), sources, false);\n    assertEquals(\"onelevel.MyFile\", javaFile.getKey());\n    assertEquals(\"MyFile\", javaFile.getName());\n    assertEquals(\"onelevel\", javaFile.getParent().getKey());\n    assertEquals(\"onelevel\", javaFile.getParent().getName());\n    assertThat((javaFile.getParent()).isDefault(), is(false));\n  }","id":95824,"modified_method":"@Test\n  public void oneLevelPackage() throws IOException {\n    JavaFile clazz = new JavaFile(\"onelevel.MyFile\");\n    assertEquals(\"onelevel.MyFile\", clazz.getKey());\n    assertEquals(\"onelevel\", clazz.getParent().getKey());\n\n    clazz = new JavaFile(\"onelevel\", \"MyFile\");\n    assertEquals(\"onelevel.MyFile\", clazz.getKey());\n    assertEquals(\"onelevel\", clazz.getParent().getKey());\n\n    File sourceDir = newDir(\"sources\");\n    List<File> sources = Arrays.asList(sourceDir);\n    JavaFile javaFile = JavaFile.fromAbsolutePath(absPath(sourceDir, \"onelevel/MyFile.java\"), sources, false);\n    assertEquals(\"onelevel.MyFile\", javaFile.getKey());\n    assertEquals(\"MyFile\", javaFile.getName());\n    assertEquals(\"onelevel\", javaFile.getParent().getKey());\n    assertEquals(\"onelevel\", javaFile.getParent().getName());\n    assertThat((javaFile.getParent()).isDefault(), is(false));\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private String absPath(String relativePath) throws IOException {\n    return new File(\"target\", relativePath).getCanonicalPath();\n  }","id":95825,"modified_method":"private String absPath(File dir, String filePath) throws IOException {\n    return new File(dir, filePath).getPath();\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldResolveOnlyJavaFromAbsolutePath() throws IOException {\n    List<File> sources = Arrays.asList(newDir(\"source1\"));\n    assertNull(JavaFile.fromAbsolutePath(absPath(\"source1/foo/bar/my_file.sql\"), sources, false));\n  }","id":95826,"modified_method":"@Test\n  public void shouldResolveOnlyJavaFromAbsolutePath() throws IOException {\n    File source1 = newDir(\"source1\");\n    List<File> sources = Arrays.asList(source1);\n    assertNull(JavaFile.fromAbsolutePath(absPath(source1, \"foo/bar/my_file.sql\"), sources, false));\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldResolveFromAbsolutePathEvenIfDefaultPackage() throws IOException {\n    List<File> sources = Arrays.asList(newDir(\"source1\"), newDir(\"source2\"));\n\n    JavaFile javaClass = JavaFile.fromAbsolutePath(absPath(\"source1/MyClass.java\"), sources, false);\n    assertEquals(JavaPackage.DEFAULT_PACKAGE_NAME + \".MyClass\", javaClass.getKey());\n    assertEquals(\"MyClass\", javaClass.getName());\n\n    assertThat((javaClass.getParent()).isDefault(), is(true));\n  }","id":95827,"modified_method":"@Test\n  public void shouldResolveFromAbsolutePathEvenIfDefaultPackage() throws IOException {\n    File source1 = newDir(\"source1\");\n    File source2 = newDir(\"source2\");\n    List<File> sources = Arrays.asList(source1, source2);\n\n    JavaFile javaClass = JavaFile.fromAbsolutePath(absPath(source1, \"MyClass.java\"), sources, false);\n    assertEquals(JavaPackage.DEFAULT_PACKAGE_NAME + \".MyClass\", javaClass.getKey());\n    assertEquals(\"MyClass\", javaClass.getName());\n\n    assertThat((javaClass.getParent()).isDefault(), is(true));\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void log(Resource resource, Message message) {\n    Object checker = message.getChecker();\n    Check check = getCheck(checker);\n    Violation violation = new Violation(new Rule(check.getRepositoryKey(), check.getTemplateKey()), resource);\n    violation.setLineId(message.getLine());\n    violation.setMessage(message.getText(Locale.ENGLISH));\n    violation.setPriority(RulePriority.fromCheckPriority(check.getPriority()));\n    context.saveViolation(violation);\n  }","id":95828,"modified_method":"public void log(Resource resource, Message message) {\n    Object checker = message.getChecker();\n    Check check = getCheck(checker);\n    Violation violation = Violation.create(new Rule(check.getRepositoryKey(), check.getTemplateKey()), resource);\n    violation.setLineId(message.getLine());\n    violation.setMessage(message.getText(Locale.ENGLISH));\n    violation.setPriority(RulePriority.fromCheckPriority(check.getPriority()));\n    context.saveViolation(violation);\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldSaveViolationsOnClasses() throws URISyntaxException, XMLStreamException {\n    SensorContext context = mock(SensorContext.class);\n    parse(context, \"/org/sonar/plugins/pmd/pmd-result.xml\");\n\n    verify(context, times(30)).saveViolation(argThat(new IsViolationOnJavaClass()));\n    verify(context, times(4)).saveViolation(argThat(new IsViolationOnJavaClass(new JavaFile(\"ch.hortis.sonar.mvn.ClassWithComments\"))));\n\n    Violation wanted = new Violation(null, new JavaFile(\"ch.hortis.sonar.mvn.ClassWithComments\"))\n        .setMessage(\"Avoid unused local variables such as 'toto'.\")\n        .setLineId(22);\n    verify(context, times(1)).saveViolation(argThat(new IsViolation(wanted)));\n  }","id":95829,"modified_method":"@Test\n  public void shouldSaveViolationsOnClasses() throws URISyntaxException, XMLStreamException {\n    SensorContext context = mock(SensorContext.class);\n    parse(context, \"/org/sonar/plugins/pmd/pmd-result.xml\");\n\n    verify(context, times(30)).saveViolation(argThat(new IsViolationOnJavaClass()));\n    verify(context, times(4)).saveViolation(argThat(new IsViolationOnJavaClass(new JavaFile(\"ch.hortis.sonar.mvn.ClassWithComments\"))));\n\n    Violation wanted = Violation.create((Rule)null, new JavaFile(\"ch.hortis.sonar.mvn.ClassWithComments\"))\n        .setMessage(\"Avoid unused local variables such as 'toto'.\")\n        .setLineId(22);\n    verify(context, times(1)).saveViolation(argThat(new IsViolation(wanted)));\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Creates of a violation from a rule. Will need to define the resource later on\n   */\n  public Violation(Rule rule) {\n    this.rule = rule;\n  }","id":95830,"modified_method":"/**\n   * Creates of a violation from a rule. Will need to define the resource later on\n   * @deprecated since 2.3. Use the factory method create()\n   */\n  @Deprecated\n  public Violation(Rule rule) {\n    this.rule = rule;\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Sets the violation priority\n   *\n   * @return the current object\n   */\n  public Violation setPriority(RulePriority priority) {\n    this.priority = priority;\n    return this;\n  }","id":95831,"modified_method":"/**\n   * Sets the violation priority\n   *\n   * @return the current object\n   * @deprecated since 2.3. The priority is set by the quality profile.\n   */\n  @Deprecated\n  public Violation setPriority(RulePriority priority) {\n    this.priority = priority;\n    return this;\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Creates a fully qualified violation\n   *\n   * @param rule the rule that has been violated\n   * @param resource the resource the violation should be attached to\n   */\n  public Violation(Rule rule, Resource resource) {\n    this.resource = resource;\n    this.rule = rule;\n  }","id":95832,"modified_method":"/**\n   * Creates a fully qualified violation\n   *\n   * @param rule the rule that has been violated\n   * @param resource the resource the violation should be attached to\n   * @deprecated since 2.3. Use the factory method create()\n   */\n  @Deprecated\n  public Violation(Rule rule, Resource resource) {\n    this.resource = resource;\n    this.rule = rule;\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<Violation> getViolations(Resource resource, Integer snapshotId) {\n    List<RuleFailureModel> models = session.getResults(RuleFailureModel.class, \"snapshotId\", snapshotId);\n    List<Violation> violations = new ArrayList<Violation>();\n    for (RuleFailureModel model : models) {\n      Violation violation = new Violation(model.getRule(), resource);\n      violation.setLineId(model.getLine());\n      violation.setMessage(model.getMessage());\n      violation.setPriority(model.getPriority());\n      violation.setCost(model.getCost());\n      violations.add(violation);\n    }\n    return violations;\n  }","id":95833,"modified_method":"public List<Violation> getViolations(Resource resource, Integer snapshotId) {\n    List<RuleFailureModel> models = session.getResults(RuleFailureModel.class, \"snapshotId\", snapshotId);\n    List<Violation> violations = new ArrayList<Violation>();\n    for (RuleFailureModel model : models) {\n      Violation violation = Violation.create(model.getRule(), resource);\n      violation.setLineId(model.getLine());\n      violation.setMessage(model.getMessage());\n      violation.setPriority(model.getPriority());\n      violation.setCost(model.getCost());\n      violations.add(violation);\n    }\n    return violations;\n  }","commit_id":"1dfd7034c4cb735683949cef50a8e3809bab6a35","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"TagMenu() {\n            super(getActionDisplayName());\n\n            // Get the current set of tag names.\n            TagsManager tagsManager = Case.getCurrentCase().getServices().getTagsManager();\n            List<TagName> tagNames = null;\n            try {\n                Set<TagName> tagNamesSet = new TreeSet<>();\n                tagNamesSet.addAll(tagsManager.getUserTagNames());\n                tagNamesSet.addAll(tagsManager.getTagNamesInUse());\n                tagNamesSet.addAll(tagsManager.getPredefinedTagNames());\n                tagNames = new ArrayList(tagNamesSet);\n            } catch (TskCoreException ex) {\n                Logger.getLogger(TagsManager.class.getName()).log(Level.SEVERE, \"Failed to get tag names\", ex); //NON-NLS\n            }\n\n            // Create a \"Quick Tag\" sub-menu.\n            JMenu quickTagMenu = new JMenu(NbBundle.getMessage(this.getClass(), \"AddTagAction.quickTag\"));\n            add(quickTagMenu);\n\n            // Each tag name in the current set of tags gets its own menu item in\n            // the \"Quick Tags\" sub-menu. Selecting one of these menu items adds\n            // a tag with the associated tag name. \n            if (null != tagNames && !tagNames.isEmpty()) {\n                for (final TagName tagName : tagNames) {\n                    JMenuItem tagNameItem = new JMenuItem(tagName.getDisplayName());\n                    tagNameItem.addActionListener((ActionEvent e) -> {\n                        addTag(tagName, NO_COMMENT);\n                    });\n                    quickTagMenu.add(tagNameItem);\n                }\n            } else {\n                JMenuItem empty = new JMenuItem(NbBundle.getMessage(this.getClass(), \"AddTagAction.noTags\"));\n                empty.setEnabled(false);\n                quickTagMenu.add(empty);\n            }\n\n            quickTagMenu.addSeparator();\n\n            // The \"Quick Tag\" menu also gets an \"Choose Tag...\" menu item.\n            // Selecting this item initiates a dialog that can be used to create\n            // or select a tag name and adds a tag with the resulting name.\n            JMenuItem newTagMenuItem = new JMenuItem(NbBundle.getMessage(this.getClass(), \"AddTagAction.newTag\"));\n            newTagMenuItem.addActionListener((ActionEvent e) -> {\n                TagName tagName = GetTagNameDialog.doDialog();\n                if (null != tagName) {\n                    addTag(tagName, NO_COMMENT);\n                }\n            });\n            quickTagMenu.add(newTagMenuItem);\n\n            // Create a \"Choose Tag and Comment...\" menu item. Selecting this item initiates\n            // a dialog that can be used to create or select a tag name with an \n            // optional comment and adds a tag with the resulting name.\n            JMenuItem tagAndCommentItem = new JMenuItem(\n                    NbBundle.getMessage(this.getClass(), \"AddTagAction.tagAndComment\"));\n            tagAndCommentItem.addActionListener((ActionEvent e) -> {\n                GetTagNameAndCommentDialog.TagNameAndComment tagNameAndComment = GetTagNameAndCommentDialog.doDialog();\n                if (null != tagNameAndComment) {\n                    addTag(tagNameAndComment.getTagName(), tagNameAndComment.getComment());\n                }\n            });\n            add(tagAndCommentItem);\n        }","id":95834,"modified_method":"TagMenu() {\n            super(getActionDisplayName());\n\n            // Get the current set of tag names.\n            TagsManager tagsManager = Case.getCurrentCase().getServices().getTagsManager();\n            Map<String, TagName> tagNamesMap = null;\n            try {\n                tagNamesMap = new TreeMap<>();\n                tagNamesMap.putAll(tagsManager.getUserTagNamesMap());\n                tagNamesMap.putAll(tagsManager.getPredefinedTagNamesMap());\n                tagNamesMap.putAll(tagsManager.getTagNamesInUseMap());\n            } catch (TskCoreException ex) {\n                Logger.getLogger(TagsManager.class.getName()).log(Level.SEVERE, \"Failed to get tag names\", ex); //NON-NLS\n            }\n\n            // Create a \"Quick Tag\" sub-menu.\n            JMenu quickTagMenu = new JMenu(NbBundle.getMessage(this.getClass(), \"AddTagAction.quickTag\"));\n            add(quickTagMenu);\n\n            // Each tag name in the current set of tags gets its own menu item in\n            // the \"Quick Tags\" sub-menu. Selecting one of these menu items adds\n            // a tag with the associated tag name. \n            if (null != tagNamesMap && !tagNamesMap.isEmpty()) {\n                for (Map.Entry<String, TagName> entry : tagNamesMap.entrySet()) {\n                    JMenuItem tagNameItem = new JMenuItem(entry.getKey());\n                    tagNameItem.addActionListener((ActionEvent e) -> {\n                        getAndAddTag(entry.getKey(), entry.getValue(), NO_COMMENT);\n                    });\n                    quickTagMenu.add(tagNameItem);\n                }\n            } else {\n                JMenuItem empty = new JMenuItem(NbBundle.getMessage(this.getClass(), \"AddTagAction.noTags\"));\n                empty.setEnabled(false);\n                quickTagMenu.add(empty);\n             }\n\n            quickTagMenu.addSeparator();\n\n            // The \"Quick Tag\" menu also gets an \"Choose Tag...\" menu item.\n            // Selecting this item initiates a dialog that can be used to create\n            // or select a tag name and adds a tag with the resulting name.\n            JMenuItem newTagMenuItem = new JMenuItem(NbBundle.getMessage(this.getClass(), \"AddTagAction.newTag\"));\n            newTagMenuItem.addActionListener((ActionEvent e) -> {\n                TagName tagName = GetTagNameDialog.doDialog();\n                if (null != tagName) {\n                    addTag(tagName, NO_COMMENT);\n                }\n            });\n            quickTagMenu.add(newTagMenuItem);\n\n            // Create a \"Choose Tag and Comment...\" menu item. Selecting this item initiates\n            // a dialog that can be used to create or select a tag name with an \n            // optional comment and adds a tag with the resulting name.\n            JMenuItem tagAndCommentItem = new JMenuItem(\n                    NbBundle.getMessage(this.getClass(), \"AddTagAction.tagAndComment\"));\n            tagAndCommentItem.addActionListener((ActionEvent e) -> {\n                GetTagNameAndCommentDialog.TagNameAndComment tagNameAndComment = GetTagNameAndCommentDialog.doDialog();\n                if (null != tagNameAndComment) {\n                    addTag(tagNameAndComment.getTagName(), tagNameAndComment.getComment());\n                }\n            });\n            add(tagAndCommentItem);\n        }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void newTagButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newTagButtonActionPerformed\n        TagName newTagName = GetTagNameDialog.doDialog(this);\n        if (newTagName != null) {\n            tagNames.put(newTagName.getDisplayName(), newTagName);\n            tagCombo.addItem(newTagName.getDisplayName());\n            tagCombo.setSelectedItem(newTagName.getDisplayName());\n        }\n    }","id":95835,"modified_method":"private void newTagButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newTagButtonActionPerformed\n        TagName newTagName = GetTagNameDialog.doDialog(this);\n        if (newTagName != null) {\n            tagNamesMap.put(newTagName.getDisplayName(), newTagName);\n            tagCombo.addItem(newTagName.getDisplayName());\n            tagCombo.setSelectedItem(newTagName.getDisplayName());\n        }\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private GetTagNameAndCommentDialog(Window owner) {\n        super(owner,\n                NbBundle.getMessage(GetTagNameAndCommentDialog.class, \"GetTagNameAndCommentDialog.createTag\"),\n                ModalityType.APPLICATION_MODAL);\n        initComponents();\n\n        // Set up the dialog to close when Esc is pressed.\n        String cancelName = NbBundle.getMessage(this.getClass(), \"GetTagNameAndCommentDialog.cancelName\");\n        InputMap inputMap = getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), cancelName);\n        ActionMap actionMap = getRootPane().getActionMap();\n        actionMap.put(cancelName, new AbstractAction() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                dispose();\n            }\n        });\n\n        // Populate the combo box with the available tag names and save the \n        // tag name DTOs to be enable to return the one the user selects.\n        TagsManager tagsManager = Case.getCurrentCase().getServices().getTagsManager();\n        List<TagName> currentTagNames = null;\n        try {\n            Set<TagName> tagNamesSet = new TreeSet<>();\n            tagNamesSet.addAll(tagsManager.getUserTagNames());\n            tagNamesSet.addAll(tagsManager.getTagNamesInUse());\n            tagNamesSet.addAll(tagsManager.getPredefinedTagNames());\n            currentTagNames = new ArrayList(tagNamesSet);\n        } catch (TskCoreException ex) {\n            Logger.getLogger(GetTagNameAndCommentDialog.class.getName()).log(Level.SEVERE, \"Failed to get tag names\", ex); //NON-NLS\n        }\n        if (null != currentTagNames && currentTagNames.isEmpty()) {\n            tagCombo.addItem(NO_TAG_NAMES_MESSAGE);\n        } else {\n            for (TagName tagName : currentTagNames) {\n                tagNames.put(tagName.getDisplayName(), tagName);\n                tagCombo.addItem(tagName.getDisplayName());\n            }\n        }\n\n        // Center and show the dialog box. \n        this.setLocationRelativeTo(WindowManager.getDefault().getMainWindow());\n        setVisible(true);\n    }","id":95836,"modified_method":"private GetTagNameAndCommentDialog(Window owner) {\n        super(owner,\n                NbBundle.getMessage(GetTagNameAndCommentDialog.class, \"GetTagNameAndCommentDialog.createTag\"),\n                ModalityType.APPLICATION_MODAL);\n        initComponents();\n\n        // Set up the dialog to close when Esc is pressed.\n        String cancelName = NbBundle.getMessage(this.getClass(), \"GetTagNameAndCommentDialog.cancelName\");\n        InputMap inputMap = getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), cancelName);\n        ActionMap actionMap = getRootPane().getActionMap();\n        actionMap.put(cancelName, new AbstractAction() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                dispose();\n            }\n        });\n\n        // Populate the combo box with the available tag names and save the \n        // tag name DTOs to be enable to return the one the user selects.\n        // Tag name DTOs may be null (user tag names that have not been used do\n        // not exist in the database).\n        TagsManager tagsManager = Case.getCurrentCase().getServices().getTagsManager();\n        try {\n            tagNamesMap.putAll(tagsManager.getUserTagNamesMap());\n            tagNamesMap.putAll(tagsManager.getPredefinedTagNamesMap());\n            tagNamesMap.putAll(tagsManager.getTagNamesInUseMap());\n        } catch (TskCoreException ex) {\n            Logger.getLogger(GetTagNameAndCommentDialog.class.getName()).log(Level.SEVERE, \"Failed to get tag names\", ex); //NON-NLS\n        }\n        if (null != tagNamesMap && tagNamesMap.isEmpty()) {\n            tagCombo.addItem(NO_TAG_NAMES_MESSAGE);\n        } else {\n            for (String tagDisplayName : tagNamesMap.keySet()) {\n                tagCombo.addItem(tagDisplayName);\n            }\n        }\n\n        // Center and show the dialog box. \n        this.setLocationRelativeTo(WindowManager.getDefault().getMainWindow());\n        setVisible(true);\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed\n        tagNameAndComment = new TagNameAndComment(tagNames.get((String) tagCombo.getSelectedItem()), commentText.getText());\n        dispose();\n    }","id":95837,"modified_method":"private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed\n        String tagDisplayName = (String) tagCombo.getSelectedItem();\n        TagName tagNameFromCombo = tagNamesMap.get(tagDisplayName);\n        if (tagNameFromCombo == null) {\n            try {\n                tagNameFromCombo = Case.getCurrentCase().getServices().getTagsManager().addTagName(tagDisplayName);\n            } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                Logger.getLogger(AddTagAction.class.getName()).log(Level.SEVERE, tagDisplayName + \" already exists in database.\", ex); //NON-NLS\n            } catch (TskCoreException ex) {\n                Logger.getLogger(AddTagAction.class.getName()).log(Level.SEVERE, \"Error adding \" + tagDisplayName + \" tag name\", ex); //NON-NLS\n            }\n        }\n        tagNameAndComment = new TagNameAndComment(tagNameFromCombo, commentText.getText());\n        dispose();\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed\n        String tagDisplayName = tagNameField.getText();\n        if (tagDisplayName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(this.getClass(),\n                            \"GetTagNameDialog.mustSupplyTtagName.msg\"),\n                    NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.tagNameErr\"),\n                    JOptionPane.ERROR_MESSAGE);\n        } else if (TagsManager.containsIllegalCharacters(tagDisplayName)) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.illegalChars.msg\"),\n                    NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.illegalCharsErr\"),\n                    JOptionPane.ERROR_MESSAGE);\n        } else {\n            tagName = tagNames.get(tagDisplayName);\n            if (tagName == null) {\n                try {\n                    tagName = Case.getCurrentCase().getServices().getTagsManager().addTagName(tagDisplayName);\n                    dispose();\n                } catch (TskCoreException ex) {\n                    Logger.getLogger(AddTagAction.class.getName()).log(Level.SEVERE, \"Error adding \" + tagDisplayName + \" tag name\", ex); //NON-NLS\n                    JOptionPane.showMessageDialog(null,\n                            NbBundle.getMessage(this.getClass(),\n                                    \"GetTagNameDialog.unableToAddTagNameToCase.msg\",\n                                    tagDisplayName),\n                            NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.taggingErr\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    tagName = null;\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    Logger.getLogger(AddTagAction.class.getName()).log(Level.SEVERE, \"Error adding \" + tagDisplayName + \" tag name\", ex); //NON-NLS\n                    JOptionPane.showMessageDialog(null,\n                            NbBundle.getMessage(this.getClass(),\n                                    \"GetTagNameDialog.tagNameAlreadyDef.msg\",\n                                    tagDisplayName),\n                            NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.dupTagErr\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    tagName = null;\n                }\n            } else {\n                dispose();\n            }\n        }\n    }","id":95838,"modified_method":"private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed\n        String tagDisplayName = tagNameField.getText();\n        if (tagDisplayName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(this.getClass(),\n                            \"GetTagNameDialog.mustSupplyTtagName.msg\"),\n                    NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.tagNameErr\"),\n                    JOptionPane.ERROR_MESSAGE);\n        } else if (TagsManager.containsIllegalCharacters(tagDisplayName)) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.illegalChars.msg\"),\n                    NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.illegalCharsErr\"),\n                    JOptionPane.ERROR_MESSAGE);\n        } else {\n            tagName = tagNamesMap.get(tagDisplayName);\n            if (tagName == null) {\n                try {\n                    tagName = Case.getCurrentCase().getServices().getTagsManager().addTagName(tagDisplayName);\n                    dispose();\n                } catch (TskCoreException ex) {\n                    Logger.getLogger(AddTagAction.class.getName()).log(Level.SEVERE, \"Error adding \" + tagDisplayName + \" tag name\", ex); //NON-NLS\n                    JOptionPane.showMessageDialog(null,\n                            NbBundle.getMessage(this.getClass(),\n                                    \"GetTagNameDialog.unableToAddTagNameToCase.msg\",\n                                    tagDisplayName),\n                            NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.taggingErr\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    tagName = null;\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    Logger.getLogger(AddTagAction.class.getName()).log(Level.SEVERE, tagDisplayName + \" already exists in database.\", ex); //NON-NLS\n                    JOptionPane.showMessageDialog(null,\n                            NbBundle.getMessage(this.getClass(),\n                                    \"GetTagNameDialog.tagNameAlreadyDef.msg\",\n                                    tagDisplayName),\n                            NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.dupTagErr\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    tagName = null;\n                }\n            } else {\n                dispose();\n            }\n        }\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public String getValueAt(int rowIndex, int columnIndex) {\n            return tagNames.get(rowIndex).getDisplayName();\n        }","id":95839,"modified_method":"@Override\n        public String getValueAt(int rowIndex, int columnIndex) {\n            return tagDisplayNames.get(rowIndex);\n        }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private GetTagNameDialog(final Window owner) {\n        super(owner,\n                NbBundle.getMessage(GetTagNameDialog.class, \"GetTagNameDialog.createTag\"),\n                ModalityType.APPLICATION_MODAL);\n        setIconImage(ImageUtilities.loadImage(TAG_ICON_PATH));\n        initComponents();\n\n        // Set up the dialog to close when Esc is pressed.\n        String cancelName = NbBundle.getMessage(this.getClass(), \"GetTagNameDialog.cancelName\");\n        InputMap inputMap = getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), cancelName);\n        ActionMap actionMap = getRootPane().getActionMap();\n        actionMap.put(cancelName, new AbstractAction() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                cancelButtonActionPerformed(e);\n            }\n        });\n\n        // Get the current set of tag names and hash them for a speedy lookup in\n        // case the user chooses an existing tag name from the tag names table.\n        TagsManager tagsManager = Case.getCurrentCase().getServices().getTagsManager();\n        List<TagName> currentTagNames = null;\n        try {\n            Set<TagName> tagNamesSet = new TreeSet<>();\n            tagNamesSet.addAll(tagsManager.getUserTagNames());\n            tagNamesSet.addAll(tagsManager.getTagNamesInUse());\n            tagNamesSet.addAll(tagsManager.getPredefinedTagNames());\n            currentTagNames = new ArrayList(tagNamesSet);\n        } catch (TskCoreException ex) {\n            Logger.getLogger(GetTagNameDialog.class.getName()).log(Level.SEVERE, \"Failed to get tag names\", ex); //NON-NLS\n        }\n        if (null != currentTagNames) {\n            for (TagName name : currentTagNames) {\n                this.tagNames.put(name.getDisplayName(), name);\n            }\n        } else {\n            currentTagNames = new ArrayList<>();\n        }\n\n        // Populate the tag names table.\n        tagsTable.setModel(new TagsTableModel(currentTagNames));\n        tagsTable.setTableHeader(null);\n        tagsTable.setCellSelectionEnabled(false);\n        tagsTable.setFocusable(false);\n        tagsTable.setRowHeight(tagsTable.getRowHeight() + 5);\n\n        // Center and show the dialog box. \n        this.setLocationRelativeTo(owner);\n        setVisible(true);\n    }","id":95840,"modified_method":"TagsTableModel(List<String> tagDisplayNames) {\n            for (String tagDisplayName : tagDisplayNames) {\n                this.tagDisplayNames.add(tagDisplayName);\n            }\n        }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public int getRowCount() {\n            return tagNames.size();\n        }","id":95841,"modified_method":"@Override\n        public int getRowCount() {\n            return tagDisplayNames.size();\n        }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Updates the tag names model for the tag names list component.\n     */\n    private void updateTagNamesListModel() {\n        tagNamesListModel.clear();\n        Collections.sort(tagNames);\n        for (UserTagName tagName : tagNames) {\n            tagNamesListModel.addElement(tagName);\n        }\n    }","id":95842,"modified_method":"/**\n     * Updates the tag names model for the tag names list component.\n     */\n    private void updateTagNamesListModel() {\n        tagNamesListModel.clear();\n        Set<UserTagName> tagNameSet = new HashSet<>();\n        tagNameSet.addAll(tagNames);\n        tagNames.clear();\n        tagNames.addAll(tagNameSet);\n        Collections.sort(tagNames);\n        for (UserTagName tagName : tagNames) {\n            tagNamesListModel.addElement(tagName);\n        }\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Checks whether a tag name with a given display name exists.\n     *\n     * @param tagDisplayName The display name to check.\n     *\n     * @return True or false.\n     */\n    public synchronized boolean tagNameExists(String tagDisplayName) {\n        lazyLoadExistingTagNames();\n        return uniqueTagNames.containsKey(tagDisplayName);\n    }","id":95843,"modified_method":"/**\n     * Checks whether a tag name with a given display name exists.\n     *\n     * @param tagDisplayName The display name to check.\n     *\n     * @return True or false.\n     */\n    public synchronized boolean tagNameExists(String tagDisplayName) {\n        lazyLoadExistingTagNames();\n        return uniqueTagNames.containsKey(tagDisplayName) &&\n                (uniqueTagNames.get(tagDisplayName) != null);\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Adds any user defined tag name to the case db and also to uniqueTagNames,\n     * to allow user tag names to be displayed while tagging.\n     *\n     * @param userTagNames a List of UserTagName objects to be potentially added\n     */\n    void storeNewUserTagNames(List<UserTagName> userTagNames) {\n        lazyLoadExistingTagNames();\n        for (UserTagName utn : userTagNames) {\n            if (!uniqueTagNames.containsKey(utn.getDisplayName())) {\n                try {\n                    TagName tagName = caseDb.addTagName(utn.getDisplayName(), utn.getDescription(), TagName.HTML_COLOR.getColorByName(utn.getColorName()));\n                    uniqueTagNames.put(tagName.getDisplayName(), tagName);\n                } catch (TskCoreException ex) {\n                    Logger.getLogger(TagsManager.class.getName()).log(Level.SEVERE, \"Failed to add saved tag name \" + utn.getDisplayName(), ex); //NON-NLS\n                }\n            }\n        }\n    }","id":95844,"modified_method":"/**\n     * Adds any user defined tag name to the case db and also to uniqueTagNames,\n     * to allow user tag names to be displayed while tagging.\n     *\n     * @param userTagNames a List of UserTagName objects to be potentially added\n     */\n    void storeNewUserTagNames(List<UserTagName> userTagNames) {\n        lazyLoadExistingTagNames();\n        for (UserTagName utn : userTagNames) {\n            if (!uniqueTagNames.containsKey(utn.getDisplayName())) {\n                uniqueTagNames.put(utn.getDisplayName(), null);\n            }\n        }\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets a list of all predefined tag names.\n     * \n     * @return A list of TagName data transfer objects (DTOs).\n     */\n    public synchronized List<TagName> getPredefinedTagNames() {\n        lazyLoadExistingTagNames();\n        List<TagName> tagNameList = new ArrayList<>();\n        tagNameList.add(uniqueTagNames.get(NbBundle.getMessage(this.getClass(), \"TagsManager.predefTagNames.bookmark.text\")));\n        return tagNameList;\n    }","id":95845,"modified_method":"/**\n     * Gets a mapping of predefined tag names to their TagName DTOs. Currently\n     * only for the bookmark tag.\n     * \n     * @return A map of String display name to TagName DTO\n     */\n    public synchronized Map<String, TagName> getPredefinedTagNamesMap() {\n        Map<String, TagName> tagNamesMap = new HashMap<>();\n        TagName bookmarkTagName = uniqueTagNames.get(NbBundle.getMessage(this.getClass(), \"TagsManager.predefTagNames.bookmark.text\"));\n        tagNamesMap.put(NbBundle.getMessage(this.getClass(), \"TagsManager.predefTagNames.bookmark.text\"), bookmarkTagName);\n        return tagNamesMap;\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Adds a new tag name to the current case and to the tags settings.\n     *\n     * @param displayName The display name for the new tag name.\n     * @param description The description for the new tag name.\n     * @param color       The HTML color to associate with the new tag name.\n     *\n     * @return A TagName data transfer object (DTO) representing the new tag\n     *         name.\n     *\n     * @throws TagNameAlreadyExistsException If the tag name would be a\n     *                                       duplicate.\n     * @throws TskCoreException              If there is an error adding the tag\n     *                                       to the case database.\n     */\n    public synchronized TagName addTagName(String displayName, String description, TagName.HTML_COLOR color) throws TagNameAlreadyExistsException, TskCoreException {\n        if (null == caseDb) {\n            throw new TskCoreException(\"Tags manager has been closed\");\n        }\n\n        lazyLoadExistingTagNames();\n\n        /*\n         * It is possible user is trying to add back a tag after having deleted\n         * it.\n         */\n        if (uniqueTagNames.containsKey(displayName)) {\n            TagName existingTagName = uniqueTagNames.get(displayName);\n            long count = getContentTagsCountByTagName(existingTagName) + getBlackboardArtifactTagsCountByTagName(existingTagName);\n            if (count == 0) {\n                addNewTagNameToTagsSettings(existingTagName);\n                return existingTagName;\n            } else {\n                throw new TagNameAlreadyExistsException();\n            }\n        }\n\n        /*\n         * Add the tag name to the case.\n         */\n        TagName newTagName = caseDb.addTagName(displayName, description, color);\n        uniqueTagNames.put(newTagName.getDisplayName(), newTagName);\n\n        /*\n         * Add the tag name to the tags settings.\n         */\n        addNewTagNameToTagsSettings(newTagName);\n\n        return newTagName;\n    }","id":95846,"modified_method":"/**\n     * Adds a new tag name to the current case and to the tags settings.\n     *\n     * @param displayName The display name for the new tag name.\n     * @param description The description for the new tag name.\n     * @param color       The HTML color to associate with the new tag name.\n     *\n     * @return A TagName data transfer object (DTO) representing the new tag\n     *         name.\n     *\n     * @throws TagNameAlreadyExistsException If the tag name would be a\n     *                                       duplicate.\n     * @throws TskCoreException              If there is an error adding the tag\n     *                                       to the case database.\n     */\n    public synchronized TagName addTagName(String displayName, String description, TagName.HTML_COLOR color) throws TagNameAlreadyExistsException, TskCoreException {\n        if (null == caseDb) {\n            throw new TskCoreException(\"Tags manager has been closed\");\n        }\n\n        lazyLoadExistingTagNames();\n        \n        /*\n         * It is possible user is trying to add back a tag after having deleted\n         * it. It is also possible a user tag name was never added to the\n         * database.\n         */\n        if (uniqueTagNames.containsKey(displayName)) {\n            if (uniqueTagNames.get(displayName) != null) {\n                TagName existingTagName = uniqueTagNames.get(displayName);\n                long count = getContentTagsCountByTagName(existingTagName) + getBlackboardArtifactTagsCountByTagName(existingTagName);\n                if (count == 0) {\n                    addNewTagNameToTagsSettings(existingTagName);\n                    return existingTagName;\n                } else {\n                    throw new TagNameAlreadyExistsException();\n                }\n            }\n        }\n        \n        TagName newTagName = caseDb.addTagName(displayName, description, color);\n        uniqueTagNames.put(newTagName.getDisplayName(), newTagName);\n\n        addNewTagNameToTagsSettings(newTagName);\n\n        return newTagName;\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Adds any tag names that are in the properties file to the tag names\n     * collection and to the case database. The properties file is used to make\n     * it possible to use tag names across cases.\n     */\n    private void addTagNamesFromTagsSettings() {\n        String setting = ModuleSettings.getConfigSetting(TAGS_SETTINGS_NAME, TAG_NAMES_SETTING_KEY);\n        if (null != setting && !setting.isEmpty()) {\n            // Read the tag name setting and break it into tag name tuples.\n            List<String> tagNameTuples = Arrays.asList(setting.split(\";\"));\n\n            // Parse each tuple and add the tag names to the current case, one\n            // at a time to gracefully discard any duplicates or corrupt tuples.\n            for (String tagNameTuple : tagNameTuples) {\n                String[] tagNameAttributes = tagNameTuple.split(\",\");\n                if (!uniqueTagNames.containsKey(tagNameAttributes[0])) {\n                    try {\n                        TagName tagName = caseDb.addTagName(tagNameAttributes[0], tagNameAttributes[1], TagName.HTML_COLOR.getColorByName(tagNameAttributes[2]));\n                        uniqueTagNames.put(tagName.getDisplayName(), tagName);\n                    } catch (TskCoreException ex) {\n                        Logger.getLogger(TagsManager.class.getName()).log(Level.SEVERE, \"Failed to add saved tag name \" + tagNameAttributes[0], ex); //NON-NLS\n                    }\n                }\n            }\n        }\n    }","id":95847,"modified_method":"/**\n     * Adds any tag names that are in the properties file to the tag names\n     * collection and to the case database. The properties file is used to make\n     * it possible to use tag names across cases.\n     */\n    private void addTagNamesFromTagsSettings() {\n        String setting = ModuleSettings.getConfigSetting(TAGS_SETTINGS_NAME, TAG_NAMES_SETTING_KEY);\n        if (null != setting && !setting.isEmpty()) {\n            // Read the tag name setting and break it into tag name tuples.\n            List<String> tagNameTuples = Arrays.asList(setting.split(\";\"));\n\n            // Parse each tuple and add the tag names to the current case, one\n            // at a time to gracefully discard any duplicates or corrupt tuples.\n            for (String tagNameTuple : tagNameTuples) {\n                String[] tagNameAttributes = tagNameTuple.split(\",\");\n                if (!uniqueTagNames.containsKey(tagNameAttributes[0])) {\n                    uniqueTagNames.put(tagNameAttributes[0], null);\n                }\n            }\n        }\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets a list of all user tag names from the preference file.\n     *\n     * @return A list, possibly empty, of TagName data transfer objects (DTOs).\n     */\n    public synchronized List<TagName> getUserTagNames() {\n        lazyLoadExistingTagNames();\n        List<TagName> tagNameList = new ArrayList<>();\n        String setting = ModuleSettings.getConfigSetting(TAGS_SETTINGS_NAME, TAG_NAMES_SETTING_KEY);\n        if (null != setting && !setting.isEmpty()) {\n            List<String> tagNameTuples = Arrays.asList(setting.split(\";\"));\n            for (String tagNameTuple : tagNameTuples) {\n                String[] tagNameAttributes = tagNameTuple.split(\",\");\n                tagNameList.add(uniqueTagNames.get(tagNameAttributes[0]));\n            }\n        }\n        return tagNameList;\n    }","id":95848,"modified_method":"/**\n     * Gets a mapping of user tag name display names to TagName DTOs if they\n     * have been added to the database. Otherwise, the display name maps to\n     * null.\n     *\n     * @return A map of String display name to TagName DTO, TagName may be null\n     */\n    public synchronized Map<String, TagName> getUserTagNamesMap() {\n        lazyLoadExistingTagNames();\n        Map<String, TagName> tagNamesMap = new HashMap<>();\n        String setting = ModuleSettings.getConfigSetting(TAGS_SETTINGS_NAME, TAG_NAMES_SETTING_KEY);\n        if (null != setting && !setting.isEmpty()) {\n            List<String> tagNameTuples = Arrays.asList(setting.split(\";\"));\n            for (String tagNameTuple : tagNameTuples) {\n                String[] tagNameAttributes = tagNameTuple.split(\",\");\n                tagNamesMap.put(tagNameAttributes[0], uniqueTagNames.get(tagNameAttributes[0]));\n            }\n        }\n        return tagNamesMap;\n    }","commit_id":"b7f227b76ccb8b17874bf0e04524a82d6016bc68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static Node childNodeNamed(Node root, String name) {\n        for (Node child : Cast.<List<Node>>uncheckedCast(root.children())) {\n            if (localNameOf(child).equals(name)) {\n                return child;\n            }\n        }\n        return null;\n    }","id":95849,"modified_method":"private static String childNodeText(Node root, String name) {\n        for (Node child : Cast.<List<Node>>uncheckedCast(root.children())) {\n            if (localNameOf(child).equals(name)) {\n                return child.text();\n            }\n        }\n        return null;\n    }","commit_id":"304beb51fa6749001fb918ed0187128d28efa316","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public DeploymentDescriptor readFrom(Reader reader) {\n        try {\n            Node appNode = createParser().parse(reader);\n            version = (String) appNode.attribute(\"version\");\n            for (final Node child : Cast.<List<Node>>uncheckedCast(appNode.children())) {\n                String childLocalName = localNameOf(child);\n                if (childLocalName.equals(\"application-name\")) {\n\n                    applicationName = child.text();\n\n                } else if (childLocalName.equals(\"initialize-in-order\")) {\n\n                    initializeInOrder = Boolean.valueOf(child.text());\n\n                } else if (childLocalName.equals(\"description\")) {\n\n                    description = child.text();\n\n                } else if (childLocalName.equals(\"display-name\")) {\n\n                    displayName = child.text();\n\n                } else if (childLocalName.equals(\"library-directory\")) {\n\n                    libraryDirectory = child.text();\n\n                } else if (childLocalName.equals(\"module\")) {\n\n                    EarModule module = null;\n                    for (Node moduleNode : Cast.<List<Node>>uncheckedCast(child.children())) {\n                        String moduleNodeLocalName = localNameOf(moduleNode);\n                        if (moduleNodeLocalName.equals(\"web\")) {\n                            Node webUriNode = childNodeNamed(moduleNode, \"web-uri\");\n                            Node contextRootNode = childNodeNamed(moduleNode, \"context-root\");\n                            String webUri = webUriNode != null ? webUriNode.text() : null;\n                            String contextRoot = contextRootNode != null ? contextRootNode.text() : null;\n                            module = new DefaultEarWebModule(webUri, contextRoot);\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), \"web\");\n                        } else if (moduleNodeLocalName.equals(\"alt-dd\")) {\n                            assert module != null;\n                            module.setAltDeployDescriptor(moduleNode.text());\n                        } else {\n                            module = new DefaultEarModule(moduleNode.text());\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), moduleNodeLocalName);\n                        }\n                    }\n\n                } else if (childLocalName.equals(\"security-role\")) {\n\n                    Node roleNameNode = childNodeNamed(child, \"role-name\");\n                    Node descriptionNode = childNodeNamed(child, \"description\");\n                    String roleName = roleNameNode != null ? roleNameNode.text() : null;\n                    String description = descriptionNode != null ? descriptionNode.text() : null;\n                    securityRoles.add(new DefaultEarSecurityRole(roleName, description));\n\n                } else {\n                    withXml(new Action<XmlProvider>() {\n                        @Override\n                        public void execute(XmlProvider xmlProvider) {\n                            xmlProvider.asNode().append(child);\n                        }\n                    });\n                }\n            }\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        } catch (SAXException ex) {\n            throw new UncheckedException(ex);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        return this;\n    }","id":95850,"modified_method":"@Override\n    public DeploymentDescriptor readFrom(Reader reader) {\n        try {\n            Node appNode = createParser().parse(reader);\n            version = (String) appNode.attribute(\"version\");\n            for (final Node child : Cast.<List<Node>>uncheckedCast(appNode.children())) {\n                String childLocalName = localNameOf(child);\n                if (childLocalName.equals(\"application-name\")) {\n\n                    applicationName = child.text();\n\n                } else if (childLocalName.equals(\"initialize-in-order\")) {\n\n                    initializeInOrder = Boolean.valueOf(child.text());\n\n                } else if (childLocalName.equals(\"description\")) {\n\n                    description = child.text();\n\n                } else if (childLocalName.equals(\"display-name\")) {\n\n                    displayName = child.text();\n\n                } else if (childLocalName.equals(\"library-directory\")) {\n\n                    libraryDirectory = child.text();\n\n                } else if (childLocalName.equals(\"module\")) {\n\n                    EarModule module = null;\n                    for (Node moduleNode : Cast.<List<Node>>uncheckedCast(child.children())) {\n                        String moduleNodeLocalName = localNameOf(moduleNode);\n                        if (moduleNodeLocalName.equals(\"web\")) {\n                            String webUri = childNodeText(moduleNode, \"web-uri\");\n                            String contextRoot = childNodeText(moduleNode, \"context-root\");\n                            module = new DefaultEarWebModule(webUri, contextRoot);\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), \"web\");\n                        } else if (moduleNodeLocalName.equals(\"alt-dd\")) {\n                            assert module != null;\n                            module.setAltDeployDescriptor(moduleNode.text());\n                        } else {\n                            module = new DefaultEarModule(moduleNode.text());\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), moduleNodeLocalName);\n                        }\n                    }\n\n                } else if (childLocalName.equals(\"security-role\")) {\n\n                    String roleName = childNodeText(child, \"role-name\");\n                    String description = childNodeText(child, \"description\");\n                    securityRoles.add(new DefaultEarSecurityRole(roleName, description));\n\n                } else {\n                    withXml(new Action<XmlProvider>() {\n                        @Override\n                        public void execute(XmlProvider xmlProvider) {\n                            xmlProvider.asNode().append(child);\n                        }\n                    });\n                }\n            }\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        } catch (SAXException ex) {\n            throw new UncheckedException(ex);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        return this;\n    }","commit_id":"304beb51fa6749001fb918ed0187128d28efa316","url":"https://github.com/gradle/gradle"},{"original_method":"public void handlePost(URI uri, Bucket data, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\t\n\t\tif(data.size() > 1024*1024) {\n\t\t\tthis.writeReply(ctx, 400, \"text/plain\", \"Too big\", \"Data exceeds 1MB limit\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTTPRequest request = new HTTPRequest(uri,data,ctx);\n\n\t\tString passwd = request.getPartAsString(\"formPassword\", 32);\n\t\tif((passwd == null) || !passwd.equals(core.formPassword)) {\n\t\t\tMultiValueTable headers = new MultiValueTable();\n\t\t\theaders.put(\"Location\", \"/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"No password (\"+passwd+\" should be \"+core.formPassword+\")\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(request.getPartAsString(\"updateconfirm\", 32).length() > 0){\n\t\t\t// false for no navigation bars, because that would be very silly\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node updating\");\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-information\", \"Node updating\"));\n\t\t\tHTMLNode content = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tcontent.addChild(\"p\").addChild(\"#\", \"The Freenet node is being updated and will self-restart. The restart process may take up to 10 minutes, because the node will try to fetch a revocation key before updating.\");\n\t\t\tcontent.addChild(\"p\").addChild(\"#\", \"Thank you for using Freenet.\");\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\tLogger.normal(this, \"Node is updating/restarting\");\n\t\t\tnode.ps.queueTimedJob(new Runnable() {\n\t\t\t\tpublic void run() { node.getNodeUpdater().Update(); }}, 0);\n\t\t\treturn;\n\t\t}else if (request.getPartAsString(GenericReadFilterCallback.magicHTTPEscapeString, MAX_URL_LENGTH).length()>0){\n\t\t\tMultiValueTable headers = new MultiValueTable();\n\t\t\tString url = null;\n\t\t\tif((request.getPartAsString(\"Go\", 32).length() > 0))\n\t\t\t\turl = request.getPartAsString(GenericReadFilterCallback.magicHTTPEscapeString, MAX_URL_LENGTH);\n\t\t\theaders.put(\"Location\", url==null ? \"/\" : url);\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}else if (request.getPartAsString(\"update\", 32).length() > 0) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node Update\");\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-query\", \"Node Update\"));\n\t\t\tHTMLNode content = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tcontent.addChild(\"p\").addChild(\"#\", \"Are you sure you wish to update your Freenet node?\");\n\t\t\tHTMLNode updateForm = content.addChild(\"p\").addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] { \"/\", \"post\" });\n\t\t\tupdateForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", \"Cancel\" });\n\t\t\tupdateForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"updateconfirm\", \"Update\" });\n\t\t\tupdateForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}else if(request.isPartSet(\"getThreadDump\")) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Get a Thread Dump\");\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tif(node.isUsingWrapper()){\n\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"Thread Dump generation\"));\n\t\t\t\tctx.getPageMaker().getContentNode(infobox).addChild(\"#\", \"A thread dump has been generated, it's aviable in \"+ WrapperManager.getProperties().getProperty(\"wrapper.logfile\"));\n\t\t\t\tSystem.out.println(\"Thread Dump:\");\n\t\t\t\tWrapperManager.requestThreadDump();\n\t\t\t}else{\n\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-error\",\"Thread Dump generation\"));\n\t\t\t\tctx.getPageMaker().getContentNode(infobox).addChild(\"#\", \"It's not possible to make the node generate a thread dump if you aren't using the wrapper!\");\n\t\t\t}\n\t\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}else if (request.isPartSet(\"addbookmark\")) {\n\t\t\tString key = request.getPartAsString(\"key\", MAX_KEY_LENGTH);\n\t\t\tString name = request.getPartAsString(\"name\", MAX_NAME_LENGTH);\n\t\t\ttry {\n\t\t\t\tbookmarks.addBookmark(new Bookmark(key, name), true);\n\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\tthis.sendBookmarkEditPage(ctx, MODE_ADD, null, key, name, \"Given key does not appear to be a valid Freenet key.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (request.isPartSet(\"managebookmarks\")) {\n\t\t\tEnumeration e = bookmarks.getBookmarks();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\n\t\t\t\tif (request.isPartSet(\"delete_\"+b.hashCode())) {\n\t\t\t\t\tbookmarks.removeBookmark(b, true);\n\t\t\t\t} else if (request.isPartSet(\"edit_\"+b.hashCode())) {\n\t\t\t\t\tthis.sendBookmarkEditPage(ctx, b);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (request.isPartSet(\"update_\"+b.hashCode())) {\n\t\t\t\t\t// removing it and adding means that any USK subscriptions are updated properly\n\t\t\t\t\tString key = request.getPartAsString(\"key\", MAX_KEY_LENGTH);\n\t\t\t\t\tString name = request.getPartAsString(\"name\", MAX_NAME_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tBookmark newbkmk = new Bookmark(key, name);\n\t\t\t\t\t\tbookmarks.removeBookmark(b, false);\n\t\t\t\t\t\tbookmarks.addBookmark(newbkmk, true);\n\t\t\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\t\t\tthis.sendBookmarkEditPage(ctx, MODE_EDIT, b, key, name, \"Given key does not appear to be a valid freenet key.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}else if(request.isPartSet(\"disable\")){\n\t\t\tUserAlert[] alerts=core.alerts.getAlerts();\n\t\t\tfor(int i=0;i<alerts.length;i++){\n\t\t\t\tif(request.getIntPart(\"disable\",-1)==alerts[i].hashCode()){\n\t\t\t\t\tUserAlert alert = alerts[i];\n\t\t\t\t\t// Won't be dismissed if it's not allowed anyway\n\t\t\t\t\tif(alert.userCanDismiss() && alert.shouldUnregisterOnDismiss()) {\n\t\t\t\t\t\talert.onDismiss();\n\t\t\t\t\t\tLogger.normal(this,\"Unregistering the userAlert \"+alert.hashCode());\n\t\t\t\t\t\tcore.alerts.unregister(alert);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.normal(this,\"Disabling the userAlert \"+alert.hashCode());\n\t\t\t\t\t\talert.isValid(false);\n\t\t\t\t\t}\n\n\t\t\t\t\twritePermanentRedirect(ctx, \"Configuration applied\", \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(request.isPartSet(\"boardname\")&&request.isPartSet(\"filename\")){\n\t\t\t// Inserting into a frost board FIN\n\t\t\t// boardname\n\t\t\t// filename\n\t\t\t// boardprivatekey (not needed)\n\t\t\t// boardpublickey (not needed) (and maybe dump it all the way)\n\t\t\t// innitialindex\n\t\t\t// sender\n\t\t\t// subject\n\t\t\t\tFrostBoard board = null;\n\t\t\t\tif(request.isPartSet(\"boardprivatekey\")&&request.isPartSet(\"boardpublickey\")) // keyed board\n\t\t\t\t{\n\t\t\t\t\tboard = new FrostBoard(\n\t\t\t\t\t\t\trequest.getPartAsString(\"boardname\",FrostBoard.MAX_NAME_LENGTH),\n\t\t\t\t\t\t\trequest.getPartAsString(\"boardprivatekey\",78),\n\t\t\t\t\t\t\trequest.getPartAsString(\"boardpublickey\",78));\n\t\t\t\t}\n\t\t\t\telse // unkeyed or public board\n\t\t\t\t{\n\t\t\t\t\tboard = new FrostBoard(request.getPartAsString(\"boardname\",FrostBoard.MAX_NAME_LENGTH));\n\t\t\t\t}\n\t\t\t\tFrostMessage fin = new FrostMessage(\"news\", board, request.getPartAsString(\"sender\",64), request.getPartAsString(\"subject\",128), request.getPartAsString(\"filename\",1024));\n\t\t\t\t\n\t\t\t\tint innitialIndex = 0;\n\t\t\t\tif(request.isPartSet(\"innitialindex\"))\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinnitialIndex = Integer.parseInt(request.getPartAsString(\"innitialindex\",3));\n\t\t\t\t\t}\n\t\t\t\t\tcatch(NumberFormatException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tinnitialIndex = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Insertion\");\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\tHTMLNode content;\n\t\t\t\ttry {\n\t\t\t\t\tFreenetURI finalKey = fin.insertMessage(this.getClientImpl(), innitialIndex);\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-success\", \"Insert Succeeded\"));\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The message \");\n\t\t\t\t\tcontent.addChild(\"#\", \" has been inserted successfully into \"+finalKey.toString());\n\t\t\t\t}\n\t\t\t\tcatch(InserterException e)\n\t\t\t\t{\n\t\t\t\t\tHTMLNode infobox = ctx.getPageMaker().getInfobox(\"infobox-error\", \"Insert Failed\");\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The insert failed with the message: \" + e.getMessage());\n\t\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\t\tif (e.uri != null) {\n\t\t\t\t\t\tcontent.addChild(\"#\", \"The URI would have been: \" + e.uri);\n\t\t\t\t\t}\n\t\t\t\t\tint mode = e.getMode();\n\t\t\t\t\tif((mode == InserterException.FATAL_ERRORS_IN_BLOCKS) || (mode == InserterException.TOO_MANY_RETRIES_IN_BLOCKS)) {\n\t\t\t\t\t\tcontent.addChild(\"br\"); /* TODO */\n\t\t\t\t\t\tcontent.addChild(\"#\", \"Splitfile-specific error: \" + e.errorCodes.toVerboseString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\tcontent.addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", \"Node Homepage\" }, \"Homepage\");\n\t\t\t\t\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\t\trequest.freeParts();\n\t\t}else if(request.isPartSet(\"key\")&&request.isPartSet(\"filename\")){\n\n\t\t\t\tFreenetURI key = new FreenetURI(request.getPartAsString(\"key\",128));\n\t\t\t\tString type = request.getPartAsString(\"content-type\",128);\n\t\t\t\tif(type==null) type = \"text/plain\";\n\t\t\t\tClientMetadata contentType = new ClientMetadata(type);\n\t\t\t\t\n\t\t\t\tBucket bucket = request.getPart(\"filename\");\n\t\t\t\t\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Insertion\");\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\tHTMLNode content;\n\t\t\t\tString filenameHint = null;\n\t\t\t\tif(key.getKeyType().equals(\"CHK\")) {\n\t\t\t\t\tString[] metas = key.getAllMetaStrings();\n\t\t\t\t\tif(metas != null && metas.length > 1) {\n\t\t\t\t\t\tfilenameHint = metas[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tInsertBlock block = new InsertBlock(bucket, contentType, key);\n\t\t\t\ttry {\n\t\t\t\t\tkey = this.insert(block, filenameHint, false);\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-success\", \"Insert Succeeded\"));\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The key \");\n\t\t\t\t\tcontent.addChild(\"a\", \"href\", \"/\" + key.getKeyType() + \"@\" + key.getGuessableKey(), key.getKeyType() + \"@\" + key.getGuessableKey());\n\t\t\t\t\tcontent.addChild(\"#\", \" has been inserted successfully.\");\n\t\t\t\t} catch (InserterException e) {\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-error\", \"Insert Failed\"));\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The insert failed with the message: \" + e.getMessage());\n\t\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\t\tif (e.uri != null) {\n\t\t\t\t\t\tcontent.addChild(\"#\", \"The URI would have been: \" + e.uri);\n\t\t\t\t\t}\n\t\t\t\t\tint mode = e.getMode();\n\t\t\t\t\tif((mode == InserterException.FATAL_ERRORS_IN_BLOCKS) || (mode == InserterException.TOO_MANY_RETRIES_IN_BLOCKS)) {\n\t\t\t\t\t\tcontent.addChild(\"br\"); /* TODO */\n\t\t\t\t\t\tcontent.addChild(\"#\", \"Splitfile-specific error: \" + e.errorCodes.toVerboseString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\tcontent.addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", \"Node Homepage\" }, \"Homepage\");\n\t\t\t\t\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\t\trequest.freeParts();\n\t\t\t\tbucket.free();\n\t\t}else if (request.isPartSet(\"shutdownconfirm\")) {\n\t\t\t// Tell the user that the node is shutting down\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node Shutdown\", false);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-information\", \"The Freenet node has been successfully shut down.\"));\n\t\t\tHTMLNode infoboxContent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tinfoboxContent.addChild(\"#\", \"Thank you for using Freenet.\");\n\t\t\twriteReply(ctx, 200, \"text/html; charset=utf-8\", \"OK\", pageNode.generate());\n\t\t\tthis.node.exit(\"Shutdown from fproxy\");\n\t\t\treturn;\n\t\t}else if(request.isPartSet(\"restartconfirm\")){\n\t\t\t// Tell the user that the node is restarting\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node Restart\", false);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-information\", \"The Freenet is being restarted.\"));\n\t\t\tHTMLNode infoboxContent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tinfoboxContent.addChild(\"#\", \"Please wait while the node is being restarted. This might take up to 3 minutes. Thank you for using Freenet.\");\n\t\t\twriteReply(ctx, 200, \"text/html; charset=utf-8\", \"OK\", pageNode.generate());\n\t\t\tLogger.normal(this, \"Node is restarting\");\n\t\t\tnode.getNodeStarter().restart();\n\t\t\treturn;\n\t\t}else {\n\t\t\tthis.handleGet(uri, ctx);\n\t\t}\n\t}","id":95851,"modified_method":"public void handlePost(URI uri, Bucket data, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\t\n\t\tif(data.size() > 1024*1024) {\n\t\t\tthis.writeReply(ctx, 400, \"text/plain\", \"Too big\", \"Data exceeds 1MB limit\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tHTTPRequest request = new HTTPRequest(uri,data,ctx);\n\n\t\tString passwd = request.getPartAsString(\"formPassword\", 32);\n\t\tif((passwd == null) || !passwd.equals(core.formPassword)) {\n\t\t\tMultiValueTable headers = new MultiValueTable();\n\t\t\theaders.put(\"Location\", \"/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"No password (\"+passwd+\" should be \"+core.formPassword+\")\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(request.getPartAsString(\"updateconfirm\", 32).length() > 0){\n\t\t\t// false for no navigation bars, because that would be very silly\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node updating\");\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-information\", \"Node updating\"));\n\t\t\tHTMLNode content = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tcontent.addChild(\"p\").addChild(\"#\", \"The Freenet node is being updated and will self-restart. The restart process may take up to 10 minutes, because the node will try to fetch a revocation key before updating.\");\n\t\t\tcontent.addChild(\"p\").addChild(\"#\", \"Thank you for using Freenet.\");\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\tLogger.normal(this, \"Node is updating/restarting\");\n\t\t\tnode.ps.queueTimedJob(new Runnable() {\n\t\t\t\tpublic void run() { node.getNodeUpdater().Update(); }}, 0);\n\t\t\treturn;\n\t\t}else if (request.getPartAsString(GenericReadFilterCallback.magicHTTPEscapeString, MAX_URL_LENGTH).length()>0){\n\t\t\tMultiValueTable headers = new MultiValueTable();\n\t\t\tString url = null;\n\t\t\tif((request.getPartAsString(\"Go\", 32).length() > 0))\n\t\t\t\turl = request.getPartAsString(GenericReadFilterCallback.magicHTTPEscapeString, MAX_URL_LENGTH);\n\t\t\theaders.put(\"Location\", url==null ? \"/\" : url);\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}else if (request.getPartAsString(\"update\", 32).length() > 0) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node Update\");\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-query\", \"Node Update\"));\n\t\t\tHTMLNode content = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tcontent.addChild(\"p\").addChild(\"#\", \"Are you sure you wish to update your Freenet node?\");\n\t\t\tHTMLNode updateForm = content.addChild(\"p\").addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] { \"/\", \"post\" });\n\t\t\tupdateForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", \"Cancel\" });\n\t\t\tupdateForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"updateconfirm\", \"Update\" });\n\t\t\tupdateForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}else if(request.isPartSet(\"getThreadDump\")) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Get a Thread Dump\");\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tif(node.isUsingWrapper()){\n\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"Thread Dump generation\"));\n\t\t\t\tctx.getPageMaker().getContentNode(infobox).addChild(\"#\", \"A thread dump has been generated, it's aviable in \"+ WrapperManager.getProperties().getProperty(\"wrapper.logfile\"));\n\t\t\t\tSystem.out.println(\"Thread Dump:\");\n\t\t\t\tWrapperManager.requestThreadDump();\n\t\t\t}else{\n\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-error\",\"Thread Dump generation\"));\n\t\t\t\tctx.getPageMaker().getContentNode(infobox).addChild(\"#\", \"It's not possible to make the node generate a thread dump if you aren't using the wrapper!\");\n\t\t\t}\n\t\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}else if (request.isPartSet(\"addbookmark\")) {\n\t\t\tString key = request.getPartAsString(\"key\", MAX_KEY_LENGTH);\n\t\t\tString name = request.getPartAsString(\"name\", MAX_NAME_LENGTH);\n\t\t\ttry {\n\t\t\t\tbookmarks.addBookmark(new Bookmark(key, name), true);\n\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\tthis.sendBookmarkEditPage(ctx, MODE_ADD, null, key, name, \"Given key does not appear to be a valid Freenet key.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (request.isPartSet(\"managebookmarks\")) {\n\t\t\tEnumeration e = bookmarks.getBookmarks();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\n\t\t\t\tif (request.isPartSet(\"delete_\"+b.hashCode())) {\n\t\t\t\t\tbookmarks.removeBookmark(b, true);\n\t\t\t\t} else if (request.isPartSet(\"edit_\"+b.hashCode())) {\n\t\t\t\t\tthis.sendBookmarkEditPage(ctx, b);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (request.isPartSet(\"update_\"+b.hashCode())) {\n\t\t\t\t\t// removing it and adding means that any USK subscriptions are updated properly\n\t\t\t\t\tString key = request.getPartAsString(\"key\", MAX_KEY_LENGTH);\n\t\t\t\t\tString name = request.getPartAsString(\"name\", MAX_NAME_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tBookmark newbkmk = new Bookmark(key, name);\n\t\t\t\t\t\tbookmarks.removeBookmark(b, false);\n\t\t\t\t\t\tbookmarks.addBookmark(newbkmk, true);\n\t\t\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\t\t\tthis.sendBookmarkEditPage(ctx, MODE_EDIT, b, key, name, \"Given key does not appear to be a valid freenet key.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}else if(request.isPartSet(\"disable\")){\n\t\t\tUserAlert[] alerts=core.alerts.getAlerts();\n\t\t\tfor(int i=0;i<alerts.length;i++){\n\t\t\t\tif(request.getIntPart(\"disable\",-1)==alerts[i].hashCode()){\n\t\t\t\t\tUserAlert alert = alerts[i];\n\t\t\t\t\t// Won't be dismissed if it's not allowed anyway\n\t\t\t\t\tif(alert.userCanDismiss() && alert.shouldUnregisterOnDismiss()) {\n\t\t\t\t\t\talert.onDismiss();\n\t\t\t\t\t\tLogger.normal(this,\"Unregistering the userAlert \"+alert.hashCode());\n\t\t\t\t\t\tcore.alerts.unregister(alert);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.normal(this,\"Disabling the userAlert \"+alert.hashCode());\n\t\t\t\t\t\talert.isValid(false);\n\t\t\t\t\t}\n\n\t\t\t\t\twritePermanentRedirect(ctx, \"Configuration applied\", \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(request.isPartSet(\"boardname\")&&request.isPartSet(\"filename\")){\n\t\t\t// Inserting into a frost board FIN\n\t\t\t// boardname\n\t\t\t// filename\n\t\t\t// boardprivatekey (not needed)\n\t\t\t// boardpublickey (not needed) (and maybe dump it all the way)\n\t\t\t// innitialindex\n\t\t\t// sender\n\t\t\t// subject\n\t\t\tString boardName = request.getPartAsString(\"boardname\",FrostBoard.MAX_NAME_LENGTH);\n\t\t\tString boardPrivateKey = request.getPartAsString(\"boardprivatekey\",78);\n\t\t\tString boardPublicKey = request.getPartAsString(\"boardpublickey\",78);\n\t\t\tString sender = request.getPartAsString(\"sender\",64);\n\t\t\tString subject = request.getPartAsString(\"subject\",128);\n\t\t\tString filename = request.getPartAsString(\"filename\",1024);\n\t\t\t\n\t\t\tint innitialIndex = 0;\n\t\t\tif(request.isPartSet(\"innitialindex\"))\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tinnitialIndex = Integer.parseInt(request.getPartAsString(\"innitialindex\",3));\n\t\t\t\t}\n\t\t\t\tcatch(NumberFormatException e)\n\t\t\t\t{\n\t\t\t\t\tinnitialIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\tFrostBoard board = null;\n\t\t\t\tif(boardPrivateKey.length()>0 && boardPublicKey.length()>0) { // keyed board\n\t\t\t\t\tboard = new FrostBoard(boardName, boardPrivateKey, boardPublicKey);\n\t\t\t\t} else { // unkeyed or public board\n\t\t\t\t\tboard = new FrostBoard(boardName);\n\t\t\t\t}\n\t\t\t\tFrostMessage fin = new FrostMessage(\"news\", board, sender, subject, filename);\n\t\t\t\t\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Insertion\");\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\tHTMLNode content;\n\t\t\t\ttry {\n\t\t\t\t\tFreenetURI finalKey = fin.insertMessage(this.getClientImpl(), innitialIndex);\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-success\", \"Insert Succeeded\"));\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The message \");\n\t\t\t\t\tcontent.addChild(\"#\", \" has been inserted successfully into \"+finalKey.toString());\n\t\t\t\t}\n\t\t\t\tcatch(InserterException e)\n\t\t\t\t{\n\t\t\t\t\tHTMLNode infobox = ctx.getPageMaker().getInfobox(\"infobox-error\", \"Insert Failed\");\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The insert failed with the message: \" + e.getMessage());\n\t\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\t\tif (e.uri != null) {\n\t\t\t\t\t\tcontent.addChild(\"#\", \"The URI would have been: \" + e.uri);\n\t\t\t\t\t}\n\t\t\t\t\tint mode = e.getMode();\n\t\t\t\t\tif((mode == InserterException.FATAL_ERRORS_IN_BLOCKS) || (mode == InserterException.TOO_MANY_RETRIES_IN_BLOCKS)) {\n\t\t\t\t\t\tcontent.addChild(\"br\"); /* TODO */\n\t\t\t\t\t\tcontent.addChild(\"#\", \"Splitfile-specific error: \" + e.errorCodes.toVerboseString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\tcontent.addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", \"Node Homepage\" }, \"Homepage\");\n\t\t\t\t\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\t\trequest.freeParts();\n\t\t}else if(request.isPartSet(\"key\")&&request.isPartSet(\"filename\")){\n\n\t\t\t\tFreenetURI key = new FreenetURI(request.getPartAsString(\"key\",128));\n\t\t\t\tString type = request.getPartAsString(\"content-type\",128);\n\t\t\t\tif(type==null) type = \"text/plain\";\n\t\t\t\tClientMetadata contentType = new ClientMetadata(type);\n\t\t\t\t\n\t\t\t\tBucket bucket = request.getPart(\"filename\");\n\t\t\t\t\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Insertion\");\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\tHTMLNode content;\n\t\t\t\tString filenameHint = null;\n\t\t\t\tif(key.getKeyType().equals(\"CHK\")) {\n\t\t\t\t\tString[] metas = key.getAllMetaStrings();\n\t\t\t\t\tif(metas != null && metas.length > 1) {\n\t\t\t\t\t\tfilenameHint = metas[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tInsertBlock block = new InsertBlock(bucket, contentType, key);\n\t\t\t\ttry {\n\t\t\t\t\tkey = this.insert(block, filenameHint, false);\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-success\", \"Insert Succeeded\"));\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The key \");\n\t\t\t\t\tcontent.addChild(\"a\", \"href\", \"/\" + key.getKeyType() + \"@\" + key.getGuessableKey(), key.getKeyType() + \"@\" + key.getGuessableKey());\n\t\t\t\t\tcontent.addChild(\"#\", \" has been inserted successfully.\");\n\t\t\t\t} catch (InserterException e) {\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-error\", \"Insert Failed\"));\n\t\t\t\t\tcontent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\t\t\tcontent.addChild(\"#\", \"The insert failed with the message: \" + e.getMessage());\n\t\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\t\tif (e.uri != null) {\n\t\t\t\t\t\tcontent.addChild(\"#\", \"The URI would have been: \" + e.uri);\n\t\t\t\t\t}\n\t\t\t\t\tint mode = e.getMode();\n\t\t\t\t\tif((mode == InserterException.FATAL_ERRORS_IN_BLOCKS) || (mode == InserterException.TOO_MANY_RETRIES_IN_BLOCKS)) {\n\t\t\t\t\t\tcontent.addChild(\"br\"); /* TODO */\n\t\t\t\t\t\tcontent.addChild(\"#\", \"Splitfile-specific error: \" + e.errorCodes.toVerboseString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\tcontent.addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", \"Node Homepage\" }, \"Homepage\");\n\t\t\t\t\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\t\trequest.freeParts();\n\t\t\t\tbucket.free();\n\t\t}else if (request.isPartSet(\"shutdownconfirm\")) {\n\t\t\t// Tell the user that the node is shutting down\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node Shutdown\", false);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-information\", \"The Freenet node has been successfully shut down.\"));\n\t\t\tHTMLNode infoboxContent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tinfoboxContent.addChild(\"#\", \"Thank you for using Freenet.\");\n\t\t\twriteReply(ctx, 200, \"text/html; charset=utf-8\", \"OK\", pageNode.generate());\n\t\t\tthis.node.exit(\"Shutdown from fproxy\");\n\t\t\treturn;\n\t\t}else if(request.isPartSet(\"restartconfirm\")){\n\t\t\t// Tell the user that the node is restarting\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Node Restart\", false);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"infobox-information\", \"The Freenet is being restarted.\"));\n\t\t\tHTMLNode infoboxContent = ctx.getPageMaker().getContentNode(infobox);\n\t\t\tinfoboxContent.addChild(\"#\", \"Please wait while the node is being restarted. This might take up to 3 minutes. Thank you for using Freenet.\");\n\t\t\twriteReply(ctx, 200, \"text/html; charset=utf-8\", \"OK\", pageNode.generate());\n\t\t\tLogger.normal(this, \"Node is restarting\");\n\t\t\tnode.getNodeStarter().restart();\n\t\t\treturn;\n\t\t}else {\n\t\t\tthis.handleGet(uri, ctx);\n\t\t}\n\t}","commit_id":"5c77a7969ff756f6e8d0803725d28d99ad641118","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Dumps the definition as XML\n     *\n     * @param context    the CamelContext\n     * @param definition the definition, such as a {@link org.apache.camel.NamedNode}\n     * @return the output in XML (is formatted)\n     * @throws JAXBException is throw if error marshalling to XML\n     */\n    public static String dumpModelAsXml(CamelContext context, NamedNode definition) throws JAXBException {\n        JAXBContext jaxbContext = context.getModelJAXBContextFactory().newJAXBContext();\n\n        Marshaller marshaller = jaxbContext.createMarshaller();\n        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n        StringWriter buffer = new StringWriter();\n        marshaller.marshal(definition, buffer);\n\n        return buffer.toString();\n    }","id":95852,"modified_method":"/**\n     * Dumps the definition as XML\n     *\n     * @param context    the CamelContext, if <tt>null<\/tt> then {@link org.apache.camel.spi.ModelJAXBContextFactory} is not in use\n     * @param definition the definition, such as a {@link org.apache.camel.NamedNode}\n     * @return the output in XML (is formatted)\n     * @throws JAXBException is throw if error marshalling to XML\n     */\n    public static String dumpModelAsXml(CamelContext context, NamedNode definition) throws JAXBException {\n        JAXBContext jaxbContext;\n        if (context == null) {\n            jaxbContext = createJAXBContext();\n        } else {\n            jaxbContext = context.getModelJAXBContextFactory().newJAXBContext();\n        }\n\n        Marshaller marshaller = jaxbContext.createMarshaller();\n        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n        StringWriter buffer = new StringWriter();\n        marshaller.marshal(definition, buffer);\n\n        return buffer.toString();\n    }","commit_id":"72d7a7d6da89be85076675751a6b253cd9ad8283","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Marshal the xml to the model definition\n     *\n     * @param context the CamelContext\n     * @param stream  the xml stream\n     * @param type    the definition type to return, will throw a {@link ClassCastException} if not the expected type\n     * @return the model definition\n     * @throws javax.xml.bind.JAXBException is thrown if error unmarshalling from xml to model\n     */\n    public static <T extends NamedNode> T createModelFromXml(CamelContext context, InputStream stream, Class<T> type) throws JAXBException {\n        JAXBContext jaxbContext = context.getModelJAXBContextFactory().newJAXBContext();\n        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n        Object result = unmarshaller.unmarshal(stream);\n        return type.cast(result);\n    }","id":95853,"modified_method":"/**\n     * Marshal the xml to the model definition\n     *\n     * @param context the CamelContext, if <tt>null<\/tt> then {@link org.apache.camel.spi.ModelJAXBContextFactory} is not in use\n     * @param stream  the xml stream\n     * @param type    the definition type to return, will throw a {@link ClassCastException} if not the expected type\n     * @return the model definition\n     * @throws javax.xml.bind.JAXBException is thrown if error unmarshalling from xml to model\n     */\n    public static <T extends NamedNode> T createModelFromXml(CamelContext context, InputStream stream, Class<T> type) throws JAXBException {\n        JAXBContext jaxbContext;\n        if (context == null) {\n            jaxbContext = createJAXBContext();\n        } else {\n            jaxbContext = context.getModelJAXBContextFactory().newJAXBContext();\n        }\n\n        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n        Object result = unmarshaller.unmarshal(stream);\n        return type.cast(result);\n    }","commit_id":"72d7a7d6da89be85076675751a6b253cd9ad8283","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Marshal the xml to the model definition\n     *\n     * @param context the CamelContext\n     * @param xml     the xml\n     * @param type    the definition type to return, will throw a {@link ClassCastException} if not the expected type\n     * @return the model definition\n     * @throws javax.xml.bind.JAXBException is thrown if error unmarshalling from xml to model\n     */\n    public static <T extends NamedNode> T createModelFromXml(CamelContext context, String xml, Class<T> type) throws JAXBException {\n        JAXBContext jaxbContext = context.getModelJAXBContextFactory().newJAXBContext();\n        StringReader reader = new StringReader(xml);\n        Object result;\n        try {\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            result = unmarshaller.unmarshal(reader);\n        } finally {\n            IOHelper.close(reader);\n        }\n\n        if (result == null) {\n            throw new JAXBException(\"Cannot unmarshal to \" + type + \" using JAXB from XML: \" + xml);\n        }\n        return type.cast(result);\n    }","id":95854,"modified_method":"/**\n     * Marshal the xml to the model definition\n     *\n     * @param context the CamelContext, if <tt>null<\/tt> then {@link org.apache.camel.spi.ModelJAXBContextFactory} is not in use\n     * @param xml     the xml\n     * @param type    the definition type to return, will throw a {@link ClassCastException} if not the expected type\n     * @return the model definition\n     * @throws javax.xml.bind.JAXBException is thrown if error unmarshalling from xml to model\n     */\n    public static <T extends NamedNode> T createModelFromXml(CamelContext context, String xml, Class<T> type) throws JAXBException {\n        JAXBContext jaxbContext;\n        if (context == null) {\n            jaxbContext = createJAXBContext();\n        } else {\n            jaxbContext = context.getModelJAXBContextFactory().newJAXBContext();\n        }\n\n        StringReader reader = new StringReader(xml);\n        Object result;\n        try {\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            result = unmarshaller.unmarshal(reader);\n        } finally {\n            IOHelper.close(reader);\n        }\n\n        if (result == null) {\n            throw new JAXBException(\"Cannot unmarshal to \" + type + \" using JAXB from XML: \" + xml);\n        }\n        return type.cast(result);\n    }","commit_id":"72d7a7d6da89be85076675751a6b253cd9ad8283","url":"https://github.com/apache/camel"},{"original_method":"private Object computeQueueLength(MetricsRequest metricsRequest) {\n    MetricsScope scope = metricsRequest.getScope();\n    AggregatesTable aggregatesTable = aggregatesTables.get(scope);\n    // First scan the ack to get an aggregate and also names of queues.\n    AggregatesScanner scanner = aggregatesTable.scan(metricsRequest.getContextPrefix(),\n                                                     \"q.ack\",\n                                                     metricsRequest.getRunId(),\n                                                     metricsRequest.getTagPrefix());\n    long ack = 0;\n    Set<QueueName> queueNames = Sets.newHashSet();\n    while (scanner.hasNext()) {\n      AggregatesScanResult scanResult = scanner.next();\n      ack += scanResult.getValue();\n      queueNames.add(QueueName.from(URI.create(scanResult.getMetric().substring(\"q.ack.\".length()))));\n    }\n\n    // For each queue, get the enqueue aggregate\n    long enqueue = 0;\n    for (QueueName queueName : queueNames) {\n      if (queueName.isStream()) {\n        // It's a stream, use stream context\n        enqueue += sumAll(aggregatesTable.scan(\"-.stream\", \"q.enqueue.\" + queueName.toString()));\n      } else {\n        // Construct query context from the queue name and the request context\n        // This is hacky. Need a refactor of how metrics, queue and tx interact\n        String contextPrefix = metricsRequest.getContextPrefix();\n        String appId = contextPrefix.substring(0, contextPrefix.indexOf('.'));\n        String flowId = queueName.toURI().getHost();\n        String flowletId = Splitter.on('/').omitEmptyStrings().split(queueName.toURI().getPath()).iterator().next();\n        // The paths would be /flowId/flowletId/queueSimpleName\n        enqueue += sumAll(aggregatesTable.scan(String.format(\"%s.f.%s.%s\", appId, flowId, flowletId),\n                                               \"q.enqueue.\" + queueName.toString()));\n      }\n    }\n\n    long len = enqueue - ack;\n    return new AggregateResponse(len >= 0 ? len : 0);\n  }","id":95855,"modified_method":"private Object computeQueueLength(MetricsRequest metricsRequest) {\n    AggregatesTable aggregatesTable = aggregatesTables.get(metricsRequest.getScope());\n\n    // process.events.processed will have a tag like \"input.queue://PurchaseFlow/reader/queue\" which indicates\n    // where the processed event came from.  So first get the aggregate count for events processed and all the\n    // queues they came from. Next, for all those queues, get the aggregate count for events they wrote,\n    // and subtract the two to get queue length.\n    AggregatesScanner scanner = aggregatesTable.scan(metricsRequest.getContextPrefix(),\n                                                     \"process.events.processed\",\n                                                     metricsRequest.getRunId(),\n                                                     \"input\");\n\n    long processed = 0;\n    Set<QueueName> queueNames = Sets.newHashSet();\n    while (scanner.hasNext()) {\n      AggregatesScanResult scanResult = scanner.next();\n      processed += scanResult.getValue();\n      // tag is of the form input.[queueURI].  ex: input.queue://PurchaseFlow/reader/queue\n      String tag = scanResult.getTag();\n      // strip the preceding \"input.\" from the tag.\n      queueNames.add(QueueName.from(URI.create(tag.substring(6, tag.length()))));\n    }\n\n    // For each queue, get the enqueue aggregate\n    long enqueue = 0;\n    for (QueueName queueName : queueNames) {\n      if (queueName.isStream()) {\n        // It's a stream, use stream context\n        enqueue += sumAll(aggregatesTable.scan(Constants.Gateway.METRICS_CONTEXT,\n                                               \"collect.events\", \"0\", queueName.getSimpleName()));\n      } else {\n        // Construct query context from the queue name and the request context\n        // This is hacky. Need a refactor of how metrics, queue and tx interact\n        String contextPrefix = metricsRequest.getContextPrefix();\n        String appId = contextPrefix.substring(0, contextPrefix.indexOf('.'));\n        String flowId = queueName.toURI().getHost();\n        String flowletId = Splitter.on('/').omitEmptyStrings().split(queueName.toURI().getPath()).iterator().next();\n        // The paths would be /flowId/flowletId/queueSimpleName\n        enqueue += sumAll(aggregatesTable.scan(String.format(\"%s.f.%s.%s\", appId, flowId, flowletId),\n                                               \"process.events.out\", \"0\", queueName.getSimpleName()));\n      }\n    }\n\n    long len = enqueue - processed;\n    return new AggregateResponse(len >= 0 ? len : 0);\n  }","commit_id":"b8f563199abc7cc500778b9edb740c155b4bc484","url":"https://github.com/caskdata/cdap"},{"original_method":"CachedStreamEvents(final TransactionSystemClient txClient, final QueueClientFactory queueClientFactory,\n                     final ExecutorService callbackExecutorService,\n                     long maxCachedSizeBytes, int maxCachedEvents,\n                     final int maxCachedEventsPerStream) {\n    this.maxCachedSizeBytes = maxCachedSizeBytes;\n    this.maxCachedEvents = maxCachedEvents;\n\n    this.eventCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .removalListener(\n        new RemovalListener<QueueName, ProducerStreamEntries>() {\n          @Override\n          public void onRemoval(RemovalNotification<QueueName, ProducerStreamEntries> notification) {\n            ProducerStreamEntries producerStreamEntries = notification.getValue();\n            if (producerStreamEntries != null) {\n              producerStreamEntries.flush(true);\n              try {\n                producerStreamEntries.close();\n              } catch (IOException e) {\n                LOG.error(\"Exception while closing producer {}\", producerStreamEntries);\n              }\n            }\n          }\n        }\n      )\n      .build(\n        new CacheLoader<QueueName, ProducerStreamEntries>() {\n          @Override\n          public ProducerStreamEntries load(final QueueName key) throws Exception {\n            Queue2Producer producer = metricsCollectionService == null ? queueClientFactory.createProducer(key) :\n              queueClientFactory.createProducer(\n                key,\n                new QueueMetrics() {\n                  MetricsCollector collector =\n                    metricsCollectionService.getCollector(MetricsScope.REACTOR, METRICS_CONTEXT, \"0\");\n\n                  @Override\n                  public void emitEnqueue(int count) {\n                    collector.gauge(\"collect.events\", count, key.getSimpleName());\n                  }\n\n                  @Override\n                  public void emitEnqueueBytes(int bytes) {\n                    collector.gauge(\"collect.bytes\", bytes, key.getSimpleName());\n                  }\n                });\n\n            return new ProducerStreamEntries(producer,\n                                             new ArrayBlockingQueue<StreamEntry>(maxCachedEventsPerStream),\n                                             txClient, callbackExecutorService, cachedBytes, cachedNumEntries);\n          }\n        });\n  }","id":95856,"modified_method":"CachedStreamEvents(final TransactionSystemClient txClient, final QueueClientFactory queueClientFactory,\n                     final ExecutorService callbackExecutorService,\n                     long maxCachedSizeBytes, int maxCachedEvents,\n                     final int maxCachedEventsPerStream) {\n    this.maxCachedSizeBytes = maxCachedSizeBytes;\n    this.maxCachedEvents = maxCachedEvents;\n\n    this.eventCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .removalListener(\n        new RemovalListener<QueueName, ProducerStreamEntries>() {\n          @Override\n          public void onRemoval(RemovalNotification<QueueName, ProducerStreamEntries> notification) {\n            ProducerStreamEntries producerStreamEntries = notification.getValue();\n            if (producerStreamEntries != null) {\n              producerStreamEntries.flush(true);\n              try {\n                producerStreamEntries.close();\n              } catch (IOException e) {\n                LOG.error(\"Exception while closing producer {}\", producerStreamEntries);\n              }\n            }\n          }\n        }\n      )\n      .build(\n        new CacheLoader<QueueName, ProducerStreamEntries>() {\n          @Override\n          public ProducerStreamEntries load(final QueueName key) throws Exception {\n            Queue2Producer producer = metricsCollectionService == null ? queueClientFactory.createProducer(key) :\n              queueClientFactory.createProducer(\n                key,\n                new QueueMetrics() {\n                  MetricsCollector collector =\n                    metricsCollectionService.getCollector(MetricsScope.REACTOR, Constants.Gateway.METRICS_CONTEXT, \"0\");\n\n                  @Override\n                  public void emitEnqueue(int count) {\n                    collector.gauge(\"collect.events\", count, key.getSimpleName());\n                  }\n\n                  @Override\n                  public void emitEnqueueBytes(int bytes) {\n                    collector.gauge(\"collect.bytes\", bytes, key.getSimpleName());\n                  }\n                });\n\n            return new ProducerStreamEntries(producer,\n                                             new ArrayBlockingQueue<StreamEntry>(maxCachedEventsPerStream),\n                                             txClient, callbackExecutorService, cachedBytes, cachedNumEntries);\n          }\n        });\n  }","commit_id":"b8f563199abc7cc500778b9edb740c155b4bc484","url":"https://github.com/caskdata/cdap"},{"original_method":"private <T> ProcessMethodCallback processMethodCallback(final BlockingQueue<FlowletProcessEntry<?>> processQueue,\n                                                          final FlowletProcessEntry<T> processEntry,\n                                                          final InputDatum input) {\n    // If it is generator flowlet, processCount is 1.\n    final int processedCount = processEntry.getProcessSpec().getProcessMethod().needsInput() ? input.size() : 1;\n\n    return new ProcessMethodCallback() {\n      @Override\n      public void onSuccess(Object object, InputContext inputContext) {\n        try {\n          flowletContext.getSystemMetrics().gauge(\"process.events.processed\", processedCount);\n          txCallback.onSuccess(object, inputContext);\n        } catch (Throwable t) {\n          LOG.error(\"Exception on onSuccess call: {}\", flowletContext, t);\n        } finally {\n          enqueueEntry();\n          inflight.decrementAndGet();\n        }\n      }\n\n      @Override\n      public void onFailure(Object inputObject, InputContext inputContext, FailureReason reason,\n                            InputAcknowledger inputAcknowledger) {\n\n        LOG.warn(\"Process failure: {}, {}, input: {}\", flowletContext, reason.getMessage(), input, reason.getCause());\n        FailurePolicy failurePolicy;\n        try {\n          flowletContext.getSystemMetrics().gauge(\"process.errors\", 1);\n          failurePolicy = txCallback.onFailure(inputObject, inputContext, reason);\n          if (failurePolicy == null) {\n            failurePolicy = FailurePolicy.RETRY;\n            LOG.info(\"Callback returns null for failure policy. Default to {}.\", failurePolicy);\n          }\n        } catch (Throwable t) {\n          LOG.error(\"Exception on onFailure call: {}\", flowletContext, t);\n          failurePolicy = FailurePolicy.RETRY;\n        }\n\n        if (input.getRetry() >= processEntry.getProcessSpec().getProcessMethod().getMaxRetries()) {\n          LOG.info(\"Too many retries, ignores the input: {}\", input);\n          failurePolicy = FailurePolicy.IGNORE;\n        }\n\n        if (failurePolicy == FailurePolicy.RETRY) {\n          FlowletProcessEntry retryEntry = processEntry.isRetry() ?\n            processEntry :\n            FlowletProcessEntry.create(processEntry.getProcessSpec(),\n                                       new ProcessSpecification<T>(new SingleItemQueueReader(input),\n                                                                   processEntry.getProcessSpec().getInputDecoder(),\n                                                                   processEntry.getProcessSpec().getProcessMethod(),\n                                                                   null));\n          processQueue.offer(retryEntry);\n\n        } else if (failurePolicy == FailurePolicy.IGNORE) {\n          try {\n            flowletContext.getSystemMetrics().gauge(\"process.events.processed\", processedCount);\n            inputAcknowledger.ack();\n          } catch (TransactionFailureException e) {\n            LOG.error(\"Fatal problem, fail to ack an input: {}\", flowletContext, e);\n          } finally {\n            enqueueEntry();\n            inflight.decrementAndGet();\n          }\n        }\n      }\n\n      private void enqueueEntry() {\n        processQueue.offer(processEntry.resetRetry());\n      }\n    };\n  }","id":95857,"modified_method":"private <T> ProcessMethodCallback processMethodCallback(final BlockingQueue<FlowletProcessEntry<?>> processQueue,\n                                                          final FlowletProcessEntry<T> processEntry,\n                                                          final InputDatum input) {\n    // If it is generator flowlet, processCount is 1.\n    final int processedCount = processEntry.getProcessSpec().getProcessMethod().needsInput() ? input.size() : 1;\n\n    return new ProcessMethodCallback() {\n      @Override\n      public void onSuccess(Object object, InputContext inputContext) {\n        try {\n          gaugeEventProcessed(inputContext);\n          txCallback.onSuccess(object, inputContext);\n        } catch (Throwable t) {\n          LOG.error(\"Exception on onSuccess call: {}\", flowletContext, t);\n        } finally {\n          enqueueEntry();\n          inflight.decrementAndGet();\n        }\n      }\n\n      @Override\n      public void onFailure(Object inputObject, InputContext inputContext, FailureReason reason,\n                            InputAcknowledger inputAcknowledger) {\n\n        LOG.warn(\"Process failure: {}, {}, input: {}\", flowletContext, reason.getMessage(), input, reason.getCause());\n        FailurePolicy failurePolicy;\n        try {\n          flowletContext.getSystemMetrics().gauge(\"process.errors\", 1);\n          failurePolicy = txCallback.onFailure(inputObject, inputContext, reason);\n          if (failurePolicy == null) {\n            failurePolicy = FailurePolicy.RETRY;\n            LOG.info(\"Callback returns null for failure policy. Default to {}.\", failurePolicy);\n          }\n        } catch (Throwable t) {\n          LOG.error(\"Exception on onFailure call: {}\", flowletContext, t);\n          failurePolicy = FailurePolicy.RETRY;\n        }\n\n        if (input.getRetry() >= processEntry.getProcessSpec().getProcessMethod().getMaxRetries()) {\n          LOG.info(\"Too many retries, ignores the input: {}\", input);\n          failurePolicy = FailurePolicy.IGNORE;\n        }\n\n        if (failurePolicy == FailurePolicy.RETRY) {\n          FlowletProcessEntry retryEntry = processEntry.isRetry() ?\n            processEntry :\n            FlowletProcessEntry.create(processEntry.getProcessSpec(),\n                                       new ProcessSpecification<T>(new SingleItemQueueReader(input),\n                                                                   processEntry.getProcessSpec().getInputDecoder(),\n                                                                   processEntry.getProcessSpec().getProcessMethod(),\n                                                                   null));\n          processQueue.offer(retryEntry);\n\n        } else if (failurePolicy == FailurePolicy.IGNORE) {\n          try {\n            gaugeEventProcessed(inputContext);\n            inputAcknowledger.ack();\n          } catch (TransactionFailureException e) {\n            LOG.error(\"Fatal problem, fail to ack an input: {}\", flowletContext, e);\n          } finally {\n            enqueueEntry();\n            inflight.decrementAndGet();\n          }\n        }\n      }\n\n      private void enqueueEntry() {\n        processQueue.offer(processEntry.resetRetry());\n      }\n\n      private void gaugeEventProcessed(InputContext inputContext) {\n        QueueName inputQueueName = inputContext.getOriginQueueName();\n        if (inputQueueName == null) {\n          flowletContext.getSystemMetrics().gauge(\"process.events.processed\", processedCount);\n        } else {\n          String tag = \"input.\" + inputQueueName.toString();\n          flowletContext.getSystemMetrics().gauge(\"process.events.processed\", processedCount, tag);\n        }\n      }\n    };\n  }","commit_id":"b8f563199abc7cc500778b9edb740c155b4bc484","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testQueueLength() throws InterruptedException, IOException {\n    QueueName queueName = QueueName.fromFlowlet(\"flowId\", \"flowlet1\", \"out\");\n\n    // Insert queue metrics\n    MetricsCollector enqueueCollector = collectionService.getCollector(MetricsScope.REACTOR,\n                                                                       \"appId.f.flowId.flowlet1\", \"0\");\n    enqueueCollector.gauge(\"q.enqueue.\" + queueName.toString(), 10);\n\n    // Insert ack metrics\n    MetricsCollector ackCollector = collectionService.getCollector(MetricsScope.REACTOR,\n                                                                   \"appId.f.flowId.flowlet2\", \"0\");\n    ackCollector.gauge(\"q.ack.\" + queueName.toString(), 6);\n\n    // Wait for collection to happen\n    TimeUnit.SECONDS.sleep(2);\n\n    // Query for queue length\n    InetSocketAddress endpoint = getMetricsQueryEndpoint();\n    URLConnection urlConn = new URL(String.format(\"http://%s:%d/metrics\",\n                                                  endpoint.getHostName(),\n                                                  endpoint.getPort())).openConnection();\n    urlConn.setDoOutput(true);\n    urlConn.addRequestProperty(\"Content-type\", \"application/json\");\n    Writer writer = new OutputStreamWriter(urlConn.getOutputStream(), Charsets.UTF_8);\n    try {\n      new Gson().toJson(ImmutableList.of(\"/reactor/apps/appId\" +\n                          \"/flows/flowId/flowlets/flowlet2/process.events.pending?aggregate=true\"), writer);\n    } finally {\n      writer.close();\n    }\n    Reader reader = new InputStreamReader(urlConn.getInputStream(), Charsets.UTF_8);\n    try {\n      JsonElement json = new Gson().fromJson(reader, JsonElement.class);\n      // Expected result looks like\n      // [\n      //   {\n      //     \"path\":\"/process/events/appId/flows/flowId/flowlet2/pending?aggregate=true\",\n      //     \"result\":{\"data\":4}\n      //   }\n      // ]\n      JsonObject resultObj = json.getAsJsonArray().get(0).getAsJsonObject().get(\"result\").getAsJsonObject();\n      Assert.assertEquals(4, resultObj.getAsJsonPrimitive(\"data\").getAsInt());\n    } finally {\n      reader.close();\n    }\n  }","id":95858,"modified_method":"@Test\n  public void testQueueLength() throws InterruptedException, IOException {\n    QueueName queueName = QueueName.fromFlowlet(\"flowId\", \"flowlet1\", \"out\");\n\n    // Insert queue metrics\n    MetricsCollector enqueueCollector = collectionService.getCollector(MetricsScope.REACTOR,\n                                                                       \"appId.f.flowId.flowlet1\", \"0\");\n    enqueueCollector.gauge(\"process.events.out\", 10, queueName.getSimpleName());\n\n    // Insert ack metrics\n    MetricsCollector ackCollector = collectionService.getCollector(MetricsScope.REACTOR,\n                                                                   \"appId.f.flowId.flowlet2\", \"0\");\n    ackCollector.gauge(\"process.events.processed\", 6, \"input.\" + queueName.toString());\n\n    // Wait for collection to happen\n    TimeUnit.SECONDS.sleep(2);\n\n    // Query for queue length\n    InetSocketAddress endpoint = getMetricsQueryEndpoint();\n    URLConnection urlConn = new URL(String.format(\"http://%s:%d/metrics\",\n                                                  endpoint.getHostName(),\n                                                  endpoint.getPort())).openConnection();\n    urlConn.setDoOutput(true);\n    urlConn.addRequestProperty(\"Content-type\", \"application/json\");\n    Writer writer = new OutputStreamWriter(urlConn.getOutputStream(), Charsets.UTF_8);\n    try {\n      new Gson().toJson(ImmutableList.of(\"/reactor/apps/appId\" +\n                          \"/flows/flowId/flowlets/flowlet2/process.events.pending?aggregate=true\"), writer);\n    } finally {\n      writer.close();\n    }\n    Reader reader = new InputStreamReader(urlConn.getInputStream(), Charsets.UTF_8);\n    try {\n      JsonElement json = new Gson().fromJson(reader, JsonElement.class);\n      // Expected result looks like\n      // [\n      //   {\n      //     \"path\":\"/process/events/appId/flows/flowId/flowlet2/pending?aggregate=true\",\n      //     \"result\":{\"data\":4}\n      //   }\n      // ]\n      JsonObject resultObj = json.getAsJsonArray().get(0).getAsJsonObject().get(\"result\").getAsJsonObject();\n      Assert.assertEquals(4, resultObj.getAsJsonPrimitive(\"data\").getAsInt());\n    } finally {\n      reader.close();\n    }\n  }","commit_id":"b8f563199abc7cc500778b9edb740c155b4bc484","url":"https://github.com/caskdata/cdap"},{"original_method":"public Queue2InputDatum(final QueueName queueName, final DequeueResult result) {\n    this.result = result;\n    this.retry = new AtomicInteger(0);\n    this.inputContext = new InputContext() {\n      @Override\n      public String getOrigin() {\n        return queueName.getSimpleName();\n      }\n\n      @Override\n      public int getRetryCount() {\n        return retry.get();\n      }\n\n      @Override\n      public String toString() {\n        return Objects.toStringHelper(InputContext.class)\n          .add(\"queue\", queueName)\n          .toString();\n      }\n    };\n  }","id":95859,"modified_method":"public Queue2InputDatum(final QueueName queueName, final DequeueResult result) {\n    this.result = result;\n    this.retry = new AtomicInteger(0);\n    this.inputContext = new InputContext() {\n      @Override\n      public String getOrigin() {\n        return queueName.getSimpleName();\n      }\n\n      @Override\n      public QueueName getOriginQueueName() {\n        return queueName;\n      }\n\n      @Override\n      public int getRetryCount() {\n        return retry.get();\n      }\n\n      @Override\n      public String toString() {\n        return Objects.toStringHelper(InputContext.class)\n          .add(\"queue\", queueName)\n          .toString();\n      }\n    };\n  }","commit_id":"b8f563199abc7cc500778b9edb740c155b4bc484","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override protected void compute2() {\n      GLRMModel model = null;\n      DataInfo dinfo = null, xinfo = null, tinfo = null;\n      Frame fr = null;\n      boolean overwriteX = false;\n\n      try {\n        init(true);   // Initialize parameters\n        _parms.read_lock_frames(GLRM.this); // Fetch & read-lock input frames\n        if (error_count() > 0) throw new IllegalArgumentException(\"Found validation errors: \" + validationErrors());\n\n        // The model to be built\n        model = new GLRMModel(dest(), _parms, new GLRMModel.GLRMOutput(GLRM.this));\n        model.delete_and_lock(self());\n\n        // Save adapted frame info for scoring later\n        tinfo = new DataInfo(Key.make(), _train, _valid, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(tinfo._key, tinfo);\n\n        // Save training frame adaptation information for use in scoring later\n        model._output._normSub = tinfo._normSub == null ? new double[tinfo._nums] : tinfo._normSub;\n        if(tinfo._normMul == null) {\n          model._output._normMul = new double[tinfo._nums];\n          Arrays.fill(model._output._normMul, 1.0);\n        } else\n          model._output._normMul = tinfo._normMul;\n        model._output._permutation = tinfo._permutation;\n        model._output._nnums = tinfo._nums;\n        model._output._ncats = tinfo._cats;\n        model._output._catOffsets = tinfo._catOffsets;\n        model._output._names_expanded = tinfo.coefNames();\n\n        // Save loss function for each column in adapted frame order\n        assert _lossFunc != null && _lossFunc.length == _train.numCols();\n        model._output._lossFunc = new GLRMParameters.Loss[_lossFunc.length];\n        for (int i = 0; i < _lossFunc.length; i++)\n          model._output._lossFunc[i] = _lossFunc[tinfo._permutation[i]];\n\n        long nobs = _train.numRows() * _train.numCols();\n        long na_cnt = 0;\n        for(int i = 0; i < _train.numCols(); i++)\n          na_cnt += _train.vec(i).naCnt();\n        model._output._nobs = nobs - na_cnt;   // TODO: Should we count NAs?\n\n        // 0) Initialize Y and X matrices\n        // Jam A and X into a single frame for distributed computation\n        // [A,X,W] A is read-only training data, X is matrix from prior iteration, W is working copy of X this iteration\n        fr = new Frame(_train);\n        for (int i = 0; i < _ncolX; i++) fr.add(\"xcol_\" + i, fr.anyVec().makeZero());\n        for (int i = 0; i < _ncolX; i++) fr.add(\"wcol_\" + i, fr.anyVec().makeZero());\n        dinfo = new DataInfo(Key.make(), fr, null, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(dinfo._key, dinfo);\n\n        int weightId = dinfo._weights ? dinfo.weightChunkId() : -1;\n        int[] numLevels = tinfo._adaptedFrame.cardinality();\n\n        // Use closed form solution for X if quadratic loss and regularization\n        update(1, \"Initializing X and Y matrices\");   // One unit of work\n        double[/*k*/][/*features*/] yinit = initialXY(tinfo, dinfo._adaptedFrame, na_cnt);\n        Archetypes yt = new Archetypes(ArrayUtils.transpose(yinit), true, tinfo._catOffsets, numLevels);  // Store Y' for more efficient matrix ops (rows = features, cols = k rank)\n        if (_parms.hasClosedForm(na_cnt))\n          initialXClosedForm(dinfo, yt, model._output._normSub, model._output._normMul);\n\n        // Compute initial objective function\n        update(1, \"Computing initial objective function\");   // One unit of work\n        boolean regX = _parms._regularization_x != GLRMParameters.Regularizer.None && _parms._gamma_x != 0;  // Assume regularization on initial X is finite, else objective can be NaN if \\gamma_x = 0\n        ObjCalc objtsk = new ObjCalc(_parms, yt, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId, regX);\n        objtsk.doAll(dinfo._adaptedFrame);\n        model._output._objective = objtsk._loss + _parms._gamma_x * objtsk._xold_reg + _parms._gamma_y * _parms.regularize_y(yt._archetypes);\n        model._output._archetypes_raw = yt;\n        model._output._iterations = 0;\n        model._output._avg_change_obj = 2 * TOLERANCE;    // Run at least 1 iteration\n        model.update(self());  // Update model in K/V store\n\n        double step = _parms._init_step_size;   // Initial step size\n        int steps_in_row = 0;                   // Keep track of number of steps taken that decrease objective\n\n        while (!isDone(model, steps_in_row, step)) {\n          update(1, \"Iteration \" + String.valueOf(model._output._iterations+1) + \" of alternating minimization\");   // One unit of work\n\n          // TODO: Should step be divided by number of original or expanded (with 0/1 categorical) cols?\n          // 1) Update X matrix given fixed Y\n          UpdateX xtsk = new UpdateX(_parms, yt, step/_ncolA, overwriteX, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId);\n          xtsk.doAll(dinfo._adaptedFrame);\n          \n          // 2) Update Y matrix given fixed X\n          UpdateY ytsk = new UpdateY(_parms, yt, step/_ncolA, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId);\n          double[][] yttmp = ytsk.doAll(dinfo._adaptedFrame)._ytnew;\n          Archetypes ytnew = new Archetypes(yttmp, true, dinfo._catOffsets, numLevels);\n\n          // 3) Compute average change in objective function\n          objtsk = new ObjCalc(_parms, ytnew, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId);\n          objtsk.doAll(dinfo._adaptedFrame);\n          double obj_new = objtsk._loss + _parms._gamma_x * xtsk._xreg + _parms._gamma_y * ytsk._yreg;\n          model._output._avg_change_obj = (model._output._objective - obj_new) / nobs;\n          model._output._iterations++;\n\n          // step = 1.0 / model._output._iterations;   // Step size \\alpha_k = 1/iters\n          if(model._output._avg_change_obj > 0) {   // Objective decreased this iteration\n            yt = ytnew;\n            model._output._archetypes_raw = ytnew;  // Need full archetypes object for scoring\n            model._output._objective = obj_new;\n            step *= 1.05;\n            steps_in_row = Math.max(1, steps_in_row+1);\n            overwriteX = true;\n          } else {    // If objective increased, re-run with smaller step size\n            step = step / Math.max(1.5, -steps_in_row);\n            steps_in_row = Math.min(0, steps_in_row-1);\n            overwriteX = false;\n            if(_parms._verbose) {\n              Log.info(\"Iteration \" + model._output._iterations + \": Objective increased to \" + obj_new + \"; reducing step size to \" + step);\n              new ProgressUpdate(\"Iteration \" + model._output._iterations + \": Objective increased to \" + obj_new + \"; reducing step size to \" + step).fork(_progressKey);\n            }\n          }\n          model._output._step_size = step;\n          model.update(self()); // Update model in K/V store\n        }\n\n        // 4) Save solution to model output\n        // Save X frame for user reference later\n        Vec[] xvecs = new Vec[_ncolX];\n        String[] xnames = new String[_ncolX];\n        if(overwriteX) {\n          for (int i = 0; i < _ncolX; i++) {\n            xvecs[i] = fr.vec(idx_xnew(i, _ncolA, _ncolX));\n            xnames[i] = \"Arch\" + String.valueOf(i + 1);\n          }\n        } else {\n          for (int i = 0; i < _ncolX; i++) {\n            xvecs[i] = fr.vec(idx_xold(i, _ncolA));\n            xnames[i] = \"Arch\" + String.valueOf(i + 1);\n          }\n        }\n        model._output._loading_key = Key.make(_parms._loading_name);\n        Frame x = new Frame(model._output._loading_key, xnames, xvecs);\n        xinfo = new DataInfo(Key.make(), x, null, 0, true, DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(x._key, x);\n        DKV.put(xinfo._key, xinfo);\n\n        model._output._step_size = step;\n        model._output._archetypes = yt.buildTable(model._output._names_expanded, false);  // Transpose Y' to get original Y\n        if (_parms._recover_svd) recoverSVD(model, xinfo);\n\n        // Impute and compute error metrics on training/validation frame\n        model._output._training_metrics = model.scoreMetricsOnly(_parms.train());\n        if (_valid != null)\n          model._output._validation_metrics = model.scoreMetricsOnly(_parms.valid());\n        model._output._model_summary = createModelSummaryTable(model._output);\n        model.update(self());\n        done();\n      } catch (Throwable t) {\n        Job thisJob = DKV.getGet(_key);\n        if (thisJob._state == JobState.CANCELLED) {\n          Log.info(\"Job cancelled by user.\");\n        } else {\n          t.printStackTrace();\n          failed(t);\n          throw t;\n        }\n      } finally {\n        updateModelOutput();\n        _parms.read_unlock_frames(GLRM.this);\n        if (model != null) model.unlock(_key);\n        if (tinfo != null) tinfo.remove();\n        if (dinfo != null) dinfo.remove();\n        if (xinfo != null) xinfo.remove();\n\n        // if (x != null && !_parms._keep_loading) x.delete();\n        // Clean up unused copy of X matrix\n        if (fr != null) {\n          if(overwriteX) {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xold(i, _ncolA)).remove();\n          } else {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xnew(i, _ncolA, _ncolX)).remove();\n          }\n        }\n      }\n      tryComplete();\n    }","id":95860,"modified_method":"@Override protected void compute2() {\n      GLRMModel model = null;\n      DataInfo dinfo = null, xinfo = null, tinfo = null;\n      Frame fr = null;\n      boolean overwriteX = false;\n\n      try {\n        init(true);   // Initialize parameters\n        _parms.read_lock_frames(GLRM.this); // Fetch & read-lock input frames\n        if (error_count() > 0) throw new IllegalArgumentException(\"Found validation errors: \" + validationErrors());\n\n        // The model to be built\n        model = new GLRMModel(dest(), _parms, new GLRMModel.GLRMOutput(GLRM.this));\n        model.delete_and_lock(self());\n\n        // Save adapted frame info for scoring later\n        tinfo = new DataInfo(Key.make(), _train, _valid, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(tinfo._key, tinfo);\n\n        // Save training frame adaptation information for use in scoring later\n        model._output._normSub = tinfo._normSub == null ? new double[tinfo._nums] : tinfo._normSub;\n        if(tinfo._normMul == null) {\n          model._output._normMul = new double[tinfo._nums];\n          Arrays.fill(model._output._normMul, 1.0);\n        } else\n          model._output._normMul = tinfo._normMul;\n        model._output._permutation = tinfo._permutation;\n        model._output._nnums = tinfo._nums;\n        model._output._ncats = tinfo._cats;\n        model._output._catOffsets = tinfo._catOffsets;\n        model._output._names_expanded = tinfo.coefNames();\n\n        // Save loss function for each column in adapted frame order\n        assert _lossFunc != null && _lossFunc.length == _train.numCols();\n        model._output._lossFunc = new GLRMParameters.Loss[_lossFunc.length];\n        for (int i = 0; i < _lossFunc.length; i++)\n          model._output._lossFunc[i] = _lossFunc[tinfo._permutation[i]];\n\n        long nobs = _train.numRows() * _train.numCols();\n        long na_cnt = 0;\n        for(int i = 0; i < _train.numCols(); i++)\n          na_cnt += _train.vec(i).naCnt();\n        model._output._nobs = nobs - na_cnt;   // TODO: Should we count NAs?\n\n        // 0) Initialize Y and X matrices\n        // Jam A and X into a single frame for distributed computation\n        // [A,X,W] A is read-only training data, X is matrix from prior iteration, W is working copy of X this iteration\n        fr = new Frame(_train);\n        for (int i = 0; i < _ncolX; i++) fr.add(\"xcol_\" + i, fr.anyVec().makeZero());\n        for (int i = 0; i < _ncolX; i++) fr.add(\"wcol_\" + i, fr.anyVec().makeZero());\n        dinfo = new DataInfo(Key.make(), fr, null, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(dinfo._key, dinfo);\n\n        int weightId = dinfo._weights ? dinfo.weightChunkId() : -1;\n        int[] numLevels = tinfo._adaptedFrame.cardinality();\n\n        // Use closed form solution for X if quadratic loss and regularization\n        update(1, \"Initializing X and Y matrices\");   // One unit of work\n        double[/*k*/][/*features*/] yinit = initialXY(tinfo, dinfo._adaptedFrame, na_cnt);\n        Archetypes yt = new Archetypes(ArrayUtils.transpose(yinit), true, tinfo._catOffsets, numLevels);  // Store Y' for more efficient matrix ops (rows = features, cols = k rank)\n        if (_parms.hasClosedForm(na_cnt))\n          initialXClosedForm(dinfo, yt, model._output._normSub, model._output._normMul);\n\n        // Compute initial objective function\n        update(1, \"Computing initial objective function\");   // One unit of work\n        boolean regX = _parms._regularization_x != GLRMParameters.Regularizer.None && _parms._gamma_x != 0;  // Assume regularization on initial X is finite, else objective can be NaN if \\gamma_x = 0\n        ObjCalc objtsk = new ObjCalc(_parms, yt, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId, regX);\n        objtsk.doAll(dinfo._adaptedFrame);\n        model._output._objective = objtsk._loss + _parms._gamma_x * objtsk._xold_reg + _parms._gamma_y * _parms.regularize_y(yt._archetypes);\n        model._output._archetypes_raw = yt;\n        model._output._iterations = 0;\n        model._output._avg_change_obj = 2 * TOLERANCE;    // Run at least 1 iteration\n        model.update(self());  // Update model in K/V store\n\n        double step = _parms._init_step_size;   // Initial step size\n        int steps_in_row = 0;                   // Keep track of number of steps taken that decrease objective\n\n        while (!isDone(model, steps_in_row, step)) {\n          update(1, \"Iteration \" + String.valueOf(model._output._iterations+1) + \" of alternating minimization\");   // One unit of work\n\n          // TODO: Should step be divided by number of original or expanded (with 0/1 categorical) cols?\n          // 1) Update X matrix given fixed Y\n          UpdateX xtsk = new UpdateX(_parms, yt, step/_ncolA, overwriteX, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId);\n          xtsk.doAll(dinfo._adaptedFrame);\n          \n          // 2) Update Y matrix given fixed X\n          UpdateY ytsk = new UpdateY(_parms, yt, step/_ncolA, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId);\n          double[][] yttmp = ytsk.doAll(dinfo._adaptedFrame)._ytnew;\n          Archetypes ytnew = new Archetypes(yttmp, true, dinfo._catOffsets, numLevels);\n\n          // 3) Compute average change in objective function\n          objtsk = new ObjCalc(_parms, ytnew, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, model._output._lossFunc, weightId);\n          objtsk.doAll(dinfo._adaptedFrame);\n          double obj_new = objtsk._loss + _parms._gamma_x * xtsk._xreg + _parms._gamma_y * ytsk._yreg;\n          model._output._avg_change_obj = (model._output._objective - obj_new) / nobs;\n          model._output._iterations++;\n\n          // step = 1.0 / model._output._iterations;   // Step size \\alpha_k = 1/iters\n          if(model._output._avg_change_obj > 0) {   // Objective decreased this iteration\n            yt = ytnew;\n            model._output._archetypes_raw = ytnew;  // Need full archetypes object for scoring\n            model._output._objective = obj_new;\n            step *= 1.05;\n            steps_in_row = Math.max(1, steps_in_row+1);\n            overwriteX = true;\n          } else {    // If objective increased, re-run with smaller step size\n            step = step / Math.max(1.5, -steps_in_row);\n            steps_in_row = Math.min(0, steps_in_row-1);\n            overwriteX = false;\n            if(_parms._verbose) {\n              Log.info(\"Iteration \" + model._output._iterations + \": Objective increased to \" + obj_new + \"; reducing step size to \" + step);\n              new ProgressUpdate(\"Iteration \" + model._output._iterations + \": Objective increased to \" + obj_new + \"; reducing step size to \" + step).fork(_progressKey);\n            }\n          }\n          model._output._step_size = step;\n          model.update(self()); // Update model in K/V store\n        }\n\n        // 4) Save solution to model output\n        // Save X frame for user reference later\n        Vec[] xvecs = new Vec[_ncolX];\n        String[] xnames = new String[_ncolX];\n        if(overwriteX) {\n          for (int i = 0; i < _ncolX; i++) {\n            xvecs[i] = fr.vec(idx_xnew(i, _ncolA, _ncolX));\n            xnames[i] = \"Arch\" + String.valueOf(i + 1);\n          }\n        } else {\n          for (int i = 0; i < _ncolX; i++) {\n            xvecs[i] = fr.vec(idx_xold(i, _ncolA));\n            xnames[i] = \"Arch\" + String.valueOf(i + 1);\n          }\n        }\n        model._output._loading_key = Key.make(_parms._loading_name);\n        Frame x = new Frame(model._output._loading_key, xnames, xvecs);\n        xinfo = new DataInfo(Key.make(), x, null, 0, true, DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(x);\n        DKV.put(xinfo);\n\n        model._output._step_size = step;\n        model._output._archetypes = yt.buildTable(model._output._names_expanded, false);  // Transpose Y' to get original Y\n        if (_parms._recover_svd) recoverSVD(model, xinfo);\n\n        // Impute and compute error metrics on training/validation frame\n        model._output._training_metrics = model.scoreMetricsOnly(_parms.train());\n        if (_valid != null)\n          model._output._validation_metrics = model.scoreMetricsOnly(_parms.valid());\n        model._output._model_summary = createModelSummaryTable(model._output);\n        model.update(self());\n        done();\n      } catch (Throwable t) {\n        Job thisJob = DKV.getGet(_key);\n        if (thisJob._state == JobState.CANCELLED) {\n          Log.info(\"Job cancelled by user.\");\n        } else {\n          t.printStackTrace();\n          failed(t);\n          throw t;\n        }\n      } finally {\n        updateModelOutput();\n        _parms.read_unlock_frames(GLRM.this);\n        if (model != null) model.unlock(_key);\n        if (tinfo != null) tinfo.remove();\n        if (dinfo != null) dinfo.remove();\n        if (xinfo != null) xinfo.remove();\n\n        // if (x != null && !_parms._keep_loading) x.delete();\n        // Clean up unused copy of X matrix\n        if (fr != null) {\n          if(overwriteX) {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xold(i, _ncolA)).remove();\n          } else {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xnew(i, _ncolA, _ncolX)).remove();\n          }\n        }\n      }\n      tryComplete();\n    }","commit_id":"14dedf6dee5a33622f4d9a2be6d5b64627b8273c","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map(Chunk[] cs) {\n      assert (_ncolA + 2*_ncolX) == cs.length;\n      double[] a = new double[_ncolA];\n      Chunk chkweight = _weightId >= 0 ? cs[_weightId]:new C0DChunk(1,cs[0]._len);\n      Random rand = RandomUtils.getRNG(_parms._seed + cs[0].start());\n      _loss = _xreg = 0;\n\n      for(int row = 0; row < cs[0]._len; row++) {\n        double[] grad = new double[_ncolX];\n\n        // Additional user-specified weight on loss for this row\n        double cweight = chkweight.atd(row);\n        assert !Double.isNaN(cweight) : \"User-specified weight cannot be NaN\";\n\n        // Copy old working copy of X to current X if requested\n        if(_update) {\n          for(int k = 0; k < _ncolX; k++)\n            chk_xold(cs,k,_ncolA).set(row, chk_xnew(cs,k,_ncolA,_ncolX).atd(row));\n        }\n\n        // Compute gradient of objective at row\n        // Categorical columns\n        for(int j = 0; j < _ncats; j++) {\n          a[j] = cs[j].atd(row);\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n\n          // Calculate x_i * Y_j where Y_j is sub-matrix corresponding to categorical col j\n          double[] xy = new double[_yt._numLevels[j]];\n          for(int level = 0; level < xy.length; level++) {\n            for(int k = 0; k < _ncolX; k++) {\n              xy[level] += chk_xold(cs,k,_ncolA).atd(row) * _yt.getCat(j, level, k);\n            }\n          }\n\n          // Gradient wrt x_i is matrix product \\grad L_{i,j}(x_i * Y_j, A_{i,j}) * Y_j'\n          double[] weight = _parms.mlgrad(xy, (int) a[j], _lossFunc[j]);\n          double[][] ysub = _yt.getCatBlock(j);\n          for(int k = 0; k < _ncolX; k++) {\n            for(int c = 0; c < weight.length; c++)\n              grad[k] += cweight * weight[c] * ysub[k][c];\n          }\n        }\n\n        // Numeric columns\n        for(int j = _ncats; j < _ncolA; j++) {\n          int js = j - _ncats;\n          a[j] = cs[j].atd(row);\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n\n          // Inner product x_i * y_j\n          double xy = 0;\n          for(int k = 0; k < _ncolX; k++)\n            xy += chk_xold(cs,k,_ncolA).atd(row) * _yt.getNum(js, k);\n\n          // Sum over y_j weighted by gradient of loss \\grad L_{i,j}(x_i * y_j, A_{i,j})\n          double weight = cweight * _parms.lgrad(xy, (a[j] - _normSub[js]) * _normMul[js], _lossFunc[j]);\n          for(int k = 0; k < _ncolX; k++)\n            grad[k] += weight * _yt.getNum(js, k);\n        }\n\n        // Update row x_i of working copy with new values\n        double[] u = new double[_ncolX];\n        for(int k = 0; k < _ncolX; k++) {\n          double xold = chk_xold(cs,k,_ncolA).atd(row);   // Old value of x_i\n          u[k] = xold - _alpha * grad[k];\n          // xnew[k] = _parms.rproxgrad_x(xold - _alpha * grad[k], _alpha);  // Proximal gradient\n          // chk_xnew(cs,k,_ncolA,_ncolX).set(row, xnew[k]);\n          // _xreg += _parms.regularize_x(xnew[k]);\n        }\n        double[] xnew = _parms.rproxgrad_x(u, _alpha, rand);\n        _xreg += _parms.regularize_x(xnew);\n        for(int k = 0; k < _ncolX; k++)\n          chk_xnew(cs,k,_ncolA,_ncolX).set(row,xnew[k]);\n\n        // Compute loss function using new x_i\n        // Categorical columns\n        for(int j = 0; j < _ncats; j++) {\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n          double[] xy = ArrayUtils.multVecArr(xnew, _yt.getCatBlock(j));\n          _loss += _parms.mloss(xy, (int) a[j], _lossFunc[j]);\n        }\n\n        // Numeric columns\n        for(int j = _ncats; j < _ncolA; j++) {\n          int js = j - _ncats;\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n          double xy = _yt.lmulNumCol(xnew, js);\n          _loss += _parms.loss(xy, (a[j] - _normSub[js]) * _normMul[js], _lossFunc[j]);\n        }\n        _loss *= cweight;\n      }\n    }","id":95861,"modified_method":"@Override public void map(Chunk[] cs) {\n      assert (_ncolA + 2*_ncolX) == cs.length;\n      double[] a = new double[_ncolA];\n      Chunk chkweight = _weightId >= 0 ? cs[_weightId]:new C0DChunk(1,cs[0]._len);\n      Random rand = RandomUtils.getRNG(0);\n      _loss = _xreg = 0;\n\n      for(int row = 0; row < cs[0]._len; row++) {\n        rand.setSeed(_parms._seed + cs[0].start() + row); //global row ID determines the seed\n        double[] grad = new double[_ncolX];\n\n        // Additional user-specified weight on loss for this row\n        double cweight = chkweight.atd(row);\n        assert !Double.isNaN(cweight) : \"User-specified weight cannot be NaN\";\n\n        // Copy old working copy of X to current X if requested\n        if(_update) {\n          for(int k = 0; k < _ncolX; k++)\n            chk_xold(cs,k,_ncolA).set(row, chk_xnew(cs,k,_ncolA,_ncolX).atd(row));\n        }\n\n        // Compute gradient of objective at row\n        // Categorical columns\n        for(int j = 0; j < _ncats; j++) {\n          a[j] = cs[j].atd(row);\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n\n          // Calculate x_i * Y_j where Y_j is sub-matrix corresponding to categorical col j\n          double[] xy = new double[_yt._numLevels[j]];\n          for(int level = 0; level < xy.length; level++) {\n            for(int k = 0; k < _ncolX; k++) {\n              xy[level] += chk_xold(cs,k,_ncolA).atd(row) * _yt.getCat(j, level, k);\n            }\n          }\n\n          // Gradient wrt x_i is matrix product \\grad L_{i,j}(x_i * Y_j, A_{i,j}) * Y_j'\n          double[] weight = _parms.mlgrad(xy, (int) a[j], _lossFunc[j]);\n          double[][] ysub = _yt.getCatBlock(j);\n          for(int k = 0; k < _ncolX; k++) {\n            for(int c = 0; c < weight.length; c++)\n              grad[k] += cweight * weight[c] * ysub[k][c];\n          }\n        }\n\n        // Numeric columns\n        for(int j = _ncats; j < _ncolA; j++) {\n          int js = j - _ncats;\n          a[j] = cs[j].atd(row);\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n\n          // Inner product x_i * y_j\n          double xy = 0;\n          for(int k = 0; k < _ncolX; k++)\n            xy += chk_xold(cs,k,_ncolA).atd(row) * _yt.getNum(js, k);\n\n          // Sum over y_j weighted by gradient of loss \\grad L_{i,j}(x_i * y_j, A_{i,j})\n          double weight = cweight * _parms.lgrad(xy, (a[j] - _normSub[js]) * _normMul[js], _lossFunc[j]);\n          for(int k = 0; k < _ncolX; k++)\n            grad[k] += weight * _yt.getNum(js, k);\n        }\n\n        // Update row x_i of working copy with new values\n        double[] u = new double[_ncolX];\n        for(int k = 0; k < _ncolX; k++) {\n          double xold = chk_xold(cs,k,_ncolA).atd(row);   // Old value of x_i\n          u[k] = xold - _alpha * grad[k];\n          // xnew[k] = _parms.rproxgrad_x(xold - _alpha * grad[k], _alpha);  // Proximal gradient\n          // chk_xnew(cs,k,_ncolA,_ncolX).set(row, xnew[k]);\n          // _xreg += _parms.regularize_x(xnew[k]);\n        }\n        double[] xnew = _parms.rproxgrad_x(u, _alpha, rand);\n        _xreg += _parms.regularize_x(xnew);\n        for(int k = 0; k < _ncolX; k++)\n          chk_xnew(cs,k,_ncolA,_ncolX).set(row,xnew[k]);\n\n        // Compute loss function using new x_i\n        // Categorical columns\n        for(int j = 0; j < _ncats; j++) {\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n          double[] xy = ArrayUtils.multVecArr(xnew, _yt.getCatBlock(j));\n          _loss += _parms.mloss(xy, (int) a[j], _lossFunc[j]);\n        }\n\n        // Numeric columns\n        for(int j = _ncats; j < _ncolA; j++) {\n          int js = j - _ncats;\n          if(Double.isNaN(a[j])) continue;   // Skip missing observations in row\n          double xy = _yt.lmulNumCol(xnew, js);\n          _loss += _parms.loss(xy, (a[j] - _normSub[js]) * _normMul[js], _lossFunc[j]);\n        }\n        _loss *= cweight;\n      }\n    }","commit_id":"14dedf6dee5a33622f4d9a2be6d5b64627b8273c","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map( Chunk chks[] ) {\n      Random rand = RandomUtils.getRNG(_parms._seed + chks[0].start());\n\n      for(int row = 0; row < chks[0]._len; row++) {\n        double xrow[] = ArrayUtils.gaussianVector(_ncolX, _parms._seed);\n        xrow = _parms.project_x(xrow, rand);\n        for(int c = 0; c < xrow.length; c++) {\n          chks[_ncolA+c].set(row, xrow[c]);\n          chks[_ncolA+_ncolX+c].set(row, xrow[c]);\n        }\n      }\n    }","id":95862,"modified_method":"@Override public void map( Chunk chks[] ) {\n      Random rand = RandomUtils.getRNG(0);\n\n      for(int row = 0; row < chks[0]._len; row++) {\n        double xrow[] = ArrayUtils.gaussianVector(_ncolX, _parms._seed);\n        rand.setSeed(_parms._seed + chks[0].start() + row); //global row ID determines the seed\n        xrow = _parms.project_x(xrow, rand);\n        for(int c = 0; c < xrow.length; c++) {\n          chks[_ncolA+c].set(row, xrow[c]);\n          chks[_ncolA+_ncolX+c].set(row, xrow[c]);\n        }\n      }\n    }","commit_id":"5ccc4699f3c71dccb64f7c11fac5a91ddff514ba","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private double[][] initialXY(DataInfo tinfo, Frame dfrm, long na_cnt) {\n      double[][] centers, centers_exp = null;\n      Random rand = RandomUtils.getRNG(_parms._seed);\n\n      if (_parms._init == Initialization.User) { // Set X and Y to user-specified points if available, Gaussian matrix if not\n        if (null != _parms._user_y) {   // Set Y = user-specified initial points\n          Vec[] yVecs = _parms._user_y.get().vecs();\n          centers = new double[_parms._k][_ncolA];\n\n          // Get the centers and put into array\n          for (int c = 0; c < _ncolA; c++) {\n            for (int r = 0; r < _parms._k; r++)\n              centers[r][c] = yVecs[c].at(r);\n          }\n\n          // Permute cluster columns to align with dinfo and expand out categoricals\n          centers = ArrayUtils.permuteCols(centers, tinfo._permutation);\n          centers_exp = expandCats(centers, tinfo);\n        } else\n          centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n\n        if (null != _parms._user_x) {   // Set X = user-specified initial points\n          Frame tmp = new Frame(dfrm);\n          tmp.add(_parms._user_x.get());   // [A,X,W,U] where U = user-specified X\n\n          // Set X and W to the same values as user-specified initial X\n          new MRTask() {\n            @Override public void map(Chunk[] cs) {\n              for(int row = 0; row < cs[0]._len; row++) {\n                for (int i = _ncolA; i < _ncolA+_ncolX; i++) {\n                  double x = cs[2*_ncolX + i].atd(row);\n                  cs[i].set(row, x);\n                  cs[_ncolX + i].set(row, x);\n                }\n              }\n            }\n          }.doAll(tmp);\n        } else {\n          InitialXProj xtsk = new InitialXProj(_parms, _ncolA, _ncolX);\n          xtsk.doAll(dfrm);\n        }\n        return centers_exp;   // Don't project or change Y in any way if user-specified, just return it\n\n      } else if (_parms._init == Initialization.Random) {  // Generate X and Y from standard normal distribution\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n        InitialXProj xtsk = new InitialXProj(_parms, _ncolA, _ncolX);\n        xtsk.doAll(dfrm);\n\n      } else if (_parms._init == Initialization.SVD) {  // Run SVD on A'A/n (Gram) and set Y = right singular vectors\n        SVDParameters parms = new SVDParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._use_all_factor_levels = true;   // Since GLRM requires Y matrix to have fully expanded ncols\n        parms._nv = _parms._k;\n        parms._transform = _parms._transform;\n        parms._svd_method = _parms._svd_method;\n        parms._max_iterations = parms._svd_method == SVDParameters.Method.Randomized ? _parms._k : _parms._max_iterations;\n        parms._seed = _parms._seed;\n        parms._keep_u = true;\n        parms._impute_missing = true;\n        parms._save_v_frame = false;\n\n        SVDModel svd = null;\n        SVD job = null;\n        try {\n          job = new EmbeddedSVD(_key, _progressKey, parms);\n          svd = job.trainModel().get();\n\n          // Ensure SVD centers align with adapted training frame cols\n          assert svd._output._permutation.length == tinfo._permutation.length;\n          for(int i = 0; i < tinfo._permutation.length; i++)\n            assert svd._output._permutation[i] == tinfo._permutation[i];\n          centers_exp = ArrayUtils.transpose(svd._output._v);\n\n          // Set X and Y appropriately given SVD of A = UDV'\n          // a) Set Y = D^(1/2)V'S where S = diag(\\sigma)\n          final double[] dsqrt = new double[_parms._k];\n          for(int i = 0; i < _parms._k; i++) {\n            dsqrt[i] = Math.sqrt(svd._output._d[i]);\n            ArrayUtils.mult(centers_exp[i], dsqrt[i]);  // This gives one row of D^(1/2)V'\n          }\n\n          // b) Set X = UD^(1/2) = AVD^(-1/2)\n          Frame uFrm = DKV.get(svd._output._u_key).get();\n          assert uFrm.numCols() == _parms._k;\n          Frame fullFrm = (new Frame(uFrm)).add(dfrm);  // Jam matrices together into frame [U,A,X,W]\n          InitialXSVD xtsk = new InitialXSVD(dsqrt, _parms._k, _ncolA, _ncolX);\n          xtsk.doAll(fullFrm);\n        } finally {\n          if (job != null) job.remove();\n          if (svd != null) {\n            if(svd._parms._keep_u)\n              svd._output._u_key.get().delete();\n            svd.remove();\n          }\n        }\n\n      } else if (_parms._init == Initialization.PlusPlus) {  // Run k-means++ and set Y = resulting cluster centers, X = indicator matrix of assignments\n        KMeansModel.KMeansParameters parms = new KMeansModel.KMeansParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._init = KMeans.Initialization.PlusPlus;\n        parms._k = _parms._k;\n        parms._max_iterations = _parms._max_iterations;\n        parms._standardize = true;\n        parms._seed = _parms._seed;\n        parms._pred_indicator = true;\n\n        KMeansModel km = null;\n        KMeans job = null;\n        try {\n          job = new EmbeddedKMeans(_key, _progressKey, parms);\n          km = job.trainModel().get();\n\n          // Score only if clusters well-defined and closed-form solution does not exist\n          double frob = frobenius2(km._output._centers_raw);\n          if(frob != 0 && !Double.isNaN(frob) && !_parms.hasClosedForm(na_cnt)) {\n            // Frame pred = km.score(_parms.train());\n            Log.info(\"Initializing X to matrix of weights inversely correlated with cluster distances\");\n            InitialXKMeans xtsk = new InitialXKMeans(_parms, km, _ncolA, _ncolX);\n            xtsk.doAll(dfrm);\n          }\n        } finally {\n          if (job != null) job.remove();\n          if (km != null) km.remove();\n        }\n\n        // Permute cluster columns to align with dinfo, normalize nums, and expand out cats to indicator cols\n        centers = ArrayUtils.permuteCols(km._output._centers_raw, tinfo.mapNames(km._output._names));\n        centers = transform(centers, tinfo._normSub, tinfo._normMul, tinfo._cats, tinfo._nums);\n        centers_exp = expandCats(centers, tinfo);\n      } else\n        error(\"_init\", \"Initialization method \" + _parms._init + \" is undefined\");\n\n      // If all centers are zero or any are NaN, initialize to standard Gaussian random matrix\n      assert centers_exp != null && centers_exp.length == _parms._k && centers_exp[0].length == _ncolY : \"Y must have \" + _parms._k + \" rows and \" + _ncolY + \" columns\";\n      double frob = frobenius2(centers_exp);   // TODO: Don't need to calculate twice if k-means++\n      if(frob == 0 || Double.isNaN(frob)) {\n        warn(\"_init\", \"Initialization failed. Setting initial Y to standard normal random matrix instead\");\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n      }\n\n      // Project rows of Y into appropriate subspace for regularizer\n      for(int i = 0; i < _parms._k; i++)\n        centers_exp[i] = _parms.project_y(centers_exp[i], rand);\n      return centers_exp;\n    }","id":95863,"modified_method":"private double[][] initialXY(DataInfo tinfo, Frame dfrm, long na_cnt) {\n      double[][] centers, centers_exp = null;\n\n      if (_parms._init == Initialization.User) { // Set X and Y to user-specified points if available, Gaussian matrix if not\n        if (null != _parms._user_y) {   // Set Y = user-specified initial points\n          Vec[] yVecs = _parms._user_y.get().vecs();\n          centers = new double[_parms._k][_ncolA];\n\n          // Get the centers and put into array\n          for (int c = 0; c < _ncolA; c++) {\n            for (int r = 0; r < _parms._k; r++)\n              centers[r][c] = yVecs[c].at(r);\n          }\n\n          // Permute cluster columns to align with dinfo and expand out categoricals\n          centers = ArrayUtils.permuteCols(centers, tinfo._permutation);\n          centers_exp = expandCats(centers, tinfo);\n        } else\n          centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n\n        if (null != _parms._user_x) {   // Set X = user-specified initial points\n          Frame tmp = new Frame(dfrm);\n          tmp.add(_parms._user_x.get());   // [A,X,W,U] where U = user-specified X\n\n          // Set X and W to the same values as user-specified initial X\n          new MRTask() {\n            @Override public void map(Chunk[] cs) {\n              for(int row = 0; row < cs[0]._len; row++) {\n                for (int i = _ncolA; i < _ncolA+_ncolX; i++) {\n                  double x = cs[2*_ncolX + i].atd(row);\n                  cs[i].set(row, x);\n                  cs[_ncolX + i].set(row, x);\n                }\n              }\n            }\n          }.doAll(tmp);\n        } else {\n          InitialXProj xtsk = new InitialXProj(_parms, _ncolA, _ncolX);\n          xtsk.doAll(dfrm);\n        }\n        return centers_exp;   // Don't project or change Y in any way if user-specified, just return it\n\n      } else if (_parms._init == Initialization.Random) {  // Generate X and Y from standard normal distribution\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n        InitialXProj xtsk = new InitialXProj(_parms, _ncolA, _ncolX);\n        xtsk.doAll(dfrm);\n\n      } else if (_parms._init == Initialization.SVD) {  // Run SVD on A'A/n (Gram) and set Y = right singular vectors\n        SVDParameters parms = new SVDParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._use_all_factor_levels = true;   // Since GLRM requires Y matrix to have fully expanded ncols\n        parms._nv = _parms._k;\n        parms._transform = _parms._transform;\n        parms._svd_method = _parms._svd_method;\n        parms._max_iterations = parms._svd_method == SVDParameters.Method.Randomized ? _parms._k : _parms._max_iterations;\n        parms._seed = _parms._seed;\n        parms._keep_u = true;\n        parms._impute_missing = true;\n        parms._save_v_frame = false;\n\n        SVDModel svd = null;\n        SVD job = null;\n        try {\n          job = new EmbeddedSVD(_key, _progressKey, parms);\n          svd = job.trainModel().get();\n\n          // Ensure SVD centers align with adapted training frame cols\n          assert svd._output._permutation.length == tinfo._permutation.length;\n          for(int i = 0; i < tinfo._permutation.length; i++)\n            assert svd._output._permutation[i] == tinfo._permutation[i];\n          centers_exp = ArrayUtils.transpose(svd._output._v);\n\n          // Set X and Y appropriately given SVD of A = UDV'\n          // a) Set Y = D^(1/2)V'S where S = diag(\\sigma)\n          final double[] dsqrt = new double[_parms._k];\n          for(int i = 0; i < _parms._k; i++) {\n            dsqrt[i] = Math.sqrt(svd._output._d[i]);\n            ArrayUtils.mult(centers_exp[i], dsqrt[i]);  // This gives one row of D^(1/2)V'\n          }\n\n          // b) Set X = UD^(1/2) = AVD^(-1/2)\n          Frame uFrm = DKV.get(svd._output._u_key).get();\n          assert uFrm.numCols() == _parms._k;\n          Frame fullFrm = (new Frame(uFrm)).add(dfrm);  // Jam matrices together into frame [U,A,X,W]\n          InitialXSVD xtsk = new InitialXSVD(dsqrt, _parms._k, _ncolA, _ncolX);\n          xtsk.doAll(fullFrm);\n        } finally {\n          if (job != null) job.remove();\n          if (svd != null) {\n            if(svd._parms._keep_u)\n              svd._output._u_key.get().delete();\n            svd.remove();\n          }\n        }\n\n      } else if (_parms._init == Initialization.PlusPlus) {  // Run k-means++ and set Y = resulting cluster centers, X = indicator matrix of assignments\n        KMeansModel.KMeansParameters parms = new KMeansModel.KMeansParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._init = KMeans.Initialization.PlusPlus;\n        parms._k = _parms._k;\n        parms._max_iterations = _parms._max_iterations;\n        parms._standardize = true;\n        parms._seed = _parms._seed;\n        parms._pred_indicator = true;\n\n        KMeansModel km = null;\n        KMeans job = null;\n        try {\n          job = new EmbeddedKMeans(_key, _progressKey, parms);\n          km = job.trainModel().get();\n\n          // Score only if clusters well-defined and closed-form solution does not exist\n          double frob = frobenius2(km._output._centers_raw);\n          if(frob != 0 && !Double.isNaN(frob) && !_parms.hasClosedForm(na_cnt)) {\n            // Frame pred = km.score(_parms.train());\n            Log.info(\"Initializing X to matrix of weights inversely correlated with cluster distances\");\n            InitialXKMeans xtsk = new InitialXKMeans(_parms, km, _ncolA, _ncolX);\n            xtsk.doAll(dfrm);\n          }\n        } finally {\n          if (job != null) job.remove();\n          if (km != null) km.remove();\n        }\n\n        // Permute cluster columns to align with dinfo, normalize nums, and expand out cats to indicator cols\n        centers = ArrayUtils.permuteCols(km._output._centers_raw, tinfo.mapNames(km._output._names));\n        centers = transform(centers, tinfo._normSub, tinfo._normMul, tinfo._cats, tinfo._nums);\n        centers_exp = expandCats(centers, tinfo);\n      } else\n        error(\"_init\", \"Initialization method \" + _parms._init + \" is undefined\");\n\n      // If all centers are zero or any are NaN, initialize to standard Gaussian random matrix\n      assert centers_exp != null && centers_exp.length == _parms._k && centers_exp[0].length == _ncolY : \"Y must have \" + _parms._k + \" rows and \" + _ncolY + \" columns\";\n      double frob = frobenius2(centers_exp);   // TODO: Don't need to calculate twice if k-means++\n      if(frob == 0 || Double.isNaN(frob)) {\n        warn(\"_init\", \"Initialization failed. Setting initial Y to standard normal random matrix instead\");\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n      }\n\n      // Project rows of Y into appropriate subspace for regularizer\n      Random rand = RandomUtils.getRNG(_parms._seed);\n      for(int i = 0; i < _parms._k; i++)\n        centers_exp[i] = _parms.project_y(centers_exp[i], rand);\n      return centers_exp;\n    }","commit_id":"5ccc4699f3c71dccb64f7c11fac5a91ddff514ba","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map( Chunk chks[] ) {\n      double tmp [] = new double[_ncolA];\n      Random rand = RandomUtils.getRNG(_parms._seed + chks[0].start());\n\n      for(int row = 0; row < chks[0]._len; row++) {\n        // double preds[] = new double[_ncolX];\n        // double p[] = _model.score_indicator(chks, row, tmp, preds);\n        double p[] = _model.score_ratio(chks, row, tmp);\n        p = _parms.project_x(p, rand);  // TODO: Should we restrict indicator cols to regularizer subspace?\n        for(int c = 0; c < p.length; c++) {\n          chks[_ncolA+c].set(row, p[c]);\n          chks[_ncolA+_ncolX+c].set(row, p[c]);\n        }\n      }\n    }","id":95864,"modified_method":"@Override public void map( Chunk chks[] ) {\n      double tmp [] = new double[_ncolA];\n      Random rand = RandomUtils.getRNG(0);\n\n      for(int row = 0; row < chks[0]._len; row++) {\n        // double preds[] = new double[_ncolX];\n        // double p[] = _model.score_indicator(chks, row, tmp, preds);\n        double p[] = _model.score_ratio(chks, row, tmp);\n        rand.setSeed(_parms._seed + chks[0].start() + row); //global row ID determines the seed\n        p = _parms.project_x(p, rand);  // TODO: Should we restrict indicator cols to regularizer subspace?\n        for(int c = 0; c < p.length; c++) {\n          chks[_ncolA+c].set(row, p[c]);\n          chks[_ncolA+_ncolX+c].set(row, p[c]);\n        }\n      }\n    }","commit_id":"5ccc4699f3c71dccb64f7c11fac5a91ddff514ba","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject( workingMemoryContext );\n            out.writeObject( betaMemory );\n            out.writeObject( resultsContext );\n            out.writeObject( alphaContexts );\n        }","id":95865,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject( workingMemoryContext );\n            out.writeObject( betaMemory );\n            out.writeObject( resultMap );\n            out.writeObject( resultsContext );\n            out.writeObject( alphaContexts );\n        }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        final Iterator it = memory.betaMemory.getCreatedHandles().iterator();\n\n        for ( ObjectEntry entry = (ObjectEntry) it.next(); entry != null; entry = (ObjectEntry) it.next() ) {\n            AccumulateResult accresult = (AccumulateResult) entry.getValue();\n            sink.assertLeftTuple( new LeftTuple( (LeftTuple) entry.getKey(),\n                                                 accresult.handle ),\n                                  context,\n                                  workingMemory );\n        }\n    }","id":95866,"modified_method":"public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        final Iterator tupleIter = memory.betaMemory.getLeftTupleMemory().iterator();\n        for ( LeftTuple leftTuple = (LeftTuple) tupleIter.next(); leftTuple != null; leftTuple = (LeftTuple) tupleIter.next() ) {\n            RightTuple rightTuple = leftTuple.getBetaChildren().getRightParent();\n            sink.assertLeftTuple( new LeftTuple( leftTuple,\n                                                 rightTuple,\n                                                 sink ),\n                                  context,\n                                  workingMemory );\n        }\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Creates a BetaMemory for the BetaNode's memory.\n     */\n    public Object createMemory(final RuleBaseConfiguration config) {\n        AccumulateMemory memory = new AccumulateMemory();\n        memory.betaMemory = this.constraints.createBetaMemory( config );\n        memory.workingMemoryContext = this.accumulate.createWorkingMemoryContext();\n        memory.resultsContext = this.resultBinder.createContext();\n        memory.alphaContexts = new ContextEntry[this.resultConstraints.length];\n        for ( int i = 0; i < this.resultConstraints.length; i++ ) {\n            memory.alphaContexts[i] = this.resultConstraints[i].createContextEntry();\n        }\n        return memory;\n    }","id":95867,"modified_method":"/**\n     * Creates a BetaMemory for the BetaNode's memory.\n     */\n    public Object createMemory(final RuleBaseConfiguration config) {\n        AccumulateMemory memory = new AccumulateMemory();\n        memory.betaMemory = this.constraints.createBetaMemory( config );\n        memory.resultMap = new ObjectHashMap();\n        memory.workingMemoryContext = this.accumulate.createWorkingMemoryContext();\n        memory.resultsContext = this.resultBinder.createContext();\n        memory.alphaContexts = new ContextEntry[this.resultConstraints.length];\n        for ( int i = 0; i < this.resultConstraints.length; i++ ) {\n            memory.alphaContexts[i] = this.resultConstraints[i].createContextEntry();\n        }\n        return memory;\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void modifyTuple(final boolean isAssert,\n                            final LeftTuple leftTuple,\n                            InternalFactHandle handle,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        AccumulateResult accresult = (AccumulateResult) memory.betaMemory.getCreatedHandles().get( leftTuple );\n\n        // if tuple was propagated\n        if ( accresult.handle != null ) {\n            this.sink.propagateRetractLeftTuple( leftTuple,\n                                                 accresult.handle,\n                                                 context,\n                                                 workingMemory );\n\n            // Destroying the acumulate result object\n            workingMemory.getFactHandleFactory().destroyFactHandle( accresult.handle );\n            accresult.handle = null;\n        }\n\n        LeftTuple tuple = leftTuple;\n        if ( this.unwrapRightObject ) {\n            // if there is a subnetwork, handle must be unwrapped\n            tuple = (LeftTuple) handle.getObject();\n            handle = tuple.getLastHandle();\n        }\n\n        if ( context.getType() == PropagationContext.ASSERTION ) {\n            // assertion\n            if ( accresult.context == null ) {\n                final Object accContext = this.accumulate.createContext();\n\n                this.accumulate.init( memory.workingMemoryContext,\n                                      accContext,\n                                      leftTuple,\n                                      workingMemory );\n\n                accresult.context = accContext;\n            }\n\n            this.accumulate.accumulate( memory.workingMemoryContext,\n                                        accresult.context,\n                                        tuple,\n                                        handle,\n                                        workingMemory );\n        } else if ( context.getType() == PropagationContext.MODIFICATION || context.getType() == PropagationContext.RULE_ADDITION || context.getType() == PropagationContext.RULE_REMOVAL ) {\n            // modification\n            if ( isAssert ) {\n                this.accumulate.accumulate( memory.workingMemoryContext,\n                                            accresult.context,\n                                            tuple,\n                                            handle,\n                                            workingMemory );\n            } else {\n                this.accumulate.reverse( memory.workingMemoryContext,\n                                         accresult.context,\n                                         tuple,\n                                         handle,\n                                         workingMemory );\n            }\n        } else {\n            // retraction\n            this.accumulate.reverse( memory.workingMemoryContext,\n                                     accresult.context,\n                                     tuple,\n                                     handle,\n                                     workingMemory );\n        }\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accresult.context,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        final InternalFactHandle createdHandle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                                     false,\n                                                                                                     workingMemory ); // so far, result is not an event\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( createdHandle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultBinder.updateFromTuple( memory.resultsContext,\n                                               workingMemory,\n                                               leftTuple );\n            if ( this.resultBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                        createdHandle ) ) {\n                accresult.handle = createdHandle;\n\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    createdHandle,\n                                                    context,\n                                                    workingMemory );\n            } else {\n                workingMemory.getFactHandleFactory().destroyFactHandle( createdHandle );\n            }\n\n            this.resultBinder.resetTuple( memory.resultsContext );\n        } else {\n            workingMemory.getFactHandleFactory().destroyFactHandle( createdHandle );\n        }\n    }","id":95868,"modified_method":"public void modifyTuple(final boolean isAssert,\n                            final LeftTuple leftTuple,\n                            InternalFactHandle handle,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        AccumulateResult accresult = (AccumulateResult) memory.resultMap.get( leftTuple );\n\n        // if tuple was propagated\n        this.sink.propagateRetractLeftTupleDestroyRightTuple( leftTuple,\n                                                              context,\n                                                              workingMemory );\n\n        LeftTuple tuple = leftTuple;\n        if ( this.unwrapRightObject ) {\n            // if there is a subnetwork, handle must be unwrapped\n            tuple = (LeftTuple) handle.getObject();\n            handle = tuple.getLastHandle();\n        }\n\n        if ( context.getType() == PropagationContext.ASSERTION ) {\n            // assertion\n            if ( accresult.context == null ) {\n                final Object accContext = this.accumulate.createContext();\n\n                this.accumulate.init( memory.workingMemoryContext,\n                                      accContext,\n                                      leftTuple,\n                                      workingMemory );\n\n                accresult.context = accContext;\n            }\n\n            this.accumulate.accumulate( memory.workingMemoryContext,\n                                        accresult.context,\n                                        tuple,\n                                        handle,\n                                        workingMemory );\n        } else if ( context.getType() == PropagationContext.MODIFICATION || context.getType() == PropagationContext.RULE_ADDITION || context.getType() == PropagationContext.RULE_REMOVAL ) {\n            // modification\n            if ( isAssert ) {\n                this.accumulate.accumulate( memory.workingMemoryContext,\n                                            accresult.context,\n                                            tuple,\n                                            handle,\n                                            workingMemory );\n            } else {\n                this.accumulate.reverse( memory.workingMemoryContext,\n                                         accresult.context,\n                                         tuple,\n                                         handle,\n                                         workingMemory );\n            }\n        } else {\n            // retraction\n            this.accumulate.reverse( memory.workingMemoryContext,\n                                     accresult.context,\n                                     tuple,\n                                     handle,\n                                     workingMemory );\n        }\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accresult.context,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        final InternalFactHandle createdHandle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                                     false,\n                                                                                                     workingMemory ); // so far, result is not an event\n        \n        final RightTuple resultTuple = new RightTuple( handle,\n                                                       this );\n        \n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( createdHandle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultBinder.updateFromTuple( memory.resultsContext,\n                                               workingMemory,\n                                               leftTuple );\n            if ( this.resultBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                        createdHandle ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    resultTuple,\n                                                    context,\n                                                    workingMemory );\n            } else {\n                workingMemory.getFactHandleFactory().destroyFactHandle( createdHandle );\n            }\n\n            this.resultBinder.resetTuple( memory.resultsContext );\n        } else {\n            workingMemory.getFactHandleFactory().destroyFactHandle( createdHandle );\n        }\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void readExternal(ObjectInput in) throws IOException,\n                                                ClassNotFoundException {\n            workingMemoryContext = in.readObject();\n            betaMemory = (BetaMemory) in.readObject();\n            resultsContext = (ContextEntry[]) in.readObject();\n            alphaContexts = (ContextEntry[]) in.readObject();\n        }","id":95869,"modified_method":"public void readExternal(ObjectInput in) throws IOException,\n                                                ClassNotFoundException {\n            workingMemoryContext = in.readObject();\n            betaMemory = (BetaMemory) in.readObject();\n            resultMap = (ObjectHashMap) in.readObject();\n            resultsContext = (ContextEntry[]) in.readObject();\n            alphaContexts = (ContextEntry[]) in.readObject();\n        }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     *\n     *  When a new object is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching tuples from left memory\n     *  2. For each matching tuple, call a modify tuple\n     *\n     */\n    public void assertObject(final InternalFactHandle factHandle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getRightTupleMemory().add( factHandle );\n\n        if ( !this.tupleMemoryEnabled ) {\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( memory.betaMemory.getContext(),\n                                               workingMemory,\n                                               factHandle );\n\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.betaMemory.getLeftTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            LeftTuple tuple = (LeftTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( memory.betaMemory.getContext(),\n                                                        tuple ) ) {\n                if ( this.accumulate.supportsReverse() || context.getType() == PropagationContext.ASSERTION ) {\n                    modifyTuple( true,\n                                 tuple,\n                                 factHandle,\n                                 context,\n                                 workingMemory );\n                } else {\n                    // context is MODIFICATION and does not supports reverse\n                    this.retractLeftTuple( tuple,\n                                           context,\n                                           workingMemory );\n                    this.assertLeftTuple( tuple,\n                                          context,\n                                          workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.betaMemory.getContext() );\n    }","id":95870,"modified_method":"/**\n     * @inheritDoc\n     *\n     *  When a new object is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching tuples from left memory\n     *  2. For each matching tuple, call a modify tuple\n     *\n     */\n    public void assertObject(final InternalFactHandle factHandle,\n                             final PropagationContext context,\n                             final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        final RightTuple rightTuple = new RightTuple( factHandle,\n                                                      this );        \n        memory.betaMemory.getRightTupleMemory().add( rightTuple );\n\n        if ( !this.tupleMemoryEnabled ) {\n            // do nothing here, as we know there are no left tuples at this stage in sequential mode.\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( memory.betaMemory.getContext(),\n                                               workingMemory,\n                                               factHandle );\n\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.betaMemory.getLeftTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            LeftTuple tuple = (LeftTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( memory.betaMemory.getContext(),\n                                                        tuple ) ) {\n                if ( this.accumulate.supportsReverse() || context.getType() == PropagationContext.ASSERTION ) {\n                    modifyTuple( true,\n                                 tuple,\n                                 factHandle,\n                                 context,\n                                 workingMemory );\n                } else {\n                    // context is MODIFICATION and does not supports reverse\n                    this.retractLeftTuple( tuple,\n                                           context,\n                                           workingMemory );\n                    this.assertLeftTuple( tuple,\n                                          context,\n                                          workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.betaMemory.getContext() );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject( handle );\n            out.writeObject( context );\n        }","id":95871,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject( context );\n        }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     *  @inheritDoc\n     *\n     *  If an object is retract, call modify tuple for each\n     *  tuple match.\n     */\n    public void retractObject(final InternalFactHandle handle,\n                              final PropagationContext context,\n                              final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        if ( !memory.betaMemory.getRightTupleMemory().remove( handle ) ) {\n            return;\n        }\n\n        this.constraints.updateFromFactHandle( memory.betaMemory.getContext(),\n                                               workingMemory,\n                                               handle );\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.betaMemory.getLeftTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            LeftTuple tuple = (LeftTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( memory.betaMemory.getContext(),\n                                                        tuple ) ) {\n                if ( this.accumulate.supportsReverse() ) {\n                    this.modifyTuple( false,\n                                      tuple,\n                                      handle,\n                                      context,\n                                      workingMemory );\n                } else {\n                    this.retractLeftTuple( tuple,\n                                           context,\n                                           workingMemory );\n                    this.assertLeftTuple( tuple,\n                                          context,\n                                          workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.betaMemory.getContext() );\n    }","id":95872,"modified_method":"/**\n     *  @inheritDoc\n     *\n     *  If an object is retract, call modify tuple for each\n     *  tuple match.\n     */\n    public void retractRightTuple(final RightTuple rightTuple,\n                              final PropagationContext context,\n                              final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getRightTupleMemory().remove( rightTuple );\n        \n        InternalFactHandle handle = rightTuple.getFactHandle(); \n\n        this.constraints.updateFromFactHandle( memory.betaMemory.getContext(),\n                                               workingMemory,\n                                               handle );\n        // need to clone the tuples to avoid concurrent modification exceptions\n        Entry[] tuples = memory.betaMemory.getLeftTupleMemory().toArray();\n        for ( int i = 0; i < tuples.length; i++ ) {\n            LeftTuple tuple = (LeftTuple) tuples[i];\n            if ( this.constraints.isAllowedCachedRight( memory.betaMemory.getContext(),\n                                                        tuple ) ) {\n                if ( this.accumulate.supportsReverse() ) {\n                    this.modifyTuple( false,\n                                      tuple,\n                                      handle,\n                                      context,\n                                      workingMemory );\n                } else {\n                    this.retractLeftTuple( tuple,\n                                           context,\n                                           workingMemory );\n                    this.assertLeftTuple( tuple,\n                                          context,\n                                          workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetFactHandle( memory.betaMemory.getContext() );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     *\n     * As the accumulate node will always propagate the tuple,\n     * it must always also retreat it.\n     *\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        if ( memory.betaMemory.getLeftTupleMemory().remove( leftTuple ) == null ) {\n            return;\n        }\n        final AccumulateResult accresult = (AccumulateResult) memory.betaMemory.getCreatedHandles().remove( leftTuple );\n\n        // if tuple was propagated\n        if ( accresult.handle != null ) {\n            this.sink.propagateRetractLeftTuple( leftTuple,\n                                                 accresult.handle,\n                                                 context,\n                                                 workingMemory );\n\n            // Destroying the acumulate result object\n            workingMemory.getFactHandleFactory().destroyFactHandle( accresult.handle );\n        }\n\n    }","id":95873,"modified_method":"/**\n     * @inheritDoc\n     *\n     * As the accumulate node will always propagate the tuple,\n     * it must always also retreat it.\n     *\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getLeftTupleMemory().remove( leftTuple );\n        \n        memory.resultMap.remove( leftTuple );\n\n        this.sink.propagateRetractLeftTupleDestroyRightTuple( leftTuple,\n                                                              context,\n                                                              workingMemory );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void readExternal(ObjectInput in) throws IOException,\n                                                ClassNotFoundException {\n            handle = (InternalFactHandle) in.readObject();\n            context = in.readObject();\n        }","id":95874,"modified_method":"public void readExternal(ObjectInput in) throws IOException,\n                                                ClassNotFoundException {\n            context = in.readObject();\n        }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     *\n     *  When a new tuple is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching objects from right memory\n     *  2. Execute the initialization code using the tuple + matching objects\n     *  3. Execute the accumulation code for each combination of tuple+object\n     *  4. Execute the return code\n     *  5. Create a new CalculatedObjectHandle for the resulting object and add it to the tuple\n     *  6. Propagate the tuple\n     *\n     *  The initialization, accumulation and return codes, in JBRules, are assembled\n     *  into a generated method code and called once for the whole match, as you can see\n     *  bellow:\n     *\n     *   Object result = this.accumulator.accumulate( ... );\n     *\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        AccumulateResult accresult = new AccumulateResult();\n\n        if ( this.tupleMemoryEnabled ) {\n            memory.betaMemory.getLeftTupleMemory().add( leftTuple );\n            memory.betaMemory.getCreatedHandles().put( leftTuple,\n                                                       accresult,\n                                                       false );\n        }\n\n        final Object accContext = this.accumulate.createContext();\n\n        accresult.context = accContext;\n        this.accumulate.init( memory.workingMemoryContext,\n                              accContext,\n                              leftTuple,\n                              workingMemory );\n\n        final Iterator it = memory.betaMemory.getRightTupleMemory().iterator( leftTuple );\n        this.constraints.updateFromTuple( memory.betaMemory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n\n        for ( FactEntry entry = (FactEntry) it.next(); entry != null; entry = (FactEntry) it.next() ) {\n            InternalFactHandle handle = entry.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( memory.betaMemory.getContext(),\n                                                       handle ) ) {\n                if ( this.unwrapRightObject ) {\n                    // if there is a subnetwork, handle must be unwrapped\n                    LeftTuple tuple = (LeftTuple) handle.getObject();\n                    handle = tuple.getLastHandle();\n                    this.accumulate.accumulate( memory.workingMemoryContext,\n                                                accContext,\n                                                tuple,\n                                                handle,\n                                                workingMemory );\n                } else {\n                    this.accumulate.accumulate( memory.workingMemoryContext,\n                                                accContext,\n                                                leftTuple,\n                                                handle,\n                                                workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetTuple( memory.betaMemory.getContext() );\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accContext,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        final InternalFactHandle handle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                              false,\n                                                                                              workingMemory ); // so far, result is not an event\n\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( handle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultBinder.updateFromTuple( memory.resultsContext,\n                                               workingMemory,\n                                               leftTuple );\n            if ( this.resultBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                        handle ) ) {\n                accresult.handle = handle;\n\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    handle,\n                                                    context,\n                                                    workingMemory );\n            } else {\n                workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n            }\n        } else {\n            workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n        }\n\n    }","id":95875,"modified_method":"/**\n     * @inheritDoc\n     *\n     *  When a new tuple is asserted into an AccumulateNode, do this:\n     *\n     *  1. Select all matching objects from right memory\n     *  2. Execute the initialization code using the tuple + matching objects\n     *  3. Execute the accumulation code for each combination of tuple+object\n     *  4. Execute the return code\n     *  5. Create a new CalculatedObjectHandle for the resulting object and add it to the tuple\n     *  6. Propagate the tuple\n     *\n     *  The initialization, accumulation and return codes, in JBRules, are assembled\n     *  into a generated method code and called once for the whole match, as you can see\n     *  bellow:\n     *\n     *   Object result = this.accumulator.accumulate( ... );\n     *\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {\n\n        final AccumulateMemory memory = (AccumulateMemory) workingMemory.getNodeMemory( this );\n\n        AccumulateResult accresult = new AccumulateResult();\n\n        if ( this.tupleMemoryEnabled ) {\n            memory.betaMemory.getLeftTupleMemory().add( leftTuple );\n            memory.resultMap.put( leftTuple,\n                                      accresult,\n                                      false );\n        }\n\n        final Object accContext = this.accumulate.createContext();\n\n        accresult.context = accContext;\n        this.accumulate.init( memory.workingMemoryContext,\n                              accContext,\n                              leftTuple,\n                              workingMemory );\n\n        this.constraints.updateFromTuple( memory.betaMemory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n\n        for ( RightTuple rightTuple = memory.betaMemory.getRightTupleMemory().getFirst( leftTuple ); rightTuple != null; rightTuple = (RightTuple) rightTuple.getNext() ) {\n            InternalFactHandle handle = rightTuple.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( memory.betaMemory.getContext(),\n                                                       handle ) ) {\n                if ( this.unwrapRightObject ) {\n                    // if there is a subnetwork, handle must be unwrapped\n                    LeftTuple tuple = (LeftTuple) handle.getObject();\n                    handle = tuple.getLastHandle();\n                    this.accumulate.accumulate( memory.workingMemoryContext,\n                                                accContext,\n                                                tuple,\n                                                handle,\n                                                workingMemory );\n                } else {\n                    this.accumulate.accumulate( memory.workingMemoryContext,\n                                                accContext,\n                                                leftTuple,\n                                                handle,\n                                                workingMemory );\n                }\n            }\n        }\n\n        this.constraints.resetTuple( memory.betaMemory.getContext() );\n\n        final Object result = this.accumulate.getResult( memory.workingMemoryContext,\n                                                         accContext,\n                                                         leftTuple,\n                                                         workingMemory );\n\n        if ( result == null ) {\n            throw new RuntimeDroolsException( \"Accumulate must not return a null value.\" );\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        final InternalFactHandle handle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                              false,\n                                                                                              workingMemory ); // so far, result is not an event\n        \n        final RightTuple resultTuple = new RightTuple( handle,\n                                                       this );        \n\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( handle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultBinder.updateFromTuple( memory.resultsContext,\n                                               workingMemory,\n                                               leftTuple );\n            if ( this.resultBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                        handle ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    resultTuple,\n                                                    context,\n                                                    workingMemory );\n            } else {\n                workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n            }\n        } else {\n            workingMemory.getFactHandleFactory().destroyFactHandle( handle );\n        }\n\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#assertLeftTuple(org.drools.reteoo.LeftTuple, org.drools.spi.PropagationContext, org.drools.reteoo.ReteooWorkingMemory)}.\n     */\n    public void testAssertTupleWithObjects() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\", false, null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\", false, null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0 );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        // assert tuple, should add left memory \n        final LeftTuple tuple1 = new LeftTuple( f1 );\n        this.node.assertLeftTuple( tuple1,\n                               this.context,\n                               this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getLeftTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        final LeftTupleMemory memory = this.memory.getLeftTupleMemory();\n        assertTrue( memory.contains( tuple0 ) );\n        assertTrue( memory.contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","id":95876,"modified_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#assertLeftTuple(org.drools.reteoo.LeftTuple, org.drools.spi.PropagationContext, org.drools.reteoo.ReteooWorkingMemory)}.\n     */\n    public void testAssertTupleWithObjects() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0,\n                                                null );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                                   this.context,\n                                   this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        // assert tuple, should add left memory \n        final LeftTuple tuple1 = new LeftTuple( f1,\n                                                null );\n        this.node.assertLeftTuple( tuple1,\n                                   this.context,\n                                   this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getLeftTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        final LeftTupleMemory memory = this.memory.getLeftTupleMemory();\n        assertTrue( memory.contains( tuple0 ) );\n        assertTrue( memory.contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#assertLeftTuple(org.drools.reteoo.LeftTuple, org.drools.spi.PropagationContext, org.drools.reteoo.ReteooWorkingMemory)}.\n     */\n    public void testAssertTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\", false, null );\n        final LeftTuple tuple0 = new LeftTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertTrue( \"An empty matching objects list should be propagated\",\n                           this.accumulator.getMatchingObjects().isEmpty() );\n\n        // assert tuple, should add left memory \n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\", false, null );\n\n        final LeftTuple tuple1 = new LeftTuple( f1 );\n        this.node.assertLeftTuple( tuple1,\n                               this.context,\n                               this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getLeftTupleMemory().size() );\n        Assert.assertTrue( \"An empty matching objects list should be propagated\",\n                           this.accumulator.getMatchingObjects().isEmpty() );\n\n        final LeftTupleMemory memory = this.memory.getLeftTupleMemory();\n        assertTrue( memory.contains( tuple0 ) );\n        assertTrue( memory.contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","id":95877,"modified_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#assertLeftTuple(org.drools.reteoo.LeftTuple, org.drools.spi.PropagationContext, org.drools.reteoo.ReteooWorkingMemory)}.\n     */\n    public void testAssertTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n        final LeftTuple tuple0 = new LeftTuple( f0,\n                                                null );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                                   this.context,\n                                   this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertTrue( \"An empty matching objects list should be propagated\",\n                           this.accumulator.getMatchingObjects().isEmpty() );\n\n        // assert tuple, should add left memory \n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n\n        final LeftTuple tuple1 = new LeftTuple( f1,\n                                                null );\n        this.node.assertLeftTuple( tuple1,\n                                   this.context,\n                                   this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getLeftTupleMemory().size() );\n        Assert.assertTrue( \"An empty matching objects list should be propagated\",\n                           this.accumulator.getMatchingObjects().isEmpty() );\n\n        final LeftTupleMemory memory = this.memory.getLeftTupleMemory();\n        assertTrue( memory.contains( tuple0 ) );\n        assertTrue( memory.contains( tuple1 ) );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#retractLeftTuple(org.drools.reteoo.LeftTuple, org.drools.spi.PropagationContext, org.drools.reteoo.ReteooWorkingMemory)}.\n     */\n    public void testRetractTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\", false, null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertTrue( \"An empty matching objects list should be propagated\",\n                           this.accumulator.getMatchingObjects().isEmpty() );\n\n        this.node.retractLeftTuple( tuple0,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n    }","id":95878,"modified_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#retractLeftTuple(org.drools.reteoo.LeftTuple, org.drools.spi.PropagationContext, org.drools.reteoo.ReteooWorkingMemory)}.\n     */\n    public void testRetractTuple() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0,\n                                                null );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                                   this.context,\n                                   this.workingMemory );\n        // check memories \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 0,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertTrue( \"An empty matching objects list should be propagated\",\n                           this.accumulator.getMatchingObjects().isEmpty() );\n\n        this.node.retractLeftTuple( tuple0,\n                                    this.context,\n                                    this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#updateNewNode(InternalWorkingMemory, org.drools.spi.PropagationContext)}.\n     */\n    public void testUpdateSink() {\n        this.node.updateSink( this.sink,\n                              this.context,\n                              this.workingMemory );\n        Assert.assertEquals( \"No tuple should be propagated\",\n                             0,\n                             this.sink.getAsserted().size() );\n\n        this.node.assertLeftTuple( new LeftTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\", false, null ) ),\n                               this.context,\n                               this.workingMemory );\n        this.node.assertLeftTuple( new LeftTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\", false, null ) ),\n                               this.context,\n                               this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n\n        final MockLeftTupleSink otherSink = new MockLeftTupleSink();\n\n        this.node.addTupleSink( otherSink );\n        this.node.updateSink( otherSink,\n                              this.context,\n                              this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             otherSink.getAsserted().size() );\n    }","id":95879,"modified_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#updateNewNode(InternalWorkingMemory, org.drools.spi.PropagationContext)}.\n     */\n    public void testUpdateSink() {\n        this.node.updateSink( this.sink,\n                              this.context,\n                              this.workingMemory );\n        Assert.assertEquals( \"No tuple should be propagated\",\n                             0,\n                             this.sink.getAsserted().size() );\n\n        this.node.assertLeftTuple( new LeftTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\",\n                                                                                                           false,\n                                                                                                           null ),\n                                                  null ),\n                                   this.context,\n                                   this.workingMemory );\n        this.node.assertLeftTuple( new LeftTuple( this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\",\n                                                                                                           false,\n                                                                                                           null ),\n                                                  null ),\n                                   this.context,\n                                   this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n\n        final MockLeftTupleSink otherSink = new MockLeftTupleSink();\n\n        this.node.addTupleSink( otherSink );\n        this.node.updateSink( otherSink,\n                              this.context,\n                              this.workingMemory );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             otherSink.getAsserted().size() );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Test just tuple assertions\n     * \n     * @throws AssertionException\n     */\n    public void testAssertTupleSequentialMode() throws Exception {\n        RuleBaseConfiguration conf = new RuleBaseConfiguration();\n        conf.setSequential( true );\n\n        ReteooRuleBase ruleBase = (ReteooRuleBase) RuleBaseFactory.newRuleBase();\n        BuildContext buildContext = new BuildContext( ruleBase,\n                                                      ruleBase.getReteooBuilder().getIdGenerator() );\n        buildContext.setTupleMemoryEnabled( false );\n        // overide the original node, so we an set the BuildContext\n        this.node = new AccumulateNode( 15,\n                                        this.tupleSource,\n                                        this.objectSource,\n                                        new AlphaNodeFieldConstraint[0],\n                                        EmptyBetaConstraints.getInstance(),\n                                        EmptyBetaConstraints.getInstance(),\n                                        this.accumulate,\n                                        false,\n                                        buildContext );\n\n        this.node.addTupleSink( this.sink );        \n        \n        this.workingMemory = new ReteooWorkingMemory( 1,\n                                                      (ReteooRuleBase) RuleBaseFactory.newRuleBase( conf ) );\n        \n        this.memory = ((AccumulateMemory) this.workingMemory.getNodeMemory( this.node )).betaMemory;\n\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\", false, null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\", false, null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0 );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        // assert tuple, should not add to left memory, since we are in sequential mode\n        this.node.assertLeftTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n        // check memories \n        assertNull( this.memory.getLeftTupleMemory() );\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        // assert tuple, should not add left memory \n        final LeftTuple tuple1 = new LeftTuple( f1 );\n        this.node.assertLeftTuple( tuple1,\n                               this.context,\n                               this.workingMemory );\n        assertNull( this.memory.getLeftTupleMemory() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","id":95880,"modified_method":"/**\n     * Test just tuple assertions\n     * \n     * @throws AssertionException\n     */\n    public void testAssertTupleSequentialMode() throws Exception {\n        RuleBaseConfiguration conf = new RuleBaseConfiguration();\n        conf.setSequential( true );\n\n        ReteooRuleBase ruleBase = (ReteooRuleBase) RuleBaseFactory.newRuleBase();\n        BuildContext buildContext = new BuildContext( ruleBase,\n                                                      ruleBase.getReteooBuilder().getIdGenerator() );\n        buildContext.setTupleMemoryEnabled( false );\n        // overide the original node, so we an set the BuildContext\n        this.node = new AccumulateNode( 15,\n                                        this.tupleSource,\n                                        this.objectSource,\n                                        new AlphaNodeFieldConstraint[0],\n                                        EmptyBetaConstraints.getInstance(),\n                                        EmptyBetaConstraints.getInstance(),\n                                        this.accumulate,\n                                        false,\n                                        buildContext );\n\n        this.node.addTupleSink( this.sink );\n\n        this.workingMemory = new ReteooWorkingMemory( 1,\n                                                      (ReteooRuleBase) RuleBaseFactory.newRuleBase( conf ) );\n\n        this.memory = ((AccumulateMemory) this.workingMemory.getNodeMemory( this.node )).betaMemory;\n\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0, null );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        // assert tuple, should not add to left memory, since we are in sequential mode\n        this.node.assertLeftTuple( tuple0,\n                                   this.context,\n                                   this.workingMemory );\n        // check memories \n        assertNull( this.memory.getLeftTupleMemory() );\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        // assert tuple, should not add left memory \n        final LeftTuple tuple1 = new LeftTuple( f1, null );\n        this.node.assertLeftTuple( tuple1,\n                                   this.context,\n                                   this.workingMemory );\n        assertNull( this.memory.getLeftTupleMemory() );\n        Assert.assertEquals( \"Wrong number of elements in matching objects list \",\n                             2,\n                             this.accumulator.getMatchingObjects().size() );\n\n        Assert.assertEquals( \"Two tuples should have been propagated\",\n                             2,\n                             this.sink.getAsserted().size() );\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#assertObject(InternalFactHandle, org.drools.spi.PropagationContext, InternalWorkingMemory)}.\n     */\n    public void testAssertObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\", false, null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\", false, null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0 );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        assertEquals( 0,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        assertEquals( 1,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        assertEquals( 2,\n                      this.accumulator.getMatchingObjects().size() );\n\n    }","id":95881,"modified_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#assertObject(InternalFactHandle, org.drools.spi.PropagationContext, InternalWorkingMemory)}.\n     */\n    public void testAssertObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0,\n                                                null );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                                   this.context,\n                                   this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        assertEquals( 0,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        assertEquals( 1,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        assertEquals( 2,\n                      this.accumulator.getMatchingObjects().size() );\n\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#retractObject(InternalFactHandle, org.drools.spi.PropagationContext, InternalWorkingMemory)}.\n     */\n    public void testRetractObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\", false, null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\", false, null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0 );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                               this.context,\n                               this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 0,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        assertEquals( 2,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.retractObject( f1,\n                                 this.context,\n                                 this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        assertEquals( 1,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.retractObject( f0,\n                                 this.context,\n                                 this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getRetracted().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        assertEquals( 0,\n                      this.accumulator.getMatchingObjects().size() );\n\n    }","id":95882,"modified_method":"/**\n     * Test method for {@link org.drools.reteoo.AccumulateNode#retractObject(InternalFactHandle, org.drools.spi.PropagationContext, InternalWorkingMemory)}.\n     */\n    public void testRetractObject() {\n        final DefaultFactHandle f0 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n        final DefaultFactHandle f1 = (DefaultFactHandle) this.workingMemory.getFactHandleFactory().newFactHandle( \"other cheese\",\n                                                                                                                  false,\n                                                                                                                  null );\n\n        final LeftTuple tuple0 = new LeftTuple( f0,\n                                                null );\n\n        this.node.assertObject( f0,\n                                this.context,\n                                this.workingMemory );\n        this.node.assertObject( f1,\n                                this.context,\n                                this.workingMemory );\n        assertEquals( 2,\n                      this.memory.getRightTupleMemory().size() );\n\n        // assert tuple, should add one to left memory\n        this.node.assertLeftTuple( tuple0,\n                                   this.context,\n                                   this.workingMemory );\n\n        // check memory \n        assertEquals( 1,\n                      this.memory.getLeftTupleMemory().size() );\n        assertEquals( 0,\n                      this.sink.getRetracted().size() );\n        assertEquals( 1,\n                      this.sink.getAsserted().size() );\n        assertEquals( 2,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.retractRightTuple( f1.getRightTuple(),\n                                     this.context,\n                                     this.workingMemory );\n        assertEquals( 1,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 1,\n                      this.sink.getRetracted().size() );\n        assertEquals( 2,\n                      this.sink.getAsserted().size() );\n        assertEquals( 1,\n                      this.accumulator.getMatchingObjects().size() );\n\n        this.node.retractRightTuple( f0.getRightTuple(),\n                                     this.context,\n                                     this.workingMemory );\n        assertEquals( 0,\n                      this.memory.getRightTupleMemory().size() );\n        assertEquals( 2,\n                      this.sink.getRetracted().size() );\n        assertEquals( 3,\n                      this.sink.getAsserted().size() );\n        assertEquals( 0,\n                      this.accumulator.getMatchingObjects().size() );\n\n    }","commit_id":"10f9a2ee73adf213821d2b263206c47efb160c83","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n        //        final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n        //\n        //        final Iterator it = memory.betaMemory.getCreatedHandles().iterator();\n        //\n        //        for ( ObjectEntry entry = (ObjectEntry) it.next(); entry != null; entry = (ObjectEntry) it.next() ) {\n        //            CollectResult result = (CollectResult) entry.getValue();\n        //            sink.assertLeftTuple( new LeftTuple( (LeftTuple) entry.getKey(),\n        //                                                 result.handle ),\n        //                                  context,\n        //                                  workingMemory );\n        //        }\n    }","id":95883,"modified_method":"public void updateSink(final LeftTupleSink sink,\n                           final PropagationContext context,\n                           final InternalWorkingMemory workingMemory) {\n                final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n                \n                final Iterator tupleIter = memory.betaMemory.getLeftTupleMemory().iterator();\n                for ( LeftTuple leftTuple = (LeftTuple) tupleIter.next(); leftTuple != null; leftTuple = (LeftTuple) tupleIter.next() ) {\n                    RightTuple rightTuple = leftTuple.getBetaChildren().getRightParent();\n                    sink.assertLeftTuple( new LeftTuple( leftTuple, rightTuple, sink), context, workingMemory );\n                }\n    }","commit_id":"0dddb8b99287b62b2c5f1d27ae1c46ff772a59e1","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Modifies the results match for a tuple, retracting it and repropagating\n     * if constraints allow it\n     *\n     * @param leftTuple\n     * @param handle\n     * @param context\n     * @param workingMemory\n     */\n    public void modifyTuple(final boolean isAssert,\n                            final LeftTuple leftTuple,\n                            final RightTuple rightTuple,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory) {\n\n        final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n\n        RightTuple result = (RightTuple) memory.betaMemory.getCreatedHandles().get( leftTuple );\n\n        // if tuple was propagated\n        if ( leftTuple.getBetaChildren() != null ) {\n            this.sink.propagateRetractLeftTuple( leftTuple,\n                                                 context,\n                                                 workingMemory );\n        }\n\n        // if there is a subnetwork, we need to unwrapp the object from inside the tuple\n        InternalFactHandle handle = rightTuple.getFactHandle();\n        if ( this.unwrapRightObject ) {\n            handle = ((LeftTuple) handle.getObject()).getLastHandle();\n        }\n\n        if ( context.getType() == PropagationContext.ASSERTION ) {\n            ((Collection) result.getFactHandle().getObject()).add( handle.getObject() );\n        } else if ( context.getType() == PropagationContext.RETRACTION ) {\n            ((Collection) result.getFactHandle().getObject()).remove( handle.getObject() );\n            rightTuple.setBetaChildren( leftTuple.getRightParentNext() );\n        } else if ( context.getType() == PropagationContext.MODIFICATION || context.getType() == PropagationContext.RULE_ADDITION || context.getType() == PropagationContext.RULE_REMOVAL ) {\n            if ( isAssert ) {\n                ((Collection) result.getFactHandle().getObject()).add( handle.getObject() );\n            } else {\n                ((Collection) result.getFactHandle().getObject()).remove( handle.getObject() );\n            }\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( result.getFactHandle(),\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultsBinder.updateFromTuple( memory.resultsContext,\n                                                workingMemory,\n                                                leftTuple );\n            if ( this.resultsBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                         result.getFactHandle() ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    result,\n                                                    context,\n                                                    workingMemory );\n            }\n\n            this.resultsBinder.resetTuple( memory.resultsContext );\n        }\n    }","id":95884,"modified_method":"/**\n     * Modifies the results match for a tuple, retracting it and repropagating\n     * if constraints allow it\n     *\n     * @param leftTuple\n     * @param handle\n     * @param context\n     * @param workingMemory\n     */\n    public void modifyTuple(final boolean isAssert,\n                            final LeftTuple leftTuple,\n                            final RightTuple rightTuple,\n                            final PropagationContext context,\n                            final InternalWorkingMemory workingMemory) {\n\n        final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n\n        RightTuple result = leftTuple.getBetaChildren().getRightParent();\n\n        // if tuple was propagated\n        if ( leftTuple.getBetaChildren() != null ) {\n            this.sink.propagateRetractLeftTuple( leftTuple,\n                                                 context,\n                                                 workingMemory );\n        }\n\n        // if there is a subnetwork, we need to unwrapp the object from inside the tuple\n        InternalFactHandle handle = rightTuple.getFactHandle();\n        if ( this.unwrapRightObject ) {\n            handle = ((LeftTuple) handle.getObject()).getLastHandle();\n        }\n\n        if ( context.getType() == PropagationContext.ASSERTION ) {\n            ((Collection) result.getFactHandle().getObject()).add( handle.getObject() );\n        } else if ( context.getType() == PropagationContext.RETRACTION ) {\n            ((Collection) result.getFactHandle().getObject()).remove( handle.getObject() );\n            rightTuple.setBetaChildren( leftTuple.getRightParentNext() );\n        } else if ( context.getType() == PropagationContext.MODIFICATION || context.getType() == PropagationContext.RULE_ADDITION || context.getType() == PropagationContext.RULE_REMOVAL ) {\n            if ( isAssert ) {\n                ((Collection) result.getFactHandle().getObject()).add( handle.getObject() );\n            } else {\n                ((Collection) result.getFactHandle().getObject()).remove( handle.getObject() );\n            }\n        }\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( result.getFactHandle(),\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultsBinder.updateFromTuple( memory.resultsContext,\n                                                workingMemory,\n                                                leftTuple );\n            if ( this.resultsBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                         result.getFactHandle() ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    result,\n                                                    context,\n                                                    workingMemory );\n            }\n\n            this.resultsBinder.resetTuple( memory.resultsContext );\n        }\n    }","commit_id":"0dddb8b99287b62b2c5f1d27ae1c46ff772a59e1","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n\n        final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getLeftTupleMemory().remove( leftTuple );\n\n        final RightTuple resultTuple = (RightTuple) memory.betaMemory.getCreatedHandles().remove( leftTuple );\n\n        if ( leftTuple.getBetaChildren() != null ) {\n            this.sink.propagateRetractLeftTuple( leftTuple,\n                                                 context,\n                                                 workingMemory );\n        }\n        workingMemory.getFactHandleFactory().destroyFactHandle( resultTuple.getFactHandle() );\n    }","id":95885,"modified_method":"/**\n     * @inheritDoc\n     */\n    public void retractLeftTuple(final LeftTuple leftTuple,\n                                 final PropagationContext context,\n                                 final InternalWorkingMemory workingMemory) {\n\n        final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n        memory.betaMemory.getLeftTupleMemory().remove( leftTuple );\n\n        this.sink.propagateRetractLeftTupleDestroyRightTuple( leftTuple, context, workingMemory );\n    }","commit_id":"0dddb8b99287b62b2c5f1d27ae1c46ff772a59e1","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @inheritDoc\n     *\n     *  When a new tuple is asserted into a CollectNode, do this:\n     *\n     *  1. Select all matching objects from right memory\n     *  2. Add them to the resulting collection object\n     *  3. Apply resultConstraints and resultsBinder to the resulting collection\n     *  4. In case all of them evaluates to true do the following:\n     *  4.1. Create a new InternalFactHandle for the resulting collection and add it to the tuple\n     *  4.2. Propagate the tuple\n     *\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {\n\n        final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n\n        final Collection result = this.collect.instantiateResultObject();\n        final InternalFactHandle resultHandle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                                    false,\n                                                                                                    workingMemory );\n        final RightTuple resultTuple = new RightTuple( resultHandle,\n                                                       this );\n\n        // do not add tuple and result to the memory in sequential mode\n        if ( this.tupleMemoryEnabled ) {\n            memory.betaMemory.getLeftTupleMemory().add( leftTuple );\n            memory.betaMemory.getCreatedHandles().put( leftTuple,\n                                                       resultTuple,\n                                                       false );\n        }\n\n        this.constraints.updateFromTuple( memory.betaMemory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n\n        for ( RightTuple rightTuple = memory.betaMemory.getRightTupleMemory().getFirst( leftTuple ); rightTuple != null; rightTuple = (RightTuple) rightTuple.getNext() ) {\n            InternalFactHandle handle = rightTuple.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( memory.betaMemory.getContext(),\n                                                       handle ) ) {\n                if ( this.unwrapRightObject ) {\n                    handle = ((LeftTuple) handle.getObject()).getLastHandle();\n                }\n                result.add( handle.getObject() );\n\n                // linking left tuple to the right tuple children list\n                leftTuple.setRightParentNext( rightTuple.getBetaChildren() );\n                rightTuple.setBetaChildren( leftTuple );\n            }\n        }\n\n        this.constraints.resetTuple( memory.betaMemory.getContext() );\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( resultHandle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultsBinder.updateFromTuple( memory.resultsContext,\n                                                workingMemory,\n                                                leftTuple );\n            if ( this.resultsBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                         resultHandle ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    resultTuple,\n                                                    context,\n                                                    workingMemory );\n            }\n            this.resultsBinder.resetTuple( memory.resultsContext );\n        }\n    }","id":95886,"modified_method":"/**\n     * @inheritDoc\n     *\n     *  When a new tuple is asserted into a CollectNode, do this:\n     *\n     *  1. Select all matching objects from right memory\n     *  2. Add them to the resulting collection object\n     *  3. Apply resultConstraints and resultsBinder to the resulting collection\n     *  4. In case all of them evaluates to true do the following:\n     *  4.1. Create a new InternalFactHandle for the resulting collection and add it to the tuple\n     *  4.2. Propagate the tuple\n     *\n     */\n    public void assertLeftTuple(final LeftTuple leftTuple,\n                                final PropagationContext context,\n                                final InternalWorkingMemory workingMemory) {\n\n        final CollectMemory memory = (CollectMemory) workingMemory.getNodeMemory( this );\n\n        final Collection result = this.collect.instantiateResultObject();\n        final InternalFactHandle resultHandle = workingMemory.getFactHandleFactory().newFactHandle( result,\n                                                                                                    false,\n                                                                                                    workingMemory );\n        final RightTuple resultTuple = new RightTuple( resultHandle,\n                                                       this );\n\n        // do not add tuple and result to the memory in sequential mode\n        if ( this.tupleMemoryEnabled ) {\n            memory.betaMemory.getLeftTupleMemory().add( leftTuple );\n        }\n\n        this.constraints.updateFromTuple( memory.betaMemory.getContext(),\n                                          workingMemory,\n                                          leftTuple );\n\n        for ( RightTuple rightTuple = memory.betaMemory.getRightTupleMemory().getFirst( leftTuple ); rightTuple != null; rightTuple = (RightTuple) rightTuple.getNext() ) {\n            InternalFactHandle handle = rightTuple.getFactHandle();\n            if ( this.constraints.isAllowedCachedLeft( memory.betaMemory.getContext(),\n                                                       handle ) ) {\n                if ( this.unwrapRightObject ) {\n                    handle = ((LeftTuple) handle.getObject()).getLastHandle();\n                }\n                result.add( handle.getObject() );\n\n                // linking left tuple to the right tuple children list\n                leftTuple.setRightParentNext( rightTuple.getBetaChildren() );\n                rightTuple.setBetaChildren( leftTuple );\n            }\n        }\n\n        this.constraints.resetTuple( memory.betaMemory.getContext() );\n\n        // First alpha node filters\n        boolean isAllowed = true;\n        for ( int i = 0, length = this.resultConstraints.length; i < length; i++ ) {\n            if ( !this.resultConstraints[i].isAllowed( resultHandle,\n                                                       workingMemory,\n                                                       memory.alphaContexts[i] ) ) {\n                isAllowed = false;\n                break;\n            }\n        }\n        if ( isAllowed ) {\n            this.resultsBinder.updateFromTuple( memory.resultsContext,\n                                                workingMemory,\n                                                leftTuple );\n            if ( this.resultsBinder.isAllowedCachedLeft( memory.resultsContext,\n                                                         resultHandle ) ) {\n                this.sink.propagateAssertLeftTuple( leftTuple,\n                                                    resultTuple,\n                                                    context,\n                                                    workingMemory );\n            }\n            this.resultsBinder.resetTuple( memory.resultsContext );\n        }\n    }","commit_id":"0dddb8b99287b62b2c5f1d27ae1c46ff772a59e1","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\n    public void abort(Throwable failure)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"HTTP2 Response #{} aborted\", stream.getId());\n        stream.reset(new ResetFrame(stream.getId(), ErrorCode.INTERNAL_ERROR.code), Callback.Adapter.INSTANCE);\n    }","id":95887,"modified_method":"@Override\n    public void abort(Throwable failure)\n    {\n        IStream stream = this.stream;\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"HTTP2 Response #{} aborted\", stream == null ? -1 : stream.getId());\n        if (stream != null)\n            stream.reset(new ResetFrame(stream.getId(), ErrorCode.INTERNAL_ERROR.code), Callback.Adapter.INSTANCE);\n    }","commit_id":"81f29576e6b7a1ee1da32b19843801becd000412","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void updateLogo(\n\t\t\tActionRequest actionRequest, long liveGroupId,\n\t\t\tlong stagingGroupId, boolean privateLayout, boolean hasLogo)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\tboolean useLogo = ParamUtil.getBoolean(actionRequest, \"useLogo\");\n\n\t\tInputStream inputStream = uploadPortletRequest.getFileAsStream(\n\t\t\t\"logoFileName\");\n\n\t\tif (useLogo && (inputStream == null)) {\n\t\t\tif (hasLogo) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthrow new UploadException(\"No logo uploaded for use\");\n\t\t}\n\n\t\tinputStream.mark(0);\n\n\t\tLayoutSetServiceUtil.updateLogo(\n\t\t\tliveGroupId, privateLayout, useLogo, inputStream);\n\n\t\tinputStream.reset();\n\n\t\tif (stagingGroupId > 0) {\n\t\t\tLayoutSetServiceUtil.updateLogo(\n\t\t\t\tstagingGroupId, privateLayout, useLogo, inputStream);\n\t\t}\n\t}","id":95888,"modified_method":"protected void updateLogo(\n\t\t\tActionRequest actionRequest, long liveGroupId,\n\t\t\tlong stagingGroupId, boolean privateLayout, boolean hasLogo)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\tboolean useLogo = ParamUtil.getBoolean(actionRequest, \"useLogo\");\n\n\t\tInputStream inputStream = uploadPortletRequest.getFileAsStream(\n\t\t\t\"logoFileName\");\n\n\t\tif (useLogo && (inputStream == null)) {\n\t\t\tif (hasLogo) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthrow new UploadException(\"No logo uploaded for use\");\n\t\t}\n\n\t\tif (inputStream != null) {\n\t\t\tinputStream.mark(0);\n\t\t}\n\n\t\tLayoutSetServiceUtil.updateLogo(\n\t\t\tliveGroupId, privateLayout, useLogo, inputStream);\n\n\t\tif (inputStream != null) {\n\t\t\tinputStream.reset();\n\t\t}\n\n\t\tif (stagingGroupId > 0) {\n\t\t\tLayoutSetServiceUtil.updateLogo(\n\t\t\t\tstagingGroupId, privateLayout, useLogo, inputStream);\n\t\t}\n\t}","commit_id":"556efb80fdfb0950cb7a43f7c85caf0485d18bff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void readRequest(HttpServletRequest request, HttpMessage message) {\n\n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n        \n        //apply the headerFilterStrategy\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getHeader(name);\n            // mapping the content-type \n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n        \n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }        \n\n        popluateRequestParameters(request, message);\n        // reset the stream cache\n        StreamCache cache = message.getBody(StreamCache.class);\n        cache.reset();\n        \n        // store the method and query and other info in headers\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n        \n        popluateAttachments(request, message);\n    }","id":95889,"modified_method":"public void readRequest(HttpServletRequest request, HttpMessage message) {\n\n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n        \n        //apply the headerFilterStrategy\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getHeader(name);\n            // mapping the content-type \n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n        \n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }        \n\n        popluateRequestParameters(request, message);\n        // reset the stream cache\n        StreamCache cache = message.getBody(StreamCache.class);\n        if (cache != null) {\n            cache.reset();\n        }\n        \n        // store the method and query and other info in headers\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n        \n        popluateAttachments(request, message);\n    }","commit_id":"ce3b0e7f693cbd204eada1b3081d0be59bf945eb","url":"https://github.com/apache/camel"},{"original_method":"public void readRequest(HttpServletRequest request, HttpMessage message) {\n        \n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n        \n        //apply the headerFilterStrategy\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getHeader(name);\n            // mapping the content-type \n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n                \n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }\n\n        popluateRequestParameters(request, message);        \n        \n        // reset the stream cache\n        StreamCache cache = message.getBody(StreamCache.class);\n        cache.reset();\n        \n        // store the method and query and other info in headers\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n        \n        popluateAttachments(request, message);\n    }","id":95890,"modified_method":"public void readRequest(HttpServletRequest request, HttpMessage message) {\n        \n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n        \n        //apply the headerFilterStrategy\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getHeader(name);\n            // mapping the content-type \n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n                \n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }\n\n        popluateRequestParameters(request, message);        \n        \n        // reset the stream cache\n        StreamCache cache = message.getBody(StreamCache.class);\n        if (cache != null) {\n            cache.reset();\n        }\n        \n        // store the method and query and other info in headers\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n        \n        popluateAttachments(request, message);\n    }","commit_id":"ce3b0e7f693cbd204eada1b3081d0be59bf945eb","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Equivalent to\n     * <pre>\n     *   MutableNodeState child = getChildNode(name, true);\n     *   child.reset(state);\n     *   return child;\n     * <\/pre>\n     */\n    @Nonnull\n    MutableNodeState setChildNode(String name, NodeState state) {\n        // FIXME better implementation, which doesn't set the base state twice\n        MutableNodeState child = getChildNode(name, true);\n        child.reset(state);\n        return child;\n    }","id":95891,"modified_method":"/**\n     * Equivalent to\n     * <pre>\n     *   MutableNodeState child = getChildNode(name, true);\n     *   child.reset(state);\n     *   return child;\n     * <\/pre>\n     */\n    @Nonnull\n    MutableNodeState setChildNode(String name, NodeState state) {\n        assert base != null;\n        MutableNodeState child = nodes.get(name);\n        if (child == null) {\n            child = new MutableNodeState(state);\n            nodes.put(name, child);\n        } else {\n            child.reset(state);\n        }\n        return child;\n    }","commit_id":"0916aafcef2c2bf390f1ba933f5cefcd3c404756","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Document loadDocument(SearchContext context, ResetFieldSelector fieldSelector, int docId) {\n        try {\n            fieldSelector.reset();\n            return context.searcher().doc(docId, fieldSelector);\n        } catch (IOException e) {\n            throw new FetchPhaseExecutionException(context, \"Failed to fetch doc id [\" + docId + \"]\", e);\n        }\n    }","id":95892,"modified_method":"private Document loadDocument(SearchContext context, @Nullable ResetFieldSelector fieldSelector, int docId) {\n        try {\n            if (fieldSelector != null) fieldSelector.reset();\n            return context.searcher().doc(docId, fieldSelector);\n        } catch (IOException e) {\n            throw new FetchPhaseExecutionException(context, \"Failed to fetch doc id [\" + docId + \"]\", e);\n        }\n    }","commit_id":"922833cdc4794a9a46bcbf5df5735308f6e643c1","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void execute(SearchContext context) {\n        ResetFieldSelector fieldSelector;\n        List<String> extractFieldNames = null;\n        if (context.hasScriptFields() && !context.hasFieldNames()) {\n            // we ask for script fields, and no field names, don't load the source\n            fieldSelector = UidFieldSelector.INSTANCE;\n        } else if (!context.hasFieldNames()) {\n            fieldSelector = new UidAndSourceFieldSelector();\n        } else if (context.fieldNames().isEmpty()) {\n            fieldSelector = UidFieldSelector.INSTANCE;\n        } else if (context.fieldNames().get(0).equals(\"*\")) {\n            // asked for all stored fields, just return null so all of them will be loaded\n            // don't load the source field in this case, makes little sense to get it with all stored fields\n            fieldSelector = AllButSourceFieldSelector.INSTANCE;\n        } else {\n            FieldMappersFieldSelector fieldSelectorMapper = new FieldMappersFieldSelector();\n            for (String fieldName : context.fieldNames()) {\n                FieldMappers x = context.smartNameFieldMappers(fieldName);\n                if (x != null && x.mapper().stored()) {\n                    fieldSelectorMapper.add(x);\n                } else {\n                    if (extractFieldNames == null) {\n                        extractFieldNames = Lists.newArrayList();\n                    }\n                    extractFieldNames.add(fieldName);\n                }\n            }\n            fieldSelectorMapper.add(UidFieldMapper.NAME);\n            fieldSelector = fieldSelectorMapper;\n        }\n\n        InternalSearchHit[] hits = new InternalSearchHit[context.docIdsToLoadSize()];\n        for (int index = 0; index < context.docIdsToLoadSize(); index++) {\n            int docId = context.docIdsToLoad()[context.docIdsToLoadFrom() + index];\n            Document doc = loadDocument(context, fieldSelector, docId);\n            Uid uid = extractUid(context, doc);\n\n            DocumentMapper documentMapper = context.mapperService().documentMapper(uid.type());\n\n            if (documentMapper == null) {\n                throw new TypeMissingException(new Index(context.shardTarget().index()), uid.type(), \"failed to find type loaded for doc [\" + uid.id() + \"]\");\n            }\n\n            byte[] source = extractSource(doc, documentMapper);\n\n            // get the version\n\n            InternalSearchHit searchHit = new InternalSearchHit(docId, uid.id(), uid.type(), source, null);\n            hits[index] = searchHit;\n\n            for (Object oField : doc.getFields()) {\n                Fieldable field = (Fieldable) oField;\n                String name = field.name();\n\n                // ignore UID, we handled it above\n                if (name.equals(UidFieldMapper.NAME)) {\n                    continue;\n                }\n\n                // ignore source, we handled it above\n                if (name.equals(SourceFieldMapper.NAME)) {\n                    continue;\n                }\n\n                Object value = null;\n                FieldMappers fieldMappers = documentMapper.mappers().indexName(field.name());\n                if (fieldMappers != null) {\n                    FieldMapper mapper = fieldMappers.mapper();\n                    if (mapper != null) {\n                        name = mapper.names().fullName();\n                        value = mapper.valueForSearch(field);\n                    }\n                }\n                if (value == null) {\n                    if (field.isBinary()) {\n                        value = field.getBinaryValue();\n                    } else {\n                        value = field.stringValue();\n                    }\n                }\n\n                if (searchHit.fieldsOrNull() == null) {\n                    searchHit.fields(new HashMap<String, SearchHitField>(2));\n                }\n\n                SearchHitField hitField = searchHit.fields().get(name);\n                if (hitField == null) {\n                    hitField = new InternalSearchHitField(name, new ArrayList<Object>(2));\n                    searchHit.fields().put(name, hitField);\n                }\n                hitField.values().add(value);\n            }\n\n            int readerIndex = context.searcher().readerIndex(docId);\n            IndexReader subReader = context.searcher().subReaders()[readerIndex];\n            int subDoc = docId - context.searcher().docStarts()[readerIndex];\n\n            // go over and extract fields that are not mapped / stored\n            context.lookup().setNextReader(subReader);\n            context.lookup().setNextDocId(subDoc);\n            if (source != null) {\n                context.lookup().source().setNextSource(source, 0, source.length);\n            }\n            if (extractFieldNames != null) {\n                for (String extractFieldName : extractFieldNames) {\n                    Object value = context.lookup().source().extractValue(extractFieldName);\n                    if (value != null) {\n                        if (searchHit.fieldsOrNull() == null) {\n                            searchHit.fields(new HashMap<String, SearchHitField>(2));\n                        }\n\n                        SearchHitField hitField = searchHit.fields().get(extractFieldName);\n                        if (hitField == null) {\n                            hitField = new InternalSearchHitField(extractFieldName, new ArrayList<Object>(2));\n                            searchHit.fields().put(extractFieldName, hitField);\n                        }\n                        hitField.values().add(value);\n                    }\n                }\n            }\n\n            for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n                FetchSubPhase.HitContext hitContext = new FetchSubPhase.HitContext();\n                if (fetchSubPhase.hitExecutionNeeded(context)) {\n                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);\n                    fetchSubPhase.hitExecute(context, hitContext);\n                }\n            }\n        }\n\n        for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n            if (fetchSubPhase.hitsExecutionNeeded(context)) {\n                fetchSubPhase.hitsExecute(context, hits);\n            }\n        }\n\n        context.fetchResult().hits(new InternalSearchHits(hits, context.queryResult().topDocs().totalHits, context.queryResult().topDocs().getMaxScore()));\n    }","id":95893,"modified_method":"public void execute(SearchContext context) {\n        ResetFieldSelector fieldSelector;\n        List<String> extractFieldNames = null;\n        boolean sourceRequested = false;\n        if (context.hasScriptFields() && !context.hasFieldNames()) {\n            // we ask for script fields, and no field names, don't load the source\n            fieldSelector = UidFieldSelector.INSTANCE;\n            sourceRequested = false;\n        } else if (!context.hasFieldNames()) {\n            fieldSelector = new UidAndSourceFieldSelector();\n            sourceRequested = true;\n        } else if (context.fieldNames().isEmpty()) {\n            fieldSelector = UidFieldSelector.INSTANCE;\n            sourceRequested = false;\n        } else {\n            boolean loadAllStored = false;\n            FieldMappersFieldSelector fieldSelectorMapper = null;\n            for (String fieldName : context.fieldNames()) {\n                if (fieldName.equals(\"*\")) {\n                    loadAllStored = true;\n                    continue;\n                }\n                if (fieldName.equals(SourceFieldMapper.NAME)) {\n                    sourceRequested = true;\n                    continue;\n                }\n                FieldMappers x = context.smartNameFieldMappers(fieldName);\n                if (x != null && x.mapper().stored()) {\n                    if (fieldSelectorMapper == null) {\n                        fieldSelectorMapper = new FieldMappersFieldSelector();\n                    }\n                    fieldSelectorMapper.add(x);\n                } else {\n                    if (extractFieldNames == null) {\n                        extractFieldNames = Lists.newArrayList();\n                    }\n                    extractFieldNames.add(fieldName);\n                }\n            }\n\n            if (loadAllStored) {\n                if (sourceRequested || extractFieldNames != null) {\n                    fieldSelector = null; // load everything, including _source\n                } else {\n                    fieldSelector = AllButSourceFieldSelector.INSTANCE;\n                }\n            } else if (fieldSelectorMapper != null) {\n                // we are asking specific stored fields, just add the UID and be done\n                fieldSelectorMapper.add(UidFieldMapper.NAME);\n                if (extractFieldNames != null) {\n                    fieldSelectorMapper.add(SourceFieldMapper.NAME);\n                }\n                fieldSelector = fieldSelectorMapper;\n            } else if (extractFieldNames != null) {\n                fieldSelector = new UidAndSourceFieldSelector();\n            } else {\n                fieldSelector = UidFieldSelector.INSTANCE;\n            }\n        }\n\n        InternalSearchHit[] hits = new InternalSearchHit[context.docIdsToLoadSize()];\n        for (int index = 0; index < context.docIdsToLoadSize(); index++) {\n            int docId = context.docIdsToLoad()[context.docIdsToLoadFrom() + index];\n            Document doc = loadDocument(context, fieldSelector, docId);\n            Uid uid = extractUid(context, doc);\n\n            DocumentMapper documentMapper = context.mapperService().documentMapper(uid.type());\n\n            if (documentMapper == null) {\n                throw new TypeMissingException(new Index(context.shardTarget().index()), uid.type(), \"failed to find type loaded for doc [\" + uid.id() + \"]\");\n            }\n\n            byte[] source = extractSource(doc, documentMapper);\n\n            // get the version\n\n            InternalSearchHit searchHit = new InternalSearchHit(docId, uid.id(), uid.type(), sourceRequested ? source : null, null);\n            hits[index] = searchHit;\n\n            for (Object oField : doc.getFields()) {\n                Fieldable field = (Fieldable) oField;\n                String name = field.name();\n\n                // ignore UID, we handled it above\n                if (name.equals(UidFieldMapper.NAME)) {\n                    continue;\n                }\n\n                // ignore source, we handled it above\n                if (name.equals(SourceFieldMapper.NAME)) {\n                    continue;\n                }\n\n                Object value = null;\n                FieldMappers fieldMappers = documentMapper.mappers().indexName(field.name());\n                if (fieldMappers != null) {\n                    FieldMapper mapper = fieldMappers.mapper();\n                    if (mapper != null) {\n                        name = mapper.names().fullName();\n                        value = mapper.valueForSearch(field);\n                    }\n                }\n                if (value == null) {\n                    if (field.isBinary()) {\n                        value = field.getBinaryValue();\n                    } else {\n                        value = field.stringValue();\n                    }\n                }\n\n                if (searchHit.fieldsOrNull() == null) {\n                    searchHit.fields(new HashMap<String, SearchHitField>(2));\n                }\n\n                SearchHitField hitField = searchHit.fields().get(name);\n                if (hitField == null) {\n                    hitField = new InternalSearchHitField(name, new ArrayList<Object>(2));\n                    searchHit.fields().put(name, hitField);\n                }\n                hitField.values().add(value);\n            }\n\n            int readerIndex = context.searcher().readerIndex(docId);\n            IndexReader subReader = context.searcher().subReaders()[readerIndex];\n            int subDoc = docId - context.searcher().docStarts()[readerIndex];\n\n            // go over and extract fields that are not mapped / stored\n            context.lookup().setNextReader(subReader);\n            context.lookup().setNextDocId(subDoc);\n            if (source != null) {\n                context.lookup().source().setNextSource(source, 0, source.length);\n            }\n            if (extractFieldNames != null) {\n                for (String extractFieldName : extractFieldNames) {\n                    Object value = context.lookup().source().extractValue(extractFieldName);\n                    if (value != null) {\n                        if (searchHit.fieldsOrNull() == null) {\n                            searchHit.fields(new HashMap<String, SearchHitField>(2));\n                        }\n\n                        SearchHitField hitField = searchHit.fields().get(extractFieldName);\n                        if (hitField == null) {\n                            hitField = new InternalSearchHitField(extractFieldName, new ArrayList<Object>(2));\n                            searchHit.fields().put(extractFieldName, hitField);\n                        }\n                        hitField.values().add(value);\n                    }\n                }\n            }\n\n            for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n                FetchSubPhase.HitContext hitContext = new FetchSubPhase.HitContext();\n                if (fetchSubPhase.hitExecutionNeeded(context)) {\n                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);\n                    fetchSubPhase.hitExecute(context, hitContext);\n                }\n            }\n        }\n\n        for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n            if (fetchSubPhase.hitsExecutionNeeded(context)) {\n                fetchSubPhase.hitsExecute(context, hits);\n            }\n        }\n\n        context.fetchResult().hits(new InternalSearchHits(hits, context.queryResult().topDocs().totalHits, context.queryResult().topDocs().getMaxScore()));\n    }","commit_id":"922833cdc4794a9a46bcbf5df5735308f6e643c1","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testStoredFields() throws Exception {\n        client.admin().indices().prepareCreate(\"test\").execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\").startObject(\"properties\")\n                .startObject(\"field1\").field(\"type\", \"string\").field(\"store\", \"yes\").endObject()\n                .startObject(\"field2\").field(\"type\", \"string\").field(\"store\", \"no\").endObject()\n                .startObject(\"field3\").field(\"type\", \"string\").field(\"store\", \"yes\").endObject()\n                .endObject().endObject().endObject().string();\n\n        client.admin().indices().preparePutMapping().setType(\"type1\").setSource(mapping).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", \"value1\")\n                .field(\"field2\", \"value2\")\n                .field(\"field3\", \"value3\")\n                .endObject()).execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"field1\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field1\").value().toString(), equalTo(\"value1\"));\n\n        // field2 is not stored, check that it gets extracted from source\n        searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"field2\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field2\").value().toString(), equalTo(\"value2\"));\n\n        searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"field3\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field3\").value().toString(), equalTo(\"value3\"));\n\n        searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"*\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(2));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field1\").value().toString(), equalTo(\"value1\"));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field3\").value().toString(), equalTo(\"value3\"));\n    }","id":95894,"modified_method":"@Test\n    public void testStoredFields() throws Exception {\n        client.admin().indices().prepareCreate(\"test\").execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\").startObject(\"properties\")\n                .startObject(\"field1\").field(\"type\", \"string\").field(\"store\", \"yes\").endObject()\n                .startObject(\"field2\").field(\"type\", \"string\").field(\"store\", \"no\").endObject()\n                .startObject(\"field3\").field(\"type\", \"string\").field(\"store\", \"yes\").endObject()\n                .endObject().endObject().endObject().string();\n\n        client.admin().indices().preparePutMapping().setType(\"type1\").setSource(mapping).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"field1\", \"value1\")\n                .field(\"field2\", \"value2\")\n                .field(\"field3\", \"value3\")\n                .endObject()).execute().actionGet();\n\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"field1\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field1\").value().toString(), equalTo(\"value1\"));\n\n        // field2 is not stored, check that it gets extracted from source\n        searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"field2\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field2\").value().toString(), equalTo(\"value2\"));\n\n        searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"field3\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field3\").value().toString(), equalTo(\"value3\"));\n\n        searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"*\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).source(), nullValue());\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(2));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field1\").value().toString(), equalTo(\"value1\"));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field3\").value().toString(), equalTo(\"value3\"));\n\n        searchResponse = client.prepareSearch().setQuery(matchAllQuery()).addField(\"*\").addField(\"_source\").execute().actionGet();\n        assertThat(searchResponse.hits().getTotalHits(), equalTo(1l));\n        assertThat(searchResponse.hits().hits().length, equalTo(1));\n        assertThat(searchResponse.hits().getAt(0).source(), notNullValue());\n        assertThat(searchResponse.hits().getAt(0).fields().size(), equalTo(2));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field1\").value().toString(), equalTo(\"value1\"));\n        assertThat(searchResponse.hits().getAt(0).fields().get(\"field3\").value().toString(), equalTo(\"value3\"));\n    }","commit_id":"922833cdc4794a9a46bcbf5df5735308f6e643c1","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void annotate(PsiElement psiElement, AnnotationHolder holder) {\n    AntElement element = (AntElement)psiElement;\n    if (element instanceof AntTask) {\n      final AntTask task = (AntTask)element;\n      AntTaskDefinition def = task.getTaskDefinition();\n      if (def == null) {\n        holder.createErrorAnnotation(task, AntBundle.getMessage(\"undefined.task\", task.getName()));\n      }\n      else {\n        checkValidAttributes(task, def, holder);\n        final AntElement parent = task.getAntParent();\n        if (parent instanceof AntTask) {\n          final AntTask parentTask = (AntTask)parent;\n          final AntTaskDefinition parentDef = parentTask.getTaskDefinition();\n          if (parentDef != null && parentDef.getNestedClassName(def.getTaskId()) == null) {\n            final TextRange textRange = new TextRange(0, task.getName().length()).shiftRight(task.getSourceElement().getTextOffset());\n            holder.createErrorAnnotation(textRange, AntBundle.getMessage(\"nested.element.is.not.allowed.for.the.task\"));\n          }\n        }\n      }\n    }\n    checkReferences(element, holder);\n  }","id":95895,"modified_method":"public void annotate(PsiElement psiElement, AnnotationHolder holder) {\n    AntElement element = (AntElement)psiElement;\n    if (element instanceof AntStructuredElement) {\n      final AntStructuredElement se = (AntStructuredElement)element;\n      AntTypeDefinition def = se.getTypeDefinition();\n      final String name = se.getName();\n      if (def == null) {\n        holder.createErrorAnnotation(se, AntBundle.getMessage(\"undefined.element\", name));\n      }\n      else {\n        checkValidAttributes(se, def, holder);\n        final AntElement parent = se.getAntParent();\n        if (parent instanceof AntStructuredElement) {\n          final AntStructuredElement pe = (AntStructuredElement)parent;\n          final AntTypeDefinition parentDef = pe.getTypeDefinition();\n          if (parentDef != null && parentDef.getNestedClassName(def.getTypeId()) == null) {\n            final TextRange textRange = new TextRange(0, name.length()).shiftRight(se.getSourceElement().getTextOffset());\n            holder.createErrorAnnotation(textRange, AntBundle.getMessage(\"nested.element.is.not.allowed.here\"));\n          }\n        }\n      }\n    }\n    checkReferences(element, holder);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkValidAttributes(AntTask task, AntTaskDefinition def, AnnotationHolder holder) {\n    final XmlTag sourceElement = task.getSourceElement();\n    for (XmlAttribute attr : sourceElement.getAttributes()) {\n      final AntAttributeType type = def.getAttributeType(attr.getName());\n      if (type == null) {\n        holder.createErrorAnnotation(task, AntBundle.getMessage(\"attribute.is.not.allowed.for.the.task\"));\n      }\n      else {\n        final String value = attr.getValue();\n        if (type == AntAttributeType.INTEGER) {\n          try {\n            Integer.parseInt(value);\n          }\n          catch (NumberFormatException e) {\n            holder.createErrorAnnotation(attr, AntBundle.getMessage(\"integer.attribute.has.invalid.value\"));\n          }\n        }\n      }\n    }\n  }","id":95896,"modified_method":"private static void checkValidAttributes(AntStructuredElement se, AntTypeDefinition def, AnnotationHolder holder) {\n    final XmlTag sourceElement = se.getSourceElement();\n    for (XmlAttribute attr : sourceElement.getAttributes()) {\n      final AntAttributeType type = def.getAttributeType(attr.getName());\n      if (type == null) {\n        holder.createErrorAnnotation(se, AntBundle.getMessage(\"attribute.is.not.allowed.for.the.task\"));\n      }\n      else {\n        final String value = attr.getValue();\n        if (type == AntAttributeType.INTEGER) {\n          try {\n            Integer.parseInt(value);\n          }\n          catch (NumberFormatException e) {\n            holder.createErrorAnnotation(attr, AntBundle.getMessage(\"integer.attribute.has.invalid.value\"));\n          }\n        }\n      }\n    }\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntCallImpl(final AntElement parent, final XmlElement sourceElement, final AntTaskDefinition definition) {\n    super(parent, sourceElement, definition);\n  }","id":95897,"modified_method":"public AntCallImpl(final AntElement parent, final XmlElement sourceElement, final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static AntElement createAntElement(final AntElement parent, final XmlTag tag) {\n    instantiate();\n    String className = null;\n    final Pair<String, String> taskId = new Pair<String, String>(tag.getName(), tag.getNamespace());\n    if (parent instanceof AntTask) {\n      final AntTaskDefinition def = ((AntTask)parent).getTaskDefinition();\n      if (def != null) {\n        className = def.getNestedClassName(taskId);\n      }\n    }\n    else {\n      for (AntTaskDefinition def : parent.getAntProject().getBaseTaskDefinitions()) {\n        if (taskId.equals(def.getTaskId())) {\n          className = def.getClassName();\n          break;\n        }\n      }\n    }\n    return createAntTask(tag, parent, className);\n  }","id":95898,"modified_method":"@NotNull\n  public static AntElement createAntElement(final AntElement parent, final XmlTag tag) {\n    instantiate();\n    AntTypeDefinition typeDef = null;\n    final AntTypeId id = new AntTypeId(tag.getName(), tag.getNamespace());\n    final AntProject project = parent.getAntProject();\n    if (parent instanceof AntStructuredElement) {\n      final AntTypeDefinition parentDef = ((AntStructuredElement)parent).getTypeDefinition();\n      if (parentDef != null) {\n        final String className = parentDef.getNestedClassName(id);\n        if (className != null) {\n          typeDef = project.getBaseTypeDefinition(className);\n        }\n      }\n    }\n    if (typeDef == null) {\n      for (AntTypeDefinition def : project.getBaseTypeDefinitions()) {\n        if (id.equals(def.getTypeId())) {\n          typeDef = def;\n          break;\n        }\n      }\n    }\n    if (typeDef != null) {\n      AntElementCreator antElementCreator = ourAntTypeToKnownAntElementCreatorMap.get(typeDef.getClassName());\n      if (antElementCreator != null) {\n        return antElementCreator.create(parent, tag);\n      }\n      if (typeDef.isTask()) {\n        return new AntTaskImpl(parent, tag, typeDef);\n      }\n    }\n    return new AntStructuredElementImpl(parent, tag, typeDef);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void instantiate() {\n    if (antTaskTypeToKnownAntTaskCreatorMap == null) {\n      antTaskTypeToKnownAntTaskCreatorMap = new HashMap<String, AntTaskCreator>();\n      antTaskTypeToKnownAntTaskCreatorMap.put(Property.class.getName(), new AntTaskCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntPropertyImpl(parent, tag, parent.getAntProject().getBaseTaskDefinition(Property.class.getName()));\n        }\n      });\n      antTaskTypeToKnownAntTaskCreatorMap.put(CallTarget.class.getName(), new AntTaskCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntCallImpl(parent, tag, parent.getAntProject().getBaseTaskDefinition(CallTarget.class.getName()));\n        }\n      });\n    }\n  }","id":95899,"modified_method":"private static void instantiate() {\n    if (ourAntTypeToKnownAntElementCreatorMap == null) {\n      ourAntTypeToKnownAntElementCreatorMap = new HashMap<String, AntElementCreator>();\n      ourAntTypeToKnownAntElementCreatorMap.put(Target.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTargetImpl(parent, tag);\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(Property.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntPropertyImpl(parent, tag, parent.getAntProject().getBaseTypeDefinition(Property.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(CallTarget.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntCallImpl(parent, tag, parent.getAntProject().getBaseTypeDefinition(CallTarget.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(Taskdef.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTaskDefImpl(parent, tag, parent.getAntProject().getBaseTypeDefinition(CallTarget.class.getName()));\n        }\n      });\n    }\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AntElement[] getChildren() {\n    if (myChildren != null) return myChildren;\n    final XmlElement element = getSourceElement();\n    if (!(element instanceof XmlTag)) {\n      myChildren = getChildrenInner();\n    }\n    else {\n      final XmlTag[] tags = ((XmlTag)element).getSubTags();\n      final List<AntElement> children = new ArrayList<AntElement>();\n      for (final XmlTag tag : tags) {\n        children.add(AntElementFactory.createAntElement(this, tag));\n      }\n      myChildren = children.toArray(new AntElement[children.size()]);\n    }\n    return myChildren;\n  }","id":95900,"modified_method":"@NotNull\n  public AntElement[] getChildren() {\n    if (myChildren != null) return myChildren;\n    return myChildren = getChildrenInner();\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntElement\");\n      final XmlElement sourceElement = getSourceElement();\n      if (sourceElement instanceof XmlTag) {\n        XmlTag tag = (XmlTag)sourceElement;\n        builder.append(\"[\");\n        builder.append(tag.getName());\n        builder.append(\"]\");\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":95901,"modified_method":"public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntElement\");\n      final XmlElement sourceElement = getSourceElement();\n      builder.append(\"[\");\n      builder.append(sourceElement.toString());\n      builder.append(\"]\");\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntProjectImpl(final AntFileImpl parent, final XmlTag tag) {\n    super(parent, tag);\n  }","id":95902,"modified_method":"public AntProjectImpl(final AntFileImpl parent, final XmlTag tag) {\n    super(parent, tag);\n    myProject = new Project();\n    myProject.init();\n    myDefinition = createProjectDefinition();\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void registerCustomTask(final AntTaskDefinition definition) {\n    myTaskDefinitionArray = null;\n    myTaskDefinitions.put(definition.getClassName(), definition);\n  }","id":95903,"modified_method":"public void registerCustomType(final AntTypeDefinition definition) {\n    myTypeDefinitionArrays = null;\n    myTypeDefinitions.put(definition.getClassName(), definition);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public AntTaskDefinition getBaseTaskDefinition(final String taskClassName) {\n    if (myTaskDefinitions != null) return myTaskDefinitions.get(taskClassName);\n    myTaskDefinitions = new HashMap<String, AntTaskDefinition>();\n    Project project = new Project();\n    project.init();\n    final Hashtable ht = project.getTaskDefinitions();\n    if (ht == null) return null;\n\n    // first pass creates taskdefinitons without nested elements\n    final Enumeration tasks = ht.keys();\n    while (tasks.hasMoreElements()) {\n      final String taskName = (String)tasks.nextElement();\n      final Class taskClass = (Class)ht.get(taskName);\n      final IntrospectionHelper helper = getHelperExceptionSafe(taskClass);\n      if (helper == null) continue;\n      final HashMap<String, AntAttributeType> attributes = new HashMap<String, AntAttributeType>();\n      final Enumeration attrEnum = helper.getAttributes();\n      while (attrEnum.hasMoreElements()) {\n        String attr = (String)attrEnum.nextElement();\n        final Class attrClass = helper.getAttributeType(attr);\n        if (int.class.equals(attrClass)) {\n          attributes.put(attr, AntAttributeType.INTEGER);\n        }\n        else if (boolean.class.equals(attrClass)) {\n          attributes.put(attr, AntAttributeType.BOOLEAN);\n        }\n        else {\n          attributes.put(attr, AntAttributeType.STRING);\n        }\n      }\n      HashMap<Pair<String, String>, String> nestedDefinitions = new HashMap<Pair<String, String>, String>();\n      final Enumeration nestedEnum = helper.getNestedElements();\n      while (nestedEnum.hasMoreElements()) {\n        final String nestedElement = (String)nestedEnum.nextElement();\n        final String className = ((Class)helper.getNestedElementMap().get(nestedElement)).getName();\n        nestedDefinitions.put(new Pair<String, String>(nestedElement, \"\"), className);\n      }\n      AntTaskDefinition def = new AntTaskDefinitionImpl(new Pair<String, String>(taskName, getSourceElement().getNamespace()),\n                                                        taskClass.getName(), attributes, nestedDefinitions);\n      myTaskDefinitions.put(def.getClassName(), def);\n    }\n\n    return myTaskDefinitions.get(taskClassName);\n  }","id":95904,"modified_method":"@Nullable\n  public AntTypeDefinition getBaseTypeDefinition(final String taskClassName) {\n    if (myTypeDefinitions != null) return myTypeDefinitions.get(taskClassName);\n    myTypeDefinitions = new HashMap<String, AntTypeDefinition>();\n    final Hashtable ht = myProject.getTaskDefinitions();\n    if (ht == null) return null;\n    // first pass creates taskdefinitons without nested elements\n    final Enumeration tasks = ht.keys();\n    while (tasks.hasMoreElements()) {\n      final String taskName = (String)tasks.nextElement();\n      final Class taskClass = (Class)ht.get(taskName);\n      final IntrospectionHelper helper = getHelperExceptionSafe(taskClass);\n      if (helper == null) continue;\n      final HashMap<String, AntAttributeType> attributes = new HashMap<String, AntAttributeType>();\n      final Enumeration attrEnum = helper.getAttributes();\n      while (attrEnum.hasMoreElements()) {\n        String attr = (String)attrEnum.nextElement();\n        final Class attrClass = helper.getAttributeType(attr);\n        if (int.class.equals(attrClass)) {\n          attributes.put(attr, AntAttributeType.INTEGER);\n        }\n        else if (boolean.class.equals(attrClass)) {\n          attributes.put(attr, AntAttributeType.BOOLEAN);\n        }\n        else {\n          attributes.put(attr, AntAttributeType.STRING);\n        }\n      }\n      final HashMap<AntTypeId, String> nestedDefinitions = new HashMap<AntTypeId, String>();\n      final Enumeration nestedEnum = helper.getNestedElements();\n      while (nestedEnum.hasMoreElements()) {\n        final String nestedElement = (String)nestedEnum.nextElement();\n        final String className = ((Class)helper.getNestedElementMap().get(nestedElement)).getName();\n        nestedDefinitions.put(new AntTypeId(nestedElement), className);\n      }\n      AntTypeDefinition def = new AntTypeDefinitionImpl(new AntTypeId(taskName, getSourceElement().getNamespace()), taskClass.getName(),\n                                                        true, attributes, nestedDefinitions);\n      myTypeDefinitions.put(def.getClassName(), def);\n    }\n    return myTypeDefinitions.get(taskClassName);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AntTaskDefinition[] getBaseTaskDefinitions() {\n    if (myTaskDefinitionArray != null) return myTaskDefinitionArray;\n    getBaseTaskDefinition(null);\n    return myTaskDefinitionArray = myTaskDefinitions.values().toArray(new AntTaskDefinition[myTaskDefinitions.size()]);\n  }","id":95905,"modified_method":"@NotNull\n  public AntTypeDefinition[] getBaseTypeDefinitions() {\n    if (myTypeDefinitionArrays != null) return myTypeDefinitionArrays;\n    getBaseTypeDefinition(null);\n    return myTypeDefinitionArrays = myTypeDefinitions.values().toArray(new AntTypeDefinition[myTypeDefinitions.size()]);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntPropertyImpl(final AntElement parent, final XmlElement sourceElement, final AntTaskDefinition definition) {\n    super(parent, sourceElement, definition);\n  }","id":95906,"modified_method":"public AntPropertyImpl(final AntElement parent, final XmlElement sourceElement, final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntTargetImpl(AntElement parent, final XmlTag tag) {\n    super(parent, tag);\n  }","id":95907,"modified_method":"public AntTargetImpl(AntElement parent, final XmlTag tag) {\n    super(parent, tag);\n    myDefinition = getAntProject().getTargetDefinition();\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntTaskImpl(final AntElement parent, final XmlElement sourceElement, final AntTaskDefinition definition) {\n    super(parent, sourceElement);\n    myDefinition = (AntTaskDefinitionImpl)definition;\n    final Pair<String, String> taskId = new Pair<String, String>(getSourceElement().getName(), getSourceElement().getNamespace());\n    if (definition != null && !definition.getTaskId().equals(taskId)) {\n      myDefinition = new AntTaskDefinitionImpl(myDefinition);\n      myDefinition.setTaskId(taskId);\n      myDefinitionCloned = true;\n    }\n  }","id":95908,"modified_method":"public AntTaskImpl(final AntElement parent, final XmlElement sourceElement, final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n  }","commit_id":"55b90c106e705f185de7e35daab181fbb0f6d9b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement resolveProperty(@NotNull final AntElement element, final String name) {\n    AntElement temp = element;\n    while (temp != null) {\n      final PsiElement property = temp.getProperty(name);\n      if (property != null) {\n        return property;\n      }\n      temp = temp.getAntParent();\n    }\n    final AntElement anchor = AntPsiUtil.getSubProjectElement(element);\n    for (PsiElement child : element.getAntProject().getChildren()) {\n      if (child == anchor) {\n        break;\n      }\n      else if (child instanceof AntProperty) {\n        AntProperty prop = (AntProperty)child;\n        final PropertiesFile propFile = prop.getPropertiesFile();\n        if (propFile != null) {\n          String prefix = prop.getPrefix();\n          if (prefix != null && !prefix.endsWith(\".\")) {\n            prefix += '.';\n          }\n          final String key = (prefix == null) ? name : prefix + name;\n          final Property property = propFile.findPropertyByKey(key);\n          if (property != null) {\n            return property;\n          }\n        }\n      }\n    }\n    for (AntFile file : AntPsiUtil.getImportedFiles(element.getAntProject(), anchor)) {\n      final AntProject importedProject = file.getAntProject();\n      importedProject.getChildren();\n      final AntProperty property = importedProject.getProperty(name);\n      if (property != null) {\n        return property;\n      }\n    }\n    return null;\n  }","id":95909,"modified_method":"public static PsiElement resolveProperty(@NotNull final AntElement element, final String propName) {\n    PsiElement result;\n    AntElement temp = element;\n    while (temp != null) {\n      result = temp.getProperty(propName);\n      if (result != null) {\n        return result;\n      }\n      temp = temp.getAntParent();\n    }\n    final AntProject project = element.getAntProject();\n    if ((result = resolvePropertyInProject(project, propName)) != null) {\n      return result;\n    }\n    for (AntFile file : AntPsiUtil.getImportedFiles(project)) {\n      final AntProject importedProject = file.getAntProject();\n      importedProject.getChildren();\n      if ((result = resolvePropertyInProject(importedProject, propName)) != null) {\n        return result;\n      }\n    }\n    final AntTarget target = PsiTreeUtil.getParentOfType(element, AntTarget.class);\n    if (target != null) {\n      final HashSet<PsiElement> targetStack = PsiElementHashSetSpinAllocator.alloc();\n      try {\n        result = resolveTargetProperty(target, propName, targetStack);\n      }\n      finally {\n        PsiElementHashSetSpinAllocator.dispose(targetStack);\n      }\n    }\n    return result;\n  }","commit_id":"36f31c8f62bb82ffc54db614fc4e65c708a64d26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement resolve() {\n    final String name = getCanonicalRepresentationText();\n    AntElement element = getElement();\n    AntProject project = element.getAntProject();\n    AntTarget result = project.getTarget(name);\n    if (result == null) {\n      for (final AntTarget target : project.getImportTargets()) {\n        if (name.equals(target.getName())) {\n          return target;\n        }\n      }\n    }\n    if (result == null && element instanceof AntAntImpl) {\n      AntAntImpl ant = (AntAntImpl)element;\n      final PsiFile psiFile = ant.findFileByName(ant.getFileName());\n      if (psiFile != null) {\n        AntFile antFile;\n        if (psiFile instanceof AntFile) {\n          antFile = (AntFile)psiFile;\n        }\n        else {\n          antFile = (AntFile)psiFile.getViewProvider().getPsi(AntSupport.getLanguage());\n        }\n        if (antFile.getAntProject() != null) {\n          result = antFile.getAntProject().getTarget(name);\n        }\n      }\n    }\n    return result;\n  }","id":95910,"modified_method":"public PsiElement resolve() {\n    final String name = getCanonicalRepresentationText();\n    final AntElement element = getElement();\n    final AntProject project = element.getAntProject();\n    AntTarget result = project.getTarget(name);\n    if (result == null) {\n      for (final AntTarget target : project.getImportTargets()) {\n        if (name.equals(target.getName())) {\n          return target;\n        }\n      }\n    }\n    if (result == null && element instanceof AntAntImpl) {\n      AntAntImpl ant = (AntAntImpl)element;\n      final PsiFile psiFile = ant.findFileByName(ant.getFileName());\n      if (psiFile != null) {\n        AntFile antFile;\n        if (psiFile instanceof AntFile) {\n          antFile = (AntFile)psiFile;\n        }\n        else {\n          antFile = (AntFile)psiFile.getViewProvider().getPsi(AntSupport.getLanguage());\n        }\n        if (antFile != null) {\n          final AntProject antProject = antFile.getAntProject();\n          if (antProject != null) {\n            result = antProject.getTarget(name);\n          }\n        }\n      }\n    }\n    return result;\n  }","commit_id":"1a3a99c62d3825edb22b20eb8fcb1d1b39e28e21","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void CheckAndUpdateDhcpFlow(VirtualMachine instance) {\n\t\tif (!_isEnabled) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (instance.getType() == VirtualMachine.Type.DomainRouter) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong accountId = instance.getAccountId();\n\t\t/* FIXME: Redundant virtual router doesn't support OVS */\n\t\tDomainRouterVO router = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn()).get(0);\n\t\tif (router == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!_vlanMappingDirtyDao.isDirty(accountId)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tlong hostId = router.getHostId();\n\t\t\tString tag = Long.toString(_vlanMappingDao.findByAccountIdAndHostId(accountId, hostId).getVlan());\n\t\t\tVmFlowLogVO log = _flowLogDao.findOrNewByVmId(instance.getId(), instance.getHostName());\n\t\t\tString vlans = getVlanInPortMapping(accountId, hostId);\n\t\t\ts_logger.debug(\"ask router \" + router.getHostName() + \" on host \"\n\t\t\t\t\t+ hostId + \" update vlan map to \" + vlans);\n\t\t\tCommands cmds = new Commands(new OvsSetTagAndFlowCommand(\n\t\t\t\t\trouter.getHostName(), tag, vlans, Long.toString(log.getLogsequence()), instance.getId()));\n\t\t\t_agentMgr.send(router.getHostId(), cmds, _ovsListener);\n\t\t} catch (Exception e) {\n\t\t\ts_logger.warn(\"apply flow to router failed\", e);\n\t\t}\n\t}","id":95911,"modified_method":"protected void CheckAndUpdateDhcpFlow(VirtualMachine instance) {\n\t\tif (!_isEnabled) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (instance.getType() == VirtualMachine.Type.DomainRouter) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong accountId = instance.getAccountId();\n\t\tList<DomainRouterVO> routers = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn());\n\t\tif (routers.size() == 0) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!_vlanMappingDirtyDao.isDirty(accountId)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (DomainRouterVO router : routers) {\n\t\t    try {\n\t\t        long hostId = router.getHostId();\n\t\t        String tag = Long.toString(_vlanMappingDao.findByAccountIdAndHostId(accountId, hostId).getVlan());\n\t\t        VmFlowLogVO log = _flowLogDao.findOrNewByVmId(instance.getId(), instance.getHostName());\n\t\t        String vlans = getVlanInPortMapping(accountId, hostId);\n\t\t        s_logger.debug(\"ask router \" + router.getHostName() + \" on host \"\n\t\t                + hostId + \" update vlan map to \" + vlans);\n\t\t        Commands cmds = new Commands(new OvsSetTagAndFlowCommand(\n\t\t                router.getHostName(), tag, vlans, Long.toString(log.getLogsequence()), instance.getId()));\n\t\t        _agentMgr.send(router.getHostId(), cmds, _ovsListener);\n\t\t    } catch (Exception e) {\n\t\t        s_logger.warn(\"apply flow to router failed\", e);\n\t\t    }\n\t\t}\n\t}","commit_id":"7f6a3bca4c44d18648eb9c7f315d12361a6fc3ed","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Set<Long> getAffectedVms(VMInstanceVO instance, boolean tellRouter) {\n\t\tlong accountId = instance.getAccountId();\n\t\tif (!_vlanMappingDirtyDao.isDirty(accountId)) {\n\t\t\ts_logger.debug(\"OVSAFFECTED: no VM affected by \" + instance.getHostName());\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tSet<Long> affectedVms = new HashSet<Long>();\n\t\tList<UserVmVO> vms = _userVmDao.listByAccountId(accountId);\n\t\tfor (UserVmVO vm : vms) {\n\t\t\taffectedVms.add(new Long(vm.getId()));\n\t\t}\n\t\t\n\t\tif (tellRouter && instance.getType() != VirtualMachine.Type.DomainRouter) {\n\t\t    /* FIXME: Redundant virtual router doesn't support OVS */\n\t\t\tDomainRouterVO router = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn()).get(0);\n\t\t\tif (router != null) {\n\t\t\t\taffectedVms.add(new Long(router.getId()));\n\t\t\t}\n\t\t}\n\t\treturn affectedVms;\n\t}","id":95912,"modified_method":"protected Set<Long> getAffectedVms(VMInstanceVO instance, boolean tellRouter) {\n\t\tlong accountId = instance.getAccountId();\n\t\tif (!_vlanMappingDirtyDao.isDirty(accountId)) {\n\t\t\ts_logger.debug(\"OVSAFFECTED: no VM affected by \" + instance.getHostName());\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tSet<Long> affectedVms = new HashSet<Long>();\n\t\tList<UserVmVO> vms = _userVmDao.listByAccountId(accountId);\n\t\tfor (UserVmVO vm : vms) {\n\t\t\taffectedVms.add(new Long(vm.getId()));\n\t\t}\n\t\t\n\t\tif (tellRouter && instance.getType() != VirtualMachine.Type.DomainRouter) {\n\t\t\tList<DomainRouterVO> routers = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn());\n\t\t\tfor (DomainRouterVO router : routers) {\n\t\t\t    if (router != null) {\n\t\t\t        affectedVms.add(new Long(router.getId()));\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\treturn affectedVms;\n\t}","commit_id":"7f6a3bca4c44d18648eb9c7f315d12361a6fc3ed","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n\tprotected void CheckAndCreateTunnel(VirtualMachine instance,\n\t\t\tDeployDestination dest) throws GreTunnelException {\n\t\tif (!_isEnabled) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (instance.getType() != VirtualMachine.Type.User\n\t\t\t\t&& instance.getType() != VirtualMachine.Type.DomainRouter) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal Transaction txn = Transaction.currentTxn();\n\t\tlong hostId = dest.getHost().getId();\n\t\tlong accountId = instance.getAccountId();\n\t\tList<UserVmVO>vms = _userVmDao.listByAccountId(accountId);\n\t\t/* FIXME: Redundant virtual router doesn't support OVS */\n\t\tDomainRouterVO router = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn()).get(0);\n\t\tList<VMInstanceVO>ins = new ArrayList<VMInstanceVO>();\n\t\tins.addAll(vms);\n\t\tins.add(router);\n\t\tList<Long>toHostIds = new ArrayList<Long>();\n\t\tList<Long>fromHostIds = new ArrayList<Long>();\n\t\t\n\t\tfor (VMInstanceVO v : ins) {\n\t\t\tLong rh = v.getHostId();\n\t\t\tif (rh == null || rh.longValue() == hostId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttxn.start();\n\t\t\tGreTunnelVO tunnel = _tunnelDao.lockByFromAndTo(hostId,\n\t\t\t\t\trh.longValue());\n\t\t\ttxn.commit();\n\t\t\tif (tunnel == null) {\n\t\t\t\tthrow new GreTunnelException(String.format(\n\t\t\t\t\t\t\"No entity(from=%1$s, to=%2$s) of failed to lock\",\n\t\t\t\t\t\thostId, rh.longValue()));\n\t\t\t}\n\n\t\t\tif (tunnel.getInPort() == 0 && !toHostIds.contains(rh)) {\n\t\t\t\ttoHostIds.add(rh);\n\t\t\t}\n\t\t\t\n\t\t\ttxn.start();\n\t\t\ttunnel = _tunnelDao.lockByFromAndTo(rh.longValue(), hostId);\n\t\t\ttxn.commit();\n\t\t\tif (tunnel == null) {\n\t\t\t\tthrow new GreTunnelException(String.format(\n\t\t\t\t\t\t\"No entity(from=%1$s, to=%2$s) of failed to lock\",\n\t\t\t\t\t\trh.longValue(), hostId));\n\t\t\t}\n\n\t\t\tif (tunnel.getInPort() == 0 && !fromHostIds.contains(rh)) {\n\t\t\t\tfromHostIds.add(rh);\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tString myIp = dest.getHost().getPrivateIpAddress();\n\t\t\tfor (Long i : toHostIds) {\n\t\t\t\tHostVO rHost = _hostDao.findById(i.longValue());\n\t\t\t\tCommands cmds = new Commands(\n\t\t\t\t\t\tnew OvsCreateGreTunnelCommand(\n\t\t\t\t\t\t\t\trHost.getPrivateIpAddress(), \"1\", hostId,\n\t\t\t\t\t\t\t\ti.longValue()));\n\t\t\t\ts_logger.debug(\"Ask host \" + hostId + \" to create gre tunnel to \" + i.longValue());\n\t\t\t\tAnswer[] answers = _agentMgr.send(hostId, cmds);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t\t\n\t\t\tfor (Long i : fromHostIds) {\n\t\t\t\tCommands cmd2s = new Commands(new OvsCreateGreTunnelCommand(myIp, \"1\", i.longValue(), hostId));\n\t\t\t\ts_logger.debug(\"Ask host \" + i.longValue() + \" to create gre tunnel to \" + hostId);\n\t\t\t\tAnswer[] answers = _agentMgr.send(i.longValue(), cmd2s);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t    s_logger.warn(\"Ovs vlan remap network creates tunnel failed\", e);\n\t\t}\t\n\t}","id":95913,"modified_method":"@DB\n\tprotected void CheckAndCreateTunnel(VirtualMachine instance,\n\t\t\tDeployDestination dest) throws GreTunnelException {\n\t\tif (!_isEnabled) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (instance.getType() != VirtualMachine.Type.User\n\t\t\t\t&& instance.getType() != VirtualMachine.Type.DomainRouter) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal Transaction txn = Transaction.currentTxn();\n\t\tlong hostId = dest.getHost().getId();\n\t\tlong accountId = instance.getAccountId();\n\t\tList<UserVmVO>vms = _userVmDao.listByAccountId(accountId);\n\t\tList<DomainRouterVO> routers = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn());\n\t\tList<VMInstanceVO>ins = new ArrayList<VMInstanceVO>();\n\t\tins.addAll(vms);\n\t\tins.addAll(routers);\n\t\tList<Long>toHostIds = new ArrayList<Long>();\n\t\tList<Long>fromHostIds = new ArrayList<Long>();\n\t\t\n\t\tfor (VMInstanceVO v : ins) {\n\t\t\tLong rh = v.getHostId();\n\t\t\tif (rh == null || rh.longValue() == hostId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttxn.start();\n\t\t\tGreTunnelVO tunnel = _tunnelDao.lockByFromAndTo(hostId,\n\t\t\t\t\trh.longValue());\n\t\t\ttxn.commit();\n\t\t\tif (tunnel == null) {\n\t\t\t\tthrow new GreTunnelException(String.format(\n\t\t\t\t\t\t\"No entity(from=%1$s, to=%2$s) of failed to lock\",\n\t\t\t\t\t\thostId, rh.longValue()));\n\t\t\t}\n\n\t\t\tif (tunnel.getInPort() == 0 && !toHostIds.contains(rh)) {\n\t\t\t\ttoHostIds.add(rh);\n\t\t\t}\n\t\t\t\n\t\t\ttxn.start();\n\t\t\ttunnel = _tunnelDao.lockByFromAndTo(rh.longValue(), hostId);\n\t\t\ttxn.commit();\n\t\t\tif (tunnel == null) {\n\t\t\t\tthrow new GreTunnelException(String.format(\n\t\t\t\t\t\t\"No entity(from=%1$s, to=%2$s) of failed to lock\",\n\t\t\t\t\t\trh.longValue(), hostId));\n\t\t\t}\n\n\t\t\tif (tunnel.getInPort() == 0 && !fromHostIds.contains(rh)) {\n\t\t\t\tfromHostIds.add(rh);\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tString myIp = dest.getHost().getPrivateIpAddress();\n\t\t\tfor (Long i : toHostIds) {\n\t\t\t\tHostVO rHost = _hostDao.findById(i.longValue());\n\t\t\t\tCommands cmds = new Commands(\n\t\t\t\t\t\tnew OvsCreateGreTunnelCommand(\n\t\t\t\t\t\t\t\trHost.getPrivateIpAddress(), \"1\", hostId,\n\t\t\t\t\t\t\t\ti.longValue()));\n\t\t\t\ts_logger.debug(\"Ask host \" + hostId + \" to create gre tunnel to \" + i.longValue());\n\t\t\t\tAnswer[] answers = _agentMgr.send(hostId, cmds);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t\t\n\t\t\tfor (Long i : fromHostIds) {\n\t\t\t\tCommands cmd2s = new Commands(new OvsCreateGreTunnelCommand(myIp, \"1\", i.longValue(), hostId));\n\t\t\t\ts_logger.debug(\"Ask host \" + i.longValue() + \" to create gre tunnel to \" + hostId);\n\t\t\t\tAnswer[] answers = _agentMgr.send(i.longValue(), cmd2s);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t    s_logger.warn(\"Ovs vlan remap network creates tunnel failed\", e);\n\t\t}\t\n\t}","commit_id":"7f6a3bca4c44d18648eb9c7f315d12361a6fc3ed","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void CheckAndDestroyTunnel(VirtualMachine vm) {\n        if (!_isEnabled) {\n            return;\n        }\n        \n        List<UserVmVO> userVms = _userVmDao.listByAccountIdAndHostId(vm.getAccountId(), vm.getHostId());\n        if (vm.getType() == VirtualMachine.Type.User) {\n            if (userVms.size() > 1) {\n                return;\n            }\n            \n            DomainRouterVO router = _routerDao.findBy(vm.getAccountId(), vm.getDataCenterIdToDeployIn()).get(0);\n            if (router.getHostId() == vm.getHostId()) {\n                return;\n            }\n        } else if (vm.getType() == VirtualMachine.Type.DomainRouter && userVms.size() != 0) {\n                return;\n        }\n        \n        try {\n            /* Now we are last one on host, destroy all tunnels of my account */\n            Command cmd = new OvsDestroyTunnelCommand(vm.getAccountId(), \"[]\");\n            Answer ans = _agentMgr.send(vm.getHostId(), cmd);\n            handleDestroyTunnelAnswer(ans, vm.getHostId(), 0, vm.getAccountId());\n            \n            /* Then ask hosts have peer tunnel with me to destroy them */\n            List<OvsTunnelAccountVO> peers = _tunnelAccountDao.listByToAccount(vm.getHostId(), vm.getAccountId());\n            for (OvsTunnelAccountVO p : peers) {\n                cmd = new OvsDestroyTunnelCommand(p.getAccount(), p.getPortName());\n                ans = _agentMgr.send(p.getFrom(), cmd);\n                handleDestroyTunnelAnswer(ans, p.getFrom(), p.getTo(), p.getAccount());\n            }\n        } catch (Exception e) {\n            s_logger.warn(String.format(\"Destroy tunnel(account:%1$s, hostId:%2$s) failed\", vm.getAccountId(), vm.getHostId()), e);\n        }\n        \n    }","id":95914,"modified_method":"@Override\n    public void CheckAndDestroyTunnel(VirtualMachine vm) {\n        if (!_isEnabled) {\n            return;\n        }\n        \n        List<UserVmVO> userVms = _userVmDao.listByAccountIdAndHostId(vm.getAccountId(), vm.getHostId());\n        if (vm.getType() == VirtualMachine.Type.User) {\n            if (userVms.size() > 1) {\n                return;\n            }\n            \n            List<DomainRouterVO> routers = _routerDao.findBy(vm.getAccountId(), vm.getDataCenterIdToDeployIn());\n            for (DomainRouterVO router : routers) {\n                if (router.getHostId() == vm.getHostId()) {\n                    return;\n                }\n            }\n        } else if (vm.getType() == VirtualMachine.Type.DomainRouter && userVms.size() != 0) {\n                return;\n        }\n        \n        try {\n            /* Now we are last one on host, destroy all tunnels of my account */\n            Command cmd = new OvsDestroyTunnelCommand(vm.getAccountId(), \"[]\");\n            Answer ans = _agentMgr.send(vm.getHostId(), cmd);\n            handleDestroyTunnelAnswer(ans, vm.getHostId(), 0, vm.getAccountId());\n            \n            /* Then ask hosts have peer tunnel with me to destroy them */\n            List<OvsTunnelAccountVO> peers = _tunnelAccountDao.listByToAccount(vm.getHostId(), vm.getAccountId());\n            for (OvsTunnelAccountVO p : peers) {\n                cmd = new OvsDestroyTunnelCommand(p.getAccount(), p.getPortName());\n                ans = _agentMgr.send(p.getFrom(), cmd);\n                handleDestroyTunnelAnswer(ans, p.getFrom(), p.getTo(), p.getAccount());\n            }\n        } catch (Exception e) {\n            s_logger.warn(String.format(\"Destroy tunnel(account:%1$s, hostId:%2$s) failed\", vm.getAccountId(), vm.getHostId()), e);\n        }\n        \n    }","commit_id":"7f6a3bca4c44d18648eb9c7f315d12361a6fc3ed","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    protected void CheckAndCreateTunnel(VirtualMachine instance, DeployDestination dest) {\n\t\tif (!_isEnabled) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (instance.getType() != VirtualMachine.Type.User\n\t\t\t\t&& instance.getType() != VirtualMachine.Type.DomainRouter) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong hostId = dest.getHost().getId();\n\t\tlong accountId = instance.getAccountId();\n\t\tList<UserVmVO>vms = _userVmDao.listByAccountId(accountId);\n\t\t/* FIXME: Redundant virtual router doesn't support OVS */\n\t\tDomainRouterVO router = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn()).get(0);\n\t\tList<VMInstanceVO>ins = new ArrayList<VMInstanceVO>();\n\t\tif (vms != null) {\n\t\t\tins.addAll(vms);\n\t\t}\n\t\tif (router != null) {\n\t\t\tins.add(router);\n\t\t}\n\t\tList<Pair<Long, Integer>>toHosts = new ArrayList<Pair<Long, Integer>>();\n\t\tList<Pair<Long, Integer>>fromHosts = new ArrayList<Pair<Long, Integer>>();\n\t\tint key;\n\t\t\n        for (VMInstanceVO v : ins) {\n            Long rh = v.getHostId();\n            if (rh == null || rh.longValue() == hostId) {\n                continue;\n            }\n\n            OvsTunnelAccountVO ta = _tunnelAccountDao.getByFromToAccount(hostId, rh.longValue(), accountId);\n            if (ta == null) {\n                key = getGreKey(hostId, rh.longValue(), accountId);\n                if (key == -1) {\n                    s_logger.warn(String.format(\"Cannot get GRE key for from=%1$s to=%2$s accountId=%3$s, tunnel create failed\", hostId, rh.longValue(), accountId));\n                    continue;\n                }\n\n                Pair<Long, Integer> p = new Pair<Long, Integer>(rh, Integer.valueOf(key));\n                if (!toHosts.contains(p)) {\n                    toHosts.add(p);\n                } \n            }\n\n            ta = _tunnelAccountDao.getByFromToAccount(rh.longValue(), hostId, accountId);\n            if (ta == null) {\n                key = getGreKey(rh.longValue(), hostId, accountId);\n                if (key == -1) {\n                    s_logger.warn(String.format(\"Cannot get GRE key for from=%1$s to=%2$s accountId=%3$s, tunnel create failed\", rh.longValue(), hostId, accountId));\n                    continue;\n                }\n\n                Pair<Long, Integer> p = new Pair<Long, Integer>(rh, Integer.valueOf(key));\n                if (!fromHosts.contains(p)) {\n                    fromHosts.add(p);\n                }\n            }\n        }\n\t\t\n\t\ttry {\n\t\t\tString myIp = dest.getHost().getPrivateIpAddress();\n\t\t\tfor (Pair<Long, Integer> i : toHosts) {\n\t\t\t\tHostVO rHost = _hostDao.findById(i.first());\n\t\t\t\tCommands cmds = new Commands(\n\t\t\t\t\t\tnew OvsCreateTunnelCommand(rHost.getPrivateIpAddress(), i.second().toString(), Long.valueOf(hostId), i.first(), accountId, myIp));\n\t\t\t\ts_logger.debug(\"Ask host \" + hostId + \" to create gre tunnel to \" + i.first());\n\t\t\t\tAnswer[] answers = _agentMgr.send(hostId, cmds);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t\t\n\t\t\tfor (Pair<Long, Integer> i : fromHosts) {\n\t\t\t    HostVO rHost = _hostDao.findById(i.first());\n\t\t\t\tCommands cmd2s = new Commands(\n\t\t\t\t        new OvsCreateTunnelCommand(myIp, i.second().toString(), i.first(), Long.valueOf(hostId), accountId, rHost.getPrivateIpAddress()));\n\t\t\t\ts_logger.debug(\"Ask host \" + i.first() + \" to create gre tunnel to \" + hostId);\n\t\t\t\tAnswer[] answers = _agentMgr.send(i.first(), cmd2s);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t    s_logger.debug(\"Ovs Tunnel network created tunnel failed\", e);\n\t\t}\t\n\t}","id":95915,"modified_method":"@DB\n    protected void CheckAndCreateTunnel(VirtualMachine instance, DeployDestination dest) {\n\t\tif (!_isEnabled) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (instance.getType() != VirtualMachine.Type.User\n\t\t\t\t&& instance.getType() != VirtualMachine.Type.DomainRouter) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong hostId = dest.getHost().getId();\n\t\tlong accountId = instance.getAccountId();\n\t\tList<UserVmVO>vms = _userVmDao.listByAccountId(accountId);\n\t\tList<DomainRouterVO> routers = _routerDao.findBy(accountId, instance.getDataCenterIdToDeployIn());\n\t\tList<VMInstanceVO>ins = new ArrayList<VMInstanceVO>();\n\t\tif (vms != null) {\n\t\t\tins.addAll(vms);\n\t\t}\n\t\tif (routers.size() != 0) {\n\t\t\tins.addAll(routers);\n\t\t}\n\t\tList<Pair<Long, Integer>>toHosts = new ArrayList<Pair<Long, Integer>>();\n\t\tList<Pair<Long, Integer>>fromHosts = new ArrayList<Pair<Long, Integer>>();\n\t\tint key;\n\t\t\n        for (VMInstanceVO v : ins) {\n            Long rh = v.getHostId();\n            if (rh == null || rh.longValue() == hostId) {\n                continue;\n            }\n\n            OvsTunnelAccountVO ta = _tunnelAccountDao.getByFromToAccount(hostId, rh.longValue(), accountId);\n            if (ta == null) {\n                key = getGreKey(hostId, rh.longValue(), accountId);\n                if (key == -1) {\n                    s_logger.warn(String.format(\"Cannot get GRE key for from=%1$s to=%2$s accountId=%3$s, tunnel create failed\", hostId, rh.longValue(), accountId));\n                    continue;\n                }\n\n                Pair<Long, Integer> p = new Pair<Long, Integer>(rh, Integer.valueOf(key));\n                if (!toHosts.contains(p)) {\n                    toHosts.add(p);\n                } \n            }\n\n            ta = _tunnelAccountDao.getByFromToAccount(rh.longValue(), hostId, accountId);\n            if (ta == null) {\n                key = getGreKey(rh.longValue(), hostId, accountId);\n                if (key == -1) {\n                    s_logger.warn(String.format(\"Cannot get GRE key for from=%1$s to=%2$s accountId=%3$s, tunnel create failed\", rh.longValue(), hostId, accountId));\n                    continue;\n                }\n\n                Pair<Long, Integer> p = new Pair<Long, Integer>(rh, Integer.valueOf(key));\n                if (!fromHosts.contains(p)) {\n                    fromHosts.add(p);\n                }\n            }\n        }\n\t\t\n\t\ttry {\n\t\t\tString myIp = dest.getHost().getPrivateIpAddress();\n\t\t\tfor (Pair<Long, Integer> i : toHosts) {\n\t\t\t\tHostVO rHost = _hostDao.findById(i.first());\n\t\t\t\tCommands cmds = new Commands(\n\t\t\t\t\t\tnew OvsCreateTunnelCommand(rHost.getPrivateIpAddress(), i.second().toString(), Long.valueOf(hostId), i.first(), accountId, myIp));\n\t\t\t\ts_logger.debug(\"Ask host \" + hostId + \" to create gre tunnel to \" + i.first());\n\t\t\t\tAnswer[] answers = _agentMgr.send(hostId, cmds);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t\t\n\t\t\tfor (Pair<Long, Integer> i : fromHosts) {\n\t\t\t    HostVO rHost = _hostDao.findById(i.first());\n\t\t\t\tCommands cmd2s = new Commands(\n\t\t\t\t        new OvsCreateTunnelCommand(myIp, i.second().toString(), i.first(), Long.valueOf(hostId), accountId, rHost.getPrivateIpAddress()));\n\t\t\t\ts_logger.debug(\"Ask host \" + i.first() + \" to create gre tunnel to \" + hostId);\n\t\t\t\tAnswer[] answers = _agentMgr.send(i.first(), cmd2s);\n\t\t\t\thandleCreateTunnelAnswer(answers);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t    s_logger.debug(\"Ovs Tunnel network created tunnel failed\", e);\n\t\t}\t\n\t}","commit_id":"7f6a3bca4c44d18648eb9c7f315d12361a6fc3ed","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n        ReadOnlyTree child = new ReadOnlyTree(parentAfter, name, after);\n\n        int permissions = getPermissions(child, Permissions.ADD_NODE);\n        checkPermissions(child.getPath(), permissions);\n\n        return new PermissionValidator(compiledPermissions, null, child);\n    }","id":95916,"modified_method":"@Override\n    public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n        ReadOnlyTree child = new ReadOnlyTree(parentAfter, name, after);\n        return checkPermissions(child, false, Permissions.ADD_NODE);\n    }","commit_id":"7be3419216a51a02a0aa7051ac7a5b64024ebbc5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) throws CommitFailedException {\n        int permissions = getPermissions(after, Permissions.MODIFY_PROPERTY);\n        checkPermissions(getPath(after), permissions);\n    }","id":95917,"modified_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) throws CommitFailedException {\n        checkPermissions(parentAfter, after, Permissions.MODIFY_PROPERTY);\n    }","commit_id":"7be3419216a51a02a0aa7051ac7a5b64024ebbc5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\n        ReadOnlyTree child = new ReadOnlyTree(parentBefore, name, before);\n\n        int permissions = getPermissions(child, Permissions.REMOVE_NODE);\n        checkPermissions(child.getPath(), permissions);\n\n        return new PermissionValidator(compiledPermissions, child, null);\n    }","id":95918,"modified_method":"@Override\n    public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\n        ReadOnlyTree child = new ReadOnlyTree(parentBefore, name, before);\n        return checkPermissions(child, true, Permissions.REMOVE_NODE);\n    }","commit_id":"7be3419216a51a02a0aa7051ac7a5b64024ebbc5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyAdded(PropertyState after) throws CommitFailedException {\n        int permissions = getPermissions(after, Permissions.ADD_PROPERTY);\n        checkPermissions(getPath(after), permissions);\n    }","id":95919,"modified_method":"@Override\n    public void propertyAdded(PropertyState after) throws CommitFailedException {\n        checkPermissions(parentAfter, after, Permissions.ADD_PROPERTY);\n    }","commit_id":"7be3419216a51a02a0aa7051ac7a5b64024ebbc5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyDeleted(PropertyState before) throws CommitFailedException {\n        int permissions = getPermissions(before, Permissions.REMOVE_PROPERTY);\n        checkPermissions(getPath(before), permissions);\n    }","id":95920,"modified_method":"@Override\n    public void propertyDeleted(PropertyState before) throws CommitFailedException {\n        checkPermissions(parentBefore, before, Permissions.REMOVE_PROPERTY);\n    }","commit_id":"7be3419216a51a02a0aa7051ac7a5b64024ebbc5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private int getPermissions(ReadOnlyTree tree, int defaultPermissions) {\n        if (isProtected(tree)) {\n            // TODO: identify specific permission depending on type of protection\n            return Permissions.NO_PERMISSION;\n        } else {\n            return defaultPermissions;\n        }\n    }","id":95921,"modified_method":"private PermissionValidator checkPermissions(ReadOnlyTree tree, boolean isBefore, int defaultPermission) throws CommitFailedException {\n        String path = tree.getPath();\n        int permission;\n\n        if (isNamespaceDefinition(path)) {\n            permission = Permissions.NAMESPACE_MANAGEMENT;\n        } else if (isNodeTypeDefinition(path)) {\n            permission = Permissions.NODE_TYPE_DEFINITION_MANAGEMENT;\n        } else if (isPrivilegeDefinition(path)) {\n            permission = Permissions.PRIVILEGE_MANAGEMENT;\n        } else if (isAccessControl(tree)) {\n            permission = Permissions.MODIFY_ACCESS_CONTROL;\n        } else {\n            // TODO: identify specific permission depending on additional types of protection\n            // - versioning -> version management\n            // - user/group -> user management\n            // - workspace management ???\n            permission = defaultPermission;\n        }\n\n        if (Permissions.isRepositoryPermissions(permission)) {\n            checkPermissions((String) null, permission);\n            return null; // no need for further validation down the subtree\n        } else {\n            checkPermissions(path, permission);\n            return (isBefore) ?\n                    new PermissionValidator(compiledPermissions, tree, null) :\n                    new PermissionValidator(compiledPermissions, null, tree);\n        }\n    }","commit_id":"7be3419216a51a02a0aa7051ac7a5b64024ebbc5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private int getPermissions(PropertyState property, int defaultPermission) {\n        if (isProtected(property)) {\n            // TODO: identify specific permission depending on type of protection\n            // - access controlled property\n            // - lock property\n            // - version property\n            // - mixinType/primaryType -> nt-management permission\n            // - node type definition -> nt-definition-management\n            // - namespace definition -> namespace management\n            // - privilege -> privilege management\n            // - user/group property -> user management\n            return Permissions.NO_PERMISSION;\n        } else if (PropertyState.OAK_CHILD_ORDER.equals(property.getName())) {\n            return Permissions.MODIFY_CHILD_NODE_COLLECTION;\n        } else {\n            return defaultPermission;\n        }\n    }","id":95922,"modified_method":"private void checkPermissions(Tree parent, PropertyState property, int defaultPermission) throws CommitFailedException {\n        String parentPath = parent.getPath();\n        String name = property.getName();\n\n        int permission;\n        if (JcrConstants.JCR_PRIMARYTYPE.equals(name) || JcrConstants.JCR_MIXINTYPES.equals(name)) {\n            // TODO: distinguish between autocreated and user-supplied modification (?)\n            permission = Permissions.NODE_TYPE_MANAGEMENT;\n        } else if (PropertyState.OAK_CHILD_ORDER.equals(property.getName())) {\n            permission = Permissions.MODIFY_CHILD_NODE_COLLECTION;\n        } else if (isLockProperty(name)) {\n            permission = Permissions.LOCK_MANAGEMENT;\n        } else if (isNamespaceDefinition(parentPath)) {\n            permission = Permissions.NAMESPACE_MANAGEMENT;\n        } else if (isNodeTypeDefinition(parentPath)) {\n            permission = Permissions.NODE_TYPE_DEFINITION_MANAGEMENT;\n        } else if (isPrivilegeDefinition(parentPath)) {\n            permission = Permissions.PRIVILEGE_MANAGEMENT;\n        } else if (isAccessControl(parent, property)) {\n            permission = Permissions.MODIFY_ACCESS_CONTROL;\n        } else {\n            // TODO: identify specific permission depending on type of protection\n            // - version property -> version management\n            // - user/group property -> user management\n            permission = defaultPermission;\n        }\n\n        checkPermissions(PathUtils.concat(parentPath, name), permission);\n    }","commit_id":"7be3419216a51a02a0aa7051ac7a5b64024ebbc5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @DB\n    @ActionEvent(eventType = EventTypes.EVENT_SNAPSHOT_DELETE, eventDescription = \"deleting snapshot\", async = true)\n    public boolean deleteSnapshot(long snapshotId) {\n        Account caller = CallContext.current().getCallingAccount();\n\n        // Verify parameters\n        SnapshotVO snapshotCheck = _snapshotDao.findById(snapshotId);\n        if (snapshotCheck == null) {\n            throw new InvalidParameterValueException(\"unable to find a snapshot with id \" + snapshotId);\n        }\n\n        _accountMgr.checkAccess(caller, null, true, snapshotCheck);\n        SnapshotStrategy snapshotStrategy = _storageStrategyFactory.getSnapshotStrategy(snapshotCheck, SnapshotOperation.DELETE);\n        if (snapshotStrategy == null) {\n            s_logger.error(\"Unable to find snaphot strategy to handle snapshot with id '\" + snapshotId + \"'\");\n            return false;\n        }\n        SnapshotDataStoreVO snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshotId, DataStoreRole.Image);\n\n        try {\n            boolean result = snapshotStrategy.deleteSnapshot(snapshotId);\n            if (result) {\n                if (snapshotCheck.getState() == Snapshot.State.BackedUp) {\n                    UsageEventUtils.publishUsageEvent(EventTypes.EVENT_SNAPSHOT_DELETE, snapshotCheck.getAccountId(), snapshotCheck.getDataCenterId(), snapshotId,\n                        snapshotCheck.getName(), null, null, 0L, snapshotCheck.getClass().getName(), snapshotCheck.getUuid());\n                }\n                if (snapshotCheck.getState() != Snapshot.State.Error && snapshotCheck.getState() != Snapshot.State.Destroyed)\n                _resourceLimitMgr.decrementResourceCount(snapshotCheck.getAccountId(), ResourceType.snapshot);\n                if (snapshotCheck.getState() == Snapshot.State.BackedUp)\n                    _resourceLimitMgr.decrementResourceCount(snapshotCheck.getAccountId(), ResourceType.secondary_storage, new Long(snapshotStoreRef.getSize()));\n            }\n            return result;\n        } catch (Exception e) {\n            s_logger.debug(\"Failed to delete snapshot: \" + snapshotCheck.getId() + \":\" + e.toString());\n            throw new CloudRuntimeException(\"Failed to delete snapshot:\" + e.toString());\n        }\n    }","id":95923,"modified_method":"@Override\n    @DB\n    @ActionEvent(eventType = EventTypes.EVENT_SNAPSHOT_DELETE, eventDescription = \"deleting snapshot\", async = true)\n    public boolean deleteSnapshot(long snapshotId) {\n        Account caller = CallContext.current().getCallingAccount();\n\n        // Verify parameters\n        SnapshotVO snapshotCheck = _snapshotDao.findById(snapshotId);\n\n        if (snapshotCheck == null) {\n            throw new InvalidParameterValueException(\"unable to find a snapshot with id \" + snapshotId);\n        }\n\n        _accountMgr.checkAccess(caller, null, true, snapshotCheck);\n\n        SnapshotStrategy snapshotStrategy = _storageStrategyFactory.getSnapshotStrategy(snapshotCheck, SnapshotOperation.DELETE);\n\n        if (snapshotStrategy == null) {\n            s_logger.error(\"Unable to find snaphot strategy to handle snapshot with id '\" + snapshotId + \"'\");\n\n            return false;\n        }\n\n        try {\n            boolean result = snapshotStrategy.deleteSnapshot(snapshotId);\n\n            if (result) {\n                if (snapshotCheck.getState() == Snapshot.State.BackedUp) {\n                    UsageEventUtils.publishUsageEvent(EventTypes.EVENT_SNAPSHOT_DELETE, snapshotCheck.getAccountId(), snapshotCheck.getDataCenterId(), snapshotId,\n                        snapshotCheck.getName(), null, null, 0L, snapshotCheck.getClass().getName(), snapshotCheck.getUuid());\n                }\n\n                if (snapshotCheck.getState() != Snapshot.State.Error && snapshotCheck.getState() != Snapshot.State.Destroyed) {\n                    _resourceLimitMgr.decrementResourceCount(snapshotCheck.getAccountId(), ResourceType.snapshot);\n                }\n\n                if (snapshotCheck.getState() == Snapshot.State.BackedUp) {\n                    SnapshotDataStoreVO snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshotId, DataStoreRole.Image);\n\n                    if (snapshotStoreRef != null) {\n                        _resourceLimitMgr.decrementResourceCount(snapshotCheck.getAccountId(), ResourceType.secondary_storage, new Long(snapshotStoreRef.getSize()));\n                    }\n                }\n            }\n\n            return result;\n        } catch (Exception e) {\n            s_logger.debug(\"Failed to delete snapshot: \" + snapshotCheck.getId() + \":\" + e.toString());\n\n            throw new CloudRuntimeException(\"Failed to delete snapshot:\" + e.toString());\n        }\n    }","commit_id":"35a8b70799129f483fc4f3cdc76cb6e055cee90e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Map<String, String> getCapabilities() {\n        return null;\n    }","id":95924,"modified_method":"@Override\n    public Map<String, String> getCapabilities() {\n        Map<String, String> mapCapabilities = new HashMap<String, String>();\n\n        mapCapabilities.put(DataStoreCapabilities.STORAGE_SYSTEM_SNAPSHOT.toString(), Boolean.TRUE.toString());\n\n        return mapCapabilities;\n    }","commit_id":"35a8b70799129f483fc4f3cdc76cb6e055cee90e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void copyAsync(DataObject srcData, DataObject destData, AsyncCompletionCallback<CopyCommandResult> callback) {\n        if (srcData.getType() == DataObjectType.SNAPSHOT && destData.getType() == DataObjectType.SNAPSHOT) {\n            // in this situation, we don't want to copy the snapshot anywhere\n\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(destData.getTO());\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(null);\n\n            callback.complete(result);\n\n            return;\n        }\n\n        throw new UnsupportedOperationException();\n    }","id":95925,"modified_method":"@Override\n    public void copyAsync(DataObject srcData, DataObject destData, AsyncCompletionCallback<CopyCommandResult> callback) {\n        throw new UnsupportedOperationException();\n    }","commit_id":"35a8b70799129f483fc4f3cdc76cb6e055cee90e","url":"https://github.com/apache/cloudstack"},{"original_method":"private String deleteSnapshot(SnapshotInfo snapshotInfo, long storagePoolId) {\n        String errMsg = null;\n\n        try {\n            SolidFireUtil.SolidFireConnection sfConnection = SolidFireUtil.getSolidFireConnection(storagePoolId, _storagePoolDetailsDao);\n\n            SolidFireUtil.deleteSolidFireSnapshot(sfConnection, getSolidFireSnapshotId(snapshotInfo.getId()));\n\n            _snapshotDetailsDao.removeDetails(snapshotInfo.getId());\n        }\n        catch (Exception ex) {\n            s_logger.debug(SolidFireUtil.LOG_PREFIX + \"Failed to delete SolidFire snapshot: \" + snapshotInfo.getId(), ex);\n\n            errMsg = ex.getMessage();\n        }\n\n        return errMsg;\n    }","id":95926,"modified_method":"private String deleteSnapshot(SnapshotInfo snapshotInfo, long storagePoolId) {\n        String errMsg = null;\n\n        try {\n            SolidFireUtil.SolidFireConnection sfConnection = SolidFireUtil.getSolidFireConnection(storagePoolId, _storagePoolDetailsDao);\n\n            SolidFireUtil.deleteSolidFireSnapshot(sfConnection, getSolidFireSnapshotId(snapshotInfo.getId()));\n\n            _snapshotDetailsDao.removeDetails(snapshotInfo.getId());\n\n            StoragePoolVO storagePool = _storagePoolDao.findById(storagePoolId);\n\n            // getUsedBytes(StoragePool) will not include the snapshot to delete because it has already been deleted by this point\n            long usedBytes = getUsedBytes(storagePool);\n\n            storagePool.setUsedBytes(usedBytes < 0 ? 0 : usedBytes);\n\n            _storagePoolDao.update(storagePoolId, storagePool);\n        }\n        catch (Exception ex) {\n            s_logger.debug(SolidFireUtil.LOG_PREFIX + \"Failed to delete SolidFire snapshot: \" + snapshotInfo.getId(), ex);\n\n            errMsg = ex.getMessage();\n        }\n\n        return errMsg;\n    }","commit_id":"35a8b70799129f483fc4f3cdc76cb6e055cee90e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean canCopy(DataObject srcData, DataObject destData) {\n        if (srcData.getType() == DataObjectType.SNAPSHOT && destData.getType() == DataObjectType.SNAPSHOT) {\n            return true;\n        }\n\n        return false;\n    }","id":95927,"modified_method":"@Override\n    public boolean canCopy(DataObject srcData, DataObject destData) {\n        return false;\n    }","commit_id":"35a8b70799129f483fc4f3cdc76cb6e055cee90e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean deleteSnapshotDirsForAccount(long accountId) {\n\n        List<VolumeVO> volumes = _volsDao.findByAccount(accountId);\n        // The above call will list only non-destroyed volumes.\n        // So call this method before marking the volumes as destroyed.\n        // i.e Call them before the VMs for those volumes are destroyed.\n        boolean success = true;\n        for (VolumeVO volume : volumes) {\n            if (volume.getPoolId() == null) {\n                continue;\n            }\n            Long volumeId = volume.getId();\n            Long dcId = volume.getDataCenterId();\n            if (_snapshotDao.listByVolumeIdIncludingRemoved(volumeId).isEmpty()) {\n                // This volume doesn't have any snapshots. Nothing do delete.\n                continue;\n            }\n            List<DataStore> ssHosts = dataStoreMgr.getImageStoresByScope(new ZoneScope(dcId));\n            for (DataStore ssHost : ssHosts) {\n                String snapshotDir = TemplateConstants.DEFAULT_SNAPSHOT_ROOT_DIR + \"/\" + accountId + \"/\" + volumeId;\n                DeleteSnapshotsDirCommand cmd = new DeleteSnapshotsDirCommand(ssHost.getTO(), snapshotDir);\n                EndPoint ep = _epSelector.select(ssHost);\n                Answer answer = null;\n                if (ep == null) {\n                    String errMsg = \"No remote endpoint to send command, check if host or ssvm is down?\";\n                    s_logger.error(errMsg);\n                    answer = new Answer(cmd, false, errMsg);\n                } else {\n                    answer = ep.sendMessage(cmd);\n                }\n                if ((answer != null) && answer.getResult()) {\n                    s_logger.debug(\"Deleted all snapshots for volume: \" + volumeId + \" under account: \" + accountId);\n                } else {\n                    success = false;\n                    if (answer != null) {\n                        s_logger.warn(\"Failed to delete all snapshot for volume \" + volumeId + \" on secondary storage \" + ssHost.getUri());\n                        s_logger.error(answer.getDetails());\n                    }\n                }\n            }\n\n            // Either way delete the snapshots for this volume.\n            List<SnapshotVO> snapshots = listSnapsforVolume(volumeId);\n            for (SnapshotVO snapshot : snapshots) {\n                SnapshotStrategy snapshotStrategy = _storageStrategyFactory.getSnapshotStrategy(snapshot, SnapshotOperation.DELETE);\n                if (snapshotStrategy == null) {\n                    s_logger.error(\"Unable to find snaphot strategy to handle snapshot with id '\" + snapshot.getId() + \"'\");\n                    continue;\n                }\n                SnapshotDataStoreVO snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshot.getId(), DataStoreRole.Image);\n\n                if (snapshotStrategy.deleteSnapshot(snapshot.getId())) {\n                    if (Type.MANUAL == snapshot.getRecurringType()) {\n                        _resourceLimitMgr.decrementResourceCount(accountId, ResourceType.snapshot);\n                        _resourceLimitMgr.decrementResourceCount(accountId, ResourceType.secondary_storage, new Long(snapshotStoreRef.getSize()));\n                    }\n\n                    // Log event after successful deletion\n                    UsageEventUtils.publishUsageEvent(EventTypes.EVENT_SNAPSHOT_DELETE, snapshot.getAccountId(), volume.getDataCenterId(), snapshot.getId(),\n                        snapshot.getName(), null, null, volume.getSize(), snapshot.getClass().getName(), snapshot.getUuid());\n                }\n            }\n        }\n\n        // Returns true if snapshotsDir has been deleted for all volumes.\n        return success;\n    }","id":95928,"modified_method":"@Override\n    public boolean deleteSnapshotDirsForAccount(long accountId) {\n\n        List<VolumeVO> volumes = _volsDao.findByAccount(accountId);\n        // The above call will list only non-destroyed volumes.\n        // So call this method before marking the volumes as destroyed.\n        // i.e Call them before the VMs for those volumes are destroyed.\n        boolean success = true;\n        for (VolumeVO volume : volumes) {\n            if (volume.getPoolId() == null) {\n                continue;\n            }\n            Long volumeId = volume.getId();\n            Long dcId = volume.getDataCenterId();\n            if (_snapshotDao.listByVolumeIdIncludingRemoved(volumeId).isEmpty()) {\n                // This volume doesn't have any snapshots. Nothing do delete.\n                continue;\n            }\n            List<DataStore> ssHosts = dataStoreMgr.getImageStoresByScope(new ZoneScope(dcId));\n            for (DataStore ssHost : ssHosts) {\n                String snapshotDir = TemplateConstants.DEFAULT_SNAPSHOT_ROOT_DIR + \"/\" + accountId + \"/\" + volumeId;\n                DeleteSnapshotsDirCommand cmd = new DeleteSnapshotsDirCommand(ssHost.getTO(), snapshotDir);\n                EndPoint ep = _epSelector.select(ssHost);\n                Answer answer = null;\n                if (ep == null) {\n                    String errMsg = \"No remote endpoint to send command, check if host or ssvm is down?\";\n                    s_logger.error(errMsg);\n                    answer = new Answer(cmd, false, errMsg);\n                } else {\n                    answer = ep.sendMessage(cmd);\n                }\n                if ((answer != null) && answer.getResult()) {\n                    s_logger.debug(\"Deleted all snapshots for volume: \" + volumeId + \" under account: \" + accountId);\n                } else {\n                    success = false;\n                    if (answer != null) {\n                        s_logger.warn(\"Failed to delete all snapshot for volume \" + volumeId + \" on secondary storage \" + ssHost.getUri());\n                        s_logger.error(answer.getDetails());\n                    }\n                }\n            }\n\n            // Either way delete the snapshots for this volume.\n            List<SnapshotVO> snapshots = listSnapsforVolume(volumeId);\n            for (SnapshotVO snapshot : snapshots) {\n                SnapshotStrategy snapshotStrategy = _storageStrategyFactory.getSnapshotStrategy(snapshot, SnapshotOperation.DELETE);\n                if (snapshotStrategy == null) {\n                    s_logger.error(\"Unable to find snaphot strategy to handle snapshot with id '\" + snapshot.getId() + \"'\");\n                    continue;\n                }\n                SnapshotDataStoreVO snapshotStoreRef = _snapshotStoreDao.findBySnapshot(snapshot.getId(), DataStoreRole.Image);\n\n                if (snapshotStrategy.deleteSnapshot(snapshot.getId())) {\n                    if (Type.MANUAL == snapshot.getRecurringType()) {\n                        _resourceLimitMgr.decrementResourceCount(accountId, ResourceType.snapshot);\n                        if  (snapshotStoreRef != null) {\n                            _resourceLimitMgr.decrementResourceCount(accountId, ResourceType.secondary_storage, new Long(snapshotStoreRef.getSize()));\n                        }\n                    }\n\n                    // Log event after successful deletion\n                    UsageEventUtils.publishUsageEvent(EventTypes.EVENT_SNAPSHOT_DELETE, snapshot.getAccountId(), volume.getDataCenterId(), snapshot.getId(),\n                        snapshot.getName(), null, null, volume.getSize(), snapshot.getClass().getName(), snapshot.getUuid());\n                }\n            }\n        }\n\n        // Returns true if snapshotsDir has been deleted for all volumes.\n        return success;\n    }","commit_id":"165618ac9ac2937fbb1d7ff0da89de1abba4ccc1","url":"https://github.com/apache/cloudstack"},{"original_method":"public Long getAccountId() {\n        return accountId;\n    }","id":95929,"modified_method":"public String getAccountName() {\n        return accountName;\n    }","commit_id":"88f9b1ab7cbba0c4a28b5bc7d70671f577b60962","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    @Override\n    @ActionEvent(eventType = EventTypes.EVENT_VM_MOVE, eventDescription = \"move VM to another user\", async = false)\n    public UserVm moveVMToUser(AssignVMCmd cmd) throws ResourceAllocationException, ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {\n        // VERIFICATIONS and VALIDATIONS\n\n        //VV 1: verify the two users\n        Account oldAccount = UserContext.current().getCaller();\n        Account newAccount = _accountService.getAccount(cmd.getAccountId());\n        if (newAccount == null || newAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Invalid accountid=\" + cmd.getAccountId() + \" in domain \" + oldAccount.getDomainId());\n        }\n\n        //don't allow to move the vm from the project\n        if (oldAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Vm id=\" + cmd.getVmId() + \" belongs to the project and can't be moved\");\n        }\n\n        //VV 2: check if account/domain is with in resource limits to create a new vm\n        _resourceLimitMgr.checkResourceLimit(newAccount, ResourceType.user_vm);\n\n        //get the VM\n        UserVmVO vm = _vmDao.findById(cmd.getVmId());\n\n        if (vm == null){\n            throw new InvalidParameterValueException(\"There is no vm by that id \" + cmd.getVmId());\n        } else if (vm.getState() == State.Running) {  // VV 3: check if vm is running\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is Running, unable to move the vm \" + vm);\n            }\n            throw new InvalidParameterValueException(\"VM is Running, unable to move the vm \" + vm);\n        }\n\n        // VV 4: Check if new owner can use the vm template\n        VirtualMachineTemplate template = _templateDao.findById(vm.getTemplateId());\n        if (!template.isPublicTemplate()) {\n            Account templateOwner = _accountMgr.getAccount(template.getAccountId());\n            _accountMgr.checkAccess(newAccount, null, templateOwner);\n        }\n\n        // VV 5: check that vm owner can create vm in the domain\n        DomainVO domain = _domainDao.findById(oldAccount.getDomainId());\n        _accountMgr.checkAccess(newAccount, domain);\n\n        DataCenterVO zone = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n\n        //check is zone networking is advanced\n        if (zone.getNetworkType() != NetworkType.Advanced) { \n            throw new InvalidParameterValueException(\"Assing virtual machine to another account is only available for advanced networking \" + vm);\n        }\n\n        VMInstanceVO vmoi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n        VirtualMachineProfileImpl<VMInstanceVO> vmOldProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmoi);\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        //generate destory vm event for usage\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_DESTROY, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(), vm.getTemplateId(), vm.getHypervisorType().toString()));\n        // update resource counts\n        _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.user_vm);\n\n        // OWNERSHIP STEP 1: update the vm owner\n        vm.setAccountId(newAccount.getAccountId());\n        _vmDao.persist(vm);\n        // OS 2: update volume\n        List<VolumeVO> volumes = _volsDao.findByInstance(cmd.getVmId());\n        for (VolumeVO volume : volumes) {\n            volume.setAccountId(cmd.getAccountId());\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume, new Long(volumes.size()));\n            _volsDao.persist(volume);\n            _resourceLimitMgr.incrementResourceCount(vm.getAccountId(), ResourceType.volume, new Long(volumes.size()));\n        }\n\n        _resourceLimitMgr.incrementResourceCount(vm.getAccountId(), ResourceType.user_vm);\n        //generate usage evenst to account for this change\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_CREATE, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(),  vm.getTemplateId(), vm.getHypervisorType().toString()));\n\n\n\n        // OS 3: update the network\n        if (zone.getNetworkType() == NetworkType.Advanced) { \n            //cleanup the network for the oldOwner\n            _networkMgr.cleanupNics(vmOldProfile);\n            _networkMgr.expungeNics(vmOldProfile);\n\n            // add the new nics\n            List<NetworkVO> networkList = new ArrayList<NetworkVO>();\n            NetworkVO defaultNetwork = null; \n\n            List<NetworkVO> oldNetworks = new ArrayList<NetworkVO>();\n            List<NetworkVO> zoneNetworks = _networkDao.listByZone(zone.getId());\n\n            for (NetworkVO network : zoneNetworks) { // get the default networks for the account\n                NetworkOfferingVO no = _networkOfferingDao.findById(network.getNetworkOfferingId());\n                if (!no.isSystemOnly()) {\n                    if (network.getGuestType() == Network.GuestType.Shared || !_networkDao.listBy(oldAccount.getId(), network.getId()).isEmpty()) {\n                        if (network.isDefault()) {\n                            oldNetworks.add(network);\n                        }\n                    }\n                }\n            }\n            for (NetworkVO oldNet: oldNetworks){\n                long networkOffering =  oldNet.getNetworkOfferingId();\n                PhysicalNetwork physicalNetwork = _networkMgr.translateZoneIdToPhysicalNetwork(zone.getId());\n                List<NetworkVO> virtualNetworks = _networkMgr.listNetworksForAccount(newAccount.getId(), zone.getId(), Network.GuestType.Isolated, true);\n                if (virtualNetworks.isEmpty()) {\n                    Network newNetwork = _networkMgr.createGuestNetwork(networkOffering, newAccount.getAccountName() + \"-network\", newAccount.getAccountName() + \"-network\", null, null,\n                            null, null, null, newAccount, false, null, physicalNetwork, zone.getId(), ACLType.Account, null);\n                    defaultNetwork = _networkDao.findById(newNetwork.getId());\n                } else if (virtualNetworks.size() > 1) {\n                    throw new InvalidParameterValueException(\"More than 1 default Virtaul networks are found for account \" + newAccount + \"; please specify networkIds\");\n                } else {\n                    defaultNetwork = virtualNetworks.get(0);\n                }\n\n                networkList.add(defaultNetwork);\n                List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>();\n                short defaultNetworkNumber = 0;\n                for (NetworkVO network : networkList) {\n\n                    if (network.isDefault()) {\n                        defaultNetworkNumber++;\n                    }\n\n                    networks.add(new Pair<NetworkVO, NicProfile>(network, null));\n                }\n\n                VMInstanceVO vmi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n                VirtualMachineProfileImpl<VMInstanceVO> vmProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmi);\n                _networkMgr.allocate(vmProfile, networks);\n            }\n        }\n\n        txn.commit();\n\n        return vm;\n    }","id":95930,"modified_method":"@DB\n    @Override\n    @ActionEvent(eventType = EventTypes.EVENT_VM_MOVE, eventDescription = \"move VM to another user\", async = false)\n    public UserVm moveVMToUser(AssignVMCmd cmd) throws ResourceAllocationException, ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {\n        // VERIFICATIONS and VALIDATIONS\n\n        //VV 1: verify the two users\n        Account adminAccount = UserContext.current().getCaller();\n        if (adminAccount.getType() != Account.ACCOUNT_TYPE_ADMIN  && adminAccount.getType() != Account.ACCOUNT_TYPE_DOMAIN_ADMIN){ // only root admin can assign VMs\n        \tthrow new InvalidParameterValueException(\"Only domain admins are allowed to assign VMs and not \" + adminAccount.getType());\n        }\n\n        //get and check the valid VM\n        UserVmVO vm = _vmDao.findById(cmd.getVmId());\n        if (vm == null){\n            throw new InvalidParameterValueException(\"There is no vm by that id \" + cmd.getVmId());\n        } else if (vm.getState() == State.Running) {  // VV 3: check if vm is running\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is Running, unable to move the vm \" + vm);\n            }\n            throw new InvalidParameterValueException(\"VM is Running, unable to move the vm \" + vm);\n        }\n\n        Account oldAccount = _accountService.getActiveAccountById(vm.getAccountId());\n        if (oldAccount == null) {\n            throw new InvalidParameterValueException(\"Invalid account for VM \" + vm.getAccountId() + \" in domain \" + oldAccount.getDomainId());\n        }\n        //don't allow to move the vm from the project\n        if (oldAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Vm id=\" + cmd.getVmId() + \" belongs to the project and can't be moved\");\n        }\n        Account newAccount = _accountService.getActiveAccountByName(cmd.getAccountName(), cmd.getDomainId());\n        if (newAccount == null || newAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Invalid accountid=\" + newAccount.getAccountId() + \" in domain \" + newAccount.getDomainId());\n        }\n\n        //VV 2: check if account/domain is with in resource limits to create a new vm\n        _resourceLimitMgr.checkResourceLimit(newAccount, ResourceType.user_vm);\n\n        // VV 4: Check if new owner can use the vm template\n        VirtualMachineTemplate template = _templateDao.findById(vm.getTemplateId());\n        if (!template.isPublicTemplate()) {\n            Account templateOwner = _accountMgr.getAccount(template.getAccountId());\n            _accountMgr.checkAccess(newAccount, null, templateOwner);\n        }\n\n        // VV 5: check that admin can create vm in the domain\n        DomainVO domain = _domainDao.findById(adminAccount.getDomainId());\n        _accountMgr.checkAccess(newAccount, domain);\n\n        DataCenterVO zone = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n\n        //check is zone networking is advanced\n        if (zone.getNetworkType() != NetworkType.Advanced) { \n            throw new InvalidParameterValueException(\"Assing virtual machine to another account is only available for advanced networking \" + vm);\n        }\n\n        VMInstanceVO vmoi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n        VirtualMachineProfileImpl<VMInstanceVO> vmOldProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmoi);\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        //generate destory vm event for usage\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_DESTROY, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(), vm.getTemplateId(), vm.getHypervisorType().toString()));\n        // update resource counts\n        _resourceLimitMgr.decrementResourceCount(oldAccount.getAccountId(), ResourceType.user_vm);\n\n        // OWNERSHIP STEP 1: update the vm owner\n        vm.setAccountId(newAccount.getAccountId());\n        _vmDao.persist(vm);\n        // OS 2: update volume\n        List<VolumeVO> volumes = _volsDao.findByInstance(cmd.getVmId());\n        for (VolumeVO volume : volumes) {\n            _resourceLimitMgr.decrementResourceCount(oldAccount.getAccountId(), ResourceType.volume, new Long(volumes.size()));\n            volume.setAccountId(newAccount.getAccountId());\n            _volsDao.persist(volume);\n            _resourceLimitMgr.incrementResourceCount(newAccount.getAccountId(), ResourceType.volume, new Long(volumes.size()));\n        }\n\n        _resourceLimitMgr.incrementResourceCount(newAccount.getAccountId(), ResourceType.user_vm);\n        //generate usage evenst to account for this change\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_CREATE, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(),  vm.getTemplateId(), vm.getHypervisorType().toString()));\n\n\n\n        // OS 3: update the network\n        if (zone.getNetworkType() == NetworkType.Advanced) { \n            //cleanup the network for the oldOwner\n            _networkMgr.cleanupNics(vmOldProfile);\n            _networkMgr.expungeNics(vmOldProfile);\n\n            // add the new nics\n            List<NetworkVO> networkList = new ArrayList<NetworkVO>();\n            NetworkVO defaultNetwork = null; \n\n            List<NetworkVO> oldNetworks = new ArrayList<NetworkVO>();\n            List<NetworkVO> zoneNetworks = _networkDao.listByZone(zone.getId());\n\n            for (NetworkVO network : zoneNetworks) { // get the default networks for the account\n                NetworkOfferingVO no = _networkOfferingDao.findById(network.getNetworkOfferingId());\n                if (!no.isSystemOnly()) {\n                    if (network.getGuestType() == Network.GuestType.Shared || !_networkDao.listBy(oldAccount.getId(), network.getId()).isEmpty()) {\n                        if (network.isDefault()) {\n                            oldNetworks.add(network);\n                        }\n                    }\n                }\n            }\n            for (NetworkVO oldNet: oldNetworks){\n                long networkOffering =  oldNet.getNetworkOfferingId();\n                PhysicalNetwork physicalNetwork = _networkMgr.translateZoneIdToPhysicalNetwork(zone.getId());\n                List<NetworkVO> virtualNetworks = _networkMgr.listNetworksForAccount(newAccount.getId(), zone.getId(), Network.GuestType.Isolated, true);\n                if (virtualNetworks.isEmpty()) {\n                    Network newNetwork = _networkMgr.createGuestNetwork(networkOffering, newAccount.getAccountName() + \"-network\", newAccount.getAccountName() + \"-network\", null, null,\n                            null, null, null, newAccount, false, null, physicalNetwork, zone.getId(), ACLType.Account, null);\n                    defaultNetwork = _networkDao.findById(newNetwork.getId());\n                } else if (virtualNetworks.size() > 1) {\n                    throw new InvalidParameterValueException(\"More than 1 default Virtaul networks are found for account \" + newAccount + \"; please specify networkIds\");\n                } else {\n                    defaultNetwork = virtualNetworks.get(0);\n                }\n\n                networkList.add(defaultNetwork);\n                List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>();\n                short defaultNetworkNumber = 0;\n                for (NetworkVO network : networkList) {\n\n                    if (network.isDefault()) {\n                        defaultNetworkNumber++;\n                    }\n\n                    networks.add(new Pair<NetworkVO, NicProfile>(network, null));\n                }\n\n                VMInstanceVO vmi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n                VirtualMachineProfileImpl<VMInstanceVO> vmProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmi);\n                _networkMgr.allocate(vmProfile, networks);\n            }\n        }\n\n        txn.commit();\n\n        return vm;\n    }","commit_id":"88f9b1ab7cbba0c4a28b5bc7d70671f577b60962","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * Check the token coverage\n     */\n    private void checkTokenCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        List<WSSecurityEngineResult> signedResults, \n        boolean utWithCallbacks\n    ) {\n        List<WSSecurityEngineResult> utResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT, utResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT_NOPASSWORD, utResults);\n        \n        List<WSSecurityEngineResult> samlResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_SIGNED, samlResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_UNSIGNED, samlResults);\n        \n        X509TokenPolicyValidator x509Validator = new X509TokenPolicyValidator(msg, results);\n        x509Validator.validatePolicy(aim);\n        \n        if (utWithCallbacks) {\n            UsernameTokenPolicyValidator utValidator = \n                new UsernameTokenPolicyValidator(msg, results);\n            utValidator.validatePolicy(aim);\n        } else {\n            Collection<AssertionInfo> ais = aim.get(SP12Constants.USERNAME_TOKEN);\n            if (ais != null) {\n                for (AssertionInfo ai : ais) {\n                    ai.setAsserted(true);\n                }\n            }\n        }\n        \n        SamlTokenPolicyValidator samlValidator = \n            new SamlTokenPolicyValidator(soapBody, signedResults, msg, results);\n        samlValidator.validatePolicy(aim);\n        \n        SecurityContextTokenPolicyValidator sctValidator = \n            new SecurityContextTokenPolicyValidator(msg, results);\n        sctValidator.validatePolicy(aim);\n        \n        WSS11PolicyValidator wss11Validator = new WSS11PolicyValidator(msg, results);\n        wss11Validator.validatePolicy(aim);\n    }","id":95931,"modified_method":"/**\n     * Check the token coverage\n     */\n    private boolean checkTokenCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        List<WSSecurityEngineResult> signedResults, \n        boolean utWithCallbacks\n    ) {\n        List<WSSecurityEngineResult> utResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT, utResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT_NOPASSWORD, utResults);\n        \n        List<WSSecurityEngineResult> samlResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_SIGNED, samlResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_UNSIGNED, samlResults);\n        \n        boolean check = true;\n        X509TokenPolicyValidator x509Validator = new X509TokenPolicyValidator(msg, results);\n        check &= x509Validator.validatePolicy(aim);\n        \n        if (utWithCallbacks) {\n            UsernameTokenPolicyValidator utValidator = \n                new UsernameTokenPolicyValidator(msg, results);\n            check &= utValidator.validatePolicy(aim);\n        } else {\n            Collection<AssertionInfo> ais = aim.get(SP12Constants.USERNAME_TOKEN);\n            if (ais != null) {\n                for (AssertionInfo ai : ais) {\n                    ai.setAsserted(true);\n                }\n            }\n        }\n        \n        SamlTokenPolicyValidator samlValidator = \n            new SamlTokenPolicyValidator(soapBody, signedResults, msg, results);\n        check &= samlValidator.validatePolicy(aim);\n        \n        SecurityContextTokenPolicyValidator sctValidator = \n            new SecurityContextTokenPolicyValidator(msg, results);\n        check &= sctValidator.validatePolicy(aim);\n        \n        WSS11PolicyValidator wss11Validator = new WSS11PolicyValidator(msg, results);\n        check &= wss11Validator.validatePolicy(aim);\n        \n        return check;\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"private void assertTokens(AssertionInfoMap aim, \n                              QName name, \n                              Collection<WSDataRef> signed,\n                              SoapMessage msg,\n                              Element soapHeader,\n                              Element soapBody,\n                              CoverageType type) throws SOAPException {\n        Collection<AssertionInfo> ais = aim.get(name);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                ai.setAsserted(true);\n                SignedEncryptedParts p = (SignedEncryptedParts)ai.getAssertion();\n                \n                if (p.isBody()) {\n                    try {\n                        if (CoverageType.SIGNED.equals(type)) {\n                            CryptoCoverageUtil.checkBodyCoverage(\n                                soapBody, signed, type, CoverageScope.ELEMENT\n                            );\n                        } else {\n                            CryptoCoverageUtil.checkBodyCoverage(\n                                soapBody, signed, type, CoverageScope.CONTENT\n                            );\n                        }\n                    } catch (WSSecurityException e) {\n                        ai.setNotAsserted(msg.getVersion().getBody() + \" not \" + type);\n                    }\n                }\n                \n                for (Header h : p.getHeaders()) {\n                    try {\n                        CryptoCoverageUtil.checkHeaderCoverage(soapHeader, signed, h\n                                .getNamespace(), h.getName(), type,\n                                CoverageScope.ELEMENT);\n                    } catch (WSSecurityException e) {\n                        ai.setNotAsserted(h.getQName() + \" not + \" + type);\n                    }\n                }\n            }\n        }\n    }","id":95932,"modified_method":"private boolean assertTokens(AssertionInfoMap aim, \n                              QName name, \n                              Collection<WSDataRef> signed,\n                              SoapMessage msg,\n                              Element soapHeader,\n                              Element soapBody,\n                              CoverageType type) throws SOAPException {\n        Collection<AssertionInfo> ais = aim.get(name);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                ai.setAsserted(true);\n                SignedEncryptedParts p = (SignedEncryptedParts)ai.getAssertion();\n                \n                if (p.isBody()) {\n                    try {\n                        if (CoverageType.SIGNED.equals(type)) {\n                            CryptoCoverageUtil.checkBodyCoverage(\n                                soapBody, signed, type, CoverageScope.ELEMENT\n                            );\n                        } else {\n                            CryptoCoverageUtil.checkBodyCoverage(\n                                soapBody, signed, type, CoverageScope.CONTENT\n                            );\n                        }\n                    } catch (WSSecurityException e) {\n                        ai.setNotAsserted(msg.getVersion().getBody() + \" not \" + type);\n                        return false;\n                    }\n                }\n                \n                for (Header h : p.getHeaders()) {\n                    try {\n                        CryptoCoverageUtil.checkHeaderCoverage(soapHeader, signed, h\n                                .getNamespace(), h.getName(), type,\n                                CoverageScope.ELEMENT);\n                    } catch (WSSecurityException e) {\n                        ai.setNotAsserted(h.getQName() + \" not + \" + type);\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Check SignedParts, EncryptedParts, SignedElements, EncryptedElements, RequiredParts, etc.\n     */\n    private void checkSignedEncryptedCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        Element soapHeader,\n        Element soapBody,\n        Collection<WSDataRef> signed, \n        Collection<WSDataRef> encrypted\n    ) throws SOAPException {\n        CryptoCoverageUtil.reconcileEncryptedSignedRefs(signed, encrypted);\n        \n        //\n        // SIGNED_PARTS and ENCRYPTED_PARTS only apply to non-Transport bindings\n        //\n        if (!isTransportBinding(aim)) {\n            assertTokens(\n                aim, SP12Constants.SIGNED_PARTS, signed, msg, soapHeader, soapBody, CoverageType.SIGNED\n            );\n            assertTokens(\n                aim, SP12Constants.ENCRYPTED_PARTS, encrypted, msg, soapHeader, soapBody, \n                CoverageType.ENCRYPTED\n            );\n        }\n        Element soapEnvelope = soapHeader.getOwnerDocument().getDocumentElement();\n        assertXPathTokens(aim, SP12Constants.SIGNED_ELEMENTS, signed, msg, soapEnvelope,\n                CoverageType.SIGNED, CoverageScope.ELEMENT);\n        assertXPathTokens(aim, SP12Constants.ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.ELEMENT);\n        assertXPathTokens(aim, SP12Constants.CONTENT_ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.CONTENT);\n        \n        assertHeadersExists(aim, msg, soapHeader);\n    }","id":95933,"modified_method":"/**\n     * Check SignedParts, EncryptedParts, SignedElements, EncryptedElements, RequiredParts, etc.\n     */\n    private boolean checkSignedEncryptedCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        Element soapHeader,\n        Element soapBody,\n        Collection<WSDataRef> signed, \n        Collection<WSDataRef> encrypted\n    ) throws SOAPException {\n        CryptoCoverageUtil.reconcileEncryptedSignedRefs(signed, encrypted);\n        //\n        // SIGNED_PARTS and ENCRYPTED_PARTS only apply to non-Transport bindings\n        //\n        boolean check = true;\n        if (!isTransportBinding(aim)) {\n            check &= assertTokens(\n                aim, SP12Constants.SIGNED_PARTS, signed, msg, soapHeader, soapBody, CoverageType.SIGNED\n            );\n            check &= assertTokens(\n                aim, SP12Constants.ENCRYPTED_PARTS, encrypted, msg, soapHeader, soapBody, \n                CoverageType.ENCRYPTED\n            );\n        }\n        Element soapEnvelope = soapHeader.getOwnerDocument().getDocumentElement();\n        check &= assertXPathTokens(aim, SP12Constants.SIGNED_ELEMENTS, signed, msg, soapEnvelope,\n                CoverageType.SIGNED, CoverageScope.ELEMENT);\n        check &= assertXPathTokens(aim, SP12Constants.ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.ELEMENT);\n        check &= assertXPathTokens(aim, SP12Constants.CONTENT_ENCRYPTED_ELEMENTS, encrypted, msg, soapEnvelope,\n                CoverageType.ENCRYPTED, CoverageScope.CONTENT);\n        \n        check &= assertHeadersExists(aim, msg, soapHeader);\n        return check;\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Check the binding coverage\n     */\n    private void checkBindingCoverage(\n        AssertionInfoMap aim, \n        SoapMessage msg,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        TransportBindingPolicyValidator transportValidator = \n            new TransportBindingPolicyValidator(msg, results, signedResults);\n        transportValidator.validatePolicy(aim);\n            \n        SymmetricBindingPolicyValidator symmetricValidator = \n            new SymmetricBindingPolicyValidator(msg, results, signedResults);\n        symmetricValidator.validatePolicy(aim);\n\n        AsymmetricBindingPolicyValidator asymmetricValidator = \n            new AsymmetricBindingPolicyValidator(msg, results, signedResults);\n        asymmetricValidator.validatePolicy(aim);\n    }","id":95934,"modified_method":"/**\n     * Check the binding coverage\n     */\n    private boolean checkBindingCoverage(\n        AssertionInfoMap aim, \n        SoapMessage msg,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        boolean check = true;\n        \n        TransportBindingPolicyValidator transportValidator = \n            new TransportBindingPolicyValidator(msg, results, signedResults);\n        check &= transportValidator.validatePolicy(aim);\n            \n        SymmetricBindingPolicyValidator symmetricValidator = \n            new SymmetricBindingPolicyValidator(msg, results, signedResults);\n        check &= symmetricValidator.validatePolicy(aim);\n\n        AsymmetricBindingPolicyValidator asymmetricValidator = \n            new AsymmetricBindingPolicyValidator(msg, results, signedResults);\n        check &= asymmetricValidator.validatePolicy(aim);\n        \n        return check;\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"private void assertXPathTokens(AssertionInfoMap aim, \n                                   QName name, \n                                   Collection<WSDataRef> refs,\n                                   SoapMessage msg,\n                                   Element soapEnvelope,\n                                   CoverageType type,\n                                   CoverageScope scope) throws SOAPException {\n        Collection<AssertionInfo> ais = aim.get(name);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                ai.setAsserted(true);\n                Map<String, String> namespaces = null;\n                List<String> xpaths = null;\n                if (CoverageScope.CONTENT.equals(scope)) {\n                    ContentEncryptedElements p = (ContentEncryptedElements)ai.getAssertion();\n                    namespaces = p.getDeclaredNamespaces();\n                    xpaths = p.getXPathExpressions();\n                } else {\n                    SignedEncryptedElements p = (SignedEncryptedElements)ai.getAssertion();\n                    namespaces = p.getDeclaredNamespaces();\n                    xpaths = p.getXPathExpressions();\n                }\n                \n                if (xpaths != null) {\n                    for (String xPath : xpaths) {\n                        try {\n                            CryptoCoverageUtil.checkCoverage(soapEnvelope, refs,\n                                    namespaces, xPath, type, scope);\n                        } catch (WSSecurityException e) {\n                            ai.setNotAsserted(\"No \" + type \n                                    + \" element found matching XPath \" + xPath);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":95935,"modified_method":"private boolean assertXPathTokens(AssertionInfoMap aim, \n                                   QName name, \n                                   Collection<WSDataRef> refs,\n                                   SoapMessage msg,\n                                   Element soapEnvelope,\n                                   CoverageType type,\n                                   CoverageScope scope) throws SOAPException {\n        Collection<AssertionInfo> ais = aim.get(name);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                ai.setAsserted(true);\n                Map<String, String> namespaces = null;\n                List<String> xpaths = null;\n                if (CoverageScope.CONTENT.equals(scope)) {\n                    ContentEncryptedElements p = (ContentEncryptedElements)ai.getAssertion();\n                    namespaces = p.getDeclaredNamespaces();\n                    xpaths = p.getXPathExpressions();\n                } else {\n                    SignedEncryptedElements p = (SignedEncryptedElements)ai.getAssertion();\n                    namespaces = p.getDeclaredNamespaces();\n                    xpaths = p.getXPathExpressions();\n                }\n                \n                if (xpaths != null) {\n                    for (String xPath : xpaths) {\n                        try {\n                            CryptoCoverageUtil.checkCoverage(soapEnvelope, refs,\n                                    namespaces, xPath, type, scope);\n                        } catch (WSSecurityException e) {\n                            ai.setNotAsserted(\"No \" + type \n                                    + \" element found matching XPath \" + xPath);\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        AssertionInfoMap aim = msg.get(AssertionInfoMap.class);\n        Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        \n        //\n        // Pre-fetch various results\n        //\n        List<WSSecurityEngineResult> signedResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.SIGN, signedResults);\n        for (WSSecurityEngineResult result : signedResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    signed.add(r);\n                }\n            }\n        }\n        \n        List<WSSecurityEngineResult> encryptResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ENCR, encryptResults);\n        for (WSSecurityEngineResult result : encryptResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    encrypted.add(r);\n                }\n            }\n        }\n        \n        /*\n        WSSecurityEngineResult tsResult = WSSecurityUtil.fetchActionResult(results, WSConstants.TS);\n        Element timestamp = null;\n        if (tsResult != null) {\n            Timestamp ts = (Timestamp)tsResult.get(WSSecurityEngineResult.TAG_TIMESTAMP);\n            timestamp = ts.getElement();\n        }\n        */\n        \n        //\n        // Check policies\n        //\n        checkSignedEncryptedCoverage(aim, msg, soapHeader, soapBody, signed, encrypted);\n        \n        checkTokenCoverage(aim, msg, soapBody, results, signedResults, utWithCallbacks);\n        \n        checkBindingCoverage(aim, msg, results, signedResults);\n\n        checkSupportingTokenCoverage(aim, msg, results, signedResults, utWithCallbacks);\n        \n        // The supporting tokens are already validated\n        assertPolicy(aim, SP12Constants.SUPPORTING_TOKENS);\n        \n        // relatively irrelevant stuff from a verification standpoint\n        assertPolicy(aim, SP12Constants.LAYOUT);\n        assertPolicy(aim, SP12Constants.WSS10);\n        assertPolicy(aim, SP12Constants.TRUST_13);\n        assertPolicy(aim, SP11Constants.TRUST_10);\n        \n        super.doResults(msg, actor, soapHeader, soapBody, results, utWithCallbacks);\n    }","id":95936,"modified_method":"@Override\n    protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        AssertionInfoMap aim = msg.get(AssertionInfoMap.class);\n        Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        \n        //\n        // Pre-fetch various results\n        //\n        List<WSSecurityEngineResult> signedResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.SIGN, signedResults);\n        for (WSSecurityEngineResult result : signedResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    signed.add(r);\n                }\n            }\n        }\n        \n        List<WSSecurityEngineResult> encryptResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ENCR, encryptResults);\n        for (WSSecurityEngineResult result : encryptResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    encrypted.add(r);\n                }\n            }\n        }\n        \n        /*\n        WSSecurityEngineResult tsResult = WSSecurityUtil.fetchActionResult(results, WSConstants.TS);\n        Element timestamp = null;\n        if (tsResult != null) {\n            Timestamp ts = (Timestamp)tsResult.get(WSSecurityEngineResult.TAG_TIMESTAMP);\n            timestamp = ts.getElement();\n        }\n        */\n        \n        //\n        // Check policies\n        //\n        boolean check = checkSignedEncryptedCoverage(aim, msg, soapHeader, soapBody, signed, encrypted);\n        \n        if (check) {\n            check = checkTokenCoverage(aim, msg, soapBody, results, signedResults, utWithCallbacks);\n        }\n        \n        if (check) {\n            check = checkBindingCoverage(aim, msg, results, signedResults);\n        }\n\n        if (check) {\n            check = checkSupportingTokenCoverage(aim, msg, results, signedResults, utWithCallbacks);\n        }\n        \n        // The supporting tokens are already validated\n        assertPolicy(aim, SP12Constants.SUPPORTING_TOKENS);\n        \n        // relatively irrelevant stuff from a verification standpoint\n        assertPolicy(aim, SP12Constants.LAYOUT);\n        assertPolicy(aim, SP12Constants.WSS10);\n        assertPolicy(aim, SP12Constants.TRUST_13);\n        assertPolicy(aim, SP11Constants.TRUST_10);\n        \n        super.doResults(msg, actor, soapHeader, soapBody, results, utWithCallbacks);\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"private void assertHeadersExists(AssertionInfoMap aim, SoapMessage msg, Node header) \n        throws SOAPException {\n        \n        Collection<AssertionInfo> ais = aim.get(SP12Constants.REQUIRED_PARTS);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                RequiredParts rp = (RequiredParts)ai.getAssertion();\n                ai.setAsserted(true);\n                for (Header h : rp.getHeaders()) {\n                    if (header == null \n                        || DOMUtils.getFirstChildWithName((Element)header, h.getQName()) == null) {\n                        ai.setNotAsserted(\"No header element of name \" + h.getQName() + \" found.\");\n                    }\n                }\n            }\n        }\n        ais = aim.get(SP12Constants.REQUIRED_ELEMENTS);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                RequiredElements rp = (RequiredElements)ai.getAssertion();\n                ai.setAsserted(true);\n                Map<String, String> namespaces = rp.getDeclaredNamespaces();\n                XPathFactory factory = XPathFactory.newInstance();\n                for (String expression : rp.getXPathExpressions()) {\n                    XPath xpath = factory.newXPath();\n                    if (namespaces != null) {\n                        xpath.setNamespaceContext(new MapNamespaceContext(namespaces));\n                    }\n                    NodeList list;\n                    try {\n                        list = (NodeList)xpath.evaluate(expression, \n                                                                 header,\n                                                                 XPathConstants.NODESET);\n                        if (list.getLength() == 0) {\n                            ai.setNotAsserted(\"No header element matching XPath \" + expression + \" found.\");\n                        }\n                    } catch (XPathExpressionException e) {\n                        ai.setNotAsserted(\"Invalid XPath expression \" + expression + \" \" + e.getMessage());\n                    }\n                }\n            }\n        }\n        \n    }","id":95937,"modified_method":"private boolean assertHeadersExists(AssertionInfoMap aim, SoapMessage msg, Node header) \n        throws SOAPException {\n        \n        Collection<AssertionInfo> ais = aim.get(SP12Constants.REQUIRED_PARTS);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                RequiredParts rp = (RequiredParts)ai.getAssertion();\n                ai.setAsserted(true);\n                for (Header h : rp.getHeaders()) {\n                    if (header == null \n                        || DOMUtils.getFirstChildWithName((Element)header, h.getQName()) == null) {\n                        ai.setNotAsserted(\"No header element of name \" + h.getQName() + \" found.\");\n                        return false;\n                    }\n                }\n            }\n        }\n        ais = aim.get(SP12Constants.REQUIRED_ELEMENTS);\n        if (ais != null) {\n            for (AssertionInfo ai : ais) {\n                RequiredElements rp = (RequiredElements)ai.getAssertion();\n                ai.setAsserted(true);\n                Map<String, String> namespaces = rp.getDeclaredNamespaces();\n                XPathFactory factory = XPathFactory.newInstance();\n                for (String expression : rp.getXPathExpressions()) {\n                    XPath xpath = factory.newXPath();\n                    if (namespaces != null) {\n                        xpath.setNamespaceContext(new MapNamespaceContext(namespaces));\n                    }\n                    NodeList list;\n                    try {\n                        list = (NodeList)xpath.evaluate(expression, \n                                                                 header,\n                                                                 XPathConstants.NODESET);\n                        if (list.getLength() == 0) {\n                            ai.setNotAsserted(\"No header element matching XPath \" + expression + \" found.\");\n                            return false;\n                        }\n                    } catch (XPathExpressionException e) {\n                        ai.setNotAsserted(\"Invalid XPath expression \" + expression + \" \" + e.getMessage());\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Check the supporting token coverage\n     */\n    private void checkSupportingTokenCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        List<WSSecurityEngineResult> results, \n        List<WSSecurityEngineResult> signedResults, \n        boolean utWithCallbacks\n    ) {\n        SignedTokenPolicyValidator suppValidator = \n            new SignedTokenPolicyValidator(msg, results, signedResults);\n        suppValidator.setValidateUsernameToken(utWithCallbacks);\n        suppValidator.validatePolicy(aim);\n\n        EndorsingTokenPolicyValidator endorsingValidator = \n            new EndorsingTokenPolicyValidator(msg, results, signedResults);\n        endorsingValidator.validatePolicy(aim);\n\n        SignedEndorsingTokenPolicyValidator signedEdorsingValidator = \n            new SignedEndorsingTokenPolicyValidator(msg, results, signedResults);\n        signedEdorsingValidator.validatePolicy(aim);\n\n        SignedEncryptedTokenPolicyValidator signedEncryptedValidator = \n            new SignedEncryptedTokenPolicyValidator(msg, results, signedResults);\n        signedEncryptedValidator.setValidateUsernameToken(utWithCallbacks);\n        signedEncryptedValidator.validatePolicy(aim);\n\n        EncryptedTokenPolicyValidator encryptedValidator = \n            new EncryptedTokenPolicyValidator(msg, results, signedResults);\n        encryptedValidator.setValidateUsernameToken(utWithCallbacks);\n        encryptedValidator.validatePolicy(aim);\n\n        EndorsingEncryptedTokenPolicyValidator endorsingEncryptedValidator = \n            new EndorsingEncryptedTokenPolicyValidator(msg, results, signedResults);\n        endorsingEncryptedValidator.setValidateUsernameToken(utWithCallbacks);\n        endorsingEncryptedValidator.validatePolicy(aim);\n\n        SignedEndorsingEncryptedTokenPolicyValidator signedEndorsingEncryptedValidator = \n            new SignedEndorsingEncryptedTokenPolicyValidator(msg, results, signedResults);\n        signedEndorsingEncryptedValidator.validatePolicy(aim);\n    }","id":95938,"modified_method":"/**\n     * Check the supporting token coverage\n     */\n    private boolean checkSupportingTokenCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        List<WSSecurityEngineResult> results, \n        List<WSSecurityEngineResult> signedResults, \n        boolean utWithCallbacks\n    ) {\n        boolean check = true;\n        \n        SignedTokenPolicyValidator suppValidator = \n            new SignedTokenPolicyValidator(msg, results, signedResults);\n        suppValidator.setValidateUsernameToken(utWithCallbacks);\n        check &= suppValidator.validatePolicy(aim);\n\n        EndorsingTokenPolicyValidator endorsingValidator = \n            new EndorsingTokenPolicyValidator(msg, results, signedResults);\n        check &= endorsingValidator.validatePolicy(aim);\n\n        SignedEndorsingTokenPolicyValidator signedEdorsingValidator = \n            new SignedEndorsingTokenPolicyValidator(msg, results, signedResults);\n        check &= signedEdorsingValidator.validatePolicy(aim);\n\n        SignedEncryptedTokenPolicyValidator signedEncryptedValidator = \n            new SignedEncryptedTokenPolicyValidator(msg, results, signedResults);\n        signedEncryptedValidator.setValidateUsernameToken(utWithCallbacks);\n        check &= signedEncryptedValidator.validatePolicy(aim);\n\n        EncryptedTokenPolicyValidator encryptedValidator = \n            new EncryptedTokenPolicyValidator(msg, results, signedResults);\n        encryptedValidator.setValidateUsernameToken(utWithCallbacks);\n        check &= encryptedValidator.validatePolicy(aim);\n\n        EndorsingEncryptedTokenPolicyValidator endorsingEncryptedValidator = \n            new EndorsingEncryptedTokenPolicyValidator(msg, results, signedResults);\n        endorsingEncryptedValidator.setValidateUsernameToken(utWithCallbacks);\n        check &= endorsingEncryptedValidator.validatePolicy(aim);\n\n        SignedEndorsingEncryptedTokenPolicyValidator signedEndorsingEncryptedValidator = \n            new SignedEndorsingEncryptedTokenPolicyValidator(msg, results, signedResults);\n        check &= signedEndorsingEncryptedValidator.validatePolicy(aim);\n        \n        return check;\n    }","commit_id":"ec1fb49f073c9a3c0be2bfeb521d758bcf3c8c00","url":"https://github.com/apache/cxf"},{"original_method":"/**\n\t * Creates a new {@link JvmDeclaredType type} from the given class.\n\t * @noreference This method is not intended to be referenced by clients.\n\t */\n\tpublic JvmDeclaredType createType(final Class<?> clazz) {\n\t\ttry {\n\t\t\tcreateTypeTask.start();\n\t\t\tif (clazz.isAnonymousClass() || clazz.isSynthetic())\n\t\t\t\tthrow new IllegalStateException(\"Cannot create type for anonymous or synthetic classes\");\n\t\t\tif (clazz.isAnnotation())\n\t\t\t\treturn createAnnotationType(clazz);\n\t\t\tif (clazz.isEnum())\n\t\t\t\treturn createEnumerationType(clazz);\n\t\n\t\t\tfinal JvmGenericType result = TypesFactory.eINSTANCE.createJvmGenericType();\n\t\t\tresult.setInterface(clazz.isInterface());\n\t\t\tsetTypeModifiers(clazz, result);\n\t\t\tsetVisibility(clazz, result);\n\t\t\tresult.internalSetIdentifier(clazz.getName());\n\t\t\tresult.setSimpleName(clazz.getSimpleName());\n\t\t\tif (clazz.getDeclaringClass() == null && clazz.getPackage() != null)\n\t\t\t\tresult.setPackageName(clazz.getPackage().getName());\n\t\t\t\n\t\t\tcreateNestedTypes(clazz, result);\n\t\t\tcreateMethods(clazz, result);\n\t\t\tcreateConstructors(clazz, result);\n\t\t\tcreateFields(clazz, result);\n\t\t\t\n\t\t\tsetSuperTypes(clazz, result);\n\t\t\ttry {\n\t\t\t\tfor (TypeVariable<?> variable : clazz.getTypeParameters()) {\n\t\t\t\t\tresult.getTypeParameters().add(createTypeParameter(variable, result));\n\t\t\t\t}\n\t\t\t} catch(GenericSignatureFormatError error) {\n\t\t\t\tlog.warn(\"Invalid class file for: \" + result.getIdentifier(), error);\n\t\t\t}\n\t\t\tcreateAnnotationValues(clazz, result);\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tcreateTypeTask.stop();\n\t\t}\n\t}","id":95939,"modified_method":"/**\n\t * Creates a new {@link JvmDeclaredType type} from the given class.\n\t * @noreference This method is not intended to be referenced by clients.\n\t */\n\tpublic JvmDeclaredType createType(final Class<?> clazz) {\n\t\ttry {\n\t\t\tcreateTypeTask.start();\n\t\t\tif (clazz.isAnonymousClass() || clazz.isSynthetic())\n\t\t\t\tthrow new IllegalStateException(\"Cannot create type for anonymous or synthetic classes\");\n\t\t\tif (clazz.isAnnotation())\n\t\t\t\treturn createAnnotationType(clazz);\n\t\t\tif (clazz.isEnum())\n\t\t\t\treturn createEnumerationType(clazz);\n\t\n\t\t\tfinal JvmGenericType result = TypesFactory.eINSTANCE.createJvmGenericType();\n\t\t\tresult.setInterface(clazz.isInterface());\n\t\t\tsetTypeModifiers(clazz, result);\n\t\t\tsetVisibility(clazz, result);\n\t\t\tresult.internalSetIdentifier(clazz.getName());\n\t\t\tresult.setSimpleName(clazz.getSimpleName());\n\t\t\tif (clazz.getDeclaringClass() == null && clazz.getPackage() != null)\n\t\t\t\tresult.setPackageName(clazz.getPackage().getName());\n\t\t\t\n\t\t\tcreateNestedTypes(clazz, result);\n\t\t\tcreateMethods(clazz, result);\n\t\t\tcreateConstructors(clazz, result);\n\t\t\tcreateFields(clazz, result);\n\t\t\t\n\t\t\tsetSuperTypes(clazz, result);\n\t\t\ttry {\n\t\t\t\tfor (TypeVariable<?> variable : clazz.getTypeParameters()) {\n\t\t\t\t\tresult.getTypeParameters().add(createTypeParameter(variable, result));\n\t\t\t\t}\n\t\t\t} catch(GenericSignatureFormatError error) {\n\t\t\t\tlogSignatureFormatError(clazz);\n\t\t\t}\n\t\t\tcreateAnnotationValues(clazz, result);\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tcreateTypeTask.stop();\n\t\t}\n\t}","commit_id":"2361a922cf94a91f9aa86368d157df340b2e51cf","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setSuperTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\ttry {\n\t\t\tif (clazz.getGenericSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getGenericSuperclass()));\n\t\t\t}\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + clazz.getCanonicalName(), error);\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getSuperclass()));\n\t\t\t}\n\t\t}\n\t\tType[] interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = clazz.getGenericInterfaces();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + clazz.getCanonicalName(), error);\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t}\n\t\tfor (Type type : interfaces) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(type));\n\t\t}\n\t\tif (result.getSuperTypes().isEmpty() && !Object.class.equals(clazz)) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(Object.class));\n\t\t}\n\t}","id":95940,"modified_method":"protected void setSuperTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\ttry {\n\t\t\tif (clazz.getGenericSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getGenericSuperclass()));\n\t\t\t}\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getSuperclass()));\n\t\t\t}\n\t\t}\n\t\tType[] interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = clazz.getGenericInterfaces();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(clazz);\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t}\n\t\tfor (Type type : interfaces) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(type));\n\t\t}\n\t\tif (result.getSuperTypes().isEmpty() && !Object.class.equals(clazz)) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(Object.class));\n\t\t}\n\t}","commit_id":"2361a922cf94a91f9aa86368d157df340b2e51cf","url":"https://github.com/eclipse/xtext"},{"original_method":"protected <T> org.eclipse.xtext.common.types.JvmConstructor createConstructor(Constructor<T> constructor) {\n\t\tJvmConstructor result = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tClass<T> declaringClass = constructor.getDeclaringClass();\n\t\tint offset = 0;\n\t\tif (declaringClass.isEnum()) {\n\t\t\toffset = 2;\n\t\t} else if (declaringClass.isMemberClass() && !Modifier.isStatic(declaringClass.getModifiers())) {\n\t\t\toffset = 1;\n\t\t}\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = constructor.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + constructor.getDeclaringClass().getCanonicalName(), error);\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t}\n\t\tif (offset != 0) {\n\t\t\t/*\n\t\t\t * #getGenericParameterTypes may return a different number of parameters\n\t\t\t * for inner classes then #getParameterTypes does. This happens for\n\t\t\t * signatures that are parameterized, e.g.\n\t\t\t * \n\t\t\t * <pre>\n\t\t\t * \n\t\t\t * class WrappedCollection<V> .. {\n\t\t\t *   class WrappedIterator implements Iterator<V> {\n\t\t\t *     WrappedIterator(Iterator<V> iterator) { .. }\n\t\t\t *   }\n\t\t\t * }\n\t\t\t * \n\t\t\t * <\/pre>\n\t\t\t * \n\t\t\t * Therefore we adjust the offset here\n\t\t\t */\n\t\t\tif (constructor.getParameterTypes().length != genericParameterTypes.length) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tenhanceGenericDeclaration(result, constructor);\n\t\tenhanceExecutable(result, constructor, constructor.getDeclaringClass().getSimpleName(),\n\t\t\t\tgenericParameterTypes, constructor.getParameterAnnotations(), offset);\n\t\tresult.setVarArgs(constructor.isVarArgs());\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = constructor.getGenericExceptionTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + constructor.getDeclaringClass().getCanonicalName(), error);\n\t\t\texceptionTypes = constructor.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(constructor, result);\n\t\treturn result;\n\t}","id":95941,"modified_method":"protected <T> org.eclipse.xtext.common.types.JvmConstructor createConstructor(Constructor<T> constructor) {\n\t\tJvmConstructor result = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tClass<T> declaringClass = constructor.getDeclaringClass();\n\t\tint offset = 0;\n\t\tif (declaringClass.isEnum()) {\n\t\t\toffset = 2;\n\t\t} else if (declaringClass.isMemberClass() && !Modifier.isStatic(declaringClass.getModifiers())) {\n\t\t\toffset = 1;\n\t\t}\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = constructor.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(constructor.getDeclaringClass());\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t}\n\t\tif (offset != 0) {\n\t\t\t/*\n\t\t\t * #getGenericParameterTypes may return a different number of parameters\n\t\t\t * for inner classes then #getParameterTypes does. This happens for\n\t\t\t * signatures that are parameterized, e.g.\n\t\t\t * \n\t\t\t * <pre>\n\t\t\t * \n\t\t\t * class WrappedCollection<V> .. {\n\t\t\t *   class WrappedIterator implements Iterator<V> {\n\t\t\t *     WrappedIterator(Iterator<V> iterator) { .. }\n\t\t\t *   }\n\t\t\t * }\n\t\t\t * \n\t\t\t * <\/pre>\n\t\t\t * \n\t\t\t * Therefore we adjust the offset here\n\t\t\t */\n\t\t\tif (constructor.getParameterTypes().length != genericParameterTypes.length) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tenhanceGenericDeclaration(result, constructor);\n\t\tenhanceExecutable(result, constructor, constructor.getDeclaringClass().getSimpleName(),\n\t\t\t\tgenericParameterTypes, constructor.getParameterAnnotations(), offset);\n\t\tresult.setVarArgs(constructor.isVarArgs());\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = constructor.getGenericExceptionTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(constructor.getDeclaringClass());\n\t\t\texceptionTypes = constructor.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(constructor, result);\n\t\treturn result;\n\t}","commit_id":"2361a922cf94a91f9aa86368d157df340b2e51cf","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmField createField(Field field) {\n\t\tJvmField result;\n\t\tif (!field.isEnumConstant())\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmField();\n\t\telse\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmEnumerationLiteral();\n\t\tresult.internalSetIdentifier(field.getDeclaringClass().getName() + \".\" + field.getName());\n\t\tresult.setSimpleName(field.getName());\n\t\tresult.setFinal(Modifier.isFinal(field.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(field.getModifiers()));\n\t\tsetVisibility(result, field.getModifiers());\n\t\tType fieldType = null;\n\t\ttry {\n\t\t\tfieldType = field.getGenericType();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + field.getDeclaringClass().getCanonicalName(), error);\n\t\t\tfieldType = field.getType();\n\t\t}\n\t\tresult.setType(createTypeReference(fieldType));\n\t\tcreateAnnotationValues(field, result);\n\t\treturn result;\n\t}","id":95942,"modified_method":"protected JvmField createField(Field field) {\n\t\tJvmField result;\n\t\tif (!field.isEnumConstant())\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmField();\n\t\telse\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmEnumerationLiteral();\n\t\tresult.internalSetIdentifier(field.getDeclaringClass().getName() + \".\" + field.getName());\n\t\tresult.setSimpleName(field.getName());\n\t\tresult.setFinal(Modifier.isFinal(field.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(field.getModifiers()));\n\t\tsetVisibility(result, field.getModifiers());\n\t\tType fieldType = null;\n\t\ttry {\n\t\t\tfieldType = field.getGenericType();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(field.getDeclaringClass());\n\t\t\tfieldType = field.getType();\n\t\t}\n\t\tresult.setType(createTypeReference(fieldType));\n\t\tcreateAnnotationValues(field, result);\n\t\treturn result;\n\t}","commit_id":"2361a922cf94a91f9aa86368d157df340b2e51cf","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmOperation createOperation(Method method) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = method.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + method.getDeclaringClass().getCanonicalName(), error);\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t}\n\t\tenhanceGenericDeclaration(result, method);\n\t\tenhanceExecutable(result, method, method.getName(), genericParameterTypes, method.getParameterAnnotations(), 0);\n\t\tresult.setVarArgs(method.isVarArgs());\n\t\tresult.setAbstract(Modifier.isAbstract(method.getModifiers()));\n\t\tresult.setFinal(Modifier.isFinal(method.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(method.getModifiers()));\n\t\tType returnType = null;\n\t\ttry {\n\t\t\treturnType = method.getGenericReturnType();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + method.getDeclaringClass().getCanonicalName(), error);\n\t\t\treturnType = method.getReturnType();\n\t\t}\n\t\tresult.setReturnType(createTypeReference(returnType));\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = method.getGenericExceptionTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + method.getDeclaringClass().getCanonicalName(), error);\n\t\t\texceptionTypes = method.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(method, result);\n\t\treturn result;\n\t}","id":95943,"modified_method":"protected JvmOperation createOperation(Method method) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = method.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t}\n\t\tenhanceGenericDeclaration(result, method);\n\t\tenhanceExecutable(result, method, method.getName(), genericParameterTypes, method.getParameterAnnotations(), 0);\n\t\tresult.setVarArgs(method.isVarArgs());\n\t\tresult.setAbstract(Modifier.isAbstract(method.getModifiers()));\n\t\tresult.setFinal(Modifier.isFinal(method.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(method.getModifiers()));\n\t\tType returnType = null;\n\t\ttry {\n\t\t\treturnType = method.getGenericReturnType();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\treturnType = method.getReturnType();\n\t\t}\n\t\tresult.setReturnType(createTypeReference(returnType));\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = method.getGenericExceptionTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlogSignatureFormatError(method.getDeclaringClass());\n\t\t\texceptionTypes = method.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(method, result);\n\t\treturn result;\n\t}","commit_id":"2361a922cf94a91f9aa86368d157df340b2e51cf","url":"https://github.com/eclipse/xtext"},{"original_method":"public static Spacing getSpacing(GroovyBlock child1, GroovyBlock child2) {\n\n    ASTNode leftNode = child1.getNode();\n    ASTNode rightNode = child2.getNode();\n\n/********** Braces ************/\n    // For left parentheses in method declarations or calls\n    if (mLPAREN.equals(rightNode.getElementType()) &&\n            rightNode.getPsi().getParent().getNode() != null &&\n            METHOD_OR_CALL.contains(rightNode.getPsi().getParent().getNode().getElementType())) {\n      return NO_SPACING;\n    }\n    // For \"super\" and \"this\" calls\n    if (mLPAREN.equals(rightNode.getElementType()) && THIS_OR_SUPER.contains(leftNode.getElementType())) {\n      return NO_SPACING;\n    }\n    // For left square bracket in array declarations and selections by index\n    if ((mLBRACK.equals(rightNode.getElementType()) &&\n            rightNode.getPsi().getParent().getNode() != null &&\n            INDEX_OR_ARRAY.contains(rightNode.getPsi().getParent().getNode().getElementType())) ||\n            ARRAY_DECLARATOR.equals(rightNode.getElementType())) {\n      return NO_SPACING;\n    }\n    // For parentheses in arguments and typecasts\n    if (LEFT_BRACES.contains(leftNode.getElementType()) ||\n            RIGHT_BRACES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n/********** punctuation marks ************/\n    // For dots, commas etc.\n    if ((NO_SPACING_NO_NEWLINE_BEFORE.contains(rightNode.getElementType())) ||\n            (mCOLON.equals(rightNode.getElementType()) &&\n                    !(rightNode.getPsi().getParent() instanceof GrConditionalExpression))) {\n      return NO_SPACING;\n    }\n\n    if (DOTS.contains(leftNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n/********** exclusions ************/\n    // For << and >> ...\n    if ((mLT.equals(leftNode.getElementType()) && mLT.equals(rightNode.getElementType())) ||\n            (mGT.equals(leftNode.getElementType()) && mGT.equals(rightNode.getElementType()))) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // Unary and postfix expressions\n    if (PREFIXES.contains(leftNode.getElementType()) ||\n            POSTFIXES.contains(rightNode.getElementType()) ||\n            (PREFIXES_OPTIONAL.contains(leftNode.getElementType()) &&\n                    leftNode.getPsi().getParent() instanceof GrUnaryExpression)) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    if (RANGES.contains(leftNode.getElementType()) ||\n            RANGES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // For Gstrings and regexes\n    if (leftNode.getPsi().getParent() != null &&\n            leftNode.getPsi().getParent().equals(rightNode.getPsi().getParent()) &&\n            leftNode.getPsi().getParent() instanceof GrString\n            ) {\n      return null;\n    }\n\n    return COMMON_SPACING;\n  }","id":95944,"modified_method":"public static Spacing getSpacing(GroovyBlock child1, GroovyBlock child2) {\n\n    ASTNode leftNode = child1.getNode();\n    ASTNode rightNode = child2.getNode();\n\n/********** Braces ************/\n    // For left parentheses in method declarations or calls\n    if (mLPAREN.equals(rightNode.getElementType()) &&\n            rightNode.getPsi().getParent().getNode() != null &&\n            METHOD_OR_CALL.contains(rightNode.getPsi().getParent().getNode().getElementType())) {\n      return NO_SPACING;\n    }\n    // For \"super\" and \"this\" calls\n    if (mLPAREN.equals(rightNode.getElementType()) && THIS_OR_SUPER.contains(leftNode.getElementType())) {\n      return NO_SPACING;\n    }\n    // For left square bracket in array declarations and selections by index\n    if ((mLBRACK.equals(rightNode.getElementType()) &&\n            rightNode.getPsi().getParent().getNode() != null &&\n            INDEX_OR_ARRAY.contains(rightNode.getPsi().getParent().getNode().getElementType())) ||\n            ARRAY_DECLARATOR.equals(rightNode.getElementType())) {\n      return NO_SPACING;\n    }\n    // For parentheses in arguments and typecasts\n    if (LEFT_BRACES.contains(leftNode.getElementType()) ||\n            RIGHT_BRACES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n    // For type parameters\n    if ((mLT.equals(leftNode.getElementType()) || mGT.equals(rightNode.getElementType())) &&\n            leftNode.getPsi().getParent() != null &&\n            leftNode.getPsi().getParent() instanceof GrTypeParameters) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    if (rightNode.getPsi() != null && rightNode.getPsi() instanceof GrTypeParameters) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n/********** punctuation marks ************/\n    // For dots, commas etc.\n    if ((PUNCTUATION_SIGNS.contains(rightNode.getElementType())) ||\n            (mCOLON.equals(rightNode.getElementType()) &&\n                    !(rightNode.getPsi().getParent() instanceof GrConditionalExpression))) {\n      return NO_SPACING;\n    }\n\n    if (DOTS.contains(leftNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n/********** exclusions ************/\n    // For << and >> ...\n    if ((mLT.equals(leftNode.getElementType()) && mLT.equals(rightNode.getElementType())) ||\n            (mGT.equals(leftNode.getElementType()) && mGT.equals(rightNode.getElementType()))) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // Unary and postfix expressions\n    if (PREFIXES.contains(leftNode.getElementType()) ||\n            POSTFIXES.contains(rightNode.getElementType()) ||\n            (PREFIXES_OPTIONAL.contains(leftNode.getElementType()) &&\n                    leftNode.getPsi().getParent() instanceof GrUnaryExpression)) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    if (RANGES.contains(leftNode.getElementType()) ||\n            RANGES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // For Gstrings and regexes\n    if (leftNode.getPsi().getParent() != null &&\n            leftNode.getPsi().getParent().equals(rightNode.getPsi().getParent()) &&\n            leftNode.getPsi().getParent() instanceof GrString\n            ) {\n      return null;\n    }\n\n    return COMMON_SPACING;\n  }","commit_id":"2405dc572e1ff9ec6d68c1deafeae06ac873b11d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Spacing getSpacing(GroovyBlock child1, GroovyBlock child2, CodeStyleSettings settings) {\n\n    ASTNode leftNode = child1.getNode();\n    ASTNode rightNode = child2.getNode();\n\n/********** Braces ************/\n\n    // For multi-line strings\n    if (!child1.getNode().getTextRange().equals(child1.getTextRange()) ||\n        !child2.getNode().getTextRange().equals(child2.getTextRange())) {\n      return NO_SPACING;\n    }\n\n    //For type parameters\n    if (mLT == leftNode.getElementType() &&\n        rightNode.getPsi() instanceof GrTypeParameter ||\n        mGT == rightNode.getElementType() &&\n            leftNode.getPsi() instanceof GrTypeParameter ||\n        mIDENT == leftNode.getElementType() &&\n        rightNode.getPsi() instanceof GrTypeParameterList) {\n      return NO_SPACING;\n    }\n\n    // For left parentheses in method declarations or calls\n    if (mLPAREN.equals(rightNode.getElementType()) &&\n        rightNode.getPsi().getParent().getNode() != null &&\n        METHOD_DEFS.contains(rightNode.getPsi().getParent().getNode().getElementType())) {\n      return NO_SPACING;\n    }\n\n    if (ARGUMENTS.equals(rightNode.getElementType())) {\n      return NO_SPACING;\n    }\n    // For left square bracket in array declarations and selections by index\n    if ((mLBRACK.equals(rightNode.getElementType()) &&\n        rightNode.getPsi().getParent().getNode() != null &&\n        INDEX_OR_ARRAY.contains(rightNode.getPsi().getParent().getNode().getElementType())) ||\n        ARRAY_DECLARATOR.equals(rightNode.getElementType())) {\n      return NO_SPACING;\n    }\n\n    if (METHOD_DEFS.contains(leftNode.getElementType())) {\n      if (RIGHT_BRACES.contains(rightNode.getElementType())) {\n        return Spacing.createSpacing(0, 0, 1, false, 100);\n      }\n      return Spacing.createSpacing(0, 0, settings.BLANK_LINES_AROUND_METHOD + 1, settings.KEEP_LINE_BREAKS, 100);\n    }\n\n    if (METHOD_DEFS.contains(rightNode.getElementType())) {\n      if (LEFT_BRACES.contains(leftNode.getElementType())) {\n        return Spacing.createSpacing(0, 0, 1, false, 100);\n      }\n      return Spacing.createSpacing(0, 0, settings.BLANK_LINES_AROUND_METHOD + 1, settings.KEEP_LINE_BREAKS, 100);\n    }\n\n    // For parentheses in arguments and typecasts\n    if (LEFT_BRACES.contains(leftNode.getElementType()) ||\n        RIGHT_BRACES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n    // For type parameters\n    if ((mLT.equals(leftNode.getElementType()) || mGT.equals(rightNode.getElementType())) &&\n        leftNode.getPsi().getParent() != null &&\n        leftNode.getPsi().getParent() instanceof GrTypeArgumentList) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    if (rightNode.getPsi() != null && rightNode.getPsi() instanceof GrTypeArgumentList) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n/********** punctuation marks ************/\n    // For dots, commas etc.\n    if ((PUNCTUATION_SIGNS.contains(rightNode.getElementType())) ||\n        (mCOLON.equals(rightNode.getElementType()) &&\n            !(rightNode.getPsi().getParent() instanceof GrConditionalExpression))) {\n      return NO_SPACING;\n    }\n\n    if (GroovyTokenTypes.DOTS.contains(leftNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n\n/********** imports ************/\n    if (IMPORT_STATEMENT.equals(leftNode.getElementType()) &&\n        IMPORT_STATEMENT.equals(rightNode.getElementType())) {\n      return IMPORT_BETWEEN_SPACING;\n    }\n    if ((IMPORT_STATEMENT.equals(leftNode.getElementType()) &&\n        (!IMPORT_STATEMENT.equals(rightNode.getElementType()) &&\n            !mSEMI.equals(rightNode.getElementType()))) ||\n        ((!IMPORT_STATEMENT.equals(leftNode.getElementType()) &&\n            !mSEMI.equals(leftNode.getElementType())) &&\n            IMPORT_STATEMENT.equals(rightNode.getElementType()))) {\n      return IMPORT_OTHER_SPACING;\n    }\n\n    if (VARIABLE_DEFINITION.equals(leftNode.getElementType()) ||\n        VARIABLE_DEFINITION.equals(rightNode.getElementType())) {\n      return Spacing.createSpacing(0, 0, 1, false, 100);\n    }\n\n/********** exclusions ************/\n    // For << and >> ...\n    if ((mLT.equals(leftNode.getElementType()) && mLT.equals(rightNode.getElementType())) ||\n        (mGT.equals(leftNode.getElementType()) && mGT.equals(rightNode.getElementType()))) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // Unary and postfix expressions\n    if (PREFIXES.contains(leftNode.getElementType()) ||\n        POSTFIXES.contains(rightNode.getElementType()) ||\n        (PREFIXES_OPTIONAL.contains(leftNode.getElementType()) &&\n            leftNode.getPsi().getParent() instanceof GrUnaryExpression)) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    if (RANGES.contains(leftNode.getElementType()) ||\n        RANGES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // For Gstrings and regexes\n    if (leftNode.getPsi().getParent() != null &&\n        leftNode.getPsi().getParent().equals(rightNode.getPsi().getParent()) &&\n        leftNode.getPsi().getParent() instanceof GrString\n        ) {\n      return null;\n    }\n\n    return COMMON_SPACING;\n  }","id":95945,"modified_method":"public static Spacing getSpacing(GroovyBlock child1, GroovyBlock child2, CodeStyleSettings settings) {\n\n    ASTNode leftNode = child1.getNode();\n    ASTNode rightNode = child2.getNode();\n\n/********** Braces ************/\n\n    // For multi-line strings\n    if (!child1.getNode().getTextRange().equals(child1.getTextRange()) ||\n        !child2.getNode().getTextRange().equals(child2.getTextRange())) {\n      return NO_SPACING;\n    }\n\n    //For type parameters\n    if (mLT == leftNode.getElementType() &&\n        rightNode.getPsi() instanceof GrTypeParameter ||\n        mGT == rightNode.getElementType() &&\n            leftNode.getPsi() instanceof GrTypeParameter ||\n        mIDENT == leftNode.getElementType() &&\n        rightNode.getPsi() instanceof GrTypeParameterList) {\n      return NO_SPACING;\n    }\n\n    // For left parentheses in method declarations or calls\n    if (mLPAREN.equals(rightNode.getElementType()) &&\n        rightNode.getPsi().getParent().getNode() != null &&\n        METHOD_DEFS.contains(rightNode.getPsi().getParent().getNode().getElementType())) {\n      return NO_SPACING;\n    }\n\n    if (ARGUMENTS.equals(rightNode.getElementType())) {\n      return NO_SPACING;\n    }\n    // For left square bracket in array declarations and selections by index\n    if ((mLBRACK.equals(rightNode.getElementType()) &&\n        rightNode.getPsi().getParent().getNode() != null &&\n        INDEX_OR_ARRAY.contains(rightNode.getPsi().getParent().getNode().getElementType())) ||\n        ARRAY_DECLARATOR.equals(rightNode.getElementType())) {\n      return NO_SPACING;\n    }\n\n    if (CLASS_LEVEL_DEFS.contains(leftNode.getElementType())) {\n      if (mRCURLY.equals(rightNode.getElementType())) {\n        return Spacing.createSpacing(0, 0, 1, false, 100);\n      }\n      int nBlanks = METHOD_DEFS.contains(leftNode.getElementType()) ? settings.BLANK_LINES_AROUND_METHOD :\n          FIELD.equals(leftNode.getElementType()) ? settings.BLANK_LINES_AROUND_FIELD : 1;\n      return Spacing.createSpacing(0, 0, nBlanks + 1, settings.KEEP_LINE_BREAKS, 100);\n    }\n\n    if (CLASS_LEVEL_DEFS.contains(rightNode.getElementType())) {\n      if (mLCURLY.equals(leftNode.getElementType())) {\n        return Spacing.createSpacing(0, 0, 1, false, 100);\n      }\n      int nBlanks = METHOD_DEFS.contains(rightNode.getElementType()) ? settings.BLANK_LINES_AROUND_METHOD :\n          FIELD.equals(rightNode.getElementType()) ? settings.BLANK_LINES_AROUND_FIELD : 1;\n      return Spacing.createSpacing(0, 0, nBlanks + 1, settings.KEEP_LINE_BREAKS, 100);\n    }\n\n    // For parentheses in arguments and typecasts\n    if (LEFT_BRACES.contains(leftNode.getElementType()) ||\n        RIGHT_BRACES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n    // For type parameters\n    if ((mLT.equals(leftNode.getElementType()) || mGT.equals(rightNode.getElementType())) &&\n        leftNode.getPsi().getParent() != null &&\n        leftNode.getPsi().getParent() instanceof GrTypeArgumentList) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    if (rightNode.getPsi() != null && rightNode.getPsi() instanceof GrTypeArgumentList) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n/********** punctuation marks ************/\n    // For dots, commas etc.\n    if ((PUNCTUATION_SIGNS.contains(rightNode.getElementType())) ||\n        (mCOLON.equals(rightNode.getElementType()) &&\n            !(rightNode.getPsi().getParent() instanceof GrConditionalExpression))) {\n      return NO_SPACING;\n    }\n\n    if (GroovyTokenTypes.DOTS.contains(leftNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n\n/********** imports ************/\n    if (IMPORT_STATEMENT.equals(leftNode.getElementType()) &&\n        IMPORT_STATEMENT.equals(rightNode.getElementType())) {\n      return IMPORT_BETWEEN_SPACING;\n    }\n    if ((IMPORT_STATEMENT.equals(leftNode.getElementType()) &&\n        (!IMPORT_STATEMENT.equals(rightNode.getElementType()) &&\n            !mSEMI.equals(rightNode.getElementType()))) ||\n        ((!IMPORT_STATEMENT.equals(leftNode.getElementType()) &&\n            !mSEMI.equals(leftNode.getElementType())) &&\n            IMPORT_STATEMENT.equals(rightNode.getElementType()))) {\n      return IMPORT_OTHER_SPACING;\n    }\n\n    if (VARIABLE_DEFINITION.equals(leftNode.getElementType()) ||\n        VARIABLE_DEFINITION.equals(rightNode.getElementType())) {\n      return Spacing.createSpacing(0, 0, 1, false, 100);\n    }\n\n/********** exclusions ************/\n    // For << and >> ...\n    if ((mLT.equals(leftNode.getElementType()) && mLT.equals(rightNode.getElementType())) ||\n        (mGT.equals(leftNode.getElementType()) && mGT.equals(rightNode.getElementType()))) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // Unary and postfix expressions\n    if (PREFIXES.contains(leftNode.getElementType()) ||\n        POSTFIXES.contains(rightNode.getElementType()) ||\n        (PREFIXES_OPTIONAL.contains(leftNode.getElementType()) &&\n            leftNode.getPsi().getParent() instanceof GrUnaryExpression)) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    if (RANGES.contains(leftNode.getElementType()) ||\n        RANGES.contains(rightNode.getElementType())) {\n      return NO_SPACING_WITH_NEWLINE;\n    }\n\n    // For Gstrings and regexes\n    if (leftNode.getPsi().getParent() != null &&\n        leftNode.getPsi().getParent().equals(rightNode.getPsi().getParent()) &&\n        leftNode.getPsi().getParent() instanceof GrString\n        ) {\n      return null;\n    }\n\n    return COMMON_SPACING;\n  }","commit_id":"3ddc5b844774b5296f24a4b393c0ff05d13c3b61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Delegate an incoming invocation from the proxy, dispatching to EntityManagerFactoryInfo\n\t * or the native EntityManagerFactory accordingly.\n\t */\n\tObject invokeProxyMethod(Method method, Object[] args) throws Throwable {\n\t\tif (method.getDeclaringClass().isAssignableFrom(EntityManagerFactoryInfo.class)) {\n\t\t\treturn method.invoke(this, args);\n\t\t}\n\t\telse if (method.getName().equals(\"createEntityManager\") && args != null && args.length > 0 &&\n\t\t\t\targs[0] != null && args[0].getClass().isEnum() && \"SYNCHRONIZED\".equals(args[0].toString())) {\n\t\t\t// JPA 2.1's createEntityManager(SynchronizationType, Map)\n\t\t\t// Redirect to plain createEntityManager and add synchronization semantics through Spring proxy\n\t\t\tEntityManager rawEntityManager = (args.length > 1 ?\n\t\t\t\t\tthis.nativeEntityManagerFactory.createEntityManager((Map<?, ?>) args[1]) :\n\t\t\t\t\tthis.nativeEntityManagerFactory.createEntityManager());\n\t\t\treturn ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, true);\n\t\t}\n\n\t\t// Standard delegation to the native factory, just post-processing EntityManager return values\n\t\tObject retVal = method.invoke(this.nativeEntityManagerFactory, args);\n\t\tif (retVal instanceof EntityManager) {\n\t\t\t// Any other createEntityManager variant - expecting non-synchronized semantics\n\t\t\tEntityManager rawEntityManager = (EntityManager) retVal;\n\t\t\tretVal = ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, false);\n\t\t}\n\t\treturn retVal;\n\t}","id":95946,"modified_method":"/**\n\t * Delegate an incoming invocation from the proxy, dispatching to EntityManagerFactoryInfo\n\t * or the native EntityManagerFactory accordingly.\n\t */\n\tObject invokeProxyMethod(Method method, Object[] args) throws Throwable {\n\t\tif (method.getDeclaringClass().isAssignableFrom(EntityManagerFactoryInfo.class)) {\n\t\t\treturn method.invoke(this, args);\n\t\t}\n\t\telse if (method.getName().equals(\"createEntityManager\") && args != null && args.length > 0 &&\n\t\t\t\targs[0] != null && args[0].getClass().isEnum() && \"SYNCHRONIZED\".equals(args[0].toString())) {\n\t\t\t// JPA 2.1's createEntityManager(SynchronizationType, Map)\n\t\t\t// Redirect to plain createEntityManager and add synchronization semantics through Spring proxy\n\t\t\tEntityManager rawEntityManager = (args.length > 1 ?\n\t\t\t\t\tgetNativeEntityManagerFactory().createEntityManager((Map<?, ?>) args[1]) :\n\t\t\t\t\tgetNativeEntityManagerFactory().createEntityManager());\n\t\t\treturn ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, true);\n\t\t}\n\n\t\t// Standard delegation to the native factory, just post-processing EntityManager return values\n\t\tObject retVal = method.invoke(getNativeEntityManagerFactory(), args);\n\t\tif (retVal instanceof EntityManager) {\n\t\t\t// Any other createEntityManager variant - expecting non-synchronized semantics\n\t\t\tEntityManager rawEntityManager = (EntityManager) retVal;\n\t\t\tretVal = ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, false);\n\t\t}\n\t\treturn retVal;\n\t}","commit_id":"db1171d5c4839293aa390e301af73b100fc206e7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create a proxy of the given EntityManagerFactory. We do this to be able\n\t * to return transaction-aware proxies for application-managed\n\t * EntityManagers, and to introduce the NamedEntityManagerFactory interface\n\t * @param emf EntityManagerFactory as returned by the persistence provider\n\t * @return proxy entity manager\n\t */\n\tprotected EntityManagerFactory createEntityManagerFactoryProxy(EntityManagerFactory emf) {\n\t\tSet<Class<?>> ifcs = new LinkedHashSet<Class<?>>();\n\t\tif (this.entityManagerFactoryInterface != null) {\n\t\t\tifcs.add(this.entityManagerFactoryInterface);\n\t\t}\n\t\telse {\n\t\t\tifcs.addAll(ClassUtils.getAllInterfacesForClassAsSet(emf.getClass(), this.beanClassLoader));\n\t\t}\n\t\tifcs.add(EntityManagerFactoryInfo.class);\n\t\ttry {\n\t\t\treturn (EntityManagerFactory) Proxy.newProxyInstance(\n\t\t\t\t\tthis.beanClassLoader, ifcs.toArray(new Class<?>[ifcs.size()]),\n\t\t\t\t\tnew ManagedEntityManagerFactoryInvocationHandler(this));\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tif (this.entityManagerFactoryInterface != null) {\n\t\t\t\tthrow new IllegalStateException(\"EntityManagerFactory interface [\" + this.entityManagerFactoryInterface +\n\t\t\t\t\t\t\"] seems to conflict with Spring's EntityManagerFactoryInfo mixin - consider resetting the \"+\n\t\t\t\t\t\t\"'entityManagerFactoryInterface' property to plain [javax.persistence.EntityManagerFactory]\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Conflicting EntityManagerFactory interfaces - \" +\n\t\t\t\t\t\t\"consider specifying the 'jpaVendorAdapter' or 'entityManagerFactoryInterface' property \" +\n\t\t\t\t\t\t\"to select a specific EntityManagerFactory interface to proceed with\", ex);\n\t\t\t}\n\t\t}\n\t}","id":95947,"modified_method":"/**\n\t * Create a proxy of the given EntityManagerFactory. We do this to be able\n\t * to return transaction-aware proxies for application-managed\n\t * EntityManagers, and to introduce the NamedEntityManagerFactory interface\n\t * @param emf EntityManagerFactory as returned by the persistence provider\n\t * @return proxy entity manager\n\t */\n\tprotected EntityManagerFactory createEntityManagerFactoryProxy(EntityManagerFactory emf) {\n\t\tSet<Class<?>> ifcs = new LinkedHashSet<Class<?>>();\n\t\tif (this.entityManagerFactoryInterface != null) {\n\t\t\tifcs.add(this.entityManagerFactoryInterface);\n\t\t}\n\t\telse if (emf != null) {\n\t\t\tifcs.addAll(ClassUtils.getAllInterfacesForClassAsSet(emf.getClass(), this.beanClassLoader));\n\t\t}\n\t\telse {\n\t\t\tifcs.add(EntityManagerFactory.class);\n\t\t}\n\t\tifcs.add(EntityManagerFactoryInfo.class);\n\t\ttry {\n\t\t\treturn (EntityManagerFactory) Proxy.newProxyInstance(\n\t\t\t\t\tthis.beanClassLoader, ifcs.toArray(new Class<?>[ifcs.size()]),\n\t\t\t\t\tnew ManagedEntityManagerFactoryInvocationHandler(this));\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tif (this.entityManagerFactoryInterface != null) {\n\t\t\t\tthrow new IllegalStateException(\"EntityManagerFactory interface [\" + this.entityManagerFactoryInterface +\n\t\t\t\t\t\t\"] seems to conflict with Spring's EntityManagerFactoryInfo mixin - consider resetting the \"+\n\t\t\t\t\t\t\"'entityManagerFactoryInterface' property to plain [javax.persistence.EntityManagerFactory]\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Conflicting EntityManagerFactory interfaces - \" +\n\t\t\t\t\t\t\"consider specifying the 'jpaVendorAdapter' or 'entityManagerFactoryInterface' property \" +\n\t\t\t\t\t\t\"to select a specific EntityManagerFactory interface to proceed with\", ex);\n\t\t\t}\n\t\t}\n\t}","commit_id":"db1171d5c4839293aa390e301af73b100fc206e7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic EntityManagerFactory getNativeEntityManagerFactory() {\n\t\treturn this.nativeEntityManagerFactory;\n\t}","id":95948,"modified_method":"@Override\n\tpublic EntityManagerFactory getNativeEntityManagerFactory() {\n\t\tif (this.nativeEntityManagerFactory != null) {\n\t\t\treturn this.nativeEntityManagerFactory;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Requested: \" + System.currentTimeMillis());\n\t\t\ttry {\n\t\t\t\treturn this.nativeEntityManagerFactoryFuture.get();\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Interrupted during initialization of native EntityManagerFactory\", ex);\n\t\t\t}\n\t\t\tcatch (ExecutionException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to asynchronously initialize native EntityManagerFactory\", ex);\n\t\t\t}\n\t\t}\n\t}","commit_id":"db1171d5c4839293aa390e301af73b100fc206e7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic final void afterPropertiesSet() throws PersistenceException {\n\t\tif (this.jpaVendorAdapter != null) {\n\t\t\tif (this.persistenceProvider == null) {\n\t\t\t\tthis.persistenceProvider = this.jpaVendorAdapter.getPersistenceProvider();\n\t\t\t}\n\t\t\tMap<String, ?> vendorPropertyMap = this.jpaVendorAdapter.getJpaPropertyMap();\n\t\t\tif (vendorPropertyMap != null) {\n\t\t\t\tfor (Map.Entry<String, ?> entry : vendorPropertyMap.entrySet()) {\n\t\t\t\t\tif (!this.jpaPropertyMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tthis.jpaPropertyMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.entityManagerFactoryInterface == null) {\n\t\t\t\tthis.entityManagerFactoryInterface = this.jpaVendorAdapter.getEntityManagerFactoryInterface();\n\t\t\t\tif (!ClassUtils.isVisible(this.entityManagerFactoryInterface, this.beanClassLoader)) {\n\t\t\t\t\tthis.entityManagerFactoryInterface = EntityManagerFactory.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.entityManagerInterface == null) {\n\t\t\t\tthis.entityManagerInterface = this.jpaVendorAdapter.getEntityManagerInterface();\n\t\t\t\tif (!ClassUtils.isVisible(this.entityManagerInterface, this.beanClassLoader)) {\n\t\t\t\t\tthis.entityManagerInterface = EntityManager.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.jpaDialect == null) {\n\t\t\t\tthis.jpaDialect = this.jpaVendorAdapter.getJpaDialect();\n\t\t\t}\n\t\t}\n\n\t\tthis.nativeEntityManagerFactory = createNativeEntityManagerFactory();\n\t\tif (this.nativeEntityManagerFactory == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"JPA PersistenceProvider returned null EntityManagerFactory - check your JPA provider setup!\");\n\t\t}\n\t\tif (this.jpaVendorAdapter != null) {\n\t\t\tthis.jpaVendorAdapter.postProcessEntityManagerFactory(this.nativeEntityManagerFactory);\n\t\t}\n\n\t\t// Wrap the EntityManagerFactory in a factory implementing all its interfaces.\n\t\t// This allows interception of createEntityManager methods to return an\n\t\t// application-managed EntityManager proxy that automatically joins\n\t\t// existing transactions.\n\t\tthis.entityManagerFactory = createEntityManagerFactoryProxy(this.nativeEntityManagerFactory);\n\t}","id":95949,"modified_method":"@Override\n\tpublic final void afterPropertiesSet() throws PersistenceException {\n\t\tif (this.jpaVendorAdapter != null) {\n\t\t\tif (this.persistenceProvider == null) {\n\t\t\t\tthis.persistenceProvider = this.jpaVendorAdapter.getPersistenceProvider();\n\t\t\t}\n\t\t\tMap<String, ?> vendorPropertyMap = this.jpaVendorAdapter.getJpaPropertyMap();\n\t\t\tif (vendorPropertyMap != null) {\n\t\t\t\tfor (Map.Entry<String, ?> entry : vendorPropertyMap.entrySet()) {\n\t\t\t\t\tif (!this.jpaPropertyMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tthis.jpaPropertyMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.entityManagerFactoryInterface == null) {\n\t\t\t\tthis.entityManagerFactoryInterface = this.jpaVendorAdapter.getEntityManagerFactoryInterface();\n\t\t\t\tif (!ClassUtils.isVisible(this.entityManagerFactoryInterface, this.beanClassLoader)) {\n\t\t\t\t\tthis.entityManagerFactoryInterface = EntityManagerFactory.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.entityManagerInterface == null) {\n\t\t\t\tthis.entityManagerInterface = this.jpaVendorAdapter.getEntityManagerInterface();\n\t\t\t\tif (!ClassUtils.isVisible(this.entityManagerInterface, this.beanClassLoader)) {\n\t\t\t\t\tthis.entityManagerInterface = EntityManager.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.jpaDialect == null) {\n\t\t\t\tthis.jpaDialect = this.jpaVendorAdapter.getJpaDialect();\n\t\t\t}\n\t\t}\n\n\t\tif (this.bootstrapExecutor != null) {\n\t\t\tthis.nativeEntityManagerFactoryFuture = this.bootstrapExecutor.submit(new Callable<EntityManagerFactory>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EntityManagerFactory call() {\n\t\t\t\t\treturn buildNativeEntityManagerFactory();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.nativeEntityManagerFactory = buildNativeEntityManagerFactory();\n\t\t}\n\n\t\t// Wrap the EntityManagerFactory in a factory implementing all its interfaces.\n\t\t// This allows interception of createEntityManager methods to return an\n\t\t// application-managed EntityManager proxy that automatically joins\n\t\t// existing transactions.\n\t\tthis.entityManagerFactory = createEntityManagerFactoryProxy(this.nativeEntityManagerFactory);\n\t\tSystem.out.println(\"Returning: \" + System.currentTimeMillis());\n\t}","commit_id":"db1171d5c4839293aa390e301af73b100fc206e7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {\n\t\tPersistenceUnitManager managerToUse = this.persistenceUnitManager;\n\t\tif (this.persistenceUnitManager == null) {\n\t\t\tthis.internalPersistenceUnitManager.afterPropertiesSet();\n\t\t\tmanagerToUse = this.internalPersistenceUnitManager;\n\t\t}\n\n\t\tthis.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse);\n\t\tJpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter();\n\t\tif (jpaVendorAdapter != null && this.persistenceUnitInfo instanceof SmartPersistenceUnitInfo) {\n\t\t\t((SmartPersistenceUnitInfo) this.persistenceUnitInfo).setPersistenceProviderPackageName(\n\t\t\t\t\tjpaVendorAdapter.getPersistenceProviderRootPackage());\n\t\t}\n\n\t\tPersistenceProvider provider = getPersistenceProvider();\n\t\tif (provider == null) {\n\t\t\tString providerClassName = this.persistenceUnitInfo.getPersistenceProviderClassName();\n\t\t\tif (providerClassName == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"No PersistenceProvider specified in EntityManagerFactory configuration, \" +\n\t\t\t\t\t\t\"and chosen PersistenceUnitInfo does not specify a provider class name either\");\n\t\t\t}\n\t\t\tClass<?> providerClass = ClassUtils.resolveClassName(providerClassName, getBeanClassLoader());\n\t\t\tprovider = (PersistenceProvider) BeanUtils.instantiateClass(providerClass);\n\t\t}\n\t\tif (provider == null) {\n\t\t\tthrow new IllegalStateException(\"Unable to determine persistence provider. \" +\n\t\t\t\t\t\"Please check configuration of \" + getClass().getName() + \"; \" +\n\t\t\t\t\t\"ideally specify the appropriate JpaVendorAdapter class for this provider.\");\n\t\t}\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Building JPA container EntityManagerFactory for persistence unit '\" +\n\t\t\t\t\tthis.persistenceUnitInfo.getPersistenceUnitName() + \"'\");\n\t\t}\n\t\tthis.nativeEntityManagerFactory =\n\t\t\t\tprovider.createContainerEntityManagerFactory(this.persistenceUnitInfo, getJpaPropertyMap());\n\t\tpostProcessEntityManagerFactory(this.nativeEntityManagerFactory, this.persistenceUnitInfo);\n\n\t\treturn this.nativeEntityManagerFactory;\n\t}","id":95950,"modified_method":"@Override\n\tprotected EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {\n\t\tPersistenceUnitManager managerToUse = this.persistenceUnitManager;\n\t\tif (this.persistenceUnitManager == null) {\n\t\t\tthis.internalPersistenceUnitManager.afterPropertiesSet();\n\t\t\tmanagerToUse = this.internalPersistenceUnitManager;\n\t\t}\n\n\t\tthis.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse);\n\t\tJpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter();\n\t\tif (jpaVendorAdapter != null && this.persistenceUnitInfo instanceof SmartPersistenceUnitInfo) {\n\t\t\t((SmartPersistenceUnitInfo) this.persistenceUnitInfo).setPersistenceProviderPackageName(\n\t\t\t\t\tjpaVendorAdapter.getPersistenceProviderRootPackage());\n\t\t}\n\n\t\tPersistenceProvider provider = getPersistenceProvider();\n\t\tif (provider == null) {\n\t\t\tString providerClassName = this.persistenceUnitInfo.getPersistenceProviderClassName();\n\t\t\tif (providerClassName == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"No PersistenceProvider specified in EntityManagerFactory configuration, \" +\n\t\t\t\t\t\t\"and chosen PersistenceUnitInfo does not specify a provider class name either\");\n\t\t\t}\n\t\t\tClass<?> providerClass = ClassUtils.resolveClassName(providerClassName, getBeanClassLoader());\n\t\t\tprovider = (PersistenceProvider) BeanUtils.instantiateClass(providerClass);\n\t\t}\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Building JPA container EntityManagerFactory for persistence unit '\" +\n\t\t\t\t\tthis.persistenceUnitInfo.getPersistenceUnitName() + \"'\");\n\t\t}\n\t\tEntityManagerFactory emf =\n\t\t\t\tprovider.createContainerEntityManagerFactory(this.persistenceUnitInfo, getJpaPropertyMap());\n\t\tpostProcessEntityManagerFactory(emf, this.persistenceUnitInfo);\n\n\t\treturn emf;\n\t}","commit_id":"db1171d5c4839293aa390e301af73b100fc206e7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Subclasses can override this method to perform custom initialization\n\t * of the SessionFactory instance, creating it via the given Configuration\n\t * object that got prepared by this LocalSessionFactoryBean.\n\t * <p>The default implementation invokes LocalSessionFactoryBuilder's buildSessionFactory.\n\t * A custom implementation could prepare the instance in a specific way (e.g. applying\n\t * a custom ServiceRegistry) or use a custom SessionFactoryImpl subclass.\n\t * @param sfb LocalSessionFactoryBuilder prepared by this LocalSessionFactoryBean\n\t * @return the SessionFactory instance\n\t * @see LocalSessionFactoryBuilder#buildSessionFactory\n\t */\n\tprotected SessionFactory buildSessionFactory(LocalSessionFactoryBuilder sfb) {\n\t\treturn sfb.buildSessionFactory();\n\t}","id":95951,"modified_method":"/**\n\t * Subclasses can override this method to perform custom initialization\n\t * of the SessionFactory instance, creating it via the given Configuration\n\t * object that got prepared by this LocalSessionFactoryBean.\n\t * <p>The default implementation invokes LocalSessionFactoryBuilder's buildSessionFactory.\n\t * A custom implementation could prepare the instance in a specific way (e.g. applying\n\t * a custom ServiceRegistry) or use a custom SessionFactoryImpl subclass.\n\t * @param sfb LocalSessionFactoryBuilder prepared by this LocalSessionFactoryBean\n\t * @return the SessionFactory instance\n\t * @see LocalSessionFactoryBuilder#buildSessionFactory\n\t */\n\tprotected SessionFactory buildSessionFactory(LocalSessionFactoryBuilder sfb) {\n\t\treturn (this.bootstrapExecutor != null ? sfb.buildSessionFactory(this.bootstrapExecutor) :\n\t\t\t\tsfb.buildSessionFactory());\n\t}","commit_id":"db1171d5c4839293aa390e301af73b100fc206e7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Determine the DataSource of the given SessionFactory.\n\t * @param sessionFactory the SessionFactory to check\n\t * @return the DataSource, or {@code null} if none found\n\t * @see ConnectionProvider\n\t */\n\tpublic static DataSource getDataSource(SessionFactory sessionFactory) {\n\t\tif (sessionFactory instanceof SessionFactoryImplementor) {\n\t\t\ttry {\n\t\t\t\tConnectionProvider cp = ((SessionFactoryImplementor) sessionFactory).getServiceRegistry().getService(\n\t\t\t\t\t\tConnectionProvider.class);\n\t\t\t\tif (cp != null) {\n\t\t\t\t\treturn cp.unwrap(DataSource.class);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnknownServiceException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No ConnectionProvider found - cannot determine DataSource for SessionFactory: \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":95952,"modified_method":"/**\n\t * Determine the DataSource of the given SessionFactory.\n\t * @param sessionFactory the SessionFactory to check\n\t * @return the DataSource, or {@code null} if none found\n\t * @see ConnectionProvider\n\t */\n\tpublic static DataSource getDataSource(SessionFactory sessionFactory) {\n\t\tif (sessionFactory instanceof SessionFactoryImplementor) {\n\t\t\tSessionFactoryImplementor sfi = (SessionFactoryImplementor) sessionFactory;\n\t\t\tObject dataSourceValue = sfi.getProperties().get(Environment.DATASOURCE);\n\t\t\tif (dataSourceValue instanceof DataSource) {\n\t\t\t\treturn (DataSource) dataSourceValue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tConnectionProvider cp = sfi.getServiceRegistry().getService(ConnectionProvider.class);\n\t\t\t\tif (cp != null) {\n\t\t\t\t\treturn cp.unwrap(DataSource.class);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnknownServiceException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No ConnectionProvider found - cannot determine DataSource for SessionFactory: \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"db1171d5c4839293aa390e301af73b100fc206e7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void init(WebApp wapp)  {\r\n        HibernateUtil.initSessionFactory();\r\n    }","id":95953,"modified_method":"public void init(WebApp app)  {\r\n        HibernateUtil.initSessionFactory(app);\r\n    }","commit_id":"c46aca03b7054aefa3343639e8fa83bbca31ae5b","url":"https://github.com/zkoss/zk"},{"original_method":"/**\r\n\t * Get the singleton hibernate Session Factory.\r\n\t */\r\n\tpublic static SessionFactory getSessionFactory() {\r\n\t\treturn initSessionFactory();\r\n\t}","id":95954,"modified_method":"/**\r\n\t * Get the singleton hibernate Session Factory.\r\n\t */\r\n\tpublic static SessionFactory getSessionFactory() {\r\n\t\treturn initSessionFactory(null);\r\n\t}","commit_id":"c46aca03b7054aefa3343639e8fa83bbca31ae5b","url":"https://github.com/zkoss/zk"},{"original_method":"static SessionFactory java5Factory() {\r\n\t\treturn new AnnotationConfiguration().configure().buildSessionFactory();\r\n\t}","id":95955,"modified_method":"static SessionFactory java5Factory(String resource) {\r\n\t\treturn resource == null ? \r\n\t\t\tnew AnnotationConfiguration().configure().buildSessionFactory() :\r\n\t\t\tnew AnnotationConfiguration().configure(resource).buildSessionFactory();\r\n\t}","commit_id":"c46aca03b7054aefa3343639e8fa83bbca31ae5b","url":"https://github.com/zkoss/zk"},{"original_method":"static SessionFactory java4Factory() {\r\n\t\treturn new Configuration().configure().buildSessionFactory();\r\n\t}","id":95956,"modified_method":"static SessionFactory java4Factory(String resource) {\r\n\t\treturn resource == null ?\r\n\t\t\tnew Configuration().configure().buildSessionFactory() :\r\n\t\t\tnew Configuration().configure(resource).buildSessionFactory();\r\n\t}","commit_id":"c46aca03b7054aefa3343639e8fa83bbca31ae5b","url":"https://github.com/zkoss/zk"},{"original_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory() {\r\n\t\tif (_factory == null) {\r\n\t\t\ttry {\r\n\t\t\t    // Create the SessionFactory per JavaVM version and allow JDK 1.4 compatibility\r\n\t\t\t\t\tif (JVMs.isJava5()) {\r\n\t\t\t\t    _factory = java5Factory();\r\n\t\t\t\t  } else {\r\n\t\t\t\t  \t_factory = java4Factory();\r\n\t\t\t\t  }\r\n\t\t\t} catch (Throwable ex) {\r\n\t\t\t    // Make sure you log the exception, as it might be swallowed\r\n\t\t\t    log.error(\"Initial SessionFactory creation failed.\" + ex);\r\n\t\t\t    throw new ExceptionInInitializerError(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn _factory;\r\n\t}","id":95957,"modified_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t * @deprecated Use {@link #initSessionFactory(WebApp app)} instead.\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory() {\r\n\t\treturn initSessionFactory(null);\r\n\t}","commit_id":"c46aca03b7054aefa3343639e8fa83bbca31ae5b","url":"https://github.com/zkoss/zk"},{"original_method":"private boolean hasPermission(String action, Object... targets) {\n        PermissionEvaluator evaluator =\n                ServiceLocator.instance()\n                        .getInstance(PermissionEvaluator.class);\n        return evaluator.evaluatePermission(action, targets);\n    }","id":95958,"modified_method":"private boolean hasPermission(String action, Object... targets) {\n        PermissionEvaluator evaluator =\n                ServiceLocator.instance()\n                        .getInstance(PermissionEvaluator.class);\n        return evaluator.checkPermission(action, targets);\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Create\n    public void buildIndex() {\n        analyze(PermissionEvaluator.class);\n        analyze(SecurityFunctions.class);\n    }","id":95959,"modified_method":"@Create\n    public void buildIndex() {\n        registerPermissionGranters(SecurityFunctions.class);\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean evaluatePermission(String action, Object ... targets) {\n        // Get the permissions to evaluate\n        for (Method evaluatorMethod : permissionFunctions) {\n            if( evaluatorMethodApplies(evaluatorMethod, action, targets) ) {\n                try {\n                    Object[] args =\n                        prepareEvaluatorArgs(evaluatorMethod, action, targets);\n\n                    Object result = evaluatorMethod.invoke(null, args);\n                    if((Boolean)result) {\n                        return true;\n                    }\n                }\n                catch (IllegalArgumentException e) {\n                    // Permission denied if the expected arguments are not\n                    // passed\n                }\n                catch (IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                }\n                catch (InvocationTargetException e) {\n                    // Permission denied if there's an exception thrown by the\n                    // evaluator method\n                }\n            }\n        }\n        return false;\n    }","id":95960,"modified_method":"/**\n     * Checks a permission for a given action on a set of targets.\n     *\n     * @param action\n     *            The action to perform.\n     * @param targets\n     *            The target object instances to perform the action on.\n     * @return True, if the permission has been granted. False otherwise.\n     */\n    public boolean checkPermission(String action, Object... targets) {\n        boolean permissionGranted = false;\n        // Get granters for all actions (those with no declared action)\n        Collection<PermissionGranter> allActionGranters =\n                permissionGrantMethods.get(ALL_ACTION_GRANTER);\n        for( PermissionGranter granter : allActionGranters ) {\n            if( granter.shouldInvokeGranter(targets) ) {\n                if(granter.invoke(action, targets)) {\n                    return true;\n                }\n            }\n        }\n\n        // Get granters for specific actions\n        Collection<PermissionGranter> actionGranters =\n                permissionGrantMethods.get(action);\n        for( PermissionGranter granter : actionGranters ) {\n            if( granter.shouldInvokeGranter(targets) ) {\n                if( granter.invoke(action, targets) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void denyWhenSomeArgsNorPresentAndAreRequired() {\n        assertThat(\n                complexPermissionEvaluator\n                        .evaluatePermission(\"only-when-all-args-present\",\n                                new HProjectIteration()))\n                .isFalse();\n    }","id":95961,"modified_method":"@Test\n    public void denyWhenSomeArgsNorPresentAndAreRequired() {\n        assertThat(\n                complexPermissionEvaluator\n                        .checkPermission(\"only-when-all-args-present\",\n                                new HProjectIteration()))\n                .isFalse();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void multiTargetAllowWithTargetsInDifferentOrder() {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"please-allow\", new HProject(),\n                        new LocaleId(\"de-DE\"))).isTrue();\n    }","id":95962,"modified_method":"@Test\n    public void multiTargetAllowWithTargetsInDifferentOrder() {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"please-allow\", new HProject(),\n                        new LocaleId(\"de-DE\"))).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void alwaysEvaluates() throws Exception {\n        Method evaluator =\n                getStaticMethod(SimpleTestEvaluators.class,\n                        \"evaluatesToTrueAlways\");\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        null)).isTrue();\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        null,\n                        new HProject())).isTrue();\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        \"my-action\")).isTrue();\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        \"my-action\", new HProject())).isTrue();\n    }","id":95963,"modified_method":"@Test\n    public void alwaysEvaluates() throws Exception {\n        PermissionGranter granter =\n                new PermissionGranter(getStaticMethod(\n                        SimpleTestEvaluators.class,\n                        \"evaluatesToTrueAlways\"));\n\n        softly.assertThat(\n                granter.shouldInvokeGranter(null)).isTrue();\n        softly.assertThat(\n                granter.shouldInvokeGranter(\n                        null,\n                        new HProject())).isTrue();\n        softly.assertThat(\n                granter.shouldInvokeGranter(\n                        \"my-action\")).isTrue();\n        softly.assertThat(\n                granter.shouldInvokeGranter(\n                        \"my-action\", new HProject())).isTrue();\n        softly.assertAll();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void alwaysGrantWithSingleArgument() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"always-grant\", new HProject())).isTrue();\n    }","id":95964,"modified_method":"@Test\n    public void alwaysGrantWithSingleArgument() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"always-grant\", new HProject())).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void allowWhenAllArgsPresentInDisorder() {\n        assertThat(\n                complexPermissionEvaluator\n                        .evaluatePermission(\"only-when-all-args-present\",\n                                new HLocale(),\n                                new HProjectIteration(), new HProject()))\n                .isTrue();\n    }","id":95965,"modified_method":"@Test\n    public void allowWhenAllArgsPresentInDisorder() {\n        assertThat(\n                complexPermissionEvaluator\n                        .checkPermission(\"only-when-all-args-present\",\n                                new HLocale(),\n                                new HProjectIteration(), new HProject()))\n                .isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void alwaysDenyForStringBuilder() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"any-action\", new StringBuilder()))\n                .isFalse();\n    }","id":95966,"modified_method":"@Test\n    public void alwaysDenyForStringBuilder() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"any-action\", new StringBuilder()))\n                .isFalse();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void allowAnyMultiAction() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"multi-action-1\", new HProjectIteration()))\n                .isTrue();\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"multi-action-2\", new HProjectIteration()))\n                .isTrue();\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"multi-action-3\", new HProjectIteration()))\n                .isTrue();\n    }","id":95967,"modified_method":"@Test\n    public void allowAnyMultiAction() throws Exception {\n        softly.assertThat(complexPermissionEvaluator\n                .checkPermission(\"multi-action-1\", new HProjectIteration()))\n                .isTrue();\n        softly.assertThat(complexPermissionEvaluator\n                .checkPermission(\"multi-action-2\", new HProjectIteration()))\n                .isTrue();\n        softly.assertThat(complexPermissionEvaluator\n                .checkPermission(\"multi-action-3\", new HProjectIteration()))\n                .isTrue();\n        softly.assertAll();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void allowCorrectMultiActionWithDifferentType() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"multi-action-1\", new HProject()))\n                .isTrue();\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"multi-action-2\", new HProject()))\n                .isTrue();\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"multi-action-3\", new HProject()))\n                .isTrue();\n    }","id":95968,"modified_method":"@Test\n    public void denyCorrectMultiActionWithDifferentType() throws Exception {\n        softly.assertThat(complexPermissionEvaluator\n                .checkPermission(\"multi-action-1\", new HProject()))\n                .isFalse();\n        softly.assertThat(complexPermissionEvaluator\n                .checkPermission(\"multi-action-2\", new HProject()))\n                .isFalse();\n        softly.assertThat(complexPermissionEvaluator\n                .checkPermission(\"multi-action-3\", new HProject()))\n                .isFalse();\n        softly.assertAll();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void multiTargetAllow() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"please-allow\", new LocaleId(\"de-DE\"),\n                        new HProject())).isTrue();\n    }","id":95969,"modified_method":"@Test\n    public void multiTargetAllow() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"please-allow\", new LocaleId(\"de-DE\"),\n                        new HProject())).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void evaluatesForMultiTargetsInDifferentOrder() throws Exception {\n        Method evaluator =\n                getStaticMethod(SimpleTestEvaluators.class,\n                        \"evaluatesForMultiTarget\");\n\n        assertThat(simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                \"multi-target-action\", new HLocale(), new HProject()\n                )).isTrue();\n    }","id":95970,"modified_method":"@Test\n    public void evaluatesForMultiTargetsInDifferentOrder() throws Exception {\n        PermissionGranter granter =\n                new PermissionGranter(getStaticMethod(\n                        SimpleTestEvaluators.class,\n                        \"evaluatesForMultiTarget\"));\n\n        assertThat(granter.shouldInvokeGranter(\n                \"multi-target-action\", new HLocale(), new HProject()\n        )).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void allowWhenAllArgsPresentInOrder() {\n        assertThat(\n                complexPermissionEvaluator\n                        .evaluatePermission(\"only-when-all-args-present\",\n                                new HProject(),\n                                new HProjectIteration(), new HLocale()))\n                .isTrue();\n    }","id":95971,"modified_method":"@Test\n    public void allowWhenAllArgsPresentInOrder() {\n        assertThat(\n                complexPermissionEvaluator\n                        .checkPermission(\"only-when-all-args-present\",\n                                new HProject(),\n                                new HProjectIteration(), new HLocale()))\n                .isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void multiTargetDenyCheckFailed() throws Exception {\n        // Only allows German\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"please-allow\", new LocaleId(\"es-ES\"),\n                        new HProject())).isFalse();\n    }","id":95972,"modified_method":"@Test\n    public void multiTargetDenyCheckFailed() throws Exception {\n        // Only allows German\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"please-allow\", new LocaleId(\"es-ES\"),\n                        new HProject())).isFalse();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void multiTargetDenyWithDifferentTargetTypes() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"please-allow\", new LocaleId(\"de-DE\"),\n                        new HProjectIteration())).isFalse();\n    }","id":95973,"modified_method":"@Test\n    public void multiTargetDenyWithDifferentTargetTypes() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"please-allow\", new LocaleId(\"de-DE\"),\n                        new HProjectIteration())).isFalse();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void injectActionAndAllow() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"action-should-grant\", new HAccount()))\n                .isTrue();\n    }","id":95974,"modified_method":"@Test\n    public void injectActionAndAllow() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"action-should-grant\", new HAccount()))\n                .isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void multiTargetDenyWithWrongAction() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"please-deny\", new LocaleId(\"de-DE\"),\n                        new HProject())).isFalse();\n    }","id":95975,"modified_method":"@Test\n    public void multiTargetDenyWithWrongAction() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"please-deny\", new LocaleId(\"de-DE\"),\n                        new HProject())).isFalse();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void allowSpecificActionAndType() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"action-1\", new HProject())).isTrue();\n    }","id":95976,"modified_method":"@Test\n    public void allowSpecificActionAndType() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"action-1\", new HProject())).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void injectActionAndDeny() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"action-should-deny\", new HAccount()))\n                .isFalse();\n    }","id":95977,"modified_method":"@Test\n    public void injectActionAndDeny() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"action-should-deny\", new HAccount()))\n                .isFalse();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void alwaysGrant() throws Exception {\n        assertThat(\n                complexPermissionEvaluator.evaluatePermission(\"always-grant\"))\n                .isTrue();\n    }","id":95978,"modified_method":"@Test\n    public void alwaysGrant() throws Exception {\n        assertThat(\n                complexPermissionEvaluator.checkPermission(\"always-grant\"))\n                .isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void allowCorrectActionButDifferentType() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"action-1\", new HProjectIteration()))\n                .isTrue();\n    }","id":95979,"modified_method":"@Test\n    public void denyCorrectActionButDifferentType() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"action-1\", new HProjectIteration()))\n                .isFalse();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void allowMatchingActionWithMultipleTargets() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"action-1\", new HProjectIteration(),\n                        \"A string\")).isTrue();\n    }","id":95980,"modified_method":"@Test\n    public void allowMatchingActionWithMultipleTargets() throws Exception {\n        // As long as all the granter parameters are supplied, the rest of\n        // arguments can be ignored\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"action-1\", new HProject(),\n                        \"A string\")).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n    public void initialize() {\n        simplePermissionEvaluator = new PermissionEvaluator();\n        complexPermissionEvaluator = new PermissionEvaluator();\n        simplePermissionEvaluator.analyze(SimpleTestEvaluators.class);\n        complexPermissionEvaluator.analyze(ComplexTestEvaluators.class);\n    }","id":95981,"modified_method":"@BeforeMethod\n    public void initialize() {\n        simplePermissionEvaluator = new PermissionEvaluator();\n        complexPermissionEvaluator = new PermissionEvaluator();\n        simplePermissionEvaluator.registerPermissionGranters(\n                SimpleTestEvaluators.class);\n        complexPermissionEvaluator.registerPermissionGranters(\n                ComplexTestEvaluators.class);\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void evaluatesForClass() throws Exception {\n        Method evaluator =\n                getStaticMethod(SimpleTestEvaluators.class,\n                        \"evaluatesForHProject\");\n\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        null, new HProject())).isTrue();\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        \"my-action\", new HProject())).isTrue();\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        null, new HProjectIteration())).isTrue();\n        assertThat(\n                simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                        \"my-action\", new HProjectIteration())).isTrue();\n    }","id":95982,"modified_method":"@Test\n    public void evaluatesForClass() throws Exception {\n        PermissionGranter granter =\n                new PermissionGranter(\n                        getStaticMethod(SimpleTestEvaluators.class,\n                                \"evaluatesForHProject\"));\n\n        softly.assertThat(\n                granter.shouldInvokeGranter(\n                        null, new HProject())).isTrue();\n        softly.assertThat(\n                granter.shouldInvokeGranter(\n                        \"my-action\", new HProject())).isTrue();\n        softly.assertThat(\n                granter.shouldInvokeGranter(\n                        null, new HProjectIteration())).isFalse();\n        softly.assertThat(\n                granter.shouldInvokeGranter(\n                        \"my-action\", new HProjectIteration())).isFalse();\n        softly.assertAll();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void alwaysGrantWithMultipleArguments() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .evaluatePermission(\"always-grant\", new HProject(), \"A string\",\n                        new HProjectIteration())).isTrue();\n    }","id":95983,"modified_method":"@Test\n    public void alwaysGrantWithMultipleArguments() throws Exception {\n        assertThat(complexPermissionEvaluator\n                .checkPermission(\"always-grant\", new HProject(), \"A string\",\n                        new HProjectIteration())).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void evaluatesForMultiTargets() throws Exception {\n        Method evaluator =\n                getStaticMethod(SimpleTestEvaluators.class,\n                        \"evaluatesForMultiTarget\");\n\n        assertThat(simplePermissionEvaluator.evaluatorMethodApplies(evaluator,\n                \"multi-target-action\", new HProject(), new HLocale()\n                )).isTrue();\n    }","id":95984,"modified_method":"@Test\n    public void evaluatesForMultiTargets() throws Exception {\n        PermissionGranter granter =\n                new PermissionGranter(getStaticMethod(\n                        SimpleTestEvaluators.class,\n                        \"evaluatesForMultiTarget\"));\n\n        assertThat(granter.shouldInvokeGranter(\n                \"multi-target-action\", new HProject(), new HLocale()\n        )).isTrue();\n    }","commit_id":"cc282bb02e2a19df3618594973f80077162818a0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tupdateLDAPServer(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteLDAPServer(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof DuplicateLDAPServerNameException ||\n\t\t\t\te instanceof LDAPServerNameException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.portal_settings.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":95985,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tupdateLDAPServer(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteLDAPServer(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof DuplicateLDAPServerNameException ||\n\t\t\t\te instanceof LDAPFilterException ||\n\t\t\t\te instanceof LDAPServerNameException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.portal_settings.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateLDAPServer(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong ldapServerId = ParamUtil.getLong(actionRequest, \"ldapServerId\");\n\n\t\tUnicodeProperties properties = PropertiesParamUtil.getProperties(\n\t\t\tactionRequest, \"settings--\");\n\n\t\tvalidateLDAPServerName(\n\t\t\tthemeDisplay.getCompanyId(), ldapServerId, properties);\n\n\t\tString filter = ParamUtil.getString(\n\t\t\tactionRequest, \"importUserSearchFilter\");\n\n\t\tif (!LDAPUtil.validateFilter(filter)) {\n\t\t\tthrow new LDAPFilterException(\"Invalid filter syntax\");\n\t\t}\n\n\t\tif (ldapServerId <= 0) {\n\t\t\tproperties = addLDAPServer(themeDisplay.getCompanyId(), properties);\n\t\t}\n\n\t\tCompanyServiceUtil.updatePreferences(\n\t\t\tthemeDisplay.getCompanyId(), properties);\n\t}","id":95986,"modified_method":"protected void updateLDAPServer(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong ldapServerId = ParamUtil.getLong(actionRequest, \"ldapServerId\");\n\n\t\tUnicodeProperties properties = PropertiesParamUtil.getProperties(\n\t\t\tactionRequest, \"settings--\");\n\n\t\tvalidateLDAPServerName(\n\t\t\tthemeDisplay.getCompanyId(), ldapServerId, properties);\n\n\t\tString filter = ParamUtil.getString(\n\t\t\tactionRequest, \"importUserSearchFilter\");\n\n\t\tLDAPUtil.validateFilter(filter);\n\n\t\tif (ldapServerId <= 0) {\n\t\t\tproperties = addLDAPServer(themeDisplay.getCompanyId(), properties);\n\t\t}\n\n\t\tCompanyServiceUtil.updatePreferences(\n\t\t\tthemeDisplay.getCompanyId(), properties);\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getAuthSearchFilter(\n\t\t\tlong ldapServerId, long companyId, String emailAddress,\n\t\t\tString screenName, String userId)\n\t\tthrows Exception {\n\n\t\tString postfix = getPropertyPostfix(ldapServerId);\n\n\t\tString filter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_AUTH_SEARCH_FILTER + postfix);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter before transformation \" + filter);\n\t\t}\n\n\t\tfilter = StringUtil.replace(\n\t\t\tfilter,\n\t\t\tnew String[] {\n\t\t\t\t\"@company_id@\", \"@email_address@\", \"@screen_name@\", \"@user_id@\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(companyId), emailAddress, screenName, userId\n\t\t\t});\n\n\t\tif (!LDAPUtil.validateFilter(filter)) {\n\t\t\tthrow new LDAPFilterException(\"Invalid filter syntax\");\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter after transformation \" + filter);\n\t\t}\n\n\t\treturn filter;\n\t}","id":95987,"modified_method":"public static String getAuthSearchFilter(\n\t\t\tlong ldapServerId, long companyId, String emailAddress,\n\t\t\tString screenName, String userId)\n\t\tthrows Exception {\n\n\t\tString postfix = getPropertyPostfix(ldapServerId);\n\n\t\tString filter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_AUTH_SEARCH_FILTER + postfix);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter before transformation \" + filter);\n\t\t}\n\n\t\tfilter = StringUtil.replace(\n\t\t\tfilter,\n\t\t\tnew String[] {\n\t\t\t\t\"@company_id@\", \"@email_address@\", \"@screen_name@\", \"@user_id@\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(companyId), emailAddress, screenName, userId\n\t\t\t});\n\n\t\tLDAPUtil.validateFilter(filter);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Search filter after transformation \" + filter);\n\t\t}\n\n\t\treturn filter;\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean validateFilter(String filter) {\n\t\tif (Validator.isNull(filter)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfilter = filter.trim();\n\n\t\tif (filter.equals(StringPool.STAR)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfilter = StringUtil.replace(filter, StringPool.SPACE, StringPool.BLANK);\n\n\t\tif (!filter.startsWith(StringPool.OPEN_PARENTHESIS) ||\n\t\t\t!filter.endsWith(StringPool.CLOSE_PARENTHESIS)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tint count = 0;\n\n\t\tfor (int i = 0; i < filter.length(); i++) {\n\t\t\tchar c = filter.charAt(i);\n\n\t\t\tif (c == CharPool.CLOSE_PARENTHESIS) {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\telse if (c == CharPool.OPEN_PARENTHESIS) {\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif (count < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cannot have two filter types in a sequence\n\n\t\tif (Pattern.matches(\".*[~<>]*=[~<>]*=.*\", filter)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cannot have a filter type after an opening parenthesis\n\n\t\tif (Pattern.matches(\"\\\\([~<>]*=.*\", filter)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cannot have an attribute without a filter type or extensible\n\n\t\tif (Pattern.matches(\"\\\\([^~<>=]*\\\\)\", filter)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (Pattern.matches(\".*[^~<>=]*[~<>]*=\\\\)\", filter)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":95988,"modified_method":"public static void validateFilter(String filter) throws PortalException {\n\t\tif (!isValidFilter(filter)) {\n\t\t\tthrow new LDAPFilterException(\"Invalid filter \" + filter);\n\t\t}\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testFilterTypeAfterOpenParenthesis() {\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(=value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(<=value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(>=value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(~=value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(~=value)(object=value)\"));\n\t}","id":95989,"modified_method":"public void testIsValidFilterTypeAfterOpenParenthesis() {\n\t\tassertTrue(isValidFilter(\"(object=value)\"));\n\t\tassertFalse(isValidFilter(\"(=value)\"));\n\t\tassertFalse(isValidFilter(\"(<=value)\"));\n\t\tassertFalse(isValidFilter(\"(>=value)\"));\n\t\tassertFalse(isValidFilter(\"(~=value)\"));\n\t\tassertFalse(isValidFilter(\"(~=value)(object=value)\"));\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testFilterTypesInSequence() {\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value=subvalue)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object<=value)\"));\n\t\tassertEquals(\n\t\t\ttrue, LDAPUtil.validateFilter(\"(object<=value<=subvalue)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object>=value)\"));\n\t\tassertEquals(\n\t\t\ttrue, LDAPUtil.validateFilter(\"(object>=value>=subvalue)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object~=value)\"));\n\t\tassertEquals(\n\t\t\ttrue, LDAPUtil.validateFilter(\"(object~=value~=subvalue)\"));\n\t\tassertEquals(\n\t\t\ttrue,\n\t\t\tLDAPUtil.validateFilter(\"(object~=value>=subvalue<=subsubvalue)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object==value)\"));\n\t\tassertEquals(\n\t\t\tfalse, LDAPUtil.validateFilter(\"(object=value=<=subvalue)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object~==value)\"));\n\t\tassertEquals(\n\t\t\tfalse, LDAPUtil.validateFilter(\"(object=value=>=subvalue)\"));\n\t\tassertEquals(\n\t\t\tfalse,\n\t\t\tLDAPUtil.validateFilter(\"(object~=value>==subvalue<=subsubvalue)\"));\n\t}","id":95990,"modified_method":"public void testIsValidFilterTypesInSequence() {\n\t\tassertTrue(isValidFilter(\"(object=value)\"));\n\t\tassertTrue(isValidFilter(\"(object=value=subvalue)\"));\n\t\tassertTrue(isValidFilter(\"(object<=value)\"));\n\t\tassertTrue(isValidFilter(\"(object<=value<=subvalue)\"));\n\t\tassertTrue(isValidFilter(\"(object>=value)\"));\n\t\tassertTrue(isValidFilter(\"(object>=value>=subvalue)\"));\n\t\tassertTrue(isValidFilter(\"(object~=value)\"));\n\t\tassertTrue(isValidFilter(\"(object~=value~=subvalue)\"));\n\t\tassertTrue(isValidFilter(\"(object~=value>=subvalue<=subsubvalue)\"));\n\t\tassertFalse(isValidFilter(\"(object==value)\"));\n\t\tassertFalse(isValidFilter(\"(object=value=<=subvalue)\"));\n\t\tassertFalse(isValidFilter(\"(object~==value)\"));\n\t\tassertFalse(isValidFilter(\"(object=value=>=subvalue)\"));\n\t\tassertFalse(isValidFilter(\"(object~=value>==subvalue<=subsubvalue)\"));\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testFilterTypeBeforeCloseParenthesis() {\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=*)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=subobject=*)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object=)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object<=)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object>=)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object~=)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object=subobject=)\"));\n\t\tassertEquals(\n\t\t\tfalse, LDAPUtil.validateFilter(\"(org=liferay)(object=subobject=)\"));\n\t}","id":95991,"modified_method":"public void testIsValidFilterTypeBeforeCloseParenthesis() {\n\t\tassertTrue(isValidFilter(\"(object=value)\"));\n\t\tassertTrue(isValidFilter(\"(object=*)\"));\n\t\tassertTrue(isValidFilter(\"(object=subobject=*)\"));\n\t\tassertFalse(isValidFilter(\"(object=)\"));\n\t\tassertFalse(isValidFilter(\"(object<=)\"));\n\t\tassertFalse(isValidFilter(\"(object>=)\"));\n\t\tassertFalse(isValidFilter(\"(object~=)\"));\n\t\tassertFalse(isValidFilter(\"(object=subobject=)\"));\n\t\tassertFalse(isValidFilter(\"(org=liferay)(object=subobject=)\"));\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testFilterBalancedParentheses() {\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"((((object=value))))\"));\n\t\tassertEquals(\n\t\t\ttrue, LDAPUtil.validateFilter(\"((((object=value))(org=liferay)))\"));\n\t\tassertEquals(\n\t\t\ttrue,\n\t\t\tLDAPUtil.validateFilter(\n\t\t\t\t\"(((inetorg=www)((object=value))(org=liferay)))(user=test)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object=value))\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(((object=value))\"));\n\t\tassertEquals(\n\t\t\tfalse,\n\t\t\tLDAPUtil.validateFilter(\"((((object=value)))(org=liferay)))\"));\n\t\tassertEquals(\n\t\t\tfalse,\n\t\t\tLDAPUtil.validateFilter(\n\t\t\t\t\"(((inetorg=www)((object=value))(org=liferay)))(user=test))\"));\n\t}","id":95992,"modified_method":"public void testIsValidFilterBalancedParentheses() {\n\t\tassertTrue(isValidFilter(\"(object=value)\"));\n\t\tassertTrue(isValidFilter(\"((((object=value))))\"));\n\t\tassertTrue(isValidFilter(\"((((object=value))(org=liferay)))\"));\n\t\tassertTrue(\n\t\t\tisValidFilter(\n\t\t\t\t\"(((inetorg=www)((object=value))(org=liferay)))(user=test)\"));\n\t\tassertFalse(isValidFilter(\"(object=value))\"));\n\t\tassertFalse(isValidFilter(\"(((object=value))\"));\n\t\tassertFalse(isValidFilter(\"((((object=value)))(org=liferay)))\"));\n\t\tassertFalse(\n\t\t\tisValidFilter(\n\t\t\t\t\"(((inetorg=www)((object=value))(org=liferay)))(user=test))\"));\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testNoFilterType() {\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object)(value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(!object)\"));\n\t}","id":95993,"modified_method":"public void testIsValidFilterNoFilterType() {\n\t\tassertTrue(isValidFilter(\"(object=value)\"));\n\t\tassertFalse(isValidFilter(\"(object)\"));\n\t\tassertFalse(isValidFilter(\"(object)(value)\"));\n\t\tassertFalse(isValidFilter(\"(!object)\"));\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testFilterOpenAndCloseParentheses() {\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"  (object=value)\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"(object=value)  \"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"object=value)\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(object=value\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"object=value\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\"(\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\")\"));\n\t\tassertEquals(false, LDAPUtil.validateFilter(\")(\"));\n\t}","id":95994,"modified_method":"public void testIsValidFilterOpenAndCloseParentheses() {\n\t\tassertTrue(isValidFilter(\"(object=value)\"));\n\t\tassertTrue(isValidFilter(\"  (object=value)\"));\n\t\tassertTrue(isValidFilter(\"(object=value)  \"));\n\t\tassertFalse(isValidFilter(\"object=value)\"));\n\t\tassertFalse(isValidFilter(\"(object=value\"));\n\t\tassertFalse(isValidFilter(\"object=value\"));\n\t\tassertFalse(isValidFilter(\"(\"));\n\t\tassertFalse(isValidFilter(\")\"));\n\t\tassertFalse(isValidFilter(\")(\"));\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testFilterSpecialChars() {\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"*\"));\n\t\tassertEquals(true, LDAPUtil.validateFilter(\"  *   \"));\n\t}","id":95995,"modified_method":"public void testIsValidFilterSpecialChars() {\n\t\tassertTrue(isValidFilter(\"\"));\n\t\tassertTrue(isValidFilter(\"*\"));\n\t\tassertTrue(isValidFilter(\"  *   \"));\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public User importLDAPUser(\n\t\t\tlong ldapServerId, long companyId, String emailAddress,\n\t\t\tString screenName)\n\t\tthrows Exception {\n\n\t\tLdapContext ldapContext = null;\n\n\t\tNamingEnumeration<SearchResult> enu = null;\n\n\t\ttry {\n\t\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\t\tldapContext = PortalLDAPUtil.getContext(ldapServerId, companyId);\n\n\t\t\tif (ldapContext == null) {\n\t\t\t\tthrow new SystemException(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.LDAP_AUTH_SEARCH_FILTER + postfix);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Search filter before transformation \" + filter);\n\t\t\t}\n\n\t\t\tfilter = StringUtil.replace(\n\t\t\t\tfilter,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"@company_id@\", \"@email_address@\", \"@screen_name@\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tString.valueOf(companyId), emailAddress, screenName\n\t\t\t\t});\n\n\t\t\tif (!LDAPUtil.validateFilter(filter)) {\n\t\t\t\tthrow new LDAPFilterException(\"Invalid filter syntax\");\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Search filter after transformation \" + filter);\n\t\t\t}\n\n\t\t\tProperties userMappings = LDAPSettingsUtil.getUserMappings(\n\t\t\t\tldapServerId, companyId);\n\n\t\t\tString userMappingsScreenName = GetterUtil.getString(\n\t\t\t\tuserMappings.getProperty(\"screenName\")).toLowerCase();\n\n\t\t\tSearchControls searchControls = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 1, 0,\n\t\t\t\tnew String[] {userMappingsScreenName}, false, false);\n\n\t\t\tenu = ldapContext.search(baseDN, filter, searchControls);\n\n\t\t\tif (enu.hasMoreElements()) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Search filter returned at least one result\");\n\t\t\t\t}\n\n\t\t\t\tBinding binding = enu.nextElement();\n\n\t\t\t\tAttributes attributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, binding));\n\n\t\t\t\treturn importLDAPUser(\n\t\t\t\t\tldapServerId, companyId, ldapContext, attributes,\n\t\t\t\t\tStringPool.BLANK);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Problem accessing LDAP server \" + e.getMessage());\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(e, e);\n\t\t\t}\n\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Problem accessing LDAP server \" + e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (enu != null) {\n\t\t\t\tenu.close();\n\t\t\t}\n\n\t\t\tif (ldapContext != null) {\n\t\t\t\tldapContext.close();\n\t\t\t}\n\t\t}\n\t}","id":95996,"modified_method":"public User importLDAPUser(\n\t\t\tlong ldapServerId, long companyId, String emailAddress,\n\t\t\tString screenName)\n\t\tthrows Exception {\n\n\t\tLdapContext ldapContext = null;\n\n\t\tNamingEnumeration<SearchResult> enu = null;\n\n\t\ttry {\n\t\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\t\tldapContext = PortalLDAPUtil.getContext(ldapServerId, companyId);\n\n\t\t\tif (ldapContext == null) {\n\t\t\t\tthrow new SystemException(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.LDAP_AUTH_SEARCH_FILTER + postfix);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Search filter before transformation \" + filter);\n\t\t\t}\n\n\t\t\tfilter = StringUtil.replace(\n\t\t\t\tfilter,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"@company_id@\", \"@email_address@\", \"@screen_name@\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tString.valueOf(companyId), emailAddress, screenName\n\t\t\t\t});\n\n\t\t\tLDAPUtil.validateFilter(filter);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Search filter after transformation \" + filter);\n\t\t\t}\n\n\t\t\tProperties userMappings = LDAPSettingsUtil.getUserMappings(\n\t\t\t\tldapServerId, companyId);\n\n\t\t\tString userMappingsScreenName = GetterUtil.getString(\n\t\t\t\tuserMappings.getProperty(\"screenName\")).toLowerCase();\n\n\t\t\tSearchControls searchControls = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 1, 0,\n\t\t\t\tnew String[] {userMappingsScreenName}, false, false);\n\n\t\t\tenu = ldapContext.search(baseDN, filter, searchControls);\n\n\t\t\tif (enu.hasMoreElements()) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Search filter returned at least one result\");\n\t\t\t\t}\n\n\t\t\t\tBinding binding = enu.nextElement();\n\n\t\t\t\tAttributes attributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, binding));\n\n\t\t\t\treturn importLDAPUser(\n\t\t\t\t\tldapServerId, companyId, ldapContext, attributes,\n\t\t\t\t\tStringPool.BLANK);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Problem accessing LDAP server \" + e.getMessage());\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(e, e);\n\t\t\t}\n\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Problem accessing LDAP server \" + e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (enu != null) {\n\t\t\t\tenu.close();\n\t\t\t}\n\n\t\t\tif (ldapContext != null) {\n\t\t\t\tldapContext.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"ceaf0fd13afc20db8668a072000cfac25a929cd0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public BehaviorDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0a, fqName)) {\n      case 0:\n        return new SNotation_BehaviorDescriptor();\n      case 3:\n        return new SNotationLabel_BehaviorDescriptor();\n      case 7:\n        return new SNotationParentheses_BehaviorDescriptor();\n      case 5:\n        return new SNotationNewLine_BehaviorDescriptor();\n      case 8:\n        return new SNotationPartList_BehaviorDescriptor();\n      case 4:\n        return new SNotationMapping_BehaviorDescriptor();\n      case 9:\n        return new SNotationQuantifier_BehaviorDescriptor();\n      case 14:\n        return new SStructureLinkRef_BehaviorDescriptor();\n      case 15:\n        return new SStructurePropertyRef_BehaviorDescriptor();\n      case 6:\n        return new SNotationNospace_BehaviorDescriptor();\n      case 10:\n        return new SNotationStyle_BehaviorDescriptor();\n      case 11:\n        return new SNotationStyleIndent_BehaviorDescriptor();\n      case 2:\n        return new SNotationCall_BehaviorDescriptor();\n      case 13:\n        return new SNotationTab_BehaviorDescriptor();\n      case 12:\n        return new SNotationStyleSeparator_BehaviorDescriptor();\n      case 1:\n        return new SNotationBreak_BehaviorDescriptor();\n      default:\n        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);\n    }\n  }","id":95997,"modified_method":"public BehaviorDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0a, fqName)) {\n      case 0:\n        return new SNotation_BehaviorDescriptor();\n      case 3:\n        return new SNotationLabel_BehaviorDescriptor();\n      case 7:\n        return new SNotationParentheses_BehaviorDescriptor();\n      case 5:\n        return new SNotationNewLine_BehaviorDescriptor();\n      case 8:\n        return new SNotationPartList_BehaviorDescriptor();\n      case 4:\n        return new SNotationMapping_BehaviorDescriptor();\n      case 9:\n        return new SNotationQuantifier_BehaviorDescriptor();\n      case 15:\n        return new SStructureLinkRef_BehaviorDescriptor();\n      case 16:\n        return new SStructurePropertyRef_BehaviorDescriptor();\n      case 6:\n        return new SNotationNospace_BehaviorDescriptor();\n      case 10:\n        return new SNotationStyle_BehaviorDescriptor();\n      case 11:\n        return new SNotationStyleIndent_BehaviorDescriptor();\n      case 2:\n        return new SNotationCall_BehaviorDescriptor();\n      case 13:\n        return new SNotationTab_BehaviorDescriptor();\n      case 12:\n        return new SNotationStyleSeparator_BehaviorDescriptor();\n      case 1:\n        return new SNotationBreak_BehaviorDescriptor();\n      case 14:\n        return new SNotationUnorderedGroup_BehaviorDescriptor();\n      default:\n        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);\n    }\n  }","commit_id":"892e770a5d2a2429d5966ccbeca390e40ad0c6e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0a, fqName)) {\n      case 0:\n        return new SNotationMapping_Constraints();\n      case 2:\n        return new SNotationQuantifier_Constraints();\n      case 4:\n        return new SStructureLinkRef_Constraints();\n      case 5:\n        return new SStructurePropertyRef_Constraints();\n      case 3:\n        return new SStructureEntityRef_Constraints();\n      case 1:\n        return new SNotationPart_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","id":95998,"modified_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0a, fqName)) {\n      case 0:\n        return new SNotationMapping_Constraints();\n      case 2:\n        return new SNotationQuantifier_Constraints();\n      case 5:\n        return new SStructureLinkRef_Constraints();\n      case 6:\n        return new SStructurePropertyRef_Constraints();\n      case 4:\n        return new SStructureEntityRef_Constraints();\n      case 1:\n        return new SNotationPart_Constraints();\n      case 3:\n        return new SNotationUnorderedGroup_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","commit_id":"892e770a5d2a2429d5966ccbeca390e40ad0c6e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean sideTransformHintSubstituteActionsBuilder_Precondition_SNotationPart_146911029171910614(final IOperationContext operationContext, final SideTransformPreconditionContext _context) {\n    return ListSequence.fromList(SNodeOperations.getDescendants(_context.getSourceNode(), \"jetbrains.mps.core.notation.structure.SNotationMapping\", false, new String[]{})).isEmpty();\n  }","id":95999,"modified_method":"public static boolean sideTransformHintSubstituteActionsBuilder_Precondition_SNotationPart_146911029171910614(final IOperationContext operationContext, final SideTransformPreconditionContext _context) {\n    SNode outer = SNotationActionUtil.getLeftOutermostNotation(_context.getSourceNode());\n    return SNodeOperations.isInstanceOf(outer, \"jetbrains.mps.core.notation.structure.SNotationCorePart\") && ListSequence.fromList(SNodeOperations.getDescendants(outer, \"jetbrains.mps.core.notation.structure.SNotationMapping\", false, new String[]{})).isEmpty();\n  }","commit_id":"892e770a5d2a2429d5966ccbeca390e40ad0c6e5","url":"https://github.com/JetBrains/MPS"}]