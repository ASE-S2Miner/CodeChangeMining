[{"original_method":"@Test\n    public void reportsTaskActionExecutionFailsWithRuntimeException() {\n        File buildFile = getTestBuildFile(\"task-action-execution-failure.gradle\");\n\n        GradleExecutionFailure failure = usingBuildFile(buildFile).runTasksAndExpectFailure(\"brokenClosure\");\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(3);\n        failure.assertHasContext(\"Execution failed for task ':brokenClosure'\");\n        failure.assertHasDescription(\"broken closure\");\n    }","id":32000,"modified_method":"@Test\n    public void reportsTaskActionExecutionFailsWithRuntimeException() {\n        File buildFile = getTestBuildFile(\"task-action-execution-failure.gradle\");\n\n        ExecutionFailure failure = usingBuildFile(buildFile).withTasks(\"brokenClosure\").runWithFailure();\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(3);\n        failure.assertHasContext(\"Execution failed for task ':brokenClosure'\");\n        failure.assertHasDescription(\"broken closure\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void reportsTaskActionExecutionFailsWithError() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\"createTask('do-stuff')\", \"{\", \"1/0\", \"}\");\n        GradleExecutionFailure failure = usingBuildFile(buildFile).runTasksAndExpectFailure(\"do-stuff\");\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(3);\n        failure.assertHasContext(\"Execution failed for task ':do-stuff'\");\n        failure.assertHasDescription(\"/ by zero\");\n    }","id":32001,"modified_method":"@Test\n    public void reportsTaskActionExecutionFailsWithError() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\"createTask('do-stuff')\", \"{\", \"1/0\", \"}\");\n        ExecutionFailure failure = usingBuildFile(buildFile).withTasks(\"do-stuff\").runWithFailure();\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(3);\n        failure.assertHasContext(\"Execution failed for task ':do-stuff'\");\n        failure.assertHasDescription(\"/ by zero\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void reportsGroovyCompilationException() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n            \"// a comment\",\n            \"import org.gradle.unknown.Unknown\",\n            \"new Unknown()\");\n        GradleExecutionFailure failure = inTestDirectory().runTasksAndExpectFailure();\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(2);\n        failure.assertHasContext(String.format(\"Could not compile build file '%s'.\", buildFile));\n    }","id":32002,"modified_method":"@Test\n    public void reportsGroovyCompilationException() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n            \"// a comment\",\n            \"import org.gradle.unknown.Unknown\",\n            \"new Unknown()\");\n        ExecutionFailure failure = inTestDirectory().runWithFailure();\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(2);\n        failure.assertHasContext(String.format(\"Could not compile build file '%s'.\", buildFile));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void reportsProjectEvaulationFailsWithGroovyException() {\n        GradleExecutionFailure failure = usingBuildScript(\"createTakk('do-stuff')\").runTasksAndExpectFailure();\n\n        failure.assertHasFileName(\"Embedded build file\");\n        failure.assertHasLineNumber(1);\n        failure.assertHasContext(\"A problem occurred evaluating root project 'tmpTest'\");\n    }","id":32003,"modified_method":"@Test\n    public void reportsProjectEvaulationFailsWithGroovyException() {\n        ExecutionFailure failure = usingBuildScript(\"createTakk('do-stuff')\").runWithFailure();\n\n        failure.assertHasFileName(\"Embedded build file\");\n        failure.assertHasLineNumber(1);\n        failure.assertHasContext(\"A problem occurred evaluating root project 'tmpTest'\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void reportsNestedProjectEvaulationFailsWithRuntimeException() {\n        testFile(\"settings.gradle\").write(\"include 'child'\");\n\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\"dependsOn 'child'\", \"createTask('t')\");\n\n        TestFile childBuildFile = testFile(\"child/build.gradle\");\n        childBuildFile.writelns(\n                \"def broken = { ->\",\n                \"    throw new RuntimeException('failure') }\",\n                \"broken()\");\n        GradleExecutionFailure failure = inTestDirectory().runTasksAndExpectFailure(\"t\");\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", childBuildFile));\n        failure.assertHasLineNumber(2);\n        failure.assertHasContext(\"A problem occurred evaluating project ':child'\");\n        failure.assertHasDescription(\"failure\");\n    }","id":32004,"modified_method":"@Test\n    public void reportsNestedProjectEvaulationFailsWithRuntimeException() {\n        testFile(\"settings.gradle\").write(\"include 'child'\");\n\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\"dependsOn 'child'\", \"createTask('t')\");\n\n        TestFile childBuildFile = testFile(\"child/build.gradle\");\n        childBuildFile.writelns(\n                \"def broken = { ->\",\n                \"    throw new RuntimeException('failure') }\",\n                \"broken()\");\n        ExecutionFailure failure = inTestDirectory().withTasks(\"t\").runWithFailure();\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", childBuildFile));\n        failure.assertHasLineNumber(2);\n        failure.assertHasContext(\"A problem occurred evaluating project ':child'\");\n        failure.assertHasDescription(\"failure\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void reportsTaskGraphActionExecutionFailsWithRuntimeException() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\"build.taskGraph.whenReady {\", \"throw new RuntimeException('broken closure')\", \"}\", \"createTask('a')\");\n\n        GradleExecutionFailure failure = usingBuildFile(buildFile).runTasksAndExpectFailure(\"a\");\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(2);\n        failure.assertHasContext(\"Failed to notify task execution graph listener\");\n        failure.assertHasDescription(\"broken closure\");\n    }","id":32005,"modified_method":"@Test\n    public void reportsTaskGraphActionExecutionFailsWithRuntimeException() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\"build.taskGraph.whenReady {\", \"throw new RuntimeException('broken closure')\", \"}\", \"createTask('a')\");\n\n        ExecutionFailure failure = usingBuildFile(buildFile).withTasks(\"a\").runWithFailure();\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasLineNumber(2);\n        failure.assertHasContext(\"Failed to notify task execution graph listener\");\n        failure.assertHasDescription(\"broken closure\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void providesADefaultBuildForBuildSrcProject() {\n        testFile(\"buildSrc/src/main/java/BuildClass.java\").writelns(\"public class BuildClass { }\");\n        testFile(\"build.gradle\").writelns(\"new BuildClass()\");\n        inTestDirectory().showTaskList();\n    }","id":32006,"modified_method":"@Test\n    public void providesADefaultBuildForBuildSrcProject() {\n        testFile(\"buildSrc/src/main/java/BuildClass.java\").writelns(\"public class BuildClass { }\");\n        testFile(\"build.gradle\").writelns(\"new BuildClass()\");\n        inTestDirectory().withTaskList().run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"private void attachDistribution(Object target) throws Exception {\n        GradleDistribution dist = getDist();\n        for (Class<?> current = target.getClass(); current != null; current = current.getSuperclass()) {\n            for (Field field : current.getDeclaredFields()) {\n                if (field.getType().equals(GradleDistribution.class)) {\n                    field.setAccessible(true);\n                    field.set(target, dist);\n                }\n            }\n        }\n    }","id":32007,"modified_method":"private void attachDistribution(Object target) throws Exception {\n        GradleDistribution distribution = getDist();\n        injectValue(target, distribution, GradleDistribution.class);\n        injectValue(target, new ForkingGradleExecuter(distribution), GradleExecuter.class);\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void canAddDynamicMethodsToProject() {\n        testFile(\"settings.gradle\").writelns(\"include 'child'\");\n        testFile(\"build.gradle\").writelns(\n                \"def rootMethod(p) { 'root' + p }\",\n                \"def sharedMethod(p) { 'ignore me' }\",\n                \"convention.plugins.test = new \" + ConventionBean.class.getName() + \"()\",\n                \"createTask('rootTask')\",\n                \"createTask('testTask')\"\n        );\n        testFile(\"child/build.gradle\").writelns(\n                \"def childMethod(p) { 'child' + p }\",\n                \"def sharedMethod(p) { 'shared' + p }\",\n                \"createTask('testTask') {\",\n                DynamicObjectIntegrationTestHelper.class.getName() + \".reportMethods(project)\",\n                \"}\"\n        );\n\n        inTestDirectory().runTasks(\"testTask\");\n\n        assertThat(result, equalTo(\"rootMethod,childMethod,sharedMethod,conventionMethod,task ':child:testTask'\"));\n    }","id":32008,"modified_method":"@Test\n    public void canAddDynamicMethodsToProject() {\n        testFile(\"settings.gradle\").writelns(\"include 'child'\");\n        testFile(\"build.gradle\").writelns(\n                \"def rootMethod(p) { 'root' + p }\",\n                \"def sharedMethod(p) { 'ignore me' }\",\n                \"convention.plugins.test = new \" + ConventionBean.class.getName() + \"()\",\n                \"createTask('rootTask')\",\n                \"createTask('testTask')\"\n        );\n        testFile(\"child/build.gradle\").writelns(\n                \"def childMethod(p) { 'child' + p }\",\n                \"def sharedMethod(p) { 'shared' + p }\",\n                \"createTask('testTask') {\",\n                DynamicObjectIntegrationTestHelper.class.getName() + \".reportMethods(project)\",\n                \"}\"\n        );\n\n        inTestDirectory().withTasks(\"testTask\").run();\n\n        assertThat(result, equalTo(\"rootMethod,childMethod,sharedMethod,conventionMethod,task ':child:testTask'\"));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void canAddDynamicPropertiesToProject() {\n        testFile(\"settings.gradle\").writelns(\"include 'child'\");\n        testFile(\"build.gradle\").writelns(\n                \"rootProperty = 'root'\",\n                \"sharedProperty = 'ignore me'\",\n                \"convention.plugins.test = new \" + ConventionBean.class.getName() + \"()\",\n                \"createTask('rootTask')\",\n                \"createTask('testTask')\"\n        );\n        testFile(\"child/build.gradle\").writelns(\n                \"childProperty = 'child'\",\n                \"sharedProperty = 'shared'\",\n                \"createTask('testTask') {\",\n                DynamicObjectIntegrationTestHelper.class.getName() + \".reportProperties(project)\",\n                \"}\"\n        );\n\n        inTestDirectory().runTasks(\"testTask\");\n\n        assertThat(result, equalTo(\"root,child,shared,convention,task ':child:testTask'\"));\n    }","id":32009,"modified_method":"@Test\n    public void canAddDynamicPropertiesToProject() {\n        testFile(\"settings.gradle\").writelns(\"include 'child'\");\n        testFile(\"build.gradle\").writelns(\n                \"rootProperty = 'root'\",\n                \"sharedProperty = 'ignore me'\",\n                \"convention.plugins.test = new \" + ConventionBean.class.getName() + \"()\",\n                \"createTask('rootTask')\",\n                \"createTask('testTask')\"\n        );\n        testFile(\"child/build.gradle\").writelns(\n                \"childProperty = 'child'\",\n                \"sharedProperty = 'shared'\",\n                \"createTask('testTask') {\",\n                DynamicObjectIntegrationTestHelper.class.getName() + \".reportProperties(project)\",\n                \"}\"\n        );\n\n        inTestDirectory().withTasks(\"testTask\").run();\n\n        assertThat(result, equalTo(\"root,child,shared,convention,task ':child:testTask'\"));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void handlesJavaSourceOnly() {\n        testFile(\"src/main/java/somepackage/SomeClass.java\").writelns(\"public class SomeClass { }\");\n        testFile(\"build.gradle\").writelns(\n                \"usePlugin('groovy')\",\n                // todo: should not need these\n                \"version = 'dev'\",\n                \"sourceCompatibility = 1.5\",\n                \"targetCompatibility = 1.5\");\n        inTestDirectory().runTasks(\"libs\");\n    }","id":32010,"modified_method":"@Test\n    public void handlesJavaSourceOnly() {\n        testFile(\"src/main/java/somepackage/SomeClass.java\").writelns(\"public class SomeClass { }\");\n        testFile(\"build.gradle\").writelns(\n                \"usePlugin('groovy')\",\n                // todo: should not need these\n                \"sourceCompatibility = 1.5\",\n                \"targetCompatibility = 1.5\");\n        inTestDirectory().withTasks(\"libs\").run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void javadocGenerationFailsOnError() throws IOException {\n        TestFile buildFile = testFile(\"javadocs.gradle\");\n        buildFile.write(\"usePlugin(org.gradle.api.plugins.JavaPlugin)\");\n        testFile(\"src/main/java/org/gradle/broken.java\").write(\"broken\");\n\n        GradleExecutionFailure failure = usingBuildFile(buildFile).runTasksAndExpectFailure(\"javadoc\");\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasContext(\"Execution failed for task ':javadoc'\");\n        failure.assertHasDescription(\"Javadoc generation failed.\");\n    }","id":32011,"modified_method":"@Test\n    public void javadocGenerationFailsOnError() throws IOException {\n        TestFile buildFile = testFile(\"javadocs.gradle\");\n        buildFile.write(\"usePlugin(org.gradle.api.plugins.JavaPlugin)\");\n        testFile(\"src/main/java/org/gradle/broken.java\").write(\"broken\");\n\n        ExecutionFailure failure = usingBuildFile(buildFile).withTasks(\"javadoc\").runWithFailure();\n\n        failure.assertHasFileName(String.format(\"Build file '%s'\", buildFile));\n        failure.assertHasContext(\"Execution failed for task ':javadoc'\");\n        failure.assertHasDescription(\"Javadoc generation failed.\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void multiProjectBuildCanHaveMultipleProjectsWithSameProjectDir() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child1', 'child2'\",\n            \"project(':child1').projectDir = new File(settingsDir, 'shared')\",\n            \"project(':child2').projectDir = new File(settingsDir, 'shared')\"\n        );\n        testFile(\"shared/build.gradle\").write(\"createTask('do-stuff')\");\n\n        inTestDirectory().runTasks(\"do-stuff\").assertTasksExecuted(\":child1:do-stuff\", \":child2:do-stuff\");\n    }","id":32012,"modified_method":"@Test\n    public void multiProjectBuildCanHaveMultipleProjectsWithSameProjectDir() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child1', 'child2'\",\n            \"project(':child1').projectDir = new File(settingsDir, 'shared')\",\n            \"project(':child2').projectDir = new File(settingsDir, 'shared')\"\n        );\n        testFile(\"shared/build.gradle\").write(\"createTask('do-stuff')\");\n\n        inTestDirectory().withTasks(\"do-stuff\").run().assertTasksExecuted(\":child1:do-stuff\", \":child2:do-stuff\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void canDetermineRootProjectAndDefaultProjectBasedOnProjectDirectory() {\n        File rootDir = getTestDir();\n        File childDir = new File(rootDir, \"child\");\n\n        testFile(\"settings.gradle\").write(\"include('child')\");\n        testFile(\"build.gradle\").write(\"createTask('do-stuff')\");\n        testFile(\"child/build.gradle\").write(\"createTask('do-stuff')\");\n\n        usingProjectDir(rootDir).withSearchUpwards().runTasks(\"do-stuff\").assertTasksExecuted(\":do-stuff\", \":child:do-stuff\");\n        usingProjectDir(rootDir).withSearchUpwards().runTasks(\":do-stuff\").assertTasksExecuted(\":do-stuff\");\n\n        usingProjectDir(childDir).withSearchUpwards().runTasks(\"do-stuff\").assertTasksExecuted(\":child:do-stuff\");\n        usingProjectDir(childDir).withSearchUpwards().runTasks(\":do-stuff\").assertTasksExecuted(\":do-stuff\");\n    }","id":32013,"modified_method":"@Test\n    public void canDetermineRootProjectAndDefaultProjectBasedOnProjectDirectory() {\n        File rootDir = getTestDir();\n        File childDir = new File(rootDir, \"child\");\n\n        testFile(\"settings.gradle\").write(\"include('child')\");\n        testFile(\"build.gradle\").write(\"createTask('do-stuff')\");\n        testFile(\"child/build.gradle\").write(\"createTask('do-stuff')\");\n\n        usingProjectDir(rootDir).withSearchUpwards().withTasks(\"do-stuff\").run().assertTasksExecuted(\":do-stuff\", \":child:do-stuff\");\n        usingProjectDir(rootDir).withSearchUpwards().withTasks(\":do-stuff\").run().assertTasksExecuted(\":do-stuff\");\n\n        usingProjectDir(childDir).withSearchUpwards().withTasks(\"do-stuff\").run().assertTasksExecuted(\":child:do-stuff\");\n        usingProjectDir(childDir).withSearchUpwards().withTasks(\":do-stuff\").run().assertTasksExecuted(\":do-stuff\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void canDetermineRootProjectAndDefaultProjectBasedOnBuildFile() {\n        testFile(\"settings.gradle\").write(\"include('child')\");\n\n        TestFile rootBuildFile = testFile(\"build.gradle\");\n        rootBuildFile.write(\"createTask('do-stuff')\");\n\n        TestFile childBuildFile = testFile(\"child/build.gradle\");\n        childBuildFile.write(\"createTask('do-stuff')\");\n\n        usingBuildFile(rootBuildFile).withSearchUpwards().runTasks(\"do-stuff\").assertTasksExecuted(\":do-stuff\", \":child:do-stuff\");\n        usingBuildFile(rootBuildFile).withSearchUpwards().runTasks(\":do-stuff\").assertTasksExecuted(\":do-stuff\");\n\n        usingBuildFile(childBuildFile).withSearchUpwards().runTasks(\"do-stuff\").assertTasksExecuted(\":child:do-stuff\");\n        usingBuildFile(childBuildFile).withSearchUpwards().runTasks(\":do-stuff\").assertTasksExecuted(\":do-stuff\");\n    }","id":32014,"modified_method":"@Test\n    public void canDetermineRootProjectAndDefaultProjectBasedOnBuildFile() {\n        testFile(\"settings.gradle\").write(\"include('child')\");\n\n        TestFile rootBuildFile = testFile(\"build.gradle\");\n        rootBuildFile.write(\"createTask('do-stuff')\");\n\n        TestFile childBuildFile = testFile(\"child/build.gradle\");\n        childBuildFile.write(\"createTask('do-stuff')\");\n\n        usingBuildFile(rootBuildFile).withSearchUpwards().withTasks(\"do-stuff\").run().assertTasksExecuted(\":do-stuff\", \":child:do-stuff\");\n        usingBuildFile(rootBuildFile).withSearchUpwards().withTasks(\":do-stuff\").run().assertTasksExecuted(\":do-stuff\");\n\n        usingBuildFile(childBuildFile).withSearchUpwards().withTasks(\"do-stuff\").run().assertTasksExecuted(\":child:do-stuff\");\n        usingBuildFile(childBuildFile).withSearchUpwards().withTasks(\":do-stuff\").run().assertTasksExecuted(\":do-stuff\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void settingsFileInParentDirectoryTakesPrecedenceOverBuildFile() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child'\",\n            \"project(':child').buildFileName = 'child.gradle'\"\n        );\n\n        File subDirectory = new File(getTestDir(), \"child\");\n        testFile(subDirectory, \"build.gradle\").write(\"throw new RuntimeException()\");\n        testFile(subDirectory, \"child.gradle\").write(\"createTask('do-stuff')\");\n\n        inDirectory(subDirectory).withSearchUpwards().runTasks(\"do-stuff\");\n        usingProjectDir(subDirectory).withSearchUpwards().runTasks(\"do-stuff\");\n    }","id":32015,"modified_method":"@Test\n    public void settingsFileInParentDirectoryTakesPrecedenceOverBuildFile() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child'\",\n            \"project(':child').buildFileName = 'child.gradle'\"\n        );\n\n        File subDirectory = new File(getTestDir(), \"child\");\n        testFile(subDirectory, \"build.gradle\").write(\"throw new RuntimeException()\");\n        testFile(subDirectory, \"child.gradle\").write(\"createTask('do-stuff')\");\n\n        inDirectory(subDirectory).withSearchUpwards().withTasks(\"do-stuff\").run();\n        usingProjectDir(subDirectory).withSearchUpwards().withTasks(\"do-stuff\").run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void buildFailsWhenMultipleProjectsMeetDefaultProjectCriteria() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child'\",\n            \"project(':child').projectDir = rootProject.projectDir\");\n        testFile(\"build.gradle\").write(\"// empty\");    \n\n        GradleExecutionFailure result = inTestDirectory().runTasksAndExpectFailure(\"test\");\n        result.assertContext(startsWith(\"Could not select the default project for this build. Multiple projects in this build have project directory\"));\n\n        result = usingProjectDir(getTestDir()).runTasksAndExpectFailure(\"test\");\n        result.assertContext(startsWith(\"Could not select the default project for this build. Multiple projects in this build have project directory\"));\n\n        result = usingBuildFile(testFile(\"build.gradle\")).runTasksAndExpectFailure(\"test\");\n        result.assertContext(startsWith(\"Could not select the default project for this build. Multiple projects in this build have build file\"));\n    }","id":32016,"modified_method":"@Test\n    public void buildFailsWhenMultipleProjectsMeetDefaultProjectCriteria() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child'\",\n            \"project(':child').projectDir = rootProject.projectDir\");\n        testFile(\"build.gradle\").write(\"// empty\");\n\n        ExecutionFailure result = inTestDirectory().withTasks(\"test\").runWithFailure();\n        result.assertContext(startsWith(\"Could not select the default project for this build. Multiple projects in this build have project directory\"));\n\n        result = usingProjectDir(getTestDir()).withTasks(\"test\").runWithFailure();\n        result.assertContext(startsWith(\"Could not select the default project for this build. Multiple projects in this build have project directory\"));\n\n        result = usingBuildFile(testFile(\"build.gradle\")).withTasks(\"test\").runWithFailure();\n        result.assertContext(startsWith(\"Could not select the default project for this build. Multiple projects in this build have build file\"));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void buildFailsWhenSpecifiedProjectDirectoryIsNotADirectory() {\n        GradleExecutionFailure result = usingProjectDir(testFile(\"unknown dir\")).runTasksAndExpectFailure();\n        result.assertContext(startsWith(\"Project directory\"));\n        result.assertContext(endsWith(\"does not exist.\"));\n    }","id":32017,"modified_method":"@Test\n    public void buildFailsWhenSpecifiedProjectDirectoryIsNotADirectory() {\n        ExecutionFailure result = usingProjectDir(testFile(\"unknown dir\")).runWithFailure();\n        result.assertContext(startsWith(\"Project directory\"));\n        result.assertContext(endsWith(\"does not exist.\"));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void multiProjectBuildCanHaveSeveralProjectsWithSameBuildFile() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child1', 'child2'\",\n            \"project(':child1').buildFileName = '../child.gradle'\",\n            \"project(':child2').buildFileName = '../child.gradle'\"\n        );\n        testFile(\"child.gradle\").write(\"createTask('do-stuff')\");\n\n        inTestDirectory().runTasks(\"do-stuff\").assertTasksExecuted(\":child1:do-stuff\", \":child2:do-stuff\");\n    }","id":32018,"modified_method":"@Test\n    public void multiProjectBuildCanHaveSeveralProjectsWithSameBuildFile() {\n        testFile(\"settings.gradle\").writelns(\n            \"include 'child1', 'child2'\",\n            \"project(':child1').buildFileName = '../child.gradle'\",\n            \"project(':child2').buildFileName = '../child.gradle'\"\n        );\n        testFile(\"child.gradle\").write(\"createTask('do-stuff')\");\n\n        inTestDirectory().withTasks(\"do-stuff\").run().assertTasksExecuted(\":child1:do-stuff\", \":child2:do-stuff\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void ignoresMultiProjectBuildInParentDirectoryWhichDoesNotMeetDefaultProjectCriteria() {\n        testFile(\"settings.gradle\").write(\"include 'another'\");\n        testFile(\"gradle.properties\").writelns(\"prop=value2\", \"otherProp=value\");\n\n        File subDirectory = new File(getTestDir(), \"subdirectory\");\n        TestFile buildFile = testFile(subDirectory, \"build.gradle\");\n        buildFile.writelns(\"createTask('do-stuff') {\",\n                \"assertThat(prop, equalTo('value'))\",\n                \"assertTrue(!project.hasProperty('otherProp'))\",\n                \"}\");\n        testFile(\"subdirectory/gradle.properties\").write(\"prop=value\");\n\n        inDirectory(subDirectory).withSearchUpwards().runTasks(\"do-stuff\");\n        usingProjectDir(subDirectory).withSearchUpwards().runTasks(\"do-stuff\");\n        usingBuildFile(buildFile).withSearchUpwards().runTasks(\"do-stuff\");\n    }","id":32019,"modified_method":"@Test\n    public void ignoresMultiProjectBuildInParentDirectoryWhichDoesNotMeetDefaultProjectCriteria() {\n        testFile(\"settings.gradle\").write(\"include 'another'\");\n        testFile(\"gradle.properties\").writelns(\"prop=value2\", \"otherProp=value\");\n\n        File subDirectory = new File(getTestDir(), \"subdirectory\");\n        TestFile buildFile = testFile(subDirectory, \"build.gradle\");\n        buildFile.writelns(\"createTask('do-stuff') {\",\n                \"assertThat(prop, equalTo('value'))\",\n                \"assertTrue(!project.hasProperty('otherProp'))\",\n                \"}\");\n        testFile(\"subdirectory/gradle.properties\").write(\"prop=value\");\n\n        inDirectory(subDirectory).withSearchUpwards().withTasks(\"do-stuff\").run();\n        usingProjectDir(subDirectory).withSearchUpwards().withTasks(\"do-stuff\").run();\n        usingBuildFile(buildFile).withSearchUpwards().withTasks(\"do-stuff\").run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void handlesSimilarlyNamedBuildFilesInSameDirectory() {\n        File buildFile1 = getTestBuildFile(\"similarly-named build.gradle\");\n        File buildFile2 = getTestBuildFile(\"similarly_named_build_gradle\");\n        assertEquals(buildFile1.getParentFile(), buildFile2.getParentFile());\n\n        usingBuildFile(buildFile1).runTasks(\"build\");\n\n        usingBuildFile(buildFile2).runTasks(\"other-build\");\n\n        usingBuildFile(buildFile1).runTasks(\"build\");\n    }","id":32020,"modified_method":"@Test\n    public void handlesSimilarlyNamedBuildFilesInSameDirectory() {\n        File buildFile1 = getTestBuildFile(\"similarly-named build.gradle\");\n        File buildFile2 = getTestBuildFile(\"similarly_named_build_gradle\");\n        assertEquals(buildFile1.getParentFile(), buildFile2.getParentFile());\n\n        usingBuildFile(buildFile1).withTasks(\"build\").run();\n\n        usingBuildFile(buildFile2).withTasks(\"other-build\").run();\n\n        usingBuildFile(buildFile1).withTasks(\"build\").run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void buildFailsWhenSpecifiedSettingsFileDoesNotContainMatchingProject() {\n        TestFile settingsFile = testFile(\"settings.gradle\");\n        settingsFile.write(\"// empty\");\n\n        TestFile projectdir = testFile(\"project dir\");\n        projectdir.asFile().mkdirs();\n\n        GradleExecutionFailure result = usingProjectDir(projectdir).usingSettingsFile(settingsFile).runTasksAndExpectFailure();\n        result.assertContext(startsWith(\"Could not select the default project for this build. No projects in this build have project directory\"));\n    }","id":32021,"modified_method":"@Test\n    public void buildFailsWhenSpecifiedSettingsFileDoesNotContainMatchingProject() {\n        TestFile settingsFile = testFile(\"settings.gradle\");\n        settingsFile.write(\"// empty\");\n\n        TestFile projectdir = testFile(\"project dir\");\n        projectdir.asFile().mkdirs();\n\n        ExecutionFailure result = usingProjectDir(projectdir).usingSettingsFile(settingsFile).runWithFailure();\n        result.assertContext(startsWith(\"Could not select the default project for this build. No projects in this build have project directory\"));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void explicitBuildFileTakesPrecedenceOverSettingsFileInSameDirectory() {\n        testFile(\"settings.gradle\").write(\"rootProject.buildFileName = 'root.gradle'\");\n        testFile(\"root.gradle\").write(\"throw new RuntimeException()\");\n\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.write(\"createTask('do-stuff')\");\n\n        usingBuildFile(buildFile).runTasks(\"do-stuff\");\n    }","id":32022,"modified_method":"@Test\n    public void explicitBuildFileTakesPrecedenceOverSettingsFileInSameDirectory() {\n        testFile(\"settings.gradle\").write(\"rootProject.buildFileName = 'root.gradle'\");\n        testFile(\"root.gradle\").write(\"throw new RuntimeException()\");\n\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.write(\"createTask('do-stuff')\");\n\n        usingBuildFile(buildFile).withTasks(\"do-stuff\").run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void canDetermineRootProjectAndDefaultProjectBasedOnCurrentDirectory() {\n        File rootDir = getTestDir();\n        File childDir = new File(rootDir, \"child\");\n\n        testFile(\"settings.gradle\").write(\"include('child')\");\n        testFile(\"build.gradle\").write(\"createTask('do-stuff')\");\n        testFile(\"child/build.gradle\").write(\"createTask('do-stuff')\");\n\n        inDirectory(rootDir).withSearchUpwards().runTasks(\"do-stuff\").assertTasksExecuted(\":do-stuff\", \":child:do-stuff\");\n        inDirectory(rootDir).withSearchUpwards().runTasks(\":do-stuff\").assertTasksExecuted(\":do-stuff\");\n\n        inDirectory(childDir).withSearchUpwards().runTasks(\"do-stuff\").assertTasksExecuted(\":child:do-stuff\");\n        inDirectory(childDir).withSearchUpwards().runTasks(\":do-stuff\").assertTasksExecuted(\":do-stuff\");\n    }","id":32023,"modified_method":"@Test\n    public void canDetermineRootProjectAndDefaultProjectBasedOnCurrentDirectory() {\n        File rootDir = getTestDir();\n        File childDir = new File(rootDir, \"child\");\n\n        testFile(\"settings.gradle\").write(\"include('child')\");\n        testFile(\"build.gradle\").write(\"createTask('do-stuff')\");\n        testFile(\"child/build.gradle\").write(\"createTask('do-stuff')\");\n\n        inDirectory(rootDir).withSearchUpwards().withTasks(\"do-stuff\").run().assertTasksExecuted(\":do-stuff\", \":child:do-stuff\");\n        inDirectory(rootDir).withSearchUpwards().withTasks(\":do-stuff\").run().assertTasksExecuted(\":do-stuff\");\n\n        inDirectory(childDir).withSearchUpwards().withTasks(\"do-stuff\").run().assertTasksExecuted(\":child:do-stuff\");\n        inDirectory(childDir).withSearchUpwards().withTasks(\":do-stuff\").run().assertTasksExecuted(\":do-stuff\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void multiProjectBuildCanHaveSettingsFileAndRootBuildFileInSubDir() {\n        File buildFilesDir = new File(getTestDir(), \"root\");\n        TestFile settingsFile = testFile(buildFilesDir, \"settings.gradle\");\n        settingsFile.writelns(\n            \"includeFlat 'child'\",\n            \"rootProject.projectDir = new File(settingsDir, '..')\",\n            \"rootProject.buildFileName = 'root/build.gradle'\"\n        );\n\n        TestFile rootBuildFile = testFile(buildFilesDir, \"build.gradle\");\n        rootBuildFile.write(\"createTask('do-stuff', dependsOn: ':child:task')\");\n\n        TestFile childBuildFile = testFile(\"child/build.gradle\");\n        childBuildFile.writelns(\n            \"createTask('do-stuff')\",\n            \"createTask('task')\"\n        );\n\n        usingProjectDir(getTestDir()).usingSettingsFile(settingsFile).runTasks(\"do-stuff\").assertTasksExecuted(\":child:task\", \":do-stuff\", \":child:do-stuff\");\n        usingBuildFile(rootBuildFile).runTasks(\"do-stuff\").assertTasksExecuted(\":child:task\", \":do-stuff\", \":child:do-stuff\");\n        usingBuildFile(childBuildFile).usingSettingsFile(settingsFile).runTasks(\"do-stuff\").assertTasksExecuted(\":child:do-stuff\");\n    }","id":32024,"modified_method":"@Test\n    public void multiProjectBuildCanHaveSettingsFileAndRootBuildFileInSubDir() {\n        File buildFilesDir = new File(getTestDir(), \"root\");\n        TestFile settingsFile = testFile(buildFilesDir, \"settings.gradle\");\n        settingsFile.writelns(\n            \"includeFlat 'child'\",\n            \"rootProject.projectDir = new File(settingsDir, '..')\",\n            \"rootProject.buildFileName = 'root/build.gradle'\"\n        );\n\n        TestFile rootBuildFile = testFile(buildFilesDir, \"build.gradle\");\n        rootBuildFile.write(\"createTask('do-stuff', dependsOn: ':child:task')\");\n\n        TestFile childBuildFile = testFile(\"child/build.gradle\");\n        childBuildFile.writelns(\n            \"createTask('do-stuff')\",\n            \"createTask('task')\"\n        );\n\n        usingProjectDir(getTestDir()).usingSettingsFile(settingsFile).withTasks(\"do-stuff\").run().assertTasksExecuted(\":child:task\", \":do-stuff\", \":child:do-stuff\");\n        usingBuildFile(rootBuildFile).withTasks(\"do-stuff\").run().assertTasksExecuted(\":child:task\", \":do-stuff\", \":child:do-stuff\");\n        usingBuildFile(childBuildFile).usingSettingsFile(settingsFile).withTasks(\"do-stuff\").run().assertTasksExecuted(\":child:do-stuff\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void buildFailsWhenSpecifiedBuildFileIsNotAFile() {\n        GradleExecutionFailure result = usingBuildFile(testFile(\"unknown build file\")).runTasksAndExpectFailure();\n        result.assertContext(startsWith(\"Build file\"));\n        result.assertContext(endsWith(\"does not exist.\"));\n    }","id":32025,"modified_method":"@Test\n    public void buildFailsWhenSpecifiedBuildFileIsNotAFile() {\n        ExecutionFailure result = usingBuildFile(testFile(\"unknown build file\")).runWithFailure();\n        result.assertContext(startsWith(\"Build file\"));\n        result.assertContext(endsWith(\"does not exist.\"));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void buildFailsWhenSpecifiedSettingsFileIsNotAFile() {\n        GradleExecutionFailure result = inTestDirectory().usingSettingsFile(testFile(\"unknown\")).runTasksAndExpectFailure();\n        result.assertDescription(startsWith(\"Cannot read settings file\"));\n        result.assertDescription(endsWith(\"as it does not exist.\"));\n    }","id":32026,"modified_method":"@Test\n    public void buildFailsWhenSpecifiedSettingsFileIsNotAFile() {\n        ExecutionFailure result = inTestDirectory().usingSettingsFile(testFile(\"unknown\")).runWithFailure();\n        result.assertDescription(startsWith(\"Cannot read settings file\"));\n        result.assertDescription(endsWith(\"as it does not exist.\"));\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void handlesWhitespaceOnlySettingsAndBuildFiles() {\n        testFile(\"settings.gradle\").write(\"   \\n  \");\n        testFile(\"build.gradle\").write(\"   \");\n        inTestDirectory().showTaskList();\n    }","id":32027,"modified_method":"@Test\n    public void handlesWhitespaceOnlySettingsAndBuildFiles() {\n        testFile(\"settings.gradle\").write(\"   \\n  \");\n        testFile(\"build.gradle\").write(\"   \");\n        inTestDirectory().withTaskList().run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void embeddedBuildFileIgnoresBuildAndScriptFiles() {\n        File rootDir = getTestDir();\n        testFile(\"settings.gradle\").write(\"throw new RuntimeException()\");\n        testFile(\"build.gradle\").write(\"throw new RuntimeException()\");\n        inDirectory(rootDir).usingBuildScript(\"Task task = createTask('do-stuff')\").runTasks(\"do-stuff\");\n    }","id":32028,"modified_method":"@Test\n    public void embeddedBuildFileIgnoresBuildAndScriptFiles() {\n        File rootDir = getTestDir();\n        testFile(\"settings.gradle\").write(\"throw new RuntimeException()\");\n        testFile(\"build.gradle\").write(\"throw new RuntimeException()\");\n        inDirectory(rootDir).usingBuildScript(\"Task task = createTask('do-stuff')\").withTasks(\"do-stuff\").run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void settingsFileTakesPrecedenceOverBuildFileInSameDirectory() {\n        testFile(\"settings.gradle\").write(\"rootProject.buildFileName = 'root.gradle'\");\n        testFile(\"root.gradle\").write(\"createTask('do-stuff')\");\n        \n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.write(\"throw new RuntimeException()\");\n\n        inTestDirectory().runTasks(\"do-stuff\");\n        usingProjectDir(getTestDir()).runTasks(\"do-stuff\");\n    }","id":32029,"modified_method":"@Test\n    public void settingsFileTakesPrecedenceOverBuildFileInSameDirectory() {\n        testFile(\"settings.gradle\").write(\"rootProject.buildFileName = 'root.gradle'\");\n        testFile(\"root.gradle\").write(\"createTask('do-stuff')\");\n        \n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.write(\"throw new RuntimeException()\");\n\n        inTestDirectory().withTasks(\"do-stuff\").run();\n        usingProjectDir(getTestDir()).withTasks(\"do-stuff\").run();\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void reportsSettingsScriptEvaluationFailsWithRuntimeException() throws IOException {\n        TestFile buildFile = testFile(\"some build.gradle\");\n        TestFile settingsFile = testFile(\"some settings.gradle\");\n        settingsFile.writelns(\"\", \"\", \"throw new RuntimeException('<failure message>')\");\n\n        GradleExecutionFailure failure = usingBuildFile(buildFile).usingSettingsFile(settingsFile)\n                .runTasksAndExpectFailure(\"do-stuff\");\n\n        failure.assertHasFileName(String.format(\"Settings file '%s'\", settingsFile));\n        failure.assertHasLineNumber(3);\n        failure.assertHasContext(\"A problem occurred evaluating the settings file.\");\n        failure.assertHasDescription(\"<failure message>\");\n    }","id":32030,"modified_method":"@Test\n    public void reportsSettingsScriptEvaluationFailsWithRuntimeException() throws IOException {\n        TestFile buildFile = testFile(\"some build.gradle\");\n        TestFile settingsFile = testFile(\"some settings.gradle\");\n        settingsFile.writelns(\"\", \"\", \"throw new RuntimeException('<failure message>')\");\n\n        ExecutionFailure failure = usingBuildFile(buildFile).usingSettingsFile(settingsFile).withTasks(\"do-stuff\")\n                .runWithFailure();\n\n        failure.assertHasFileName(String.format(\"Settings file '%s'\", settingsFile));\n        failure.assertHasLineNumber(3);\n        failure.assertHasContext(\"A problem occurred evaluating the settings file.\");\n        failure.assertHasDescription(\"<failure message>\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void executesAllTasksInASingleBuildAndEachTaskAtMostOnce() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"build.taskGraph.whenReady { assertFalse(project.hasProperty('graphReady')); graphReady = true }\",\n                \"createTask('a') { task -> project.executedA = task }\",\n                \"createTask('b') { \",\n                \"    assertSame(a, project.executedA);\",\n                \"    assertTrue(build.taskGraph.hasTask(':a'))\",\n                \"}\",\n                \"createTask('c', dependsOn: 'a')\",\n                \"createTask('d', dependsOn: 'a')\",\n                \"createTask('e', dependsOn: ['a', 'd'])\"\n                );\n        usingBuildFile(buildFile).runTasks(\"a\", \"b\").assertTasksExecuted(\":a\", \":b\");\n        usingBuildFile(buildFile).runTasks(\"a\", \"a\").assertTasksExecuted(\":a\");\n        usingBuildFile(buildFile).runTasks(\"c\", \"a\").assertTasksExecuted(\":a\", \":c\");\n        usingBuildFile(buildFile).runTasks(\"c\", \"e\").assertTasksExecuted(\":a\", \":c\", \":d\", \":e\");\n    }","id":32031,"modified_method":"@Test\n    public void executesAllTasksInASingleBuildAndEachTaskAtMostOnce() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"build.taskGraph.whenReady { assertFalse(project.hasProperty('graphReady')); graphReady = true }\",\n                \"createTask('a') { task -> project.executedA = task }\",\n                \"createTask('b') { \",\n                \"    assertSame(a, project.executedA);\",\n                \"    assertTrue(build.taskGraph.hasTask(':a'))\",\n                \"}\",\n                \"createTask('c', dependsOn: 'a')\",\n                \"createTask('d', dependsOn: 'a')\",\n                \"createTask('e', dependsOn: ['a', 'd'])\"\n                );\n        usingBuildFile(buildFile).withTasks(\"a\", \"b\").run().assertTasksExecuted(\":a\", \":b\");\n        usingBuildFile(buildFile).withTasks(\"a\", \"a\").run().assertTasksExecuted(\":a\");\n        usingBuildFile(buildFile).withTasks(\"c\", \"a\").run().assertTasksExecuted(\":a\", \":c\");\n        usingBuildFile(buildFile).withTasks(\"c\", \"e\").run().assertTasksExecuted(\":a\", \":c\", \":d\", \":e\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void executesMultiProjectsTasksInASingleBuildAndEachTaskAtMostOnce() {\n        testFile(\"settings.gradle\").writelns(\"include 'child1', 'child2'\");\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"createTask('a')\",\n                \"allprojects {\",\n                \"    createTask('b')\",\n                \"    createTask('c', dependsOn: ['b', ':a'])\",\n                \"}\"\n                );\n        usingBuildFile(buildFile).runTasks(\"a\", \"c\").assertTasksExecuted(\":a\", \":b\", \":c\", \":child1:b\", \":child1:c\", \":child2:b\", \":child2:c\");\n        usingBuildFile(buildFile).runTasks(\"b\", \":child2:c\").assertTasksExecuted(\":b\", \":child1:b\", \":child2:b\", \":a\", \":child2:c\");\n    }","id":32032,"modified_method":"@Test\n    public void executesMultiProjectsTasksInASingleBuildAndEachTaskAtMostOnce() {\n        testFile(\"settings.gradle\").writelns(\"include 'child1', 'child2'\");\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"createTask('a')\",\n                \"allprojects {\",\n                \"    createTask('b')\",\n                \"    createTask('c', dependsOn: ['b', ':a'])\",\n                \"}\"\n                );\n        usingBuildFile(buildFile).withTasks(\"a\", \"c\").run().assertTasksExecuted(\":a\", \":b\", \":c\", \":child1:b\", \":child1:c\", \":child2:b\", \":child2:c\");\n        usingBuildFile(buildFile).withTasks(\"b\", \":child2:c\").run().assertTasksExecuted(\":b\", \":child1:b\", \":child2:b\", \":a\", \":child2:c\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void executesMultiProjectDefaultTasksInASingleBuildAndEachTaskAtMostOnce() {\n        testFile(\"settings.gradle\").writelns(\"include 'child1', 'child2'\");\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"defaultTasks 'a', 'b'\",\n                \"createTask('a')\",\n                \"subprojects {\",\n                \"    createTask('a', dependsOn: ':a')\",\n                \"    createTask('b', dependsOn: ':a')\",\n                \"}\"\n                );\n        usingBuildFile(buildFile).runTasks().assertTasksExecuted(\":a\", \":child1:a\", \":child2:a\", \":child1:b\", \":child2:b\");\n    }","id":32033,"modified_method":"@Test\n    public void executesMultiProjectDefaultTasksInASingleBuildAndEachTaskAtMostOnce() {\n        testFile(\"settings.gradle\").writelns(\"include 'child1', 'child2'\");\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"defaultTasks 'a', 'b'\",\n                \"createTask('a')\",\n                \"subprojects {\",\n                \"    createTask('a', dependsOn: ':a')\",\n                \"    createTask('b', dependsOn: ':a')\",\n                \"}\"\n                );\n        usingBuildFile(buildFile).run().assertTasksExecuted(\":a\", \":child1:a\", \":child2:a\", \":child1:b\", \":child2:b\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void taskCanAccessTaskGraph() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"import org.gradle.integtests.TaskExecutionIntegrationTest\",\n                \"createTask('a', dependsOn: 'b') { task ->\",\n                \"    assertTrue(build.taskGraph.hasTask(task))\",\n                \"    assertTrue(build.taskGraph.hasTask(':a'))\",\n                \"    assertTrue(build.taskGraph.hasTask(a))\",\n                \"    assertTrue(build.taskGraph.hasTask(':b'))\",\n                \"    assertTrue(build.taskGraph.hasTask(b))\",\n                \"    assertTrue(build.taskGraph.allTasks.contains(task))\",\n                \"    assertTrue(build.taskGraph.allTasks.contains(project.task('b')))\",\n                \"}\",\n                \"createTask('b')\",\n                \"build.taskGraph.whenReady { graph ->\",\n                \"    assertTrue(graph.hasTask(':a'))\",\n                \"    assertTrue(graph.hasTask(a))\",\n                \"    assertTrue(graph.hasTask(':b'))\",\n                \"    assertTrue(graph.hasTask(b))\",\n                \"    assertTrue(graph.allTasks.contains(a))\",\n                \"    assertTrue(graph.allTasks.contains(b))\",\n                \"    TaskExecutionIntegrationTest.graphListenerNotified = true\",\n                \"}\"\n        );\n        usingBuildFile(buildFile).runTasks(\"a\").assertTasksExecuted(\":b\", \":a\");\n\n        assertTrue(graphListenerNotified);\n    }","id":32034,"modified_method":"@Test\n    public void taskCanAccessTaskGraph() {\n        TestFile buildFile = testFile(\"build.gradle\");\n        buildFile.writelns(\n                \"import org.gradle.integtests.TaskExecutionIntegrationTest\",\n                \"createTask('a', dependsOn: 'b') { task ->\",\n                \"    assertTrue(build.taskGraph.hasTask(task))\",\n                \"    assertTrue(build.taskGraph.hasTask(':a'))\",\n                \"    assertTrue(build.taskGraph.hasTask(a))\",\n                \"    assertTrue(build.taskGraph.hasTask(':b'))\",\n                \"    assertTrue(build.taskGraph.hasTask(b))\",\n                \"    assertTrue(build.taskGraph.allTasks.contains(task))\",\n                \"    assertTrue(build.taskGraph.allTasks.contains(project.task('b')))\",\n                \"}\",\n                \"createTask('b')\",\n                \"build.taskGraph.whenReady { graph ->\",\n                \"    assertTrue(graph.hasTask(':a'))\",\n                \"    assertTrue(graph.hasTask(a))\",\n                \"    assertTrue(graph.hasTask(':b'))\",\n                \"    assertTrue(graph.hasTask(b))\",\n                \"    assertTrue(graph.allTasks.contains(a))\",\n                \"    assertTrue(graph.allTasks.contains(b))\",\n                \"    TaskExecutionIntegrationTest.graphListenerNotified = true\",\n                \"}\"\n        );\n        usingBuildFile(buildFile).withTasks(\"a\").run().assertTasksExecuted(\":b\", \":a\");\n\n        assertTrue(graphListenerNotified);\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"@Test @Ignore\n    public void archiveWithImplicitAndExplicitDependencies() {\n        testFile(\"settings.gradle\").write(\"include ('a', 'b')\");\n        testFile(\"a/build.gradle\").writelns(\n                \"dependsOn(':b')\",\n                \"createTask('libs', type: org.gradle.api.tasks.bundling.Bundle)\",\n                // todo - should not have to do these next 2 lines\n                \"version = 'none'\",\n                \"libs.defaultArchiveTypes = org.gradle.api.plugins.JavaPluginConvention.DEFAULT_ARCHIVE_TYPES\",\n                \"libs {\",\n                \"    zip() {\",\n                \"        destinationDir = file('something.zip')\",\n                \"        files(file('src'))\",\n                \"    }\",\n                \"}\",\n                \"libs.dependsOn('compile')\",\n                \"createTask('compile')\"\n        );\n        testFile(\"b/build.gradle\").writelns(\n                \"createTask('libs')\",\n                \"createTask('archive_zip')\"\n        );\n\n        // todo - should archive_zip depend on b:libs, as it is a dependencu of its parent libs task?\n        usingBuildFile(testFile(\"build.gradle\")).runTasks(\"a:archive_zip\").assertTasksExecuted(\":a:compile\", \"b:archive_zip\", \"a:archive_zip\");\n        \n        usingBuildFile(testFile(\"build.gradle\")).runTasks(\"a:libs\").assertTasksExecuted(\":a:compile\", \"b:archive_zip\", \"b:libs\", \"a:archive_zip\");\n    }","id":32035,"modified_method":"@Test @Ignore\n    public void archiveWithImplicitAndExplicitDependencies() {\n        testFile(\"settings.gradle\").write(\"include ('a', 'b')\");\n        testFile(\"a/build.gradle\").writelns(\n                \"dependsOn(':b')\",\n                \"createTask('libs', type: org.gradle.api.tasks.bundling.Bundle)\",\n                // todo - should not have to do these next 2 lines\n                \"version = 'none'\",\n                \"libs.defaultArchiveTypes = org.gradle.api.plugins.JavaPluginConvention.DEFAULT_ARCHIVE_TYPES\",\n                \"libs {\",\n                \"    zip() {\",\n                \"        destinationDir = file('something.zip')\",\n                \"        files(file('src'))\",\n                \"    }\",\n                \"}\",\n                \"libs.dependsOn('compile')\",\n                \"createTask('compile')\"\n        );\n        testFile(\"b/build.gradle\").writelns(\n                \"createTask('libs')\",\n                \"createTask('archive_zip')\"\n        );\n\n        // todo - should archive_zip depend on b:libs, as it is a dependencu of its parent libs task?\n        usingBuildFile(testFile(\"build.gradle\")).withTasks(\"a:archive_zip\").run().assertTasksExecuted(\":a:compile\", \"b:archive_zip\", \"a:archive_zip\");\n\n        usingBuildFile(testFile(\"build.gradle\")).withTasks(\"a:libs\").run().assertTasksExecuted(\":a:compile\", \"b:archive_zip\", \"b:libs\", \"a:archive_zip\");\n    }","commit_id":"0822db78885fbbf6b7316fe4cf401c608c1dc049","url":"https://github.com/gradle/gradle"},{"original_method":"/** Build a single-value Result\n     *  @param s if lower than OK, our status is set to OK */\n    ExecutionResult(final HealthCheckDescriptor healthCheckDescriptor, Result simpleResult,\n            long elapsedTimeInMs) {\n        this.name = healthCheckDescriptor.getName();\n        this.tags = healthCheckDescriptor.getTags();\n        this.resultFromHC = simpleResult;\n        this.finishedAt = new Date();\n        this.elapsedTimeInMs = elapsedTimeInMs;\n        this.serviceId = healthCheckDescriptor.getServiceId();\n    }","id":32036,"modified_method":"/** Build a single-value Result\n     *  @param s if lower than OK, our status is set to OK */\n    ExecutionResult(final HealthCheckMetaData healthCheckDescriptor, Result simpleResult,\n            long elapsedTimeInMs) {\n        this.metaData = healthCheckDescriptor;\n        this.resultFromHC = simpleResult;\n        this.finishedAt = new Date();\n        this.elapsedTimeInMs = elapsedTimeInMs;\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Natural order of results (failed results are sorted before ok results).\n     */\n    @Override\n    public int compareTo(ExecutionResult otherResult) {\n        int retVal = otherResult.getHealthCheckResult().getStatus().compareTo(this.getHealthCheckResult().getStatus());\n        if (retVal == 0) {\n            retVal = Collator.getInstance().compare(getHealthCheckName(), otherResult.getHealthCheckName());\n        }\n        return retVal;\n    }","id":32037,"modified_method":"/**\n     * Natural order of results (failed results are sorted before ok results).\n     */\n    @Override\n    public int compareTo(ExecutionResult otherResult) {\n        int retVal = otherResult.getHealthCheckResult().getStatus().compareTo(this.getHealthCheckResult().getStatus());\n        if (retVal == 0) {\n            retVal = Collator.getInstance().compare(this.getHealthCheckMetaData().getTitle(), otherResult.getHealthCheckMetaData().getTitle());\n        }\n        return retVal;\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public List<String> getHealthCheckTags() {\n        return this.tags;\n    }","id":32038,"modified_method":"@Override\n    public HealthCheckMetaData getHealthCheckMetaData() {\n        return this.metaData;\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"Long getServiceId() {\n        return this.serviceId;\n    }","id":32039,"modified_method":"long getServiceId() {\n        return this.metaData.getServiceId();\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Shortcut constructor to created error result.\n     *\n     * @param healthCheckDescriptor\n     * @param status\n     * @param errorMessage\n     */\n    ExecutionResult(HealthCheckDescriptor healthCheckDescriptor, Result.Status status, String errorMessage) {\n        this(healthCheckDescriptor, new Result(status, errorMessage), 0L);\n    }","id":32040,"modified_method":"/**\n     * Shortcut constructor to created error result.\n     *\n     * @param healthCheckDescriptor\n     * @param status\n     * @param errorMessage\n     */\n    ExecutionResult(HealthCheckMetaData healthCheckDescriptor, Result.Status status, String errorMessage) {\n        this(healthCheckDescriptor, new Result(status, errorMessage), 0L);\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Shortcut constructor to created error result.\n     *\n     * @param healthCheckDescriptor\n     * @param status\n     * @param errorMessage\n     */\n    ExecutionResult(HealthCheckDescriptor healthCheckDescriptor, Result.Status status, String errorMessage, long elapsedTime) {\n        this(healthCheckDescriptor, new Result(status, errorMessage), elapsedTime);\n    }","id":32041,"modified_method":"/**\n     * Shortcut constructor to created error result.\n     *\n     * @param healthCheckDescriptor\n     * @param status\n     * @param errorMessage\n     */\n    ExecutionResult(HealthCheckMetaData healthCheckDescriptor, Result.Status status, String errorMessage, long elapsedTime) {\n        this(healthCheckDescriptor, new Result(status, errorMessage), elapsedTime);\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public String toString() {\n        return \"HealthCheck '\" + name + \"'\";\n    }","id":32042,"modified_method":"@Override\n    public String toString() {\n        return \"HealthCheck '\" + this.metaData.getTitle() + \"'\";\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (serviceId ^ (serviceId >>> 32));\n        return result;\n    }","id":32043,"modified_method":"@Override\n    public int hashCode() {\n        return this.metaData.hashCode();\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"public HealthCheckDescriptor(final ServiceReference healthCheckRef) {\n        if (healthCheckRef == null) {\n            throw new IllegalArgumentException(\"HealthCheck reference must not be null\");\n        }\n        this.serviceReference = healthCheckRef;\n        this.serviceId = (Long) healthCheckRef.getProperty(Constants.SERVICE_ID);\n\n        this.name = getHealthCheckName(healthCheckRef);\n        this.className = (String) healthCheckRef.getProperty(ComponentConstants.COMPONENT_NAME);\n        this.tags = arrayPropertyToListOfStr(healthCheckRef.getProperty(HealthCheck.TAGS));\n    }","id":32044,"modified_method":"public HealthCheckDescriptor(final ServiceReference healthCheckRef) {\n        if (healthCheckRef == null) {\n            throw new IllegalArgumentException(\"HealthCheck reference must not be null\");\n        }\n        this.serviceReference = healthCheckRef;\n        this.metaData = new HealthCheckMetaData(healthCheckRef);\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public boolean equals(final Object obj) {\n        if ( !(obj instanceof HealthCheckDescriptor)) {\n            return false;\n        }\n        final HealthCheckDescriptor other = (HealthCheckDescriptor) obj;\n        return serviceId == other.serviceId;\n    }","id":32045,"modified_method":"@Override\n    public boolean equals(final Object obj) {\n        if ( !(obj instanceof HealthCheckDescriptor)) {\n            return false;\n        }\n        final HealthCheckDescriptor other = (HealthCheckDescriptor) obj;\n        return this.metaData.equals(other.metaData);\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"void collectResultsFromFutures(List<HealthCheckFuture> futuresForResultOfThisCall, Collection<HealthCheckExecutionResult> results) {\n\n        Set<ExecutionResult> resultsFromFutures = new HashSet<ExecutionResult>();\n\n        Iterator<HealthCheckFuture> futuresIt = futuresForResultOfThisCall.iterator();\n        while (futuresIt.hasNext()) {\n            HealthCheckFuture future = futuresIt.next();\n            ExecutionResult result;\n            if (future.isDone()) {\n                logger.debug(\"Health Check is done: {}\", future.getHealthCheckDescriptor());\n\n                try {\n                    result = future.get();\n                } catch (Exception e) {\n                    logger.warn(\"Unexpected Exception during future.get(): \" + e, e);\n                    result = new ExecutionResult(future.getHealthCheckDescriptor(), Result.Status.HEALTH_CHECK_ERROR,\n                            \"Unexpected Exception during future.get(): \" + e);\n                }\n\n                // if the future came from a previous call remove it from stillRunningFutures\n                if (this.stillRunningFutures.containsKey(future.getHealthCheckDescriptor())) {\n                    this.stillRunningFutures.remove(future.getHealthCheckDescriptor());\n                }\n\n            } else {\n                logger.debug(\"Health Check timed out: {}\", future.getHealthCheckDescriptor());\n                // Futures must not be cancelled as interrupting a health check might could cause a corrupted repository index\n                // (CrxRoundtripCheck) or ugly messages/stack traces in the log file\n\n                this.stillRunningFutures.put(future.getHealthCheckDescriptor(), future);\n\n                // normally we turn the check into WARN (normal timeout), but if the threshold time for CRITICAL is reached for a certain\n                // future we turn the result CRITICAL\n                long futureElapsedTimeMs = new Date().getTime() - future.getCreatedTime().getTime();\n                if (futureElapsedTimeMs < this.longRunningFutureThresholdForRedMs) {\n                    result = new ExecutionResult(future.getHealthCheckDescriptor(), Result.Status.WARN,\n                            \"Timeout: Check still running after \" + msHumanReadable(futureElapsedTimeMs), futureElapsedTimeMs);\n\n                } else {\n                    result = new ExecutionResult(future.getHealthCheckDescriptor(), Result.Status.CRITICAL,\n                            \"Timeout: Check still running after \" + msHumanReadable(futureElapsedTimeMs)\n                                    + \" (exceeding the configured threshold for CRITICAL: \"\n                                    + msHumanReadable(this.longRunningFutureThresholdForRedMs) + \")\", futureElapsedTimeMs);\n                }\n            }\n            resultsFromFutures.add(result);\n            futuresIt.remove();\n        }\n\n        logger.debug(\"Adding {} results from futures\", resultsFromFutures.size());\n        results.addAll(resultsFromFutures);\n    }","id":32046,"modified_method":"void collectResultsFromFutures(List<HealthCheckFuture> futuresForResultOfThisCall, Collection<HealthCheckExecutionResult> results) {\n\n        Set<ExecutionResult> resultsFromFutures = new HashSet<ExecutionResult>();\n\n        Iterator<HealthCheckFuture> futuresIt = futuresForResultOfThisCall.iterator();\n        while (futuresIt.hasNext()) {\n            HealthCheckFuture future = futuresIt.next();\n            ExecutionResult result;\n            if (future.isDone()) {\n                logger.debug(\"Health Check is done: {}\", future.getHealthCheckDescriptor());\n\n                try {\n                    result = future.get();\n                } catch (Exception e) {\n                    logger.warn(\"Unexpected Exception during future.get(): \" + e, e);\n                    result = new ExecutionResult(future.getHealthCheckDescriptor().getMetaData(), Result.Status.HEALTH_CHECK_ERROR,\n                            \"Unexpected Exception during future.get(): \" + e);\n                }\n\n                // if the future came from a previous call remove it from stillRunningFutures\n                if (this.stillRunningFutures.containsKey(future.getHealthCheckDescriptor())) {\n                    this.stillRunningFutures.remove(future.getHealthCheckDescriptor());\n                }\n\n            } else {\n                logger.debug(\"Health Check timed out: {}\", future.getHealthCheckDescriptor());\n                // Futures must not be cancelled as interrupting a health check might could cause a corrupted repository index\n                // (CrxRoundtripCheck) or ugly messages/stack traces in the log file\n\n                this.stillRunningFutures.put(future.getHealthCheckDescriptor(), future);\n\n                // normally we turn the check into WARN (normal timeout), but if the threshold time for CRITICAL is reached for a certain\n                // future we turn the result CRITICAL\n                long futureElapsedTimeMs = new Date().getTime() - future.getCreatedTime().getTime();\n                if (futureElapsedTimeMs < this.longRunningFutureThresholdForRedMs) {\n                    result = new ExecutionResult(future.getHealthCheckDescriptor().getMetaData(), Result.Status.WARN,\n                            \"Timeout: Check still running after \" + msHumanReadable(futureElapsedTimeMs), futureElapsedTimeMs);\n\n                } else {\n                    result = new ExecutionResult(future.getHealthCheckDescriptor().getMetaData(), Result.Status.CRITICAL,\n                            \"Timeout: Check still running after \" + msHumanReadable(futureElapsedTimeMs)\n                                    + \" (exceeding the configured threshold for CRITICAL: \"\n                                    + msHumanReadable(this.longRunningFutureThresholdForRedMs) + \")\", futureElapsedTimeMs);\n                }\n            }\n            resultsFromFutures.add(result);\n            futuresIt.remove();\n        }\n\n        logger.debug(\"Adding {} results from futures\", resultsFromFutures.size());\n        results.addAll(resultsFromFutures);\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"public void setLongRunningFutureThresholdForRedMs(Long longRunningFutureThresholdForRedMs) {\n        this.longRunningFutureThresholdForRedMs = longRunningFutureThresholdForRedMs;\n    }","id":32047,"modified_method":"public void setLongRunningFutureThresholdForRedMs(\n            final long longRunningFutureThresholdForRedMs) {\n        this.longRunningFutureThresholdForRedMs = longRunningFutureThresholdForRedMs;\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"private List<HealthCheckDescriptor> getHealthCheckDescriptors(final ServiceReference... healthCheckReferences) {\n        final List<HealthCheckDescriptor> descriptors = new LinkedList<HealthCheckDescriptor>();\n        for (ServiceReference serviceReference : healthCheckReferences) {\n            HealthCheckDescriptor descriptor = new HealthCheckDescriptor(serviceReference);\n\n            if (ArrayUtils.contains(this.disabledChecks, descriptor.getClassName())) {\n                logger.debug(\"Skipping check {} because it is disabled in OSGi configuration\", descriptor);\n                continue;\n            }\n\n            descriptors.add(descriptor);\n        }\n\n        return descriptors;\n    }","id":32048,"modified_method":"private List<HealthCheckDescriptor> getHealthCheckDescriptors(final ServiceReference... healthCheckReferences) {\n        final List<HealthCheckDescriptor> descriptors = new LinkedList<HealthCheckDescriptor>();\n        for (ServiceReference serviceReference : healthCheckReferences) {\n            HealthCheckDescriptor descriptor = new HealthCheckDescriptor(serviceReference);\n\n            descriptors.add(descriptor);\n        }\n\n        return descriptors;\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"void setTimeoutInMs(final Long timeoutInMs) {\n        this.timeoutInMs = timeoutInMs;\n    }","id":32049,"modified_method":"public void setTimeoutInMs(final long timeoutInMs) {\n        this.timeoutInMs = timeoutInMs;\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"@Before\n    public void setup() {\n        MockitoAnnotations.initMocks(this);\n\n        when(future.getHealthCheckDescriptor()).thenReturn(healthCheckDescriptor);\n        when(healthCheckDescriptor.getName()).thenReturn(\"Test Check\");\n\n        healthCheckExecutorImpl = new HealthCheckExecutorImpl();\n        // 2 sec normal timeout\n        healthCheckExecutorImpl.setTimeoutInMs(2000L);\n        // 10 sec timeout for critical\n        healthCheckExecutorImpl.setLongRunningFutureThresholdForRedMs(10000L);\n    }","id":32050,"modified_method":"@Before\n    public void setup() {\n        MockitoAnnotations.initMocks(this);\n\n        when(future.getHealthCheckDescriptor()).thenReturn(healthCheckDescriptor);\n        when(healthCheckDescriptor.getMetaData()).thenReturn(this.healthCheckMetaData);\n        when(healthCheckMetaData.getTitle()).thenReturn(\"Test Check\");\n\n        healthCheckExecutorImpl = new HealthCheckExecutorImpl();\n        // 2 sec normal timeout\n        healthCheckExecutorImpl.setTimeoutInMs(2000L);\n        // 10 sec timeout for critical\n        healthCheckExecutorImpl.setLongRunningFutureThresholdForRedMs(10000L);\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testCollectResultsFromFutures() throws Exception {\n\n        List<HealthCheckFuture> futures = new LinkedList<HealthCheckFuture>();\n        futures.add(future);\n        Collection<HealthCheckExecutionResult> results = new TreeSet<HealthCheckExecutionResult>();\n\n        when(future.isDone()).thenReturn(true);\n        ExecutionResult testResult = new ExecutionResult(healthCheckDescriptor, new Result(Result.Status.OK, \"test\"), 10L);\n        when(future.get()).thenReturn(testResult);\n\n        healthCheckExecutorImpl.collectResultsFromFutures(futures, results);\n\n        verify(future, times(1)).get();\n\n        assertEquals(1, results.size());\n        assertTrue(results.contains(testResult));\n\n    }","id":32051,"modified_method":"@Test\n    public void testCollectResultsFromFutures() throws Exception {\n\n        List<HealthCheckFuture> futures = new LinkedList<HealthCheckFuture>();\n        futures.add(future);\n        Collection<HealthCheckExecutionResult> results = new TreeSet<HealthCheckExecutionResult>();\n\n        when(future.isDone()).thenReturn(true);\n        ExecutionResult testResult = new ExecutionResult(healthCheckDescriptor.getMetaData(), new Result(Result.Status.OK, \"test\"), 10L);\n        when(future.get()).thenReturn(testResult);\n\n        healthCheckExecutorImpl.collectResultsFromFutures(futures, results);\n\n        verify(future, times(1)).get();\n\n        assertEquals(1, results.size());\n        assertTrue(results.contains(testResult));\n\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"HealthCheckFuture(final HealthCheckDescriptor healthCheckDescriptor, final BundleContext bundleContext) {\n        super(new Callable<ExecutionResult>() {\n            @Override\n            public ExecutionResult call() throws Exception {\n                Thread.currentThread().setName(\n                        \"Health-Check-\" + StringUtils.substringAfterLast(healthCheckDescriptor.getClassName(), \".\"));\n                LOG.debug(\"Starting check {}\", healthCheckDescriptor);\n\n                StopWatch stopWatch = new StopWatch();\n                stopWatch.start();\n                Result resultFromHealthCheck = null;\n                ExecutionResult executionResult = null;\n\n                final HealthCheck healthCheck = (HealthCheck) bundleContext.getService(healthCheckDescriptor.getServiceReference());\n\n                try {\n                    if (healthCheck != null) {\n                        resultFromHealthCheck = healthCheck.execute();\n                    } else {\n                        throw new IllegalStateException(\"Service for \" + healthCheckDescriptor + \" is gone\");\n                    }\n\n                } catch (Exception e) {\n                    resultFromHealthCheck = new Result(Result.Status.CRITICAL, \"Exception during execution of \" + this + \": \" + e);\n                    // TODO ResultLog should be improved to be able to store exceptions\n                } finally {\n                    // unget service ref\n                    bundleContext.ungetService(healthCheckDescriptor.getServiceReference());\n\n                    // update result with information about this run\n                    stopWatch.stop();\n                    long elapsedTime = stopWatch.getTime();\n                    if (resultFromHealthCheck != null) {\n                        // wrap the result in an execution result\n                        executionResult = new ExecutionResult(healthCheckDescriptor, resultFromHealthCheck, elapsedTime);\n                    }\n                    LOG.debug(\"Time consumed for {}: {}\", healthCheckDescriptor, HealthCheckExecutorImpl.msHumanReadable(elapsedTime));\n                }\n\n                Thread.currentThread().setName(\"Health-Check-idle\");\n                return executionResult;\n            }\n        });\n        this.createdTime = new Date();\n        this.healthCheckDescriptor = healthCheckDescriptor;\n\n    }","id":32052,"modified_method":"HealthCheckFuture(final HealthCheckDescriptor healthCheckDescriptor, final BundleContext bundleContext) {\n        super(new Callable<ExecutionResult>() {\n            @Override\n            public ExecutionResult call() throws Exception {\n                Thread.currentThread().setName(\n                        \"Health-Check-\" + StringUtils.substringAfterLast(healthCheckDescriptor.getMetaData().getTitle(), \".\"));\n                LOG.debug(\"Starting check {}\", healthCheckDescriptor);\n\n                StopWatch stopWatch = new StopWatch();\n                stopWatch.start();\n                Result resultFromHealthCheck = null;\n                ExecutionResult executionResult = null;\n\n                final HealthCheck healthCheck = (HealthCheck) bundleContext.getService(healthCheckDescriptor.getServiceReference());\n\n                try {\n                    if (healthCheck != null) {\n                        resultFromHealthCheck = healthCheck.execute();\n                    } else {\n                        throw new IllegalStateException(\"Service for \" + healthCheckDescriptor + \" is gone\");\n                    }\n\n                } catch (Exception e) {\n                    resultFromHealthCheck = new Result(Result.Status.CRITICAL, \"Exception during execution of \" + this + \": \" + e);\n                    // TODO ResultLog should be improved to be able to store exceptions\n                } finally {\n                    // unget service ref\n                    bundleContext.ungetService(healthCheckDescriptor.getServiceReference());\n\n                    // update result with information about this run\n                    stopWatch.stop();\n                    long elapsedTime = stopWatch.getTime();\n                    if (resultFromHealthCheck != null) {\n                        // wrap the result in an execution result\n                        executionResult = new ExecutionResult(healthCheckDescriptor.getMetaData(), resultFromHealthCheck, elapsedTime);\n                    }\n                    LOG.debug(\"Time consumed for {}: {}\", healthCheckDescriptor, HealthCheckExecutorImpl.msHumanReadable(elapsedTime));\n                }\n\n                Thread.currentThread().setName(\"Health-Check-idle\");\n                return executionResult;\n            }\n        });\n        this.createdTime = new Date();\n        this.healthCheckDescriptor = healthCheckDescriptor;\n\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"private HealthCheckExecutionResult get(final HealthCheckDescriptor healthCheckDescriptor, final long resultCacheTtlInMs) {\n        final Long key = healthCheckDescriptor.getServiceId();\n        final HealthCheckExecutionResult cachedResult = cache.get(key);\n        if (cachedResult != null) {\n            Date finishedAt = cachedResult.getFinishedAt();\n            if (finishedAt == null) {\n                // never cache without proper meta data -> remove it\n                cache.remove(key);\n                return null;\n            }\n\n            // Option: add resultCacheTtlInMs as property to health check to make it configurable per check\n            Date validUntil = new Date(finishedAt.getTime() + resultCacheTtlInMs);\n            Date now = new Date();\n            if (validUntil.after(now)) {\n                logger.debug(\"Cache hit: validUntil={} cachedResult={}\", validUntil, cachedResult);\n                return cachedResult;\n            } else {\n                logger.debug(\"Outdated result: validUntil={} cachedResult={}\", validUntil, cachedResult);\n                cache.remove(key);\n            }\n        }\n\n        // null => no cache hit\n        return null;\n    }","id":32053,"modified_method":"private HealthCheckExecutionResult get(final HealthCheckDescriptor healthCheckDescriptor, final long resultCacheTtlInMs) {\n        final Long key = healthCheckDescriptor.getMetaData().getServiceId();\n        final HealthCheckExecutionResult cachedResult = cache.get(key);\n        if (cachedResult != null) {\n            Date finishedAt = cachedResult.getFinishedAt();\n            if (finishedAt == null) {\n                // never cache without proper meta data -> remove it\n                cache.remove(key);\n                return null;\n            }\n\n            // Option: add resultCacheTtlInMs as property to health check to make it configurable per check\n            Date validUntil = new Date(finishedAt.getTime() + resultCacheTtlInMs);\n            Date now = new Date();\n            if (validUntil.after(now)) {\n                logger.debug(\"Cache hit: validUntil={} cachedResult={}\", validUntil, cachedResult);\n                return cachedResult;\n            } else {\n                logger.debug(\"Outdated result: validUntil={} cachedResult={}\", validUntil, cachedResult);\n                cache.remove(key);\n            }\n        }\n\n        // null => no cache hit\n        return null;\n    }","commit_id":"56cc4a5c53216f4a0f706fb0eb77c72d721e67cf","url":"https://github.com/apache/sling"},{"original_method":"protected void processAnnotations(Set<WebXml> fragments,\n            boolean handlesTypesOnly) {\n        for(WebXml fragment : fragments) {\n            // Only need to scan for @HandlesTypes matches if any of the\n            // following are true:\n            // - it has already been determined only @HandlesTypes is required\n            //   (e.g. main web.xml has metadata-complete=\"true\"\n            // - this fragment is for a container JAR (Servlet 3.1 section 8.1)\n            // - this fragment has metadata-complete=\"true\"\n            boolean htOnly = handlesTypesOnly || !fragment.getWebappJar() ||\n                    fragment.isMetadataComplete();\n\n            WebXml annotations = new WebXml();\n            // no impact on distributable\n            annotations.setDistributable(true);\n            URL url = fragment.getURL();\n            processAnnotationsUrl(url, annotations, htOnly);\n            Set<WebXml> set = new HashSet<>();\n            set.add(annotations);\n            // Merge annotations into fragment - fragment takes priority\n            fragment.merge(set);\n        }\n    }","id":32054,"modified_method":"protected void processAnnotations(Set<WebXml> fragments,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache) {\n        for(WebXml fragment : fragments) {\n            // Only need to scan for @HandlesTypes matches if any of the\n            // following are true:\n            // - it has already been determined only @HandlesTypes is required\n            //   (e.g. main web.xml has metadata-complete=\"true\"\n            // - this fragment is for a container JAR (Servlet 3.1 section 8.1)\n            // - this fragment has metadata-complete=\"true\"\n            boolean htOnly = handlesTypesOnly || !fragment.getWebappJar() ||\n                    fragment.isMetadataComplete();\n\n            WebXml annotations = new WebXml();\n            // no impact on distributable\n            annotations.setDistributable(true);\n            URL url = fragment.getURL();\n            processAnnotationsUrl(url, annotations, htOnly, javaClassCache);\n            Set<WebXml> set = new HashSet<>();\n            set.add(annotations);\n            // Merge annotations into fragment - fragment takes priority\n            fragment.merge(set);\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Scan the web.xml files that apply to the web application and merge them\n     * using the rules defined in the spec. For the global web.xml files,\n     * where there is duplicate configuration, the most specific level wins. ie\n     * an application's web.xml takes precedence over the host level or global\n     * web.xml file.\n     */\n    protected void webConfig() {\n        /*\n         * Anything and everything can override the global and host defaults.\n         * This is implemented in two parts\n         * - Handle as a web fragment that gets added after everything else so\n         *   everything else takes priority\n         * - Mark Servlets as overridable so SCI configuration can replace\n         *   configuration from the defaults\n         */\n\n        /*\n         * The rules for annotation scanning are not as clear-cut as one might\n         * think. Tomcat implements the following process:\n         * - As per SRV.1.6.2, Tomcat will scan for annotations regardless of\n         *   which Servlet spec version is declared in web.xml. The EG has\n         *   confirmed this is the expected behaviour.\n         * - As per http://java.net/jira/browse/SERVLET_SPEC-36, if the main\n         *   web.xml is marked as metadata-complete, JARs are still processed\n         *   for SCIs.\n         * - If metadata-complete=true and an absolute ordering is specified,\n         *   JARs excluded from the ordering are also excluded from the SCI\n         *   processing.\n         * - If an SCI has a @HandlesType annotation then all classes (except\n         *   those in JARs excluded from an absolute ordering) need to be\n         *   scanned to check if they match.\n         */\n        WebXmlParser webXmlParser = new WebXmlParser(context.getXmlNamespaceAware(),\n                context.getXmlValidation(), context.getXmlBlockExternal());\n\n        Set<WebXml> defaults = new HashSet<>();\n        defaults.add(getDefaultWebXmlFragment(webXmlParser));\n\n        WebXml webXml = createWebXml();\n\n        // Parse context level web.xml\n        InputSource contextWebXml = getContextWebXmlSource();\n        if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) {\n            ok = false;\n        }\n\n        ServletContext sContext = context.getServletContext();\n\n        // Ordering is important here\n\n        // Step 1. Identify all the JARs packaged with the application and those\n        // provided by the container. If any of the application JARs have a\n        // web-fragment.xml it will be parsed at this point. web-fragment.xml\n        // files are ignored for container provided JARs.\n        Map<String,WebXml> fragments = processJarsForWebFragments(webXml, webXmlParser);\n\n        // Step 2. Order the fragments.\n        Set<WebXml> orderedFragments = null;\n        orderedFragments =\n                WebXml.orderWebFragments(webXml, fragments, sContext);\n\n        // Step 3. Look for ServletContainerInitializer implementations\n        if (ok) {\n            processServletContainerInitializers();\n        }\n\n        if  (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {\n            // Step 4. Process /WEB-INF/classes for annotations and\n            // @HandlesTypes matches\n            if (ok) {\n                WebResource[] webResources =\n                        context.getResources().listResources(\"/WEB-INF/classes\");\n\n                for (WebResource webResource : webResources) {\n                    processAnnotationsWebResource(webResource, webXml,\n                            webXml.isMetadataComplete());\n                }\n            }\n\n            // Step 5. Process JARs for annotations for annotations and\n            // @HandlesTypes matches - only need to process those fragments we\n            // are going to use (remember orderedFragments includes any\n            // container fragments)\n            if (ok) {\n                processAnnotations(\n                        orderedFragments, webXml.isMetadataComplete());\n            }\n\n            // Cache, if used, is no longer required so clear it\n            javaClassCache.clear();\n        }\n\n        if (!webXml.isMetadataComplete()) {\n            // Step 6. Merge web-fragment.xml files into the main web.xml\n            // file.\n            if (ok) {\n                ok = webXml.merge(orderedFragments);\n            }\n\n            // Step 7. Apply global defaults\n            // Have to merge defaults before JSP conversion since defaults\n            // provide JSP servlet definition.\n            webXml.merge(defaults);\n\n            // Step 8. Convert explicitly mentioned jsps to servlets\n            if (ok) {\n                convertJsps(webXml);\n            }\n\n            // Step 9. Apply merged web.xml to Context\n            if (ok) {\n                configureContext(webXml);\n            }\n        } else {\n            webXml.merge(defaults);\n            convertJsps(webXml);\n            configureContext(webXml);\n        }\n\n        if (context.getLogEffectiveWebXml()) {\n            log.info(\"web.xml:\\n\" + webXml.toXml());\n        }\n\n        // Always need to look for static resources\n        // Step 10. Look for static resources packaged in JARs\n        if (ok) {\n            // Spec does not define an order.\n            // Use ordered JARs followed by remaining JARs\n            Set<WebXml> resourceJars = new LinkedHashSet<>();\n            for (WebXml fragment : orderedFragments) {\n                resourceJars.add(fragment);\n            }\n            for (WebXml fragment : fragments.values()) {\n                if (!resourceJars.contains(fragment)) {\n                    resourceJars.add(fragment);\n                }\n            }\n            processResourceJARs(resourceJars);\n            // See also StandardContext.resourcesStart() for\n            // WEB-INF/classes/META-INF/resources configuration\n        }\n\n        // Step 11. Apply the ServletContainerInitializer config to the\n        // context\n        if (ok) {\n            for (Map.Entry<ServletContainerInitializer,\n                    Set<Class<?>>> entry :\n                        initializerClassMap.entrySet()) {\n                if (entry.getValue().isEmpty()) {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), null);\n                } else {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }","id":32055,"modified_method":"/**\n     * Scan the web.xml files that apply to the web application and merge them\n     * using the rules defined in the spec. For the global web.xml files,\n     * where there is duplicate configuration, the most specific level wins. ie\n     * an application's web.xml takes precedence over the host level or global\n     * web.xml file.\n     */\n    protected void webConfig() {\n        /*\n         * Anything and everything can override the global and host defaults.\n         * This is implemented in two parts\n         * - Handle as a web fragment that gets added after everything else so\n         *   everything else takes priority\n         * - Mark Servlets as overridable so SCI configuration can replace\n         *   configuration from the defaults\n         */\n\n        /*\n         * The rules for annotation scanning are not as clear-cut as one might\n         * think. Tomcat implements the following process:\n         * - As per SRV.1.6.2, Tomcat will scan for annotations regardless of\n         *   which Servlet spec version is declared in web.xml. The EG has\n         *   confirmed this is the expected behaviour.\n         * - As per http://java.net/jira/browse/SERVLET_SPEC-36, if the main\n         *   web.xml is marked as metadata-complete, JARs are still processed\n         *   for SCIs.\n         * - If metadata-complete=true and an absolute ordering is specified,\n         *   JARs excluded from the ordering are also excluded from the SCI\n         *   processing.\n         * - If an SCI has a @HandlesType annotation then all classes (except\n         *   those in JARs excluded from an absolute ordering) need to be\n         *   scanned to check if they match.\n         */\n        WebXmlParser webXmlParser = new WebXmlParser(context.getXmlNamespaceAware(),\n                context.getXmlValidation(), context.getXmlBlockExternal());\n\n        Set<WebXml> defaults = new HashSet<>();\n        defaults.add(getDefaultWebXmlFragment(webXmlParser));\n\n        WebXml webXml = createWebXml();\n\n        // Parse context level web.xml\n        InputSource contextWebXml = getContextWebXmlSource();\n        if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) {\n            ok = false;\n        }\n\n        ServletContext sContext = context.getServletContext();\n\n        // Ordering is important here\n\n        // Step 1. Identify all the JARs packaged with the application and those\n        // provided by the container. If any of the application JARs have a\n        // web-fragment.xml it will be parsed at this point. web-fragment.xml\n        // files are ignored for container provided JARs.\n        Map<String,WebXml> fragments = processJarsForWebFragments(webXml, webXmlParser);\n\n        // Step 2. Order the fragments.\n        Set<WebXml> orderedFragments = null;\n        orderedFragments =\n                WebXml.orderWebFragments(webXml, fragments, sContext);\n\n        // Step 3. Look for ServletContainerInitializer implementations\n        if (ok) {\n            processServletContainerInitializers();\n        }\n\n        if  (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {\n            // Step 4. Process /WEB-INF/classes for annotations and\n            // @HandlesTypes matches\n            Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n\n            if (ok) {\n                WebResource[] webResources =\n                        context.getResources().listResources(\"/WEB-INF/classes\");\n\n                for (WebResource webResource : webResources) {\n                    processAnnotationsWebResource(webResource, webXml,\n                            webXml.isMetadataComplete(), javaClassCache);\n                }\n            }\n\n            // Step 5. Process JARs for annotations for annotations and\n            // @HandlesTypes matches - only need to process those fragments we\n            // are going to use (remember orderedFragments includes any\n            // container fragments)\n            if (ok) {\n                processAnnotations(\n                        orderedFragments, webXml.isMetadataComplete(), javaClassCache);\n            }\n\n            // Cache, if used, is no longer required so clear it\n            javaClassCache.clear();\n        }\n\n        if (!webXml.isMetadataComplete()) {\n            // Step 6. Merge web-fragment.xml files into the main web.xml\n            // file.\n            if (ok) {\n                ok = webXml.merge(orderedFragments);\n            }\n\n            // Step 7. Apply global defaults\n            // Have to merge defaults before JSP conversion since defaults\n            // provide JSP servlet definition.\n            webXml.merge(defaults);\n\n            // Step 8. Convert explicitly mentioned jsps to servlets\n            if (ok) {\n                convertJsps(webXml);\n            }\n\n            // Step 9. Apply merged web.xml to Context\n            if (ok) {\n                configureContext(webXml);\n            }\n        } else {\n            webXml.merge(defaults);\n            convertJsps(webXml);\n            configureContext(webXml);\n        }\n\n        if (context.getLogEffectiveWebXml()) {\n            log.info(\"web.xml:\\n\" + webXml.toXml());\n        }\n\n        // Always need to look for static resources\n        // Step 10. Look for static resources packaged in JARs\n        if (ok) {\n            // Spec does not define an order.\n            // Use ordered JARs followed by remaining JARs\n            Set<WebXml> resourceJars = new LinkedHashSet<>();\n            for (WebXml fragment : orderedFragments) {\n                resourceJars.add(fragment);\n            }\n            for (WebXml fragment : fragments.values()) {\n                if (!resourceJars.contains(fragment)) {\n                    resourceJars.add(fragment);\n                }\n            }\n            processResourceJARs(resourceJars);\n            // See also StandardContext.resourcesStart() for\n            // WEB-INF/classes/META-INF/resources configuration\n        }\n\n        // Step 11. Apply the ServletContainerInitializer config to the\n        // context\n        if (ok) {\n            for (Map.Entry<ServletContainerInitializer,\n                    Set<Class<?>>> entry :\n                        initializerClassMap.entrySet()) {\n                if (entry.getValue().isEmpty()) {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), null);\n                } else {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"protected void processAnnotationsUrl(URL url, WebXml fragment,\n            boolean handlesTypesOnly) {\n        if (url == null) {\n            // Nothing to do.\n            return;\n        } else if (\"jar\".equals(url.getProtocol())) {\n            processAnnotationsJar(url, fragment, handlesTypesOnly);\n        } else if (\"file\".equals(url.getProtocol())) {\n            try {\n                processAnnotationsFile(\n                        new File(url.toURI()), fragment, handlesTypesOnly);\n            } catch (URISyntaxException e) {\n                log.error(sm.getString(\"contextConfig.fileUrl\", url), e);\n            }\n        } else {\n            log.error(sm.getString(\"contextConfig.unknownUrlProtocol\",\n                    url.getProtocol(), url));\n        }\n\n    }","id":32056,"modified_method":"protected void processAnnotationsUrl(URL url, WebXml fragment,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache) {\n        if (url == null) {\n            // Nothing to do.\n            return;\n        } else if (\"jar\".equals(url.getProtocol())) {\n            processAnnotationsJar(url, fragment, handlesTypesOnly, javaClassCache);\n        } else if (\"file\".equals(url.getProtocol())) {\n            try {\n                processAnnotationsFile(\n                        new File(url.toURI()), fragment, handlesTypesOnly, javaClassCache);\n            } catch (URISyntaxException e) {\n                log.error(sm.getString(\"contextConfig.fileUrl\", url), e);\n            }\n        } else {\n            log.error(sm.getString(\"contextConfig.unknownUrlProtocol\",\n                    url.getProtocol(), url));\n        }\n\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"private String classHierarchyToString(String className,\n            JavaClassCacheEntry entry) {\n        JavaClassCacheEntry start = entry;\n        StringBuilder msg = new StringBuilder(className);\n        msg.append(\"->\");\n\n        String parentName = entry.getSuperclassName();\n        JavaClassCacheEntry parent = javaClassCache.get(parentName);\n        int count = 0;\n\n        while (count < 100 && parent != null && parent != start) {\n            msg.append(parentName);\n            msg.append(\"->\");\n\n            count ++;\n            parentName = parent.getSuperclassName();\n            parent = javaClassCache.get(parentName);\n        }\n\n        msg.append(parentName);\n\n        return msg.toString();\n    }","id":32057,"modified_method":"private String classHierarchyToString(String className,\n            JavaClassCacheEntry entry, Map<String,JavaClassCacheEntry> javaClassCache) {\n        JavaClassCacheEntry start = entry;\n        StringBuilder msg = new StringBuilder(className);\n        msg.append(\"->\");\n\n        String parentName = entry.getSuperclassName();\n        JavaClassCacheEntry parent = javaClassCache.get(parentName);\n        int count = 0;\n\n        while (count < 100 && parent != null && parent != start) {\n            msg.append(parentName);\n            msg.append(\"->\");\n\n            count ++;\n            parentName = parent.getSuperclassName();\n            parent = javaClassCache.get(parentName);\n        }\n\n        msg.append(parentName);\n\n        return msg.toString();\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry) {\n        Set<ServletContainerInitializer> result = new HashSet<>();\n\n        // Super class\n        String superClassName = cacheEntry.getSuperclassName();\n        JavaClassCacheEntry superClassCacheEntry =\n                javaClassCache.get(superClassName);\n\n        // Avoid an infinite loop with java.lang.Object\n        if (cacheEntry.equals(superClassCacheEntry)) {\n            cacheEntry.setSciSet(EMPTY_SCI_SET);\n            return;\n        }\n\n        // May be null of the class is not present or could not be loaded.\n        if (superClassCacheEntry != null) {\n            if (superClassCacheEntry.getSciSet() == null) {\n                populateSCIsForCacheEntry(superClassCacheEntry);\n            }\n            result.addAll(superClassCacheEntry.getSciSet());\n        }\n        result.addAll(getSCIsForClass(superClassName));\n\n        // Interfaces\n        for (String interfaceName : cacheEntry.getInterfaceNames()) {\n            JavaClassCacheEntry interfaceEntry =\n                    javaClassCache.get(interfaceName);\n            // A null could mean that the class not present in application or\n            // that there is nothing of interest. Either way, nothing to do here\n            // so move along\n            if (interfaceEntry != null) {\n                if (interfaceEntry.getSciSet() == null) {\n                    populateSCIsForCacheEntry(interfaceEntry);\n                }\n                result.addAll(interfaceEntry.getSciSet());\n            }\n            result.addAll(getSCIsForClass(interfaceName));\n        }\n\n        cacheEntry.setSciSet(result.isEmpty() ? EMPTY_SCI_SET : result);\n    }","id":32058,"modified_method":"private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n        Set<ServletContainerInitializer> result = new HashSet<>();\n\n        // Super class\n        String superClassName = cacheEntry.getSuperclassName();\n        JavaClassCacheEntry superClassCacheEntry =\n                javaClassCache.get(superClassName);\n\n        // Avoid an infinite loop with java.lang.Object\n        if (cacheEntry.equals(superClassCacheEntry)) {\n            cacheEntry.setSciSet(EMPTY_SCI_SET);\n            return;\n        }\n\n        // May be null of the class is not present or could not be loaded.\n        if (superClassCacheEntry != null) {\n            if (superClassCacheEntry.getSciSet() == null) {\n                populateSCIsForCacheEntry(superClassCacheEntry, javaClassCache);\n            }\n            result.addAll(superClassCacheEntry.getSciSet());\n        }\n        result.addAll(getSCIsForClass(superClassName));\n\n        // Interfaces\n        for (String interfaceName : cacheEntry.getInterfaceNames()) {\n            JavaClassCacheEntry interfaceEntry =\n                    javaClassCache.get(interfaceName);\n            // A null could mean that the class not present in application or\n            // that there is nothing of interest. Either way, nothing to do here\n            // so move along\n            if (interfaceEntry != null) {\n                if (interfaceEntry.getSciSet() == null) {\n                    populateSCIsForCacheEntry(interfaceEntry, javaClassCache);\n                }\n                result.addAll(interfaceEntry.getSciSet());\n            }\n            result.addAll(getSCIsForClass(interfaceName));\n        }\n\n        cacheEntry.setSciSet(result.isEmpty() ? EMPTY_SCI_SET : result);\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"private void populateJavaClassCache(String className) {\n        if (!javaClassCache.containsKey(className)) {\n            String name = className.replace('.', '/') + \".class\";\n            try (InputStream is = context.getLoader().getClassLoader().getResourceAsStream(name)) {\n                if (is == null) {\n                    return;\n                }\n                ClassParser parser = new ClassParser(is);\n                JavaClass clazz = parser.parse();\n                populateJavaClassCache(clazz.getClassName(), clazz);\n            } catch (ClassFormatException e) {\n                log.debug(sm.getString(\"contextConfig.invalidSciHandlesTypes\",\n                        className), e);\n            } catch (IOException e) {\n                log.debug(sm.getString(\"contextConfig.invalidSciHandlesTypes\",\n                        className), e);\n            }\n        }\n    }","id":32059,"modified_method":"private void populateJavaClassCache(String className,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n        if (!javaClassCache.containsKey(className)) {\n            String name = className.replace('.', '/') + \".class\";\n            try (InputStream is = context.getLoader().getClassLoader().getResourceAsStream(name)) {\n                if (is == null) {\n                    return;\n                }\n                ClassParser parser = new ClassParser(is);\n                JavaClass clazz = parser.parse();\n                populateJavaClassCache(clazz.getClassName(), clazz, javaClassCache);\n            } catch (ClassFormatException e) {\n                log.debug(sm.getString(\"contextConfig.invalidSciHandlesTypes\",\n                        className), e);\n            } catch (IOException e) {\n                log.debug(sm.getString(\"contextConfig.invalidSciHandlesTypes\",\n                        className), e);\n            }\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"protected void processAnnotationsStream(InputStream is, WebXml fragment,\n            boolean handlesTypesOnly)\n            throws ClassFormatException, IOException {\n\n        ClassParser parser = new ClassParser(is);\n        JavaClass clazz = parser.parse();\n        checkHandlesTypes(clazz);\n\n        if (handlesTypesOnly) {\n            return;\n        }\n\n        AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();\n        if (annotationsEntries != null) {\n            String className = clazz.getClassName();\n            for (AnnotationEntry ae : annotationsEntries) {\n                String type = ae.getAnnotationType();\n                if (\"Ljavax/servlet/annotation/WebServlet;\".equals(type)) {\n                    processAnnotationWebServlet(className, ae, fragment);\n                }else if (\"Ljavax/servlet/annotation/WebFilter;\".equals(type)) {\n                    processAnnotationWebFilter(className, ae, fragment);\n                }else if (\"Ljavax/servlet/annotation/WebListener;\".equals(type)) {\n                    fragment.addListener(className);\n                } else {\n                    // Unknown annotation - ignore\n                }\n            }\n        }\n    }","id":32060,"modified_method":"protected void processAnnotationsStream(InputStream is, WebXml fragment,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache)\n            throws ClassFormatException, IOException {\n\n        ClassParser parser = new ClassParser(is);\n        JavaClass clazz = parser.parse();\n        checkHandlesTypes(clazz, javaClassCache);\n\n        if (handlesTypesOnly) {\n            return;\n        }\n\n        AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();\n        if (annotationsEntries != null) {\n            String className = clazz.getClassName();\n            for (AnnotationEntry ae : annotationsEntries) {\n                String type = ae.getAnnotationType();\n                if (\"Ljavax/servlet/annotation/WebServlet;\".equals(type)) {\n                    processAnnotationWebServlet(className, ae, fragment);\n                }else if (\"Ljavax/servlet/annotation/WebFilter;\".equals(type)) {\n                    processAnnotationWebFilter(className, ae, fragment);\n                }else if (\"Ljavax/servlet/annotation/WebListener;\".equals(type)) {\n                    fragment.addListener(className);\n                } else {\n                    // Unknown annotation - ignore\n                }\n            }\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"protected void processAnnotationsJar(URL url, WebXml fragment,\n            boolean handlesTypesOnly) {\n\n        try (Jar jar = JarFactory.newInstance(url)) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"contextConfig.processAnnotationsJar.debug\", url));\n            }\n\n            jar.nextEntry();\n            String entryName = jar.getEntryName();\n            while (entryName != null) {\n                if (entryName.endsWith(\".class\")) {\n                    try (InputStream is = jar.getEntryInputStream()) {\n                        processAnnotationsStream(\n                                is, fragment, handlesTypesOnly);\n                    } catch (IOException e) {\n                        log.error(sm.getString(\"contextConfig.inputStreamJar\",\n                                entryName, url),e);\n                    } catch (ClassFormatException e) {\n                        log.error(sm.getString(\"contextConfig.inputStreamJar\",\n                                entryName, url),e);\n                    }\n                }\n                jar.nextEntry();\n                entryName = jar.getEntryName();\n            }\n        } catch (IOException e) {\n            log.error(sm.getString(\"contextConfig.jarFile\", url), e);\n        }\n    }","id":32061,"modified_method":"protected void processAnnotationsJar(URL url, WebXml fragment,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        try (Jar jar = JarFactory.newInstance(url)) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"contextConfig.processAnnotationsJar.debug\", url));\n            }\n\n            jar.nextEntry();\n            String entryName = jar.getEntryName();\n            while (entryName != null) {\n                if (entryName.endsWith(\".class\")) {\n                    try (InputStream is = jar.getEntryInputStream()) {\n                        processAnnotationsStream(is, fragment, handlesTypesOnly, javaClassCache);\n                    } catch (IOException e) {\n                        log.error(sm.getString(\"contextConfig.inputStreamJar\",\n                                entryName, url),e);\n                    } catch (ClassFormatException e) {\n                        log.error(sm.getString(\"contextConfig.inputStreamJar\",\n                                entryName, url),e);\n                    }\n                }\n                jar.nextEntry();\n                entryName = jar.getEntryName();\n            }\n        } catch (IOException e) {\n            log.error(sm.getString(\"contextConfig.jarFile\", url), e);\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"protected void processAnnotationsWebResource(WebResource webResource,\n            WebXml fragment, boolean handlesTypesOnly) {\n\n        if (webResource.isDirectory()) {\n            WebResource[] webResources =\n                    webResource.getWebResourceRoot().listResources(\n                            webResource.getWebappPath());\n            if (webResources.length > 0) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"contextConfig.processAnnotationsWebDir.debug\",\n                            webResource.getURL()));\n                }\n                for (WebResource r : webResources) {\n                    processAnnotationsWebResource(r, fragment, handlesTypesOnly);\n                }\n            }\n        } else if (webResource.isFile() &&\n                webResource.getName().endsWith(\".class\")) {\n            try (InputStream is = webResource.getInputStream()) {\n                processAnnotationsStream(is, fragment, handlesTypesOnly);\n            } catch (IOException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamWebResource\",\n                        webResource.getWebappPath()),e);\n            } catch (ClassFormatException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamWebResource\",\n                        webResource.getWebappPath()),e);\n            }\n        }\n    }","id":32062,"modified_method":"protected void processAnnotationsWebResource(WebResource webResource,\n            WebXml fragment, boolean handlesTypesOnly,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        if (webResource.isDirectory()) {\n            WebResource[] webResources =\n                    webResource.getWebResourceRoot().listResources(\n                            webResource.getWebappPath());\n            if (webResources.length > 0) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"contextConfig.processAnnotationsWebDir.debug\",\n                            webResource.getURL()));\n                }\n                for (WebResource r : webResources) {\n                    processAnnotationsWebResource(r, fragment, handlesTypesOnly, javaClassCache);\n                }\n            }\n        } else if (webResource.isFile() &&\n                webResource.getName().endsWith(\".class\")) {\n            try (InputStream is = webResource.getInputStream()) {\n                processAnnotationsStream(is, fragment, handlesTypesOnly, javaClassCache);\n            } catch (IOException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamWebResource\",\n                        webResource.getWebappPath()),e);\n            } catch (ClassFormatException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamWebResource\",\n                        webResource.getWebappPath()),e);\n            }\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * For classes packaged with the web application, the class and each\n     * super class needs to be checked for a match with {@link HandlesTypes} or\n     * for an annotation that matches {@link HandlesTypes}.\n     * @param javaClass the class to check\n     */\n    protected void checkHandlesTypes(JavaClass javaClass) {\n\n        // Skip this if we can\n        if (typeInitializerMap.size() == 0) {\n            return;\n        }\n\n        if ((javaClass.getAccessFlags() &\n                org.apache.tomcat.util.bcel.Const.ACC_ANNOTATION) > 0) {\n            // Skip annotations.\n            return;\n        }\n\n        String className = javaClass.getClassName();\n\n        Class<?> clazz = null;\n        if (handlesTypesNonAnnotations) {\n            // This *might* be match for a HandlesType.\n            populateJavaClassCache(className, javaClass);\n            JavaClassCacheEntry entry = javaClassCache.get(className);\n            if (entry.getSciSet() == null) {\n                try {\n                    populateSCIsForCacheEntry(entry);\n                } catch (StackOverflowError soe) {\n                    throw new IllegalStateException(sm.getString(\n                            \"contextConfig.annotationsStackOverflow\",\n                            context.getName(),\n                            classHierarchyToString(className, entry)));\n                }\n            }\n            if (!entry.getSciSet().isEmpty()) {\n                // Need to try and load the class\n                clazz = Introspection.loadClass(context, className);\n                if (clazz == null) {\n                    // Can't load the class so no point continuing\n                    return;\n                }\n\n                for (ServletContainerInitializer sci : entry.getSciSet()) {\n                    Set<Class<?>> classes = initializerClassMap.get(sci);\n                    if (classes == null) {\n                        classes = new HashSet<>();\n                        initializerClassMap.put(sci, classes);\n                    }\n                    classes.add(clazz);\n                }\n            }\n        }\n\n        if (handlesTypesAnnotations) {\n            AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries();\n            if (annotationEntries != null) {\n                for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :\n                        typeInitializerMap.entrySet()) {\n                    if (entry.getKey().isAnnotation()) {\n                        String entryClassName = entry.getKey().getName();\n                        for (AnnotationEntry annotationEntry : annotationEntries) {\n                            if (entryClassName.equals(\n                                    getClassName(annotationEntry.getAnnotationType()))) {\n                                if (clazz == null) {\n                                    clazz = Introspection.loadClass(\n                                            context, className);\n                                    if (clazz == null) {\n                                        // Can't load the class so no point\n                                        // continuing\n                                        return;\n                                    }\n                                }\n                                for (ServletContainerInitializer sci : entry.getValue()) {\n                                    initializerClassMap.get(sci).add(clazz);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","id":32063,"modified_method":"/**\n     * For classes packaged with the web application, the class and each\n     * super class needs to be checked for a match with {@link HandlesTypes} or\n     * for an annotation that matches {@link HandlesTypes}.\n     * @param javaClass the class to check\n     */\n    protected void checkHandlesTypes(JavaClass javaClass,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        // Skip this if we can\n        if (typeInitializerMap.size() == 0) {\n            return;\n        }\n\n        if ((javaClass.getAccessFlags() &\n                org.apache.tomcat.util.bcel.Const.ACC_ANNOTATION) > 0) {\n            // Skip annotations.\n            return;\n        }\n\n        String className = javaClass.getClassName();\n\n        Class<?> clazz = null;\n        if (handlesTypesNonAnnotations) {\n            // This *might* be match for a HandlesType.\n            populateJavaClassCache(className, javaClass, javaClassCache);\n            JavaClassCacheEntry entry = javaClassCache.get(className);\n            if (entry.getSciSet() == null) {\n                try {\n                    populateSCIsForCacheEntry(entry, javaClassCache);\n                } catch (StackOverflowError soe) {\n                    throw new IllegalStateException(sm.getString(\n                            \"contextConfig.annotationsStackOverflow\",\n                            context.getName(),\n                            classHierarchyToString(className, entry, javaClassCache)));\n                }\n            }\n            if (!entry.getSciSet().isEmpty()) {\n                // Need to try and load the class\n                clazz = Introspection.loadClass(context, className);\n                if (clazz == null) {\n                    // Can't load the class so no point continuing\n                    return;\n                }\n\n                for (ServletContainerInitializer sci : entry.getSciSet()) {\n                    Set<Class<?>> classes = initializerClassMap.get(sci);\n                    if (classes == null) {\n                        classes = new HashSet<>();\n                        initializerClassMap.put(sci, classes);\n                    }\n                    classes.add(clazz);\n                }\n            }\n        }\n\n        if (handlesTypesAnnotations) {\n            AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries();\n            if (annotationEntries != null) {\n                for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :\n                        typeInitializerMap.entrySet()) {\n                    if (entry.getKey().isAnnotation()) {\n                        String entryClassName = entry.getKey().getName();\n                        for (AnnotationEntry annotationEntry : annotationEntries) {\n                            if (entryClassName.equals(\n                                    getClassName(annotationEntry.getAnnotationType()))) {\n                                if (clazz == null) {\n                                    clazz = Introspection.loadClass(\n                                            context, className);\n                                    if (clazz == null) {\n                                        // Can't load the class so no point\n                                        // continuing\n                                        return;\n                                    }\n                                }\n                                for (ServletContainerInitializer sci : entry.getValue()) {\n                                    initializerClassMap.get(sci).add(clazz);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"protected void processAnnotationsFile(File file, WebXml fragment,\n            boolean handlesTypesOnly) {\n\n        if (file.isDirectory()) {\n            // Returns null if directory is not readable\n            String[] dirs = file.list();\n            if (dirs != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"contextConfig.processAnnotationsDir.debug\", file));\n                }\n                for (String dir : dirs) {\n                    processAnnotationsFile(\n                            new File(file,dir), fragment, handlesTypesOnly);\n                }\n            }\n        } else if (file.getName().endsWith(\".class\") && file.canRead()) {\n            try (FileInputStream fis = new FileInputStream(file)) {\n                processAnnotationsStream(fis, fragment, handlesTypesOnly);\n            } catch (IOException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamFile\",\n                        file.getAbsolutePath()),e);\n            } catch (ClassFormatException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamFile\",\n                        file.getAbsolutePath()),e);\n            }\n        }\n    }","id":32064,"modified_method":"protected void processAnnotationsFile(File file, WebXml fragment,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        if (file.isDirectory()) {\n            // Returns null if directory is not readable\n            String[] dirs = file.list();\n            if (dirs != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"contextConfig.processAnnotationsDir.debug\", file));\n                }\n                for (String dir : dirs) {\n                    processAnnotationsFile(\n                            new File(file,dir), fragment, handlesTypesOnly, javaClassCache);\n                }\n            }\n        } else if (file.getName().endsWith(\".class\") && file.canRead()) {\n            try (FileInputStream fis = new FileInputStream(file)) {\n                processAnnotationsStream(fis, fragment, handlesTypesOnly, javaClassCache);\n            } catch (IOException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamFile\",\n                        file.getAbsolutePath()),e);\n            } catch (ClassFormatException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamFile\",\n                        file.getAbsolutePath()),e);\n            }\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"private void populateJavaClassCache(String className, JavaClass javaClass) {\n        if (javaClassCache.containsKey(className)) {\n            return;\n        }\n\n        // Add this class to the cache\n        javaClassCache.put(className, new JavaClassCacheEntry(javaClass));\n\n        populateJavaClassCache(javaClass.getSuperclassName());\n\n        for (String iterface : javaClass.getInterfaceNames()) {\n            populateJavaClassCache(iterface);\n        }\n    }","id":32065,"modified_method":"private void populateJavaClassCache(String className, JavaClass javaClass,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n        if (javaClassCache.containsKey(className)) {\n            return;\n        }\n\n        // Add this class to the cache\n        javaClassCache.put(className, new JavaClassCacheEntry(javaClass));\n\n        populateJavaClassCache(javaClass.getSuperclassName(), javaClassCache);\n\n        for (String iterface : javaClass.getInterfaceNames()) {\n            populateJavaClassCache(iterface, javaClassCache);\n        }\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testFilterMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        ContextConfig config = new ContextConfig();\n        File sFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        config.processAnnotationsFile(sFile, webxml, false);\n        File fFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamFilter\");\n        config.processAnnotationsFile(fFile, webxml, false);\n        FilterDef fdef = webxml.getFilters().get(\"paramFilter\");\n        assertNotNull(fdef);\n        assertEquals(\"Servlet says: \",fdef.getParameterMap().get(\"message\"));\n    }","id":32066,"modified_method":"@Test\n    public void testFilterMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ContextConfig config = new ContextConfig();\n        File sFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        config.processAnnotationsFile(sFile, webxml, false, javaClassCache);\n        File fFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamFilter\");\n        config.processAnnotationsFile(fFile, webxml, false, javaClassCache);\n        FilterDef fdef = webxml.getFilters().get(\"paramFilter\");\n        assertNotNull(fdef);\n        assertEquals(\"Servlet says: \",fdef.getParameterMap().get(\"message\"));\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testAnnotation() throws Exception {\n        WebXml webxml = new WebXml();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false);\n        ServletDef servletDef = webxml.getServlets().get(\"param\");\n        assertNotNull(servletDef);\n        assertEquals(\"Hello\", servletDef.getParameterMap().get(\"foo\"));\n        assertEquals(\"World!\", servletDef.getParameterMap().get(\"bar\"));\n        assertEquals(\"param\", webxml.getServletMappings().get(\n                \"/annotation/overwrite\"));\n\n        assertEquals(\"param\", servletDef.getDescription());\n        assertEquals(\"param\", servletDef.getDisplayName());\n        assertEquals(\"paramLarge.png\", servletDef.getLargeIcon());\n        assertEquals(\"paramSmall.png\", servletDef.getSmallIcon());\n        assertEquals(Boolean.FALSE, servletDef.getAsyncSupported());\n        assertEquals(Integer.valueOf(0), servletDef.getLoadOnStartup());\n        assertNull(servletDef.getEnabled());\n        assertNull(servletDef.getJspFile());\n\n    }","id":32067,"modified_method":"@Test\n    public void testAnnotation() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false, javaClassCache);\n        ServletDef servletDef = webxml.getServlets().get(\"param\");\n        assertNotNull(servletDef);\n        assertEquals(\"Hello\", servletDef.getParameterMap().get(\"foo\"));\n        assertEquals(\"World!\", servletDef.getParameterMap().get(\"bar\"));\n        assertEquals(\"param\", webxml.getServletMappings().get(\n                \"/annotation/overwrite\"));\n\n        assertEquals(\"param\", servletDef.getDescription());\n        assertEquals(\"param\", servletDef.getDisplayName());\n        assertEquals(\"paramLarge.png\", servletDef.getLargeIcon());\n        assertEquals(\"paramSmall.png\", servletDef.getSmallIcon());\n        assertEquals(Boolean.FALSE, servletDef.getAsyncSupported());\n        assertEquals(Integer.valueOf(0), servletDef.getLoadOnStartup());\n        assertNull(servletDef.getEnabled());\n        assertNull(servletDef.getJspFile());\n\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testCheckHandleTypes() throws Exception {\n        ContextConfig config = new ContextConfig();\n        config.handlesTypesAnnotations = true;\n        config.handlesTypesNonAnnotations = true;\n\n        // Need a Context, Loader and ClassLoader for checkHandleTypes\n        StandardContext context = new StandardContext();\n        context.setLoader(new TesterLoader());\n        config.context = context;\n\n        // Add an SCI that has no interest in any type\n        SCI sciNone = new SCI();\n        config.initializerClassMap.put(sciNone, new HashSet<Class<?>>());\n\n        // Add an SCI with an interest in Servlets\n        SCI sciServlet = new SCI();\n        config.initializerClassMap.put(sciServlet, new HashSet<Class<?>>());\n        config.typeInitializerMap.put(Servlet.class,\n                new HashSet<ServletContainerInitializer>());\n        config.typeInitializerMap.get(Servlet.class).add(sciServlet);\n\n        // Add an SCI with an interest in Objects - i.e. everything\n        SCI sciObject = new SCI();\n        config.initializerClassMap.put(sciObject, new HashSet<Class<?>>());\n        config.typeInitializerMap.put(Object.class,\n                new HashSet<ServletContainerInitializer>());\n        config.typeInitializerMap.get(Object.class).add(sciObject);\n\n        // Scan Servlet, Filter, Servlet, Listener\n        WebXml ignore = new WebXml();\n        File file = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        config.processAnnotationsFile(file, ignore, false);\n        file = paramClassResource(\"org/apache/catalina/startup/ParamFilter\");\n        config.processAnnotationsFile(file, ignore, false);\n        file = paramClassResource(\"org/apache/catalina/startup/TesterServlet\");\n        config.processAnnotationsFile(file, ignore, false);\n        file = paramClassResource(\"org/apache/catalina/startup/TestListener\");\n        config.processAnnotationsFile(file, ignore, false);\n\n        // Check right number of classes were noted to be handled\n        assertEquals(0, config.initializerClassMap.get(sciNone).size());\n        assertEquals(2, config.initializerClassMap.get(sciServlet).size());\n        assertEquals(4, config.initializerClassMap.get(sciObject).size());\n    }","id":32068,"modified_method":"@Test\n    public void testCheckHandleTypes() throws Exception {\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ContextConfig config = new ContextConfig();\n        config.handlesTypesAnnotations = true;\n        config.handlesTypesNonAnnotations = true;\n\n        // Need a Context, Loader and ClassLoader for checkHandleTypes\n        StandardContext context = new StandardContext();\n        context.setLoader(new TesterLoader());\n        config.context = context;\n\n        // Add an SCI that has no interest in any type\n        SCI sciNone = new SCI();\n        config.initializerClassMap.put(sciNone, new HashSet<Class<?>>());\n\n        // Add an SCI with an interest in Servlets\n        SCI sciServlet = new SCI();\n        config.initializerClassMap.put(sciServlet, new HashSet<Class<?>>());\n        config.typeInitializerMap.put(Servlet.class,\n                new HashSet<ServletContainerInitializer>());\n        config.typeInitializerMap.get(Servlet.class).add(sciServlet);\n\n        // Add an SCI with an interest in Objects - i.e. everything\n        SCI sciObject = new SCI();\n        config.initializerClassMap.put(sciObject, new HashSet<Class<?>>());\n        config.typeInitializerMap.put(Object.class,\n                new HashSet<ServletContainerInitializer>());\n        config.typeInitializerMap.get(Object.class).add(sciObject);\n\n        // Scan Servlet, Filter, Servlet, Listener\n        WebXml ignore = new WebXml();\n        File file = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        config.processAnnotationsFile(file, ignore, false, javaClassCache);\n        file = paramClassResource(\"org/apache/catalina/startup/ParamFilter\");\n        config.processAnnotationsFile(file, ignore, false, javaClassCache);\n        file = paramClassResource(\"org/apache/catalina/startup/TesterServlet\");\n        config.processAnnotationsFile(file, ignore, false, javaClassCache);\n        file = paramClassResource(\"org/apache/catalina/startup/TestListener\");\n        config.processAnnotationsFile(file, ignore, false, javaClassCache);\n\n        // Check right number of classes were noted to be handled\n        assertEquals(0, config.initializerClassMap.get(sciNone).size());\n        assertEquals(2, config.initializerClassMap.get(sciServlet).size());\n        assertEquals(4, config.initializerClassMap.get(sciObject).size());\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testOverwriteAnnotation() throws Exception {\n        WebXml webxml = new WebXml();\n        ServletDef servletDef = new ServletDef();\n        servletDef.setServletName(\"param\");\n        servletDef.setServletClass(\"org.apache.catalina.startup.ParamServlet\");\n        servletDef.addInitParameter(\"foo\", \"tomcat\");\n        servletDef.setDescription(\"Description\");\n        servletDef.setDisplayName(\"DisplayName\");\n        servletDef.setLargeIcon(\"LargeIcon\");\n        servletDef.setSmallIcon(\"SmallIcon\");\n        servletDef.setAsyncSupported(\"true\");\n        servletDef.setLoadOnStartup(\"1\");\n\n        webxml.addServlet(servletDef);\n        webxml.addServletMapping(\"/param\", \"param\");\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false);\n\n        assertEquals(servletDef, webxml.getServlets().get(\"param\"));\n\n        assertEquals(\"tomcat\", servletDef.getParameterMap().get(\"foo\"));\n        assertEquals(\"param\", webxml.getServletMappings().get(\"/param\"));\n        // annotation mapping not added s. Servlet Spec 3.0 (Nov 2009)\n        // 8.2.3.3.iv page 81\n        assertNull(webxml.getServletMappings().get(\"/annotation/overwrite\"));\n\n        assertEquals(\"Description\", servletDef.getDescription());\n        assertEquals(\"DisplayName\", servletDef.getDisplayName());\n        assertEquals(\"LargeIcon\", servletDef.getLargeIcon());\n        assertEquals(\"SmallIcon\", servletDef.getSmallIcon());\n        assertEquals(Boolean.TRUE, servletDef.getAsyncSupported());\n        assertEquals(Integer.valueOf(1), servletDef.getLoadOnStartup());\n        assertNull(servletDef.getEnabled());\n        assertNull(servletDef.getJspFile());\n    }","id":32069,"modified_method":"@Test\n    public void testOverwriteAnnotation() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ServletDef servletDef = new ServletDef();\n        servletDef.setServletName(\"param\");\n        servletDef.setServletClass(\"org.apache.catalina.startup.ParamServlet\");\n        servletDef.addInitParameter(\"foo\", \"tomcat\");\n        servletDef.setDescription(\"Description\");\n        servletDef.setDisplayName(\"DisplayName\");\n        servletDef.setLargeIcon(\"LargeIcon\");\n        servletDef.setSmallIcon(\"SmallIcon\");\n        servletDef.setAsyncSupported(\"true\");\n        servletDef.setLoadOnStartup(\"1\");\n\n        webxml.addServlet(servletDef);\n        webxml.addServletMapping(\"/param\", \"param\");\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false, javaClassCache);\n\n        assertEquals(servletDef, webxml.getServlets().get(\"param\"));\n\n        assertEquals(\"tomcat\", servletDef.getParameterMap().get(\"foo\"));\n        assertEquals(\"param\", webxml.getServletMappings().get(\"/param\"));\n        // annotation mapping not added s. Servlet Spec 3.0 (Nov 2009)\n        // 8.2.3.3.iv page 81\n        assertNull(webxml.getServletMappings().get(\"/annotation/overwrite\"));\n\n        assertEquals(\"Description\", servletDef.getDescription());\n        assertEquals(\"DisplayName\", servletDef.getDisplayName());\n        assertEquals(\"LargeIcon\", servletDef.getLargeIcon());\n        assertEquals(\"SmallIcon\", servletDef.getSmallIcon());\n        assertEquals(Boolean.TRUE, servletDef.getAsyncSupported());\n        assertEquals(Integer.valueOf(1), servletDef.getLoadOnStartup());\n        assertNull(servletDef.getEnabled());\n        assertNull(servletDef.getJspFile());\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testSetupWebXMLNoMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        ServletDef servletDef = new ServletDef();\n        servletDef.setServletName(\"param1\");\n        servletDef.setServletClass(\n                \"org.apache.catalina.startup.NoMappingParamServlet\");\n        servletDef.addInitParameter(\"foo\", \"tomcat\");\n\n        webxml.addServlet(servletDef);\n        webxml.addServletMapping(\"/param\", \"param1\");\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/NoMappingParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false);\n        assertEquals(\"tomcat\", servletDef.getParameterMap().get(\"foo\"));\n        assertEquals(\"World!\", servletDef.getParameterMap().get(\"bar\"));\n        ServletDef servletDef1 = webxml.getServlets().get(\"param1\");\n        assertNotNull(servletDef1);\n        assertEquals(servletDef, servletDef1);\n    }","id":32070,"modified_method":"@Test\n    public void testSetupWebXMLNoMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ServletDef servletDef = new ServletDef();\n        servletDef.setServletName(\"param1\");\n        servletDef.setServletClass(\n                \"org.apache.catalina.startup.NoMappingParamServlet\");\n        servletDef.addInitParameter(\"foo\", \"tomcat\");\n\n        webxml.addServlet(servletDef);\n        webxml.addServletMapping(\"/param\", \"param1\");\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/NoMappingParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false, javaClassCache);\n        assertEquals(\"tomcat\", servletDef.getParameterMap().get(\"foo\"));\n        assertEquals(\"World!\", servletDef.getParameterMap().get(\"bar\"));\n        ServletDef servletDef1 = webxml.getServlets().get(\"param1\");\n        assertNotNull(servletDef1);\n        assertEquals(servletDef, servletDef1);\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testOverwriteFilterMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        FilterDef filterDef = new FilterDef();\n        filterDef.setFilterName(\"paramFilter\");\n        filterDef.setFilterClass(\"org.apache.catalina.startup.ParamFilter\");\n        filterDef.addInitParameter(\"message\", \"tomcat\");\n        filterDef.setDescription(\"Description\");\n        filterDef.setDisplayName(\"DisplayName\");\n        filterDef.setLargeIcon(\"LargeIcon\");\n        filterDef.setSmallIcon(\"SmallIcon\");\n        filterDef.setAsyncSupported(\"true\");\n\n\n        webxml.addFilter(filterDef);\n        FilterMap filterMap = new FilterMap();\n        filterMap.addURLPattern(\"/param1\");\n        filterMap.setFilterName(\"paramFilter\");\n        webxml.addFilterMapping(filterMap);\n\n        ContextConfig config = new ContextConfig();\n        File sFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        config.processAnnotationsFile(sFile, webxml, false);\n        File fFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamFilter\");\n        config.processAnnotationsFile(fFile, webxml, false);\n        FilterDef fdef = webxml.getFilters().get(\"paramFilter\");\n        assertNotNull(fdef);\n        assertEquals(filterDef,fdef);\n        assertEquals(\"tomcat\",fdef.getParameterMap().get(\"message\"));\n        Set<FilterMap> filterMappings = webxml.getFilterMappings();\n        assertTrue(filterMappings.contains(filterMap));\n        // annotation mapping not added s. Servlet Spec 3.0 (Nov 2009)\n        // 8.2.3.3.vi page 81\n        String[] urlPatterns = filterMap.getURLPatterns();\n        assertNotNull(urlPatterns);\n        assertEquals(1,urlPatterns.length);\n        assertEquals(\"/param1\",urlPatterns[0]);\n\n        // check simple Parameter\n        assertEquals(\"Description\", fdef.getDescription());\n        assertEquals(\"DisplayName\", fdef.getDisplayName());\n        assertEquals(\"LargeIcon\", fdef.getLargeIcon());\n        assertEquals(\"SmallIcon\", fdef.getSmallIcon());\n        // FIXME: Strange why servletDef is Boolean and FilterDef is String?\n        assertEquals(\"true\", fdef.getAsyncSupported());\n\n        String[] dis = filterMap.getDispatcherNames();\n        assertEquals(2, dis.length);\n        assertEquals(DispatcherType.ERROR.toString(),dis[0]);\n        assertEquals(DispatcherType.ASYNC.toString(),dis[1]);\n\n    }","id":32071,"modified_method":"@Test\n    public void testOverwriteFilterMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        FilterDef filterDef = new FilterDef();\n        filterDef.setFilterName(\"paramFilter\");\n        filterDef.setFilterClass(\"org.apache.catalina.startup.ParamFilter\");\n        filterDef.addInitParameter(\"message\", \"tomcat\");\n        filterDef.setDescription(\"Description\");\n        filterDef.setDisplayName(\"DisplayName\");\n        filterDef.setLargeIcon(\"LargeIcon\");\n        filterDef.setSmallIcon(\"SmallIcon\");\n        filterDef.setAsyncSupported(\"true\");\n\n\n        webxml.addFilter(filterDef);\n        FilterMap filterMap = new FilterMap();\n        filterMap.addURLPattern(\"/param1\");\n        filterMap.setFilterName(\"paramFilter\");\n        webxml.addFilterMapping(filterMap);\n\n        ContextConfig config = new ContextConfig();\n        File sFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamServlet\");\n        config.processAnnotationsFile(sFile, webxml, false, javaClassCache);\n        File fFile = paramClassResource(\n                \"org/apache/catalina/startup/ParamFilter\");\n        config.processAnnotationsFile(fFile, webxml, false, javaClassCache);\n        FilterDef fdef = webxml.getFilters().get(\"paramFilter\");\n        assertNotNull(fdef);\n        assertEquals(filterDef,fdef);\n        assertEquals(\"tomcat\",fdef.getParameterMap().get(\"message\"));\n        Set<FilterMap> filterMappings = webxml.getFilterMappings();\n        assertTrue(filterMappings.contains(filterMap));\n        // annotation mapping not added s. Servlet Spec 3.0 (Nov 2009)\n        // 8.2.3.3.vi page 81\n        String[] urlPatterns = filterMap.getURLPatterns();\n        assertNotNull(urlPatterns);\n        assertEquals(1,urlPatterns.length);\n        assertEquals(\"/param1\",urlPatterns[0]);\n\n        // check simple Parameter\n        assertEquals(\"Description\", fdef.getDescription());\n        assertEquals(\"DisplayName\", fdef.getDisplayName());\n        assertEquals(\"LargeIcon\", fdef.getLargeIcon());\n        assertEquals(\"SmallIcon\", fdef.getSmallIcon());\n        // FIXME: Strange why servletDef is Boolean and FilterDef is String?\n        assertEquals(\"true\", fdef.getAsyncSupported());\n\n        String[] dis = filterMap.getDispatcherNames();\n        assertEquals(2, dis.length);\n        assertEquals(DispatcherType.ERROR.toString(),dis[0]);\n        assertEquals(DispatcherType.ASYNC.toString(),dis[1]);\n\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testDuplicateFilterMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/DuplicateMappingParamFilter\");\n        assertTrue(pFile.exists());\n        try {\n            config.processAnnotationsFile(pFile, webxml, false);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // ignore\n        }\n        FilterDef filterDef = webxml.getFilters().get(\"paramD\");\n        assertNull(filterDef);\n    }","id":32072,"modified_method":"@Test\n    public void testDuplicateFilterMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/DuplicateMappingParamFilter\");\n        assertTrue(pFile.exists());\n        try {\n            config.processAnnotationsFile(pFile, webxml, false, javaClassCache);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // ignore\n        }\n        FilterDef filterDef = webxml.getFilters().get(\"paramD\");\n        assertNull(filterDef);\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testDuplicateMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/DuplicateMappingParamServlet\");\n        assertTrue(pFile.exists());\n        try {\n            config.processAnnotationsFile(pFile, webxml, false);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // ignore\n        }\n        ServletDef servletDef = webxml.getServlets().get(\"param\");\n        assertNull(servletDef);\n    }","id":32073,"modified_method":"@Test\n    public void testDuplicateMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/DuplicateMappingParamServlet\");\n        assertTrue(pFile.exists());\n        try {\n            config.processAnnotationsFile(pFile, webxml, false, javaClassCache);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // ignore\n        }\n        ServletDef servletDef = webxml.getServlets().get(\"param\");\n        assertNull(servletDef);\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testNoMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/NoMappingParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false);\n        ServletDef servletDef = webxml.getServlets().get(\"param1\");\n        assertNull(servletDef);\n\n        webxml.addServletMapping(\"/param\", \"param1\");\n        config.processAnnotationsFile(pFile, webxml, false);\n        servletDef = webxml.getServlets().get(\"param1\");\n        assertNull(servletDef);\n\n    }","id":32074,"modified_method":"@Test\n    public void testNoMapping() throws Exception {\n        WebXml webxml = new WebXml();\n        Map<String,JavaClassCacheEntry> javaClassCache = new HashMap<>();\n        ContextConfig config = new ContextConfig();\n        File pFile = paramClassResource(\n                \"org/apache/catalina/startup/NoMappingParamServlet\");\n        assertTrue(pFile.exists());\n        config.processAnnotationsFile(pFile, webxml, false, javaClassCache);\n        ServletDef servletDef = webxml.getServlets().get(\"param1\");\n        assertNull(servletDef);\n\n        webxml.addServletMapping(\"/param\", \"param1\");\n        config.processAnnotationsFile(pFile, webxml, false, javaClassCache);\n        servletDef = webxml.getServlets().get(\"param1\");\n        assertNull(servletDef);\n\n    }","commit_id":"4794181ed4b76bc158396f0dc369b7816a672f42","url":"https://github.com/apache/tomcat"},{"original_method":"/**\r\n   * Returns the absolute path to this application.\r\n   * @return application path\r\n   */\r\n  private static String applicationPath() {\r\n    // raw application path\r\n    final String path = Util.class.getProtectionDomain().\r\n      getCodeSource().getLocation().getPath();\r\n\r\n    // decode path; URLDecode returns wrong results\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    final int pl = path.length();\r\n    for(int p = 0; p < pl; ++p) {\r\n      final char ch = path.charAt(p);\r\n      if(ch == '%' && p + 2 < pl) {\r\n        tb.addByte((byte) Integer.parseInt(path.substring(p + 1, p + 3), 16));\r\n        p += 2;\r\n      } else {\r\n        tb.add(ch);\r\n      }\r\n    }\r\n    try {\r\n      // return path, using the correct encoding\r\n      return new String(tb.finish(), Prop.ENCODING);\r\n    } catch(final Exception ex) {\r\n      // use default path; not expected to occur\r\n      stack(ex);\r\n      return tb.toString();\r\n    }\r\n  }","id":32075,"modified_method":"/**\r\n   * Returns the absolute path to this application, or {@code null} if the\r\n   * path cannot be evaluated.\r\n   * @return application path.\r\n   */\r\n  private static String applicationPath() {\r\n    final ProtectionDomain pd = Util.class.getProtectionDomain();\r\n    if(pd == null) return null;\r\n    // raw application path\r\n    final String path = pd.getCodeSource().getLocation().getPath();\r\n    // decode path; URLDecode returns wrong results\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    final int pl = path.length();\r\n    for(int p = 0; p < pl; ++p) {\r\n      final char ch = path.charAt(p);\r\n      if(ch == '%' && p + 2 < pl) {\r\n        tb.addByte((byte) Integer.parseInt(path.substring(p + 1, p + 3), 16));\r\n        p += 2;\r\n      } else {\r\n        tb.add(ch);\r\n      }\r\n    }\r\n    try {\r\n      // return path, using the correct encoding\r\n      return new String(tb.finish(), Prop.ENCODING);\r\n    } catch(final Exception ex) {\r\n      // use default path; not expected to occur\r\n      stack(ex);\r\n      return tb.toString();\r\n    }\r\n  }","commit_id":"99889878ee006689e3b4060ffcb7bd93a1d50b79","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the the preferred directory for storing the property file,\r\n   * databases directory, etc.\r\n   * @return application path\r\n   */\r\n  public static String homeDir() {\r\n    // check working directory for property file\r\n    final String work = System.getProperty(\"user.dir\");\r\n    if(new File(work, IO.BASEXSUFFIX).exists()) return work;\r\n\r\n    // not found; check application directory\r\n    final File f = new File(applicationPath());\r\n    final String home = f.isFile() ? f.getParent() : f.getPath();\r\n    if(new File(home, IO.BASEXSUFFIX).exists()) return home;\r\n\r\n    // not found; choose user home directory\r\n    return System.getProperty(\"user.home\");\r\n  }","id":32076,"modified_method":"/**\r\n   * Returns the the preferred directory for storing the property file,\r\n   * databases directory, etc.\r\n   * @return application path\r\n   */\r\n  public static String homeDir() {\r\n    // check working directory for property file\r\n    final String work = System.getProperty(\"user.dir\");\r\n    if(new File(work, IO.BASEXSUFFIX).exists()) return work;\r\n\r\n    // not found; check application directory\r\n    final String app = applicationPath();\r\n    if(app != null) {\r\n      final File f = new File(app);\r\n      final String home = f.isFile() ? f.getParent() : f.getPath();\r\n      if(new File(home, IO.BASEXSUFFIX).exists()) return home;\r\n    }\r\n\r\n    // not found; choose user home directory\r\n    return System.getProperty(\"user.home\");\r\n  }","commit_id":"99889878ee006689e3b4060ffcb7bd93a1d50b79","url":"https://github.com/BaseXdb/basex"},{"original_method":"private Map<String, String> _buildFrameworkProperties(Class<?> clazz) {\n\t\tMap<String, String> properties = new HashMap<String, String>();\n\n\t\tproperties.put(\n\t\t\tConstants.BUNDLE_DESCRIPTION, ReleaseInfo.getReleaseInfo());\n\t\tproperties.put(Constants.BUNDLE_NAME, ReleaseInfo.getName());\n\t\tproperties.put(Constants.BUNDLE_VENDOR, ReleaseInfo.getVendor());\n\t\tproperties.put(Constants.BUNDLE_VERSION, ReleaseInfo.getVersion());\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_DIR,\n\t\t\t_getFelixFileInstallDir());\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_LOG_LEVEL,\n\t\t\t_getFelixFileInstallLogLevel());\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_POLL,\n\t\t\tString.valueOf(PropsValues.MODULE_FRAMEWORK_AUTO_DEPLOY_INTERVAL));\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_TMPDIR,\n\t\t\tSystemProperties.get(SystemProperties.TMP_DIR));\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_BEGINNING_STARTLEVEL,\n\t\t\tString.valueOf(PropsValues.MODULE_FRAMEWORK_BEGINNING_START_LEVEL));\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_BUNDLE_PARENT,\n\t\t\tConstants.FRAMEWORK_BUNDLE_PARENT_APP);\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_STORAGE,\n\t\t\tPropsValues.MODULE_FRAMEWORK_STATE_DIR);\n\n\t\tCodeSource codeSource = clazz.getProtectionDomain().getCodeSource();\n\n\t\tURL location = codeSource.getLocation();\n\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.OSGI_FRAMEWORK, location.toExternalForm());\n\n\t\tFile frameworkFile = new File(location.getFile());\n\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.OSGI_INSTALL_AREA, frameworkFile.getParent());\n\n\t\tProperties extraProperties = PropsUtil.getProperties(\n\t\t\tPropsKeys.MODULE_FRAMEWORK_PROPERTIES, true);\n\n\t\tfor (Map.Entry<Object, Object> entry : extraProperties.entrySet()) {\n\t\t\tString key = (String)entry.getKey();\n\t\t\tString value = (String)entry.getValue();\n\n\t\t\t// We need to support an empty string and a null value distinctly.\n\t\t\t// This is due to some different behaviors between OSGi\n\t\t\t// implementations. If a property is passed as xyz= it will be\n\t\t\t// treated as an empty string. Otherwise, xyz=null will be treated\n\t\t\t// as an explicit null value.\n\n\t\t\tif (value.equals(StringPool.NULL)) {\n\t\t\t\tvalue = null;\n\t\t\t}\n\n\t\t\tproperties.put(key, value);\n\t\t}\n\n\t\tString systemPackagesExtra = _getSystemPackagesExtra();\n\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_SYSTEMPACKAGES_EXTRA, systemPackagesExtra);\n\n\t\treturn properties;\n\t}","id":32077,"modified_method":"private Map<String, String> _buildFrameworkProperties(Class<?> clazz) {\n\t\tMap<String, String> properties = new HashMap<String, String>();\n\n\t\tproperties.put(\n\t\t\tConstants.BUNDLE_DESCRIPTION, ReleaseInfo.getReleaseInfo());\n\t\tproperties.put(Constants.BUNDLE_NAME, ReleaseInfo.getName());\n\t\tproperties.put(Constants.BUNDLE_VENDOR, ReleaseInfo.getVendor());\n\t\tproperties.put(Constants.BUNDLE_VERSION, ReleaseInfo.getVersion());\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_DIR,\n\t\t\t_getFelixFileInstallDir());\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_LOG_LEVEL,\n\t\t\t_getFelixFileInstallLogLevel());\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_POLL,\n\t\t\tString.valueOf(PropsValues.MODULE_FRAMEWORK_AUTO_DEPLOY_INTERVAL));\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.FELIX_FILEINSTALL_TMPDIR,\n\t\t\tSystemProperties.get(SystemProperties.TMP_DIR));\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_BEGINNING_STARTLEVEL,\n\t\t\tString.valueOf(PropsValues.MODULE_FRAMEWORK_BEGINNING_START_LEVEL));\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_BUNDLE_PARENT,\n\t\t\tConstants.FRAMEWORK_BUNDLE_PARENT_APP);\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_STORAGE,\n\t\t\tPropsValues.MODULE_FRAMEWORK_STATE_DIR);\n\n\t\tProtectionDomain protectionDomain = clazz.getProtectionDomain();\n\n\t\tCodeSource codeSource = protectionDomain.getCodeSource();\n\n\t\tURL codeSourceURL = codeSource.getLocation();\n\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.OSGI_FRAMEWORK, codeSourceURL.toExternalForm());\n\n\t\tFile frameworkFile = new File(codeSourceURL.getFile());\n\n\t\tproperties.put(\n\t\t\tFrameworkPropsKeys.OSGI_INSTALL_AREA, frameworkFile.getParent());\n\n\t\tProperties extraProperties = PropsUtil.getProperties(\n\t\t\tPropsKeys.MODULE_FRAMEWORK_PROPERTIES, true);\n\n\t\tfor (Map.Entry<Object, Object> entry : extraProperties.entrySet()) {\n\t\t\tString key = (String)entry.getKey();\n\t\t\tString value = (String)entry.getValue();\n\n\t\t\t// We need to support an empty string and a null value distinctly.\n\t\t\t// This is due to some different behaviors between OSGi\n\t\t\t// implementations. If a property is passed as xyz= it will be\n\t\t\t// treated as an empty string. Otherwise, xyz=null will be treated\n\t\t\t// as an explicit null value.\n\n\t\t\tif (value.equals(StringPool.NULL)) {\n\t\t\t\tvalue = null;\n\t\t\t}\n\n\t\t\tproperties.put(key, value);\n\t\t}\n\n\t\tString systemPackagesExtra = _getSystemPackagesExtra();\n\n\t\tproperties.put(\n\t\t\tConstants.FRAMEWORK_SYSTEMPACKAGES_EXTRA, systemPackagesExtra);\n\n\t\treturn properties;\n\t}","commit_id":"9ecad982e7022f80f48e38bacedc00fc45e104b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doPut(DBBroker broker,IncomingMessage request,OutgoingMessage response)\n      throws BadRequestException,PermissionDeniedException,NotFoundException,EXistException\n   {\n      XmldbURI pathUri = XmldbURI.create(request.getPath());\n      String contentType = request.getHeader(\"Content-Type\");\n      String charset = getContext().getDefaultCharset();\n      \n      MimeType mime = MimeType.BINARY_TYPE;\n      if (contentType != null) {\n         int semicolon = contentType.indexOf(';');\n         if (semicolon>0) {\n            contentType = contentType.substring(0,semicolon).trim();\n         }\n         mime = MimeTable.getInstance().getContentType(contentType);\n         if (mime==null) {\n            mime = MimeType.BINARY_TYPE;\n         }\n         int equals = contentType.indexOf('=',semicolon);\n         if (equals>0) {\n            String param = contentType.substring(semicolon+1,equals).trim();\n            if (param.compareToIgnoreCase(\"charset=\")==0) {\n               charset = param.substring(equals+1).trim();\n            }\n         }\n      }\n      \n      if (mime.getName().equals(Atom.MIME_TYPE)) {\n         DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n         docFactory.setNamespaceAware(true);\n         DocumentBuilder docBuilder = null;\n         Document doc = null;\n         try {\n            InputSource src = new InputSource(new InputStreamReader(request.getInputStream(),charset));\n            docBuilder = docFactory.newDocumentBuilder();\n            doc = docBuilder.parse(src);\n         } catch (IOException e) {\n            LOG.warn(e);\n            throw new BadRequestException(e.getMessage());\n         } catch (SAXException e) {\n            LOG.warn(e);\n            throw new BadRequestException(e.getMessage());\n         } catch (ParserConfigurationException e) {\n            LOG.warn(e);\n            throw new BadRequestException(e.getMessage());\n         }\n         Element root = doc.getDocumentElement();\n         String ns = root.getNamespaceURI();\n         if (ns==null || !ns.equals(Atom.NAMESPACE_STRING)) {\n            throw new BadRequestException(\"Any content posted with the Atom mime type must be in the Atom namespace.\");\n         }\n         if (root.getLocalName().equals(\"feed\")) {\n            Collection collection = broker.getCollection(pathUri);\n            DocumentImpl feedDoc = collection.getDocument(broker,FEED_DOCUMENT_URI);\n            if (feedDoc==null) {\n               throw new BadRequestException(\"Collection at \"+request.getPath()+\" does not exist.\");\n            }\n            \n            if (DOM.findChild(root,Atom.NAMESPACE_STRING,\"title\")==null) {\n               throw new BadRequestException(\"The feed metadata sent does not contain a title.\");\n            }\n            \n            TransactionManager transact = broker.getBrokerPool().getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n\n            try {\n               feedDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n               \n               ElementImpl feedRoot = (ElementImpl)feedDoc.getDocumentElement();\n               \n               // Modify the feed by merging the new feed-level elements\n               mergeFeed(transaction,feedRoot,root,DateFormatter.toXSDDateTime(new Date()));\n               \n               // Store the feed\n               broker.storeXMLResource(transaction, feedDoc);\n               transact.commit(transaction);\n               response.setStatusCode(204);\n            } catch (LockException ex) {\n               transact.abort(transaction);\n               throw new EXistException(\"Cannot acquire write lock.\",ex);\n            } finally {\n               if (feedDoc!=null) {\n                  feedDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n               }\n            }\n         } else if (root.getLocalName().equals(\"entry\")) {\n            Collection collection = broker.getCollection(pathUri);\n            if (collection == null) {\n               throw new BadRequestException(\"Collection \"+request.getPath()+\" does not exist.\");\n            }\n            String id = request.getParameter(\"id\");\n            if (id==null) {\n               throw new BadRequestException(\"The 'id' parameter for the entry is missing.\");\n            }\n            LOG.debug(\"Updating entry \"+id+\" in collection \"+request.getPath());\n            DocumentImpl feedDoc = null;\n            TransactionManager transact = broker.getBrokerPool().getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            String currentDateTime = DateFormatter.toXSDDateTime(new Date());\n            try {\n               // Get the feed\n               LOG.debug(\"Acquiring lock on feed document...\");\n               feedDoc = collection.getDocument(broker,FEED_DOCUMENT_URI);\n               feedDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n\n               // Find the entry\n               FindEntry finder = new FindEntry(id);\n               DOM.findChildren(feedDoc.getDocumentElement(),Atom.NAMESPACE_STRING,\"entry\",finder);\n               Element entry = finder.getEntry();\n               mergeEntry(transaction,(ElementImpl)entry,root,currentDateTime);\n\n               // Update the feed time\n               DOMDB.replaceTextElement(transaction,(ElementImpl)feedDoc.getDocumentElement(),Atom.NAMESPACE_STRING,\"updated\",currentDateTime,true);\n\n               // Store the feed\n               broker.storeXMLResource(transaction, feedDoc);\n               transact.commit(transaction);\n               \n               // Send back the changed entry\n               response.setStatusCode(200);\n               response.setContentType(Atom.MIME_TYPE+\"; charset=\"+charset);\n               OutputStreamWriter w = new OutputStreamWriter(response.getOutputStream(),charset);\n               Transformer identity = TransformerFactory.newInstance().newTransformer();\n               identity.transform(new DOMSource(entry),new StreamResult(w));\n               w.flush();\n               w.close();\n            } catch (LockException ex) {\n               transact.abort(transaction);\n               throw new EXistException(\"Cannot acquire write lock.\",ex);\n            } catch (IOException ex) {\n               throw new EXistException(\"I/O exception during serialization of entry response.\",ex);\n            } catch (TransformerException ex) {\n               throw new EXistException(\"Serialization error.\",ex);\n            } finally {\n               if (feedDoc!=null) {\n                  feedDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n               }\n            }\n         } else {\n            throw new BadRequestException(\"Unexpected element: {http://www.w3.org/2005/Atom}\"+root.getLocalName());\n         }\n      } else {\n         TransactionManager transact = broker.getBrokerPool().getTransactionManager();\n         Txn transaction = transact.beginTransaction();\n         try {\n            XmldbURI docUri = pathUri.lastSegment();\n            XmldbURI collUri = pathUri.removeLastSegment();\n            \n            if (docUri==null || collUri==null) {\n               transact.abort(transaction);\n               throw new BadRequestException(\"The path is not valid: \" + request.getPath());\n            }\n            Collection collection = broker.getCollection(collUri);\n            if (collection == null) {\n               transact.abort(transaction);\n               throw new BadRequestException(\"The collection does not exist: \" + collUri);\n            }\n            if (collection.getDocument(broker,docUri)==null) {\n               transact.abort(transaction);\n               throw new BadRequestException(\"Resource \"+docUri+\" does not exist in collection \"+collUri);\n            }\n            \n            File tempFile = storeInTemporaryFile(request.getInputStream(),request.getContentLength());\n            \n            if (mime.isXMLType()) {\n               InputStream is = new FileInputStream(tempFile);\n               IndexInfo info = collection.validateXMLResource(transaction, broker, docUri, new InputSource(new InputStreamReader(is,charset)));\n               is.close();\n               info.getDocument().getMetadata().setMimeType(contentType);\n               is = new FileInputStream(tempFile);\n               collection.store(transaction, broker, info, new InputSource(new InputStreamReader(is,charset)), false);\n               is.close();\n            } else {\n               \n               FileInputStream is = new FileInputStream(tempFile);\n               collection.addBinaryResource(transaction, broker, docUri, is, contentType, (int) tempFile.length());\n               is.close();\n            }\n            transact.commit(transaction);\n            \n            // TODO: Change the entry updated and send back the change?\n            response.setStatusCode(200);\n            \n         } catch (IOException ex) {\n            transact.abort(transaction);\n            throw new EXistException(\"I/O error while handling temporary files.\",ex);\n         } catch (SAXParseException e) {\n            transact.abort(transaction);\n            throw new BadRequestException(\"Parsing exception at \"\n                    + e.getLineNumber() + \"/\" + e.getColumnNumber() + \": \"\n                    + e.toString());\n         } catch (SAXException e) {\n            transact.abort(transaction);\n            Exception o = e.getException();\n            if (o == null)\n               o = e;\n            throw new BadRequestException(\"Parsing exception: \"\n                    + o.getMessage());\n         } catch (TriggerException e) {\n            transact.abort(transaction);\n            throw new PermissionDeniedException(e.getMessage());\n         } catch (LockException e) {\n            transact.abort(transaction);\n            throw new PermissionDeniedException(e.getMessage());\n         }\n      }\n   }","id":32078,"modified_method":"public void doPut(DBBroker broker,IncomingMessage request,OutgoingMessage response)\n      throws BadRequestException,PermissionDeniedException,NotFoundException,EXistException\n   {\n      XmldbURI pathUri = XmldbURI.create(request.getPath());\n      String contentType = request.getHeader(\"Content-Type\");\n      String charset = getContext().getDefaultCharset();\n      \n      MimeType mime = MimeType.BINARY_TYPE;\n      if (contentType != null) {\n         int semicolon = contentType.indexOf(';');\n         if (semicolon>0) {\n            contentType = contentType.substring(0,semicolon).trim();\n         }\n         mime = MimeTable.getInstance().getContentType(contentType);\n         if (mime==null) {\n            mime = MimeType.BINARY_TYPE;\n         }\n         int equals = contentType.indexOf('=',semicolon);\n         if (equals>0) {\n            String param = contentType.substring(semicolon+1,equals).trim();\n            if (param.compareToIgnoreCase(\"charset=\")==0) {\n               charset = param.substring(equals+1).trim();\n            }\n         }\n      }\n      \n      if (mime.getName().equals(Atom.MIME_TYPE)) {\n         DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n         docFactory.setNamespaceAware(true);\n         DocumentBuilder docBuilder = null;\n         Document doc = null;\n         try {\n            InputSource src = new InputSource(new InputStreamReader(request.getInputStream(),charset));\n            docBuilder = docFactory.newDocumentBuilder();\n            doc = docBuilder.parse(src);\n         } catch (IOException e) {\n            LOG.warn(e);\n            throw new BadRequestException(e.getMessage());\n         } catch (SAXException e) {\n            LOG.warn(e);\n            throw new BadRequestException(e.getMessage());\n         } catch (ParserConfigurationException e) {\n            LOG.warn(e);\n            throw new BadRequestException(e.getMessage());\n         }\n         Element root = doc.getDocumentElement();\n         String ns = root.getNamespaceURI();\n         if (ns==null || !ns.equals(Atom.NAMESPACE_STRING)) {\n            throw new BadRequestException(\"Any content posted with the Atom mime type must be in the Atom namespace.\");\n         }\n         if (root.getLocalName().equals(\"feed\")) {\n            Collection collection = broker.getCollection(pathUri);\n            DocumentImpl feedDoc = collection.getDocument(broker,FEED_DOCUMENT_URI);\n            if (feedDoc==null) {\n               throw new BadRequestException(\"Collection at \"+request.getPath()+\" does not exist.\");\n            }\n            \n            if (DOM.findChild(root,Atom.NAMESPACE_STRING,\"title\")==null) {\n               throw new BadRequestException(\"The feed metadata sent does not contain a title.\");\n            }\n            \n            TransactionManager transact = broker.getBrokerPool().getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n\n            try {\n               feedDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n               \n               ElementImpl feedRoot = (ElementImpl)feedDoc.getDocumentElement();\n               \n               // Modify the feed by merging the new feed-level elements\n               mergeFeed(broker,transaction,feedRoot,root,DateFormatter.toXSDDateTime(new Date()));\n               \n               // Store the feed\n               broker.storeXMLResource(transaction, feedDoc);\n               transact.commit(transaction);\n               response.setStatusCode(204);\n            } catch (LockException ex) {\n               transact.abort(transaction);\n               throw new EXistException(\"Cannot acquire write lock.\",ex);\n            } catch (RuntimeException ex) {\n               transact.abort(transaction);\n               throw ex;\n            } finally {\n               if (feedDoc!=null) {\n                  feedDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n               }\n            }\n         } else if (root.getLocalName().equals(\"entry\")) {\n            Collection collection = broker.getCollection(pathUri);\n            if (collection == null) {\n               throw new BadRequestException(\"Collection \"+request.getPath()+\" does not exist.\");\n            }\n            String id = request.getParameter(\"id\");\n            if (id==null) {\n               throw new BadRequestException(\"The 'id' parameter for the entry is missing.\");\n            }\n            LOG.debug(\"Updating entry \"+id+\" in collection \"+request.getPath());\n            DocumentImpl feedDoc = null;\n            TransactionManager transact = broker.getBrokerPool().getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            String currentDateTime = DateFormatter.toXSDDateTime(new Date());\n            try {\n               // Get the feed\n               LOG.debug(\"Acquiring lock on feed document...\");\n               feedDoc = collection.getDocument(broker,FEED_DOCUMENT_URI);\n               feedDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n\n               // Find the entry\n               FindEntry finder = new FindEntry(id);\n               DOM.findChildren(feedDoc.getDocumentElement(),Atom.NAMESPACE_STRING,\"entry\",finder);\n               Element entry = finder.getEntry();\n               mergeEntry(transaction,(ElementImpl)entry,root,currentDateTime);\n\n               // Update the feed time\n               DOMDB.replaceTextElement(transaction,(ElementImpl)feedDoc.getDocumentElement(),Atom.NAMESPACE_STRING,\"updated\",currentDateTime,true);\n\n               // Store the feed\n               broker.storeXMLResource(transaction, feedDoc);\n               transact.commit(transaction);\n               \n               // Send back the changed entry\n               response.setStatusCode(200);\n               response.setContentType(Atom.MIME_TYPE+\"; charset=\"+charset);\n               OutputStreamWriter w = new OutputStreamWriter(response.getOutputStream(),charset);\n               Transformer identity = TransformerFactory.newInstance().newTransformer();\n               identity.transform(new DOMSource(entry),new StreamResult(w));\n               w.flush();\n               w.close();\n            } catch (LockException ex) {\n               transact.abort(transaction);\n               throw new EXistException(\"Cannot acquire write lock.\",ex);\n            } catch (IOException ex) {\n               throw new EXistException(\"I/O exception during serialization of entry response.\",ex);\n            } catch (TransformerException ex) {\n               throw new EXistException(\"Serialization error.\",ex);\n            } finally {\n               if (feedDoc!=null) {\n                  feedDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n               }\n            }\n         } else {\n            throw new BadRequestException(\"Unexpected element: {http://www.w3.org/2005/Atom}\"+root.getLocalName());\n         }\n      } else {\n         TransactionManager transact = broker.getBrokerPool().getTransactionManager();\n         Txn transaction = transact.beginTransaction();\n         try {\n            XmldbURI docUri = pathUri.lastSegment();\n            XmldbURI collUri = pathUri.removeLastSegment();\n            \n            if (docUri==null || collUri==null) {\n               transact.abort(transaction);\n               throw new BadRequestException(\"The path is not valid: \" + request.getPath());\n            }\n            Collection collection = broker.getCollection(collUri);\n            if (collection == null) {\n               transact.abort(transaction);\n               throw new BadRequestException(\"The collection does not exist: \" + collUri);\n            }\n            if (collection.getDocument(broker,docUri)==null) {\n               transact.abort(transaction);\n               throw new BadRequestException(\"Resource \"+docUri+\" does not exist in collection \"+collUri);\n            }\n            \n            File tempFile = storeInTemporaryFile(request.getInputStream(),request.getContentLength());\n            \n            if (mime.isXMLType()) {\n               InputStream is = new FileInputStream(tempFile);\n               IndexInfo info = collection.validateXMLResource(transaction, broker, docUri, new InputSource(new InputStreamReader(is,charset)));\n               is.close();\n               info.getDocument().getMetadata().setMimeType(contentType);\n               is = new FileInputStream(tempFile);\n               collection.store(transaction, broker, info, new InputSource(new InputStreamReader(is,charset)), false);\n               is.close();\n            } else {\n               \n               FileInputStream is = new FileInputStream(tempFile);\n               collection.addBinaryResource(transaction, broker, docUri, is, contentType, (int) tempFile.length());\n               is.close();\n            }\n            transact.commit(transaction);\n            \n            // TODO: Change the entry updated and send back the change?\n            response.setStatusCode(200);\n            \n         } catch (IOException ex) {\n            transact.abort(transaction);\n            throw new EXistException(\"I/O error while handling temporary files.\",ex);\n         } catch (SAXParseException e) {\n            transact.abort(transaction);\n            throw new BadRequestException(\"Parsing exception at \"\n                    + e.getLineNumber() + \"/\" + e.getColumnNumber() + \": \"\n                    + e.toString());\n         } catch (SAXException e) {\n            transact.abort(transaction);\n            Exception o = e.getException();\n            if (o == null)\n               o = e;\n            throw new BadRequestException(\"Parsing exception: \"\n                    + o.getMessage());\n         } catch (TriggerException e) {\n            transact.abort(transaction);\n            throw new PermissionDeniedException(e.getMessage());\n         } catch (LockException e) {\n            transact.abort(transaction);\n            throw new PermissionDeniedException(e.getMessage());\n         }\n      }\n   }","commit_id":"29b3709e6504a1f9303cd282e45a2f0c10f9f146","url":"https://github.com/eXist-db/exist"},{"original_method":"public void mergeEntry(final Txn transaction,final ElementImpl target,Element source,final String updated) {\n      final List toRemove = new ArrayList();\n      DOM.forEachChild(target,new NodeHandler() {\n         public void process(Node parent, Node child) {\n            if (child.getNodeType()==Node.ELEMENT_NODE) {\n               String ns = child.getNamespaceURI();\n               if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n                  String lname = child.getLocalName();\n                  if (lname.equals(\"updated\")) {\n                     // Changed updated\n                     DOMDB.replaceText(transaction,(ElementImpl)child,updated);\n                  } else if (lname.equals(\"link\")) {\n                     String rel = ((Element)child).getAttribute(\"rel\");\n                     if (!rel.equals(\"edit\") && !rel.equals(\"edit-media\")) {\n                        // remove it\n                        toRemove.add(child);\n                     }\n                  } else if (!lname.equals(\"id\") && !lname.equals(\"published\")) {\n                     // remove it\n                     toRemove.add(child);\n                  }\n               } else {\n                  // remove it\n                  toRemove.add(child);\n               }\n            } else {\n               toRemove.add(child);\n            }\n         }\n      });\n      for (Iterator childrenToRemove = toRemove.iterator(); childrenToRemove.hasNext(); ) {\n         Node child = (Node)childrenToRemove.next();\n         target.removeChild(transaction,child);\n      }\n      final Document ownerDocument = target.getOwnerDocument();\n      DOM.forEachChild(source,new NodeHandler() {\n         public void process(Node parent,Node child) {\n            if (child.getNodeType()==Node.ELEMENT_NODE) {\n               String ns = child.getNamespaceURI();\n               if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n                  String lname = child.getLocalName();\n                  \n                  // Skip server controls updated, published, and id elements\n                  if (lname.equals(\"updated\") ||\n                      lname.equals(\"published\") ||\n                      lname.equals(\"id\")) {\n                     return;\n                  }\n                  // Skip the edit link relations\n                  if (lname.equals(\"link\")) {\n                     String rel = ((Element)child).getAttribute(\"rel\");\n                     if (!rel.equals(\"edit\") && !rel.equals(\"edit-media\")) {\n                        return;\n                     }\n                  }\n               }\n               DOMDB.appendChild(transaction,target,child);\n               DOMDB.appendChild(transaction,target,ownerDocument.createTextNode(\"\\n\"));\n            }\n         }\n      });\n   }","id":32079,"modified_method":"public void mergeEntry(final Txn transaction,final ElementImpl target,Element source,final String updated) {\n      final List toRemove = new ArrayList();\n      DOM.forEachChild(target,new NodeHandler() {\n         public void process(Node parent, Node child) {\n            if (child.getNodeType()==Node.ELEMENT_NODE) {\n               String ns = child.getNamespaceURI();\n               if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n                  String lname = child.getLocalName();\n                  if (lname.equals(\"updated\")) {\n                     // Changed updated\n                     DOMDB.replaceText(transaction,(ElementImpl)child,updated);\n                  } else if (lname.equals(\"link\")) {\n                     String rel = ((Element)child).getAttribute(\"rel\");\n                     if (!rel.equals(\"edit\") && !rel.equals(\"edit-media\")) {\n                        // remove it\n                        toRemove.add(child);\n                     }\n                  } else if (!lname.equals(\"id\") && !lname.equals(\"published\")) {\n                     // remove it\n                     toRemove.add(child);\n                  }\n               } else {\n                  // remove it\n                  toRemove.add(child);\n               }\n            } else {\n               toRemove.add(child);\n            }\n         }\n      });\n      for (Iterator childrenToRemove = toRemove.iterator(); childrenToRemove.hasNext(); ) {\n         Node child = (Node)childrenToRemove.next();\n         target.removeChild(transaction,child);\n      }\n      final Document ownerDocument = target.getOwnerDocument();\n      DOM.forEachChild(source,new NodeHandler() {\n         public void process(Node parent,Node child) {\n            if (child.getNodeType()==Node.ELEMENT_NODE) {\n               String ns = child.getNamespaceURI();\n               if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n                  String lname = child.getLocalName();\n                  \n                  // Skip server controls updated, published, and id elements\n                  if (lname.equals(\"updated\") ||\n                      lname.equals(\"published\") ||\n                      lname.equals(\"id\")) {\n                     return;\n                  }\n                  // Skip the edit link relations\n                  if (lname.equals(\"link\")) {\n                     String rel = ((Element)child).getAttribute(\"rel\");\n                     if (!rel.equals(\"edit\") && !rel.equals(\"edit-media\")) {\n                        return;\n                     }\n                  }\n               }\n               DOMDB.appendChild(transaction,target,child);\n            }\n         }\n      });\n   }","commit_id":"29b3709e6504a1f9303cd282e45a2f0c10f9f146","url":"https://github.com/eXist-db/exist"},{"original_method":"public void mergeFeed(final Txn transaction,final ElementImpl target,Element source,final String updated) {\n      final List toRemove = new ArrayList();\n      DOM.forEachChild(target,new NodeHandler() {\n         public void process(Node parent, Node child) {\n            if (child.getNodeType()==Node.ELEMENT_NODE) {\n               String ns = child.getNamespaceURI();\n               if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n                  String lname = child.getLocalName();\n                  if (lname.equals(\"updated\")) {\n                     // Changed updated\n                     DOMDB.replaceText(transaction,(ElementImpl)child,updated);\n                  } else if (lname.equals(\"link\")) {\n                     Element echild = (Element)child;\n                     String rel = echild.getAttribute(\"rel\");\n                     if (!rel.equals(\"edit\")) {\n                        // remove it\n                        toRemove.add(child);\n                     }\n                  } else if (!lname.equals(\"id\") && !lname.equals(\"published\") && !lname.equals(\"entry\")) {\n                     // remove it\n                     toRemove.add(child);\n                  }\n               } else {\n                  // remove it\n                  toRemove.add(child);\n               }\n            } else {\n               toRemove.add(child);\n            }\n         }\n      });\n      for (Iterator childrenToRemove = toRemove.iterator(); childrenToRemove.hasNext(); ) {\n         Node child = (Node)childrenToRemove.next();\n         target.removeChild(transaction,child);\n      }\n      final Document ownerDocument = target.getOwnerDocument();\n      NodeList nl = source.getChildNodes();\n      Element firstEntry = DOM.findChild(target,Atom.NAMESPACE_STRING,\"entry\");\n      for (int i=0; i<nl.getLength(); i++) {\n         Node child = nl.item(i);\n         if (child.getNodeType()==Node.ELEMENT_NODE) {\n            String ns = child.getNamespaceURI();\n            if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n               String lname = child.getLocalName();\n\n               // Skip server controls updated, published, and id elements\n               if (lname.equals(\"updated\") ||\n                   lname.equals(\"published\") ||\n                   lname.equals(\"id\")) {\n                  continue;\n               }\n               // Skip the edit link relations\n               if (lname.equals(\"link\")) {\n                  String rel = ((Element)child).getAttribute(\"rel\");\n                  if (rel.equals(\"edit\")) {\n                     continue;\n                  }\n               }\n            }\n            if (firstEntry==null) {\n               DOMDB.appendChild(transaction,target,child);\n               DOMDB.appendChild(transaction,target,ownerDocument.createTextNode(\"\\n\"));\n            } else {\n               DOMDB.insertBefore(transaction,target,child,firstEntry);\n               DOMDB.insertBefore(transaction,target,ownerDocument.createTextNode(\"\\n\"),firstEntry);\n               // TODO: this is a total hack.  Somehow, the insertion order is wrong due to firstEntry changing position\n               firstEntry = DOM.findChild(target,Atom.NAMESPACE_STRING,\"entry\");\n            }\n         }\n      }\n   }","id":32080,"modified_method":"public void mergeFeed(final DBBroker broker,final Txn transaction,final ElementImpl target,Element source,final String updated) {\n      final DocumentImpl ownerDocument = (DocumentImpl)target.getOwnerDocument();\n      final List toRemove = new ArrayList();\n      DOM.forEachChild(target,new NodeHandler() {\n         public void process(Node parent, Node child) {\n            if (child.getNodeType()==Node.ELEMENT_NODE) {\n               String ns = child.getNamespaceURI();\n               if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n                  String lname = child.getLocalName();\n                  if (lname.equals(\"updated\")) {\n                     // Changed updated\n                     DOMDB.replaceText(transaction,(ElementImpl)child,updated);\n                  } else if (lname.equals(\"link\")) {\n                     Element echild = (Element)child;\n                     String rel = echild.getAttribute(\"rel\");\n                     if (!rel.equals(\"edit\")) {\n                        // remove it\n                        toRemove.add(child);\n                     }\n                  } else if (!lname.equals(\"id\") && !lname.equals(\"published\") && !lname.equals(\"entry\")) {\n                     // remove it\n                     toRemove.add(child);\n                  }\n               } else {\n                  // remove it\n                  toRemove.add(child);\n               }\n            } else {\n               toRemove.add(child);\n            }\n         }\n      });\n      for (Iterator childrenToRemove = toRemove.iterator(); childrenToRemove.hasNext(); ) {\n         Node child = (Node)childrenToRemove.next();\n         target.removeChild(transaction,child);\n      }\n      NodeList nl = source.getChildNodes();\n      NodeListener firstEntry = null;\n      Element theFirstEntry = DOM.findChild(target,Atom.NAMESPACE_STRING,\"entry\");\n      if (theFirstEntry!=null) {\n         firstEntry = new NodeListener((StoredNode)theFirstEntry);\n         ownerDocument.getMetadata().setIndexListener(firstEntry);\n      }\n      for (int i=0; i<nl.getLength(); i++) {\n         Node child = nl.item(i);\n         if (child.getNodeType()==Node.ELEMENT_NODE) {\n            String ns = child.getNamespaceURI();\n            if (ns!=null && ns.equals(Atom.NAMESPACE_STRING)) {\n               String lname = child.getLocalName();\n\n               // Skip server controls updated, published, and id elements\n               if (lname.equals(\"updated\") ||\n                   lname.equals(\"published\") ||\n                   lname.equals(\"id\")) {\n                  continue;\n               }\n               // Skip the edit link relations\n               if (lname.equals(\"link\")) {\n                  String rel = ((Element)child).getAttribute(\"rel\");\n                  if (rel.equals(\"edit\")) {\n                     continue;\n                  }\n               }\n            }\n            if (firstEntry==null) {\n               DOMDB.appendChild(transaction,target,child);\n            } else {\n               DOMDB.insertBefore(transaction,target,child,firstEntry.node);\n            }\n         }\n      }\n      ownerDocument.getMetadata().clearIndexListener();\n      ownerDocument.getMetadata().setLastModified(System.currentTimeMillis());\n   }","commit_id":"29b3709e6504a1f9303cd282e45a2f0c10f9f146","url":"https://github.com/eXist-db/exist"},{"original_method":"public URI getNodeUri() throws XQException\n\t{\n\t\ttry\n\t\t{\n\t\t\tNodeValue n = (NodeValue)item.convertTo(Type.NODE);\n\t\t\tDocument doc = n.getOwnerDocument();\n\t\t\tif(doc != null)\n\t\t\t{\n\t\t\t\tString documentURI = n.getOwnerDocument().getDocumentURI();\n\t\t\t\tif(documentURI != null)\n\t\t\t\t{\n\t\t\t\t\treturn new URI(documentURI);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t\t\n\t\t}\n\t\tcatch(XPathException xpe)\n\t\t{\n\t\t\tthrow new XQException(xpe.getMessage());\n\t\t}\n\t\tcatch(URISyntaxException use)\n\t\t{\n\t\t\tthrow new XQException(use.getMessage());\n\t\t}\n\t}","id":32081,"modified_method":"public URI getNodeUri() throws XQException\n\t{\n\t\ttry\n\t\t{\n\t\t\tNodeValue n = (NodeValue)item.convertTo(Type.NODE);\n\t\t\tDocument doc = n.getOwnerDocument();\n\t\t\tif(doc != null)\n\t\t\t{\n                           /*\n\t\t\t\tString documentURI = n.getOwnerDocument().getDocumentURI();\n                            */\n                           String documentURI = null;\n                           try {\n                              Method method = Document.class.getMethod(\"getDocumentURI\",null);\n                              documentURI = (String)method.invoke(n.getOwnerDocument(),null);\n                           } catch (NoSuchMethodException ex) {\n                           } catch (IllegalAccessException ex) {\n                           } catch (InvocationTargetException ex) {\n                           }\n\t\t\t\tif(documentURI != null)\n\t\t\t\t{\n\t\t\t\t\treturn new URI(documentURI);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t\t\n\t\t}\n\t\tcatch(XPathException xpe)\n\t\t{\n\t\t\tthrow new XQException(xpe.getMessage());\n\t\t}\n\t\tcatch(URISyntaxException use)\n\t\t{\n\t\t\tthrow new XQException(use.getMessage());\n\t\t}\n\t}","commit_id":"403ca9034642544cbd0f83f281549897dd05a6b3","url":"https://github.com/eXist-db/exist"},{"original_method":"public URI getNodeUri() throws XQException\n\t{\n\t\ttry\n\t\t{\n\t\t\tNodeValue n = (NodeValue)item.convertTo(Type.NODE);\n\t\t\tDocument doc = n.getOwnerDocument();\n\t\t\tif(doc != null)\n\t\t\t{\n\t\t\t\tString documentURI = n.getOwnerDocument().getDocumentURI();\n\t\t\t\tif(documentURI != null)\n\t\t\t\t{\n\t\t\t\t\treturn new URI(documentURI);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t\t\n\t\t}\n\t\tcatch(XPathException xpe)\n\t\t{\n\t\t\tthrow new XQException(xpe.getMessage());\n\t\t}\n\t\tcatch(URISyntaxException use)\n\t\t{\n\t\t\tthrow new XQException(use.getMessage());\n\t\t}\n\t}","id":32082,"modified_method":"public URI getNodeUri() throws XQException\n\t{\n\t\ttry\n\t\t{\n\t\t\tNodeValue n = (NodeValue)item.convertTo(Type.NODE);\n\t\t\tDocument doc = n.getOwnerDocument();\n\t\t\tif(doc != null)\n\t\t\t{\n                           /*\n\t\t\t\tString documentURI = n.getOwnerDocument().getDocumentURI();\n                            */\n                           String documentURI = null;\n                           try {\n                              Method method = Document.class.getMethod(\"getDocumentURI\",null);\n                              documentURI = (String)method.invoke(n.getOwnerDocument(),null);\n                           } catch (Exception ex) {\n                              throw new XQException(ex.getMessage());\n                           }\n\t\t\t\tif(documentURI != null)\n\t\t\t\t{\n\t\t\t\t\treturn new URI(documentURI);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t\t\n\t\t}\n\t\tcatch(XPathException xpe)\n\t\t{\n\t\t\tthrow new XQException(xpe.getMessage());\n\t\t}\n\t\tcatch(URISyntaxException use)\n\t\t{\n\t\t\tthrow new XQException(use.getMessage());\n\t\t}\n\t}","commit_id":"c8ae1a0dfddace2b0024b7304688a1f94b4b9061","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public Object multiply(Object a, Object b) {\n\n        if (a == null || b == null) {\n            return null;\n        }\n\n        switch (typeCode) {\n\n            case Types.SQL_REAL :\n            case Types.SQL_FLOAT :\n            case Types.SQL_DOUBLE : {\n                double ad = ((Number) a).doubleValue();\n                double bd = ((Number) b).doubleValue();\n\n                return ValuePool.getDouble(Double.doubleToLongBits(ad * bd));\n            }\n            case Types.SQL_NUMERIC :\n            case Types.SQL_DECIMAL : {\n                a = convertToDefaultType(null, a);\n                b = convertToDefaultType(null, b);\n\n                BigDecimal abd = (BigDecimal) a;\n                BigDecimal bbd = (BigDecimal) b;\n\n                return abd.multiply(bbd);\n            }\n            case Types.TINYINT :\n            case Types.SQL_SMALLINT :\n            case Types.SQL_INTEGER : {\n                int ai = ((Number) a).intValue();\n                int bi = ((Number) b).intValue();\n\n                return ValuePool.getInt(ai * bi);\n            }\n            case Types.SQL_BIGINT : {\n                long longa = ((Number) a).longValue();\n                long longb = ((Number) b).longValue();\n\n                return ValuePool.getLong(longa * longb);\n            }\n            default :\n                throw Error.runtimeError(ErrorCode.U_S0500, \"NumberType\");\n        }\n    }","id":32083,"modified_method":"@Override\n    public Object multiply(Object a, Object b) {\n\n        if (a == null || b == null) {\n            return null;\n        }\n\n        switch (typeCode) {\n\n            case Types.SQL_REAL :\n            case Types.SQL_FLOAT :\n            case Types.SQL_DOUBLE : {\n                double ad = ((Number) a).doubleValue();\n                double bd = ((Number) b).doubleValue();\n\n                return ValuePool.getDouble(Double.doubleToLongBits(ad * bd));\n            }\n            case Types.SQL_NUMERIC :\n            case Types.SQL_DECIMAL : {\n                a = convertToDefaultType(null, a);\n                b = convertToDefaultType(null, b);\n\n                BigDecimal abd = (BigDecimal) a;\n                BigDecimal bbd = (BigDecimal) b;\n\n                // VOLTDB changed for fixed decimal scale ... return abd.multiply(bbd);\n                BigDecimal cbd = abd.multiply(bbd);\n                // This replicates VoltDecimalHelper.setDefaultScale(cbd);\n                // without the library dependency.\n                return cbd.setScale(12 /* == VoltDecimalHelper.kDefaultScale*/,\n                                    java.math.RoundingMode.HALF_EVEN);\n                // ... VOLTDB changed\n            }\n            case Types.TINYINT :\n            case Types.SQL_SMALLINT :\n            case Types.SQL_INTEGER : {\n                int ai = ((Number) a).intValue();\n                int bi = ((Number) b).intValue();\n\n                return ValuePool.getInt(ai * bi);\n            }\n            case Types.SQL_BIGINT : {\n                long longa = ((Number) a).longValue();\n                long longb = ((Number) b).longValue();\n\n                return ValuePool.getLong(longa * longb);\n            }\n            default :\n                throw Error.runtimeError(ErrorCode.U_S0500, \"NumberType\");\n        }\n    }","commit_id":"7b995913a6bec179bc283fd880961df1c3d14c46","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Convert the given value to the type given, if possible.\n     *\n     * This function is in the performance path, so some effort has been made to order\n     * the giant string of branches such that most likely things are first, and that\n     * if the type is already correct, it should move very quickly through the logic.\n     * Some clarity has been sacrificed for performance, but perfect clarity is pretty\n     * elusive with complicated logic like this anyway.\n     *\n     * @throws Exception with a message describing why the types are incompatible.\n     */\n    public static Object tryToMakeCompatible(final Class<?> expectedClz, final Object param)\n    throws Exception\n    {\n        // uncomment for debugging\n        /*System.err.printf(\"Converting %s of type %s to type %s\\n\",\n                String.valueOf(param),\n                param == null ? \"NULL\" : param.getClass().getName(),\n                paramType.getName());\n        System.err.flush();*/\n\n        // Get blatant null out of the way fast, as it avoids some inline checks\n        // There are some suble null values that aren't java null coming up, but wait until\n        // after the basics to check for those.\n        if (param == null) {\n            return nullValueForType(expectedClz);\n        }\n\n        Class<?> inputClz = param.getClass();\n\n        // If we make it through this first block, memoize a number value for some range checks later\n        Number numberParam = null;\n\n        // This first code block tries to hit as many common cases as possible\n        // Specifically, it does primitive types and strings, which are the most common param types.\n        // Downconversions (e.g. long => short) happen later, but can use the memoized numberParam value.\n        // Notice this block switches on the type of the given value (different later).\n\n        if (inputClz == Long.class) {\n            if (expectedClz == long.class) return param;\n            if ((Long) param == VoltType.NULL_BIGINT) return nullValueForType(expectedClz);\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Integer.class) {\n            if (expectedClz == int.class) return param;\n            if ((Integer) param == VoltType.NULL_INTEGER) return nullValueForType(expectedClz);\n            if (expectedClz == long.class) return ((Integer) param).longValue();\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Short.class) {\n            if (expectedClz == short.class) return param;\n            if ((Short) param == VoltType.NULL_SMALLINT) return nullValueForType(expectedClz);\n            if (expectedClz == long.class) return ((Short) param).longValue();\n            if (expectedClz == int.class) return ((Short) param).intValue();\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Byte.class) {\n            if (expectedClz == byte.class) return param;\n            if ((Byte) param == VoltType.NULL_TINYINT) return nullValueForType(expectedClz);\n            if (expectedClz == long.class) return ((Byte) param).longValue();\n            if (expectedClz == int.class) return ((Byte) param).intValue();\n            if (expectedClz == short.class) return ((Byte) param).shortValue();\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Double.class) {\n            if (expectedClz == double.class) return param;\n            if ((Double) param == VoltType.NULL_FLOAT) return nullValueForType(expectedClz);\n        }\n        else if (inputClz == String.class) {\n            if (((String) param).equals(VoltTable.CSV_NULL)) return nullValueForType(expectedClz);\n            else if (expectedClz == String.class) return param;\n            // Hack allows hex-encoded strings to be passed into byte[] params\n            else if (expectedClz == byte[].class) {\n                return Encoder.hexDecode((String) param);\n            }\n            // We allow all values to be passed as strings for csv loading, json, etc...\n            // This code handles primitive types. Complex types come later.\n            if (expectedClz.isPrimitive()) {\n                return convertStringToPrimitive((String) param, expectedClz);\n            }\n        }\n        else if (inputClz == byte[].class) {\n            if (expectedClz == byte[].class) return param;\n            // allow byte arrays to be passed into string parameters\n            else if (expectedClz == String.class) {\n                String value = new String((byte[]) param, Charsets.UTF_8);\n                if (value.equals(VoltTable.CSV_NULL)) return nullValueForType(expectedClz);\n                else return value;\n            }\n        }\n        // null sigil\n        else if (param == VoltType.NULL_STRING_OR_VARBINARY) {\n            return nullValueForType(expectedClz);\n        }\n        // null sigil\n        else if (param == VoltType.NULL_DECIMAL) {\n            return nullValueForType(expectedClz);\n        }\n        // these are used by system procedures and are ignored here\n        else if (param instanceof SystemProcedureExecutionContext) {\n            return param;\n        }\n\n        // make sure we get the array/scalar match\n        if (expectedClz.isArray() != inputClz.isArray()) {\n            throw new Exception(String.format(\"Array / Scalar parameter mismatch (%s to %s)\",\n                    inputClz.getName(), expectedClz.getName()));\n        }\n\n        // handle arrays in a factored-out method\n        if (expectedClz.isArray()) {\n            return tryToMakeCompatibleArray(expectedClz.getComponentType(), inputClz.getComponentType(), param);\n        }\n\n        // The following block switches on the type of the paramter desired.\n        // It handles all of the paths not trapped in the code above. We can assume\n        // values are not null and that most sane primitive stuff has been handled.\n        // Downcasting is handled here (e.g. long => short).\n        // Time (in many forms) and Decimal are also handled below.\n\n        if ((expectedClz == int.class) && (numberParam != null)) {\n            long val = numberParam.longValue();\n            if (val == VoltType.NULL_INTEGER) {\n                throw new Exception(\"tryToMakeCompatible: The provided long value: (\"\n                        + param.toString() + \") might be interpreted as integer null. \" +\n                                \"Try explicitly using a int parameter.\");\n            }\n            // if it's in the right range, crop the value and return\n            if ((val <= Integer.MAX_VALUE) && (val >= Integer.MIN_VALUE))\n                return numberParam.intValue();\n        }\n        else if ((expectedClz == short.class) && (numberParam != null)) {\n            if ((inputClz == Long.class) || (inputClz == Integer.class)) {\n                long val = numberParam.longValue();\n                if (val == VoltType.NULL_SMALLINT) {\n                    throw new Exception(\"tryToMakeCompatible: The provided int or long value: (\"\n                            + param.toString() + \") might be interpreted as smallint null. \" +\n                                    \"Try explicitly using a short parameter.\");\n                }\n                // if it's in the right range, crop the value and return\n                if ((val <= Short.MAX_VALUE) && (val >= Short.MIN_VALUE))\n                    return numberParam.shortValue();\n            }\n        }\n        else if ((expectedClz == byte.class) && (numberParam != null)) {\n            if ((inputClz == Long.class) || (inputClz == Integer.class) || (inputClz == Short.class)) {\n                long val = numberParam.longValue();\n                if (val == VoltType.NULL_TINYINT) {\n                    throw new Exception(\"tryToMakeCompatible: The provided short, int or long value: (\"\n                            + param.toString() + \") might be interpreted as tinyint null. \" +\n                                    \"Try explicitly using a byte parameter.\");\n                }\n                // if it's in the right range, crop the value and return\n                if ((val <= Byte.MAX_VALUE) && (val >= Byte.MIN_VALUE))\n                    return numberParam.byteValue();\n            }\n        }\n        else if ((expectedClz == double.class) && (numberParam != null)) {\n            return numberParam.doubleValue();\n        }\n        else if (expectedClz == TimestampType.class) {\n            if (inputClz == Long.class) return new TimestampType((Long)param); // null values safe\n            if (inputClz == TimestampType.class) return param;\n            if (inputClz == Date.class) return new TimestampType((Date) param);\n            // if a string is given for a date, use java's JDBC parsing\n            if (inputClz == String.class) {\n                String longtime = ((String) param).trim();\n                try {\n                    return new TimestampType(Long.parseLong(longtime));\n                } catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n                try {\n                    return new TimestampType(longtime);\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n            }\n        }\n        else if (expectedClz == java.sql.Timestamp.class) {\n            if (param instanceof java.sql.Timestamp) return param;\n            if (param instanceof java.util.Date) return new java.sql.Timestamp(((java.util.Date) param).getTime());\n            if (param instanceof TimestampType) return ((TimestampType) param).asJavaTimestamp();\n            // If a string is given for a date, use java's JDBC parsing.\n            if (inputClz == String.class) {\n                String longtime = ((String) param).trim();\n                try {\n                    return new java.sql.Timestamp(Long.parseLong(longtime));\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n                try {\n                    return java.sql.Timestamp.valueOf(longtime);\n                } catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n\n            }\n        }\n        else if (expectedClz == java.sql.Date.class) {\n            if (param instanceof java.sql.Date) return param; // covers java.sql.Date and java.sql.Timestamp\n            if (param instanceof java.util.Date) return new java.sql.Date(((java.util.Date) param).getTime());\n            if (param instanceof TimestampType) return ((TimestampType) param).asExactJavaSqlDate();\n            // If a string is given for a date, use java's JDBC parsing.\n            if (inputClz == String.class) {\n                try {\n                    return new java.sql.Date(TimestampType.millisFromJDBCformat((String) param));\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n            }\n        }\n        else if (expectedClz == java.util.Date.class) {\n            if (param instanceof java.util.Date) return param; // covers java.sql.Date and java.sql.Timestamp\n            if (param instanceof TimestampType) return ((TimestampType) param).asExactJavaDate();\n            // If a string is given for a date, use the default format parser for the default locale.\n            if (inputClz == String.class) {\n                try {\n                    return new java.util.Date(TimestampType.millisFromJDBCformat((String) param));\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n            }\n        }\n        else if (expectedClz == BigDecimal.class) {\n            if (numberParam != null) {\n                BigInteger bi = new BigInteger(param.toString());\n                BigDecimal bd = new BigDecimal(bi);\n                bd = bd.setScale(12, BigDecimal.ROUND_HALF_EVEN);\n                return bd;\n            }\n            if (inputClz == BigDecimal.class) {\n                BigDecimal bd = (BigDecimal) param;\n                bd = bd.setScale(12 ,BigDecimal.ROUND_HALF_EVEN);\n                return bd;\n            }\n            if (expectedClz == BigDecimal.class) {\n                return VoltDecimalHelper.deserializeBigDecimalFromString((String) param);\n            }\n        }\n        else if (expectedClz == VoltTable.class && inputClz == VoltTable.class) {\n            return param;\n        }\n\n        throw new Exception(\n                \"tryToMakeCompatible: The provided value: (\" + param.toString() + \") of type: \" + inputClz.getName() +\n                \" is not a match or is out of range for the target parameter type: \" + expectedClz.getName());\n    }","id":32084,"modified_method":"/**\n     * Convert the given value to the type given, if possible.\n     *\n     * This function is in the performance path, so some effort has been made to order\n     * the giant string of branches such that most likely things are first, and that\n     * if the type is already correct, it should move very quickly through the logic.\n     * Some clarity has been sacrificed for performance, but perfect clarity is pretty\n     * elusive with complicated logic like this anyway.\n     *\n     * @throws Exception with a message describing why the types are incompatible.\n     */\n    public static Object tryToMakeCompatible(final Class<?> expectedClz, final Object param)\n    throws Exception\n    {\n        // uncomment for debugging\n        /*System.err.printf(\"Converting %s of type %s to type %s\\n\",\n                String.valueOf(param),\n                param == null ? \"NULL\" : param.getClass().getName(),\n                paramType.getName());\n        System.err.flush();*/\n\n        // Get blatant null out of the way fast, as it avoids some inline checks\n        // There are some suble null values that aren't java null coming up, but wait until\n        // after the basics to check for those.\n        if (param == null) {\n            return nullValueForType(expectedClz);\n        }\n\n        Class<?> inputClz = param.getClass();\n\n        // If we make it through this first block, memoize a number value for some range checks later\n        Number numberParam = null;\n\n        // This first code block tries to hit as many common cases as possible\n        // Specifically, it does primitive types and strings, which are the most common param types.\n        // Downconversions (e.g. long => short) happen later, but can use the memoized numberParam value.\n        // Notice this block switches on the type of the given value (different later).\n\n        if (inputClz == Long.class) {\n            if (expectedClz == long.class) return param;\n            if ((Long) param == VoltType.NULL_BIGINT) return nullValueForType(expectedClz);\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Integer.class) {\n            if (expectedClz == int.class) return param;\n            if ((Integer) param == VoltType.NULL_INTEGER) return nullValueForType(expectedClz);\n            if (expectedClz == long.class) return ((Integer) param).longValue();\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Short.class) {\n            if (expectedClz == short.class) return param;\n            if ((Short) param == VoltType.NULL_SMALLINT) return nullValueForType(expectedClz);\n            if (expectedClz == long.class) return ((Short) param).longValue();\n            if (expectedClz == int.class) return ((Short) param).intValue();\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Byte.class) {\n            if (expectedClz == byte.class) return param;\n            if ((Byte) param == VoltType.NULL_TINYINT) return nullValueForType(expectedClz);\n            if (expectedClz == long.class) return ((Byte) param).longValue();\n            if (expectedClz == int.class) return ((Byte) param).intValue();\n            if (expectedClz == short.class) return ((Byte) param).shortValue();\n            numberParam = (Number) param;\n        }\n        else if (inputClz == Double.class) {\n            if (expectedClz == double.class) return param;\n            if ((Double) param == VoltType.NULL_FLOAT) return nullValueForType(expectedClz);\n        }\n        else if (inputClz == String.class) {\n            if (((String) param).equals(VoltTable.CSV_NULL)) return nullValueForType(expectedClz);\n            else if (expectedClz == String.class) return param;\n            // Hack allows hex-encoded strings to be passed into byte[] params\n            else if (expectedClz == byte[].class) {\n                return Encoder.hexDecode((String) param);\n            }\n            // We allow all values to be passed as strings for csv loading, json, etc...\n            // This code handles primitive types. Complex types come later.\n            if (expectedClz.isPrimitive()) {\n                return convertStringToPrimitive((String) param, expectedClz);\n            }\n        }\n        else if (inputClz == byte[].class) {\n            if (expectedClz == byte[].class) return param;\n            // allow byte arrays to be passed into string parameters\n            else if (expectedClz == String.class) {\n                String value = new String((byte[]) param, Charsets.UTF_8);\n                if (value.equals(VoltTable.CSV_NULL)) return nullValueForType(expectedClz);\n                else return value;\n            }\n        }\n        // null sigil\n        else if (param == VoltType.NULL_STRING_OR_VARBINARY) {\n            return nullValueForType(expectedClz);\n        }\n        // null sigil\n        else if (param == VoltType.NULL_DECIMAL) {\n            return nullValueForType(expectedClz);\n        }\n        // these are used by system procedures and are ignored here\n        else if (param instanceof SystemProcedureExecutionContext) {\n            return param;\n        }\n\n        // make sure we get the array/scalar match\n        if (expectedClz.isArray() != inputClz.isArray()) {\n            throw new Exception(String.format(\"Array / Scalar parameter mismatch (%s to %s)\",\n                    inputClz.getName(), expectedClz.getName()));\n        }\n\n        // handle arrays in a factored-out method\n        if (expectedClz.isArray()) {\n            return tryToMakeCompatibleArray(expectedClz.getComponentType(), inputClz.getComponentType(), param);\n        }\n\n        // The following block switches on the type of the paramter desired.\n        // It handles all of the paths not trapped in the code above. We can assume\n        // values are not null and that most sane primitive stuff has been handled.\n        // Downcasting is handled here (e.g. long => short).\n        // Time (in many forms) and Decimal are also handled below.\n\n        if ((expectedClz == int.class) && (numberParam != null)) {\n            long val = numberParam.longValue();\n            if (val == VoltType.NULL_INTEGER) {\n                throw new Exception(\"tryToMakeCompatible: The provided long value: (\"\n                        + param.toString() + \") might be interpreted as integer null. \" +\n                                \"Try explicitly using a int parameter.\");\n            }\n            // if it's in the right range, crop the value and return\n            if ((val <= Integer.MAX_VALUE) && (val >= Integer.MIN_VALUE))\n                return numberParam.intValue();\n        }\n        else if ((expectedClz == short.class) && (numberParam != null)) {\n            if ((inputClz == Long.class) || (inputClz == Integer.class)) {\n                long val = numberParam.longValue();\n                if (val == VoltType.NULL_SMALLINT) {\n                    throw new Exception(\"tryToMakeCompatible: The provided int or long value: (\"\n                            + param.toString() + \") might be interpreted as smallint null. \" +\n                                    \"Try explicitly using a short parameter.\");\n                }\n                // if it's in the right range, crop the value and return\n                if ((val <= Short.MAX_VALUE) && (val >= Short.MIN_VALUE))\n                    return numberParam.shortValue();\n            }\n        }\n        else if ((expectedClz == byte.class) && (numberParam != null)) {\n            if ((inputClz == Long.class) || (inputClz == Integer.class) || (inputClz == Short.class)) {\n                long val = numberParam.longValue();\n                if (val == VoltType.NULL_TINYINT) {\n                    throw new Exception(\"tryToMakeCompatible: The provided short, int or long value: (\"\n                            + param.toString() + \") might be interpreted as tinyint null. \" +\n                                    \"Try explicitly using a byte parameter.\");\n                }\n                // if it's in the right range, crop the value and return\n                if ((val <= Byte.MAX_VALUE) && (val >= Byte.MIN_VALUE))\n                    return numberParam.byteValue();\n            }\n        }\n        else if ((expectedClz == double.class) && (numberParam != null)) {\n            return numberParam.doubleValue();\n        }\n        else if (expectedClz == TimestampType.class) {\n            if (inputClz == Long.class) return new TimestampType((Long)param); // null values safe\n            if (inputClz == TimestampType.class) return param;\n            if (inputClz == Date.class) return new TimestampType((Date) param);\n            // if a string is given for a date, use java's JDBC parsing\n            if (inputClz == String.class) {\n                String longtime = ((String) param).trim();\n                try {\n                    return new TimestampType(Long.parseLong(longtime));\n                } catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n                try {\n                    return new TimestampType(longtime);\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n            }\n        }\n        else if (expectedClz == java.sql.Timestamp.class) {\n            if (param instanceof java.sql.Timestamp) return param;\n            if (param instanceof java.util.Date) return new java.sql.Timestamp(((java.util.Date) param).getTime());\n            if (param instanceof TimestampType) return ((TimestampType) param).asJavaTimestamp();\n            // If a string is given for a date, use java's JDBC parsing.\n            if (inputClz == String.class) {\n                String longtime = ((String) param).trim();\n                try {\n                    return new java.sql.Timestamp(Long.parseLong(longtime));\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n                try {\n                    return java.sql.Timestamp.valueOf(longtime);\n                } catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n\n            }\n        }\n        else if (expectedClz == java.sql.Date.class) {\n            if (param instanceof java.sql.Date) return param; // covers java.sql.Date and java.sql.Timestamp\n            if (param instanceof java.util.Date) return new java.sql.Date(((java.util.Date) param).getTime());\n            if (param instanceof TimestampType) return ((TimestampType) param).asExactJavaSqlDate();\n            // If a string is given for a date, use java's JDBC parsing.\n            if (inputClz == String.class) {\n                try {\n                    return new java.sql.Date(TimestampType.millisFromJDBCformat((String) param));\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n            }\n        }\n        else if (expectedClz == java.util.Date.class) {\n            if (param instanceof java.util.Date) return param; // covers java.sql.Date and java.sql.Timestamp\n            if (param instanceof TimestampType) return ((TimestampType) param).asExactJavaDate();\n            // If a string is given for a date, use the default format parser for the default locale.\n            if (inputClz == String.class) {\n                try {\n                    return new java.util.Date(TimestampType.millisFromJDBCformat((String) param));\n                }\n                catch (IllegalArgumentException e) {\n                    // Defer errors to the generic Exception throw below, if it's not the right format\n                }\n            }\n        }\n        else if (expectedClz == BigDecimal.class) {\n            if (numberParam != null) {\n                BigInteger bi = new BigInteger(param.toString());\n                BigDecimal bd = new BigDecimal(bi);\n                bd = VoltDecimalHelper.setDefaultScale(bd);\n                return bd;\n            }\n            if (inputClz == BigDecimal.class) {\n                BigDecimal bd = (BigDecimal) param;\n                bd = VoltDecimalHelper.setDefaultScale(bd);\n                return bd;\n            }\n            if (expectedClz == BigDecimal.class) {\n                return VoltDecimalHelper.deserializeBigDecimalFromString((String) param);\n            }\n        }\n        else if (expectedClz == VoltTable.class && inputClz == VoltTable.class) {\n            return param;\n        }\n\n        throw new Exception(\n                \"tryToMakeCompatible: The provided value: (\" + param.toString() + \") of type: \" + inputClz.getName() +\n                \" is not a match or is out of range for the target parameter type: \" + expectedClz.getName());\n    }","commit_id":"7b995913a6bec179bc283fd880961df1c3d14c46","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Deserialize a Volt fixed precision and scale 16-byte decimal from a String representation\n     * @param decimal <code>String<\/code> representation of the decimal\n     */\n    public static BigDecimal deserializeBigDecimalFromString(String decimal) throws IOException\n    {\n        if (decimal == null) {\n            return null;\n        }\n        BigDecimal bd = new BigDecimal(decimal);\n        // enforce scale 12 to make the precision check right\n        if (bd.scale() < 12) {\n            bd.setScale(12);\n        }\n        // if the scale is too large, check for trailing zeros\n        if (bd.scale() > 12) {\n            bd = bd.stripTrailingZeros();\n            if (bd.scale() > 12) {\n                throw new IOException(\"Decimal \" + bd + \" has more then 12 digits of scale\");\n            }\n            // enforce scale 12 to make the precision check right\n            if (bd.scale() < 12) {\n                bd.setScale(12);\n            }\n        }\n        if (bd.precision() > 38) {\n            throw new RuntimeException(\"Decimal \" + bd + \" has more than  38 digits of precision.\");\n        }\n        return bd;\n    }","id":32085,"modified_method":"/**\n     * Deserialize a Volt fixed precision and scale 16-byte decimal from a String representation\n     * @param decimal <code>String<\/code> representation of the decimal\n     */\n    public static BigDecimal deserializeBigDecimalFromString(String decimal) throws IOException\n    {\n        if (decimal == null) {\n            return null;\n        }\n        BigDecimal bd = new BigDecimal(decimal);\n        // if the scale is too large, check for trailing zeros\n        if (bd.scale() > kDefaultScale) {\n            bd = bd.stripTrailingZeros();\n            if (bd.scale() > kDefaultScale) {\n                throw new IOException(\"Decimal \" + bd + \" has more than \" + kDefaultScale + \" digits of scale\");\n            }\n        }\n        // enforce scale 12 to make the precision check right\n        if (bd.scale() < kDefaultScale) {\n            bd = bd.setScale(kDefaultScale);\n        }\n        if (bd.precision() > 38) {\n            throw new RuntimeException(\n                    \"Decimal \" + bd + \" has more than \" + kDefaultPrecision + \" digits of precision.\");\n        }\n        return bd;\n    }","commit_id":"7b995913a6bec179bc283fd880961df1c3d14c46","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static Object getRandomValue(VoltType type, int maxSize, double nullFraction, Random r) {\n        assert(type != null);\n        assert(maxSize >= 0);\n        assert(nullFraction >= 0.0);\n        assert(nullFraction <= 1.0);\n        assert(r != null);\n\n        // return null for some fraction of requests\n        if (r.nextDouble() < nullFraction) {\n            return null;\n        }\n\n        Object ret = null;\n        switch (type) {\n            // --------------------------------\n            // INTEGERS\n            // --------------------------------\n            case TINYINT:\n                ret = Byte.valueOf((byte) Math.abs(r.nextInt() % 128));\n                break;\n            case SMALLINT:\n                ret = Short.valueOf((short) Math.abs(r.nextInt() % 32768));\n                break;\n            case INTEGER:\n                ret = Integer.valueOf(Math.abs(r.nextInt() % 100000));\n                break;\n            case BIGINT:\n                ret = Long.valueOf(Math.abs(r.nextInt() % 100000));\n                break;\n            // --------------------------------\n            // FLOATS\n            // --------------------------------\n            case FLOAT:\n                ret = Double.valueOf(Math.abs(r.nextDouble()));\n                break;\n            // --------------------------------\n            // STRINGS\n            // --------------------------------\n            case STRING: {\n                assert(maxSize > 0);\n                int size = r.nextInt(maxSize) + 1;\n                char[] str = new char[size];\n                for (int ctr = 0; ctr < size; ctr++) {\n                    char data = (char)(r.nextInt(128));\n                    //\n                    // Skip quotation marks\n                    //\n                    if (Character.isLetter(data) == false) {\n                       ctr--;\n                    } else {\n                       str[ctr] = data;\n                    }\n                 }\n                ret = new String(str);\n                break;\n            }\n            // --------------------------------\n            // VARBINARY\n            // --------------------------------\n            case VARBINARY: {\n                assert(maxSize > 0);\n                int size = r.nextInt(maxSize) + 1;\n                byte[] bytestr = new byte[size];\n                r.nextBytes(bytestr);\n                ret = bytestr;\n                break;\n            }\n            // --------------------------------\n            // TIMESTAMP\n            // --------------------------------\n            case TIMESTAMP: {\n                long timestamp = r.nextInt((int)(VoltTypeUtil.DATE_STOP - VoltTypeUtil.DATE_START)) + VoltTypeUtil.DATE_START;\n                ret = new TimestampType(Long.valueOf(timestamp * 1000));\n                break;\n            }\n            // --------------------------------\n            // DECIMAL\n            // --------------------------------\n            case DECIMAL: {\n                BigDecimal bd = new BigDecimal(r.nextDouble());\n                ret = bd.setScale(12, BigDecimal.ROUND_HALF_EVEN);\n                break;\n            }\n            // --------------------------------\n            // INVALID\n            // --------------------------------\n            default:\n                LOG.severe(\"ERROR: Unable to generate random value for invalid ValueType '\" + type + \"'\");\n        } // SWITCH\n        return (ret);\n    }","id":32086,"modified_method":"public static Object getRandomValue(VoltType type, int maxSize, double nullFraction, Random r) {\n        assert(type != null);\n        assert(maxSize >= 0);\n        assert(nullFraction >= 0.0);\n        assert(nullFraction <= 1.0);\n        assert(r != null);\n\n        // return null for some fraction of requests\n        if (r.nextDouble() < nullFraction) {\n            return null;\n        }\n\n        Object ret = null;\n        switch (type) {\n            // --------------------------------\n            // INTEGERS\n            // --------------------------------\n            case TINYINT:\n                ret = Byte.valueOf((byte) Math.abs(r.nextInt() % 128));\n                break;\n            case SMALLINT:\n                ret = Short.valueOf((short) Math.abs(r.nextInt() % 32768));\n                break;\n            case INTEGER:\n                ret = Integer.valueOf(Math.abs(r.nextInt() % 100000));\n                break;\n            case BIGINT:\n                ret = Long.valueOf(Math.abs(r.nextInt() % 100000));\n                break;\n            // --------------------------------\n            // FLOATS\n            // --------------------------------\n            case FLOAT:\n                ret = Double.valueOf(Math.abs(r.nextDouble()));\n                break;\n            // --------------------------------\n            // STRINGS\n            // --------------------------------\n            case STRING: {\n                assert(maxSize > 0);\n                int size = r.nextInt(maxSize) + 1;\n                char[] str = new char[size];\n                for (int ctr = 0; ctr < size; ctr++) {\n                    char data = (char)(r.nextInt(128));\n                    //\n                    // Skip quotation marks\n                    //\n                    if (Character.isLetter(data) == false) {\n                       ctr--;\n                    } else {\n                       str[ctr] = data;\n                    }\n                 }\n                ret = new String(str);\n                break;\n            }\n            // --------------------------------\n            // VARBINARY\n            // --------------------------------\n            case VARBINARY: {\n                assert(maxSize > 0);\n                int size = r.nextInt(maxSize) + 1;\n                byte[] bytestr = new byte[size];\n                r.nextBytes(bytestr);\n                ret = bytestr;\n                break;\n            }\n            // --------------------------------\n            // TIMESTAMP\n            // --------------------------------\n            case TIMESTAMP: {\n                long timestamp = r.nextInt((int)(VoltTypeUtil.DATE_STOP - VoltTypeUtil.DATE_START)) + VoltTypeUtil.DATE_START;\n                ret = new TimestampType(Long.valueOf(timestamp * 1000));\n                break;\n            }\n            // --------------------------------\n            // DECIMAL\n            // --------------------------------\n            case DECIMAL: {\n                BigDecimal bd = new BigDecimal(r.nextDouble());\n                ret = VoltDecimalHelper.setDefaultScale(bd);\n                break;\n            }\n            // --------------------------------\n            // INVALID\n            // --------------------------------\n            default:\n                LOG.severe(\"ERROR: Unable to generate random value for invalid ValueType '\" + type + \"'\");\n        } // SWITCH\n        return (ret);\n    }","commit_id":"7b995913a6bec179bc283fd880961df1c3d14c46","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static String formatStringAsPercentage(final String string) {\n\t\tif (StringUtils.isBlank(string)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal BigDecimal decimal = new BigDecimal(string);\n\t\tdecimal.setScale(2, RoundingMode.HALF_DOWN); // same as GradebookService\n\n\t\treturn formatDoubleAsPercentage(decimal.doubleValue());\n\t}","id":32087,"modified_method":"/**\n\t * Format the given string as a percentage with two decimal precision. String should be something that can be converted to a number.\n\t * \n\t * @param string string representation of the number\n\t * @return percentage to decimal places with a '%' for good measure\n\t */\n\tpublic static String formatStringAsPercentage(final String string) {\n\t\tif (StringUtils.isBlank(string)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal BigDecimal decimal = new BigDecimal(string).setScale(2, RoundingMode.HALF_DOWN);\n\n\t\treturn formatDoubleAsPercentage(decimal.doubleValue());\n\t}","commit_id":"cca6ca2acbfae6dad5d042b43d6a83966687e6c9","url":"https://github.com/sakaiproject/sakai"},{"original_method":"void setScaleOnChild(float parentScale, LWComponent c) {\n        if (DEBUG.LAYOUT) out(\"setScaleOnChild \" + parentScale + \"*\" + ChildScale + \" \" + c);\n        if (c instanceof LWImage) {\n            if (parentScale == 1f)\n                c.setScale(LWImage.ChildImageScale);\n            else\n                c.setScale(parentScale * (1f/ChildScale) * LWImage.ChildImageScale);\n        } else\n            c.setScale(parentScale * ChildScale);\n        //c.setScale(scale * mChildScale);\n    }","id":32088,"modified_method":"void setScaleOnChild(float parentScale, LWComponent c) {\n        if (DEBUG.LAYOUT) out(\"setScaleOnChild \" + parentScale + \"*\" + ChildScale + \" \" + c);\n        if (c instanceof LWImage) {\n            c.setScale(parentScale * LWImage.ChildImageScale);\n        } else {\n            c.setScale(parentScale * LWNode.ChildScale);\n        }\n    }","commit_id":"044d596825d528a037d5846a420ef3e32bc76351","url":"https://github.com/VUE/VUE"},{"original_method":"private void drawNode(DrawContext dc)\n    {\n        Graphics2D g = dc.g;\n        \n        //-------------------------------------------------------\n        // Fill the shape (if it's not transparent)\n        //-------------------------------------------------------\n        \n        if (isSelected() && dc.isInteractive()) {\n            LWPathway p = VUE.getActivePathway();\n            if (p != null && p.isVisible() && p.getCurrentNode() == this) {\n                // SPECIAL CASE:\n                // as the current element on the current pathway draws a huge\n                // semi-transparent stroke around it, skip drawing our fat \n                // transparent selection stroke on this node.  So we just\n                // do nothing here.\n            } else {\n                g.setColor(COLOR_HIGHLIGHT);\n                g.setStroke(new BasicStroke(getStrokeWidth() + SelectionStrokeWidth));\n                //g.setStroke(new BasicStroke(stroke.getLineWidth() + SelectionStrokeWidth));\n                g.draw(drawnShape);\n            }\n        }\n        \n        if (imageIcon != null) {\n            // experimental\n            //imageIcon.paintIcon(null, g, (int)getX(), (int)getY());\n            imageIcon.paintIcon(null, g, 0, 0);\n        } else if (dc.isPresenting() || isPresentationContext()) {\n            ; // do nothing: no fill\n        } else {\n            Color fillColor = getRenderFillColor();\n            if (fillColor != null) { // transparent if null\n                g.setColor(fillColor);\n                if (isZoomedFocus())\n                    g.setComposite(ZoomTransparency);\n                g.fill(drawnShape);\n                if (isZoomedFocus())\n                    g.setComposite(AlphaComposite.Src);\n            }\n        }\n\n        /*\n        if (!isAutoSized()) { // debug\n            g.setColor(Color.green);\n            g.setStroke(STROKE_ONE);\n            g.draw(drawnShape);\n        }\n        else if (false&&isRollover()) { // debug\n            // temporary debug\n            //g.setColor(new Color(0,0,128));\n            g.setColor(Color.blue);\n            g.draw(drawnShape);\n        }\n        else*/\n        \n        if (getStrokeWidth() > 0 && !isPresentationContext() && !dc.isPresenting()) {\n            //if (LWSelection.DEBUG_SELECTION && isSelected())\n            //if (isSelected())\n            //g.setColor(COLOR_SELECTION);\n            //else\n                g.setColor(getStrokeColor());\n            g.setStroke(this.stroke);\n            g.draw(drawnShape);\n        }\n\n\n        if (DEBUG.BOXES) {\n            dc.setAbsoluteStroke(0.5);\n            //if (hasChildren()) dc.g.draw(child_box);\n            if (false && _lastNodeContent != null && !mIsRectShape) {\n                dc.g.setColor(Color.darkGray);\n                dc.g.draw(_lastNodeContent);\n            } else {\n                dc.g.setColor(Color.blue);\n                dc.g.draw(this.drawnShape);\n            }\n        }\n            \n        //-------------------------------------------------------\n        // Draw the generated icon\n        //-------------------------------------------------------\n\n        drawNodeDecorations(dc);\n\n        // todo: create drawLabel, drawBorder & drawBody\n        // LWComponent methods so can automatically turn\n        // this off in MapViewer, adjust stroke color for\n        // selection, etc.\n        \n        // TODO BUG: label sometimes getting \"set\" w/out sending layout event --\n        // has to do with case where we pre-fill a textbox with \"label\", and\n        // if they type nothing we don't set a label, but that's not working\n        // entirely -- it manages to not trigger an update event, but somehow\n        // this.label is still getting set -- maybe we have to null it out\n        // manually (and maybe labelBox also)\n        \n        if (hasLabel() && this.labelBox != null && this.labelBox.getParent() == null) {\n            // if parent is not null, this box is an active edit on the map\n            // and we don't want to paint it here as AWT/Swing is handling\n            // that at the moment (and at a possibly slightly different offset)\n            float lx = relativeLabelX();\n            float ly = relativeLabelY();\n            g.translate(lx, ly);\n            //if (DEBUG.LAYOUT) System.out.println(\"*** \" + this + \" drawing label at \" + lx + \",\" + ly);\n            this.labelBox.draw(dc);\n            g.translate(-lx, -ly);\n\n            // todo: this (and in LWLink) is a hack -- can't we\n            // do this relative to the node?\n            //this.labelBox.setMapLocation(getX() + lx, getY() + ly);\n        }\n\n    }","id":32089,"modified_method":"protected void drawNode(DrawContext dc)\n    {\n        Graphics2D g = dc.g;\n        \n        //-------------------------------------------------------\n        // Fill the shape (if it's not transparent)\n        //-------------------------------------------------------\n        \n        if (isSelected() && dc.isInteractive()) {\n            LWPathway p = VUE.getActivePathway();\n            if (p != null && p.isVisible() && p.getCurrentNode() == this) {\n                // SPECIAL CASE:\n                // as the current element on the current pathway draws a huge\n                // semi-transparent stroke around it, skip drawing our fat \n                // transparent selection stroke on this node.  So we just\n                // do nothing here.\n            } else {\n                g.setColor(COLOR_HIGHLIGHT);\n                g.setStroke(new BasicStroke(getStrokeWidth() + SelectionStrokeWidth));\n                //g.setStroke(new BasicStroke(stroke.getLineWidth() + SelectionStrokeWidth));\n                g.draw(drawnShape);\n            }\n        }\n        \n        if (imageIcon != null) {\n            // experimental\n            //imageIcon.paintIcon(null, g, (int)getX(), (int)getY());\n            imageIcon.paintIcon(null, g, 0, 0);\n        } else if (false && (dc.isPresenting() || isPresentationContext())) { // old-style \"turn off the wrappers\"\n            ; // do nothing: no fill\n        } else {\n            Color fillColor = getRenderFillColor();\n            if (fillColor != null) { // transparent if null\n                g.setColor(fillColor);\n                if (isZoomedFocus())\n                    g.setComposite(ZoomTransparency);\n                g.fill(drawnShape);\n                if (isZoomedFocus())\n                    g.setComposite(AlphaComposite.Src);\n            }\n        }\n\n        /*\n        if (!isAutoSized()) { // debug\n            g.setColor(Color.green);\n            g.setStroke(STROKE_ONE);\n            g.draw(drawnShape);\n        }\n        else if (false&&isRollover()) { // debug\n            // temporary debug\n            //g.setColor(new Color(0,0,128));\n            g.setColor(Color.blue);\n            g.draw(drawnShape);\n        }\n        else*/\n        \n        if (getStrokeWidth() > 0 /*&& !isPresentationContext() && !dc.isPresenting()*/) { // old style \"turn off the wrappers\"\n            //if (LWSelection.DEBUG_SELECTION && isSelected())\n            //if (isSelected())\n            //g.setColor(COLOR_SELECTION);\n            //else\n                g.setColor(getStrokeColor());\n            g.setStroke(this.stroke);\n            g.draw(drawnShape);\n        }\n\n\n        if (DEBUG.BOXES) {\n            dc.setAbsoluteStroke(0.5);\n            //if (hasChildren()) dc.g.draw(child_box);\n            if (false && _lastNodeContent != null && !mIsRectShape) {\n                dc.g.setColor(Color.darkGray);\n                dc.g.draw(_lastNodeContent);\n            } else {\n                dc.g.setColor(Color.blue);\n                dc.g.draw(this.drawnShape);\n            }\n        }\n            \n        //-------------------------------------------------------\n        // Draw the generated icon\n        //-------------------------------------------------------\n\n        drawNodeDecorations(dc);\n\n        // todo: create drawLabel, drawBorder & drawBody\n        // LWComponent methods so can automatically turn\n        // this off in MapViewer, adjust stroke color for\n        // selection, etc.\n        \n        // TODO BUG: label sometimes getting \"set\" w/out sending layout event --\n        // has to do with case where we pre-fill a textbox with \"label\", and\n        // if they type nothing we don't set a label, but that's not working\n        // entirely -- it manages to not trigger an update event, but somehow\n        // this.label is still getting set -- maybe we have to null it out\n        // manually (and maybe labelBox also)\n        \n        if (hasLabel() && this.labelBox != null && this.labelBox.getParent() == null) {\n            // if parent is not null, this box is an active edit on the map\n            // and we don't want to paint it here as AWT/Swing is handling\n            // that at the moment (and at a possibly slightly different offset)\n            float lx = relativeLabelX();\n            float ly = relativeLabelY();\n            g.translate(lx, ly);\n            //if (DEBUG.LAYOUT) System.out.println(\"*** \" + this + \" drawing label at \" + lx + \",\" + ly);\n            this.labelBox.draw(dc);\n            g.translate(-lx, -ly);\n\n            // todo: this (and in LWLink) is a hack -- can't we\n            // do this relative to the node?\n            //this.labelBox.setMapLocation(getX() + lx, getY() + ly);\n        }\n\n    }","commit_id":"9cd6fd3bd677449380907a7d834915733e9e72a7","url":"https://github.com/VUE/VUE"},{"original_method":"private void drawNodeDecorations(DrawContext dc)\n    {\n        Graphics2D g = dc.g;\n\n        /*\n        if (DEBUG.BOXES && mIsRectShape) {\n            //-------------------------------------------------------\n            // paint a divider line\n            //-------------------------------------------------------\n            g.setColor(Color.gray);\n            dc.setAbsoluteStroke(0.5);\n            g.draw(dividerUnderline);\n            g.draw(dividerStub);\n        }\n        */\n            \n        //-------------------------------------------------------\n        // paint the node icons\n        //-------------------------------------------------------\n\n        if (!dc.isPresenting() && iconShowing()) {\n            mIconBlock.draw(dc);\n            // draw divider if there's a label\n            if (hasLabel()) {\n                final Color renderFill = getRenderFillColor();\n                final Color marginColor;\n                if (renderFill != null) {\n                    if (renderFill.equals(Color.black))\n                        marginColor = Color.darkGray;\n                    else\n                        marginColor = renderFill.darker();\n                } else {\n                    // transparent fill: base on stroke color\n                    marginColor = getStrokeColor().brighter();\n                }\n                g.setColor(marginColor);\n                g.setStroke(STROKE_ONE);\n                g.draw(mIconDivider);\n            }\n        }\n    }","id":32090,"modified_method":"private void drawNodeDecorations(DrawContext dc)\n    {\n        Graphics2D g = dc.g;\n\n        /*\n        if (DEBUG.BOXES && mIsRectShape) {\n            //-------------------------------------------------------\n            // paint a divider line\n            //-------------------------------------------------------\n            g.setColor(Color.gray);\n            dc.setAbsoluteStroke(0.5);\n            g.draw(dividerUnderline);\n            g.draw(dividerStub);\n        }\n        */\n            \n        //-------------------------------------------------------\n        // paint the node icons\n        //-------------------------------------------------------\n\n        if (/*!dc.isPresenting() &&*/ iconShowing()) {\n            mIconBlock.draw(dc);\n            // draw divider if there's a label\n            if (hasLabel()) {\n                final Color renderFill = getRenderFillColor();\n                final Color marginColor;\n                if (renderFill != null) {\n                    if (renderFill.equals(Color.black))\n                        marginColor = Color.darkGray;\n                    else\n                        marginColor = renderFill.darker();\n                } else {\n                    // transparent fill: base on stroke color\n                    marginColor = getStrokeColor().brighter();\n                }\n                g.setColor(marginColor);\n                g.setStroke(STROKE_ONE);\n                g.draw(mIconDivider);\n            }\n        }\n    }","commit_id":"9cd6fd3bd677449380907a7d834915733e9e72a7","url":"https://github.com/VUE/VUE"},{"original_method":"public void draw(DrawContext dc)\n    {\n        if (isFiltered() == false) {\n\n            super.drawPathwayDecorations(dc);\n            \n            dc.g.translate(getX(), getY());\n            float scale = getScale();\n            if (scale != 1f) dc.g.scale(scale, scale);\n\n            drawNode(dc);\n\n            //-------------------------------------------------------\n            // Restore graphics context\n            //-------------------------------------------------------\n            // todo arch: consider not restoring the scale before we draw the children, and maybe\n            // even handling this in LWContainer, as a way to see if we could get rid of all the\n            // confusing \"x * getScale()\" code & awkward recursive setScale code.  Actually, we\n            // couldn't attempt this unless we also fully changed the children be drawn in a\n            // translated GC, and the hit-detection was compensated for more at search time instead\n            // of by resizing the object by having getHeight, etc, auto multiply by the scale\n            // factor, and actually resizing the bounds-shape when we scale an object.\n            \n\n            if (scale != 1f) dc.g.scale(1/scale, 1/scale);\n            dc.g.translate(-getX(), -getY());\n        }\n\n        //-------------------------------------------------------\n        // Draw any children\n        //-------------------------------------------------------\n\n        // This produces the cleanest code in all above -- don't need to manage scaling if we\n        // translate to a region where all the nodes will lie within, and then their positioning\n        // auto-collapses as they're scaled down...\n\n        if (hasChildren()) {\n            //g.translate(childBaseX * ChildScale, childBaseY * ChildScale);\n            //g.scale(ChildScale, ChildScale);\n            //super.draw(dc.createScaled(ChildScale)); // not using this\n            //g.setComposite(childComposite);\n            if (isZoomedFocus())\n                dc.g.setComposite(ZoomTransparency);\n            super.drawChildren(dc);\n        }\n    }","id":32091,"modified_method":"protected void drawImpl(DrawContext dc)\n    {\n        if (isFiltered() == false) {\n\n            //super.drawPathwayDecorations(dc);\n            \n            dc.g.translate(getX(), getY());\n            float scale = getScale();\n            if (scale != 1f) dc.g.scale(scale, scale);\n\n            drawNode(dc);\n\n            //-------------------------------------------------------\n            // Restore graphics context\n            //-------------------------------------------------------\n            // todo arch: consider not restoring the scale before we draw the children, and maybe\n            // even handling this in LWContainer, as a way to see if we could get rid of all the\n            // confusing \"x * getScale()\" code & awkward recursive setScale code.  Actually, we\n            // couldn't attempt this unless we also fully changed the children be drawn in a\n            // translated GC, and the hit-detection was compensated for more at search time instead\n            // of by resizing the object by having getHeight, etc, auto multiply by the scale\n            // factor, and actually resizing the bounds-shape when we scale an object.\n            \n\n            if (scale != 1f) dc.g.scale(1/scale, 1/scale);\n            dc.g.translate(-getX(), -getY());\n        }\n\n        //-------------------------------------------------------\n        // Draw any children\n        //-------------------------------------------------------\n\n        // This produces the cleanest code in all above -- don't need to manage scaling if we\n        // translate to a region where all the nodes will lie within, and then their positioning\n        // auto-collapses as they're scaled down...\n\n        if (hasChildren()) {\n            //g.translate(childBaseX * ChildScale, childBaseY * ChildScale);\n            //g.scale(ChildScale, ChildScale);\n            //super.draw(dc.createScaled(ChildScale)); // not using this\n            //g.setComposite(childComposite);\n            if (isZoomedFocus())\n                dc.g.setComposite(ZoomTransparency);\n            super.drawChildren(dc);\n        }\n    }","commit_id":"9cd6fd3bd677449380907a7d834915733e9e72a7","url":"https://github.com/VUE/VUE"},{"original_method":"void setScaleOnChild(float parentScale, LWComponent c) {\n        if (DEBUG.LAYOUT) out(\"setScaleOnChild \" + parentScale + \"*\" + ChildScale + \" \" + c);\n        if (c instanceof LWImage) {\n            if (LWImage.RawImageSizes)\n                c.setScale(parentScale * LWImage.ChildImageScale);\n            else\n                c.setScale(parentScale);\n        } else {\n            c.setScale(parentScale * LWNode.ChildScale);\n        }\n    }","id":32092,"modified_method":"void setScaleOnChild(float parentScale, LWComponent c) {\n        if (DEBUG.LAYOUT) out(\"setScaleOnChild \" + parentScale + \"*\" + ChildScale + \" \" + c);\n        if (c instanceof LWImage) {\n//             if (LWImage.RawImageSizes)\n//                 c.setScale(parentScale * LWImage.ChildImageScale);\n//             else\n                c.setScale(parentScale);\n        } else {\n            c.setScale(parentScale * LWNode.ChildScale);\n        }\n    }","commit_id":"9cd6fd3bd677449380907a7d834915733e9e72a7","url":"https://github.com/VUE/VUE"},{"original_method":"protected void validateClaims(Client client, JwtClaims claims) {\n        validateIssuer(claims.getIssuer());\n        validateSubject(client, claims.getSubject());\n        validateAudience(client, claims.getAudience());\n        \n        // If we have no issued time then we need to have an expiry\n        boolean expiredRequired = claims.getIssuedAt() == null;\n        JwtUtils.validateJwtExpiry(claims, expiredRequired);\n        \n        JwtUtils.validateJwtNotBefore(claims, futureTTL, false);\n        \n        // If we have no expiry then we must have an issued at\n        boolean issuedAtRequired = claims.getExpiryTime() == null;\n        if (issuedAtRequired) {\n            JwtUtils.validateJwtTTL(claims, ttl, issuedAtRequired);\n        }\n    }","id":32093,"modified_method":"protected void validateClaims(Client client, JwtClaims claims) {\n        validateIssuer(claims.getIssuer());\n        validateSubject(client, claims.getSubject());\n        validateAudience(client, claims.getAudience());\n        \n        // If we have no issued time then we need to have an expiry\n        boolean expiredRequired = claims.getIssuedAt() == null;\n        JwtUtils.validateJwtExpiry(claims, clockOffset, expiredRequired);\n        \n        JwtUtils.validateJwtNotBefore(claims, clockOffset, false);\n        \n        // If we have no expiry then we must have an issued at\n        boolean issuedAtRequired = claims.getExpiryTime() == null;\n        JwtUtils.validateJwtIssuedAt(claims, ttl, clockOffset, issuedAtRequired);\n    }","commit_id":"0ca573916675d00cb2dc083ed1b0dba47a17d1ef","url":"https://github.com/apache/cxf"},{"original_method":"public static void validateJwtClaims(JwtClaims claims, int ttl, int futureTTL, Client c) {\n        validateJwtSubjectAndAudience(claims, c);\n        \n        // If we have no issued time then we need to have an expiry\n        boolean expiredRequired = claims.getIssuedAt() == null;\n        JwtUtils.validateJwtExpiry(claims, expiredRequired);\n        \n        JwtUtils.validateJwtNotBefore(claims, futureTTL, false);\n        \n        // If we have no expiry then we must have an issued at\n        boolean issuedAtRequired = claims.getExpiryTime() == null;\n        if (issuedAtRequired) {\n            JwtUtils.validateJwtTTL(claims, ttl, issuedAtRequired);\n        }\n    }","id":32094,"modified_method":"public static void validateJwtClaims(JwtClaims claims, int ttl, int clockOffset, Client c) {\n        validateJwtSubjectAndAudience(claims, c);\n        \n        // If we have no issued time then we need to have an expiry\n        boolean expiredRequired = claims.getIssuedAt() == null;\n        JwtUtils.validateJwtExpiry(claims, clockOffset, expiredRequired);\n        \n        JwtUtils.validateJwtNotBefore(claims, clockOffset, false);\n        \n        // If we have no expiry then we must have an issued at\n        boolean issuedAtRequired = claims.getExpiryTime() == null;\n        if (issuedAtRequired) {\n            JwtUtils.validateJwtIssuedAt(claims, ttl, clockOffset, issuedAtRequired);\n        }\n    }","commit_id":"0ca573916675d00cb2dc083ed1b0dba47a17d1ef","url":"https://github.com/apache/cxf"},{"original_method":"protected void validateJwtClaims(JwtClaims claims, String clientId, boolean validateClaimsAlways) {\n        // validate the issuer\n        String issuer = claims.getIssuer();\n        if (issuer == null && validateClaimsAlways) {\n            throw new SecurityException(\"Invalid provider\");\n        }\n        if (supportSelfIssuedProvider && issuerId == null \n            && issuer != null && SELF_ISSUED_ISSUER.equals(issuer)) {\n            //TODO: self-issued provider token validation\n        } else {\n            if (issuer != null && !issuer.equals(issuerId)) {\n                throw new SecurityException(\"Invalid provider\");\n            }\n            // validate subject\n            if (claims.getSubject() == null) {\n                throw new SecurityException(\"Invalid subject\");\n            }\n            // validate audience\n            String aud = claims.getAudience();\n            if (aud == null && validateClaimsAlways || aud != null && !clientId.equals(aud)) {\n                throw new SecurityException(\"Invalid audience\");\n            }\n    \n            // If we have no issued time then we need to have an expiry\n            boolean expiredRequired = claims.getIssuedAt() == null;\n            JwtUtils.validateJwtExpiry(claims, expiredRequired);\n            \n            JwtUtils.validateJwtNotBefore(claims, futureTTL, false);\n            \n            // If we have no expiry then we must have an issued at\n            boolean issuedAtRequired = claims.getExpiryTime() == null;\n            if (issuedAtRequired) {\n                JwtUtils.validateJwtTTL(claims, ttl, issuedAtRequired);\n            }\n        }\n    }","id":32095,"modified_method":"/**\n     * Validate core JWT claims\n     * @param claims the claims\n     * @param clientId OAuth2 client id\n     * @param validateClaimsAlways if set to true then enforce that the claims \n     *                             to be validated must be set\n     */\n    protected void validateJwtClaims(JwtClaims claims, String clientId, boolean validateClaimsAlways) {\n        // validate the issuer\n        String issuer = claims.getIssuer();\n        if (issuer == null && validateClaimsAlways) {\n            throw new SecurityException(\"Invalid provider\");\n        }\n        if (supportSelfIssuedProvider && issuerId == null \n            && issuer != null && SELF_ISSUED_ISSUER.equals(issuer)) {\n            //TODO: self-issued provider token validation\n        } else {\n            if (issuer != null && !issuer.equals(issuerId)) {\n                throw new SecurityException(\"Invalid provider\");\n            }\n            // validate subject\n            if (claims.getSubject() == null) {\n                throw new SecurityException(\"Invalid subject\");\n            }\n            // validate audience\n            String aud = claims.getAudience();\n            if (aud == null && validateClaimsAlways || aud != null && !clientId.equals(aud)) {\n                throw new SecurityException(\"Invalid audience\");\n            }\n    \n            // If strict time validation: if no issuedTime claim is set then an expiresAt claim must be set\n            // Otherwise: validate only if expiresAt claim is set\n            boolean expiredRequired = \n                validateClaimsAlways || strictTimeValidation && claims.getIssuedAt() == null;\n            JwtUtils.validateJwtExpiry(claims, clockOffset, expiredRequired);\n            \n            // If strict time validation: If no expiresAt claim is set then an issuedAt claim must be set\n            // Otherwise: validate only if issuedAt claim is set\n            boolean issuedAtRequired = \n                validateClaimsAlways || strictTimeValidation && claims.getExpiryTime() == null;\n            JwtUtils.validateJwtIssuedAt(claims, clockOffset, issuedAtRequired);\n            \n            if (strictTimeValidation) {\n                JwtUtils.validateJwtNotBefore(claims, clockOffset, strictTimeValidation);\n            }\n        }\n    }","commit_id":"8654f83ed145f3be4dabd19205491b7ec5e31a64","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void validateToken(JwtToken jwt) {\n        // If we have no issued time then we need to have an expiry\n        boolean expiredRequired = jwt.getClaims().getIssuedAt() == null;\n        JwtUtils.validateJwtExpiry(jwt.getClaims(), expiredRequired);\n        \n        JwtUtils.validateJwtNotBefore(jwt.getClaims(), futureTTL, false);\n        \n        // If we have no expiry then we must have an issued at\n        boolean issuedAtRequired = jwt.getClaims().getExpiryTime() == null;\n        if (issuedAtRequired) {\n            JwtUtils.validateJwtTTL(jwt.getClaims(), ttl, issuedAtRequired);\n        }\n    }","id":32096,"modified_method":"@Override\n    protected void validateToken(JwtToken jwt) {\n        // If we have no issued time then we need to have an expiry\n        boolean expiredRequired = jwt.getClaims().getIssuedAt() == null;\n        JwtUtils.validateJwtExpiry(jwt.getClaims(), clockOffset, expiredRequired);\n        \n        JwtUtils.validateJwtNotBefore(jwt.getClaims(), clockOffset, false);\n        \n        // If we have no expiry then we must have an issued at\n        boolean issuedAtRequired = jwt.getClaims().getExpiryTime() == null;\n        JwtUtils.validateJwtIssuedAt(jwt.getClaims(), clockOffset, issuedAtRequired);\n    }","commit_id":"8654f83ed145f3be4dabd19205491b7ec5e31a64","url":"https://github.com/apache/cxf"},{"original_method":"public static void validateJwtTTL(JwtClaims claims, int timeToLive, boolean claimRequired) {\n        Long issuedAtInSecs = claims.getIssuedAt();\n        if (issuedAtInSecs == null) {\n            if (claimRequired) {\n                throw new JwtException(\"Invalid issuedAt\");\n            }\n            return;\n        }\n        \n        Date validCreation = new Date();\n        Date createdDate = new Date(issuedAtInSecs * 1000L);\n        \n        int ttl = timeToLive;\n        if (ttl <= 0) {\n            ttl = 300;\n        }\n        \n        // Calculate the time that is allowed for the message to travel\n        long currentTime = validCreation.getTime();\n        currentTime -= (long)ttl * 1000L;\n        validCreation.setTime(currentTime);\n\n        // Validate the time it took the message to travel\n        if (createdDate.before(validCreation)) {\n            throw new JwtException(\"Invalid issuedAt\");\n        }\n    }","id":32097,"modified_method":"public static void validateJwtIssuedAt(JwtClaims claims, int clockOffset, boolean claimRequired) {\n        Long issuedAtInSecs = claims.getIssuedAt();\n        if (issuedAtInSecs == null) {\n            if (claimRequired) {\n                throw new JwtException(\"Invalid issuedAt\");\n            }\n            return;\n        }\n        \n        Date createdDate = new Date(issuedAtInSecs * 1000L);\n        if (clockOffset != 0) {\n            // Calculate the time that is allowed for the message to travel\n            createdDate.setTime(createdDate.getTime() - (long)clockOffset * 1000L);\n        }\n        \n        Date rightNow = new Date();\n\n        if (createdDate.after(rightNow)) {\n            throw new JwtException(\"Invalid issuedAt\");\n        }\n    }","commit_id":"8654f83ed145f3be4dabd19205491b7ec5e31a64","url":"https://github.com/apache/cxf"},{"original_method":"public static void validateJwtExpiry(JwtClaims claims, boolean claimRequired) {\n        Long expiryTime = claims.getExpiryTime();\n        if (expiryTime == null) {\n            if (claimRequired) {\n                throw new JwtException(\"The token has expired\");\n            }\n            return;\n        }\n        \n        Date rightNow = new Date();\n        Date expiresDate = new Date(expiryTime * 1000L);\n        if (expiresDate.before(rightNow)) {\n            throw new JwtException(\"The token has expired\");\n        }\n    }","id":32098,"modified_method":"public static void validateJwtExpiry(JwtClaims claims, int clockOffset, boolean claimRequired) {\n        Long expiryTime = claims.getExpiryTime();\n        if (expiryTime == null) {\n            if (claimRequired) {\n                throw new JwtException(\"The token has expired\");\n            }\n            return;\n        }\n        Date rightNow = new Date();\n        Date expiresDate = new Date(expiryTime * 1000L);\n        if (clockOffset != 0) {\n            expiresDate.setTime(expiresDate.getTime() + (long)clockOffset * 1000L);\n        }\n        if (expiresDate.before(rightNow)) {\n            throw new JwtException(\"The token has expired\");\n        }\n    }","commit_id":"8654f83ed145f3be4dabd19205491b7ec5e31a64","url":"https://github.com/apache/cxf"},{"original_method":"public static void validateJwtNotBefore(JwtClaims claims, int futureTimeToLive, boolean claimRequired) {\n        Long notBeforeTime = claims.getNotBefore();\n        \n        // If no NotBefore then just use the IssueAt if it exists\n        if (notBeforeTime == null && claims.getIssuedAt() != null) {\n            notBeforeTime = claims.getIssuedAt();\n        }\n        \n        if (notBeforeTime == null && claimRequired) {\n            throw new JwtException(\"The token cannot be accepted yet\");\n        }\n        \n        Date validCreation = new Date();\n        long currentTime = validCreation.getTime();\n        if (futureTimeToLive > 0) {\n            validCreation.setTime(currentTime + (long)futureTimeToLive * 1000L);\n        }\n        Date createdDate = new Date(notBeforeTime * 1000L);\n\n        // Check to see if the not before time is in the future\n        if (createdDate.after(validCreation)) {\n            throw new JwtException(\"The token cannot be accepted yet\");\n        }\n    }","id":32099,"modified_method":"public static void validateJwtNotBefore(JwtClaims claims, int clockOffset, boolean claimRequired) {\n        Long notBeforeTime = claims.getNotBefore();\n        if (notBeforeTime == null) {\n            if (claimRequired) {\n                throw new JwtException(\"The token cannot be accepted yet\");\n            }\n            return;\n        }\n        \n        Date validCreation = new Date();\n        long currentTime = validCreation.getTime();\n        if (clockOffset != 0) {\n            validCreation.setTime(currentTime + (long)clockOffset * 1000L);\n        }\n        Date notBeforeDate = new Date(notBeforeTime * 1000L);\n\n        // Check to see if the not before time is in the future\n        if (notBeforeDate.after(validCreation)) {\n            throw new JwtException(\"The token cannot be accepted yet\");\n        }\n    }","commit_id":"8654f83ed145f3be4dabd19205491b7ec5e31a64","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void sawOpcode(int seen) {\n        switch (seen) {\n        default:\n            break;\n        case Constants.IF_ICMPEQ:\n        case Constants.IF_ICMPNE:\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            if (bad(left, right) || bad(right, left))\n\n                accumulator.accumulateBug(new BugInstance(this, \"TESTING\", NORMAL_PRIORITY).addClassAndMethod(this)\n                        .addValueSource(left, this).addValueSource(right, this), this);\n            break;\n        }\n\n    }","id":32100,"modified_method":"@Override\n    public void sawOpcode(int seen) {\n        switch (seen) {\n        default:\n            break;\n        case Constants.IF_ICMPEQ:\n        case Constants.IF_ICMPNE:\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            if (bad(left, right) || bad(right, left))\n                accumulator.accumulateBug(new BugInstance(this, \"TESTING\", NORMAL_PRIORITY).addClassAndMethod(this)\n                        .addValueSource(left, this).addValueSource(right, this)\n                        .addString(\"Just check the sign of the result of compare or compareTo, not specific values such as 1 or -1\"), this);\n            break;\n        }\n\n    }","commit_id":"c386c4a415aa9c05ea6204f539f9ca1800e7c941","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName();\n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n        InvokeInstruction inv = (InvokeInstruction) handle.getInstruction();\n        MethodAnnotation calledMethodAnnotation = getMethodCalledAnnotation(cpg, inv);\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 1;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull())\n                        bugAccumulator.accumulateBug(\n                                new BugInstance(this, \"EC_NULL_ARG\", priority).addClassAndMethod(methodGen, sourceFile),\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            else if (calledMethodAnnotation != null && calledMethodAnnotation.getClassName().equals(\"org.testng.Assert\"))\n                return;\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n            return;\n        }\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            addEqualsCheck(lhsType_.getSignature(), handle.getPosition());\n            addEqualsCheck(rhsType_.getSignature(), handle.getPosition());\n        }\n\n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n\n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (true) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n\n                int priority = result.getPriority() + priorityModifier;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", priority)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets)\n                                .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","id":32101,"modified_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName();\n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n        InvokeInstruction inv = (InvokeInstruction) handle.getInstruction();\n        MethodAnnotation calledMethodAnnotation = getMethodCalledAnnotation(cpg, inv);\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 1;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull()) {\n                        String type = \"EC_NULL_ARG\";\n                        if (calledMethodAnnotation != null && calledMethodAnnotation.isStatic())\n                            type = \"DMI_DOH\";\n                        BugInstance bug = new BugInstance(this, type, priority + priorityModifier).addClassAndMethod(methodGen, sourceFile)\n                        .addOptionalAnnotation(calledMethodAnnotation);\n                        if (type.equals(\"DMI_DOH\"))\n                            bug.addString(\"Use \\\"== null\\\" to check for a value being null\");\n                        bugAccumulator.accumulateBug(\n                                bug,\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                    }\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            else if (calledMethodAnnotation != null && calledMethodAnnotation.getClassName().equals(\"org.testng.Assert\"))\n                return;\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n            return;\n        }\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            addEqualsCheck(lhsType_.getSignature(), handle.getPosition());\n            addEqualsCheck(rhsType_.getSignature(), handle.getPosition());\n        }\n\n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n\n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (true) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n\n                int priority = result.getPriority() + priorityModifier;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", priority)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets)\n                                .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","commit_id":"c386c4a415aa9c05ea6204f539f9ca1800e7c941","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void checkForSelfOperation(int opCode, String op) {\n        {\n\n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            OpcodeStack.Item item1 = stack.getStackItem(1);\n\n            if (item0.getSignature().equals(\"D\") || item0.getSignature().equals(\"F\"))\n                return;\n            if (item1.getSignature().equals(\"D\") || item1.getSignature().equals(\"F\"))\n                return;\n\n            XField field0 = item0.getXField();\n            XField field1 = item1.getXField();\n            int fr0 = item0.getFieldLoadedFromRegister();\n            int fr1 = item1.getFieldLoadedFromRegister();\n            if (field0 != null && field0.equals(field1) && fr0 != -1 && fr0 == fr1) {\n                int priority = NORMAL_PRIORITY;\n                if (field0.isVolatile())\n                    priority++;\n                BugInstance bug = new BugInstance(this, \"SA_FIELD_SELF_\" + op, priority)\n                        .addClassAndMethod(this).addField(field0);\n                \n                if (this.isMethodCall())\n                    bug.addCalledMethod(this);\n                bugAccumulator.accumulateBug(bug, this);\n            }\n\n            else if (opCode == IXOR && item0.equals(item1)) {\n                LocalVariableAnnotation localVariableAnnotation = LocalVariableAnnotation.getLocalVariableAnnotation(this, item0);\n                if (localVariableAnnotation != null)\n                    bugAccumulator.accumulateBug(\n                            new BugInstance(this, \"SA_LOCAL_SELF_\" + op, HIGH_PRIORITY).addClassAndMethod(this).add(\n                                    localVariableAnnotation), this);\n            } else if (false && opCode == ISUB && registerLoadCount >= 2) { // let\n                                                                   // FindSelfComparison2\n                                                                   // report\n                                                                   // this; more\n                                                                   // accurate\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"SA_LOCAL_SELF_\" + op, (opCode == ISUB || opCode == LSUB\n                                || opCode == INVOKEINTERFACE || opCode == INVOKEVIRTUAL) ? NORMAL_PRIORITY : HIGH_PRIORITY)\n                                .addClassAndMethod(this).add(\n                                        LocalVariableAnnotation.getLocalVariableAnnotation(getMethod(), whichRegister, getPC(),\n                                                getPC() - 1)), this);\n            }\n        }\n    }","id":32102,"modified_method":"private void checkForSelfOperation(int opCode, String op) {\n        {\n\n            \n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            OpcodeStack.Item item1 = stack.getStackItem(1);\n\n            if (item0.getSignature().equals(\"D\") || item0.getSignature().equals(\"F\"))\n                return;\n            if (item1.getSignature().equals(\"D\") || item1.getSignature().equals(\"F\"))\n                return;\n\n            BitSet linesMentionedMultipleTimes = getClassContext().linesMentionedMultipleTimes(getMethod());\n            SourceLineAnnotation source = SourceLineAnnotation.fromVisitedInstruction(this);\n            boolean possibleClone = source.getStartLine() > 0 && linesMentionedMultipleTimes.get(source.getStartLine());\n            LineNumberTable lineNumberTable = getCode().getLineNumberTable();\n            int linesDifference = 0;\n            if (lineNumberTable != null && item0.getPC() != -1 && item1.getPC() != -1) {\n                int line0 = lineNumberTable.getSourceLine(item0.getPC());\n                int line1 = lineNumberTable.getSourceLine(item1.getPC());\n                linesDifference = Math.abs(line0-line1);\n            }\n            XField field0 = item0.getXField();\n            XField field1 = item1.getXField();\n            int fr0 = item0.getFieldLoadedFromRegister();\n            int fr1 = item1.getFieldLoadedFromRegister();\n            if (field0 != null && field0.equals(field1) && (field0.isStatic() || fr0 != -1 && fr0 == fr1)) {\n                int priority = NORMAL_PRIORITY;\n                if (field0.isVolatile())\n                    priority++;\n                if (linesDifference > 1) {\n                    if (possibleClone)\n                        return;\n                    priority++;\n                }\n                \n                BugInstance bug = new BugInstance(this, \"SA_FIELD_SELF_\" + op, priority)\n                        .addClassAndMethod(this).addField(field0);\n                \n                if (this.isMethodCall())\n                    bug.addCalledMethod(this);\n                bugAccumulator.accumulateBug(bug, this);\n            }\n\n            else if (opCode == IXOR && item0.equals(item1)) {\n                LocalVariableAnnotation localVariableAnnotation = LocalVariableAnnotation.getLocalVariableAnnotation(this, item0);\n                if (localVariableAnnotation != null)\n                    bugAccumulator.accumulateBug(\n                            new BugInstance(this, \"SA_LOCAL_SELF_\" + op, linesDifference > 1 ? NORMAL_PRIORITY : HIGH_PRIORITY).addClassAndMethod(this).add(\n                                    localVariableAnnotation), this);\n            }\n        }\n    }","commit_id":"f7c67352d2ff639c3b73e60b0a9fe5bc1b208ea8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void visit(Code obj) {\n        // System.out.println(getFullyQualifiedMethodName());\n        whichRegister = -1;\n        registerLoadCount = 0;\n        resetDoubleAssignmentState();\n        super.visit(obj);\n        resetDoubleAssignmentState();\n        bugAccumulator.reportAccumulatedBugs();\n    }","id":32103,"modified_method":"@Override\n    public void visit(Code obj) {\n        if (DEBUG)\n            System.out.println(getFullyQualifiedMethodName());\n        whichRegister = -1;\n        registerLoadCount = 0;\n        resetDoubleAssignmentState();\n        super.visit(obj);\n        resetDoubleAssignmentState();\n        bugAccumulator.reportAccumulatedBugs();\n        if (DEBUG)\n            System.out.println();\n    }","commit_id":"f7c67352d2ff639c3b73e60b0a9fe5bc1b208ea8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void sawOpcode(int seen) {\n        // System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" +\n        // whichRegister + \" \" + registerLoadCount);\n\n        if (stack.hasIncomingBranches(getPC()))\n            resetDoubleAssignmentState();\n\n        if (seen == PUTFIELD) {\n            OpcodeStack.Item obj = stack.getStackItem(1);\n            OpcodeStack.Item value = stack.getStackItem(0);\n            XField f = getXFieldOperand();\n            XClass x = getXClassOperand();\n\n            checkPUTFIELD: if (putFieldPC + 10 > getPC() && f != null && obj != null && f.equals(putFieldXField)\n                    && !f.isSynthetic() && obj.equals(putFieldObj) && x != null) {\n\n                LineNumberTable table = getCode().getLineNumberTable();\n                if (table != null) {\n                    int first = table.getSourceLine(putFieldPC);\n                    int second = table.getSourceLine(getPC());\n                    if (first + 1 != second && first != second)\n                        break checkPUTFIELD;\n                } else if (putFieldPC + 3 != getPC())\n                    break checkPUTFIELD;\n\n                int priority = NORMAL_PRIORITY;\n                if (value.equals(putFieldValue) && putFieldPC + 3 != getPC())\n                    priority++;\n                boolean storeOfDefaultValue = putFieldValue.isNull() || putFieldValue.hasConstantValue(0);\n                if (storeOfDefaultValue)\n                    priority++;\n                if (f.isVolatile())\n                    priority++;\n                XField intendedTarget = null;\n\n                double minimumDistance = 2;\n                int matches = 0;\n                for (XField f2 : x.getXFields())\n                    if (!f.equals(f2) && !f2.isStatic() && !f2.isFinal() && !f2.isSynthetic()\n                            && f2.getSignature().equals(f.getSignature())) {\n\n                        double distance = EditDistance.editDistanceRatio(f.getName(), f2.getName());\n                        matches++;\n                        if (minimumDistance > distance) {\n                            minimumDistance = distance;\n                            intendedTarget = f2;\n                        }\n\n                    }\n                if (minimumDistance > 0.6 && (matches > 1 || storeOfDefaultValue))\n                    intendedTarget = null;\n                else if (intendedTarget != null)\n                    priority--;\n                BugInstance bug = new BugInstance(this, \"SA_FIELD_DOUBLE_ASSIGNMENT\", priority).addClassAndMethod(this)\n                        .addReferencedField(this);\n                if (intendedTarget != null)\n                    bug.addField(intendedTarget).describe(FieldAnnotation.DID_YOU_MEAN_ROLE);\n\n                bugAccumulator.accumulateBug(bug, this);\n            }\n            putFieldPC = getPC();\n            putFieldXField = f;\n            putFieldObj = obj;\n            putFieldValue = value;\n\n        } else if (isReturn(seen))\n            resetDoubleAssignmentState();\n        else if (seen == GETFIELD && Util.nullSafeEquals(getXFieldOperand(), putFieldXField)) {\n            OpcodeStack.Item obj = stack.getStackItem(0);\n            if (obj.equals(putFieldObj))\n                resetDoubleAssignmentState();\n        }\n\n        switch (seen) {\n        case INVOKEVIRTUAL:\n        case INVOKEINTERFACE:\n            if (getClassName().toLowerCase().indexOf(\"test\") >= 0)\n                break;\n            if (getMethodName().toLowerCase().indexOf(\"test\") >= 0)\n                break;\n            if (getSuperclassName().toLowerCase().indexOf(\"test\") >= 0)\n                break;\n            if (getNextOpcode() == POP)\n                break;\n            String name = getNameConstantOperand();\n\n            boolean booleanComparisonMethod = FindSelfComparison2.booleanComparisonMethod(name);\n            if (booleanComparisonMethod || FindSelfComparison2.comparatorMethod(name)) {\n                String sig = getSigConstantOperand();\n                SignatureParser parser = new SignatureParser(sig);\n                if (parser.getNumParameters() == 1\n                        && (booleanComparisonMethod && sig.endsWith(\";)Z\") ||  FindSelfComparison2.comparatorMethod(name) && sig.endsWith(\";)I\")))\n                    checkForSelfOperation(seen, \"COMPARISON\");\n            }\n            break;\n\n        case LOR:\n        case LAND:\n        case LXOR:\n        case LSUB:\n        case IOR:\n        case IAND:\n        case IXOR:\n        case ISUB:\n            checkForSelfOperation(seen, \"COMPUTATION\");\n            break;\n        case FCMPG:\n        case DCMPG:\n        case DCMPL:\n        case FCMPL:\n            break;\n        case LCMP:\n        case IF_ACMPEQ:\n        case IF_ACMPNE:\n        case IF_ICMPNE:\n        case IF_ICMPEQ:\n        case IF_ICMPGT:\n        case IF_ICMPLE:\n        case IF_ICMPLT:\n        case IF_ICMPGE:\n            checkForSelfOperation(seen, \"COMPARISON\");\n        }\n        if (isRegisterLoad() && seen != IINC) {\n            if (getRegisterOperand() == whichRegister)\n                registerLoadCount++;\n            else {\n                whichRegister = getRegisterOperand();\n                registerLoadCount = 1;\n            }\n        } else {\n            whichRegister = -1;\n            registerLoadCount = 0;\n        }\n    }","id":32104,"modified_method":"@Override\n    public void sawOpcode(int seen) {\n        if (DEBUG)\n            System.out.printf(\"%3d %-15s %s%n\", getPC(), OPCODE_NAMES[seen], stack);\n       \n\n        if (stack.hasIncomingBranches(getPC()))\n            resetDoubleAssignmentState();\n\n        if (seen == PUTFIELD) {\n            OpcodeStack.Item obj = stack.getStackItem(1);\n            OpcodeStack.Item value = stack.getStackItem(0);\n            XField f = getXFieldOperand();\n            XClass x = getXClassOperand();\n\n            checkPUTFIELD: if (putFieldPC + 10 > getPC() && f != null && obj != null && f.equals(putFieldXField)\n                    && !f.isSynthetic() && obj.equals(putFieldObj) && x != null) {\n\n                LineNumberTable table = getCode().getLineNumberTable();\n                if (table != null) {\n                    int first = table.getSourceLine(putFieldPC);\n                    int second = table.getSourceLine(getPC());\n                    if (first + 1 != second && first != second)\n                        break checkPUTFIELD;\n                } else if (putFieldPC + 3 != getPC())\n                    break checkPUTFIELD;\n\n                int priority = NORMAL_PRIORITY;\n                if (value.equals(putFieldValue) && putFieldPC + 3 != getPC())\n                    priority++;\n                boolean storeOfDefaultValue = putFieldValue.isNull() || putFieldValue.hasConstantValue(0);\n                if (storeOfDefaultValue)\n                    priority++;\n                if (f.isVolatile())\n                    priority++;\n                XField intendedTarget = null;\n\n                double minimumDistance = 2;\n                int matches = 0;\n                for (XField f2 : x.getXFields())\n                    if (!f.equals(f2) && !f2.isStatic() && !f2.isFinal() && !f2.isSynthetic()\n                            && f2.getSignature().equals(f.getSignature())) {\n\n                        double distance = EditDistance.editDistanceRatio(f.getName(), f2.getName());\n                        matches++;\n                        if (minimumDistance > distance) {\n                            minimumDistance = distance;\n                            intendedTarget = f2;\n                        }\n\n                    }\n                if (minimumDistance > 0.6 && (matches > 1 || storeOfDefaultValue))\n                    intendedTarget = null;\n                else if (intendedTarget != null)\n                    priority--;\n                BugInstance bug = new BugInstance(this, \"SA_FIELD_DOUBLE_ASSIGNMENT\", priority).addClassAndMethod(this)\n                        .addReferencedField(this);\n                if (intendedTarget != null)\n                    bug.addField(intendedTarget).describe(FieldAnnotation.DID_YOU_MEAN_ROLE);\n\n                bugAccumulator.accumulateBug(bug, this);\n            }\n            putFieldPC = getPC();\n            putFieldXField = f;\n            putFieldObj = obj;\n            putFieldValue = value;\n\n        } else if (isReturn(seen))\n            resetDoubleAssignmentState();\n        else if (seen == GETFIELD && Util.nullSafeEquals(getXFieldOperand(), putFieldXField)) {\n            OpcodeStack.Item obj = stack.getStackItem(0);\n            if (obj.equals(putFieldObj))\n                resetDoubleAssignmentState();\n        }\n\n        switch (seen) {\n        case INVOKEVIRTUAL:\n        case INVOKEINTERFACE:\n            if (getClassName().toLowerCase().indexOf(\"test\") >= 0)\n                break;\n            if (getMethodName().toLowerCase().indexOf(\"test\") >= 0)\n                break;\n            if (getSuperclassName().toLowerCase().indexOf(\"test\") >= 0)\n                break;\n            if (getNextOpcode() == POP)\n                break;\n            String name = getNameConstantOperand();\n\n            boolean booleanComparisonMethod = FindSelfComparison2.booleanComparisonMethod(name);\n            if (booleanComparisonMethod || FindSelfComparison2.comparatorMethod(name)) {\n                String sig = getSigConstantOperand();\n                SignatureParser parser = new SignatureParser(sig);\n                if (parser.getNumParameters() == 1\n                        && (booleanComparisonMethod && sig.endsWith(\";)Z\") ||  FindSelfComparison2.comparatorMethod(name) && sig.endsWith(\";)I\")))\n                    checkForSelfOperation(seen, \"COMPARISON\");\n            }\n            break;\n\n        case LOR:\n        case LAND:\n        case LXOR:\n        case LSUB:\n        case IOR:\n        case IAND:\n        case IXOR:\n        case ISUB:\n            checkForSelfOperation(seen, \"COMPUTATION\");\n            break;\n        case FCMPG:\n        case DCMPG:\n        case DCMPL:\n        case FCMPL:\n            break;\n        case LCMP:\n        case IF_ACMPEQ:\n        case IF_ACMPNE:\n        case IF_ICMPNE:\n        case IF_ICMPEQ:\n        case IF_ICMPGT:\n        case IF_ICMPLE:\n        case IF_ICMPLT:\n        case IF_ICMPGE:\n            checkForSelfOperation(seen, \"COMPARISON\");\n        }\n        if (isRegisterLoad() && seen != IINC) {\n            if (getRegisterOperand() == whichRegister)\n                registerLoadCount++;\n            else {\n                whichRegister = getRegisterOperand();\n                registerLoadCount = 1;\n            }\n        } else {\n            whichRegister = -1;\n            registerLoadCount = 0;\n        }\n    }","commit_id":"f7c67352d2ff639c3b73e60b0a9fe5bc1b208ea8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + ternaryConversionState);\n\t\tif (seen == IMUL) {\n\t\t\tif (imul_distance != 1) resetIMulCastLong();\n\t\t\timul_distance = 0;\n\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\t\t\t\timul_constant = adjustMultiplier(item0.getConstant(), imul_constant);\n\t\t\t\timul_constant = adjustMultiplier(item1.getConstant(), imul_constant);\n\n\t\t\t\tif (item0.isInitialParameter() || item1.isInitialParameter())\n\t\t\t\t\timul_operand_is_parameter = true;\n\t\t\t}} else {\n\t\t\t\timul_distance++;\n\t\t\t}\n\n\t\tif (prevOpCode == IMUL && seen == I2L) {\n\t\t\tint priority = adjustPriority(imul_constant, NORMAL_PRIORITY);\n\t\t\tif (priority >= LOW_PRIORITY && imul_operand_is_parameter) priority = NORMAL_PRIORITY;\n\t\t\tif (priority <= best_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG) {\n\t\t\t\tbest_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG = priority;\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\"ICAST_INTEGER_MULTIPLY_CAST_TO_LONG\", \n\t\t\t\t\t\tpriority)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\t\tif (getMethodName().equals(\"<clinit>\") && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {\n\t\t\tString clazz = getClassConstantOperand();\n\t\t\tif (!clazz.equals(getClassName())) {\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass targetClass = Repository.lookupClass(clazz);\n\t\t\t\t\tif (Repository.instanceOf(targetClass, getThisClass())) {\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\t\tif (seen == GETSTATIC) priority--;\n\t\t\t\t\t\tif (!targetClass.isPublic()) priority++;\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\t\t\"IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION\", \n\t\t\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(this).addClass(getDottedClassConstantOperand()),\n\t\t\t\t\t\tthis);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// ignore it\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (false && (seen == INVOKEVIRTUAL)\n\t\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(\"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\n\t\tif (seen >= IALOAD && seen <= SALOAD || seen >= IASTORE && seen <= SASTORE ) {\n\t\t\tItem index  = stack.getStackItem(0);\n\t\t\tif (index.getSpecialKind() == Item.AVERAGE_COMPUTED_USING_DIVISION)\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\n\t\t}\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t\t&& getPrevOpcode(3) == IREM\n\t\t)\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue && \n\t\t\t\t(!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t\t|| seen == I2B && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)) \n\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\n\n\t\tconstantArgumentToShift = false;\n\t\tshiftOfNonnegativeValue = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject rightHandSide\n\t\t\t\t= stack.getStackItem(0).getConstant();\n\n\t\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\t\tshiftOfNonnegativeValue = stack.getStackItem(1).isNonNegative();\n\t\t\t\tif (rightHandSide instanceof Integer) {\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", \n\t\t\t\t\t\t\t\tvalueOfConstantArgumentToShift < 0 ? LOW_PRIORITY : HIGH_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift).describe(IntAnnotation.INT_SHIFT), this);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Date\")\n\t\t\t\t&& getNameConstantOperand().equals(\"setMonth\")\n\t\t\t\t&& getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Calendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"set\")\n\n\t\t\t\t||\n\t\t\t\tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"<init>\")\n\n\t\t) {\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tif (sig.startsWith(\"(III\")) {\n\t\t\t\tint pos = sig.length() - 5;\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(pos);\n\t\t\t\tObject o = item.getConstant();\n\t\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\t\tint v = (Integer) o;\n\t\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t\t|| seen == ISTORE_0\n\t\t\t\t|| seen == ISTORE_1\n\t\t\t\t|| seen == ISTORE_2\n\t\t\t\t|| seen == ISTORE_3)\n\t\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\n\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t// Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) {\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\tif (item.getSpecialKind() != OpcodeStack.Item.MATH_ABS)\n\t\t\t\t\tbadlyComputingOddState++;\n\t\t\t\telse  badlyComputingOddState = 0;\n\t\t\t}\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE)  {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n\t\t\t\t&& (getNameConstantOperand().equals(\"toString\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n\t\t\t\t)\n\t\t) {\n\t\t\tString classConstants = getClassConstantOperand();\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tString signature = item.getSignature();\n\t\t\tif (signature != null && signature.startsWith(\"[\")) {\n\t\t\t\tString name = \"anonymous array\";\n\t\t\t\tint reg = item.getRegisterNumber();\n\t\t\t\tif(reg != -1) {\n\t\t\t\t\tLocalVariableAnnotation lva =\n\t\t\t\t\t\tLocalVariableAnnotation.getLocalVariableAnnotation(\n\t\t\t\t\t\t\tgetMethod(), reg, getPC(), getPC()-1);\n\t\t\t\t\tname = \"array \" + lva.getName() + \"[]\";\n\t\t\t\t}\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addString(name), this);\n\t\t\t}\n\t\t}\n\n\t\tif (isTigerOrHigher) {\n\t\t\tif (previousMethodInvocation != null && prevOpCode == INVOKESPECIAL && seen == INVOKEVIRTUAL) {\n\t\t\t\tString classNameForPreviousMethod = previousMethodInvocation.getClassName();\n\t\t\t\tString classNameForThisMethod = getClassConstantOperand();\n\t\t\t\tif (classNameForPreviousMethod.startsWith(\"java.lang.\") \n\t\t\t\t\t\t&& classNameForPreviousMethod.equals(classNameForThisMethod.replace('/','.'))\n\t\t\t\t\t\t&& getNameConstantOperand().endsWith(\"Value\")\n\t\t\t\t\t\t&& getSigConstantOperand().length() == 3) {\n\t\t\t\t\tif (getSigConstantOperand().charAt(2) == previousMethodInvocation.getSignature().charAt(1))\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\t} else ternaryConversionState = 0;\n\n\t\t\t} else if (seen == INVOKEVIRTUAL) {\n\t\t\t\tif (getClassConstantOperand().startsWith(\"java/lang\") && getNameConstantOperand().endsWith(\"Value\") && getSigConstantOperand().length() == 3)\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}else if (ternaryConversionState == 1) {\n\t\t\t\tif (I2L <= seen && seen <= I2S) \n\t\t\t\t\tternaryConversionState = 2;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}\n\t\t\telse if (ternaryConversionState == 2) {\n\t\t\t\tternaryConversionState = 0;\n\t\t\t\tif (seen == GOTO) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKESTATIC)\n\t\t\tif ((getNameConstantOperand().startsWith(\"assert\") || getNameConstantOperand().startsWith(\"fail\")) && getMethodName().equals(\"run\")\n\t\t\t\t\t&& implementsRunnable(getThisClass())) {\n\t\t\t\ttry {\n\t\t\t\t\t int size1 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\"java/lang/Throwable\", getPC());\n\t\t\t\t\tint size2 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\"java/lang/Error\", getPC());\n\t\t\t\t\tint size3 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\t\t\"java/lang/AssertionFailureError\", getPC());\n\t\t\t\t\tint size = Math.min(Math.min( size1, size2), size3);\n\t\t\t\t\t if (size == Integer.MAX_VALUE) {\n\t\t\t\t\tJavaClass targetClass = AnalysisContext.currentAnalysisContext().lookupClass(getClassConstantOperand().replace('/', '.'));\n\t\t\t\t\tif (targetClass.getSuperclassName().startsWith(\"junit\")) {\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\t }\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t}\n\n\t\t\t}\n\t\tif (seen == INVOKESPECIAL && getClassConstantOperand().startsWith(\"java/lang/\")  && getNameConstantOperand().equals(\"<init>\")\n\t\t\t\t&& getSigConstantOperand().length() == 4\n\t\t) \n\n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse if (seen == INVOKESTATIC && getClassConstantOperand().startsWith(\"java/lang/\")  \n\t\t\t\t&& getNameConstantOperand().equals(\"valueOf\")\n\t\t\t\t&& getSigConstantOperand().length() == 4) \n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse previousMethodInvocation = null;\n\t\tprevOpCode = seen;\n\t}","id":32105,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + ternaryConversionState);\n\t\tif (seen == IMUL) {\n\t\t\tif (imul_distance != 1) resetIMulCastLong();\n\t\t\timul_distance = 0;\n\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\t\t\t\timul_constant = adjustMultiplier(item0.getConstant(), imul_constant);\n\t\t\t\timul_constant = adjustMultiplier(item1.getConstant(), imul_constant);\n\n\t\t\t\tif (item0.isInitialParameter() || item1.isInitialParameter())\n\t\t\t\t\timul_operand_is_parameter = true;\n\t\t\t}} else {\n\t\t\t\timul_distance++;\n\t\t\t}\n\n\t\tif (prevOpCode == IMUL && seen == I2L) {\n\t\t\tint priority = adjustPriority(imul_constant, NORMAL_PRIORITY);\n\t\t\tif (priority >= LOW_PRIORITY && imul_operand_is_parameter) priority = NORMAL_PRIORITY;\n\t\t\tif (priority <= best_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG) {\n\t\t\t\tbest_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG = priority;\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\"ICAST_INTEGER_MULTIPLY_CAST_TO_LONG\", \n\t\t\t\t\t\tpriority)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\t\tif (getMethodName().equals(\"<clinit>\") && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {\n\t\t\tString clazz = getClassConstantOperand();\n\t\t\tif (!clazz.equals(getClassName())) {\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass targetClass = Repository.lookupClass(clazz);\n\t\t\t\t\tif (Repository.instanceOf(targetClass, getThisClass())) {\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\t\tif (seen == GETSTATIC) priority--;\n\t\t\t\t\t\tif (!targetClass.isPublic()) priority++;\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\t\t\"IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION\", \n\t\t\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(this).addClass(getDottedClassConstantOperand()),\n\t\t\t\t\t\tthis);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// ignore it\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (false && (seen == INVOKEVIRTUAL)\n\t\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(\"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\n\t\tif (seen >= IALOAD && seen <= SALOAD || seen >= IASTORE && seen <= SASTORE ) {\n\t\t\tItem index  = stack.getStackItem(0);\n\t\t\tif (index.getSpecialKind() == Item.AVERAGE_COMPUTED_USING_DIVISION)\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\n\t\t}\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t\t&& getPrevOpcode(3) == IREM\n\t\t)\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue && \n\t\t\t\t(!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t\t|| seen == I2B && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)) \n\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\n\n\t\tconstantArgumentToShift = false;\n\t\tshiftOfNonnegativeValue = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject rightHandSide\n\t\t\t\t= stack.getStackItem(0).getConstant();\n\n\t\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\t\tshiftOfNonnegativeValue = stack.getStackItem(1).isNonNegative();\n\t\t\t\tif (rightHandSide instanceof Integer) {\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", \n\t\t\t\t\t\t\t\tvalueOfConstantArgumentToShift < 0 ? LOW_PRIORITY : HIGH_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift).describe(IntAnnotation.INT_SHIFT), this);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Date\")\n\t\t\t\t&& getNameConstantOperand().equals(\"setMonth\")\n\t\t\t\t&& getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Calendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"set\")\n\n\t\t\t\t||\n\t\t\t\tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"<init>\")\n\n\t\t) {\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tif (sig.startsWith(\"(III\")) {\n\t\t\t\tint pos = sig.length() - 5;\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(pos);\n\t\t\t\tObject o = item.getConstant();\n\t\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\t\tint v = (Integer) o;\n\t\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t\t|| seen == ISTORE_0\n\t\t\t\t|| seen == ISTORE_1\n\t\t\t\t|| seen == ISTORE_2\n\t\t\t\t|| seen == ISTORE_3)\n\t\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\n\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t// Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) {\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\tif (item.getSpecialKind() != OpcodeStack.Item.MATH_ABS)\n\t\t\t\t\tbadlyComputingOddState++;\n\t\t\t\telse  badlyComputingOddState = 0;\n\t\t\t}\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE)  {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n\t\t\t\t&& (getNameConstantOperand().equals(\"toString\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n\t\t\t\t)\n\t\t) {\n\t\t\tString classConstants = getClassConstantOperand();\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tString signature = item.getSignature();\n\t\t\tif (signature != null && signature.startsWith(\"[\")) {\n\t\t\t\tString name = null;\n\t\t\t\tint reg = item.getRegisterNumber();\n\t\t\t\tCollection<BugAnnotation> as = new ArrayList<BugAnnotation>();\n\t\t\t\tif(reg != -1) {\n\t\t\t\t\tLocalVariableAnnotation lva =\n\t\t\t\t\t\tLocalVariableAnnotation.getLocalVariableAnnotation(\n\t\t\t\t\t\t\tgetMethod(), reg, getPC(), getPC()-1);\n\t\t\t\t\tname = \"array \" + lva.getName() + \"[]\";\n\t\t\t\t\tas.add(lva);\n\t\t\t\t}\n\t\t\t\tif(name != null) {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addAnnotations(as), this);\n\t\t\t\t} else {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isTigerOrHigher) {\n\t\t\tif (previousMethodInvocation != null && prevOpCode == INVOKESPECIAL && seen == INVOKEVIRTUAL) {\n\t\t\t\tString classNameForPreviousMethod = previousMethodInvocation.getClassName();\n\t\t\t\tString classNameForThisMethod = getClassConstantOperand();\n\t\t\t\tif (classNameForPreviousMethod.startsWith(\"java.lang.\") \n\t\t\t\t\t\t&& classNameForPreviousMethod.equals(classNameForThisMethod.replace('/','.'))\n\t\t\t\t\t\t&& getNameConstantOperand().endsWith(\"Value\")\n\t\t\t\t\t\t&& getSigConstantOperand().length() == 3) {\n\t\t\t\t\tif (getSigConstantOperand().charAt(2) == previousMethodInvocation.getSignature().charAt(1))\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\t} else ternaryConversionState = 0;\n\n\t\t\t} else if (seen == INVOKEVIRTUAL) {\n\t\t\t\tif (getClassConstantOperand().startsWith(\"java/lang\") && getNameConstantOperand().endsWith(\"Value\") && getSigConstantOperand().length() == 3)\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}else if (ternaryConversionState == 1) {\n\t\t\t\tif (I2L <= seen && seen <= I2S) \n\t\t\t\t\tternaryConversionState = 2;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}\n\t\t\telse if (ternaryConversionState == 2) {\n\t\t\t\tternaryConversionState = 0;\n\t\t\t\tif (seen == GOTO) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKESTATIC)\n\t\t\tif ((getNameConstantOperand().startsWith(\"assert\") || getNameConstantOperand().startsWith(\"fail\")) && getMethodName().equals(\"run\")\n\t\t\t\t\t&& implementsRunnable(getThisClass())) {\n\t\t\t\ttry {\n\t\t\t\t\t int size1 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\"java/lang/Throwable\", getPC());\n\t\t\t\t\tint size2 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\"java/lang/Error\", getPC());\n\t\t\t\t\tint size3 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\t\t\"java/lang/AssertionFailureError\", getPC());\n\t\t\t\t\tint size = Math.min(Math.min( size1, size2), size3);\n\t\t\t\t\t if (size == Integer.MAX_VALUE) {\n\t\t\t\t\tJavaClass targetClass = AnalysisContext.currentAnalysisContext().lookupClass(getClassConstantOperand().replace('/', '.'));\n\t\t\t\t\tif (targetClass.getSuperclassName().startsWith(\"junit\")) {\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\t }\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t}\n\n\t\t\t}\n\t\tif (seen == INVOKESPECIAL && getClassConstantOperand().startsWith(\"java/lang/\")  && getNameConstantOperand().equals(\"<init>\")\n\t\t\t\t&& getSigConstantOperand().length() == 4\n\t\t) \n\n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse if (seen == INVOKESTATIC && getClassConstantOperand().startsWith(\"java/lang/\")  \n\t\t\t\t&& getNameConstantOperand().equals(\"valueOf\")\n\t\t\t\t&& getSigConstantOperand().length() == 4) \n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse previousMethodInvocation = null;\n\t\tprevOpCode = seen;\n\t}","commit_id":"891ef5eb846d44a4820644be23f40c6a6a43c119","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (getMethodName().equals(\"<init>\") && seen == INVOKEVIRTUAL) {\n\t\t\tXMethod m = getXMethodOperand();\n\t\t\tif (m != null && m.isAbstract()) {\n\t\t\tint args = PreorderVisitor.getNumberArguments(m.getSignature());\n\t\t\tOpcodeStack.Item item = stack.getStackItem(args);\n\t\t\tif (item.getRegisterNumber() == 0) {\n\t\t\t\ttry {\n                \tSet<XMethod> targets = Hierarchy2.resolveVirtualMethodCallTargets(m, false, false);\n\t                for(XMethod called : targets) {\n\t                \tif (!called.isAbstract())\n\t                \t\tfieldSummary.setCalledFromSuperConstructor(getXMethod(), called);\n\t                }\n                } catch (ClassNotFoundException e) {\n\t               AnalysisContext.reportMissingClass(e);\n                }\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\tif (seen == INVOKESPECIAL && getMethodName().equals(\"<init>\") && getNameConstantOperand().equals(\"<init>\") && !getClassConstantOperand().equals(getClassName()))\n\t\t\tsawInitializeSuper = true;\n\t\tif (seen == PUTFIELD || seen == PUTSTATIC) {\n\t\t\tXField fieldOperand = getXFieldOperand();\n\t\t\tif (fieldOperand == null) return;\n\t\t\ttouched.add(fieldOperand);\n\t\t\tif (!fieldOperand.getClassDescriptor().getClassName().equals(getClassName()))\n\t\t\t\tfieldSummary.addWrittenOutsideOfConstructor(fieldOperand);\n\t\t\telse if (seen == PUTFIELD) {\n\t\t\t\tOpcodeStack.Item addr = stack.getStackItem(1); {\n\t\t\t\tif (addr.getRegisterNumber() != 0 || !getMethodName().equals(\"<init>\"))\n\t\t\t\t\tfieldSummary.addWrittenOutsideOfConstructor(fieldOperand);\n\t\t\t\t}\n\t\t\t} else if (seen == PUTSTATIC && !getMethodName().equals(\"<clinit>\"))\n\t\t\t\tfieldSummary.addWrittenOutsideOfConstructor(fieldOperand);\n\t\t\tOpcodeStack.Item top = stack.getStackItem(0);\n\t\t\tfieldSummary.mergeSummary(fieldOperand, top);\n\t\t}\n\n\t}","id":32106,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (getMethodName().equals(\"<init>\") && seen == INVOKEVIRTUAL) {\n\t\t\tXMethod m = getXMethodOperand();\n\t\t\tif (m != null && !m.isPrivate() && !m.isFinal()) {\n\t\t\tint args = PreorderVisitor.getNumberArguments(m.getSignature());\n\t\t\tOpcodeStack.Item item = stack.getStackItem(args);\n\t\t\tif (item.getRegisterNumber() == 0) {\n\t\t\t\ttry {\n                \tSet<XMethod> targets = Hierarchy2.resolveVirtualMethodCallTargets(m, false, false);\n\t                for(XMethod called : targets) {\n\t                \tif (!called.isAbstract() && !called.equals(m))\n\t                \t\tfieldSummary.setCalledFromSuperConstructor(getXMethod(), called);\n\t                }\n                } catch (ClassNotFoundException e) {\n\t               AnalysisContext.reportMissingClass(e);\n                }\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\tif (seen == INVOKESPECIAL && getMethodName().equals(\"<init>\") && getNameConstantOperand().equals(\"<init>\") && !getClassConstantOperand().equals(getClassName()))\n\t\t\tsawInitializeSuper = true;\n\t\tif (seen == PUTFIELD || seen == PUTSTATIC) {\n\t\t\tXField fieldOperand = getXFieldOperand();\n\t\t\tif (fieldOperand == null) return;\n\t\t\ttouched.add(fieldOperand);\n\t\t\tif (!fieldOperand.getClassDescriptor().getClassName().equals(getClassName()))\n\t\t\t\tfieldSummary.addWrittenOutsideOfConstructor(fieldOperand);\n\t\t\telse if (seen == PUTFIELD) {\n\t\t\t\tOpcodeStack.Item addr = stack.getStackItem(1); {\n\t\t\t\tif (addr.getRegisterNumber() != 0 || !getMethodName().equals(\"<init>\"))\n\t\t\t\t\tfieldSummary.addWrittenOutsideOfConstructor(fieldOperand);\n\t\t\t\t}\n\t\t\t} else if (seen == PUTSTATIC && !getMethodName().equals(\"<clinit>\"))\n\t\t\t\tfieldSummary.addWrittenOutsideOfConstructor(fieldOperand);\n\t\t\tOpcodeStack.Item top = stack.getStackItem(0);\n\t\t\tfieldSummary.mergeSummary(fieldOperand, top);\n\t\t}\n\n\t}","commit_id":"9611d36d1921d45452aca65b164106f6f55e4350","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int opcode) {\n\t\tif (opcode == PUTFIELD) {\n\t\t\tXField f = getXFieldOperand();\n\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\tif (item.getRegisterNumber() != 0)\n\t\t\t\treturn;\n\t\t\tinitializedFields.add(f);\n\t\t\treturn;\n\t\t}\n\t\tif (opcode != GETFIELD)\n\t\t\treturn;\n\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\tif (item.getRegisterNumber() != 0)\n\t\t\treturn;\n\t\tXField f = getXFieldOperand();\n\t\tif (!f.getClassDescriptor().equals(getClassDescriptor()))\n\t\t\treturn;\n\t\tif (f.isSynthetic() || f.getName().startsWith(\"this$\"))\n\t\t\treturn;\n\t\tif (initializedFields.contains(f))\n\t\t\treturn;\n\t\tFieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n\n\t\tSet<XMethod> calledFrom = fieldSummary.getCalledFromSuperConstructor(DescriptorFactory\n\t\t        .createClassDescriptor(getSuperclassName()), getXMethod());\n\t\tif (calledFrom.isEmpty())\n\t\t\treturn;\n\n\t\tfor (XMethod m : calledFrom) {\n\n\t\t\tBugInstance bug = new BugInstance(this, \"TESTING\", NORMAL_PRIORITY).addClassAndMethod(this).addMethod(m).addField(f);\n\n\t\t\taccumulator.accumulateBug(bug, this);\n\t\t}\n\n\t}","id":32107,"modified_method":"@Override\n\tpublic void sawOpcode(int opcode) {\n\t\tif (opcode == PUTFIELD) {\n\t\t\tXField f = getXFieldOperand();\n\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\tif (item.getRegisterNumber() != 0)\n\t\t\t\treturn;\n\t\t\tinitializedFields.add(f);\n\t\t\treturn;\n\t\t}\n\t\tif (opcode != GETFIELD)\n\t\t\treturn;\n\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\tif (item.getRegisterNumber() != 0)\n\t\t\treturn;\n\t\tXField f = getXFieldOperand();\n\t\tif (!f.getClassDescriptor().equals(getClassDescriptor()))\n\t\t\treturn;\n\t\tif (f.isSynthetic() || f.getName().startsWith(\"this$\"))\n\t\t\treturn;\n\t\tif (initializedFields.contains(f))\n\t\t\treturn;\n\t\tFieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n\n\t\tSet<XMethod> calledFrom = fieldSummary.getCalledFromSuperConstructor(DescriptorFactory\n\t\t        .createClassDescriptor(getSuperclassName()), getXMethod());\n\t\tif (calledFrom.isEmpty())\n\t\t\treturn;\n\t\tUnreadFields unreadFields = AnalysisContext.currentAnalysisContext().getUnreadFields();\n\t\t\n\t\tint priority = NORMAL_PRIORITY;\n\t\tif (f.isFinal() || !unreadFields.getWrittenOutsideOfConstructorFields().contains(f))\n\t\t\tpriority = HIGH_PRIORITY;\n\t\tBugInstance bug = new BugInstance(this, \"UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR\", priority).addClassAndMethod(this).addField(f);\n\t\t\n\t\tfor (XMethod m : calledFrom) \n\t\t\tbug.addMethod(m).describe(MethodAnnotation.METHOD_CALLED_FROM);\n\n\t\taccumulator.accumulateBug(bug, this);\n\t\t\n\n\t}","commit_id":"9611d36d1921d45452aca65b164106f6f55e4350","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t\n\n\t\tif (seen == INVOKEVIRTUAL &&   getNameConstantOperand().equals(\"hashCode\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"()I\")\n\t\t\t\t&& stack.getStackDepth() > 0) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tif (item0.getSignature().charAt(0) == '[')\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_INVOKING_HASHCODE_ON_ARRAY\", NORMAL_PRIORITY).addClassAndMethod(this)\n\t\t\t\t\t\t.addValueSource(item0, this)\n\t\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\t\tif (seen != RETURN && isReturn(seen) && isRegisterStore(getPrevOpcode(1))) {\n\t\t\t\n\t\t\tint priority = Priorities.NORMAL_PRIORITY;\n\t\t\tif  (getMethodSig().endsWith(\")Z\")) priority =  Priorities.HIGH_PRIORITY;\n\t\t\telse {\n\t\t\t\tif (getMethodSig().endsWith(\")Ljava/lang/String;\")) priority =  Priorities.LOW_PRIORITY;\n\t\t\t\tif (getPC() == getCode().getCode().length-1 ) priority++;\n\t\t\t}\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"DLS_DEAD_LOCAL_STORE_IN_RETURN\", priority).addClassAndMethod(this).addSourceLine(this));\n\t\t}\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + ternaryConversionState);\n\t\tif (seen == IMUL) {\n\t\t\tif (imul_distance != 1) resetIMulCastLong();\n\t\t\timul_distance = 0;\n\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\t\t\t\timul_constant = adjustMultiplier(item0.getConstant(), imul_constant);\n\t\t\t\timul_constant = adjustMultiplier(item1.getConstant(), imul_constant);\n\n\t\t\t\tif (item0.isInitialParameter() || item1.isInitialParameter())\n\t\t\t\t\timul_operand_is_parameter = true;\n\t\t\t}} else {\n\t\t\t\timul_distance++;\n\t\t\t}\n\n\t\tif (prevOpCode == IMUL && seen == I2L) {\n\t\t\tint priority = adjustPriority(imul_constant, NORMAL_PRIORITY);\n\t\t\tif (priority >= LOW_PRIORITY && imul_constant != 1000 && imul_constant != 60 && imul_operand_is_parameter) priority = NORMAL_PRIORITY;\n\t\t\tif (priority <= best_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG) {\n\t\t\t\tbest_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG = priority;\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\"ICAST_INTEGER_MULTIPLY_CAST_TO_LONG\", \n\t\t\t\t\t\tpriority)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\t\tif (getMethodName().equals(\"<clinit>\") && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {\n\t\t\tString clazz = getClassConstantOperand();\n\t\t\tif (!clazz.equals(getClassName())) {\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass targetClass = Repository.lookupClass(clazz);\n\t\t\t\t\tif (Repository.instanceOf(targetClass, getThisClass())) {\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\t\tif (seen == GETSTATIC) priority--;\n\t\t\t\t\t\tif (!targetClass.isPublic()) priority++;\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\t\t\"IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION\", \n\t\t\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(this).addClass(getClassConstantOperand()),\n\t\t\t\t\t\tthis);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// ignore it\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (false && (seen == INVOKEVIRTUAL)\n\t\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\n\t\tif (seen >= IALOAD && seen <= SALOAD || seen >= IASTORE && seen <= SASTORE ) {\n\t\t\tItem index  = stack.getStackItem(0);\n\t\t\tif (index.getSpecialKind() == Item.AVERAGE_COMPUTED_USING_DIVISION) {\n\t\t\t\tSourceLineAnnotation where;\n\t\t\t\tif (index.getPC() >= 0)\n\t\t\t\t\twhere = SourceLineAnnotation.fromVisitedInstruction(this, index.getPC());\n\t\t\t\telse where = SourceLineAnnotation.fromVisitedInstruction(this);\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), where);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t\t&& getPrevOpcode(3) == IREM\n\t\t)\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue && \n\t\t\t\t(!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t\t|| seen == I2B && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)) \n\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\n\n\t\tconstantArgumentToShift = false;\n\t\tshiftOfNonnegativeValue = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject rightHandSide\n\t\t\t\t= stack.getStackItem(0).getConstant();\n\n\t\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\t\tshiftOfNonnegativeValue = stack.getStackItem(1).isNonNegative();\n\t\t\t\tif (rightHandSide instanceof Integer) {\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", \n\t\t\t\t\t\t\t\tvalueOfConstantArgumentToShift < 0 ? LOW_PRIORITY \n\t\t\t\t\t\t\t\t\t\t: (valueOfConstantArgumentToShift == 32 && getMethodName().equals(\"hashCode\") \n\t\t\t\t\t\t\t\t\t\t\t\t? NORMAL_PRIORITY : HIGH_PRIORITY))\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift).describe(IntAnnotation.INT_SHIFT)\n\t\t\t\t\t\t.addValueSource(stack.getStackItem(1), this), this);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n\t\t\t\t&& (getClassConstantOperand().equals(\"java/util/Date\") \n\t\t\t\t\t\t|| getClassConstantOperand().equals(\"java/sql/Date\"))\n\t\t\t\t&& getNameConstantOperand().equals(\"setMonth\")\n\t\t\t\t&& getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", HIGH_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Calendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"set\")\n\n\t\t\t\t||\n\t\t\t\tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"<init>\")\n\n\t\t) {\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tif (sig.startsWith(\"(III\")) {\n\t\t\t\tint pos = sig.length() - 5;\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(pos);\n\t\t\t\tObject o = item.getConstant();\n\t\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\t\tint v = (Integer) o;\n\t\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t\t|| seen == ISTORE_0\n\t\t\t\t|| seen == ISTORE_1\n\t\t\t\t|| seen == ISTORE_2\n\t\t\t\t|| seen == ISTORE_3)\n\t\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\n\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t// Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) {\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\tif (!item.isNonNegative() && item.getSpecialKind() != OpcodeStack.Item.MATH_ABS)\n\t\t\t\t\tbadlyComputingOddState++;\n\t\t\t\telse  badlyComputingOddState = 0;\n\t\t\t}\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE)  {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n\t\t\t\t&& (getNameConstantOperand().equals(\"toString\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n\t\t\t\t\t\t|| (getNameConstantOperand().equals(\"print\") || getNameConstantOperand().equals(\"println\"))\n\t\t\t\t\t\t \t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)V\")\n\t\t\t\t)\n\t\t) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tString signature = item.getSignature();\n\t\t\tif (signature != null && signature.startsWith(\"[\")) {\n\t\t\t\tboolean debuggingContext = signature.equals(\"[Ljava/lang/StackTraceElement;\");\n\t\t\t\t\n\t\t\t\tif (!debuggingContext) {\n\t\t\t\t\tfor(CodeException e : getCode().getExceptionTable()) {\n\t\t\t\t\t\tif (e.getHandlerPC()<= getPC() && e.getHandlerPC() +30 >= getPC())\n\t\t\t\t\t\t\tdebuggingContext = true;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\t\t\t\t\tfor(int i = 1; !debuggingContext &&  i < stack.getStackDepth(); i++) {\n\t\t\t\t\tOpcodeStack.Item e = stack.getStackItem(i);\n\t\t\t\t\t\n\t\t\t\t\tif (e.getSignature().indexOf(\"Logger\") >= 0 || e.getSignature().indexOf(\"Exception\") >= 0) debuggingContext = true;\n\t\t\t\t\t\n\t\t\t\t\tXField f = e.getXField();\n\t\t\t\t\tif (f != null && (SYSTEM_ERR.equals(f.getFieldDescriptor()) || SYSTEM_OUT.equals(f.getFieldDescriptor())))\n\t\t\t\t\t\t\tdebuggingContext = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString name = null;\n\t\t\t\tint reg = item.getRegisterNumber();\n\t\t\t\tCollection<BugAnnotation> as = new ArrayList<BugAnnotation>();\n\t\t\t\tXField field = item.getXField();\n\t\t\t\tFieldAnnotation fieldAnnotation = null;\n\t\t\t\tif (field != null) {\n\t\t\t\t\tfieldAnnotation = FieldAnnotation.fromXField(field);\n\t\t\t\t\tfieldAnnotation.setDescription(FieldAnnotation.LOADED_FROM_ROLE);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tif(reg != -1) {\n\t\t\t\t\tLocalVariableAnnotation lva =\n\t\t\t\t\t\tLocalVariableAnnotation.getLocalVariableAnnotation(\n\t\t\t\t\t\t\tgetMethod(), reg, getPC(), getPC()-1);\n\t\t\t\t\tif (lva.isNamed()) {\n\t\t\t\t\t\tas.add(lva);\n\t\t\t\t\t\tif (fieldAnnotation != null)\n\t\t\t\t\t\t\tas.add(fieldAnnotation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fieldAnnotation != null) \n\t\t\t\t\t\t\tas.add(fieldAnnotation);\n\t\t\t\t\t\tas.add(lva);\n\t\t\t\t\t}\n\t\t\t\t} else if (fieldAnnotation != null)\n\t\t\t\t\t\tas.add(fieldAnnotation);\n\t\t\t\telse {\n\t\t\t\t\tXMethod m = item.getReturnValueOf();\n\t\t\t\t\tif (m != null) {\n\t\t\t\t\t\tMethodAnnotation methodAnnotation = MethodAnnotation.fromXMethod(m);\n\t\t\t\t\t\tmethodAnnotation.setDescription(MethodAnnotation.METHOD_RETURN_VALUE_OF);\n\t\t\t\t\t\tas.add(methodAnnotation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint priority = debuggingContext ? NORMAL_PRIORITY : HIGH_PRIORITY;\n\t\t\t\tif(!as.isEmpty()) {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", priority)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addAnnotations(as), this);\n\t\t\t\t} else {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY\", priority)\n\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isTigerOrHigher) {\n\t\t\tif (previousMethodInvocation != null && prevOpCode == INVOKESPECIAL && seen == INVOKEVIRTUAL) {\n\t\t\t\tString classNameForPreviousMethod = previousMethodInvocation.getClassName();\n\t\t\t\tString classNameForThisMethod = getClassConstantOperand();\n\t\t\t\tif (classNameForPreviousMethod.startsWith(\"java.lang.\") \n\t\t\t\t\t\t&& classNameForPreviousMethod.equals(classNameForThisMethod.replace('/','.'))\n\t\t\t\t\t\t&& getNameConstantOperand().endsWith(\"Value\")\n\t\t\t\t\t\t&& getSigConstantOperand().length() == 3) {\n\t\t\t\t\tif (getSigConstantOperand().charAt(2) == previousMethodInvocation.getSignature().charAt(1))\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\t} else ternaryConversionState = 0;\n\n\t\t\t} else if (false && seen == INVOKEVIRTUAL) {\n\t\t\t\tif (getClassConstantOperand().startsWith(\"java/lang\") && getNameConstantOperand().endsWith(\"Value\") && getSigConstantOperand().length() == 3)\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}else if (ternaryConversionState == 1) {\n\t\t\t\tif (I2L < seen && seen <= I2S) \n\t\t\t\t\tternaryConversionState = 2;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}\n\t\t\telse if (ternaryConversionState == 2) {\n\t\t\t\tternaryConversionState = 0;\n\t\t\t\tif (seen == GOTO) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t} else ternaryConversionState = 0;\n\t\t}\n\n\t\tAssertInvokedFromRun: \n\t\tif (seen == INVOKESTATIC)\n\t\t\tif ((getNameConstantOperand().startsWith(\"assert\") || getNameConstantOperand().startsWith(\"fail\")) && getMethodName().equals(\"run\")\n\t\t\t\t\t&& implementsRunnable(getThisClass())) {\n\t\t\t\t\tint size1 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n\t\t\t\t\t        \"java/lang/Throwable\", getPC());\n\t\t\t\t\tint size2 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(), \"java/lang/Error\",\n\t\t\t\t\t        getPC());\n\t\t\t\tint size3 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n\t\t\t\t        \"java/lang/AssertionFailureError\", getPC());\n\t\t\t\tint size = Math.min(Math.min(size1, size2), size3);\n\t\t\t\tif (size == Integer.MAX_VALUE) {\n\t\t\t\t\tString dottedClassName = getClassConstantOperand().replace('/', '.');\n\t\t\t\t\tif (!dottedClassName.startsWith(\"junit\")) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJavaClass targetClass = AnalysisContext.currentAnalysisContext().lookupClass(dottedClassName);\n\t\t\t\t\t\t\tif (!targetClass.getSuperclassName().startsWith(\"junit\"))\n\t\t\t\t\t\t\t\tbreak AssertInvokedFromRun;\n\t\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t\t\t\tbreak AssertInvokedFromRun;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD\",\n\t\t\t\t\t        NORMAL_PRIORITY).addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\tif (seen == INVOKESPECIAL && getClassConstantOperand().startsWith(\"java/lang/\")  && getNameConstantOperand().equals(\"<init>\")\n\t\t\t\t&& getSigConstantOperand().length() == 4\n\t\t) \n\n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse if (seen == INVOKESTATIC && getClassConstantOperand().startsWith(\"java/lang/\")  \n\t\t\t\t&& getNameConstantOperand().equals(\"valueOf\")\n\t\t\t\t&& getSigConstantOperand().length() == 4) \n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse previousMethodInvocation = null;\n\t\t\n\t\t\n\t\t\n\t\tif (seen == LDC2_W) {\n\t\t\tvalue_LDC2_W = getConstantRefOperand();\n\t\t} else if (seen == L2I && getPrevOpcode(1) == LAND && getPrevOpcode(2) == LDC2_W && value_LDC2_W instanceof ConstantLong) {\n\t\t\tConstantLong longValue = (ConstantLong) value_LDC2_W;\n\t\t\tif (longValue.getBytes() == 0xEFFFFFFF)\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"UNKNOWN\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n\n\t\t}\n\t\tprevOpCode = seen;\n\n\t\t}","id":32108,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t\n\n\t\tif (seen == INVOKEVIRTUAL &&   getNameConstantOperand().equals(\"hashCode\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"()I\")\n\t\t\t\t&& stack.getStackDepth() > 0) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tif (item0.getSignature().charAt(0) == '[')\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_INVOKING_HASHCODE_ON_ARRAY\", NORMAL_PRIORITY).addClassAndMethod(this)\n\t\t\t\t\t\t.addValueSource(item0, this)\n\t\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\t\tif (seen != RETURN && isReturn(seen) && isRegisterStore(getPrevOpcode(1))) {\n\t\t\t\n\t\t\tint priority = Priorities.NORMAL_PRIORITY;\n\t\t\tif  (getMethodSig().endsWith(\")Z\")) priority =  Priorities.HIGH_PRIORITY;\n\t\t\telse {\n\t\t\t\tif (getMethodSig().endsWith(\")Ljava/lang/String;\")) priority =  Priorities.LOW_PRIORITY;\n\t\t\t\tif (getPC() == getCode().getCode().length-1 ) priority++;\n\t\t\t}\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"DLS_DEAD_LOCAL_STORE_IN_RETURN\", priority).addClassAndMethod(this).addSourceLine(this));\n\t\t}\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + ternaryConversionState);\n\t\tif (seen == IMUL) {\n\t\t\tif (imul_distance != 1) resetIMulCastLong();\n\t\t\timul_distance = 0;\n\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\t\t\t\timul_constant = adjustMultiplier(item0.getConstant(), imul_constant);\n\t\t\t\timul_constant = adjustMultiplier(item1.getConstant(), imul_constant);\n\n\t\t\t\tif (item0.isInitialParameter() || item1.isInitialParameter())\n\t\t\t\t\timul_operand_is_parameter = true;\n\t\t\t}} else {\n\t\t\t\timul_distance++;\n\t\t\t}\n\n\t\tif (prevOpCode == IMUL && seen == I2L) {\n\t\t\tint priority = adjustPriority(imul_constant, NORMAL_PRIORITY);\n\t\t\tif (priority >= LOW_PRIORITY && imul_constant != 1000 && imul_constant != 60 && imul_operand_is_parameter) priority = NORMAL_PRIORITY;\n\t\t\tif (priority <= best_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG) {\n\t\t\t\tbest_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG = priority;\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\"ICAST_INTEGER_MULTIPLY_CAST_TO_LONG\", \n\t\t\t\t\t\tpriority)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\t\tif (getMethodName().equals(\"<clinit>\") && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {\n\t\t\tString clazz = getClassConstantOperand();\n\t\t\tif (!clazz.equals(getClassName())) {\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass targetClass = Repository.lookupClass(clazz);\n\t\t\t\t\tif (Repository.instanceOf(targetClass, getThisClass())) {\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\t\tif (seen == GETSTATIC) priority--;\n\t\t\t\t\t\tif (!targetClass.isPublic()) priority++;\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\t\t\"IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION\", \n\t\t\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(this).addClass(getClassConstantOperand()),\n\t\t\t\t\t\tthis);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// ignore it\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (false && (seen == INVOKEVIRTUAL)\n\t\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\n\t\tif (seen >= IALOAD && seen <= SALOAD || seen >= IASTORE && seen <= SASTORE ) {\n\t\t\tItem index  = stack.getStackItem(0);\n\t\t\tif (index.getSpecialKind() == Item.AVERAGE_COMPUTED_USING_DIVISION) {\n\t\t\t\tSourceLineAnnotation where;\n\t\t\t\tif (index.getPC() >= 0)\n\t\t\t\t\twhere = SourceLineAnnotation.fromVisitedInstruction(this, index.getPC());\n\t\t\t\telse where = SourceLineAnnotation.fromVisitedInstruction(this);\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), where);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t\t&& getPrevOpcode(3) == IREM\n\t\t)\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue && \n\t\t\t\t(!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t\t|| seen == I2B && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)) \n\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\n\n\t\tconstantArgumentToShift = false;\n\t\tshiftOfNonnegativeValue = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject rightHandSide\n\t\t\t\t= stack.getStackItem(0).getConstant();\n\n\t\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\t\tshiftOfNonnegativeValue = stack.getStackItem(1).isNonNegative();\n\t\t\t\tif (rightHandSide instanceof Integer) {\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", \n\t\t\t\t\t\t\t\tvalueOfConstantArgumentToShift < 0 ? LOW_PRIORITY \n\t\t\t\t\t\t\t\t\t\t: (valueOfConstantArgumentToShift == 32 && getMethodName().equals(\"hashCode\") \n\t\t\t\t\t\t\t\t\t\t\t\t? NORMAL_PRIORITY : HIGH_PRIORITY))\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift).describe(IntAnnotation.INT_SHIFT)\n\t\t\t\t\t\t.addValueSource(stack.getStackItem(1), this), this);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n\t\t\t\t&& (getClassConstantOperand().equals(\"java/util/Date\") \n\t\t\t\t\t\t|| getClassConstantOperand().equals(\"java/sql/Date\"))\n\t\t\t\t&& getNameConstantOperand().equals(\"setMonth\")\n\t\t\t\t&& getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", HIGH_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Calendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"set\")\n\n\t\t\t\t||\n\t\t\t\tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"<init>\")\n\n\t\t) {\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tif (sig.startsWith(\"(III\")) {\n\t\t\t\tint pos = sig.length() - 5;\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(pos);\n\t\t\t\tObject o = item.getConstant();\n\t\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\t\tint v = (Integer) o;\n\t\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t\t|| seen == ISTORE_0\n\t\t\t\t|| seen == ISTORE_1\n\t\t\t\t|| seen == ISTORE_2\n\t\t\t\t|| seen == ISTORE_3)\n\t\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\n\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t// Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) {\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\tif (!item.isNonNegative() && item.getSpecialKind() != OpcodeStack.Item.MATH_ABS)\n\t\t\t\t\tbadlyComputingOddState++;\n\t\t\t\telse  badlyComputingOddState = 0;\n\t\t\t}\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE)  {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n\t\t\t\t&& (getNameConstantOperand().equals(\"toString\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n\t\t\t\t\t\t|| (getNameConstantOperand().equals(\"print\") || getNameConstantOperand().equals(\"println\"))\n\t\t\t\t\t\t \t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)V\")\n\t\t\t\t)\n\t\t) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tString signature = item.getSignature();\n\t\t\tif (signature != null && signature.startsWith(\"[\")) {\n\t\t\t\tboolean debuggingContext = signature.equals(\"[Ljava/lang/StackTraceElement;\");\n\t\t\t\t\n\t\t\t\tif (!debuggingContext) {\n\t\t\t\t\tfor(CodeException e : getCode().getExceptionTable()) {\n\t\t\t\t\t\tif (e.getHandlerPC()<= getPC() && e.getHandlerPC() +30 >= getPC())\n\t\t\t\t\t\t\tdebuggingContext = true;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\t\t\t\t\tfor(int i = 1; !debuggingContext &&  i < stack.getStackDepth(); i++) {\n\t\t\t\t\tOpcodeStack.Item e = stack.getStackItem(i);\n\t\t\t\t\t\n\t\t\t\t\tif (e.getSignature().indexOf(\"Logger\") >= 0 || e.getSignature().indexOf(\"Exception\") >= 0) debuggingContext = true;\n\t\t\t\t\t\n\t\t\t\t\tXField f = e.getXField();\n\t\t\t\t\tif (f != null && (SYSTEM_ERR.equals(f.getFieldDescriptor()) || SYSTEM_OUT.equals(f.getFieldDescriptor())))\n\t\t\t\t\t\t\tdebuggingContext = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString name = null;\n\t\t\t\tint reg = item.getRegisterNumber();\n\t\t\t\tCollection<BugAnnotation> as = new ArrayList<BugAnnotation>();\n\t\t\t\tXField field = item.getXField();\n\t\t\t\tFieldAnnotation fieldAnnotation = null;\n\t\t\t\tif (field != null) {\n\t\t\t\t\tfieldAnnotation = FieldAnnotation.fromXField(field);\n\t\t\t\t\tfieldAnnotation.setDescription(FieldAnnotation.LOADED_FROM_ROLE);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tif(reg != -1) {\n\t\t\t\t\tLocalVariableAnnotation lva =\n\t\t\t\t\t\tLocalVariableAnnotation.getLocalVariableAnnotation(\n\t\t\t\t\t\t\tgetMethod(), reg, getPC(), getPC()-1);\n\t\t\t\t\tif (lva.isNamed()) {\n\t\t\t\t\t\tas.add(lva);\n\t\t\t\t\t\tif (fieldAnnotation != null)\n\t\t\t\t\t\t\tas.add(fieldAnnotation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fieldAnnotation != null) \n\t\t\t\t\t\t\tas.add(fieldAnnotation);\n\t\t\t\t\t\tas.add(lva);\n\t\t\t\t\t}\n\t\t\t\t} else if (fieldAnnotation != null)\n\t\t\t\t\t\tas.add(fieldAnnotation);\n\t\t\t\telse {\n\t\t\t\t\tXMethod m = item.getReturnValueOf();\n\t\t\t\t\tif (m != null) {\n\t\t\t\t\t\tMethodAnnotation methodAnnotation = MethodAnnotation.fromXMethod(m);\n\t\t\t\t\t\tmethodAnnotation.setDescription(MethodAnnotation.METHOD_RETURN_VALUE_OF);\n\t\t\t\t\t\tas.add(methodAnnotation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint priority = debuggingContext ? NORMAL_PRIORITY : HIGH_PRIORITY;\n\t\t\t\tif(!as.isEmpty()) {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", priority)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addAnnotations(as), this);\n\t\t\t\t} else {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY\", priority)\n\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isTigerOrHigher) {\n\t\t\tif (previousMethodInvocation != null && prevOpCode == INVOKESPECIAL && seen == INVOKEVIRTUAL) {\n\t\t\t\tString classNameForPreviousMethod = previousMethodInvocation.getClassName();\n\t\t\t\tString classNameForThisMethod = getClassConstantOperand();\n\t\t\t\tif (classNameForPreviousMethod.startsWith(\"java.lang.\") \n\t\t\t\t\t\t&& classNameForPreviousMethod.equals(classNameForThisMethod.replace('/','.'))\n\t\t\t\t\t\t&& getNameConstantOperand().endsWith(\"Value\")\n\t\t\t\t\t\t&& getSigConstantOperand().length() == 3) {\n\t\t\t\t\tif (getSigConstantOperand().charAt(2) == previousMethodInvocation.getSignature().charAt(1))\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\t} else ternaryConversionState = 0;\n\n\t\t\t} else if (false && seen == INVOKEVIRTUAL) {\n\t\t\t\tif (getClassConstantOperand().startsWith(\"java/lang\") && getNameConstantOperand().endsWith(\"Value\") && getSigConstantOperand().length() == 3)\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}else if (ternaryConversionState == 1) {\n\t\t\t\tif (I2L < seen && seen <= I2S) \n\t\t\t\t\tternaryConversionState = 2;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}\n\t\t\telse if (ternaryConversionState == 2) {\n\t\t\t\tternaryConversionState = 0;\n\t\t\t\tif (seen == GOTO) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t} else ternaryConversionState = 0;\n\t\t}\n\n\t\tAssertInvokedFromRun: \n\t\tif (seen == INVOKESTATIC)\n\t\t\tif ((getNameConstantOperand().startsWith(\"assert\") || getNameConstantOperand().startsWith(\"fail\")) && getMethodName().equals(\"run\")\n\t\t\t\t\t&& implementsRunnable(getThisClass())) {\n\t\t\t\t\tint size1 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n\t\t\t\t\t        \"java/lang/Throwable\", getPC());\n\t\t\t\t\tint size2 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(), \"java/lang/Error\",\n\t\t\t\t\t        getPC());\n\t\t\t\tint size3 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n\t\t\t\t        \"java/lang/AssertionFailureError\", getPC());\n\t\t\t\tint size = Math.min(Math.min(size1, size2), size3);\n\t\t\t\tif (size == Integer.MAX_VALUE) {\n\t\t\t\t\tString dottedClassName = getClassConstantOperand().replace('/', '.');\n\t\t\t\t\tif (!dottedClassName.startsWith(\"junit\")) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJavaClass targetClass = AnalysisContext.currentAnalysisContext().lookupClass(dottedClassName);\n\t\t\t\t\t\t\tif (!targetClass.getSuperclassName().startsWith(\"junit\"))\n\t\t\t\t\t\t\t\tbreak AssertInvokedFromRun;\n\t\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t\t\t\tbreak AssertInvokedFromRun;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD\",\n\t\t\t\t\t        NORMAL_PRIORITY).addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\tif (seen == INVOKESPECIAL && getClassConstantOperand().startsWith(\"java/lang/\")  && getNameConstantOperand().equals(\"<init>\")\n\t\t\t\t&& getSigConstantOperand().length() == 4\n\t\t) \n\n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse if (seen == INVOKESTATIC && getClassConstantOperand().startsWith(\"java/lang/\")  \n\t\t\t\t&& getNameConstantOperand().equals(\"valueOf\")\n\t\t\t\t&& getSigConstantOperand().length() == 4) \n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse previousMethodInvocation = null;\n\t\t\n\t\t\n\t\t\n\t\tif (seen == IAND || seen == LAND) {\n\t\t\tOpcodeStack.Item rhs = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item lhs = stack.getStackItem(1);\n\t\t\tObject constant = rhs.getConstant();\n\t\t\tOpcodeStack.Item value = lhs;\n\t\t\tif (constant == null) {\n\t\t\t\tconstant = lhs.getConstant();\n\t\t\t\tvalue = rhs;\n\t\t\t}\n\t\t\tif (constant instanceof Number) {\n\t\t\t\tlong constantValue = ((Number)constant).longValue();\n\t\t\t\tif (constantValue == 0xEFFFFFFF || constantValue == 0xEFFFFFFFFFFFFFFFL)\n\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"TESTING\", NORMAL_PRIORITY).addClassAndMethod(this)\n\t\t\t\t\t\t\t.addString(\"Apparent failed attempt to mask lower 31 bits of an int\").addValueSource(value, this), this);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (seen == LDC2_W) {\n\t\t\tvalue_LDC2_W = getConstantRefOperand();\n\t\t} else if (seen == L2I && getPrevOpcode(1) == LAND && getPrevOpcode(2) == LDC2_W && value_LDC2_W instanceof ConstantLong) {\n\t\t\tConstantLong longValue = (ConstantLong) value_LDC2_W;\n\t\t\tif (longValue.getBytes() == 0xEFFFFFFF)\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"TESTING\", NORMAL_PRIORITY).addClassAndMethod(this).addString(\"Apparent failed attempt to mask lower 31 bits of an int\"), this);\n\t\t}\n\t\tprevOpCode = seen;\n\n\t\t}","commit_id":"b0c5ce9f73123b434a2843bf4afa24662a3573fb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static void marshallMap(File file)\n    {\n        marshallMap(file, tufts.vue.VUE.getActiveMap());\n    }","id":32109,"modified_method":"/**A static method which creates an appropriate marshaller and marshal the active map*/\n    public static void marshallMap(File file)\n    {\n        marshallMap(file, tufts.vue.VUE.getActiveMap());\n    }","commit_id":"92a8656387548f9a89d1b508790dcd3a6fb373fa","url":"https://github.com/VUE/VUE"},{"original_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, String fileType)\n    {\n        File file = null;\n        \n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        \n        chooser.setAcceptAllFileFilterUsed(false);\n        \n        if (fileType != null)\n         chooser.setFileFilter(new VueFileFilter(fileType)); \n        \n        else\n        {\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"xml\"));  \n            chooser.setFileFilter(new VueFileFilter(\"xml\")); \n            chooser.addChoosableFileFilter(new VueFileFilter(\"jpeg\"));  \n            chooser.addChoosableFileFilter(new VueFileFilter(\"svg\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"pdf\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"html\"));\n        }\n            \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Save\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            boolean proceed = true;\n            \n            if (chooser.getSelectedFile().exists())\n              {\n                int n = JOptionPane.showConfirmDialog(null, \"Would you Like to Replace the File\", \n                        \"Replacing File\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                  proceed = false;\n                \n              } \n        \n            if (proceed == true)\n              {\n                String fileName = chooser.getSelectedFile().getAbsolutePath();\n                  \n                String extension = chooser.getFileFilter().getDescription();\n                \n                //if it isn't a file name with the right extention \n                if (!fileName.endsWith(\".\" + extension))\n                fileName += \".\" + extension;\n                \n                file = new File(fileName); \n                  \n                // if they choose nothing, fileName will be null -- detect & abort\n                VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getParent());\n              }\n        }\n        \n        return file;\n    }","id":32110,"modified_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, String fileType)\n    {\n        File picked = null;\n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        \n        chooser.setAcceptAllFileFilterUsed(false);\n        \n        if (fileType != null)\n         chooser.setFileFilter(new VueFileFilter(fileType)); \n        \n        else\n        {\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"xml\"));  \n            chooser.setFileFilter(new VueFileFilter(\"xml\")); \n            chooser.addChoosableFileFilter(new VueFileFilter(\"jpeg\"));  \n            chooser.addChoosableFileFilter(new VueFileFilter(\"svg\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"pdf\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"html\"));\n        }\n            \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Save\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            picked = chooser.getSelectedFile();\n            \n            boolean proceed = true;\n            String fileName = picked.getAbsolutePath();\n            String extension = chooser.getFileFilter().getDescription();\n                \n            //if it isn't a file name with the right extention \n            if (!fileName.endsWith(\".\" + extension)) {\n                fileName += \".\" + extension;\n                picked = new File(fileName);\n            }\n            \n            if (picked.exists()) {\n                int n = JOptionPane.showConfirmDialog(null, \"Would you Like to Replace the File \\'\" + picked.getName() + \"\\'\", \n                        \"Replacing File\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                    proceed = false;\n            } \n            \n            if (proceed == true) {\n                VueUtil.setCurrentDirectoryPath(picked.getParent());\n            }\n        }\n        \n        return picked;\n    }","commit_id":"92a8656387548f9a89d1b508790dcd3a6fb373fa","url":"https://github.com/VUE/VUE"},{"original_method":"/**A static method which creates an appropriate marshaller and marshal the active map*/\n    public static void marshallMap(File file, LWMap map)\n    {\n        Marshaller marshaller = null;\n        \n        //if (this.marshaller == null) {\n        Mapping mapping = new Mapping();\n            \n        try \n        {  \n            FileWriter writer = new FileWriter(file);\n            \n            marshaller = new Marshaller(writer);\n            mapping.loadMapping(XML_MAPPING);\n            marshaller.setMapping(mapping);\n            \n            System.out.println(\"start of marshall\");\n            marshaller.marshal(map);\n            System.out.println(\"end of marshall\");\n            \n            writer.flush();\n            writer.close();\n            \n        } \n        catch (Exception e) \n        {\n            System.err.println(\"ActionUtil.marshallMap: \" + e);\n        }\n        //}\n    }","id":32111,"modified_method":"/**A static method which creates an appropriate marshaller and marshal the given map*/\n    public static void marshallMap(File file, LWMap map)\n    {\n        Marshaller marshaller = null;\n        \n        //if (this.marshaller == null) {\n        Mapping mapping = new Mapping();\n            \n        try \n        {  \n            FileWriter writer = new FileWriter(file);\n            \n            marshaller = new Marshaller(writer);\n            mapping.loadMapping(XML_MAPPING);\n            marshaller.setMapping(mapping);\n            \n            System.out.println(\"start of marshall\");\n            marshaller.marshal(map);\n            System.out.println(\"end of marshall\");\n            \n            writer.flush();\n            writer.close();\n\n            map.setFile(file);\n        } \n        catch (Exception e) \n        {\n            System.err.println(\"ActionUtil.marshallMap: \" + e);\n        }\n        //}\n    }","commit_id":"92a8656387548f9a89d1b508790dcd3a6fb373fa","url":"https://github.com/VUE/VUE"},{"original_method":"public LWMap loadMap(String filename)\n    {\n        try \n        {\n            \n            //Unmarshaller unmarshaller = ActionUtil.getUnmarshaller();\n            if (debug) System.err.println(\"Unmarshalling from \" + filename);\n            \n            //LWMap map = (LWMap) unmarshaller.unmarshal(new InputSource(reader));\n            //map.completeXMLRestore();\n            //return map;\n            File file = new File(filename);\n            LWMap map = ActionUtil.unmarshallMap(file);\n            map.setLabel(file.getName());\n            return map;\n        } \n        catch (Exception e) \n        {\n            System.err.println(\"OpenAction.loadMap[\" + filename + \"]: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n    }","id":32112,"modified_method":"public LWMap loadMap(String filename)\n    {\n        try \n        {\n            \n            //Unmarshaller unmarshaller = ActionUtil.getUnmarshaller();\n            if (debug) System.err.println(\"Unmarshalling from \" + filename);\n            \n            //LWMap map = (LWMap) unmarshaller.unmarshal(new InputSource(reader));\n            //map.completeXMLRestore();\n            //return map;\n            File file = new File(filename);\n            LWMap map = ActionUtil.unmarshallMap(file);\n            map.setFile(file);\n            return map;\n        } \n        catch (Exception e) \n        {\n            System.err.println(\"OpenAction.loadMap[\" + filename + \"]: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n    }","commit_id":"92a8656387548f9a89d1b508790dcd3a6fb373fa","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e)\n    {\n        System.out.println(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n         \n        boolean saveCondition = true;\n        \n        if (isSaveAs() || file == null)\n        {\n          file = ActionUtil.selectFile(\"Save Map\", \"xml\");\n          \n          if (file == null)\n              saveCondition = false;\n        }\n        \n        if (saveCondition == true)\n        {\n            if (file.getName().endsWith(\".xml\")) {\n                LWMap map = tufts.vue.VUE.getActiveMap();\n                map.setLabel(file.getName());\n                ActionUtil.marshallMap(file, map);\n            }\n          else if (file.getName().endsWith(\".jpeg\"))\n            new ImageConversion().createJpeg(file);\n          \n          else if (file.getName().endsWith(\".svg\"))\n            new SVGConversion().createSVG(file);\n          \n          else if (file.getName().endsWith(\".pdf\"))\n            new PDFTransform().convert(file);\n          \n          else if (file.getName().endsWith(\".html\"))\n            new HTMLConversion().convert(file);\n          \n          System.out.println(\"Saved \" + getFileName());\n        }\n            \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","id":32113,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        System.out.println(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n        \n        LWMap map = tufts.vue.VUE.getActiveMap();\n        File file = map.getFile();\n        \n        if (isSaveAs() || file == null)\n            file = ActionUtil.selectFile(\"Save Map\", \"xml\");\n        \n        if (file != null)\n        {\n            String name = file.getName().toLowerCase();\n\n            if (name.endsWith(\".xml\"))\n                ActionUtil.marshallMap(file, map);\n            \n            else if (name.endsWith(\".jpeg\") || name.endsWith(\".jpg\"))\n                new ImageConversion().createJpeg(file);\n\n            else if (name.endsWith(\".svg\"))\n                new SVGConversion().createSVG(file);\n\n            else if (name.endsWith(\".pdf\"))\n                new PDFTransform().convert(file);\n\n            else if (name.endsWith(\".html\"))\n                new HTMLConversion().convert(file);\n            \n            System.out.println(\"Wrote \" + file);\n        }\n            \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","commit_id":"92a8656387548f9a89d1b508790dcd3a6fb373fa","url":"https://github.com/VUE/VUE"},{"original_method":"/**A static method which creates an appropriate marshaller and marshal the active map*/\n    public static void marshallMap(File file)\n    {\n        Marshaller marshaller = null;\n        \n        //if (this.marshaller == null) {\n        Mapping mapping = new Mapping();\n            \n        try \n        {  \n            FileWriter writer = new FileWriter(file);\n            \n            marshaller = new Marshaller(writer);\n            mapping.loadMapping(XML_MAPPING);\n            marshaller.setMapping(mapping);\n            \n            System.out.println(\"start of marshall\");\n            marshaller.marshal(tufts.vue.VUE.getActiveMap());\n            System.out.println(\"end of marshall\");\n            \n            writer.flush();\n            writer.close();\n            \n        } \n        catch (Exception e) \n        {\n            System.err.println(\"ActionUtil.marshallMap: \" + e);\n        }\n        //}\n    }","id":32114,"modified_method":"public static void marshallMap(File file)\n    {\n        marshallMap(file, tufts.vue.VUE.getActiveMap());\n    }","commit_id":"a9c5122a4543f0433938081ce30390d473e6427e","url":"https://github.com/VUE/VUE"},{"original_method":"public LWMap loadMap(String filename)\n    {\n        try \n        {\n            \n            //Unmarshaller unmarshaller = ActionUtil.getUnmarshaller();\n            if (debug) System.err.println(\"Unmarshalling from \" + filename);\n            \n            //LWMap map = (LWMap) unmarshaller.unmarshal(new InputSource(reader));\n            //map.completeXMLRestore();\n            //return map;\n            \n            return (ActionUtil.unmarshallMap(new File(filename)));\n        } \n        catch (Exception e) \n        {\n            System.err.println(\"OpenAction.loadMap[\" + filename + \"]: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n    }","id":32115,"modified_method":"public LWMap loadMap(String filename)\n    {\n        try \n        {\n            \n            //Unmarshaller unmarshaller = ActionUtil.getUnmarshaller();\n            if (debug) System.err.println(\"Unmarshalling from \" + filename);\n            \n            //LWMap map = (LWMap) unmarshaller.unmarshal(new InputSource(reader));\n            //map.completeXMLRestore();\n            //return map;\n            File file = new File(filename);\n            LWMap map = ActionUtil.unmarshallMap(file);\n            map.setLabel(file.getName());\n            return map;\n        } \n        catch (Exception e) \n        {\n            System.err.println(\"OpenAction.loadMap[\" + filename + \"]: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n    }","commit_id":"a9c5122a4543f0433938081ce30390d473e6427e","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e)\n    {\n        System.out.println(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n         \n        boolean saveCondition = true;\n        \n        if (isSaveAs() || file == null)\n        {\n          file = ActionUtil.selectFile(\"Save Map\", \"xml\");\n          \n          if (file == null)\n              saveCondition = false;\n        }\n        \n        if (saveCondition == true)\n        {\n          if (file.getName().endsWith(\".xml\"))\n            ActionUtil.marshallMap(file);\n          \n          else if (file.getName().endsWith(\".jpeg\"))\n            new ImageConversion().createJpeg(file);\n          \n          else if (file.getName().endsWith(\".svg\"))\n            new SVGConversion().createSVG(file);\n          \n          else if (file.getName().endsWith(\".pdf\"))\n            new PDFTransform().convert(file);\n          \n          else if (file.getName().endsWith(\".html\"))\n            new HTMLConversion().convert(file);\n          \n          System.out.println(\"Saved \" + getFileName());\n        }\n            \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","id":32116,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        System.out.println(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n         \n        boolean saveCondition = true;\n        \n        if (isSaveAs() || file == null)\n        {\n          file = ActionUtil.selectFile(\"Save Map\", \"xml\");\n          \n          if (file == null)\n              saveCondition = false;\n        }\n        \n        if (saveCondition == true)\n        {\n            if (file.getName().endsWith(\".xml\")) {\n                LWMap map = tufts.vue.VUE.getActiveMap();\n                map.setLabel(file.getName());\n                ActionUtil.marshallMap(file, map);\n            }\n          else if (file.getName().endsWith(\".jpeg\"))\n            new ImageConversion().createJpeg(file);\n          \n          else if (file.getName().endsWith(\".svg\"))\n            new SVGConversion().createSVG(file);\n          \n          else if (file.getName().endsWith(\".pdf\"))\n            new PDFTransform().convert(file);\n          \n          else if (file.getName().endsWith(\".html\"))\n            new HTMLConversion().convert(file);\n          \n          System.out.println(\"Saved \" + getFileName());\n        }\n            \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","commit_id":"a9c5122a4543f0433938081ce30390d473e6427e","url":"https://github.com/VUE/VUE"},{"original_method":"/**A static method which displays a file chooser for the user to choose which file to open.\n       It returns the selected file or null if the process didn't complete */\n    public static File openFile(String title, String extension)\n    {\n        File file = null;\n        \n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        chooser.setFileFilter(new VueFileFilter());\n        \n        if (VueUtil.isCurrentDirectoryPathSet()) \n            chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Open\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            String fileName = chooser.getSelectedFile().getAbsolutePath();\n            \n            //if it isn't a file name with the right extention \n            if (!fileName.endsWith(\".\" + extension))\n              fileName += \".\" + extension;\n            \n            //if the file with the given name exists\n            if ((file = new File(fileName)).exists())\n            {\n                VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getParent());\n            }\n            \n            else\n            {\n                //what to do here?\n                System.err.println(\"the file doesn't exist\");\n                file = null;\n            }\n        }\n        \n        return file;\n    }","id":32117,"modified_method":"/**A static method which displays a file chooser for the user to choose which file to open.\n       It returns the selected file or null if the process didn't complete */\n    public static File openFile(String title, String extension)\n    {\n        File file = null;\n        \n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        chooser.setFileFilter(new VueFileFilter(extension));\n        \n        if (VueUtil.isCurrentDirectoryPathSet()) \n            chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Open\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            String fileName = chooser.getSelectedFile().getAbsolutePath();\n            \n            //if it isn't a file name with the right extention \n            if (!fileName.endsWith(\".\" + extension))\n              fileName += \".\" + extension;\n            \n            //if the file with the given name exists\n            if ((file = new File(fileName)).exists())\n            {\n                VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getParent());\n            }\n            \n            else\n            {\n                //what to do here?\n                System.err.println(\"the file doesn't exist\");\n                file = null;\n            }\n        }\n        \n        return file;\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, String extension)\n    {\n        File file = null;\n        \n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        //chooser.setFileFilter(new VueFileFilter());\n            \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Save\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            boolean proceed = true;\n            \n            if (chooser.getSelectedFile().exists())\n              {\n                int n = JOptionPane.showConfirmDialog(null, \"Would you Like to Replace the File\", \n                        \"Replacing File\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                  proceed = false;\n                \n              } \n        \n            if (proceed == true)\n              {\n                String fileName = chooser.getSelectedFile().getAbsolutePath();\n                  \n                //if it isn't a file name with the right extention \n                if (!fileName.endsWith(\".\" + extension))\n                fileName += \".\" + extension;\n                \n                file = new File(fileName); \n                  \n                // if they choose nothing, fileName will be null -- detect & abort\n                VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getParent());\n              }\n        }\n        \n        return file;\n    }","id":32118,"modified_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, String fileType)\n    {\n        File file = null;\n        \n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        \n        chooser.setAcceptAllFileFilterUsed(false);\n        \n        if (fileType != null)\n         chooser.setFileFilter(new VueFileFilter(fileType)); \n        \n        else\n        {\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"xml\"));  \n            chooser.setFileFilter(new VueFileFilter(\"xml\")); \n            chooser.addChoosableFileFilter(new VueFileFilter(\"jpeg\"));  \n            chooser.addChoosableFileFilter(new VueFileFilter(\"svg\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"pdf\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"html\"));\n        }\n            \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Save\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            boolean proceed = true;\n            \n            if (chooser.getSelectedFile().exists())\n              {\n                int n = JOptionPane.showConfirmDialog(null, \"Would you Like to Replace the File\", \n                        \"Replacing File\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                  proceed = false;\n                \n              } \n        \n            if (proceed == true)\n              {\n                String fileName = chooser.getSelectedFile().getAbsolutePath();\n                  \n                String extension = chooser.getFileFilter().getDescription();\n                \n                //if it isn't a file name with the right extention \n                if (!fileName.endsWith(\".\" + extension))\n                fileName += \".\" + extension;\n                \n                file = new File(fileName); \n                  \n                // if they choose nothing, fileName will be null -- detect & abort\n                VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getParent());\n              }\n        }\n        \n        return file;\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"public void convert(File result){\n        System.out.println(\"in convert..................\");\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        \n        try\n        {\n            InputStream xslInput = new FileInputStream( xslFileName );\n            StreamSource xslSource = new StreamSource( xslInput );\n                \n            StreamSource xmlSource = new StreamSource( xmlFileName );\n            \n            Templates templates = tfactory.newTemplates( xslSource );\n        \n            \n            \n            StreamResult out = new StreamResult(result);\n            \n            Transformer transformer = templates.newTransformer();\n    \n            transformer.transform( xmlSource, out );\n        }\n        catch ( IOException ex )\n        {\n            System.out.println(ex.getMessage());\n        }\n        catch ( TransformerException ex )\n        {\n            System.out.println( ex.getMessage() );\n        }\n        \n        System.out.println(\"finished converting xml to html.\");\n    }","id":32119,"modified_method":"public void convert(File result){\n        System.out.println(\"in convert..................\");\n        \n        ActionUtil.marshallMap(new File(xmlFileName));\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        \n        try\n        {\n            InputStream xslInput = new FileInputStream( xslFileName );\n            StreamSource xslSource = new StreamSource( xslInput );\n                \n            StreamSource xmlSource = new StreamSource( xmlFileName );\n            \n            Templates templates = tfactory.newTemplates( xslSource );\n        \n            \n            \n            StreamResult out = new StreamResult(result);\n            \n            Transformer transformer = templates.newTransformer();\n    \n            transformer.transform( xmlSource, out );\n        }\n        catch ( IOException ex )\n        {\n            System.out.println(ex.getMessage());\n        }\n        catch ( TransformerException ex )\n        {\n            System.out.println( ex.getMessage() );\n        }\n        \n        System.out.println(\"finished converting xml to html.\");\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent ae) {\n        System.out.println(\"Performing HTML Conversion:\" + ae.getActionCommand());\n        \n        ActionUtil.marshallMap(new File(xmlFileName));\n        \n        File result = ActionUtil.selectFile(\"Save As HTML\", \"html\");\n        if(!result.equals(null)) convert(result);\n    }","id":32120,"modified_method":"public void actionPerformed(ActionEvent ae) {\n        System.out.println(\"Performing HTML Conversion:\" + ae.getActionCommand());\n        \n        //ActionUtil.marshallMap(new File(xmlFileName));\n        \n        File result = ActionUtil.selectFile(\"Save As HTML\", \"html\");\n        if(!result.equals(null)) convert(result);\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"/**A method defined in the interface */\n    public void actionPerformed(java.awt.event.ActionEvent actionEvent) {\n        \n        try \n        {\n           File selectedFile = ActionUtil.selectFile(\"Saving JPEG\", \"jpeg\");\n           \n           if (selectedFile != null)\n             {\n                //retrives the current map and gets its size\n                MapViewer currentMap = VUE.getActiveViewer();\n                \n                Rectangle2D bounds = currentMap.getAllComponentBounds();\n                int xLocation = (int)bounds.getX() + 5, yLocation = (int)bounds.getY() + 5;\n                Dimension size = new Dimension((int)bounds.getWidth() + xLocation, (int)bounds.getHeight() + yLocation);\n        \n                //creates an image object and sets up the graphics object of the image\n                BufferedImage mapImage = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);\n                Graphics g = mapImage.getGraphics();\n                \n                g.setClip(0, 0, size.width, size.height);\n        \n                //let the map draws to the image object's graphic object\n                currentMap.paintComponent(g);\n                \n                //outlining the returned image\n                //g.setColor(Color.black);\n                //g.drawRect(0, 0, size.width - 1, size.height - 1);\n        \n                //begins the conversion to the file\n                convert(mapImage, selectedFile, \"jpeg\");\n            }\n       }\n        \n       catch(Exception ex) \n       {\n            System.out.println(\"Couldn't convert to JPEG:\" + ex);\n       }   \n    }","id":32121,"modified_method":"/**A method defined in the interface */\n    public void actionPerformed(java.awt.event.ActionEvent actionEvent) {\n        \n       try \n       {\n           File selectedFile = ActionUtil.selectFile(\"Saving JPEG\", \"jpeg\");\n           \n           if (selectedFile != null)\n             createJpeg(selectedFile);\n       }\n        \n       catch(Exception ex) \n       {\n            System.out.println(\"Couldn't convert to JPEG:\" + ex);\n       }   \n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e)\n    {\n        /*\n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(\"Open Map\");\n        chooser.setFileFilter(new VueFileFilter());\n        if (VueUtil.isCurrentDirectoryPathSet()) \n            chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Open\");\n        String fileName = \"test.xml\";\n        if (option == JFileChooser.APPROVE_OPTION) {\n            fileName = chooser.getSelectedFile().getAbsolutePath();\n            VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getP //if it isn't a file name with the right extention \n                if (!fileName.endsWith(\".\" + extension))\n                fileName += \".\" + extension;arent());\n         */\n           \n        File file = ActionUtil.openFile(\"Open Map\", \"xml\");\n        \n        if (file != null)\n        {\n         \n            VUE.activateWaitCursor();\n            try \n            {\n                //LWMap loadedMap = loadMap(fileName);\n                LWMap loadedMap = loadMap(file.getAbsolutePath());\n                VUE.displayMap(loadedMap);\n            } \n            finally \n            {\n                VUE.clearWaitCursor();\n            }\n        }\n        \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","id":32122,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        /*\n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(\"Open Map\");\n        chooser.setFileFilter(new VueFileFilter());\n        if (VueUtil.isCurrentDirectoryPathSet()) \n            chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Open\");\n        String fileName = \"test.xml\";\n        if (option == JFileChooser.APPROVE_OPTION) {\n            fileName = chooser.getSelectedFile().getAbsolutePath();\n            VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getP //if it isn't a file name with the right extention \n                if (!fileName.endsWith(\".\" + extension))\n                fileName += \".\" + extension;arent());\n         */\n           \n        File file = ActionUtil.openFile(\"Open Map\", \"xml\");\n        \n        if (file != null && file.getName().endsWith(\".xml\"))\n        {\n         \n            VUE.activateWaitCursor();\n            try \n            {\n                //LWMap loadedMap = loadMap(fileName);\n                LWMap loadedMap = loadMap(file.getAbsolutePath());\n                VUE.displayMap(loadedMap);\n            } \n            finally \n            {\n                VUE.clearWaitCursor();\n            }\n        }\n        \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"public void convert(File pdfFile){\n        \n        //create new instance of transformer factory\n        TransformerFactory factory =\n            TransformerFactory.newInstance();\n        \n        //create File objects from file names\n        File xslFile = new File(xslFileName);\n        File xmlFile = new File(xmlFileName);\n        File foFile = new File(foFileName);\n        \n        \n        //create a transformer to hold the converted xml object\n        Transformer trans = null;\n        try{\n            trans = \n            factory.newTransformer(new StreamSource(xslFile));\n        }catch(TransformerConfigurationException tce){\n            System.out.println(\"problem creating new transformer: \" + tce);\n        }\n        \n        //create an output stream to the default.fo file\n        FileOutputStream foOut = null; \n        try{\n            foOut = new FileOutputStream(foFile);\n        }catch(FileNotFoundException fnfe){\n            System.out.println(\"can't find fo file: \" + fnfe);\n        }\n        \n        //transform xml file to fo file to prep for pdf conversion\n        try{\n            trans.transform(new StreamSource(xmlFile),\n            new StreamResult(foOut));\n        }catch(TransformerException te){\n            System.out.println(\"problem performing traslation: \" + te);\n        }\n        \n        //closing file output stream to default.fo file (no sharing violation)\n        try{\n            foOut.close();\n        }catch(IOException ioe){\n            System.out.println(\"io problems closing fo file: \" + ioe);\n        }\n        \n        //get fop version used below as param for renderer\n        String version = org.apache.fop.apps.Version.getVersion();\n        \n        \n        //set system prop driver to the sax parser\n        System.setProperty(\"org.xml.sax.driver\", \n            \"org.apache.xerces.parsers.SAXParser\");\n        \n        //create an xml reader\n        try{\n            XMLReaderFactory.createXMLReader(); \n        }catch(SAXException se){\n            System.out.println(\"problems creating XML reader: \" + se);\n        }\n        \n        //create output stream for pdf file\n        FileOutputStream pdfOut =null;\n        try{\n            pdfOut = new FileOutputStream(pdfFile);\n        }catch(FileNotFoundException fnfe){\n            System.out.println(\"can't find pdf file: \" + fnfe);\n        }\n        \n        //initalize new driver for rendering with param (fo file source, pdf file)\n        org.apache.fop.apps.Driver driver = \n            new org.apache.fop.apps.Driver(\n                new org.xml.sax.InputSource(\n                foFileName), pdfOut);\n        \n        driver.setRenderer(1);\n        \n        //running driver to render fo file to pdf format\n        try{\n            driver.run();\n        }catch(IOException ioe){\n            System.out.println(\"io problems running the driver: \" + ioe);\n        }catch(Exception fe){\n            System.out.println(\"fop problems running the driver: \" + fe);\n        }\n        \n        //closing file output stream to selected pdf file (no sharing violation)\n        try{\n            pdfOut.close();\n        }catch(IOException ioe){\n            System.out.println(\"io problems closing pdf file: \" + ioe);\n        }\n    }","id":32123,"modified_method":"public void convert(File pdfFile){\n        \n        ActionUtil.marshallMap(new File(xmlFileName));\n        //create new instance of transformer factory\n        TransformerFactory factory =\n            TransformerFactory.newInstance();\n        \n        //create File objects from file names\n        File xslFile = new File(xslFileName);\n        File xmlFile = new File(xmlFileName);\n        File foFile = new File(foFileName);\n        \n        \n        //create a transformer to hold the converted xml object\n        Transformer trans = null;\n        try{\n            trans = \n            factory.newTransformer(new StreamSource(xslFile));\n        }catch(TransformerConfigurationException tce){\n            System.out.println(\"problem creating new transformer: \" + tce);\n        }\n        \n        //create an output stream to the default.fo file\n        FileOutputStream foOut = null; \n        try{\n            foOut = new FileOutputStream(foFile);\n        }catch(FileNotFoundException fnfe){\n            System.out.println(\"can't find fo file: \" + fnfe);\n        }\n        \n        //transform xml file to fo file to prep for pdf conversion\n        try{\n            trans.transform(new StreamSource(xmlFile),\n            new StreamResult(foOut));\n        }catch(TransformerException te){\n            System.out.println(\"problem performing traslation: \" + te);\n        }\n        \n        //closing file output stream to default.fo file (no sharing violation)\n        try{\n            foOut.close();\n        }catch(IOException ioe){\n            System.out.println(\"io problems closing fo file: \" + ioe);\n        }\n        \n        //get fop version used below as param for renderer\n        String version = org.apache.fop.apps.Version.getVersion();\n        \n        \n        //set system prop driver to the sax parser\n        System.setProperty(\"org.xml.sax.driver\", \n            \"org.apache.xerces.parsers.SAXParser\");\n        \n        //create an xml reader\n        try{\n            XMLReaderFactory.createXMLReader(); \n        }catch(SAXException se){\n            System.out.println(\"problems creating XML reader: \" + se);\n        }\n        \n        //create output stream for pdf file\n        FileOutputStream pdfOut =null;\n        try{\n            pdfOut = new FileOutputStream(pdfFile);\n        }catch(FileNotFoundException fnfe){\n            System.out.println(\"can't find pdf file: \" + fnfe);\n        }\n        \n        //initalize new driver for rendering with param (fo file source, pdf file)\n        org.apache.fop.apps.Driver driver = \n            new org.apache.fop.apps.Driver(\n                new org.xml.sax.InputSource(\n                foFileName), pdfOut);\n        \n        driver.setRenderer(1);\n        \n        //running driver to render fo file to pdf format\n        try{\n            driver.run();\n        }catch(IOException ioe){\n            System.out.println(\"io problems running the driver: \" + ioe);\n        }catch(Exception fe){\n            System.out.println(\"fop problems running the driver: \" + fe);\n        }\n        \n        //closing file output stream to selected pdf file (no sharing violation)\n        try{\n            pdfOut.close();\n        }catch(IOException ioe){\n            System.out.println(\"io problems closing pdf file: \" + ioe);\n        }\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(java.awt.event.ActionEvent actionEvent) {\n        System.out.println(\"Performing PDF Conversion:\" + actionEvent.getActionCommand());\n        \n        ActionUtil.marshallMap(new File(xmlFileName));\n        \n        File pdfFile = ActionUtil.selectFile(\"Save As PDF\", \"pdf\");\n        if(!pdfFile.equals(null)) convert(pdfFile);\n    }","id":32124,"modified_method":"public void actionPerformed(java.awt.event.ActionEvent actionEvent) {\n        System.out.println(\"Performing PDF Conversion:\" + actionEvent.getActionCommand());\n        \n        //ActionUtil.marshallMap(new File(xmlFileName));\n        \n        File pdfFile = ActionUtil.selectFile(\"Save As PDF\", \"pdf\");\n        if(!pdfFile.equals(null)) convert(pdfFile);\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e)\n    {\n        System.out.println(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n         \n        boolean saveCondition = true;\n        \n        if (isSaveAs() || file == null)\n        {\n          file = (ActionUtil.selectFile(\"Save Map\", \"xml\"));\n          \n          if (file == null)\n              saveCondition = false;\n        }\n        \n        if (saveCondition == true)\n        {\n          ActionUtil.marshallMap(file);\n          System.out.println(\"Saved \" + getFileName());\n        }\n            \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","id":32125,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        System.out.println(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n         \n        boolean saveCondition = true;\n        \n        if (isSaveAs() || file == null)\n        {\n          file = ActionUtil.selectFile(\"Save Map\", null);\n          \n          if (file == null)\n              saveCondition = false;\n        }\n        \n        if (saveCondition == true)\n        {\n          if (file.getName().endsWith(\".xml\"))\n            ActionUtil.marshallMap(file);\n          \n          else if (file.getName().endsWith(\".jpeg\"))\n            new ImageConversion().createJpeg(file);\n          \n          else if (file.getName().endsWith(\".svg\"))\n            new SVGConversion().createSVG(file);\n          \n          else if (file.getName().endsWith(\".pdf\"))\n            new PDFTransform().convert(file);\n          \n          else if (file.getName().endsWith(\".html\"))\n            new HTMLConversion().convert(file);\n          \n          System.out.println(\"Saved \" + getFileName());\n        }\n            \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"private static void  setMenuToolbars(JFrame frame, Action[] windowActions)\n    {\n        final int metaMask = VueUtil.isMacPlatform() ? Event.META_MASK : Event.CTRL_MASK;\n        \n        JMenuBar menuBar = new JMenuBar();\n        JMenu fileMenu = new JMenu(\"File\");\n        JMenu editMenu = new JMenu(\"Edit\");\n        JMenu viewMenu = new JMenu(\"View\");\n        JMenu formatMenu = new JMenu(\"Format\");\n        JMenu arrangeMenu = new JMenu(\"Arrange\");\n        //JMenu alignMenu = new JMenu(\"Align\");\n        JMenu windowMenu = new JMenu(\"Window\");\n        JMenu optionsMenu = new JMenu(\"Options\");\n        JMenu helpMenu = new JMenu(\"Help\");\n        \n        menuBar.add(fileMenu);\n        menuBar.add(editMenu);\n        menuBar.add(viewMenu);\n        menuBar.add(formatMenu);\n        menuBar.add(arrangeMenu);\n        menuBar.add(windowMenu);\n        menuBar.add(optionsMenu);\n        menuBar.add(helpMenu);\n        //adding actions\n        SaveAction saveAction = new SaveAction(\"Save\", false);\n        SaveAction saveAsAction = new SaveAction(\"Save As...\");\n        OpenAction openAction = new OpenAction(\"Open\");\n        ExitAction exitAction = new ExitAction(\"Quit\");\n        fileMenu.add(Actions.NewMap);\n        fileMenu.add(openAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, metaMask));\n        fileMenu.add(saveAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask));\n        fileMenu.add(saveAsAction);\n        fileMenu.add(Actions.CloseMap);\n        //fileMenu.add(htmlAction);\n        fileMenu.add(new JMenuItem(\"Export ...\"));\n        fileMenu.addSeparator();\n        fileMenu.add(exitAction);\n        \n        editMenu.add(Actions.Undo);\n        editMenu.add(Actions.Redo);\n        editMenu.addSeparator();\n        editMenu.add(Actions.NewNode);\n        editMenu.add(Actions.NewText);\n        editMenu.add(Actions.Rename);\n        editMenu.add(Actions.Duplicate);\n        editMenu.addSeparator();\n        editMenu.add(Actions.Cut);\n        editMenu.add(Actions.Copy);\n        editMenu.add(Actions.Paste);\n        editMenu.addSeparator();\n        editMenu.add(Actions.SelectAll);\n        editMenu.add(Actions.DeselectAll);\n        \n        viewMenu.add(Actions.ZoomIn);\n        viewMenu.add(Actions.ZoomOut);\n        viewMenu.add(Actions.ZoomFit);\n        viewMenu.add(Actions.ZoomActual);\n        viewMenu.addSeparator();\n        viewMenu.add(new JMenuItem(\"Resources\"));\n        viewMenu.add(new JMenuItem(\"Collection\"));\n        viewMenu.add(new JMenuItem(\"Inspector\"));\n        viewMenu.add(new JMenuItem(\"Pathway\"));\n        viewMenu.add(new JMenuItem(\"Toolbar\"));\n        viewMenu.add(new JMenuItem(\"Overview\"));\n        \n        JMenu fontMenu = new JMenu(\"Font\");\n\n        /*\n        // this list bigger than screen & menu isn't scrolling for us!\n        String[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        System.out.println(java.util.Arrays.asList(fonts));\n        for (int i = 0; i < fonts.length; i++) {\n            JMenuItem fm = new JMenuItem(fonts[i]);\n            fontMenu.add(fm);\n        }\n        */\n                           \n        //formatMenu.add(fontMenu);\n        formatMenu.add(Actions.FontSmaller);\n        formatMenu.add(Actions.FontBigger);\n        formatMenu.add(Actions.FontBold);\n        formatMenu.add(Actions.FontItalic);\n        //formatMenu.add(new JMenuItem(\"Size\"));\n        //formatMenu.add(new JMenuItem(\"Style\"));\n        formatMenu.add(\"Text Justify\").setEnabled(false);\n\n\n        for (int i = 0; i < Actions.ALIGN_MENU_ACTIONS.length; i++) {\n            Action a = Actions.ALIGN_MENU_ACTIONS[i];\n            if (a == null)\n                alignMenu.addSeparator();\n            else\n                alignMenu.add(a);\n        }\n        /*\n        alignMenu.add(Actions.AlignLeftEdges);\n        alignMenu.add(Actions.AlignRightEdges);\n        alignMenu.add(Actions.AlignTopEdges);\n        alignMenu.add(Actions.AlignBottomEdges);\n        alignMenu.addSeparator();\n        alignMenu.add(Actions.AlignCentersRow);\n        alignMenu.add(Actions.AlignCentersColumn);\n        alignMenu.addSeparator();\n        alignMenu.add(Actions.DistributeVertically);\n        alignMenu.add(Actions.DistributeHorizontally);\n        */\n        \n        arrangeMenu.add(Actions.BringToFront);\n        arrangeMenu.add(Actions.BringForward);\n        arrangeMenu.add(Actions.SendToBack);\n        arrangeMenu.add(Actions.SendBackward);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(Actions.Group);\n        arrangeMenu.add(Actions.Ungroup);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(alignMenu);\n        \n        for (int i = 0; i < windowActions.length; i++) {\n            System.out.println(\"adding \" + windowActions[i]);\n            windowMenu.add(new JCheckBoxMenuItem(windowActions[i]));\n        }\n\n        optionsMenu.add(new JMenuItem(\"Node Types...\"));\n        optionsMenu.add(new JMenuItem(\"Map Preference...\"));\n        optionsMenu.add(new JMenuItem(\"Preferences...\"));\n        \n        helpMenu.add(new JMenuItem(\"Help\"));\n        \n\n        //extra additions by the power team members\n        PDFTransform pdfAction = new PDFTransform(\"PDF\");\n        HTMLConversion htmlAction = new HTMLConversion(\"HTML\");\n        XMLView xmlAction = new XMLView(\"XML\");\n        ImageConversion imageAction = new ImageConversion(\"JPEG\");\n        ImageMap imageMap = new ImageMap(\"IMAP\");\n        SVGConversion svgAction = new SVGConversion(\"SVG\");\n        PrintAction printAction = new PrintAction(\"Print\");\n        \n        JToolBar toolBar = new JToolBar();\n        toolBar.add(Actions.NewMap);\n        toolBar.add(openAction);\n        toolBar.add(Actions.CloseMap);\n        toolBar.add(saveAction);\n        toolBar.add(saveAsAction);\n        toolBar.add(printAction);\n        toolBar.add(imageAction);\n        toolBar.add(htmlAction);\n        toolBar.add(xmlAction);\n        toolBar.add(pdfAction);\n        toolBar.add(imageMap);\n        toolBar.add(svgAction);\n       // toolBar.add(new JButton(new ImageIcon(\"tufts/vue/images/ZoomOut16.gif\")));\n        toolBar.add(new JButton(new PolygonIcon(Color.RED)));\n        frame.setJMenuBar(menuBar);\n        //frame.getContentPane().add(toolBar,BorderLayout.NORTH);\n        frame.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {System.exit(0);}});\n\n    }","id":32126,"modified_method":"private static void  setMenuToolbars(JFrame frame, Action[] windowActions)\n    {\n        final int metaMask = VueUtil.isMacPlatform() ? Event.META_MASK : Event.CTRL_MASK;\n        \n        JMenuBar menuBar = new JMenuBar();\n        JMenu fileMenu = new JMenu(\"File\");\n        JMenu editMenu = new JMenu(\"Edit\");\n        JMenu viewMenu = new JMenu(\"View\");\n        JMenu formatMenu = new JMenu(\"Format\");\n        JMenu arrangeMenu = new JMenu(\"Arrange\");\n        //JMenu alignMenu = new JMenu(\"Align\");\n        JMenu windowMenu = new JMenu(\"Window\");\n        JMenu optionsMenu = new JMenu(\"Options\");\n        JMenu helpMenu = new JMenu(\"Help\");\n        \n        menuBar.add(fileMenu);\n        menuBar.add(editMenu);\n        menuBar.add(viewMenu);\n        menuBar.add(formatMenu);\n        menuBar.add(arrangeMenu);\n        menuBar.add(windowMenu);\n        menuBar.add(optionsMenu);\n        menuBar.add(helpMenu);\n        //adding actions\n        SaveAction saveAction = new SaveAction(\"Save\", false);\n        SaveAction saveAsAction = new SaveAction(\"Save As...\");\n        OpenAction openAction = new OpenAction(\"Open\");\n        ExitAction exitAction = new ExitAction(\"Quit\");\n        \n        /**Actions added by the power team*/\n        PrintAction printAction = new PrintAction(\"Print\");\n        XMLView xmlAction = new XMLView(\"XML View\");\n        /**End of addition*/\n        \n        fileMenu.add(Actions.NewMap);\n        fileMenu.add(openAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, metaMask));\n        fileMenu.add(saveAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask));\n        fileMenu.add(saveAsAction);\n        fileMenu.add(Actions.CloseMap);\n        //fileMenu.add(htmlAction);\n        fileMenu.add(new JMenuItem(\"Export ...\"));\n        fileMenu.add(printAction);\n        fileMenu.add(xmlAction);\n        fileMenu.addSeparator();\n        fileMenu.add(exitAction);\n        \n        editMenu.add(Actions.Undo);\n        editMenu.add(Actions.Redo);\n        editMenu.addSeparator();\n        editMenu.add(Actions.NewNode);\n        editMenu.add(Actions.NewText);\n        editMenu.add(Actions.Rename);\n        editMenu.add(Actions.Duplicate);\n        editMenu.addSeparator();\n        editMenu.add(Actions.Cut);\n        editMenu.add(Actions.Copy);\n        editMenu.add(Actions.Paste);\n        editMenu.addSeparator();\n        editMenu.add(Actions.SelectAll);\n        editMenu.add(Actions.DeselectAll);\n        \n        viewMenu.add(Actions.ZoomIn);\n        viewMenu.add(Actions.ZoomOut);\n        viewMenu.add(Actions.ZoomFit);\n        viewMenu.add(Actions.ZoomActual);\n        viewMenu.addSeparator();\n        viewMenu.add(new JMenuItem(\"Resources\"));\n        viewMenu.add(new JMenuItem(\"Collection\"));\n        viewMenu.add(new JMenuItem(\"Inspector\"));\n        viewMenu.add(new JMenuItem(\"Pathway\"));\n        viewMenu.add(new JMenuItem(\"Toolbar\"));\n        viewMenu.add(new JMenuItem(\"Overview\"));\n        \n        JMenu fontMenu = new JMenu(\"Font\");\n\n        /*\n        // this list bigger than screen & menu isn't scrolling for us!\n        String[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        System.out.println(java.util.Arrays.asList(fonts));\n        for (int i = 0; i < fonts.length; i++) {\n            JMenuItem fm = new JMenuItem(fonts[i]);\n            fontMenu.add(fm);\n        }\n        */\n                           \n        //formatMenu.add(fontMenu);\n        formatMenu.add(Actions.FontSmaller);\n        formatMenu.add(Actions.FontBigger);\n        formatMenu.add(Actions.FontBold);\n        formatMenu.add(Actions.FontItalic);\n        //formatMenu.add(new JMenuItem(\"Size\"));\n        //formatMenu.add(new JMenuItem(\"Style\"));\n        formatMenu.add(\"Text Justify\").setEnabled(false);\n\n\n        for (int i = 0; i < Actions.ALIGN_MENU_ACTIONS.length; i++) {\n            Action a = Actions.ALIGN_MENU_ACTIONS[i];\n            if (a == null)\n                alignMenu.addSeparator();\n            else\n                alignMenu.add(a);\n        }\n        /*\n        alignMenu.add(Actions.AlignLeftEdges);\n        alignMenu.add(Actions.AlignRightEdges);\n        alignMenu.add(Actions.AlignTopEdges);\n        alignMenu.add(Actions.AlignBottomEdges);\n        alignMenu.addSeparator();\n        alignMenu.add(Actions.AlignCentersRow);\n        alignMenu.add(Actions.AlignCentersColumn);\n        alignMenu.addSeparator();\n        alignMenu.add(Actions.DistributeVertically);\n        alignMenu.add(Actions.DistributeHorizontally);\n        */\n        \n        arrangeMenu.add(Actions.BringToFront);\n        arrangeMenu.add(Actions.BringForward);\n        arrangeMenu.add(Actions.SendToBack);\n        arrangeMenu.add(Actions.SendBackward);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(Actions.Group);\n        arrangeMenu.add(Actions.Ungroup);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(alignMenu);\n        \n        for (int i = 0; i < windowActions.length; i++) {\n            System.out.println(\"adding \" + windowActions[i]);\n            windowMenu.add(new JCheckBoxMenuItem(windowActions[i]));\n        }\n\n        optionsMenu.add(new JMenuItem(\"Node Types...\"));\n        optionsMenu.add(new JMenuItem(\"Map Preference...\"));\n        optionsMenu.add(new JMenuItem(\"Preferences...\"));\n        \n        helpMenu.add(new JMenuItem(\"Help\"));\n        \n\n        //extra additions by the power team members\n        PDFTransform pdfAction = new PDFTransform(\"PDF\");\n        HTMLConversion htmlAction = new HTMLConversion(\"HTML\");\n        ImageConversion imageAction = new ImageConversion(\"JPEG\");\n        ImageMap imageMap = new ImageMap(\"IMAP\");\n        SVGConversion svgAction = new SVGConversion(\"SVG\");\n        \n        JToolBar toolBar = new JToolBar();\n        toolBar.add(Actions.NewMap);\n        toolBar.add(openAction);\n        toolBar.add(Actions.CloseMap);\n        toolBar.add(saveAction);\n        toolBar.add(saveAsAction);\n        toolBar.add(printAction);\n        toolBar.add(imageAction);\n        toolBar.add(htmlAction);\n        toolBar.add(xmlAction);\n        toolBar.add(pdfAction);\n        toolBar.add(imageMap);\n        toolBar.add(svgAction);\n       // toolBar.add(new JButton(new ImageIcon(\"tufts/vue/images/ZoomOut16.gif\")));\n        toolBar.add(new JButton(new PolygonIcon(Color.RED)));\n        frame.setJMenuBar(menuBar);\n        //frame.getContentPane().add(toolBar,BorderLayout.NORTH);\n        frame.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {System.exit(0);}});\n\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"public String getDescription()\n    {\n        return \"VUE Files\";\n    }","id":32127,"modified_method":"public String getDescription()\n    {\n        //return \"VUE Files\";\n        return description;\n    }","commit_id":"d251a2fb906dccaa215de13bc77ef47d8a10a6d5","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * @return true if success, false if not\n     */\n      \n    public static boolean saveMap(LWMap map, boolean saveAs)\n    {\n        System.out.println(\"SaveAction.saveMap: \" + map);\n        \n        if (map == null)\n            return false;\n        \n        File file = map.getFile();\n        \n        if (saveAs || file == null)\n            //file = ActionUtil.selectFile(\"Save Map\", \"vue\");\n            file = ActionUtil.selectFile(\"Save Map\", null);\n        \n        if (file == null)\n            return false;\n        \n        try {\n            VUE.activateWaitCursor();\n            String name = file.getName().toLowerCase();\n\n            if (name.endsWith(\".rli.xml\")) {\n\t\t\t\tnew IMSResourceList().convert(map,file);\n\t\t\t}\n            \n\t\t\telse if (name.endsWith(\".xml\") || name.endsWith(\".vue\"))\n                ActionUtil.marshallMap(file, map);\n            \n            else if (name.endsWith(\".jpeg\") || name.endsWith(\".jpg\"))\n                ImageConversion.createActiveMapJpeg(file);\n            \n            else if (name.endsWith(\".svg\"))\n                new SVGConversion().createSVG(file);\n            \n            else if (name.endsWith(\".pdf\"))\n                new PDFTransform().convert(file);\n            \n            //else if (name.endsWith(\".html\"))\n              //  new HTMLConversion().convert(file);\n            \n            //else if (name.endsWith(\".imap\"))\n            else if (name.endsWith(\".html\"))\n                new ImageMap().createImageMap(file);\n            \n\n\t\t\t// don't know this as not all the above stuff is passing\n            // exceptions on to us!\n            System.out.println(\"Save code completed for \" + file);\n            VueFrame frame = (VueFrame)VUE.getMainWindow();\n            String title = VUE.getName() + \": \" + name;                      \n            frame.setTitle(title);\n            \n            if (name.endsWith(\".vue\"))\n            {\n             RecentlyOpenedFilesManager rofm = RecentlyOpenedFilesManager.getInstance();\n             rofm.updateRecentlyOpenedFiles(file.getAbsolutePath());\n            }\n            return true;\n\n        } catch (Throwable t) {\n            VUE.Log.error(\"Exception attempting to save file \" + file + \": \" + t);\n            Throwable e = t;\n            if (t.getCause() != null)\n                e = t.getCause();\n            if (e instanceof java.io.FileNotFoundException) {\n                VueUtil.alert(e.getMessage(), \"Save Failed\");\n            } else {\n                e.printStackTrace();\n                VueUtil.alert(\"Save failed for \\\"\" + file + \"\\\"\", e);\n            }\n            if (e != t)\n                VUE.Log.error(\"Exception attempting to save file \" + file + \": \" + e);\n        } finally {\n            VUE.clearWaitCursor();\n        }\n\n        return false;\n    }","id":32128,"modified_method":"/**\n     * @return true if success, false if not\n     */\n      \n    public static boolean saveMap(LWMap map, boolean saveAs)\n    {\n        System.out.println(\"SaveAction.saveMap: \" + map);\n        \n        if (map == null)\n            return false;\n        \n        File file = map.getFile();\n\n        if (map.getSaveFileModelVersion() == 0) {\n            VueUtil.alert(String.format(\"Saving %s in this version of VUE will prevent older versions of VUE\"\n                                        + \"\\nfrom displaying it properly.  You may wish to save this map under a new name.\",\n                                        map.getLabel()),\n                          \"Version Notice: \" + map.getLabel());\n            \n        }\n        \n        \n        if (saveAs || file == null)\n            //file = ActionUtil.selectFile(\"Save Map\", \"vue\");\n            file = ActionUtil.selectFile(\"Save Map\", null);\n        \n        if (file == null)\n            return false;\n        \n        try {\n            VUE.activateWaitCursor();\n            String name = file.getName().toLowerCase();\n\n            if (name.endsWith(\".rli.xml\")) {\n                new IMSResourceList().convert(map,file);\n            }\n            else if (name.endsWith(\".xml\") || name.endsWith(\".vue\")) {\n                ActionUtil.marshallMap(file, map);\n            }\n            else if (name.endsWith(\".jpeg\") || name.endsWith(\".jpg\"))\n                ImageConversion.createActiveMapJpeg(file);\n            \n            else if (name.endsWith(\".svg\"))\n                new SVGConversion().createSVG(file);\n            \n            else if (name.endsWith(\".pdf\"))\n                new PDFTransform().convert(file);\n            \n            //else if (name.endsWith(\".html\"))\n              //  new HTMLConversion().convert(file);\n            \n            //else if (name.endsWith(\".imap\"))\n            else if (name.endsWith(\".html\"))\n                new ImageMap().createImageMap(file);\n            \n\n\t\t\t// don't know this as not all the above stuff is passing\n            // exceptions on to us!\n            System.out.println(\"Save code completed for \" + file);\n            VueFrame frame = (VueFrame)VUE.getMainWindow();\n            String title = VUE.getName() + \": \" + name;                      \n            frame.setTitle(title);\n            \n            if (name.endsWith(\".vue\"))\n            {\n             RecentlyOpenedFilesManager rofm = RecentlyOpenedFilesManager.getInstance();\n             rofm.updateRecentlyOpenedFiles(file.getAbsolutePath());\n            }\n            return true;\n\n        } catch (Throwable t) {\n            VUE.Log.error(\"Exception attempting to save file \" + file + \": \" + t);\n            Throwable e = t;\n            if (t.getCause() != null)\n                e = t.getCause();\n            if (e instanceof java.io.FileNotFoundException) {\n                VueUtil.alert(e.getMessage(), \"Save Failed\");\n            } else {\n                e.printStackTrace();\n                VueUtil.alert(\"Save failed for \\\"\" + file + \"\\\"\", e);\n            }\n            if (e != t)\n                VUE.Log.error(\"Exception attempting to save file \" + file + \": \" + e);\n        } finally {\n            VUE.clearWaitCursor();\n        }\n\n        return false;\n    }","commit_id":"79010ce9c921dca3e1040d7c5b83a71168fd25d8","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e)\n    {\n        if (inSave) // otherwise rapid Ctrl-S's will trigger multiple dialog boxes\n            return;\n\n        try {\n            inSave = true;\n            System.out.println(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n            saveMap(tufts.vue.VUE.getActiveMap(), isSaveAs());\n            System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n        } finally {\n            inSave = false;\n        }\n    }","id":32129,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        if (inSave) // otherwise rapid Ctrl-S's will trigger multiple dialog boxes\n            return;\n\n        try {\n            inSave = true;\n            tufts.vue.VUE.Log.info(\"Action[\"+e.getActionCommand()+\"] invoked...\");\n            if (saveMap(tufts.vue.VUE.getActiveMap(), isSaveAs()))\n                tufts.vue.VUE.Log.info(\"Action[\"+e.getActionCommand()+\"] completed.\");\n            else\n                tufts.vue.VUE.Log.info(\"Action[\"+e.getActionCommand()+\"] aborted.\");\n        } finally {\n            inSave = false;\n        }\n    }","commit_id":"79010ce9c921dca3e1040d7c5b83a71168fd25d8","url":"https://github.com/VUE/VUE"},{"original_method":"/** uploadMapAll\n     * Iterate over map, storing local resources in repository, rewriting the \n     * references in the map so they point to the remote location.  Then store\n     * revised map in repository, leaving map in memory unchanged. (!?)\n     * \n     * Based on method of the same name in tufts.vue.FedoraPublisher.java.\n     *  \n     * @param dataSource DataSource object for Sakai LMS\n     * @param collectionId Workspace in Sakai to store map\n     * @param map VUE map to store in Sakai\n     */\n    public static void uploadMapAll(DataSource dataSource, Object collectionId, LWMap map)\n    throws CloneNotSupportedException, IOException, ServiceException\n    {        \n    \tProperties dsConfig = dataSource.getConfiguration();\n    \tString hostUrl = getHostUrl( dsConfig );\n    \tString sessionId = getSessionId( dsConfig );\n    \t\n    \tFile savedMapFile = saveMapToFile( map );\n       \tString resourceName = savedMapFile.getName();\n\n    \t// if there isn't a locally-saved map, then abort.\n    \tif( !savedMapFile.exists() ) {\n    \t\tthrow new IOException();\n    \t}\n\n    \t// create folder for map and resources\n    \tString folderName = createFolder( sessionId, hostUrl, collectionId.toString(), makeSakaiFolderFromVueMap( resourceName ) );\n \n    \t/* I had this clever idea: Why not work with a clone instead of the \n    \t * real map, then if there was a problem I could roll back my changes \n    \t * and leave the real map unmodified. Anoop claims this works for him\n    \t * (see FedoraPublisher.java) but I didn't have the same luck. pdw 19-nov-07 \n    \t */\n    \t//LWMap cloneMap = (LWMap)map.clone();\n    \t//cloneMap.setLabel(map.getLabel());\n    \tIterator<LWComponent> i = map.getAllDescendents(LWComponent.ChildKind.ANY).iterator();\n    \twhile(i.hasNext()) \n    \t{\n    \t\tLWComponent component = (LWComponent) i.next();\n    \t\tLog.debug(\"Component:\" + component +\" has resource:\" + component.hasResource());\n   \t\tif(component.hasResource()\n    \t\t\t\t&& (component instanceof LWNode || component instanceof LWLink) \n    \t\t\t\t&& (component.getResource() instanceof URLResource))\n    \t\t{\n    \t\t\tURLResource resource = (URLResource) component.getResource();\n    \t\t\tSystem.out.println(\"Component:\" + component \n    \t\t\t\t\t+ \"file:\" + resource.getSpec() \n    \t\t\t\t\t+ \" has file:\"+resource.getSpec().startsWith(FILE_PREFIX));\n    \t\t\tif(resource.isLocalFile()) {                    \n    \t\t\t\tFile file = new File(resource.getSpec().replace(FILE_PREFIX,\"\"));\n    \t\t\t\tSystem.out.println(\"LWComponent:\" + component.getLabel() \n    \t\t\t\t\t\t+ \" Resource: \"+resource.getSpec() \n    \t\t\t\t\t\t+ \" File:\" + file + \" exists:\" + file.exists() \n    \t\t\t\t\t\t+ \" MimeType\" + new MimetypesFileTypeMap().getContentType(file));\n    \t\t\t\t// Maps created on another computer could contain a reference to a local file\n    \t\t\t\t// that doesn't exist on this user's computer.  Don't process these.\n    \t\t\t\tif( !file.exists() ) {\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \t\t\t\tuploadObjectToRepository( \n    \t\t\t\t\t\tgetHostUrl( dsConfig ),\n    \t\t\t\t\t\tsessionId,\n    \t\t\t\t\t\tfile.getName(),\n    \t\t\t\t\t\tfolderName, \n    \t\t\t\t\t\tfile, \n    \t\t\t\t\t\tRESOURCE_DESC, true );\n\n    \t\t\t\t//Replace the link for resource in the map\n    \t\t\t\tString ingestUrl =  hostUrl + \"/access/content\" + folderName + file.getName();\n    \t\t\t\tSystem.out.println( ingestUrl );\n    \t\t\t\tresource.setSpec(ingestUrl);\n    \t\t\t\t//TODO The following call to setProperty() clears the \"File\" property.\n    \t\t\t\t// this is necessary because currently setSpec() doesn't reset the File \n    \t\t\t\t// property, leaving a resource with both an URL and File property.  It\n    \t\t\t\t// shouldn't have both. - pdw 28-nov-07\n    \t\t\t\tresource.removeProperty( \"File\" );\n    \t\t\t}\n    \t\t}\n    \t}\n    \t//upload the map \n    \t/* TODO NOTE: The map that is uploaded has changed from the map that \n    \t * was saved locally earlier this method.  The difference is that the\n    \t * resources that were local now point to Sakai.    \n    \t */\n    \t//File tmpFile = tufts.vue.action.ActionUtil.selectFile(\"Save Map\", \"vue\");\n    \t//File tmpFile = File.createTempFile(\"~vue-\", \".tmp\", VueUtil.getDefaultUserFolder());\n    \t//tmpFile.deleteOnExit();  \n//    \ttufts.vue.action.ActionUtil.marshallMap( tmpFile );\n    \ttufts.vue.action.ActionUtil.marshallMap( savedMapFile );\n    \tuploadObjectToRepository( \n    \t\t\thostUrl,\n    \t\t\tsessionId,\n    \t\t\tresourceName,\n    \t\t\tfolderName,\n    \t\t\tsavedMapFile,  //tmpFile, \n    \t\t\tmap.hasNotes() ? map.getNotes() : MAP_DESC, false );\n    }","id":32130,"modified_method":"/** uploadMapAll\n     * Iterate over map, storing local resources in repository, rewriting the \n     * references in the map so they point to the remote location.  Then store\n     * revised map in repository, leaving map in memory unchanged. (!?)\n     * \n     * Based on method of the same name in tufts.vue.FedoraPublisher.java.\n     *  \n     * @param dataSource DataSource object for Sakai LMS\n     * @param collectionId Workspace in Sakai to store map\n     * @param map VUE map to store in Sakai\n     */\n    public static void uploadMapAll(DataSource dataSource, Object collectionId, LWMap map)\n    throws CloneNotSupportedException, IOException, ServiceException\n    {        \n    \tProperties dsConfig = dataSource.getConfiguration();\n    \tString hostUrl = getHostUrl( dsConfig );\n    \tString sessionId = getSessionId( dsConfig );\n    \t\n    \tFile savedMapFile = saveMapToFile( map );\n       \tString resourceName = savedMapFile.getName();\n\n    \t// if there isn't a locally-saved map, then abort.\n    \tif( !savedMapFile.exists() ) {\n    \t\tthrow new IOException();\n    \t}\n\n    \t// create folder for map and resources\n    \tString folderName = createFolder( sessionId, hostUrl, collectionId.toString(), makeSakaiFolderFromVueMap( resourceName ) );\n \n    \t/* I had this clever idea: Why not work with a clone instead of the \n    \t * real map, then if there was a problem I could roll back my changes \n    \t * and leave the real map unmodified. Anoop claims this works for him\n    \t * (see FedoraPublisher.java) but I didn't have the same luck. pdw 19-nov-07 \n    \t */\n    \t//LWMap cloneMap = (LWMap)map.clone();\n    \t//cloneMap.setLabel(map.getLabel());\n        String mapLabel = map.getLabel();\n        File origFile = map.getFile();\n        \n        File tempFile  = new File(VueUtil.getDefaultUserFolder()+File.separator+origFile.getName());\n        tempFile.deleteOnExit();\n        tufts.vue.action.ActionUtil.marshallMap(tempFile,map);\n        \n        LWMap cloneMap =   tufts.vue.action.OpenAction.loadMap(tempFile.getAbsolutePath());\n        \n    \t//Iterator<LWComponent> i = map.getAllDescendents(LWComponent.ChildKind.ANY).iterator();\n        Iterator<LWComponent> i = cloneMap.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n        \n    \twhile(i.hasNext()) \n    \t{\n    \t\tLWComponent component = (LWComponent) i.next();\n    \t\tLog.debug(\"Component:\" + component +\" has resource:\" + component.hasResource());\n   \t\tif(component.hasResource()\n    \t\t\t\t&& (component instanceof LWNode || component instanceof LWLink) \n    \t\t\t\t&& (component.getResource() instanceof URLResource))\n    \t\t{\n    \t\t\tURLResource resource = (URLResource) component.getResource();\n    \t\t\tSystem.out.println(\"Component:\" + component \n    \t\t\t\t\t+ \"file:\" + resource.getSpec() \n    \t\t\t\t\t+ \" has file:\"+resource.getSpec().startsWith(FILE_PREFIX));\n    \t\t\tif(resource.isLocalFile()) {                    \n    \t\t\t\tFile file = new File(resource.getSpec().replace(FILE_PREFIX,\"\"));\n    \t\t\t\tSystem.out.println(\"LWComponent:\" + component.getLabel() \n    \t\t\t\t\t\t+ \" Resource: \"+resource.getSpec() \n    \t\t\t\t\t\t+ \" File:\" + file + \" exists:\" + file.exists() \n    \t\t\t\t\t\t+ \" MimeType\" + new MimetypesFileTypeMap().getContentType(file));\n    \t\t\t\t// Maps created on another computer could contain a reference to a local file\n    \t\t\t\t// that doesn't exist on this user's computer.  Don't process these.\n    \t\t\t\tif( !file.exists() ) {\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \t\t\t\tuploadObjectToRepository( \n    \t\t\t\t\t\tgetHostUrl( dsConfig ),\n    \t\t\t\t\t\tsessionId,\n    \t\t\t\t\t\tfile.getName(),\n    \t\t\t\t\t\tfolderName, \n    \t\t\t\t\t\tfile, \n    \t\t\t\t\t\tRESOURCE_DESC, true );\n\n    \t\t\t\t//Replace the link for resource in the map\n    \t\t\t\tString ingestUrl =  hostUrl + \"/access/content\" + folderName + file.getName();\n    \t\t\t\tSystem.out.println( ingestUrl );\n    \t\t\t\tresource.setSpec(ingestUrl);\n    \t\t\t\t//TODO The following call to setProperty() clears the \"File\" property.\n    \t\t\t\t// this is necessary because currently setSpec() doesn't reset the File \n    \t\t\t\t// property, leaving a resource with both an URL and File property.  It\n    \t\t\t\t// shouldn't have both. - pdw 28-nov-07\n    \t\t\t\tresource.removeProperty( \"File\" );\n    \t\t\t}\n    \t\t}\n    \t}\n    \t//upload the map \n    \t/* TODO NOTE: The map that is uploaded has changed from the map that \n    \t * was saved locally earlier this method.  The difference is that the\n    \t * resources that were local now point to Sakai.    \n    \t */\n    \t//File tmpFile = tufts.vue.action.ActionUtil.selectFile(\"Save Map\", \"vue\");\n    \t//File tmpFile = File.createTempFile(\"~vue-\", \".tmp\", VueUtil.getDefaultUserFolder());\n    \t//tmpFile.deleteOnExit();  \n//    \ttufts.vue.action.ActionUtil.marshallMap( tmpFile );\n    \t//tufts.vue.action.ActionUtil.marshallMap( savedMapFile );\n        tufts.vue.action.ActionUtil.marshallMap(tempFile,cloneMap);\n        \n    \tuploadObjectToRepository( \n    \t\t\thostUrl,\n    \t\t\tsessionId,\n    \t\t\tresourceName,\n    \t\t\tfolderName,\n    \t\t\tcloneMap.getFile(),  //tmpFile, \n    \t\t\tcloneMap.hasNotes() ? cloneMap.getNotes() : MAP_DESC, false );\n        tufts.vue.action.ActionUtil.marshallMap(origFile, map);\n        \n    }","commit_id":"7edd123f5f143a7b65d8aee7f0077288faa4f77b","url":"https://github.com/VUE/VUE"},{"original_method":"@Nullable\n  private static Project doOpenFile(VirtualFile virtualFile, int line) {\n    final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    if (projects.length == 0) {\n      final PlatformProjectOpenProcessor processor = PlatformProjectOpenProcessor.getInstanceIfItExists();\n      if (processor != null) {\n        return PlatformProjectOpenProcessor.doOpenProject(virtualFile, null, false, line);\n      }\n      Messages.showErrorDialog(\"No project found to open file in\", \"Cannot open file\");\n      return null;\n    }\n    else {\n      Project project = projects[0];\n      for (Project aProject : projects) {\n        if (ProjectRootManager.getInstance(aProject).getFileIndex().isInContent(virtualFile)) {\n          project = aProject;\n          break;\n        }\n      }\n      if (line == -1) {\n        new OpenFileDescriptor(project, virtualFile).navigate(true);\n      }\n      else {\n        new OpenFileDescriptor(project, virtualFile, line-1, 0).navigate(true);\n      }\n      return project;\n    }\n  }","id":32131,"modified_method":"@Nullable\n  private static Project doOpenFile(VirtualFile virtualFile, int line) {\n    final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    if (projects.length == 0) {\n      final PlatformProjectOpenProcessor processor = PlatformProjectOpenProcessor.getInstanceIfItExists();\n      if (processor != null) {\n        return PlatformProjectOpenProcessor.doOpenProject(virtualFile, null, false, line, null);\n      }\n      Messages.showErrorDialog(\"No project found to open file in\", \"Cannot open file\");\n      return null;\n    }\n    else {\n      Project project = projects[0];\n      for (Project aProject : projects) {\n        if (ProjectRootManager.getInstance(aProject).getFileIndex().isInContent(virtualFile)) {\n          project = aProject;\n          break;\n        }\n      }\n      if (line == -1) {\n        new OpenFileDescriptor(project, virtualFile).navigate(true);\n      }\n      else {\n        new OpenFileDescriptor(project, virtualFile, line-1, 0).navigate(true);\n      }\n      return project;\n    }\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void attachModule(Project project, VirtualFile file) {\n    try {\n      final ModifiableModuleModel model = ModuleManager.getInstance(project).getModifiableModel();\n      model.loadModule(file.getPath());\n\n      AccessToken token = WriteAction.start();\n      try {\n        model.commit();\n      }\n      finally {\n        token.finish();\n      }\n    }\n    catch (Exception ex) {\n      LOG.info(ex);\n      Messages.showErrorDialog(project, \"Cannot attach project: \" + ex.getMessage(), CommonBundle.getErrorTitle());\n    }\n  }","id":32132,"modified_method":"private static void attachModule(Project project, VirtualFile file, ProjectOpenedCallback callback) {\n    try {\n      final ModifiableModuleModel model = ModuleManager.getInstance(project).getModifiableModel();\n      final Module module = model.loadModule(file.getPath());\n\n      AccessToken token = WriteAction.start();\n      try {\n        model.commit();\n      }\n      finally {\n        token.finish();\n      }\n      callback.projectOpened(project, model.findModuleByName(module.getName()));\n    }\n    catch (Exception ex) {\n      LOG.info(ex);\n      Messages.showErrorDialog(project, \"Cannot attach project: \" + ex.getMessage(), CommonBundle.getErrorTitle());\n    }\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean attachToProject(Project project, File projectDir) {\n    if (!projectDir.exists()) {\n      Project newProject = ((ProjectManagerEx) ProjectManager.getInstance()).newProject(projectDir.getParentFile().getName(), projectDir.getParent(), true, false);\n      if (newProject == null) {\n        return false;\n      }\n      final VirtualFile baseDir = LocalFileSystem.getInstance().refreshAndFindFileByPath(projectDir.getParent());\n      PlatformProjectOpenProcessor.runDirectoryProjectConfigurators(baseDir, newProject);\n      newProject.save();\n      AccessToken token = ApplicationManager.getApplication().acquireWriteActionLock(null);\n      try {\n        Disposer.dispose(newProject);\n      }\n      finally {\n        token.finish();\n      }\n    }\n    for(String file: projectDir.list()) {\n      if (FileUtil.getExtension(file).equals(\"iml\")) {\n        VirtualFile imlFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(new File(projectDir, file));\n        if (imlFile != null) {\n          attachModule(project, imlFile);\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }","id":32133,"modified_method":"@Override\n  public boolean attachToProject(Project project, File projectDir, ProjectOpenedCallback callback) {\n    if (!projectDir.exists()) {\n      Project newProject = ((ProjectManagerEx) ProjectManager.getInstance()).newProject(projectDir.getParentFile().getName(), projectDir.getParent(), true, false);\n      if (newProject == null) {\n        return false;\n      }\n      final VirtualFile baseDir = LocalFileSystem.getInstance().refreshAndFindFileByPath(projectDir.getParent());\n      PlatformProjectOpenProcessor.runDirectoryProjectConfigurators(baseDir, newProject);\n      newProject.save();\n      AccessToken token = ApplicationManager.getApplication().acquireWriteActionLock(null);\n      try {\n        Disposer.dispose(newProject);\n      }\n      finally {\n        token.finish();\n      }\n    }\n    for(String file: projectDir.list()) {\n      if (FileUtil.getExtension(file).equals(\"iml\")) {\n        VirtualFile imlFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(new File(projectDir, file));\n        if (imlFile != null) {\n          attachModule(project, imlFile, callback);\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    Project project = e.getData(PlatformDataKeys.PROJECT);\n    NewDirectoryProjectDialog dlg = new NewDirectoryProjectDialog(project);\n    dlg.show();\n    if (dlg.getExitCode() != DialogWrapper.OK_EXIT_CODE) return;\n    final DirectoryProjectGenerator generator = dlg.getProjectGenerator();\n    final File location = new File(dlg.getNewProjectLocation());\n    if (!location.exists() && !location.mkdirs()) {\n      Messages.showErrorDialog(project, \"Cannot create directory '\" + location + \"'\", \"Create Project\");\n      return;\n    }\n\n    VirtualFile baseDir = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n      public VirtualFile compute() {\n        return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(location);\n      }\n    });\n    baseDir.refresh(false, true);\n\n    if (baseDir.getChildren().length > 0) {\n      int rc = Messages.showYesNoDialog(project,\n                                        \"The directory '\" + location +\n                                            \"' is not empty. Would you like to create a project from existing sources instead?\",\n                                        \"Create New Project\", Messages.getQuestionIcon());\n      if (rc == 0) {\n        PlatformProjectOpenProcessor.getInstance().doOpenProject(baseDir, null, false);\n        return;\n      }\n    }\n\n    Object settings = null;\n    if (generator != null) {\n      try {\n        settings = generator.showGenerationSettings(baseDir);\n      }\n      catch (ProcessCanceledException e1) {\n        return;\n      }\n    }\n    GeneralSettings.getInstance().setLastProjectLocation(location.getParent());\n    Project newProject = PlatformProjectOpenProcessor.getInstance().doOpenProject(baseDir, null, false);\n    if (generator != null && newProject != null) {\n      //noinspection unchecked\n      generator.generateProject(newProject, baseDir, settings);\n    }\n  }","id":32134,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n    Project project = e.getData(PlatformDataKeys.PROJECT);\n    NewDirectoryProjectDialog dlg = new NewDirectoryProjectDialog(project);\n    dlg.show();\n    if (dlg.getExitCode() != DialogWrapper.OK_EXIT_CODE) return;\n    final DirectoryProjectGenerator generator = dlg.getProjectGenerator();\n    final File location = new File(dlg.getNewProjectLocation());\n    if (!location.exists() && !location.mkdirs()) {\n      Messages.showErrorDialog(project, \"Cannot create directory '\" + location + \"'\", \"Create Project\");\n      return;\n    }\n\n    final VirtualFile baseDir = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n      public VirtualFile compute() {\n        return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(location);\n      }\n    });\n    baseDir.refresh(false, true);\n\n    if (baseDir.getChildren().length > 0) {\n      int rc = Messages.showYesNoDialog(project,\n                                        \"The directory '\" + location +\n                                            \"' is not empty. Would you like to create a project from existing sources instead?\",\n                                        \"Create New Project\", Messages.getQuestionIcon());\n      if (rc == 0) {\n        PlatformProjectOpenProcessor.getInstance().doOpenProject(baseDir, null, false);\n        return;\n      }\n    }\n\n    Object settings = null;\n    if (generator != null) {\n      try {\n        settings = generator.showGenerationSettings(baseDir);\n      }\n      catch (ProcessCanceledException e1) {\n        return;\n      }\n    }\n    GeneralSettings.getInstance().setLastProjectLocation(location.getParent());\n    final Object finalSettings = settings;\n    PlatformProjectOpenProcessor.doOpenProject(baseDir, null, false, -1, new ProjectOpenedCallback() {\n      @Override\n      public void projectOpened(Project project, Module module) {\n        if (generator != null) {\n          generator.generateProject(project, baseDir, finalSettings, module);\n        }\n      }\n    });\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureProject(final Project project, @NotNull final VirtualFile baseDir) {\n    final ModuleManager moduleManager = ModuleManager.getInstance(project);\n    final Module[] modules = moduleManager.getModules();\n    if (modules.length == 0) {\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          String moduleName = baseDir.getName().replace(\":\", \"\");     // correct module name when opening root of drive as project (RUBY-5181)\n          String imlName = baseDir.getPath() + \"/.idea/\" + moduleName + ModuleFileType.DOT_DEFAULT_EXTENSION;\n          final Module module = moduleManager.newModule(imlName, ModuleTypeManager.getInstance().getDefaultModuleType());\n          ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();\n          rootModel.addContentEntry(baseDir);\n          rootModel.inheritSdk();\n          rootModel.commit();\n        }\n      });\n    }\n  }","id":32135,"modified_method":"public void configureProject(final Project project, @NotNull final VirtualFile baseDir, final Ref<Module> moduleRef) {\n    final ModuleManager moduleManager = ModuleManager.getInstance(project);\n    final Module[] modules = moduleManager.getModules();\n    if (modules.length == 0) {\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          String moduleName = baseDir.getName().replace(\":\", \"\");     // correct module name when opening root of drive as project (RUBY-5181)\n          String imlName = baseDir.getPath() + \"/.idea/\" + moduleName + ModuleFileType.DOT_DEFAULT_EXTENSION;\n          final Module module = moduleManager.newModule(imlName, ModuleTypeManager.getInstance().getDefaultModuleType());\n          ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();\n          rootModel.addContentEntry(baseDir);\n          rootModel.inheritSdk();\n          rootModel.commit();\n          moduleRef.set(module);\n        }\n      });\n    }\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Project doOpenProject(@NotNull final VirtualFile virtualFile, @Nullable final Project projectToClose, final boolean forceOpenInNewFrame) {\n    return doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame, -1);\n  }","id":32136,"modified_method":"@Nullable\n  public Project doOpenProject(@NotNull final VirtualFile virtualFile, @Nullable final Project projectToClose, final boolean forceOpenInNewFrame) {\n    return doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame, -1, null);\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Project doOpenProject(@NotNull final VirtualFile virtualFile,\n                                      Project projectToClose,\n                                      final boolean forceOpenInNewFrame,\n                                      final int line) {\n    VirtualFile baseDir = virtualFile;\n    if (!baseDir.isDirectory()) {\n      baseDir = virtualFile.getParent();\n      while (baseDir != null) {\n        if (new File(baseDir.getPath(), \".idea\").exists()) {\n          break;\n        }\n        baseDir = baseDir.getParent();\n      }\n      if (baseDir == null) {\n        baseDir = virtualFile.getParent();\n      }\n    }\n\n    final File projectDir = new File(baseDir.getPath(), \".idea\");\n\n    Project[] openProjects = ProjectManager.getInstance().getOpenProjects();\n    if (!forceOpenInNewFrame && openProjects.length > 0) {\n      if (projectToClose == null) {\n        projectToClose = openProjects[openProjects.length - 1];\n      }\n\n      if (ProjectAttachProcessor.canAttachToProject()) {\n        final OpenOrAttachDialog dialog = new OpenOrAttachDialog(projectToClose);\n        dialog.show();\n        if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n          return null;\n        }\n        if (dialog.isReplace()) {\n          if (!ProjectUtil.closeAndDispose(projectToClose)) return null;\n        }\n        else if (dialog.isAttach()) {\n          attachToProject(projectToClose, projectDir);\n          return null;\n        }\n      }\n      else {\n        int exitCode = ProjectUtil.confirmOpenNewProject(false);\n        if (exitCode == 0) { // this window option\n          if (!ProjectUtil.closeAndDispose(projectToClose)) return null;\n        }\n        else if (exitCode != 1) { // not in a new window\n          return null;\n        }\n      }\n    }\n    \n    final ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    Project project = null;\n    if (projectDir.exists()) {\n      try {\n        for (ProjectOpenProcessor processor : ProjectOpenProcessor.EXTENSION_POINT_NAME.getExtensions()) {\n          processor.refreshProjectFiles(projectDir);\n        }\n        \n        project = ((ProjectManagerImpl) projectManager).convertAndLoadProject(baseDir.getPath());\n      }\n      catch (Exception e) {\n        // ignore\n      }\n    }\n    else {\n      projectDir.mkdirs();\n    }\n\n    if (project == null) {\n      project = projectManager.newProject(projectDir.getParentFile().getName(), projectDir.getParent(), true, false);\n    }\n\n    if (project == null) return null;\n    runDirectoryProjectConfigurators(baseDir, project);\n\n    openFileFromCommandLine(project, virtualFile, line);\n    projectManager.openProject(project);\n\n    return project;\n  }","id":32137,"modified_method":"@Nullable\n  public static Project doOpenProject(@NotNull final VirtualFile virtualFile,\n                                      Project projectToClose,\n                                      final boolean forceOpenInNewFrame,\n                                      final int line, \n                                      ProjectOpenedCallback callback) {\n    VirtualFile baseDir = virtualFile;\n    if (!baseDir.isDirectory()) {\n      baseDir = virtualFile.getParent();\n      while (baseDir != null) {\n        if (new File(baseDir.getPath(), \".idea\").exists()) {\n          break;\n        }\n        baseDir = baseDir.getParent();\n      }\n      if (baseDir == null) {\n        baseDir = virtualFile.getParent();\n      }\n    }\n\n    final File projectDir = new File(baseDir.getPath(), \".idea\");\n\n    Project[] openProjects = ProjectManager.getInstance().getOpenProjects();\n    if (!forceOpenInNewFrame && openProjects.length > 0) {\n      if (projectToClose == null) {\n        projectToClose = openProjects[openProjects.length - 1];\n      }\n\n      if (ProjectAttachProcessor.canAttachToProject()) {\n        final OpenOrAttachDialog dialog = new OpenOrAttachDialog(projectToClose);\n        dialog.show();\n        if (dialog.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n          return null;\n        }\n        if (dialog.isReplace()) {\n          if (!ProjectUtil.closeAndDispose(projectToClose)) return null;\n        }\n        else if (dialog.isAttach()) {\n          attachToProject(projectToClose, projectDir, callback);\n          return null;\n        }\n      }\n      else {\n        int exitCode = ProjectUtil.confirmOpenNewProject(false);\n        if (exitCode == 0) { // this window option\n          if (!ProjectUtil.closeAndDispose(projectToClose)) return null;\n        }\n        else if (exitCode != 1) { // not in a new window\n          return null;\n        }\n      }\n    }\n    \n    final ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    Project project = null;\n    if (projectDir.exists()) {\n      try {\n        for (ProjectOpenProcessor processor : ProjectOpenProcessor.EXTENSION_POINT_NAME.getExtensions()) {\n          processor.refreshProjectFiles(projectDir);\n        }\n        \n        project = ((ProjectManagerImpl) projectManager).convertAndLoadProject(baseDir.getPath());\n      }\n      catch (Exception e) {\n        // ignore\n      }\n    }\n    else {\n      projectDir.mkdirs();\n    }\n\n    if (project == null) {\n      project = projectManager.newProject(projectDir.getParentFile().getName(), projectDir.getParent(), true, false);\n    }\n\n    if (project == null) return null;\n    final Module module = runDirectoryProjectConfigurators(baseDir, project);\n\n    openFileFromCommandLine(project, virtualFile, line);\n    projectManager.openProject(project);\n    if (callback != null) {\n      callback.projectOpened(project, module);\n    }\n\n    return project;\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void attachToProject(Project project, File projectDir) {\n    final ProjectAttachProcessor[] extensions = Extensions.getExtensions(ProjectAttachProcessor.EP_NAME);\n    for (ProjectAttachProcessor processor : extensions) {\n      if (processor.attachToProject(project, projectDir)) {\n        break;\n      }\n    }\n  }","id":32138,"modified_method":"private static void attachToProject(Project project, File projectDir, ProjectOpenedCallback callback) {\n    final ProjectAttachProcessor[] extensions = Extensions.getExtensions(ProjectAttachProcessor.EP_NAME);\n    for (ProjectAttachProcessor processor : extensions) {\n      if (processor.attachToProject(project, projectDir, callback)) {\n        break;\n      }\n    }\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void runDirectoryProjectConfigurators(VirtualFile baseDir, Project project) {\n    ProjectBaseDirectory.getInstance(project).setBaseDir(baseDir);\n    for(DirectoryProjectConfigurator configurator: Extensions.getExtensions(DirectoryProjectConfigurator.EP_NAME)) {\n      try {\n        configurator.configureProject(project, baseDir);\n      }\n      catch (Exception e) {\n        LOG.error(e);\n      }\n    }\n  }","id":32139,"modified_method":"public static Module runDirectoryProjectConfigurators(VirtualFile baseDir, Project project) {\n    ProjectBaseDirectory.getInstance(project).setBaseDir(baseDir);\n    final Ref<Module> moduleRef = new Ref<Module>();\n    for (DirectoryProjectConfigurator configurator: Extensions.getExtensions(DirectoryProjectConfigurator.EP_NAME)) {\n      try {\n        configurator.configureProject(project, baseDir, moduleRef);\n      }\n      catch (Exception e) {\n        LOG.error(e);\n      }\n    }\n    return moduleRef.get();\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureProject(final Project project, @NotNull final VirtualFile baseDir) {\n    StartupManager.getInstance(project).registerPostStartupActivity(new DumbAwareRunnable() {\n      public void run() {\n        // ensure the dialog is shown after all startup activities are done\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                if (project.isDisposed()) return;\n                final ToolWindow toolWindow = ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.PROJECT_VIEW);\n                if (toolWindow != null && toolWindow.getType() != ToolWindowType.SLIDING) {\n                  toolWindow.activate(null);\n                }\n              }\n            }, ModalityState.NON_MODAL);\n          }\n        });\n      }\n    });\n  }","id":32140,"modified_method":"public void configureProject(final Project project, @NotNull final VirtualFile baseDir, Ref<Module> moduleRef) {\n    StartupManager.getInstance(project).registerPostStartupActivity(new DumbAwareRunnable() {\n      public void run() {\n        // ensure the dialog is shown after all startup activities are done\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                if (project.isDisposed()) return;\n                final ToolWindow toolWindow = ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.PROJECT_VIEW);\n                if (toolWindow != null && toolWindow.getType() != ToolWindowType.SLIDING) {\n                  toolWindow.activate(null);\n                }\n              }\n            }, ModalityState.NON_MODAL);\n          }\n        });\n      }\n    });\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean attachToProject(Project project, File projectDir) {\n    return false;\n  }","id":32141,"modified_method":"public boolean attachToProject(Project project, File projectDir, ProjectOpenedCallback callback) {\n    return false;\n  }","commit_id":"cda83ddbb31e534a53cc6069363ddbf93ece4dcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void start(StartContext context) throws StartException {\n        log.debugf(\"Starting OSGi BundleManager\");\n        try {\n            // [JBVFS-164] Add a URLStreamHandlerFactory service\n            String handlerModules = SystemPropertyActions.getProperty(\"jboss.protocol.handler.modules\");\n            if (handlerModules == null)\n                System.setProperty(\"jboss.protocol.handler.modules\", \"org.jboss.osgi.framework\");\n\n            // Setup the OSGi {@link Framework} properties\n            Configuration config = injectedConfig.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(config.getProperties());\n            ServiceContainer container = context.getController().getServiceContainer();\n            ModuleLoader moduleLoader = injectedModuleLoader.getValue().getModuleLoader();\n            Module frameworkModule = new FrameworkModuleLoader(moduleLoader, props).getFrameworkModule();\n            props.put(IntegrationMode.class.getName(), IntegrationMode.CONTAINER);\n            props.put(ModuleLoader.class.getName(), moduleLoader);\n            props.put(ServiceContainer.class.getName(), container);\n            props.put(Module.class.getName(), frameworkModule);\n\n            // [TODO] This is a temporary workaround to configure the HTTP subsystem in OSGi\n            // this will go away once the HTTP subsystem from AS implements the OSGi HTTP Service.\n            props.put(\"org.osgi.service.http.port\", \"\" + osgiHttpServerPortBinding.getValue().getSocketAddress().getPort());\n\n            // Always clean the framework storage\n            // [TODO] Differentiate beetween user data and persisted bundles\n            props.put(Constants.FRAMEWORK_STORAGE_CLEAN, Constants.FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT);\n\n            // Get {@link ModuleLoader} for the OSGi layer\n            bundleManager = new BundleManager(props);\n            ModuleManagerPlugin plugin = bundleManager.getPlugin(ModuleManagerPlugin.class);\n            ModuleLoader osgiModuleLoader = plugin.getModuleLoader();\n\n            // Register the {@link ModuleLoader} with the {@link ClassifyingModuleLoaderService}\n            ServiceController<?> controller = container.getRequiredService(ClassifyingModuleLoaderService.SERVICE_NAME);\n            ClassifyingModuleLoaderService moduleLoaderService = (ClassifyingModuleLoaderService) controller.getValue();\n            Value<ModuleLoader> value = new ImmediateValue<ModuleLoader>(osgiModuleLoader);\n            osgiModuleLoaderInjector = new ClassifyingModuleLoaderInjector(Constants.JBOSGI_PREFIX, value);\n            osgiModuleLoaderInjector.inject(moduleLoaderService);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to create BundleManager\", t);\n        }\n    }","id":32142,"modified_method":"public synchronized void start(StartContext context) throws StartException {\n        log.debugf(\"Starting OSGi BundleManager\");\n        try {\n            // [JBVFS-164] Add a URLStreamHandlerFactory service\n            String handlerModules = SystemPropertyActions.getProperty(\"jboss.protocol.handler.modules\");\n            if (handlerModules == null)\n                System.setProperty(\"jboss.protocol.handler.modules\", \"org.jboss.osgi.framework\");\n\n            // Setup the OSGi {@link Framework} properties\n            Configuration config = injectedConfig.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(config.getProperties());\n\n            // Set the Framework's {@link IntegrationMode}\n            props.put(IntegrationMode.class.getName(), IntegrationMode.CONTAINER);\n\n            // Setup the default {@link ModuleLoader}\n            ModuleLoader moduleLoader = injectedModuleLoader.getValue().getModuleLoader();\n            props.put(ModuleLoader.class.getName(), moduleLoader);\n\n            // Setup the {@link ServiceContainer}\n            ServiceContainer container = context.getController().getServiceContainer();\n            props.put(ServiceContainer.class.getName(), container);\n\n            // Configure the OSGi HttpService port\n            // [TODO] This will go away once the HTTP subsystem from AS implements the OSGi HttpService.\n            props.put(\"org.osgi.service.http.port\", \"\" + osgiHttpServerPortBinding.getValue().getSocketAddress().getPort());\n\n            // Setup the Framework's storage area. Always clean the framework storage on first init.\n            // [TODO] Differentiate beetween user data and persisted bundles. Persist bundle state in the domain model.\n            props.put(Constants.FRAMEWORK_STORAGE_CLEAN, Constants.FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT);\n\n            // Get {@link ModuleLoader} for the OSGi layer\n            bundleManager = new BundleManager(props);\n\n            // Setup the Framework {@link Module}\n            Module frameworkModule = new FrameworkModuleLoader(bundleManager).getFrameworkModule();\n            bundleManager.setProperty(Module.class.getName(), frameworkModule);\n\n            // Setup the {@link DeployerServicePlugin}\n            ServerDeploymentManager deploymentManager = injectedDeploymentManager.getValue();\n            bundleManager.addPlugin(DeployerServicePlugin.class, new ServerDeployerServicePlugin(bundleManager, deploymentManager));\n\n            // Register the {@link ModuleLoader} with the {@link ClassifyingModuleLoaderService}\n            ModuleManagerPlugin moduleManagerPlugin = bundleManager.getPlugin(ModuleManagerPlugin.class);\n            ServiceController<?> controller = container.getRequiredService(ClassifyingModuleLoaderService.SERVICE_NAME);\n            ClassifyingModuleLoaderService moduleLoaderService = (ClassifyingModuleLoaderService) controller.getValue();\n            Value<ModuleLoader> value = new ImmediateValue<ModuleLoader>(moduleManagerPlugin.getModuleLoader());\n            osgiModuleLoaderInjector = new ClassifyingModuleLoaderInjector(Constants.JBOSGI_PREFIX, value);\n            osgiModuleLoaderInjector.inject(moduleLoaderService);\n\n            // Register the {@link BundleManagerMBean}\n            BundleManagerMBean bundleManagerMBean = new BundleManagerMBean() {\n                @Override\n                public long installBundle(ModuleIdentifier identifier) throws BundleException {\n                    Bundle bundle = bundleManager.installBundle(identifier);\n                    return bundle.getBundleId();\n                }\n                @Override\n                public long installBundle(String location, ModuleIdentifier identifier) throws BundleException {\n                    Bundle bundle = bundleManager.installBundle(location, identifier);\n                    return bundle.getBundleId();\n                }\n            };\n            StandardMBean mbean = new StandardMBean(bundleManagerMBean, BundleManagerMBean.class);\n            injectedMBeanServer.getValue().registerMBean(mbean, BundleManagerMBean.OBJECTNAME);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to create BundleManager\", t);\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(final BatchBuilder batchBuilder) {\n        BundleManagerService service = new BundleManagerService();\n        batchBuilder.addService(BundleManagerService.SERVICE_NAME, service)\n            .addDependency(Configuration.SERVICE_NAME, Configuration.class, service.injectedConfig)\n            .addDependency(ClassifyingModuleLoaderService.SERVICE_NAME, ClassifyingModuleLoaderService.class, service.injectedModuleLoader)\n            .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(\"osgi-http\"), SocketBinding.class, service.osgiHttpServerPortBinding)\n            .setInitialMode(Mode.ON_DEMAND)\n            .install();\n    }","id":32143,"modified_method":"public static void addService(final BatchBuilder batchBuilder) {\n        BundleManagerService service = new BundleManagerService();\n        ServiceBuilder<?> serviceBuilder = batchBuilder.addService(BundleManagerService.SERVICE_NAME, service);\n        serviceBuilder.addDependency(Configuration.SERVICE_NAME, Configuration.class, service.injectedConfig);\n        serviceBuilder.addDependency(ClassifyingModuleLoaderService.SERVICE_NAME, ClassifyingModuleLoaderService.class, service.injectedModuleLoader);\n        serviceBuilder.addDependency(ServerDeploymentManager.SERVICE_NAME_LOCAL, ServerDeploymentManager.class, service.injectedDeploymentManager);\n        serviceBuilder.addDependency(SocketBinding.JBOSS_BINDING_NAME.append(\"osgi-http\"), SocketBinding.class, service.osgiHttpServerPortBinding);\n        serviceBuilder.addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.injectedMBeanServer);\n        serviceBuilder.setInitialMode(Mode.ON_DEMAND);\n        serviceBuilder.install();\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"Module getFrameworkModule() throws ModuleLoadException {\n            return (moduleSpec != null ? loadModule(moduleSpec.getModuleIdentifier()) : defaultFrameworkModule);\n        }","id":32144,"modified_method":"Module getFrameworkModule() throws ModuleLoadException {\n            return loadModule(moduleSpec.getModuleIdentifier());\n        }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected ModuleSpec findModule(ModuleIdentifier identifier) throws ModuleLoadException {\n            if (moduleSpec == null || identifier.equals(frameworkIdentifier) == false)\n                throw new IllegalStateException(\"Cannot provide ModuleSpec for: \" + identifier);\n            return moduleSpec;\n        }","id":32145,"modified_method":"@Override\n        protected ModuleSpec findModule(ModuleIdentifier identifier) throws ModuleLoadException {\n            return moduleSpec;\n        }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(final BatchBuilder batchBuilder, final OSGiSubsystemState state) {\n        Configuration config = new Configuration(state);\n        batchBuilder.addService(SERVICE_NAME, config)\n            .addDependency(ServerEnvironmentService.SERVICE_NAME, ServerEnvironment.class, config.injectedEnvironment)\n            .setInitialMode(Mode.ACTIVE)\n            .install();\n    }","id":32146,"modified_method":"public static void addService(final BatchBuilder batchBuilder, final OSGiSubsystemState state) {\n        Configuration config = new Configuration(state);\n        ServiceBuilder<?> serviceBuilder = batchBuilder.addService(SERVICE_NAME, config);\n        serviceBuilder.addDependency(ServerEnvironmentService.SERVICE_NAME, ServerEnvironment.class, config.injectedEnvironment);\n        serviceBuilder.setInitialMode(Mode.ACTIVE);\n        serviceBuilder.install();\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public BundleContext getValue() throws IllegalStateException {\n        if (framework == null || framework.getState() != Bundle.ACTIVE)\n            throw new IllegalStateException(\"Cannot get BundleContext for: \" + framework);\n        return framework.getBundleContext();\n    }","id":32147,"modified_method":"@Override\n    public Framework getValue() throws IllegalStateException {\n        return framework;\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static BundleContext getServiceValue(ServiceContainer container) {\n        try {\n            ServiceController<?> controller = container.getRequiredService(SERVICE_NAME);\n            return (BundleContext) controller.getValue();\n        } catch (ServiceNotFoundException ex) {\n            throw new IllegalStateException(\"Cannot obtain required service: \" + SERVICE_NAME);\n        }\n    }","id":32148,"modified_method":"public static Framework getServiceValue(ServiceContainer container) {\n        try {\n            ServiceController<?> controller = container.getRequiredService(SERVICE_NAME);\n            return (Framework) controller.getValue();\n        } catch (ServiceNotFoundException ex) {\n            throw new IllegalStateException(\"Cannot obtain required service: \" + SERVICE_NAME);\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(final BatchBuilder batchBuilder, Activation policy) {\n        FrameworkService service = new FrameworkService();\n        batchBuilder.addService(FrameworkService.SERVICE_NAME, service)\n            .addDependency(BundleManagerService.SERVICE_NAME, BundleManager.class, service.injectedBundleManager)\n            .addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.injectedMBeanServer)\n            .addDependency(Configuration.SERVICE_NAME, Configuration.class, service.injectedConfig)\n            .setInitialMode(policy == Activation.LAZY ? Mode.ON_DEMAND : Mode.ACTIVE)\n            .install();\n    }","id":32149,"modified_method":"public static void addService(final BatchBuilder batchBuilder) {\n        FrameworkService service = new FrameworkService();\n        ServiceBuilder<?> serviceBuilder = batchBuilder.addService(FrameworkService.SERVICE_NAME, service);\n        serviceBuilder.addDependency(BundleManagerService.SERVICE_NAME, BundleManager.class, service.injectedBundleManager);\n        serviceBuilder.addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.injectedMBeanServer);\n        serviceBuilder.addDependency(Configuration.SERVICE_NAME, Configuration.class, service.injectedConfig);\n        serviceBuilder.setInitialMode(Mode.ON_DEMAND);\n        serviceBuilder.install();\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void start(StartContext context) throws StartException {\n        log.infof(\"Starting OSGi Framework\");\n        try {\n            // Start the OSGi {@link Framework}\n            final ServiceContainer serviceContainer = context.getController().getServiceContainer();\n            BundleManager bundleManager = injectedBundleManager.getValue();\n            framework = bundleManager.getFrameworkState();\n            framework.start();\n\n            // Register the {@link MBeanServer} as OSGi service\n            BundleContext sysContext = framework.getBundleContext();\n            MBeanServer mbeanServer = injectedMBeanServer.getValue();\n            sysContext.registerService(MBeanServer.class.getName(), mbeanServer, null);\n\n            // Register a {@link SynchronousBundleListener} that removes the {@link DeploymentService}\n            BundleListener uninstallListener = new SynchronousBundleListener() {\n\n                @Override\n                public void bundleChanged(BundleEvent event) {\n                    if (event.getType() == BundleEvent.UNINSTALLED) {\n                        AbstractUserBundle userBundle;\n                        try {\n                            userBundle = AbstractUserBundle.assertBundleState(event.getBundle());\n                        } catch (RuntimeException ex) {\n                            // ignore\n                            return;\n                        }\n                        Deployment deployment = userBundle.getDeployment();\n                        ServiceName serviceName = deployment.getAttachment(ServiceName.class);\n                        if (serviceName != null) {\n                            ServiceController<?> controller = serviceContainer.getService(serviceName);\n                            if (controller != null) {\n                                controller.setMode(ServiceController.Mode.REMOVE);\n                            }\n                        }\n                    }\n                }\n            };\n            sysContext.addBundleListener(uninstallListener);\n\n            // Create the list of {@link Deployment}s for the configured modules\n            List<Deployment> deployments = new ArrayList<Deployment>();\n            BundleDeploymentPlugin depPlugin = bundleManager.getPlugin(BundleDeploymentPlugin.class);\n            for (OSGiModule module : injectedConfig.getValue().getModules()) {\n                ModuleIdentifier identifier = module.getIdentifier();\n                Deployment dep = depPlugin.createDeployment(identifier);\n                dep.setAutoStart(module.isStart());\n                deployments.add(dep);\n            }\n\n            // Deploy the bundles through the {@link DeployerService}\n            ServiceReference sref = sysContext.getServiceReference(DeployerService.class.getName());\n            DeployerService service = (DeployerService) sysContext.getService(sref);\n            service.deploy(deployments.toArray(new Deployment[deployments.size()]));\n\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to start OSGi Framework: \" + framework, t);\n        }\n    }","id":32150,"modified_method":"public synchronized void start(StartContext context) throws StartException {\n        log.infof(\"Starting OSGi Framework\");\n        try {\n            // Start the OSGi {@link Framework}\n            final BundleManager bundleManager = injectedBundleManager.getValue();\n            framework = bundleManager.getFrameworkState();\n            framework.start();\n\n            // Register the {@link MBeanServer} as OSGi service\n            BundleContext sysContext = framework.getBundleContext();\n            MBeanServer mbeanServer = injectedMBeanServer.getValue();\n            sysContext.registerService(MBeanServer.class.getName(), mbeanServer, null);\n\n            // Create the list of {@link Deployment}s for the configured modules\n            List<Deployment> deployments = new ArrayList<Deployment>();\n            BundleDeploymentPlugin depPlugin = bundleManager.getPlugin(BundleDeploymentPlugin.class);\n            for (OSGiModule module : injectedConfig.getValue().getModules()) {\n                ModuleIdentifier identifier = module.getIdentifier();\n                Deployment dep = depPlugin.createDeployment(identifier);\n                dep.setAutoStart(module.isStart());\n                deployments.add(dep);\n            }\n\n            // Deploy the bundles through the {@link SystemDeployerService}\n            // [TODO] Revisit whether these deployments should go through the {@link DeploymentUnitProcessor} chain\n            DeployerService service = new SystemDeployerService(sysContext)\n            {\n               @Override\n               protected Bundle installBundle(Deployment dep) throws BundleException\n               {\n                  AbstractBundle bundleState = bundleManager.installBundle(dep);\n                  return bundleState.getBundleWrapper();\n               }\n            };\n            service.deploy(deployments.toArray(new Deployment[deployments.size()]));\n\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to start OSGi Framework: \" + framework, t);\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Activate the services required for service deployments.\n     *\n     * @param deploymentChain The deployment chain\n     */\n    public void activate(final DeploymentChain deploymentChain) {\n        deploymentChain.addProcessor(new ManifestAttachmentProcessor(), Phase.MANIFEST_ATTACHMENT_PROCESSOR);\n        deploymentChain.addProcessor(new AnnotationIndexProcessor(),  Phase.ANNOTATION_INDEX_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleDependencyProcessor(), Phase.MODULE_DEPENDENCY_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleConfigProcessor(), Phase.MODULE_CONFIG_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleDeploymentProcessor(), Phase.MODULE_DEPLOYMENT_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleContextProcessor(), Phase.MODULE_CONTEXT_PROCESSOR);\n        deploymentChain.addProcessor(new ServiceActivatorDependencyProcessor(), Phase.SERVICE_ACTIVATION_DEPENDENCY_PROCESSOR);\n        deploymentChain.addProcessor(new ServiceActivatorProcessor(), Phase.SERVICE_ACTIVATOR_PROCESSOR);\n    }","id":32151,"modified_method":"/**\n     * Activate the services required for service deployments.\n     *\n     * @param deploymentChain The deployment chain\n     */\n    public void activate(final DeploymentChain deploymentChain) {\n        deploymentChain.addProcessor(new ManifestAttachmentProcessor(), Phase.MANIFEST_ATTACHMENT_PROCESSOR);\n        deploymentChain.addProcessor(new OSGiManifestAttachmentProcessor(), Phase.OSGI_MANIFEST_ATTACHMENT_PROCESSOR);\n        deploymentChain.addProcessor(new AnnotationIndexProcessor(),  Phase.ANNOTATION_INDEX_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleDependencyProcessor(), Phase.MODULE_DEPENDENCY_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleConfigProcessor(), Phase.MODULE_CONFIG_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleDeploymentProcessor(), Phase.MODULE_DEPLOYMENT_PROCESSOR);\n        deploymentChain.addProcessor(new ModuleContextProcessor(), Phase.MODULE_CONTEXT_PROCESSOR);\n        deploymentChain.addProcessor(new ServiceActivatorDependencyProcessor(), Phase.SERVICE_ACTIVATION_DEPENDENCY_PROCESSOR);\n        deploymentChain.addProcessor(new ServiceActivatorProcessor(), Phase.SERVICE_ACTIVATOR_PROCESSOR);\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process the deployment to create and attach module configuration.\n     *\n     * @param context the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     */\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        if(context.getAttachment(ModuleConfig.ATTACHMENT_KEY) != null)\n            return;\n        final VirtualFile deploymentRoot = getVirtualFileAttachment(context);\n        final MountHandle rootMount = context.getAttachment(MountHandle.ATTACHMENT_KEY);\n        final NestedMounts mounts = context.getAttachment(NestedMounts.ATTACHMENT_KEY);\n\n        final ModuleIdentifier moduleIdentifier = ModuleIdentifier.create(\"deployment.\" + deploymentRoot.getName());\n\n        int numMounts = mounts == null ? 1 : mounts.size() + 1;\n        final ModuleConfig.ResourceRoot[] resourceRoots = new ModuleConfig.ResourceRoot[numMounts];\n\n        if (mounts != null) {\n            int i = 1;\n            for (NestedMounts.Entry entry : mounts) {\n                resourceRoots[i++] = new ModuleConfig.ResourceRoot(entry.file(), entry.mount());\n            }\n        }\n        resourceRoots[0] = new ModuleConfig.ResourceRoot(deploymentRoot, rootMount);\n\n        final ModuleDependencies dependenciesAttachment = getAttachedDependencies(context);\n        final ModuleConfig.Dependency[] dependencies = dependenciesAttachment != null ? dependenciesAttachment.getDependencies() : NO_DEPS;\n        final ModuleConfig moduleConfig = new ModuleConfig(moduleIdentifier, dependencies, resourceRoots);\n        context.putAttachment(ModuleConfig.ATTACHMENT_KEY, moduleConfig);\n    }","id":32152,"modified_method":"/**\n     * Process the deployment to create and attach module configuration.\n     *\n     * @param context the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     */\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n\n        if(context.getAttachment(ModuleConfig.ATTACHMENT_KEY) != null)\n            return;\n\n        if(OSGiManifestAttachment.getManifestAttachment(context) != null)\n            return;\n\n        final VirtualFile deploymentRoot = VirtualFileAttachment.getVirtualFileAttachment(context);\n        final MountHandle rootMount = context.getAttachment(MountHandle.ATTACHMENT_KEY);\n        final NestedMounts mounts = context.getAttachment(NestedMounts.ATTACHMENT_KEY);\n\n        final ModuleIdentifier moduleIdentifier = ModuleIdentifier.create(\"deployment.\" + deploymentRoot.getName());\n\n        int numMounts = mounts == null ? 1 : mounts.size() + 1;\n        final ModuleConfig.ResourceRoot[] resourceRoots = new ModuleConfig.ResourceRoot[numMounts];\n\n        if (mounts != null) {\n            int i = 1;\n            for (NestedMounts.Entry entry : mounts) {\n                resourceRoots[i++] = new ModuleConfig.ResourceRoot(entry.file(), entry.mount());\n            }\n        }\n        resourceRoots[0] = new ModuleConfig.ResourceRoot(deploymentRoot, rootMount);\n\n        final ModuleDependencies dependenciesAttachment = ModuleDependencies.getAttachedDependencies(context);\n        final ModuleConfig.Dependency[] dependencies = dependenciesAttachment != null ? dependenciesAttachment.getDependencies() : NO_DEPS;\n        final ModuleConfig moduleConfig = new ModuleConfig(moduleIdentifier, dependencies, resourceRoots);\n        context.putAttachment(ModuleConfig.ATTACHMENT_KEY, moduleConfig);\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n\n        // Check if we already have an OSGi deployment\n        Deployment deployment = DeploymentAttachment.getDeploymentAttachment(context);\n\n        // Check for attached BundleInfo\n        BundleInfo info = BundleInfoAttachment.getBundleInfoAttachment(context);\n        if (deployment == null && info != null) {\n            deployment = DeploymentFactory.createDeployment(info);\n            deployment.addAttachment(BundleInfo.class, info);\n            DeploymentAttachment.attachDeployment(context, deployment);\n        }\n\n        // Check for attached OSGiMetaData\n        OSGiMetaData metadata = OSGiMetaDataAttachment.getOSGiMetaDataAttachment(context);\n        if (deployment == null && metadata != null) {\n            VirtualFile virtualFile = VirtualFileAttachment.getVirtualFileAttachment(context);\n            String location = virtualFile.getPathName();\n            String symbolicName = metadata.getBundleSymbolicName();\n            Version version = metadata.getBundleVersion();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n            deployment.addAttachment(OSGiMetaData.class, metadata);\n            DeploymentAttachment.attachDeployment(context, deployment);\n        }\n\n        // Check for attached XModule\n        XModule resModule = XModuleAttachment.getXModuleAttachment(context);\n        if (deployment == null && resModule != null) {\n            VirtualFile virtualFile = VirtualFileAttachment.getVirtualFileAttachment(context);\n            String location = virtualFile.getPathName();\n            String symbolicName = resModule.getName();\n            Version version = resModule.getVersion();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n            deployment.addAttachment(XModule.class, resModule);\n            DeploymentAttachment.attachDeployment(context, deployment);\n        }\n\n        // Create the {@link OSGiDeploymentService}\n        if (deployment != null) {\n\n            // Prevent garbage collection of the MountHandle which will close the file\n            MountHandle mount = context.getAttachment(MountHandle.ATTACHMENT_KEY);\n            deployment.addAttachment(MountHandle.class, mount);\n\n            OSGiDeploymentService.addService(context);\n        }\n    }","id":32153,"modified_method":"@Override\n    public void processDeployment(final DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n\n        // Check if we already have an OSGi deployment\n        Deployment deployment = OSGiDeploymentAttachment.getAttachment(context);\n\n        String location = InstallBundleInitiatorService.getLocation(serviceContainer, context.getName());\n        VirtualFile virtualFile = VirtualFileAttachment.getVirtualFileAttachment(context);\n\n        // Check for attached BundleInfo\n        BundleInfo info = BundleInfoAttachment.getBundleInfoAttachment(context);\n        if (deployment == null && info != null) {\n            deployment = DeploymentFactory.createDeployment(info);\n            deployment.addAttachment(BundleInfo.class, info);\n            OSGiDeploymentAttachment.attachDeployment(context, deployment);\n        }\n\n        // Check for attached OSGiMetaData\n        OSGiMetaData metadata = OSGiMetaDataAttachment.getOSGiMetaDataAttachment(context);\n        if (deployment == null && metadata != null) {\n            String symbolicName = metadata.getBundleSymbolicName();\n            Version version = metadata.getBundleVersion();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n            deployment.addAttachment(OSGiMetaData.class, metadata);\n            OSGiDeploymentAttachment.attachDeployment(context, deployment);\n        }\n\n        // Check for attached XModule\n        XModule resModule = XModuleAttachment.getXModuleAttachment(context);\n        if (deployment == null && resModule != null) {\n            String symbolicName = resModule.getName();\n            Version version = resModule.getVersion();\n            deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n            deployment.addAttachment(XModule.class, resModule);\n            OSGiDeploymentAttachment.attachDeployment(context, deployment);\n        }\n\n        // Create the {@link OSGiDeploymentService}\n        if (deployment != null) {\n\n            // Prevent garbage collection of the MountHandle which will close the file\n            MountHandle mount = context.getAttachment(MountHandle.ATTACHMENT_KEY);\n            deployment.addAttachment(MountHandle.class, mount);\n\n            // Mark the bundle to start automatically\n            deployment.setAutoStart(true);\n\n            OSGiDeploymentService.addService(context);\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Activate the services required for service deployments.\n     */\n    public void activate(final BootUpdateContext updateContext) {\n        updateContext.addDeploymentProcessor(new OSGiManifestDeploymentProcessor(), Phase.OSGI_MANIFEST_DEPLOYMENT_PROCESSOR);\n        updateContext.addDeploymentProcessor(new OSGiAttachmentsDeploymentProcessor(), Phase.OSGI_ATTACHMENTS_DEPLOYMENT_PROCESSOR);\n    }","id":32154,"modified_method":"/**\n     * Activate the services required for service deployments.\n     */\n    public void activate(final BootUpdateContext updateContext) {\n        ServiceContainer serviceContainer = updateContext.getServiceContainer();\n        updateContext.addDeploymentProcessor(new BundleInfoAttachmentProcessor(serviceContainer), Phase.OSGI_BUNDLE_INFO_ATTACHMENT_PROCESSOR);\n        updateContext.addDeploymentProcessor(new OSGiAttachmentsDeploymentProcessor(serviceContainer), Phase.OSGI_ATTACHMENTS_DEPLOYMENT_PROCESSOR);\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processDeployment(ServiceController<? extends Deployment> controller) {\n            controller.removeListener(this);\n            Set<Deployment> bundlesToStart = null;\n            synchronized (this) {\n                pendingDeployments.remove(controller.getValue());\n                if (pendingDeployments.isEmpty()) {\n                    bundlesToStart = new HashSet<Deployment>(startedDeployments);\n                    startedDeployments.clear();\n                }\n            }\n\n            if (bundlesToStart != null) {\n                ServiceContainer serviceContainer = controller.getServiceContainer();\n                PackageAdmin packageAdmin = PackageAdminService.getServiceValue(serviceContainer);\n                for (Deployment deployment : bundlesToStart) {\n                    Bundle bundle = deployment.getAttachment(Bundle.class);\n                    if (packageAdmin.getBundleType(bundle) != PackageAdmin.BUNDLE_TYPE_FRAGMENT) {\n                        log.tracef(\"Starting bundle: %s\", bundle);\n                        try {\n                            bundle.start();\n                        } catch (BundleException ex) {\n                            log.errorf(ex, \"Cannot start bundle: %s\", bundle);\n                        }\n                    }\n                }\n            }\n        }","id":32155,"modified_method":"private void processDeployment(ServiceController<? extends Deployment> controller) {\n\n            controller.removeListener(this);\n            Set<Deployment> bundlesToStart = null;\n\n            synchronized (this) {\n                pendingDeployments.remove(controller.getValue());\n                if (pendingDeployments.isEmpty()) {\n                    bundlesToStart = new HashSet<Deployment>(startedDeployments);\n                    startedDeployments.clear();\n                }\n            }\n\n            if (bundlesToStart != null) {\n                ServiceContainer serviceContainer = controller.getServiceContainer();\n                PackageAdmin packageAdmin = PackageAdminService.getServiceValue(serviceContainer);\n                StartLevel startLevel = StartLevelService.getServiceValue(serviceContainer);\n                for (Deployment dep : bundlesToStart) {\n                    Bundle bundle = dep.getAttachment(Bundle.class);\n                    if (packageAdmin.getBundleType(bundle) != PackageAdmin.BUNDLE_TYPE_FRAGMENT) {\n\n                        boolean autoStart = dep.isAutoStart();\n\n                        // Obtain the autoStart properties from the initiating deployment\n                        // If this call is not a result of BundleContext.installBundle(...)\n                        // there won't be an {@link InstallBundleInitiatorService}\n                        String contextName = InstallBundleInitiatorService.getContextName(dep);\n                        ServiceName serviceName = InstallBundleInitiatorService.getServiceName(contextName);\n                        ServiceController<?> initiatingController = serviceContainer.getService(serviceName);\n                        if (initiatingController != null) {\n                            try {\n                                Deployment initiatingDeployment = (Deployment) initiatingController.getValue();\n                                autoStart = initiatingDeployment.isAutoStart();\n                                Integer startlevel = initiatingDeployment.getStartLevel();\n                                if (startlevel != null)\n                                    startLevel.setBundleStartLevel(bundle, startlevel);\n                            } finally {\n                                initiatingController.setMode(Mode.REMOVE);\n                            }\n                        }\n\n                        if (autoStart) {\n                            log.tracef(\"Starting bundle: %s\", bundle);\n                            try {\n                                bundle.start();\n                            } catch (BundleException ex) {\n                                log.errorf(ex, \"Cannot start bundle: %s\", bundle);\n                            }\n                        }\n                    }\n                }\n            }\n        }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Uninstall the Bundle associated with this deployment.\n     *\n     * @param context The stop context.\n     */\n    public synchronized void stop(StopContext context) {\n        log.tracef(\"Uninstalling deployment: %s\", deployment);\n        try {\n            getDeployerService().undeploy(deployment);\n        } catch (Throwable t) {\n            log.errorf(t, \"Failed to uninstall deployment: %s\", deployment);\n        }\n    }","id":32156,"modified_method":"/**\n     * Uninstall the Bundle associated with this deployment.\n     *\n     * @param context The stop context.\n     */\n    public synchronized void stop(StopContext context) {\n        log.tracef(\"Uninstalling deployment: %s\", deployment);\n        try {\n            BundleManager bundleManager = injectedBundleManager.getValue();\n            bundleManager.uninstallBundle(deployment);\n        } catch (Throwable t) {\n            log.errorf(t, \"Failed to uninstall deployment: %s\", deployment);\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Install the Bundle associated with this deployment.\n     *\n     * @param context The start context\n     */\n    public synchronized void start(StartContext context) throws StartException {\n\n        // Get the OSGi system context\n        ServiceController<?> controller = context.getController();\n        ServiceContainer serviceContainer = controller.getServiceContainer();\n\n        // Make sure the Framework does not shut down when the last bundle gets removed\n        ServiceController<?> frameworkController = serviceContainer.getService(FrameworkService.SERVICE_NAME);\n        frameworkController.setMode(Mode.ACTIVE);\n\n        log.tracef(\"Installing deployment: %s\", deployment);\n        try {\n            boolean autoStart = deployment.isAutoStart();\n            deployment.setAutoStart(false);\n            Bundle bundle = getDeployerService().deploy(deployment);\n            deployment.addAttachment(Bundle.class, bundle);\n            deployment.setAutoStart(autoStart);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to install deployment: \" + deployment, t);\n        }\n    }","id":32157,"modified_method":"/**\n     * Install the Bundle associated with this deployment.\n     *\n     * @param context The start context\n     */\n    public synchronized void start(StartContext context) throws StartException {\n\n        // Get the OSGi system context\n        ServiceController<?> controller = context.getController();\n        ServiceContainer serviceContainer = controller.getServiceContainer();\n\n        // Make sure the Framework does not shut down when the last bundle gets removed\n        ServiceController<?> contextController = serviceContainer.getService(FrameworkService.SERVICE_NAME);\n        contextController.setMode(Mode.ACTIVE);\n\n        log.tracef(\"Installing deployment: %s\", deployment);\n        try {\n            boolean autoStart = deployment.isAutoStart();\n            deployment.setAutoStart(false);\n            BundleManager bundleManager = injectedBundleManager.getValue();\n            bundleManager.installBundle(deployment);\n            deployment.setAutoStart(autoStart);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to install deployment: \" + deployment, t);\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(DeploymentUnitContext context) {\n\n        // Attach the {@link DeploymentService} name so we remove that service on Bundle.uninstall()\n        ServiceName deploymentServiceName = DeploymentService.getServiceName(context.getName());\n        Deployment deployment = DeploymentAttachment.getDeploymentAttachment(context);\n        deployment.addAttachment(ServiceName.class, deploymentServiceName);\n\n        BatchBuilder batchBuilder = context.getBatchBuilder();\n        OSGiDeploymentService service = new OSGiDeploymentService(deployment);\n        ServiceName serviceName = OSGiDeploymentService.SERVICE_NAME.append(deploymentServiceName.getSimpleName());\n        ServiceBuilder<Deployment> serviceBuilder = batchBuilder.addService(serviceName, service);\n        serviceBuilder.addDependency(FrameworkService.SERVICE_NAME, BundleContext.class, service.injectedContext);\n        serviceBuilder.addDependency(PackageAdminService.SERVICE_NAME);\n        serviceBuilder.addDependency(deploymentServiceName);\n        serviceBuilder.setInitialMode(Mode.ACTIVE);\n        if (enableListener)\n            serviceBuilder.addListener(listener);\n        serviceBuilder.install();\n    }","id":32158,"modified_method":"public static void addService(DeploymentUnitContext context) {\n        addService(context.getBatchBuilder(), OSGiDeploymentAttachment.getAttachment(context), context.getName());\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void, P> resultHandler, P param) {\n        log.infof(\"Activating OSGi Subsystem\");\n\n        // TODO: Hack, which registers the framework module with the {@link ModularURLStreamHandlerFactory}\n        String value = SystemPropertyActions.getProperty(\"jboss.protocol.handler.modules\", \"org.jboss.osgi.framework\");\n        if (!value.equals(\"org.jboss.osgi.framework\"))\n            value = value + \"|org.jboss.osgi.framework\";\n        System.setProperty(\"jboss.protocol.handler.modules\", value);\n\n        Activation policy = subsystemState.getActivationPolicy();\n        BatchBuilder batchBuilder = updateContext.getBatchBuilder();\n        Configuration.addService(batchBuilder, subsystemState);\n        BundleManagerService.addService(batchBuilder);\n        FrameworkService.addService(batchBuilder, policy);\n        PackageAdminService.addService(batchBuilder);\n    }","id":32159,"modified_method":"protected <P> void applyUpdate(UpdateContext updateContext, UpdateResultHandler<? super Void, P> resultHandler, P param) {\n        log.infof(\"Activating OSGi Subsystem\");\n\n        // TODO: Hack, which registers the framework module with the {@link ModularURLStreamHandlerFactory}\n        String value = SystemPropertyActions.getProperty(\"jboss.protocol.handler.modules\", \"org.jboss.osgi.framework\");\n        if (!value.equals(\"org.jboss.osgi.framework\"))\n            value = value + \"|org.jboss.osgi.framework\";\n        System.setProperty(\"jboss.protocol.handler.modules\", value);\n\n        Activation policy = subsystemState.getActivationPolicy();\n        BatchBuilder batchBuilder = updateContext.getBatchBuilder();\n        Configuration.addService(batchBuilder, subsystemState);\n        BundleManagerService.addService(batchBuilder);\n        FrameworkService.addService(batchBuilder);\n        BundleContextService.addService(batchBuilder, policy);\n        PackageAdminService.addService(batchBuilder);\n        StartLevelService.addService(batchBuilder);\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeContent(final XMLExtendedStreamWriter streamWriter) throws XMLStreamException {\n        synchronized (this) {\n            Activation policy = subsystemState.getActivationPolicy();\n            streamWriter.writeAttribute(Attribute.ACTIVATION.getLocalName(), policy.name().toLowerCase());\n\n            Map<String, Object> properties = subsystemState.getProperties();\n            if (properties.isEmpty() == false) {\n                streamWriter.writeStartElement(Element.PROPERTIES.getLocalName());\n                for (Map.Entry<String, Object> entry : properties.entrySet()) {\n                    streamWriter.writeStartElement(Element.PROPERTY.getLocalName());\n                    streamWriter.writeAttribute(Attribute.NAME.getLocalName(), entry.getKey());\n                    streamWriter.writeCharacters((String) entry.getValue());\n                    streamWriter.writeEndElement();\n                }\n                streamWriter.writeEndElement();\n            }\n\n            List<OSGiModule> modules = subsystemState.getModules();\n            if (modules.isEmpty() == false) {\n                streamWriter.writeStartElement(Element.MODULES.getLocalName());\n                for (OSGiModule module : modules) {\n                    ModuleIdentifier identifier = module.getIdentifier();\n                    streamWriter.writeStartElement(Element.MODULE.getLocalName());\n                    String canonicalName = identifier.getName() + \":\" + identifier.getSlot();\n                    streamWriter.writeAttribute(Attribute.IDENTIFIER.getLocalName(), canonicalName);\n                    if (module.isStart())\n                        streamWriter.writeAttribute(Attribute.START.getLocalName(), \"true\");\n                    streamWriter.writeEndElement();\n                }\n                streamWriter.writeEndElement();\n            }\n            streamWriter.writeEndElement();\n        }\n    }","id":32160,"modified_method":"@Override\n    public void writeContent(final XMLExtendedStreamWriter streamWriter) throws XMLStreamException {\n        synchronized (this) {\n            Activation policy = subsystemState.getActivationPolicy();\n            streamWriter.writeAttribute(Attribute.ACTIVATION.getLocalName(), policy.name().toLowerCase());\n\n            Map<String, Object> properties = subsystemState.getProperties();\n            if (properties.isEmpty() == false) {\n                streamWriter.writeStartElement(Element.PROPERTIES.getLocalName());\n                for (Map.Entry<String, Object> entry : properties.entrySet()) {\n                    streamWriter.writeStartElement(Element.PROPERTY.getLocalName());\n                    streamWriter.writeAttribute(Attribute.NAME.getLocalName(), entry.getKey());\n                    streamWriter.writeCharacters((String) entry.getValue());\n                    streamWriter.writeEndElement();\n                }\n                streamWriter.writeEndElement();\n            }\n\n            List<OSGiModule> modules = subsystemState.getModules();\n            if (modules.isEmpty() == false) {\n                streamWriter.writeStartElement(Element.MODULES.getLocalName());\n                for (OSGiModule module : modules) {\n                    ModuleIdentifier identifier = module.getIdentifier();\n                    streamWriter.writeStartElement(Element.MODULE.getLocalName());\n                    String canonicalName = identifier.getName();\n                    if (\"main\".equals(identifier.getSlot()) == false)\n                        canonicalName += \":\" + identifier.getSlot();\n                    streamWriter.writeAttribute(Attribute.IDENTIFIER.getLocalName(), canonicalName);\n                    if (module.isStart())\n                        streamWriter.writeAttribute(Attribute.START.getLocalName(), \"true\");\n                    streamWriter.writeEndElement();\n                }\n                streamWriter.writeEndElement();\n            }\n            streamWriter.writeEndElement();\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n\n        // Check if we already have an OSGi deployment\n        Deployment deployment = DeploymentAttachment.getDeploymentAttachment(context);\n        if (deployment != null)\n            return;\n\n        // Get the OSGi XService properties\n        String resName = \"META-INF/jbosgi-xservice.properties\";\n        VirtualFile virtualFile = VirtualFileAttachment.getVirtualFileAttachment(context);\n        VirtualFile xserviceFile = virtualFile.getChild(resName);\n        if (xserviceFile.exists()) {\n            try {\n                OSGiMetaData metadata = OSGiMetaDataBuilder.load(xserviceFile.openStream());\n                String location = virtualFile.getPathName();\n                String symbolicName = metadata.getBundleSymbolicName();\n                Version version = metadata.getBundleVersion();\n                deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n                deployment.addAttachment(OSGiMetaData.class, metadata);\n                OSGiMetaDataAttachment.attachOSGiMetaData(context, metadata);\n                DeploymentAttachment.attachDeployment(context, deployment);\n            } catch (IOException ex) {\n                throw new DeploymentUnitProcessingException(\"Cannot parse: \" + xserviceFile);\n            }\n        }\n    }","id":32161,"modified_method":"@Override\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n\n        // Check if we already have an OSGi deployment\n        Deployment deployment = OSGiDeploymentAttachment.getAttachment(context);\n        if (deployment != null)\n            return;\n\n        // Get the OSGi XService properties\n        String resName = \"META-INF/jbosgi-xservice.properties\";\n        VirtualFile virtualFile = VirtualFileAttachment.getVirtualFileAttachment(context);\n        VirtualFile xserviceFile = virtualFile.getChild(resName);\n        if (xserviceFile.exists()) {\n            try {\n                OSGiMetaData metadata = OSGiMetaDataBuilder.load(xserviceFile.openStream());\n                String location = virtualFile.getPathName();\n                String symbolicName = metadata.getBundleSymbolicName();\n                Version version = metadata.getBundleVersion();\n                deployment = DeploymentFactory.createDeployment(AbstractVFS.adapt(virtualFile), location, symbolicName, version);\n                deployment.addAttachment(OSGiMetaData.class, metadata);\n                OSGiMetaDataAttachment.attachOSGiMetaData(context, metadata);\n                OSGiDeploymentAttachment.attachDeployment(context, deployment);\n            } catch (IOException ex) {\n                throw new DeploymentUnitProcessingException(\"Cannot parse: \" + xserviceFile);\n            }\n        }\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void addService(final BatchBuilder batchBuilder) {\n        PackageAdminService service = new PackageAdminService();\n        batchBuilder.addService(PackageAdminService.SERVICE_NAME, service)\n            .addDependency(FrameworkService.SERVICE_NAME, BundleContext.class, service.injectedContext)\n            .setInitialMode(Mode.ON_DEMAND)\n            .install();\n    }","id":32162,"modified_method":"public static void addService(final BatchBuilder batchBuilder) {\n        PackageAdminService service = new PackageAdminService();\n        ServiceBuilder<?> serviceBuilder = batchBuilder.addService(PackageAdminService.SERVICE_NAME, service);\n        serviceBuilder.addDependency(BundleContextService.SERVICE_NAME, BundleContext.class, service.injectedContext);\n        serviceBuilder.setInitialMode(Mode.ON_DEMAND);\n        serviceBuilder.install();\n    }","commit_id":"52eb2af1215f77eddcc13a16bbd17b73061289c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceName installService(final ServiceTarget target, final ModuleIdentifier identifier, final List<ModuleIdentifier> dependencies) {\n        final ModuleLoadService service = new ModuleLoadService();\n        final ServiceName serviceName = ServiceModuleLoader.moduleServiceName(identifier);\n        final ServiceBuilder<Module> builder = target.addService(serviceName, service);\n        builder.addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, service.getServiceModuleLoader());\n        builder.addDependency(ServiceModuleLoader.moduleSpecServiceName(identifier), ModuleSpec.class, service.getModuleSpec());\n        for (final ModuleIdentifier dep : dependencies) {\n            if (dep.getName().startsWith(ServiceModuleLoader.MODULE_PREFIX)) {\n                builder.addDependencies(ServiceModuleLoader.moduleSpecServiceName(dep));\n            }\n        }\n        builder.setInitialMode(Mode.ON_DEMAND);\n        builder.install();\n        return serviceName;\n    }","id":32163,"modified_method":"public static ServiceName installService(final ServiceTarget target, final ModuleIdentifier identifier, final List<ModuleIdentifier> dependencies) {\n        final ModuleLoadService service = new ModuleLoadService(dependencies);\n        final ServiceName serviceName = ServiceModuleLoader.moduleServiceName(identifier);\n        final ServiceBuilder<Module> builder = target.addService(serviceName, service);\n        builder.addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, service.getServiceModuleLoader());\n        builder.addDependency(ServiceModuleLoader.moduleSpecServiceName(identifier), ModuleSpec.class, service.getModuleSpec());\n        for (final ModuleIdentifier dep : dependencies) {\n            if (dep.getName().startsWith(ServiceModuleLoader.MODULE_PREFIX)) {\n                builder.addDependencies(ServiceModuleLoader.moduleSpecServiceName(dep));\n            }\n        }\n        builder.setInitialMode(Mode.ON_DEMAND);\n        builder.install();\n        return serviceName;\n    }","commit_id":"2f215d9ac196b1ad4c213349b814bd293dc5e282","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        try {\n            module = serviceModuleLoader.getValue().loadModule(moduleSpec.getValue().getModuleIdentifier());\n            serviceModuleLoader.getValue().relinkModule(module);\n\n        } catch (ModuleLoadException e) {\n            throw new StartException(\"Failed to load module: \" + moduleSpec.getValue().getModuleIdentifier(), e);\n        }\n    }","id":32164,"modified_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        try {\n            final ServiceModuleLoader moduleLoader = serviceModuleLoader.getValue();\n            final Module module = moduleLoader.loadModule(moduleSpec.getValue().getModuleIdentifier());\n            moduleLoader.relinkModule(module);\n            for (ModuleIdentifier id : dependencies) {\n                String val = moduleLoader.loadModule(id).getProperty(\"jboss.api\");\n                if (val != null) {\n                    if (val.equals(\"private\")) {\n                        PRIVATE_DEP_LOGGER.privateApiUsed(moduleSpec.getValue().getModuleIdentifier().getName(), id);\n                    } else if (val.equals(\"unsupported\")) {\n                        UNSUPPORTED_DEP_LOGGER.unsupportedApiUsed(moduleSpec.getValue().getModuleIdentifier().getName(), id);\n                    }\n                }\n            }\n            this.module = module;\n        } catch (ModuleLoadException e) {\n            throw new StartException(\"Failed to load module: \" + moduleSpec.getValue().getModuleIdentifier(), e);\n        }\n    }","commit_id":"2f215d9ac196b1ad4c213349b814bd293dc5e282","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server(args.length==0?8080:Integer.parseInt(args[0]));\n        \n        ResourceHandler resource_handler=new ResourceHandler()\n        {\n            protected void doDirectory(HttpServletRequest request, HttpServletResponse response, Resource resource) throws IOException\n            {\n                String listing=resource.getListHTML(request.getRequestURI(),request.getPathInfo().lastIndexOf(\"/\")>0);\n                response.setContentType(\"text/html; charset=UTF-8\");\n                response.getWriter().println(listing);\n            }\n        };\n        resource_handler.setWelcomeFiles(new String[]{\"index.html\"});\n        \n        resource_handler.setResourceBase(args.length==2?args[1]:\".\");\n        Log.info(\"serving \"+resource_handler.getBaseResource());\n        HandlerList handlers = new HandlerList();\n        handlers.setHandlers(new Handler[]{resource_handler,new DefaultHandler()});\n        server.setHandler(handlers);\n        \n        server.start();\n        server.join();\n    }","id":32165,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        Server server = new Server(8080);\n\n        ResourceHandler resource_handler = new ResourceHandler();\n        resource_handler.setDirectoriesListed(true);\n        resource_handler.setWelcomeFiles(new String[]{ \"index.html\" });\n\n        resource_handler.setResourceBase(\".\");\n        \n        HandlerList handlers = new HandlerList();\n        handlers.setHandlers(new Handler[] { resource_handler, new DefaultHandler() });\n        server.setHandler(handlers);\n\n        server.start();\n        server.join();\n    }","commit_id":"c0a92fa463688a392af494156c7c8ddee78a6c34","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server();\n        \n        SelectChannelConnector connector0 = new SelectChannelConnector();\n        connector0.setPort(8080);\n        connector0.setMaxIdleTime(5000);\n        connector0.setName(\"connector 0\");\n       \n        \n        SelectChannelConnector connector1 = new SelectChannelConnector();\n        connector1.setHost(\"127.0.0.1\");\n        connector1.setPort(8888);\n        connector1.setName(\"connector 1\");\n        \n        SocketConnector connector2 = new SocketConnector();\n        connector2.setHost(\"127.0.0.2\");\n        connector2.setPort(8888);\n        connector2.setThreadPool(new QueuedThreadPool());\n        connector2.setName(\"connector 2\");\n        \n        server.setConnectors(new Connector[]{connector0,connector1,connector2});\n        \n        server.setHandler(new HelloHandler());\n        \n        server.start();\n        server.join();\n    }","id":32166,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        Server server = new Server();\n\n        SelectChannelConnector connector0 = new SelectChannelConnector();\n        connector0.setPort(8080);\n        connector0.setMaxIdleTime(30000);\n        connector0.setRequestHeaderSize(8192);\n\n        SelectChannelConnector connector1 = new SelectChannelConnector();\n        connector1.setHost(\"127.0.0.1\");\n        connector1.setPort(8888);\n        connector1.setThreadPool(new QueuedThreadPool(20));\n        connector1.setName(\"admin\");\n\n        SslSelectChannelConnector ssl_connector = new SslSelectChannelConnector();\n        String jetty_home = System.getProperty(\"jetty.home\",\"../jetty-distribution/target/distribution\");\n        System.setProperty(\"jetty.home\",jetty_home);\n        ssl_connector.setPort(8443);\n        ssl_connector.setKeystore(jetty_home + \"/etc/keystore\");\n        ssl_connector.setPassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        ssl_connector.setKeyPassword(\"OBF:1u2u1wml1z7s1z7a1wnl1u2g\");\n        ssl_connector.setTruststore(jetty_home + \"/etc/keystore\");\n        ssl_connector.setTrustPassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        server.addConnector(ssl_connector);\n\n        server.setConnectors(new Connector[]\n        { connector0, connector1, ssl_connector });\n\n        server.setHandler(new HelloHandler());\n\n        server.start();\n        server.join();\n    }","commit_id":"c0a92fa463688a392af494156c7c8ddee78a6c34","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server();\n        Connector connector=new SelectChannelConnector();\n        connector.setPort(8080);\n        server.setConnectors(new Connector[]{connector});\n        \n        ContextHandler context0 = new ContextHandler();\n        context0.setContextPath(\"/\");\n        Handler handler0=new HelloHandler(\"Root Context\");\n        context0.setHandler(handler0);\n\n        ContextHandler context1 = new ContextHandler();\n        context1.setContextPath(\"/context\");\n        Handler handler1=new HelloHandler(\"A Context\");\n        context1.setHandler(handler1);   \n\n        ContextHandler context2 = new ContextHandler();\n        context2.setContextPath(\"/context\");\n        context2.setVirtualHosts(new String[]{\"127.0.0.2\"});\n        Handler handler2=new HelloHandler(\"A Virtual Context\");\n        context2.setHandler(handler2);   \n        \n        ContextHandlerCollection contexts = new ContextHandlerCollection();\n        contexts.setHandlers(new Handler[]{context0,context1,context2});\n        \n        server.setHandler(contexts);\n        \n        server.start();\n        System.err.println(server.dump());\n        server.join();\n    }","id":32167,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        Server server = new Server();\n        Connector connector = new SelectChannelConnector();\n        connector.setPort(8080);\n        server.setConnectors(new Connector[]\n        { connector });\n\n        ContextHandler context0 = new ContextHandler();\n        context0.setContextPath(\"/\");\n        Handler handler0 = new HelloHandler(\"Root Context\",BODY);\n        context0.setHandler(handler0);\n\n        ContextHandler context1 = new ContextHandler();\n        context1.setContextPath(\"/context\");\n        Handler handler1 = new HelloHandler(\"A Context\",BODY);\n        context1.setHandler(handler1);\n\n        ContextHandler context2 = new ContextHandler();\n        context2.setContextPath(\"/context\");\n        context2.setVirtualHosts(new String[]\n        { \"127.0.0.2\" });\n        Handler handler2 = new HelloHandler(\"A Virtual Context\",BODY);\n        context2.setHandler(handler2);\n\n        ContextHandlerCollection contexts = new ContextHandlerCollection();\n        contexts.setHandlers(new Handler[]\n        { context0, context1, context2 });\n\n        server.setHandler(contexts);\n\n        server.start();\n        System.err.println(server.dump());\n        server.join();\n    }","commit_id":"c0a92fa463688a392af494156c7c8ddee78a6c34","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void doDirectory(HttpServletRequest request,HttpServletResponse response, Resource resource)\n        throws IOException\n    {\n        response.sendError(HttpStatus.FORBIDDEN_403);\n    }","id":32168,"modified_method":"protected void doDirectory(HttpServletRequest request,HttpServletResponse response, Resource resource)\n        throws IOException\n    {\n        if (_directory)\n        {\n            String listing = resource.getListHTML(request.getRequestURI(),request.getPathInfo().lastIndexOf(\"/\") > 0);\n            response.setContentType(\"text/html; charset=UTF-8\");\n            response.getWriter().println(listing);\n        }\n        else\n            response.sendError(HttpStatus.FORBIDDEN_403);\n    }","commit_id":"c0a92fa463688a392af494156c7c8ddee78a6c34","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void init()\n    {\n        if ( jetty == null )\n        {\n            jetty = new Server( jettyPort );\n            jetty.setThreadPool( new QueuedThreadPool( jettyMaxThreads ) );\n        }\n    }","id":32169,"modified_method":"@Override\n    public void init()\n    {\n        if ( jetty == null )\n        {\n            jetty = new Server();\n\t\t\tConnector connector = new SelectChannelConnector();\n\n\t\t\tconnector.setPort( jettyPort );\n\t\t\tconnector.setHost( jettyAddr );\n\t\t\tjetty.addConnector( connector );\n\n            jetty.setThreadPool( new QueuedThreadPool( jettyMaxThreads ) );\n        }\n    }","commit_id":"a495f46963d3111d60a49cdea46d2c1ca8ee82f5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void initWebServer()\n    {\n        int webServerPort = getWebServerPort();\n        int maxThreads = getMaxThreads();\n\n        log.info( \"Starting Neo Server on port [%s] with [%d] threads available\", webServerPort, maxThreads );\n        webServer.setPort( webServerPort );\n        webServer.setMaxThreads( maxThreads );\n        webServer.init();\n    }","id":32170,"modified_method":"private void initWebServer()\n    {\n        int webServerPort = getWebServerPort();\n\t\tString webServerAddr = getWebServerAddress();\n\n        int maxThreads = getMaxThreads();\n\n        log.info( \"Starting Neo Server on port [%s] with [%d] threads available\", webServerPort, maxThreads );\n        webServer.setPort( webServerPort );\n\t\twebServer.setAddress( webServerAddr );\n\n        webServer.setMaxThreads( maxThreads );\n        webServer.init();\n    }","commit_id":"a495f46963d3111d60a49cdea46d2c1ca8ee82f5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public URI baseUri()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"http\" );\n        int webServerPort = getWebServerPort();\n        if ( webServerPort == 443 )\n        {\n            sb.append( \"s\" );\n\n        }\n        sb.append( \"://\" );\n        sb.append( addressResolver.getHostname() );\n\n        if ( webServerPort != 80 )\n        {\n            sb.append( \":\" );\n            sb.append( webServerPort );\n        }\n        sb.append( \"/\" );\n\n        try\n        {\n            return new URI( sb.toString() );\n        }\n        catch ( URISyntaxException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":32171,"modified_method":"@Override\n    public URI baseUri()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"http\" );\n        int webServerPort = getWebServerPort();\n        if ( webServerPort == 443 )\n        {\n            sb.append( \"s\" );\n\n        }\n        sb.append( \"://\" );\n        //sb.append( addressResolver.getHostname() );\n\t\tsb.append( getWebServerAddress() );\n\n        if ( webServerPort != 80 )\n        {\n            sb.append( \":\" );\n            sb.append( webServerPort );\n        }\n        sb.append( \"/\" );\n\n        try\n        {\n            return new URI( sb.toString() );\n        }\n        catch ( URISyntaxException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"a495f46963d3111d60a49cdea46d2c1ca8ee82f5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void initializeClient() throws Exception\n    {\n        _client = new HttpClient();\n        _client.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);\n        _client.setThreadPool(new QueuedThreadPool());\n        _client.start();\n    }","id":32172,"modified_method":"private void initializeClient() throws Exception\n    {\n        _client = new HttpClient();\n        _client.setConnectorType(_connectorType);\n        \n        if ( _maxThreads != null )\n        {\n            _client.setThreadPool(new QueuedThreadPool(Integer.parseInt(_maxThreads)));\n        }\n        else\n        {\n            _client.setThreadPool(new QueuedThreadPool());\n        }\n        \n        if ( _maxConnections != null )\n        {\n            _client.setMaxConnectionsPerAddress(Integer.parseInt(_maxConnections));\n        }\n        \n        if ( _timeout != null )\n        {\n            _client.setTimeout(Long.parseLong(_timeout));\n        }\n        \n        if ( _idleTimeout != null )\n        {\n            _client.setIdleTimeout(Long.parseLong(_idleTimeout));\n        }\n        \n        if ( _requestBufferSize != null )\n        {\n            _client.setRequestBufferSize(Integer.parseInt(_requestBufferSize));\n        }\n        \n        if ( _requestHeaderSize != null )\n        {\n            _client.setRequestHeaderSize(Integer.parseInt(_requestHeaderSize));\n        }\n        \n        if ( _responseBufferSize != null )\n        {\n            _client.setResponseBufferSize(Integer.parseInt(_responseBufferSize));\n        }\n        \n        if ( _responseHeaderSize != null )\n        {\n            _client.setResponseHeaderSize(Integer.parseInt(_responseHeaderSize));\n        }                 \n        \n        _client.start();\n    }","commit_id":"7bc092bf8bcece75d8ec1c1bfef0c4032dc53898","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void computeFeatureCallHighlighting(XAbstractFeatureCall featureCall, IHighlightedPositionAcceptor acceptor) {\n\t\tJvmIdentifiableElement feature = featureCall.getFeature();\n\t\tif (feature != null && !feature.eIsProxy()) {\n\t\t\tif (feature instanceof JvmField) {\n\t\t\t\tif (((JvmField) feature).isStatic()) {\n\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.STATIC_FIELD);\n\t\t\t\t} else {\n\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.FIELD);\n\t\t\t\t}\n\t\t\t} else if (feature instanceof JvmOperation && !featureCall.isOperation()) {\n\t\t\t\tJvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\t\tif (jvmOperation.isStatic())\n\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.STATIC_METHOD_INVOCATION);\n\t\t\t}\n\t\t\tif(featureCall.isExtension()){\n\t\t\t\thighlightFeatureCall(featureCall, acceptor, \n\t\t\t\t\t\tXbaseHighlightingConfiguration.EXTENSION_METHOD_INVOCATION);\n\t\t\t} else {\n\t\t\t\t// Extensions without implicit first argument\n\t\t\t\tXExpression implicitReceiver = featureCall.getImplicitReceiver();\n\t\t\t\tif(implicitReceiver != null && implicitReceiver instanceof XAbstractFeatureCall){\n\t\t\t\t\t\tif(isExtension(((XAbstractFeatureCall) implicitReceiver).getFeature()))\n\t\t\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, \n\t\t\t\t\t\t\t\t\tXbaseHighlightingConfiguration.EXTENSION_METHOD_INVOCATION);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\tif(feature instanceof JvmAnnotationTarget && DeprecationUtil.isDeprecated((JvmAnnotationTarget)feature)){\n\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.DEPRECATED_MEMBERS);\n\t\t\t}\n\t\t}\n\t}","id":32173,"modified_method":"protected void computeFeatureCallHighlighting(XAbstractFeatureCall featureCall, IHighlightedPositionAcceptor acceptor) {\n\t\tJvmIdentifiableElement feature = featureCall.getFeature();\n\t\tif (feature != null && !feature.eIsProxy()) {\n\t\t\tif (feature instanceof JvmField) {\n\t\t\t\tif (((JvmField) feature).isStatic()) {\n\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.STATIC_FIELD);\n\t\t\t\t} else {\n\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.FIELD);\n\t\t\t\t}\n\t\t\t} else if (feature instanceof JvmOperation && !featureCall.isOperation()) {\n\t\t\t\tJvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\t\tif (jvmOperation.isStatic())\n\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.STATIC_METHOD_INVOCATION);\n\t\t\t}\n\n\t\t\tif(!(featureCall instanceof XBinaryOperation || featureCall instanceof XUnaryOperation) && featureCall.isExtension()){\n\t\t\t\thighlightFeatureCall(featureCall, acceptor, \n\t\t\t\t\t\tXbaseHighlightingConfiguration.EXTENSION_METHOD_INVOCATION);\n\t\t\t} else {\n\t\t\t\t// Extensions without implicit first argument\n\t\t\t\tXExpression implicitReceiver = featureCall.getImplicitReceiver();\n\t\t\t\tif(implicitReceiver != null && implicitReceiver instanceof XAbstractFeatureCall){\n\t\t\t\t\t\tif(isExtension(((XAbstractFeatureCall) implicitReceiver).getFeature()))\n\t\t\t\t\t\t\thighlightFeatureCall(featureCall, acceptor, \n\t\t\t\t\t\t\t\t\tXbaseHighlightingConfiguration.EXTENSION_METHOD_INVOCATION);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\tif(feature instanceof JvmAnnotationTarget && DeprecationUtil.isDeprecated((JvmAnnotationTarget)feature)){\n\t\t\t\thighlightFeatureCall(featureCall, acceptor, XbaseHighlightingConfiguration.DEPRECATED_MEMBERS);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cf6405557cddfced18c58d81b733c8c1830784a4","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void transform(XtendField source, JvmGenericType container) {\n\t\tif ((source.isExtension() && source.getType() != null) || source.getName() != null) {\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tfinal String computeFieldName = computeFieldName(source);\n\t\t\tfield.setSimpleName(computeFieldName);\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(source, field);\n\t\t\tfield.setVisibility(source.getVisibility());\n\t\t\tfield.setStatic(source.isStatic());\n\t\t\tfinal boolean isDataObject = hasAnnotation((XtendAnnotationTarget) source.eContainer(), Data.class);\n\t\t\tif (isDataObject) {\n\t\t\t\tfield.setFinal(true);\n\t\t\t} else {\n\t\t\t\tfield.setFinal(source.isFinal());\n\t\t\t}\n\t\t\tif (source.getType() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.cloneWithProxies(source.getType()));\n\t\t\t} else if (source.getInitialValue() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.inferredType(source.getInitialValue()));\n\t\t\t}\n\t\t\tboolean isProperty = isDataObject;\n\t\t\tfor (XAnnotation anno : source.getAnnotations()) {\n\t\t\t\tif (!annotationTranslationFilter.apply(anno))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (Property.class.getName().equals(anno.getAnnotationType().getIdentifier())) {\n\t\t\t\t\tisProperty = true;\n\t\t\t\t} else {\n\t\t\t\t\tJvmAnnotationReference annotationReference = jvmTypesBuilder.getJvmAnnotationReference(anno);\n\t\t\t\t\tif(annotationReference != null)\n\t\t\t\t\t\tfield.getAnnotations().add(annotationReference);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (source.isExtension()) {\n\t\t\t\tfield.getAnnotations().add(jvmTypesBuilder.toAnnotation(source, Extension.class));\n\t\t\t}\n\t\t\tif (isProperty && !field.isStatic()) {\n\t\t\t\tfield.setSimpleName(\"_\"+computeFieldName);\n\t\t\t\tfinal JvmOperation getter = jvmTypesBuilder.toGetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\ttypeExtensions.setSynthetic(getter, true);\n\t\t\t\tjvmTypesBuilder.setDocumentation(getter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\tif (getter != null && !hasMethod((XtendClass)source.eContainer(), getter.getSimpleName(), getter.getParameters()))\n\t\t\t\t\tcontainer.getMembers().add( getter);\n\t\t\t\tif (!source.isFinal() && ! isDataObject) {\n\t\t\t\t\tfinal JvmOperation setter = jvmTypesBuilder.toSetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\t\ttypeExtensions.setSynthetic(setter, true);\n\t\t\t\t\tjvmTypesBuilder.setDocumentation(setter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\t\tif (setter != null && !hasMethod((XtendClass)source.eContainer(), setter.getSimpleName(), setter.getParameters()))\n\t\t\t\t\t\tcontainer.getMembers().add( setter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tjvmTypesBuilder.setDocumentation(field, jvmTypesBuilder.getDocumentation(source));\n\t\t\tjvmTypesBuilder.setInitializer(field, source.getInitialValue());\n\t\t\t\n\t\t}\n\t}","id":32174,"modified_method":"protected void transform(XtendField source, JvmGenericType container) {\n\t\tif ((source.isExtension() && source.getType() != null) || source.getName() != null) {\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tfinal String computeFieldName = computeFieldName(source);\n\t\t\tfield.setSimpleName(computeFieldName);\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(source, field);\n\t\t\tfield.setVisibility(source.getVisibility());\n\t\t\tfield.setStatic(source.isStatic());\n\t\t\tfinal boolean isDataObject = hasAnnotation((XtendAnnotationTarget) source.eContainer(), Data.class);\n\t\t\tif (isDataObject) {\n\t\t\t\tfield.setFinal(true);\n\t\t\t} else {\n\t\t\t\tfield.setFinal(source.isFinal());\n\t\t\t}\n\t\t\tif (source.getType() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.cloneWithProxies(source.getType()));\n\t\t\t} else if (source.getInitialValue() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.inferredType(source.getInitialValue()));\n\t\t\t}\n\t\t\tboolean isProperty = isDataObject;\n\t\t\tfor (XAnnotation anno : source.getAnnotations()) {\n\t\t\t\tif (!annotationTranslationFilter.apply(anno))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (Property.class.getName().equals(anno.getAnnotationType().getIdentifier())) {\n\t\t\t\t\tisProperty = true;\n\t\t\t\t} else {\n\t\t\t\t\tJvmAnnotationReference annotationReference = jvmTypesBuilder.getJvmAnnotationReference(anno);\n\t\t\t\t\tif(annotationReference != null)\n\t\t\t\t\t\tfield.getAnnotations().add(annotationReference);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (source.isExtension() && typeReferences.findDeclaredType(Extension.class, source) != null) {\n\t\t\t\tfield.getAnnotations().add(jvmTypesBuilder.toAnnotation(source, Extension.class));\n\t\t\t}\n\t\t\tif (isProperty && !field.isStatic()) {\n\t\t\t\tfield.setSimpleName(\"_\"+computeFieldName);\n\t\t\t\tfinal JvmOperation getter = jvmTypesBuilder.toGetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\ttypeExtensions.setSynthetic(getter, true);\n\t\t\t\tjvmTypesBuilder.setDocumentation(getter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\tif (getter != null && !hasMethod((XtendClass)source.eContainer(), getter.getSimpleName(), getter.getParameters()))\n\t\t\t\t\tcontainer.getMembers().add( getter);\n\t\t\t\tif (!source.isFinal() && ! isDataObject) {\n\t\t\t\t\tfinal JvmOperation setter = jvmTypesBuilder.toSetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\t\ttypeExtensions.setSynthetic(setter, true);\n\t\t\t\t\tjvmTypesBuilder.setDocumentation(setter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\t\tif (setter != null && !hasMethod((XtendClass)source.eContainer(), setter.getSimpleName(), setter.getParameters()))\n\t\t\t\t\t\tcontainer.getMembers().add( setter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tjvmTypesBuilder.setDocumentation(field, jvmTypesBuilder.getDocumentation(source));\n\t\t\tjvmTypesBuilder.setInitializer(field, source.getInitialValue());\n\t\t\t\n\t\t}\n\t}","commit_id":"9e8b14a8b1f32507e03770cdb62b77ca1c8fe026","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void transform(XtendField source, JvmGenericType container) {\n\t\tif (source.isExtension() || source.getName() != null) {\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tfinal String computeFieldName = computeFieldName(source);\n\t\t\tfield.setSimpleName(computeFieldName);\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(source, field);\n\t\t\tfield.setVisibility(source.getVisibility());\n\t\t\tfield.setStatic(source.isStatic());\n\t\t\tfinal boolean isDataObject = hasAnnotation((XtendAnnotationTarget) source.eContainer(), Data.class);\n\t\t\tif (isDataObject) {\n\t\t\t\tfield.setFinal(true);\n\t\t\t} else {\n\t\t\t\tfield.setFinal(source.isFinal());\n\t\t\t}\n\t\t\tif (source.getType() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.cloneWithProxies(source.getType()));\n\t\t\t} else if (source.getInitialValue() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.inferredNonVoidType());\n\t\t\t}\n\t\t\tboolean isProperty = isDataObject;\n\t\t\tfor (XAnnotation anno : source.getAnnotations()) {\n\t\t\t\tif (!annotationTranslationFilter.apply(anno))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (Property.class.getName().equals(anno.getAnnotationType().getIdentifier())) {\n\t\t\t\t\tisProperty = true;\n\t\t\t\t} else {\n\t\t\t\t\tJvmAnnotationReference annotationReference = jvmTypesBuilder.getJvmAnnotationReference(anno);\n\t\t\t\t\tif(annotationReference != null)\n\t\t\t\t\t\tfield.getAnnotations().add(annotationReference);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isProperty && !field.isStatic()) {\n\t\t\t\tfield.setSimpleName(\"_\"+computeFieldName);\n\t\t\t\tfinal JvmOperation getter = jvmTypesBuilder.toGetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\ttypeExtensions.setSynthetic(getter, true);\n\t\t\t\tjvmTypesBuilder.setDocumentation(getter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\tif (getter != null && !hasMethod((XtendClass)source.eContainer(), getter.getSimpleName(), getter.getParameters()))\n\t\t\t\t\tcontainer.getMembers().add( getter);\n\t\t\t\tif (!source.isFinal() && ! isDataObject) {\n\t\t\t\t\tfinal JvmOperation setter = jvmTypesBuilder.toSetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\t\ttypeExtensions.setSynthetic(setter, true);\n\t\t\t\t\tjvmTypesBuilder.setDocumentation(setter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\t\tif (setter != null && !hasMethod((XtendClass)source.eContainer(), setter.getSimpleName(), setter.getParameters()))\n\t\t\t\t\t\tcontainer.getMembers().add( setter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tjvmTypesBuilder.setDocumentation(field, jvmTypesBuilder.getDocumentation(source));\n\t\t\tjvmTypesBuilder.setInitializer(field, source.getInitialValue());\n\t\t\t\n\t\t}\n\t}","id":32175,"modified_method":"protected void transform(XtendField source, JvmGenericType container) {\n\t\tif ((source.isExtension() && source.getType() != null) || source.getName() != null) {\n\t\t\tJvmField field = typesFactory.createJvmField();\n\t\t\tfinal String computeFieldName = computeFieldName(source);\n\t\t\tfield.setSimpleName(computeFieldName);\n\t\t\tcontainer.getMembers().add(field);\n\t\t\tassociator.associatePrimary(source, field);\n\t\t\tfield.setVisibility(source.getVisibility());\n\t\t\tfield.setStatic(source.isStatic());\n\t\t\tfinal boolean isDataObject = hasAnnotation((XtendAnnotationTarget) source.eContainer(), Data.class);\n\t\t\tif (isDataObject) {\n\t\t\t\tfield.setFinal(true);\n\t\t\t} else {\n\t\t\t\tfield.setFinal(source.isFinal());\n\t\t\t}\n\t\t\tif (source.getType() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.cloneWithProxies(source.getType()));\n\t\t\t} else if (source.getInitialValue() != null) {\n\t\t\t\tfield.setType(jvmTypesBuilder.inferredNonVoidType());\n\t\t\t}\n\t\t\tboolean isProperty = isDataObject;\n\t\t\tfor (XAnnotation anno : source.getAnnotations()) {\n\t\t\t\tif (!annotationTranslationFilter.apply(anno))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (Property.class.getName().equals(anno.getAnnotationType().getIdentifier())) {\n\t\t\t\t\tisProperty = true;\n\t\t\t\t} else {\n\t\t\t\t\tJvmAnnotationReference annotationReference = jvmTypesBuilder.getJvmAnnotationReference(anno);\n\t\t\t\t\tif(annotationReference != null)\n\t\t\t\t\t\tfield.getAnnotations().add(annotationReference);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isProperty && !field.isStatic()) {\n\t\t\t\tfield.setSimpleName(\"_\"+computeFieldName);\n\t\t\t\tfinal JvmOperation getter = jvmTypesBuilder.toGetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\ttypeExtensions.setSynthetic(getter, true);\n\t\t\t\tjvmTypesBuilder.setDocumentation(getter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\tif (getter != null && !hasMethod((XtendClass)source.eContainer(), getter.getSimpleName(), getter.getParameters()))\n\t\t\t\t\tcontainer.getMembers().add( getter);\n\t\t\t\tif (!source.isFinal() && ! isDataObject) {\n\t\t\t\t\tfinal JvmOperation setter = jvmTypesBuilder.toSetter(source, computeFieldName, field.getSimpleName(), field.getType());\n\t\t\t\t\ttypeExtensions.setSynthetic(setter, true);\n\t\t\t\t\tjvmTypesBuilder.setDocumentation(setter, jvmTypesBuilder.getDocumentation(source));\n\t\t\t\t\tif (setter != null && !hasMethod((XtendClass)source.eContainer(), setter.getSimpleName(), setter.getParameters()))\n\t\t\t\t\t\tcontainer.getMembers().add( setter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tjvmTypesBuilder.setDocumentation(field, jvmTypesBuilder.getDocumentation(source));\n\t\t\tjvmTypesBuilder.setInitializer(field, source.getInitialValue());\n\t\t\t\n\t\t}\n\t}","commit_id":"83d348a361642c7bb746ddca934f599f3043029b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public Comparable weigh(@NotNull LookupElement element, @NotNull CompletionLocation location) {\n    Object o = element.getObject();\n    if (o instanceof ResolveResult) {\n      o = ((ResolveResult)o).getElement();\n    }\n\n    final PsiElement position = location.getCompletionParameters().getPosition();\n    if (!(position.getContainingFile() instanceof GroovyFileBase)) {\n      return null;\n    }\n\n    if (!(position.getParent() instanceof GrReferenceElement)) {\n      if (o instanceof PsiClass || o instanceof PsiPackage) return 0;\n      return 1;\n    }\n\n    final GrReferenceElement parent = (GrReferenceElement)position.getParent();\n\n    if (parent.getQualifier() == null) {\n      if (o instanceof GrVariable && !(o instanceof GrField)) return NotQualifiedKind.aLocal;\n      if (o instanceof PsiClass) return NotQualifiedKind.aClass;\n      if (o instanceof PsiPackage) return NotQualifiedKind.aPackage;\n      if (isLightElement(o)) return NotQualifiedKind.anImplicitGroovyMethod;\n      if (o instanceof PsiMember) return NotQualifiedKind.aMember;\n      if (o instanceof String) return NotQualifiedKind.aString;\n    }\n    else {\n      if (o instanceof PsiClass) return QualifiedKind.aClass;\n      if (o instanceof PsiPackage) return QualifiedKind.aPackage;\n      if (isLightElement(o)) {\n        return QualifiedKind.anImplicitGroovyMethod;\n      }\n      if (o instanceof GrEnumConstant || o instanceof PsiEnumConstant) return QualifiedKind.anEnumConstant;\n      if (o instanceof PsiMember) {\n        final PsiClass containingClass = ((PsiMember)o).getContainingClass();\n        if (containingClass != null) {\n          if (TRASH_CLASSES.contains(containingClass.getQualifiedName())) {\n            return QualifiedKind.aTrashMethod;\n          }\n        }\n        return QualifiedKind.aMember;\n      }\n      if (o instanceof String) return QualifiedKind.aString;\n    }\n    return null;\n  }","id":32176,"modified_method":"@Override\n  public Comparable weigh(@NotNull LookupElement element, @NotNull CompletionLocation location) {\n    Object o = element.getObject();\n    if (o instanceof ResolveResult) {\n      o = ((ResolveResult)o).getElement();\n    }\n\n    final PsiElement position = location.getCompletionParameters().getPosition();\n    if (!(position.getContainingFile() instanceof GroovyFileBase)) {\n      return null;\n    }\n\n    if (!(position.getParent() instanceof GrReferenceElement)) {\n      if (o instanceof PsiClass || o instanceof PsiPackage) return 0;\n      return 1;\n    }\n\n    final GrReferenceElement parent = (GrReferenceElement)position.getParent();\n\n    if (parent.getQualifier() == null) {\n      if (o instanceof GrVariable && !(o instanceof GrField)) return NotQualifiedKind.aLocal;\n      if (o instanceof PsiClass) return NotQualifiedKind.aClass;\n      if (o instanceof PsiPackage) return NotQualifiedKind.aPackage;\n      if (isLightElement(o)) return NotQualifiedKind.anImplicitGroovyMethod;\n      if (o instanceof PsiMember) return NotQualifiedKind.aMember;\n      if (o instanceof String) {\n        if (\"for\".equals(o)) return NotQualifiedKind.aKeyword;\n\n        return NotQualifiedKind.aString;\n      }\n    }\n    else {\n      if (o instanceof PsiClass) return QualifiedKind.aClass;\n      if (o instanceof PsiPackage) return QualifiedKind.aPackage;\n      if (isLightElement(o)) {\n        return QualifiedKind.anImplicitGroovyMethod;\n      }\n      if (o instanceof GrEnumConstant || o instanceof PsiEnumConstant) return QualifiedKind.anEnumConstant;\n      if (o instanceof PsiMember) {\n        final PsiClass containingClass = ((PsiMember)o).getContainingClass();\n        if (containingClass != null) {\n          if (TRASH_CLASSES.contains(containingClass.getQualifiedName())) {\n            return QualifiedKind.aTrashMethod;\n          }\n        }\n        return QualifiedKind.aMember;\n      }\n      if (o instanceof String) return QualifiedKind.aString;\n    }\n    return null;\n  }","commit_id":"b6ebb8543acc0219948469227db8defa44feea8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static LookupElementBuilder setTypeText(PsiElement element, LookupElementBuilder builder, PsiSubstitutor substitutor) {\n    if (element instanceof PsiVariable) {\n      builder = builder.setTypeText(substitutor.substitute(((PsiVariable)element).getType()).getPresentableText());\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiType type = substitutor.substitute(((PsiMethod)element).getReturnType());\n      if (type != null) {\n        builder = builder.setTypeText(type.getPresentableText());\n      }\n    }\n    return builder;\n  }","id":32177,"modified_method":"private static LookupElementBuilder setTypeText(PsiElement element, LookupElementBuilder builder, PsiSubstitutor substitutor) {\n    PsiType type = null;\n    if (element instanceof GrVariable) {\n      type = ((GrVariable)element).getTypeGroovy();\n    }\n    else if (element instanceof PsiVariable) {\n      type = ((PsiVariable)element).getType();\n    }\n    else if (element instanceof PsiMethod) {\n      type = substitutor.substitute(((PsiMethod)element).getReturnType());\n    }\n    return type != null ? builder.setTypeText(type.getPresentableText()) : builder;\n  }","commit_id":"b6ebb8543acc0219948469227db8defa44feea8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Color getTailTextColor(boolean isSelected, LookupElementPresentation presentation, Color defaultForeground) {\n    if (presentation.isTailGrayed()) {\n      return isSelected ? SELECTED_GRAYED_FOREGROUND_COLOR : GRAYED_FOREGROUND_COLOR;\n    }\n\n    final Color tailForeground = presentation.getTailForeground();\n    if (tailForeground != null) {\n      return tailForeground;\n    }\n\n    return defaultForeground;\n  }","id":32178,"modified_method":"private static Color getTailTextColor(boolean isSelected, LookupElementPresentation presentation, Color defaultForeground) {\n    if (presentation.isTailGrayed()) {\n      return getGrayedForeground(isSelected);\n    }\n\n    final Color tailForeground = presentation.getTailForeground();\n    if (tailForeground != null) {\n      return tailForeground;\n    }\n\n    return defaultForeground;\n  }","commit_id":"a200eeb5f04f64457b6fcb6d0bdcd53696abcbd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int setTypeTextLabel(LookupElement item, final Color background, Color foreground, final LookupElementPresentation presentation, int allowedWidth) {\n    final String givenText = presentation.getTypeText();\n    final String labelText = trimLabelText(StringUtil.isEmpty(givenText) ? \"\" : \"   \" + givenText, allowedWidth, myNormalMetrics);\n\n    int used = RealLookupElementPresentation.getStringWidth(labelText, myNormalMetrics);\n\n    final Icon icon = presentation.getTypeIcon();\n    if (icon != null) {\n      myTypeLabel.setIcon(icon);\n      used += icon.getIconWidth();\n    }\n\n    Color sampleBackground = background;\n\n    Object o = item.getObject();\n    if (o instanceof LookupValueWithUIHint && StringUtil.isEmpty(labelText)) {\n      Color proposedBackground = ((LookupValueWithUIHint)o).getColorHint();\n      if (proposedBackground != null) {\n        sampleBackground = proposedBackground;\n      }\n      myTypeLabel.append(\"  \");\n      used += myNormalMetrics.stringWidth(\"WW\");\n    } else {\n      myTypeLabel.append(labelText);\n    }\n\n    myTypeLabel.setBackground(sampleBackground);\n    myTypeLabel.setForeground(item instanceof EmptyLookupItem ? EMPTY_ITEM_FOREGROUND_COLOR : foreground);\n    return used;\n  }","id":32179,"modified_method":"private int setTypeTextLabel(LookupElement item,\n                               final Color background,\n                               Color foreground,\n                               final LookupElementPresentation presentation,\n                               int allowedWidth,\n                               boolean selected) {\n    final String givenText = presentation.getTypeText();\n    final String labelText = trimLabelText(StringUtil.isEmpty(givenText) ? \"\" : \"   \" + givenText, allowedWidth, myNormalMetrics);\n\n    int used = RealLookupElementPresentation.getStringWidth(labelText, myNormalMetrics);\n\n    final Icon icon = presentation.getTypeIcon();\n    if (icon != null) {\n      myTypeLabel.setIcon(icon);\n      used += icon.getIconWidth();\n    }\n\n    Color sampleBackground = background;\n\n    Object o = item.getObject();\n    if (o instanceof LookupValueWithUIHint && StringUtil.isEmpty(labelText)) {\n      Color proposedBackground = ((LookupValueWithUIHint)o).getColorHint();\n      if (proposedBackground != null) {\n        sampleBackground = proposedBackground;\n      }\n      myTypeLabel.append(\"  \");\n      used += myNormalMetrics.stringWidth(\"WW\");\n    } else {\n      myTypeLabel.append(labelText);\n    }\n\n    myTypeLabel.setBackground(sampleBackground);\n    myTypeLabel.setForeground(presentation.isTypeGrayed() ? getGrayedForeground(selected) : item instanceof EmptyLookupItem ? EMPTY_ITEM_FOREGROUND_COLOR : foreground);\n    return used;\n  }","commit_id":"a200eeb5f04f64457b6fcb6d0bdcd53696abcbd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getListCellRendererComponent(\n      final JList list,\n      Object value,\n      int index,\n      boolean isSelected,\n      boolean hasFocus) {\n\n\n    if (isSelected && !myLookup.isFocused() && myLookup.isCompletion()) {\n      myPanel.setBorder(new DottedBorder(Color.gray));\n      isSelected = false;\n    } else {\n      myPanel.setBorder(null);\n    }\n\n    final LookupElement item = (LookupElement)value;\n    final Color foreground = isSelected ? SELECTED_FOREGROUND_COLOR : FOREGROUND_COLOR;\n    final Color background = getItemBackground(list, index, isSelected);\n\n    int allowedWidth = list.getFixedCellWidth() - getCommonIconWidth();\n    final LookupElementPresentation presentation = new RealLookupElementPresentation(allowedWidth, myNormalMetrics, myBoldMetrics);\n    item.renderElement(presentation);\n\n    myNameComponent.clear();\n    myNameComponent.setIcon(getIcon(presentation.getIcon()));\n    myNameComponent.setBackground(background);\n    allowedWidth -= setItemTextLabel(item, foreground, isSelected, presentation, allowedWidth);\n\n    myTypeLabel.clear();\n    if (allowedWidth > 0) {\n      allowedWidth -= setTypeTextLabel(item, background, foreground, presentation, allowedWidth);\n    }\n\n    myTailComponent.clear();\n    myTailComponent.setBackground(background);\n    if (allowedWidth >= 0) {\n      setTailTextLabel(isSelected, presentation, foreground, allowedWidth);\n    }\n\n    myArrowLabel.setIcon(myLookup.getActionsFor(item).isEmpty() ? PopupIcons.EMPTY_ICON : PopupIcons.HAS_NEXT_ICON_GRAYED);\n    myArrowLabel.setBackground(background);\n    myArrowLabel.setForeground(foreground);\n\n    return myPanel;\n  }","id":32180,"modified_method":"public Component getListCellRendererComponent(\n      final JList list,\n      Object value,\n      int index,\n      boolean isSelected,\n      boolean hasFocus) {\n\n\n    if (isSelected && !myLookup.isFocused() && myLookup.isCompletion()) {\n      myPanel.setBorder(new DottedBorder(Color.gray));\n      isSelected = false;\n    } else {\n      myPanel.setBorder(null);\n    }\n\n    final LookupElement item = (LookupElement)value;\n    final Color foreground = isSelected ? SELECTED_FOREGROUND_COLOR : FOREGROUND_COLOR;\n    final Color background = getItemBackground(list, index, isSelected);\n\n    int allowedWidth = list.getFixedCellWidth() - getCommonIconWidth();\n    final LookupElementPresentation presentation = new RealLookupElementPresentation(allowedWidth, myNormalMetrics, myBoldMetrics);\n    item.renderElement(presentation);\n\n    myNameComponent.clear();\n    myNameComponent.setIcon(getIcon(presentation.getIcon()));\n    myNameComponent.setBackground(background);\n    allowedWidth -= setItemTextLabel(item, foreground, isSelected, presentation, allowedWidth);\n\n    myTypeLabel.clear();\n    if (allowedWidth > 0) {\n      allowedWidth -= setTypeTextLabel(item, background, foreground, presentation, allowedWidth, isSelected);\n    }\n\n    myTailComponent.clear();\n    myTailComponent.setBackground(background);\n    if (allowedWidth >= 0) {\n      setTailTextLabel(isSelected, presentation, foreground, allowedWidth);\n    }\n\n    myArrowLabel.setIcon(myLookup.getActionsFor(item).isEmpty() ? PopupIcons.EMPTY_ICON : PopupIcons.HAS_NEXT_ICON_GRAYED);\n    myArrowLabel.setBackground(background);\n    myArrowLabel.setForeground(foreground);\n\n    return myPanel;\n  }","commit_id":"a200eeb5f04f64457b6fcb6d0bdcd53696abcbd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LookupElementBuilder setTypeText(@Nullable String typeText) {\n    final LookupElementPresentation presentation = copyPresentation();\n    presentation.setTypeText(typeText);\n    return new LookupElementBuilder(myLookupString, myObject, myInsertHandler, null, presentation,\n                                    myAllLookupStrings, myCaseSensitive);\n  }","id":32181,"modified_method":"public LookupElementBuilder setTypeText(@Nullable String typeText) {\n    return setTypeText(typeText, false);\n  }","commit_id":"a200eeb5f04f64457b6fcb6d0bdcd53696abcbd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static LookupElementBuilder createPropertyLookupElement(@NotNull String name, @NotNull PsiType type) {\n    return LookupElementBuilder.create(name).setIcon(GroovyIcons.PROPERTY).setTypeText(type.getPresentableText());\n  }","id":32182,"modified_method":"@NotNull\n  public static LookupElementBuilder createPropertyLookupElement(@NotNull String name, @Nullable PsiType type) {\n    LookupElementBuilder res = LookupElementBuilder.create(name).setIcon(GroovyIcons.PROPERTY);\n    if (type != null) {\n      res = res.setTypeText(type.getPresentableText());\n    }\n    return res;\n  }","commit_id":"db9e26a218fbb09f47638a00f87309b47fd984c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Gets the used locale.\n     * @return the used locale.\n     */\n    public final Locale getLocale()\n    {\n        return locale;\n    }","id":32183,"modified_method":"/**\n     * @return Locale\n     */\n    public final Locale getLocale()\n    {\n    \tif (converter != null)\n        {\n    \t\treturn converter.getLocale();\n        }\n        if (typeConverter != null)\n        {\n        \treturn typeConverter.getLocale();\n        }\n        return null;\n    }","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.util.convert.ILocalizable#setLocale(java.util.Locale)\n\t */\n\tpublic void setLocale(Locale locale)\n\t{\n\t\tthis.locale = locale;\n\t}","id":32184,"modified_method":"/**\n\t * @see wicket.util.convert.ILocalizable#setLocale(java.util.Locale)\n\t */\n\tpublic void setLocale(Locale locale)\n\t{\n\t\tthis.locale = locale;\n\n\t\t// Set locale on each string type converter\n\t\tfor (final Iterator iterator = classToConverter.values().iterator(); iterator.hasNext();)\n\t\t{\n\t\t\t((ITypeConverter)iterator.next()).setLocale(locale);\n\t\t}\n\n\t\t// Set locale on default converter\n\t\tdefaultConverter.setLocale(locale);\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Converts the given value to class c.\n\t * \n\t * @param value\n\t *            The value to convert\n\t * @param c\n\t *            The class to convert to\n\t * @return The converted value\n\t * \n\t * @see wicket.util.convert.IConverter#convert(java.lang.Object,\n\t *      java.lang.Class)\n\t */\n\tpublic Object convert(Object value, Class c)\n\t{\n\t\t// Null is always converted to null\n\t\tif (value == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t// Class cannot be null\n\t\tif (c == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Class cannot be null\");\n\t\t}\n\n\t\t// Catch all cases where value is already the right type\n\t\tif (c.isAssignableFrom(value.getClass()))\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\t// Get type converter for class\n\t\tfinal ITypeConverter converter = get(c);\n\t\tif (converter == null)\n\t\t{\n\t\t\tdefaultConverter.setLocale(locale);\n\t\t\treturn defaultConverter.convert(value, c);\n\t\t}\n\n\t\t// Set locale\n\t\tconverter.setLocale(locale);\n\n\t\ttry\n\t\t{\n\t\t\t// Use type converter to convert to value\n\t\t\treturn converter.convert(value);\n\t\t}\n\t\tcatch (ConversionException e)\n\t\t{\n\t\t\tthrow e.setConverter(this).setTypeConverter(converter).setLocale(locale).setTargetType(\n\t\t\t\t\tc).setSourceValue(value);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new ConversionException(e).setConverter(this).setLocale(locale).setTargetType(c)\n\t\t\t\t\t.setSourceValue(value);\n\t\t}\n\t}","id":32185,"modified_method":"/**\n\t * Converts the given value to class c.\n\t * \n\t * @param value\n\t *            The value to convert\n\t * @param c\n\t *            The class to convert to\n\t * @return The converted value\n\t * \n\t * @see wicket.util.convert.IConverter#convert(java.lang.Object,\n\t *      java.lang.Class)\n\t */\n\tpublic Object convert(Object value, Class c)\n\t{\n\t\t// Null is always converted to null\n\t\tif (value == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t// Class cannot be null\n\t\tif (c == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Class cannot be null\");\n\t\t}\n\n\t\t// Catch all cases where value is already the right type\n\t\tif (c.isAssignableFrom(value.getClass()))\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\t// Get type converter for class\n\t\tfinal ITypeConverter converter = get(c);\n\t\tif (converter == null)\n\t\t{\n\t\t\treturn defaultConverter.convert(value, c);\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// Use type converter to convert to value\n\t\t\treturn converter.convert(value);\n\t\t}\n\t\tcatch (ConversionException e)\n\t\t{\n\t\t\tthrow e.setConverter(this).setTypeConverter(converter).setTargetType(c).setSourceValue(\n\t\t\t\t\tvalue);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new ConversionException(e).setConverter(this).setTargetType(c).setSourceValue(\n\t\t\t\t\tvalue);\n\t\t}\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.util.convert.IConverterFactory#newConverter()\n\t */\n\tpublic IConverter newConverter()\n\t{\n\t\tConverter converter = new Converter();\n\t\tconverter.set(Boolean.TYPE, new BooleanConverter());\n\t\tconverter.set(Boolean.class, new BooleanConverter());\n\t\tconverter.set(Byte.TYPE, new ByteConverter());\n\t\tconverter.set(Byte.class, new ByteConverter());\n\t\tconverter.set(Character.TYPE, new CharacterConverter());\n\t\tconverter.set(Character.class, new CharacterConverter());\n\t\tconverter.set(Double.TYPE, new DoubleConverter());\n\t\tconverter.set(Double.class, new DoubleConverter());\n\t\tconverter.set(Float.TYPE, new FloatConverter());\n\t\tconverter.set(Float.class, new FloatConverter());\n\t\tconverter.set(Integer.TYPE, new IntegerConverter());\n\t\tconverter.set(Integer.class, new IntegerConverter());\n\t\tconverter.set(Long.TYPE, new LongConverter());\n\t\tconverter.set(Long.class, new LongConverter());\n\t\tconverter.set(Short.TYPE, new ShortConverter());\n\t\tconverter.set(Short.class, new ShortConverter());\n\t\tconverter.set(String.class, new StringConverter());\n        converter.set(Date.class, new DateConverter());\n\t\treturn converter;\n\t}","id":32186,"modified_method":"/**\n\t * @see wicket.util.convert.IConverterFactory#newConverter(Locale)\n\t */\n\tpublic IConverter newConverter(final Locale locale)\n\t{\n\t\treturn new Converter(locale);\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"public void testConversion()\n\t{\n        final IConverter converter = new ConverterFactory().newConverter();\n        converter.setLocale(Locale.US);   \n        assertEquals(new Long(7), converter.convert(new Integer(7), Long.class));\n        assertEquals(\"7\", converter.convert(new Integer(7), String.class));\n        assertEquals(\"7.1\", converter.convert(new Double(7.1), String.class));\n        \n        // TODO someone could add a whole lot more tests here, including DUTCH_LOCALE tests - JL\n\t}","id":32187,"modified_method":"public void testConversion()\n\t{\n        final IConverter converter = new ConverterFactory().newConverter(Locale.US);\n        assertEquals(new Long(7), converter.convert(new Integer(7), Long.class));\n        assertEquals(\"7\", converter.convert(new Integer(7), String.class));\n        assertEquals(\"7.1\", converter.convert(new Double(7.1), String.class));\n        \n        // TODO someone could add a whole lot more tests here, including DUTCH_LOCALE tests - JL\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the converter instance.\n\t * \n\t * @return the converter\n\t */\n\tpublic final IConverter getConverter()\n\t{\n\t\tif (converter == null)\n\t\t{\n\t\t\t// Get the converter factory, possibly overriden by the client\n\t\t\tIConverterFactory converterFactory = getApplication().getConverterFactory();\n\n\t\t\t// Let the factory create a new converter\n\t\t\tconverter = converterFactory.newConverter();\n\t\t\tconverter.setLocale(locale);\n\t\t}\n\t\treturn converter;\n\t}","id":32188,"modified_method":"/**\n\t * Gets the converter instance.\n\t * \n\t * @return the converter\n\t */\n\tpublic final IConverter getConverter()\n\t{\n\t\tif (converter == null)\n\t\t{\n\t\t\t// Let the factory create a new converter\n\t\t\tconverter = getApplication().getConverterFactory().newConverter(locale);\n\t\t}\n\t\treturn converter;\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Set the locale.\n\t * \n\t * @param locale\n\t *            New locale\n\t */\n\tpublic final void setLocale(final Locale locale)\n\t{\n\t\tthis.locale = locale;\n\n        // Set the new locale on the converter instance\n\t\tgetConverter().setLocale(locale);\n\t}","id":32189,"modified_method":"/**\n\t * Set the locale.\n\t * \n\t * @param locale\n\t *            New locale\n\t */\n\tpublic final void setLocale(final Locale locale)\n\t{\n\t\tthis.locale = locale;\n        this.converter = null;\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param locale\n\t *            The locale for this converter\n\t */\n\tpublic StringConverter(final Locale locale)\n\t{\n\t\tsuper(locale);\n\t}","id":32190,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param locale\n\t *            The locale for this converter\n\t */\n\tpublic StringConverter(final Locale locale)\n\t{\n\t\tsetLocale(locale);\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.util.convert.ITypeConverter#convert(java.lang.Object)\n\t */\n\tpublic Object convert(final Object value)\n\t{\n\t\t// Null is always converted to null\n\t\tif (value == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t// Catch all cases where value is already the right type\n\t\tif (value instanceof String)\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\t// Get string converter for value's class\n\t\tfinal Class c = value.getClass();\n\t\tITypeConverter converter = get(c);\n\t\tif (converter == null)\n\t\t{\n\t\t\tdefaultConverter.setLocale(getLocale());\n\t\t\treturn defaultConverter.convert(value);\n\t\t}\n\n\t\t// Set locale\n\t\tconverter.setLocale(getLocale());\n\n\t\ttry\n\t\t{\n\t\t\t// Use type converter to convert to value\n\t\t\treturn converter.convert(value);\n\t\t}\n\t\tcatch (ConversionException e)\n\t\t{\n\t\t\tthrow e.setTypeConverter(this).setLocale(getLocale()).setTargetType(c).setSourceValue(\n\t\t\t\t\tvalue);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new ConversionException(e).setTypeConverter(this).setLocale(getLocale())\n\t\t\t\t\t.setTargetType(c).setSourceValue(value);\n\t\t}\n\t}","id":32191,"modified_method":"/**\n\t * @see wicket.util.convert.ITypeConverter#convert(java.lang.Object)\n\t */\n\tpublic Object convert(final Object value)\n\t{\n\t\t// Null is always converted to null\n\t\tif (value == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t// Catch all cases where value is already the right type\n\t\tif (value instanceof String)\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\t// Get string converter for value's class\n\t\tfinal Class c = value.getClass();\n\t\tITypeConverter converter = get(c);\n\t\tif (converter == null)\n\t\t{\n\t\t\treturn defaultConverter.convert(value);\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// Use type converter to convert to value\n\t\t\treturn converter.convert(value);\n\t\t}\n\t\tcatch (ConversionException e)\n\t\t{\n\t\t\tthrow e.setTypeConverter(this).setTargetType(c).setSourceValue(value);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new ConversionException(e).setTypeConverter(this).setTargetType(c)\n\t\t\t\t\t.setSourceValue(value);\n\t\t}\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Validates input by trying it to convert to the given type using the\n\t * {@link wicket.util.convert.IConverter}instance of the component doing\n\t * the validation.\n\t * \n\t * @param component\n\t *            The component that wants to validate its input\n\t * @see wicket.markup.html.form.validation.IValidator#validate(wicket.markup.html.form.FormComponent)\n\t */\n\tpublic final void validate(final FormComponent component)\n\t{\n\t\t// Get component value\n\t\tfinal String value = component.getRequestString();\n\n\t\t// If value is non-empty\n\t\tif (!Strings.isEmpty(value))\n\t\t{\n\t\t\t// Check value by attempting to convert it using the given locale\n\t\t\tfinal IConverter converter = component.getConverter();\n\t\t\tconverter.setLocale(getLocale());\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconverter.convert(value, type);\n\t\t\t}\n\t\t\tcatch (ConversionException e)\n\t\t\t{\n\t\t\t\tconversionError(value, component, e);\n\t\t\t}\n\t\t}\n\t}","id":32192,"modified_method":"/**\n\t * Validates input by trying it to convert to the given type using the\n\t * {@link wicket.util.convert.IConverter}instance of the component doing\n\t * the validation.\n\t * \n\t * @param component\n\t *            The component that wants to validate its input\n\t * @see wicket.markup.html.form.validation.IValidator#validate(wicket.markup.html.form.FormComponent)\n\t */\n\tpublic final void validate(final FormComponent component)\n\t{\n\t\t// Get component value\n\t\tfinal String value = component.getRequestString();\n\n\t\t// If value is non-empty\n\t\tif (!Strings.isEmpty(value))\n\t\t{\n\t\t\t// Check value by attempting to convert it\n\t\t\tfinal IConverter converter = component.getConverter();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconverter.convert(value, type);\n\t\t\t}\n\t\t\tcatch (ConversionException e)\n\t\t\t{\n\t\t\t\tconversionError(value, component, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"fb8487651be66365f77f20f240eb41b67b1b5f60","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n  public void setup() {\n    bind(YarnJacksonJaxbJsonProvider.class);\n    bind(AHSWebServices.class);\n    bind(TimelineWebServices.class);\n    bind(GenericExceptionHandler.class);\n    bind(ApplicationBaseProtocol.class).toInstance(historyClientService);\n    bind(TimelineDataManager.class).toInstance(timelineDataManager);\n    route(\"/\", AHSController.class);\n    route(pajoin(\"/apps\", APP_STATE), AHSController.class);\n    route(pajoin(\"/app\", APPLICATION_ID), AHSController.class, \"app\");\n    route(pajoin(\"/appattempt\", APPLICATION_ATTEMPT_ID), AHSController.class,\n      \"appattempt\");\n    route(pajoin(\"/container\", CONTAINER_ID), AHSController.class, \"container\");\n    route(\n      pajoin(\"/logs\", NM_NODENAME, CONTAINER_ID, ENTITY_STRING, APP_OWNER,\n        CONTAINER_LOG_TYPE), AHSController.class, \"logs\");\n    route(\"/errors-and-warnings\", AHSController.class, \"errorsAndWarnings\");\n  }","id":32193,"modified_method":"@Override\n  public void setup() {\n    bind(YarnJacksonJaxbJsonProvider.class);\n    bind(AHSWebServices.class);\n    bind(TimelineWebServices.class);\n    bind(GenericExceptionHandler.class);\n    bind(ApplicationBaseProtocol.class).toInstance(historyClientService);\n    bind(TimelineDataManager.class).toInstance(timelineDataManager);\n    route(\"/\", AHSController.class);\n    route(\"/about\", AHSController.class, \"about\");\n    route(pajoin(\"/apps\", APP_STATE), AHSController.class);\n    route(pajoin(\"/app\", APPLICATION_ID), AHSController.class, \"app\");\n    route(pajoin(\"/appattempt\", APPLICATION_ATTEMPT_ID), AHSController.class,\n      \"appattempt\");\n    route(pajoin(\"/container\", CONTAINER_ID), AHSController.class, \"container\");\n    route(\n      pajoin(\"/logs\", NM_NODENAME, CONTAINER_ID, ENTITY_STRING, APP_OWNER,\n        CONTAINER_LOG_TYPE), AHSController.class, \"logs\");\n    route(\"/errors-and-warnings\", AHSController.class, \"errorsAndWarnings\");\n  }","commit_id":"76afd28862c1f27011273659a82cd45903a77170","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void render(Block html) {\n    boolean addErrorsAndWarningsLink = false;\n    Log log = LogFactory.getLog(NavBlock.class);\n    if (log instanceof Log4JLogger) {\n      Log4jWarningErrorMetricsAppender appender =\n          Log4jWarningErrorMetricsAppender.findAppender();\n      if (appender != null) {\n        addErrorsAndWarningsLink = true;\n      }\n    }\n    Hamlet.DIV<Hamlet> nav = html.\n        div(\"#nav\").\n            h3(\"Application History\").\n                ul().\n                    li().a(url(\"apps\"), \"Applications\").\n                        ul().\n                            li().a(url(\"apps\",\n                                YarnApplicationState.FINISHED.toString()),\n                                YarnApplicationState.FINISHED.toString()).\n                            _().\n                            li().a(url(\"apps\",\n                                YarnApplicationState.FAILED.toString()),\n                                YarnApplicationState.FAILED.toString()).\n                            _().\n                            li().a(url(\"apps\",\n                                YarnApplicationState.KILLED.toString()),\n                                YarnApplicationState.KILLED.toString()).\n                            _().\n                        _().\n                    _().\n                _();\n\n    Hamlet.UL<Hamlet.DIV<Hamlet>> tools = nav.h3(\"Tools\").ul();\n    tools.li().a(\"/conf\", \"Configuration\")._()\n        .li().a(\"/logs\", \"Local logs\")._()\n        .li().a(\"/stacks\", \"Server stacks\")._()\n        .li().a(\"/jmx?qry=Hadoop:*\", \"Server metrics\")._();\n\n    if (addErrorsAndWarningsLink) {\n      tools.li().a(url(\"errors-and-warnings\"), \"Errors/Warnings\")._();\n    }\n    tools._()._();\n  }","id":32194,"modified_method":"@Override\n  public void render(Block html) {\n    boolean addErrorsAndWarningsLink = false;\n    Log log = LogFactory.getLog(NavBlock.class);\n    if (log instanceof Log4JLogger) {\n      Log4jWarningErrorMetricsAppender appender =\n          Log4jWarningErrorMetricsAppender.findAppender();\n      if (appender != null) {\n        addErrorsAndWarningsLink = true;\n      }\n    }\n    Hamlet.DIV<Hamlet> nav = html.\n        div(\"#nav\").\n            h3(\"Application History\").\n                ul().\n                    li().a(url(\"about\"), \"About\").\n                    _().\n                    li().a(url(\"apps\"), \"Applications\").\n                        ul().\n                            li().a(url(\"apps\",\n                                YarnApplicationState.FINISHED.toString()),\n                                YarnApplicationState.FINISHED.toString()).\n                            _().\n                            li().a(url(\"apps\",\n                                YarnApplicationState.FAILED.toString()),\n                                YarnApplicationState.FAILED.toString()).\n                            _().\n                            li().a(url(\"apps\",\n                                YarnApplicationState.KILLED.toString()),\n                                YarnApplicationState.KILLED.toString()).\n                            _().\n                        _().\n                    _().\n                _();\n\n    Hamlet.UL<Hamlet.DIV<Hamlet>> tools = nav.h3(\"Tools\").ul();\n    tools.li().a(\"/conf\", \"Configuration\")._()\n        .li().a(\"/logs\", \"Local logs\")._()\n        .li().a(\"/stacks\", \"Server stacks\")._()\n        .li().a(\"/jmx?qry=Hadoop:*\", \"Server metrics\")._();\n\n    if (addErrorsAndWarningsLink) {\n      tools.li().a(url(\"errors-and-warnings\"), \"Errors/Warnings\")._();\n    }\n    tools._()._();\n  }","commit_id":"76afd28862c1f27011273659a82cd45903a77170","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testAbout() throws Exception {\n    WebResource r = resource();\n    ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .accept(MediaType.APPLICATION_JSON)\n        .get(ClientResponse.class);\n    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n    TimelineWebServices.AboutInfo about =\n        response.getEntity(TimelineWebServices.AboutInfo.class);\n    Assert.assertNotNull(about);\n    Assert.assertEquals(\"Timeline API\", about.getAbout());\n  }","id":32195,"modified_method":"@Test\n  public void testAbout() throws Exception {\n    WebResource r = resource();\n    ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .accept(MediaType.APPLICATION_JSON)\n        .get(ClientResponse.class);\n    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n    TimelineAbout actualAbout = response.getEntity(TimelineAbout.class);\n    TimelineAbout expectedAbout =\n        TimelineUtils.createTimelineAbout(\"Timeline API\");\n    Assert.assertNotNull(\n        \"Timeline service about response is null\", actualAbout);\n    Assert.assertEquals(expectedAbout.getAbout(), actualAbout.getAbout());\n    Assert.assertEquals(expectedAbout.getTimelineServiceVersion(),\n        actualAbout.getTimelineServiceVersion());\n    Assert.assertEquals(expectedAbout.getTimelineServiceBuildVersion(),\n        actualAbout.getTimelineServiceBuildVersion());\n    Assert.assertEquals(expectedAbout.getTimelineServiceVersionBuiltOn(),\n        actualAbout.getTimelineServiceVersionBuiltOn());\n    Assert.assertEquals(expectedAbout.getHadoopVersion(),\n        actualAbout.getHadoopVersion());\n    Assert.assertEquals(expectedAbout.getHadoopBuildVersion(),\n        actualAbout.getHadoopBuildVersion());\n    Assert.assertEquals(expectedAbout.getHadoopVersionBuiltOn(),\n        actualAbout.getHadoopVersionBuiltOn());\n  }","commit_id":"76afd28862c1f27011273659a82cd45903a77170","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Return the description of the timeline web services.\n   */\n  @GET\n  @Produces({ MediaType.APPLICATION_JSON /* , MediaType.APPLICATION_XML */})\n  public AboutInfo about(\n      @Context HttpServletRequest req,\n      @Context HttpServletResponse res) {\n    init(res);\n    return new AboutInfo(\"Timeline API\");\n  }","id":32196,"modified_method":"/**\n   * Return the description of the timeline web services.\n   */\n  @GET\n  @Produces({ MediaType.APPLICATION_JSON /* , MediaType.APPLICATION_XML */})\n  public TimelineAbout about(\n      @Context HttpServletRequest req,\n      @Context HttpServletResponse res) {\n    init(res);\n    return TimelineUtils.createTimelineAbout(\"Timeline API\");\n  }","commit_id":"76afd28862c1f27011273659a82cd45903a77170","url":"https://github.com/apache/hadoop"},{"original_method":"@Override public void render(Block html) {\n    UL<DIV<Hamlet>> mainList = html.\n      div(\"#nav\").\n        h3(\"Cluster\").\n        ul().\n          li().a(url(\"cluster\"), \"About\")._().\n          li().a(url(\"nodes\"), \"Nodes\")._().\n          li().a(url(\"nodelabels\"), \"Node Labels\")._();\n    UL<LI<UL<DIV<Hamlet>>>> subAppsList = mainList.\n          li().a(url(\"apps\"), \"Applications\").\n            ul();\n    subAppsList.li()._();\n    for (YarnApplicationState state : YarnApplicationState.values()) {\n      subAppsList.\n              li().a(url(\"apps\", state.toString()), state.toString())._();\n    }\n    subAppsList._()._();\n    mainList.\n          li().a(url(\"scheduler\"), \"Scheduler\")._()._().\n        h3(\"Tools\").\n        ul().\n          li().a(\"/conf\", \"Configuration\")._().\n          li().a(\"/logs\", \"Local logs\")._().\n          li().a(\"/stacks\", \"Server stacks\")._().\n          li().a(\"/jmx?qry=Hadoop:*\", \"Server metrics\")._()._()._();\n  }","id":32197,"modified_method":"@Override public void render(Block html) {\n    boolean addErrorsAndWarningsLink = false;\n    Log log = LogFactory.getLog(RMErrorsAndWarningsPage.class);\n    if (log instanceof Log4JLogger) {\n      Log4jWarningErrorMetricsAppender appender =\n          Log4jWarningErrorMetricsAppender.findAppender();\n      if (appender != null) {\n        addErrorsAndWarningsLink = true;\n      }\n    }\n    UL<DIV<Hamlet>> mainList = html.\n      div(\"#nav\").\n        h3(\"Cluster\").\n        ul().\n          li().a(url(\"cluster\"), \"About\")._().\n          li().a(url(\"nodes\"), \"Nodes\")._().\n          li().a(url(\"nodelabels\"), \"Node Labels\")._();\n    UL<LI<UL<DIV<Hamlet>>>> subAppsList = mainList.\n          li().a(url(\"apps\"), \"Applications\").\n            ul();\n    subAppsList.li()._();\n    for (YarnApplicationState state : YarnApplicationState.values()) {\n      subAppsList.\n              li().a(url(\"apps\", state.toString()), state.toString())._();\n    }\n    subAppsList._()._();\n    UL<DIV<Hamlet>> tools = mainList.\n          li().a(url(\"scheduler\"), \"Scheduler\")._()._().\n        h3(\"Tools\").ul();\n    tools.li().a(\"/conf\", \"Configuration\")._().\n          li().a(\"/logs\", \"Local logs\")._().\n          li().a(\"/stacks\", \"Server stacks\")._().\n          li().a(\"/jmx?qry=Hadoop:*\", \"Server metrics\")._();\n\n    if (addErrorsAndWarningsLink) {\n      tools.li().a(url(\"errors-and-warnings\"), \"Errors/Warnings\")._();\n    }\n    tools._()._();\n  }","commit_id":"bad070fe15a642cc6f3a165612fbd272187e03cb","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void render(Block html) {\n\t\n    String RMWebAppURL =\n        WebAppUtils.getResolvedRemoteRMWebAppURLWithScheme(this.conf);\n\t  html\n      .div(\"#nav\")\n      .h3()._(\"ResourceManager\")._()\n        .ul()\n          .li().a(RMWebAppURL, \"RM Home\")._()._()\n      .h3()._(\"NodeManager\")._() // TODO: Problem if no header like this\n        .ul()\n          .li()\n            .a(url(\"node\"), \"Node Information\")._()\n          .li()\n            .a(url(\"allApplications\"), \"List of Applications\")\n            ._()\n          .li()\n            .a(url(\"allContainers\"), \"List of Containers\")._()\n        ._()\n      .h3(\"Tools\")\n        .ul()\n          .li().a(\"/conf\", \"Configuration\")._()\n          .li().a(\"/logs\", \"Local logs\")._()\n          .li().a(\"/stacks\", \"Server stacks\")._()\n          .li().a(\"/jmx?qry=Hadoop:*\", \"Server metrics\")._()._()._();\n  }","id":32198,"modified_method":"@Override\n  protected void render(Block html) {\n\n    boolean addErrorsAndWarningsLink = false;\n    Log log = LogFactory.getLog(NMErrorsAndWarningsPage.class);\n    if (log instanceof Log4JLogger) {\n      Log4jWarningErrorMetricsAppender appender = Log4jWarningErrorMetricsAppender.findAppender();\n      if (appender != null) {\n        addErrorsAndWarningsLink = true;\n      }\n    }\n\t\n    String RMWebAppURL =\n        WebAppUtils.getResolvedRMWebAppURLWithScheme(this.conf);\n\t  Hamlet.UL<Hamlet.DIV<Hamlet>> ul = html\n      .div(\"#nav\")\n      .h3()._(\"ResourceManager\")._()\n        .ul()\n          .li().a(RMWebAppURL, \"RM Home\")._()._()\n      .h3()._(\"NodeManager\")._() // TODO: Problem if no header like this\n        .ul()\n          .li()\n            .a(url(\"node\"), \"Node Information\")._()\n          .li()\n            .a(url(\"allApplications\"), \"List of Applications\")\n            ._()\n          .li()\n            .a(url(\"allContainers\"), \"List of Containers\")._()\n        ._()\n      .h3(\"Tools\")\n        .ul()\n          .li().a(\"/conf\", \"Configuration\")._()\n          .li().a(\"/logs\", \"Local logs\")._()\n          .li().a(\"/stacks\", \"Server stacks\")._()\n          .li().a(\"/jmx?qry=Hadoop:*\", \"Server metrics\")._();\n    if (addErrorsAndWarningsLink) {\n      ul.li().a(url(\"errors-and-warnings\"), \"Errors/Warnings\")._();\n    }\n    ul._()._();\n  }","commit_id":"bad070fe15a642cc6f3a165612fbd272187e03cb","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void setup() {\n    bind(JAXBContextResolver.class);\n    bind(RMWebServices.class);\n    bind(GenericExceptionHandler.class);\n    bind(RMWebApp.class).toInstance(this);\n\n    if (rm != null) {\n      bind(ResourceManager.class).toInstance(rm);\n      bind(ApplicationBaseProtocol.class).toInstance(rm.getClientRMService());\n    }\n    route(\"/\", RmController.class);\n    route(pajoin(\"/nodes\", NODE_STATE), RmController.class, \"nodes\");\n    route(pajoin(\"/apps\", APP_STATE), RmController.class);\n    route(\"/cluster\", RmController.class, \"about\");\n    route(pajoin(\"/app\", APPLICATION_ID), RmController.class, \"app\");\n    route(\"/scheduler\", RmController.class, \"scheduler\");\n    route(pajoin(\"/queue\", QUEUE_NAME), RmController.class, \"queue\");\n    route(\"/nodelabels\", RmController.class, \"nodelabels\");\n    route(pajoin(\"/appattempt\", APPLICATION_ATTEMPT_ID), RmController.class,\n      \"appattempt\");\n    route(pajoin(\"/container\", CONTAINER_ID), RmController.class, \"container\");\n  }","id":32199,"modified_method":"@Override\n  public void setup() {\n    bind(JAXBContextResolver.class);\n    bind(RMWebServices.class);\n    bind(GenericExceptionHandler.class);\n    bind(RMWebApp.class).toInstance(this);\n\n    if (rm != null) {\n      bind(ResourceManager.class).toInstance(rm);\n      bind(ApplicationBaseProtocol.class).toInstance(rm.getClientRMService());\n    }\n    route(\"/\", RmController.class);\n    route(pajoin(\"/nodes\", NODE_STATE), RmController.class, \"nodes\");\n    route(pajoin(\"/apps\", APP_STATE), RmController.class);\n    route(\"/cluster\", RmController.class, \"about\");\n    route(pajoin(\"/app\", APPLICATION_ID), RmController.class, \"app\");\n    route(\"/scheduler\", RmController.class, \"scheduler\");\n    route(pajoin(\"/queue\", QUEUE_NAME), RmController.class, \"queue\");\n    route(\"/nodelabels\", RmController.class, \"nodelabels\");\n    route(pajoin(\"/appattempt\", APPLICATION_ATTEMPT_ID), RmController.class,\n      \"appattempt\");\n    route(pajoin(\"/container\", CONTAINER_ID), RmController.class, \"container\");\n    route(\"/errors-and-warnings\", RmController.class, \"errorsAndWarnings\");\n  }","commit_id":"bad070fe15a642cc6f3a165612fbd272187e03cb","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n    public void setup() {\n      bind(NMWebServices.class);\n      bind(GenericExceptionHandler.class);\n      bind(JAXBContextResolver.class);\n      bind(ResourceView.class).toInstance(this.resourceView);\n      bind(ApplicationACLsManager.class).toInstance(this.aclsManager);\n      bind(LocalDirsHandlerService.class).toInstance(dirsHandler);\n      route(\"/\", NMController.class, \"info\");\n      route(\"/node\", NMController.class, \"node\");\n      route(\"/allApplications\", NMController.class, \"allApplications\");\n      route(\"/allContainers\", NMController.class, \"allContainers\");\n      route(pajoin(\"/application\", APPLICATION_ID), NMController.class,\n          \"application\");\n      route(pajoin(\"/container\", CONTAINER_ID), NMController.class,\n          \"container\");\n      route(\n          pajoin(\"/containerlogs\", CONTAINER_ID, APP_OWNER, CONTAINER_LOG_TYPE),\n          NMController.class, \"logs\");\n    }","id":32200,"modified_method":"@Override\n    public void setup() {\n      bind(NMWebServices.class);\n      bind(GenericExceptionHandler.class);\n      bind(JAXBContextResolver.class);\n      bind(ResourceView.class).toInstance(this.resourceView);\n      bind(ApplicationACLsManager.class).toInstance(this.aclsManager);\n      bind(LocalDirsHandlerService.class).toInstance(dirsHandler);\n      route(\"/\", NMController.class, \"info\");\n      route(\"/node\", NMController.class, \"node\");\n      route(\"/allApplications\", NMController.class, \"allApplications\");\n      route(\"/allContainers\", NMController.class, \"allContainers\");\n      route(pajoin(\"/application\", APPLICATION_ID), NMController.class,\n          \"application\");\n      route(pajoin(\"/container\", CONTAINER_ID), NMController.class,\n          \"container\");\n      route(\n          pajoin(\"/containerlogs\", CONTAINER_ID, APP_OWNER, CONTAINER_LOG_TYPE),\n          NMController.class, \"logs\");\n      route(\"/errors-and-warnings\", NMController.class, \"errorsAndWarnings\");\n    }","commit_id":"bad070fe15a642cc6f3a165612fbd272187e03cb","url":"https://github.com/apache/hadoop"},{"original_method":"private void assertResultPage(final String file) throws IOException\n\t{\n\t\tString document = tester.getLastResponse().getTextResponse().toString();\n\t\tdocument = document.replaceAll(\"[1-9]+[.]IFormSubmitListener\", \"1.IFormSubmitListener\");\n\t\tDiffUtil.validatePage(document, getClass(), file, true);\n\t}","id":32201,"modified_method":"private void assertResultPage(final String file) throws IOException\n\t{\n\t\tString document = tester.getLastResponse().getDocument();\n\t\tdocument = document.replaceAll(\"[1-9]+[.]IFormSubmitListener\", \"1.IFormSubmitListener\");\n\t\tDiffUtil.validatePage(document, getClass(), file, true);\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Tests visibility of children after enclosure has been made hidden and visible again\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testVisibilityOfChildren() throws Exception\n\t{\n\t\t// render with enclosure initially visible\n\t\ttester.startPage(EnclosurePage_6.class);\n\t\tString doc = tester.getLastResponse().getTextResponse().toString();\n\t\tassertTrue(doc.contains(\"content1\"));\n\t\tassertTrue(doc.contains(\"content2\"));\n\n\t\t// render with enclosure hidden\n\t\ttester.clickLink(\"link\");\n\t\tdoc = tester.getLastResponse().getTextResponse().toString();\n\t\tassertFalse(doc.contains(\"content1\"));\n\t\tassertFalse(doc.contains(\"content2\"));\n\n\t\t// render with enclosure visible again\n\t\ttester.clickLink(\"link\");\n\t\tdoc = tester.getLastResponse().getTextResponse().toString();\n\t\tassertTrue(doc.contains(\"content1\"));\n\t\tassertTrue(doc.contains(\"content2\"));\n\t}","id":32202,"modified_method":"/**\n\t * Tests visibility of children after enclosure has been made hidden and visible again\n\t * \n\t * @throws Exception\n\t */\n\tpublic void testVisibilityOfChildren() throws Exception\n\t{\n\t\t// render with enclosure initially visible\n\t\ttester.startPage(EnclosurePage_6.class);\n\t\tString doc = tester.getLastResponse().getDocument();\n\t\tassertTrue(doc.contains(\"content1\"));\n\t\tassertTrue(doc.contains(\"content2\"));\n\n\t\t// render with enclosure hidden\n\t\ttester.clickLink(\"link\");\n\t\tdoc = tester.getLastResponse().getDocument();\n\t\tassertFalse(doc.contains(\"content1\"));\n\t\tassertFalse(doc.contains(\"content2\"));\n\n\t\t// render with enclosure visible again\n\t\ttester.clickLink(\"link\");\n\t\tdoc = tester.getLastResponse().getDocument();\n\t\tassertTrue(doc.contains(\"content1\"));\n\t\tassertTrue(doc.contains(\"content2\"));\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Tests the webapplication for a successful match.\n\t */\n\tpublic void testHangmanSuccessWebGame()\n\t{\n\t\tWicketTester tester = new WicketTester(new HangmanApplication());\n\n\t\ttester.startPage(Home.class, new PageParameters(\"word=hangman\"));\n\t\ttester.assertComponent(\"start\", Link.class);\n\t\ttester.assertContains(\"Wicket Examples - hangman\");\n\t\ttester.clickLink(\"start\");\n\t\ttester.assertLabel(\"guessesRemaining\", \"5\");\n\t\tclickLetter(tester, 'f');\n\t\ttester.assertLabel(\"guessesRemaining\", \"4\");\n\t\tclickLetter(tester, 'h');\n\t\ttester.assertLabel(\"guessesRemaining\", \"4\");\n\t\tclickLetter(tester, 'a');\n\t\tclickLetter(tester, 'n');\n\t\tclickLetter(tester, 'g');\n\t\tclickLetter(tester, 'm');\n\t\ttester.assertRenderedPage(Win.class);\n\t}","id":32203,"modified_method":"/**\n\t * Tests the webapplication for a successful match.\n\t */\n\tpublic void testHangmanSuccessWebGame()\n\t{\n\t\tWicketTester tester = new WicketTester(new HangmanApplication());\n\n\t\ttester.startPage(Home.class, new PageParameters().set(\"word\", \"hangman\"));\n\t\ttester.assertComponent(\"start\", Link.class);\n\t\ttester.assertContains(\"Wicket Examples - hangman\");\n\t\ttester.clickLink(\"start\");\n\t\ttester.assertLabel(\"guessesRemaining\", \"5\");\n\t\tclickLetter(tester, 'f');\n\t\ttester.assertLabel(\"guessesRemaining\", \"4\");\n\t\tclickLetter(tester, 'h');\n\t\ttester.assertLabel(\"guessesRemaining\", \"4\");\n\t\tclickLetter(tester, 'a');\n\t\tclickLetter(tester, 'n');\n\t\tclickLetter(tester, 'g');\n\t\tclickLetter(tester, 'm');\n\t\ttester.assertRenderedPage(Win.class);\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"private Letter letter(Game hangman, char c)\n\t{\n\t\tfor (Iterator iter = hangman.getLetters().iterator(); iter.hasNext();)\n\t\t{\n\t\t\tLetter letter = (Letter)iter.next();\n\t\t\tif (letter.asString().equalsIgnoreCase(Character.toString(c)))\n\t\t\t{\n\t\t\t\treturn letter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":32204,"modified_method":"private Letter letter(Game hangman, char c)\n\t{\n\t\tfor (Letter letter : hangman.getLetters())\n\t\t{\n\t\t\tif (letter.asString().equalsIgnoreCase(Character.toString(c)))\n\t\t\t{\n\t\t\t\treturn letter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Tests the webapplication for an unsuccessful match.\n\t */\n\tpublic void testHangmanFailureWebGame()\n\t{\n\t\tWicketTester tester = new WicketTester(new HangmanApplication());\n\n\t\ttester.startPage(Home.class, new PageParameters(\"word=hangman\"));\n\t\ttester.assertComponent(\"start\", Link.class);\n\t\ttester.assertContains(\"Wicket Examples - hangman\");\n\t\ttester.clickLink(\"start\");\n\t\ttester.assertLabel(\"guessesRemaining\", \"5\");\n\t\tclickLetter(tester, 'f');\n\t\ttester.assertLabel(\"guessesRemaining\", \"4\");\n\t\tclickLetter(tester, 'e');\n\t\ttester.assertLabel(\"guessesRemaining\", \"3\");\n\t\tclickLetter(tester, 't');\n\t\ttester.assertLabel(\"guessesRemaining\", \"2\");\n\t\tclickLetter(tester, 'x');\n\t\ttester.assertLabel(\"guessesRemaining\", \"1\");\n\t\tclickLetter(tester, 'z');\n\t\ttester.assertRenderedPage(Lose.class);\n\t}","id":32205,"modified_method":"/**\n\t * Tests the webapplication for an unsuccessful match.\n\t */\n\tpublic void testHangmanFailureWebGame()\n\t{\n\t\tWicketTester tester = new WicketTester(new HangmanApplication());\n\n\t\ttester.startPage(Home.class, new PageParameters().set(\"word\", \"hangman\"));\n\t\ttester.assertComponent(\"start\", Link.class);\n\t\ttester.assertContains(\"Wicket Examples - hangman\");\n\t\ttester.clickLink(\"start\");\n\t\ttester.assertLabel(\"guessesRemaining\", \"5\");\n\t\tclickLetter(tester, 'f');\n\t\ttester.assertLabel(\"guessesRemaining\", \"4\");\n\t\tclickLetter(tester, 'e');\n\t\ttester.assertLabel(\"guessesRemaining\", \"3\");\n\t\tclickLetter(tester, 't');\n\t\ttester.assertLabel(\"guessesRemaining\", \"2\");\n\t\tclickLetter(tester, 'x');\n\t\ttester.assertLabel(\"guessesRemaining\", \"1\");\n\t\tclickLetter(tester, 'z');\n\t\ttester.assertRenderedPage(Lose.class);\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @throws Exception\n\t */\n\tpublic void testRenderHomePage_4() throws Exception\n\t{\n\t\tSystem.out.println(\"=== \" + MarkupInheritanceExtension_4.class.getName() + \" ===\");\n\n\t\ttester.startPage(MarkupInheritanceExtension_4.class);\n\n\t\t// Validate the document\n\t\tassertEquals(MarkupInheritanceExtension_4.class, tester.getLastRenderedPage().getClass());\n\t\tString document = tester.getLastResponse().getTextResponse().toString();\n\t\tDiffUtil.validatePage(document, getClass(), \"MarkupInheritanceExpectedResult_4.html\", true);\n\n\t\tMarkupInheritanceExtension_4 page = (MarkupInheritanceExtension_4)tester.getLastRenderedPage();\n\n\t\tLink link = (Link)page.get(\"link\");\n\t\ttester.clickLink(link.getPageRelativePath());\n\n\t\tassertEquals(MarkupInheritanceExtension_4.class, tester.getLastRenderedPage().getClass());\n\n\t\tdocument = tester.getLastResponse().getTextResponse().toString();\n\t\tDiffUtil.validatePage(document, getClass(), \"MarkupInheritanceExpectedResult_4-1.html\",\n\t\t\ttrue);\n\t}","id":32206,"modified_method":"/**\n\t * @throws Exception\n\t */\n\tpublic void testRenderHomePage_4() throws Exception\n\t{\n\t\tSystem.out.println(\"=== \" + MarkupInheritanceExtension_4.class.getName() + \" ===\");\n\n\t\ttester.startPage(MarkupInheritanceExtension_4.class);\n\n\t\t// Validate the document\n\t\tassertEquals(MarkupInheritanceExtension_4.class, tester.getLastRenderedPage().getClass());\n\t\tString document = tester.getLastResponse().getDocument();\n\t\tDiffUtil.validatePage(document, getClass(), \"MarkupInheritanceExpectedResult_4.html\", true);\n\n\t\tMarkupInheritanceExtension_4 page = (MarkupInheritanceExtension_4)tester.getLastRenderedPage();\n\n\t\tLink link = (Link)page.get(\"link\");\n\t\ttester.clickLink(link.getPageRelativePath());\n\n\t\tassertEquals(MarkupInheritanceExtension_4.class, tester.getLastRenderedPage().getClass());\n\n\t\tdocument = tester.getLastResponse().getDocument();\n\t\tDiffUtil.validatePage(document, getClass(), \"MarkupInheritanceExpectedResult_4-1.html\",\n\t\t\ttrue);\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@Override\n\tpublic boolean equals(Object obj)\n\t{\n\t\tif (obj instanceof PageA)\n\t\t{\n\t\t\tif (getNumericId() == ((PageA)obj).getNumericId())\n\t\t\t{\n\t\t\t\tif (page != null)\n\t\t\t\t{\n\t\t\t\t\treturn page.equals(((PageA)obj).page);\n\t\t\t\t}\n\t\t\t\treturn ((PageA)obj).page == null;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":32207,"modified_method":"/**\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@Override\n\tpublic boolean equals(Object obj)\n\t{\n\t\tif (obj instanceof PageA)\n\t\t{\n\t\t\tif (getPageId() == ((PageA)obj).getPageId())\n\t\t\t{\n\t\t\t\tif (page != null)\n\t\t\t\t{\n\t\t\t\t\treturn page.equals(((PageA)obj).page);\n\t\t\t\t}\n\t\t\t\treturn ((PageA)obj).page == null;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic boolean equals(Object obj)\n\t{\n\t\tif (obj instanceof PageB)\n\t\t{\n\t\t\treturn getNumericId() == ((PageB)obj).getNumericId() && test.equals(((PageB)obj).test);\n\t\t}\n\t\treturn false;\n\t}","id":32208,"modified_method":"@Override\n\tpublic boolean equals(Object obj)\n\t{\n\t\tif (obj instanceof PageB)\n\t\t{\n\t\t\treturn getPageId() == ((PageB)obj).getPageId() && test.equals(((PageB)obj).test);\n\t\t}\n\t\treturn false;\n\t}","commit_id":"cea4fb65950eb9d3dcdf3f823ae3ab80d78c9b8c","url":"https://github.com/apache/wicket"},{"original_method":"public IBindingFactory seed( final Class seed ) throws BindingException {\n    try {\n      this.bindingFactory = BindingDirectory.getFactory( this.name, seed );\n      String[] mappedClasses = this.bindingFactory.getMappedClasses( );\n      for ( int i = 0; i < mappedClasses.length; i++ ) {\n        if ( this.bindingFactory.getElementNames( )[i] != null ) {\n          try {\n            this.elementToClassMap.put( this.bindingFactory.getElementNames( )[i], ClassLoader.getSystemClassLoader( ).loadClass( mappedClasses[i] ) );\n            this.classToElementMap.put( mappedClasses[i], this.bindingFactory.getElementNames( )[i] );\n            this.classToNamespaceMap.put( mappedClasses[i], this.bindingFactory.getElementNamespaces( )[i] );\n          } catch ( ClassNotFoundException e ) {\n            LOG.trace( e, e );\n          }\n        }\n      }\n    } catch ( JiBXException e ) {\n      LOG.debug( e, e );\n      throw new BindingException( \"Failed to build binding factory for \" + this.name + \" with seed class \" + seed.getCanonicalName( ) );\n    }\n    return this.bindingFactory;\n  }","id":32209,"modified_method":"public IBindingFactory seed( final Class seed ) throws BindingException {\n    final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader( );\n    try {\n      this.bindingFactory = BindingDirectory.getFactory( this.name, seed, systemClassLoader );\n      final String[] mappedClasses = this.bindingFactory.getMappedClasses( );\n      for ( int i = 0; i < mappedClasses.length; i++ ) {\n        if ( this.bindingFactory.getElementNames( )[i] != null ) {\n          try {\n            this.elementToClassMap.put( this.bindingFactory.getElementNames( )[i], systemClassLoader.loadClass( mappedClasses[i] ) );\n            this.classToElementMap.put( mappedClasses[i], this.bindingFactory.getElementNames( )[i] );\n            this.classToNamespaceMap.put( mappedClasses[i], this.bindingFactory.getElementNamespaces( )[i] );\n          } catch ( ClassNotFoundException e ) {\n            LOG.trace( e, e );\n          }\n        }\n      }\n    } catch ( JiBXException e ) {\n      LOG.debug( e, e );\n      throw new BindingException( \"Failed to build binding factory for \" + this.name + \" with seed class \" + seed.getCanonicalName( ) );\n    }\n    return this.bindingFactory;\n  }","commit_id":"eb0bd60d64c1d3a91d287866f35a968716d9fdee","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public boolean processClass( Class candidate ) throws Exception {\n    Field f;\n    String bindingList;\n    try {\n      f = candidate.getDeclaredField( \"JiBX_bindingList\" );\n      bindingList = ( String ) f.get( null );\n    } catch ( Exception e ) {\n      return false;\n    }\n    List<String> bindings = Lists.transform( Arrays.asList( bindingList.split( \"\\\\|\" ) ), new Function<String,String>() {\n      @Override\n      public String apply( String arg0 ) {\n        return BindingManager.sanitizeNamespace( arg0.replaceAll(\".*JiBX_\",\"\").replaceAll(\"Factory\",\"\") );\n      }        \n    });\n    boolean seeded = false;\n    for( String binding : bindings ) {\n      if( binding.length( ) > 2 ) {\n        try {\n          seeded |= BindingManager.seedBinding( binding, candidate );\n        } catch ( Exception e ) {\n        }\n      }\n    }\n    return seeded;\n  }","id":32210,"modified_method":"@Override\n  public boolean processClass( Class candidate ) throws Exception {\n    boolean seeded = false;\n    if ( BaseMessage.class.isAssignableFrom( candidate ) ) {\n      String bindingList;\n      try {\n        Field f = candidate.getDeclaredField( \"JiBX_bindingList\" );\n        bindingList = ( String ) f.get( null );\n      } catch ( Exception e ) {\n        return false;\n      }\n      final List<String> bindings = Lists.transform( Arrays.asList( bindingList.split( \"\\\\|\" ) ), new Function<String,String>() {\n        @Override\n        public String apply( String arg0 ) {\n          return BindingManager.sanitizeNamespace( arg0.replaceAll(\".*JiBX_\",\"\").replaceAll(\"Factory\",\"\") );\n        }\n      });\n      for( String binding : bindings ) {\n        if( binding.length( ) > 2 ) {\n          try {\n            seeded |= BindingManager.seedBinding( binding, candidate );\n          } catch ( Exception e ) {\n          }\n        }\n      }\n      BindingManager.waitForSeeding( );\n    }\n    return seeded;\n  }","commit_id":"eb0bd60d64c1d3a91d287866f35a968716d9fdee","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static boolean trySeed( final BindingKey key, final Class seedClass ) {\n    boolean seeded = false;\n    if ( !BindingManager.bindingMap.containsKey( key ) ) {\n      try {\n        BindingManager.getBinding( key ).seed( seedClass );\n        Logs.exhaust().trace( \"Seeding binding \" + key.getName( ) + \" for class \" + seedClass.getCanonicalName( ) );\n        EventRecord.here( BindingManager.class, EventType.BINDING_SEEDED, key.getName( ), seedClass.getName() ).trace( );\n        seeded = true;\n      } catch ( BindingException e ) {\n        throw BootstrapException.error( \"Failed to seed binding \" + key.getName( ) + \" with class \" + seedClass, e );\n      }\n    }\n    return seeded;\n  }","id":32211,"modified_method":"private static boolean trySeed( final BindingKey key, final Class seedClass ) {\n    boolean seeded = false;\n    if ( !BindingManager.bindingMap.containsKey( key ) ) {\n      final Binding binding = BindingManager.getBinding( key );\n      seeded = true;\n      bindingSeedMap.put( key, Threads.enqueue( Empyrean.class, BindingManager.class, new Callable<Boolean>( ) {\n        @Override\n        public Boolean call( ) throws Exception {\n          try {\n            binding.seed( seedClass );\n            Logs.exhaust( ).trace( \"Seeding binding \" + key.getName( ) + \" for class \" + seedClass.getCanonicalName( ) );\n            EventRecord.here( BindingManager.class, EventType.BINDING_SEEDED, key.getName( ) + \" \" + key.component, seedClass.getName() ).debug( );\n          } catch ( BindingException e ) {\n            throw new BindingException( \"Failed to seed binding \" + key.getName( ) + \" with class \" + seedClass, e );\n          }\n          return true;\n        }\n      } ) );\n    }\n    return seeded;\n  }","commit_id":"eb0bd60d64c1d3a91d287866f35a968716d9fdee","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static boolean seedBinding( final String bindingName,\n                                     final Class seedClass ) {\n    boolean seeded = trySeed( key( bindingName ), seedClass );\n\n    if ( BaseMessage.class.isAssignableFrom( seedClass ) ) {\n      Class<?> messageClass = seedClass;\n      while ( messageClass != BaseMessage.class ) {\n        final ComponentMessage componentMessage = messageClass.getAnnotation( ComponentMessage.class );\n        if ( componentMessage != null ) {\n          seeded = seeded || trySeed(\n              key( Optional.<Class<? extends ComponentId>>fromNullable( componentMessage.value() ), bindingName ),\n              seedClass );\n          break;\n        }\n        messageClass = messageClass.getSuperclass( );\n      }\n    }\n\n    return seeded;\n  }","id":32212,"modified_method":"public static boolean seedBinding( final String bindingName,\n                                     final Class seedClass ) {\n    boolean foundComponent = false;\n    boolean seeded = false;\n\n    if ( BaseMessage.class.isAssignableFrom( seedClass ) ) {\n      Class<?> messageClass = seedClass;\n      while ( messageClass != BaseMessage.class ) {\n        final ComponentMessage componentMessage = messageClass.getAnnotation( ComponentMessage.class );\n        if ( componentMessage != null ) {\n          foundComponent = true;\n          final BindingKey key = key( Optional.<Class<? extends ComponentId>>fromNullable( componentMessage.value() ), bindingName );\n          seeded = trySeed( key , seedClass );\n          if ( seeded ) {\n            BindingManager.bindingMap.put( key( bindingName ), getBinding( key ) );\n          }\n          break;\n        }\n        messageClass = messageClass.getSuperclass( );\n      }\n    }\n\n    if ( !seeded && !foundComponent ) {\n      seeded = trySeed( key( bindingName ), seedClass );\n    }\n\n    return seeded;\n  }","commit_id":"eb0bd60d64c1d3a91d287866f35a968716d9fdee","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static ClassLoader internalGetFelixBundleClassLoader(Bundle bundle)\n    {\n        //firstly, try to find classes matching a newer version of felix\n        initFelix403(bundle);\n      \n        if (isFelix403.booleanValue())\n        {\n            try\n            {\n                Object wiring = Felix_adapt_method.invoke(bundle, new Object[] {Felix_bundleWiringClazz});\n                ClassLoader cl = (ClassLoader)Felix_bundle_wiring_getClassLoader_method.invoke(wiring);\n                return cl;\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n                return null;\n            }\n        }\n\n\n        // Fallback to trying earlier versions of felix.     \n        if (Felix_BundleImpl_m_modules_field == null)\n        {\n            try\n            {\n                Class bundleImplClazz = bundle.getClass().getClassLoader().loadClass(\"org.apache.felix.framework.BundleImpl\");  \n                Felix_BundleImpl_m_modules_field = bundleImplClazz.getDeclaredField(\"m_modules\");\n                Felix_BundleImpl_m_modules_field.setAccessible(true);\n            }\n            catch (ClassNotFoundException e)\n            {\n                LOG.warn(e);\n            }\n            catch (NoSuchFieldException e)\n            {\n                LOG.warn(e);\n            }\n        }\n\n        // Figure out which version of the modules is exported\n        Object currentModuleImpl;\n        try\n        {\n            Object[] moduleArray = (Object[]) Felix_BundleImpl_m_modules_field.get(bundle);\n            currentModuleImpl = moduleArray[moduleArray.length - 1];\n        }\n        catch (Throwable t2)\n        {\n            try\n            {\n                List<Object> moduleArray = (List<Object>) Felix_BundleImpl_m_modules_field.get(bundle);\n                currentModuleImpl = moduleArray.get(moduleArray.size() - 1);\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n                return null;\n            }\n        }\n\n        if (Felix_ModuleImpl_m_classLoader_field == null && currentModuleImpl != null)\n        {\n            try\n            {\n                Felix_ModuleImpl_m_classLoader_field = bundle.getClass().getClassLoader().loadClass(\"org.apache.felix.framework.ModuleImpl\").getDeclaredField(\"m_classLoader\");\n                Felix_ModuleImpl_m_classLoader_field.setAccessible(true);\n            }\n            catch (ClassNotFoundException e)\n            {\n                LOG.warn(e);\n                return null;\n            }   \n            catch (NoSuchFieldException e)\n            {\n                LOG.warn(e);\n                return null;\n            }\n        }\n        // first make sure that the classloader is ready:\n        // the m_classLoader field must be initialized by the\n        // ModuleImpl.getClassLoader() private method.\n        ClassLoader cl = null;\n        try\n        {\n            cl = (ClassLoader) Felix_ModuleImpl_m_classLoader_field.get(currentModuleImpl);\n            if (cl != null)\n                return cl;\n        }\n        catch (Exception e)\n        {\n            LOG.warn(e);\n            return null;\n        }\n        \n        // looks like it was not ready:\n        // the m_classLoader field must be initialized by the\n        // ModuleImpl.getClassLoader() private method.\n        // this call will do that.\n        try\n        {\n            bundle.loadClass(\"java.lang.Object\");\n            cl = (ClassLoader) Felix_ModuleImpl_m_classLoader_field.get(currentModuleImpl);\n            return cl;\n        }\n        catch (Exception e)\n        {\n            LOG.warn(e);\n            return null;\n        }\n    }","id":32213,"modified_method":"/**\n     * @param bundle\n     * @return\n     */\n    private static ClassLoader internalGetFelixBundleClassLoader(Bundle bundle)\n    {\n        \n        if (osgiContainer == OSGiContainerType.Felix403)\n        {\n            try\n            {\n                if (Felix_BundleWiring_Class == null)\n                    Felix_BundleWiring_Class = bundle.getClass().getClassLoader().loadClass(\"org.osgi.framework.wiring.BundleWiring\");\n\n\n                Felix_BundleImpl_Adapt_Method.setAccessible(true);\n\n                if (Felix_BundleWiring_getClassLoader_Method == null)\n                {\n                    Felix_BundleWiring_getClassLoader_Method = Felix_BundleWiring_Class.getDeclaredMethod(\"getClassLoader\");\n                    Felix_BundleWiring_getClassLoader_Method.setAccessible(true);\n                }\n\n\n                Object wiring = Felix_BundleImpl_Adapt_Method.invoke(bundle, new Object[] {Felix_BundleWiring_Class});\n                return (ClassLoader)Felix_BundleWiring_getClassLoader_Method.invoke(wiring);\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n                return null;\n            }\n        }\n\n\n        if (osgiContainer == OSGiContainerType.FelixOld)\n        {     \n            try\n            {\n                if (Felix_BundleImpl_m_Modules_Field == null)\n                {\n                    Felix_BundleImpl_m_Modules_Field = Felix_BundleImpl_Class.getDeclaredField(\"m_modules\");\n                    Felix_BundleImpl_m_Modules_Field.setAccessible(true);\n                }\n\n                // Figure out which version of the modules is exported\n                Object currentModuleImpl;\n\n                try\n                {\n                    Object[] moduleArray = (Object[]) Felix_BundleImpl_m_Modules_Field.get(bundle);\n                    currentModuleImpl = moduleArray[moduleArray.length - 1];\n                }\n                catch (Throwable t2)\n                {\n                    try\n                    {\n                        List<Object> moduleArray = (List<Object>) Felix_BundleImpl_m_Modules_Field.get(bundle);\n                        currentModuleImpl = moduleArray.get(moduleArray.size() - 1);\n                    }\n                    catch (Exception e)\n                    {\n                        LOG.warn(e);\n                        return null;\n                    }\n                }\n\n                if (Felix_ModuleImpl_m_ClassLoader_Field == null && currentModuleImpl != null)\n                {\n                    try\n                    {\n                        Felix_ModuleImpl_m_ClassLoader_Field = bundle.getClass().getClassLoader().loadClass(\"org.apache.felix.framework.ModuleImpl\").getDeclaredField(\"m_classLoader\");\n                        Felix_ModuleImpl_m_ClassLoader_Field.setAccessible(true);\n                    }\n                    catch (Exception e)\n                    {\n                        LOG.warn(e);\n                        return null;\n                    }\n                }\n\n                // first make sure that the classloader is ready:\n                // the m_classLoader field must be initialized by the\n                // ModuleImpl.getClassLoader() private method.\n                ClassLoader cl = null;\n                try\n                {\n                    cl = (ClassLoader) Felix_ModuleImpl_m_ClassLoader_Field.get(currentModuleImpl);\n                    if (cl != null)\n                        return cl;\n                }\n                catch (Exception e)\n                {\n                    LOG.warn(e);\n                    return null;\n                }\n\n                // looks like it was not ready:\n                // the m_classLoader field must be initialized by the\n                // ModuleImpl.getClassLoader() private method.\n                // this call will do that.\n                try\n                {\n                    bundle.loadClass(\"java.lang.Object\");\n                    cl = (ClassLoader) Felix_ModuleImpl_m_ClassLoader_Field.get(currentModuleImpl);\n                    return cl;\n                }\n                catch (Exception e)\n                {\n                    LOG.warn(e);\n                    return null;\n                }\n            }  \n            catch (Exception e)\n            {\n                LOG.warn(e);\n                return null;\n            }\n        }\n        \n        LOG.warn(\"No classloader for felix platform for bundle \"+bundle.getSymbolicName());\n        return null;\n    }","commit_id":"90f387bc34ca9b5ed974661849ca5c51e663c0a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Assuming the bundle is started.\n     * \n     * @param bundle\n     * @return classloader object\n     */\n    public ClassLoader getBundleClassLoader(Bundle bundle)\n    {\n        String bundleActivator = (String) bundle.getHeaders().get(\"Bundle-Activator\");\n       \n        if (bundleActivator == null)\n        {\n            bundleActivator = (String) bundle.getHeaders().get(\"Jetty-ClassInBundle\");\n        }\n        if (bundleActivator != null)\n        {\n            try\n            {\n                return bundle.loadClass(bundleActivator).getClassLoader();\n            }\n            catch (ClassNotFoundException e)\n            {\n                LOG.warn(e);\n            }\n        }\n        // resort to introspection\n        if (!identifiedOsgiImpl)\n        {\n            init(bundle);\n        }\n        if (isEquinox)\n        {\n            return internalGetEquinoxBundleClassLoader(bundle);\n        }\n        else if (isFelix) \n        { \n            return internalGetFelixBundleClassLoader(bundle); \n        }\n        \n        LOG.warn(\"No classloader found for bundle \"+bundle.getSymbolicName());\n        return null;\n    }","id":32214,"modified_method":"/**\n     * Assuming the bundle is started.\n     * \n     * @param bundle\n     * @return classloader object\n     */\n    public ClassLoader getBundleClassLoader(Bundle bundle)\n    {\n        String bundleActivator = (String) bundle.getHeaders().get(\"Bundle-Activator\");\n   \n        if (bundleActivator == null)\n        {\n            bundleActivator = (String) bundle.getHeaders().get(\"Jetty-ClassInBundle\");\n        }\n        if (bundleActivator != null)\n        {\n            try\n            {\n                return bundle.loadClass(bundleActivator).getClassLoader();\n            }\n            catch (ClassNotFoundException e)\n            {\n                LOG.warn(e);\n            }\n        }\n        \n        // resort to introspection     \n        return getBundleClassLoaderForContainer(bundle);\n    }","commit_id":"90f387bc34ca9b5ed974661849ca5c51e663c0a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private static ClassLoader internalGetEquinoxBundleClassLoader(Bundle bundle)\n    {\n        // assume equinox:\n        try\n        {\n            if (Equinox_BundleHost_getBundleLoader_method == null)\n            {\n                Equinox_BundleHost_getBundleLoader_method = \n                    bundle.getClass().getClassLoader().loadClass(\"org.eclipse.osgi.framework.internal.core.BundleHost\").getDeclaredMethod(\"getBundleLoader\", new Class[] {});\n                Equinox_BundleHost_getBundleLoader_method.setAccessible(true);\n            }\n            Object bundleLoader = Equinox_BundleHost_getBundleLoader_method.invoke(bundle, new Object[] {});\n            if (Equinox_BundleLoader_createClassLoader_method == null && bundleLoader != null)\n            {\n                Equinox_BundleLoader_createClassLoader_method = \n                    bundleLoader.getClass().getClassLoader().loadClass(\"org.eclipse.osgi.internal.loader.BundleLoader\").getDeclaredMethod(\"createClassLoader\", new Class[] {});\n                Equinox_BundleLoader_createClassLoader_method.setAccessible(true);\n            }\n            return (ClassLoader) Equinox_BundleLoader_createClassLoader_method.invoke(bundleLoader, new Object[] {});\n        }\n        catch (Throwable t)\n        {\n            LOG.warn(t);\n        }\n        LOG.warn(\"No classloader for equinox platform for bundle \"+bundle.getSymbolicName());\n        return null;\n    }","id":32215,"modified_method":"/**\n     * @param bundle\n     * @return\n     */\n    private static ClassLoader internalGetEquinoxBundleClassLoader(Bundle bundle)\n    {\n        if (osgiContainer == OSGiContainerType.EquinoxOld)\n        {\n            try\n            {\n                if (Equinox_BundleHost_getBundleLoader_method == null)\n                {\n                    Equinox_BundleHost_getBundleLoader_method = \n                            Equinox_BundleHost_Class.getDeclaredMethod(\"getBundleLoader\", new Class[] {});\n                    Equinox_BundleHost_getBundleLoader_method.setAccessible(true);\n                }\n                Object bundleLoader = Equinox_BundleHost_getBundleLoader_method.invoke(bundle, new Object[] {});\n                if (Equinox_BundleLoader_createClassLoader_method == null && bundleLoader != null)\n                {\n                    Equinox_BundleLoader_createClassLoader_method = \n                            bundleLoader.getClass().getClassLoader().loadClass(\"org.eclipse.osgi.internal.loader.BundleLoader\").getDeclaredMethod(\"createClassLoader\", new Class[] {});\n                    Equinox_BundleLoader_createClassLoader_method.setAccessible(true);\n                }\n                return (ClassLoader) Equinox_BundleLoader_createClassLoader_method.invoke(bundleLoader, new Object[] {});\n            }\n            catch (ClassNotFoundException t)\n            {\n                LOG.warn(t);\n                return null;\n            }\n            catch (Throwable t)\n            {\n                LOG.warn(t);\n                return null;\n            }\n        }\n        \n        if (osgiContainer == OSGiContainerType.EquinoxLuna)\n        {\n            try\n            {\n                if (Equinox_EquinoxBundle_getModuleClassLoader_Method == null)\n                    Equinox_EquinoxBundle_getModuleClassLoader_Method = Equinox_EquinoxBundle_Class.getDeclaredMethod(\"getModuleClassLoader\", new Class[] {Boolean.TYPE});\n\n                Equinox_EquinoxBundle_getModuleClassLoader_Method.setAccessible(true);\n                return (ClassLoader)Equinox_EquinoxBundle_getModuleClassLoader_Method.invoke(bundle, new Object[] {Boolean.FALSE});\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n                return null;\n            }\n        }\n        \n        LOG.warn(\"No classloader for equinox platform for bundle \"+bundle.getSymbolicName());\n        return null;\n    }","commit_id":"90f387bc34ca9b5ed974661849ca5c51e663c0a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Only useful for equinox: on felix we get the file:// url already. Other\n     * OSGi implementations have not been tested\n     * <p>\n     * Get a URL to the content of the bundle entry that uses the file:\n     * protocol. The content of the bundle entry may be downloaded or extracted\n     * to the local file system in order to create a file: URL.\n     * \n     * @return a URL to the content of the bundle entry that uses the file:\n     *         protocol\n     *         <\/p>\n     * @throws IOException \n     */\n    public URL getFileURL(URL url) throws Exception\n \n    {\n        if (\"bundleresource\".equals(url.getProtocol()) || \"bundleentry\".equals(url.getProtocol()))\n        {\n\n            URLConnection conn = url.openConnection();\n            conn.setDefaultUseCaches(Resource.getDefaultUseCaches());\n            if (BUNDLE_URL_CONNECTION_getFileURL == null && conn.getClass().getName().equals(\"org.eclipse.osgi.framework.internal.core.BundleURLConnection\"))\n            {\n                BUNDLE_URL_CONNECTION_getFileURL = conn.getClass().getMethod(\"getFileURL\", null);\n                BUNDLE_URL_CONNECTION_getFileURL.setAccessible(true);\n            }\n            if (BUNDLE_URL_CONNECTION_getFileURL != null) { return (URL) BUNDLE_URL_CONNECTION_getFileURL.invoke(conn, null); }\n\n        }\n        return url;\n    }","id":32216,"modified_method":"/**\n     * Only useful for equinox: on felix we get the file:// url already. Other\n     * OSGi implementations have not been tested\n     * <p>\n     * Get a URL to the content of the bundle entry that uses the file:\n     * protocol. The content of the bundle entry may be downloaded or extracted\n     * to the local file system in order to create a file: URL.\n     * \n     * @return a URL to the content of the bundle entry that uses the file:\n     *         protocol\n     *         <\/p>\n     * @throws IOException \n     */\n    public URL getFileURL(URL url) throws Exception\n \n    {\n        if (\"bundleresource\".equals(url.getProtocol()) || \"bundleentry\".equals(url.getProtocol()))\n        {\n\n            URLConnection conn = url.openConnection();\n            conn.setDefaultUseCaches(Resource.getDefaultUseCaches());\n            if (BUNDLE_URL_CONNECTION_getFileURL == null \n                && \n                match (conn.getClass().getName(), BUNDLE_URL_CONNECTION_CLASSES))\n            {\n                BUNDLE_URL_CONNECTION_getFileURL = conn.getClass().getMethod(\"getFileURL\", null);\n                BUNDLE_URL_CONNECTION_getFileURL.setAccessible(true);\n            }\n            if (BUNDLE_URL_CONNECTION_getFileURL != null) { return (URL) BUNDLE_URL_CONNECTION_getFileURL.invoke(conn, null); }\n\n        }\n        return url;\n    }","commit_id":"90f387bc34ca9b5ed974661849ca5c51e663c0a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Works with equinox, felix, nuxeo and probably more. Not exactly in the\n     * spirit of OSGi but quite necessary to support self-contained webapps and\n     * other situations.\n     * \n     * @param bundle The bundle\n     * @return Its installation location as a file.\n     * @throws Exception\n     */\n    public File getBundleInstallLocation(Bundle bundle) throws Exception\n    {\n        // String installedBundles = System.getProperty(\"osgi.bundles\");\n        // grab the MANIFEST.MF's url\n        // and then do what it takes.\n        URL url = bundle.getEntry(\"/META-INF/MANIFEST.MF\");\n\n        if (url.getProtocol().equals(\"file\"))\n        {\n            // some osgi frameworks do use the file protocole directly in some\n            // situations. Do use the FileResource to transform the URL into a\n            // File: URL#toURI is broken\n            return new FileResource(url).getFile().getParentFile().getParentFile();\n        }\n        else if (url.getProtocol().equals(\"bundleentry\"))\n        {\n            // say hello to equinox who has its own protocol.\n            // we use introspection like there is no tomorrow to get access to\n            // the File\n\n            URLConnection con = url.openConnection();\n            con.setUseCaches(Resource.getDefaultUseCaches()); // work around\n            // problems where\n            // url connections\n            // cache\n            // references to\n            // jars\n\n            if (BUNDLE_ENTRY_FIELD == null)\n            {\n                BUNDLE_ENTRY_FIELD = con.getClass().getDeclaredField(\"bundleEntry\");\n                BUNDLE_ENTRY_FIELD.setAccessible(true);\n            }\n            Object bundleEntry = BUNDLE_ENTRY_FIELD.get(con);\n            if (bundleEntry.getClass().getName().equals(\"org.eclipse.osgi.baseadaptor.bundlefile.FileBundleEntry\"))\n            {\n                if (FILE_FIELD == null)\n                {\n                    FILE_FIELD = bundleEntry.getClass().getDeclaredField(\"file\");\n                    FILE_FIELD.setAccessible(true);\n                }\n                File f = (File) FILE_FIELD.get(bundleEntry);\n                return f.getParentFile().getParentFile();\n            }\n            else if (bundleEntry.getClass().getName().equals(\"org.eclipse.osgi.baseadaptor.bundlefile.ZipBundleEntry\"))\n            {\n                url = bundle.getEntry(\"/\");\n\n                con = url.openConnection();\n                con.setDefaultUseCaches(Resource.getDefaultUseCaches());\n\n                if (BUNDLE_ENTRY_FIELD == null)\n                {// this one will be a DirZipBundleEntry\n                    BUNDLE_ENTRY_FIELD = con.getClass().getDeclaredField(\"bundleEntry\");\n                    BUNDLE_ENTRY_FIELD.setAccessible(true);\n                }\n                bundleEntry = BUNDLE_ENTRY_FIELD.get(con);\n                if (BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY == null)\n                {\n                    BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY = bundleEntry.getClass().getDeclaredField(\"bundleFile\");\n                    BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY.setAccessible(true);\n                }\n                Object zipBundleFile = BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY.get(bundleEntry);\n                if (ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE == null)\n                {\n                    ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE = zipBundleFile.getClass().getDeclaredField(\"zipFile\");\n                    ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE.setAccessible(true);\n                }\n                ZipFile zipFile = (ZipFile) ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE.get(zipBundleFile);\n                return new File(zipFile.getName());\n            }\n            else if (bundleEntry.getClass().getName().equals(\"org.eclipse.osgi.baseadaptor.bundlefile.DirZipBundleEntry\"))\n            {\n                // that will not happen as we did ask for the manifest not a\n                // directory.\n            }\n        }\n        else if (\"bundle\".equals(url.getProtocol()))\n        {\n            // observed this on felix-2.0.0\n            String location = bundle.getLocation();\n            if (location.startsWith(\"file:/\"))\n            {\n                URI uri = new URI(URIUtil.encodePath(location));\n                return new File(uri);\n            }\n            else if (location.startsWith(\"file:\"))\n            {\n                // location defined in the BundleArchive m_bundleArchive\n                // it is relative to relative to the BundleArchive's\n                // m_archiveRootDir\n                File res = new File(location.substring(\"file:\".length()));\n                if (!res.exists()) { return null;\n                // Object bundleArchive = getFelixBundleArchive(bundle);\n                // File archiveRoot =\n                // getFelixBundleArchiveRootDir(bundleArchive);\n                // String currentLocation =\n                // getFelixBundleArchiveCurrentLocation(bundleArchive);\n                // System.err.println(\"Got the archive root \" +\n                // archiveRoot.getAbsolutePath()\n                // + \" current location \" + currentLocation +\n                // \" is directory ?\");\n                // res = new File(archiveRoot, currentLocation != null\n                // ? currentLocation : location.substring(\"file:\".length()));\n                }\n                return res;\n            }\n            else if (location.startsWith(\"reference:file:\"))\n            {\n                location = URLDecoder.decode(location.substring(\"reference:\".length()), \"UTF-8\");\n                File file = new File(location.substring(\"file:\".length()));\n                return file;\n            }\n        }\n        return null;\n    }","id":32217,"modified_method":"/**\n     * Works with equinox, felix, nuxeo and probably more. Not exactly in the\n     * spirit of OSGi but quite necessary to support self-contained webapps and\n     * other situations.\n     * \n     * @param bundle The bundle\n     * @return Its installation location as a file.\n     * @throws Exception\n     */\n    public File getBundleInstallLocation(Bundle bundle) throws Exception\n    {\n        // String installedBundles = System.getProperty(\"osgi.bundles\");\n        // grab the MANIFEST.MF's url\n        // and then do what it takes.\n        URL url = bundle.getEntry(\"/META-INF/MANIFEST.MF\");\n\n        if (url.getProtocol().equals(\"file\"))\n        {\n            // some osgi frameworks do use the file protocole directly in some\n            // situations. Do use the FileResource to transform the URL into a\n            // File: URL#toURI is broken\n            return new FileResource(url).getFile().getParentFile().getParentFile();\n        }\n        else if (url.getProtocol().equals(\"bundleentry\"))\n        {\n            // say hello to equinox who has its own protocol.\n            // we use introspection like there is no tomorrow to get access to\n            // the File\n\n            URLConnection con = url.openConnection();\n            con.setUseCaches(Resource.getDefaultUseCaches()); // work around\n            // problems where\n            // url connections\n            // cache\n            // references to\n            // jars\n\n            if (BUNDLE_ENTRY_FIELD == null)\n            {\n                BUNDLE_ENTRY_FIELD = con.getClass().getDeclaredField(\"bundleEntry\");\n                BUNDLE_ENTRY_FIELD.setAccessible(true);\n            }\n            Object bundleEntry = BUNDLE_ENTRY_FIELD.get(con);\n           \n            if (match(bundleEntry.getClass().getName(), FILE_BUNDLE_ENTRY_CLASSES))\n            {\n                if (FILE_FIELD == null)\n                {\n                    FILE_FIELD = bundleEntry.getClass().getDeclaredField(\"file\");\n                    FILE_FIELD.setAccessible(true);\n                }\n                File f = (File) FILE_FIELD.get(bundleEntry);\n                return f.getParentFile().getParentFile();\n            }\n            else if (match(bundleEntry.getClass().getName(), ZIP_BUNDLE_ENTRY_CLASSES))\n            {\n                url = bundle.getEntry(\"/\");\n\n                con = url.openConnection();\n                con.setDefaultUseCaches(Resource.getDefaultUseCaches());\n\n                if (BUNDLE_ENTRY_FIELD == null)\n                {// this one will be a DirZipBundleEntry\n                    BUNDLE_ENTRY_FIELD = con.getClass().getDeclaredField(\"bundleEntry\");\n                    BUNDLE_ENTRY_FIELD.setAccessible(true);\n                }\n                bundleEntry = BUNDLE_ENTRY_FIELD.get(con);\n                if (BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY == null)\n                {\n                    BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY = bundleEntry.getClass().getDeclaredField(\"bundleFile\");\n                    BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY.setAccessible(true);\n                }\n                Object zipBundleFile = BUNDLE_FILE_FIELD_FOR_DIR_ZIP_BUNDLE_ENTRY.get(bundleEntry);\n                if (ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE == null)\n                {\n                    ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE = zipBundleFile.getClass().getDeclaredField(\"zipFile\");\n                    ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE.setAccessible(true);\n                }\n                ZipFile zipFile = (ZipFile) ZIP_FILE_FILED_FOR_ZIP_BUNDLE_FILE.get(zipBundleFile);\n                return new File(zipFile.getName());\n            }\n            else if (match (bundleEntry.getClass().getName(), DIR_ZIP_BUNDLE_ENTRY_CLASSES))\n            {\n                // that will not happen as we did ask for the manifest not a\n                // directory.\n            }\n        }\n        else if (\"bundle\".equals(url.getProtocol()))\n        {\n            // observed this on felix-2.0.0\n            String location = bundle.getLocation();\n            if (location.startsWith(\"file:/\"))\n            {\n                URI uri = new URI(URIUtil.encodePath(location));\n                return new File(uri);\n            }\n            else if (location.startsWith(\"file:\"))\n            {\n                // location defined in the BundleArchive m_bundleArchive\n                // it is relative to relative to the BundleArchive's\n                // m_archiveRootDir\n                File res = new File(location.substring(\"file:\".length()));\n                if (!res.exists()) { return null;\n                // Object bundleArchive = getFelixBundleArchive(bundle);\n                // File archiveRoot =\n                // getFelixBundleArchiveRootDir(bundleArchive);\n                // String currentLocation =\n                // getFelixBundleArchiveCurrentLocation(bundleArchive);\n                // System.err.println(\"Got the archive root \" +\n                // archiveRoot.getAbsolutePath()\n                // + \" current location \" + currentLocation +\n                // \" is directory ?\");\n                // res = new File(archiveRoot, currentLocation != null\n                // ? currentLocation : location.substring(\"file:\".length()));\n                }\n                return res;\n            }\n            else if (location.startsWith(\"reference:file:\"))\n            {\n                location = URLDecoder.decode(location.substring(\"reference:\".length()), \"UTF-8\");\n                File file = new File(location.substring(\"file:\".length()));\n                return file;\n            }\n        }\n        return null;\n    }","commit_id":"90f387bc34ca9b5ed974661849ca5c51e663c0a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Only useful for equinox: on felix we get the file:// or jar:// url\n     * already. Other OSGi implementations have not been tested\n     * <p>\n     * Get a URL to the bundle entry that uses a common protocol (i.e. file:\n     * jar: or http: etc.).\n     * <\/p>\n     * \n     * @return a URL to the bundle entry that uses a common protocol\n     */\n    public URL getLocalURL(URL url)\n    throws Exception\n    {\n        if (\"bundleresource\".equals(url.getProtocol()) || \"bundleentry\".equals(url.getProtocol()))\n        {\n\n            URLConnection conn = url.openConnection();\n            conn.setDefaultUseCaches(Resource.getDefaultUseCaches());\n            if (BUNDLE_URL_CONNECTION_getLocalURL == null && conn.getClass().getName().equals(\"org.eclipse.osgi.framework.internal.core.BundleURLConnection\"))\n            {\n                BUNDLE_URL_CONNECTION_getLocalURL = conn.getClass().getMethod(\"getLocalURL\", null);\n                BUNDLE_URL_CONNECTION_getLocalURL.setAccessible(true);\n            }\n            if (BUNDLE_URL_CONNECTION_getLocalURL != null) { return (URL) BUNDLE_URL_CONNECTION_getLocalURL.invoke(conn, null); }\n        }\n        return url;\n    }","id":32218,"modified_method":"/**\n     * Only useful for equinox: on felix we get the file:// or jar:// url\n     * already. Other OSGi implementations have not been tested\n     * <p>\n     * Get a URL to the bundle entry that uses a common protocol (i.e. file:\n     * jar: or http: etc.).\n     * <\/p>\n     * \n     * @return a URL to the bundle entry that uses a common protocol\n     */\n    public URL getLocalURL(URL url)\n    throws Exception\n    {\n        if (\"bundleresource\".equals(url.getProtocol()) || \"bundleentry\".equals(url.getProtocol()))\n        {\n\n            URLConnection conn = url.openConnection();\n            conn.setDefaultUseCaches(Resource.getDefaultUseCaches());\n            if (BUNDLE_URL_CONNECTION_getLocalURL == null && match(conn.getClass().getName(), BUNDLE_URL_CONNECTION_CLASSES))\n            {\n                BUNDLE_URL_CONNECTION_getLocalURL = conn.getClass().getMethod(\"getLocalURL\", null);\n                BUNDLE_URL_CONNECTION_getLocalURL.setAccessible(true);\n            }\n            if (BUNDLE_URL_CONNECTION_getLocalURL != null) { return (URL) BUNDLE_URL_CONNECTION_getLocalURL.invoke(conn, null); }\n        }\n        return url;\n    }","commit_id":"90f387bc34ca9b5ed974661849ca5c51e663c0a9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public AutoScalingQueryBinding() {\n    super( AUTOSCALING_NAMESPACE_PATTERN, AUTOSCALING_DEFAULT_VERSION, OperationParameter.Action );\n  }","id":32219,"modified_method":"public AutoScalingQueryBinding() {\n    super( AUTOSCALING_NAMESPACE_PATTERN, AUTOSCALING_DEFAULT_VERSION, OperationParameter.Action, OperationParameter.Operation );\n  }","commit_id":"45189a1ea3e4461ce52e131ac0975fbf2b570312","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"rawtypes\" )\n  private List<String> populateObjectList( final GroovyObject obj, final Map.Entry<String, String> paramFieldPair, final Map<String, String> params, final int paramSize ) {\n    final List<String> failedMappings = new ArrayList<String>( );\n    try {\n      final Field declaredField = getRecursiveField( obj.getClass( ), paramFieldPair.getValue( ) );\n      final ArrayList theList = ( ArrayList ) obj.getProperty( paramFieldPair.getValue( ) );\n      final Class genericType = ( Class ) ( ( ParameterizedType ) declaredField.getGenericType( ) ).getActualTypeArguments( )[0];\n      // :: simple case: FieldName.# :://\n      if ( String.class.equals( genericType ) ) {\n        if ( params.containsKey( paramFieldPair.getKey( ) ) ) {\n          theList.add( params.remove( paramFieldPair.getKey( ) ) );\n        } else {\n          final List<String> keys = Lists.newArrayList( params.keySet( ) );\n          for ( final String k : keys ) {\n            if ( k.matches( paramFieldPair.getKey( ) + \"\\\\.\\\\d*\" ) ) {\n              theList.add( params.remove( k ) );\n            }\n          }\n        }\n      } else if ( declaredField.isAnnotationPresent( HttpEmbedded.class ) ) {\n        final HttpEmbedded annoteEmbedded = ( HttpEmbedded ) declaredField.getAnnotation( HttpEmbedded.class );\n        // :: build the parameter map and call populate object recursively :://\n        if ( annoteEmbedded.multiple( ) ) {\n          final List<String> keys = Lists.newArrayList( params.keySet( ) );\n          final Map<String,Map<String,String>> subParamMaps = new TreeMap<String,Map<String,String>>( Ordering.natural().onResultOf( FunctionToInteger.INSTANCE ) );\n          for ( final String k : keys ) {            \n            if ( k.startsWith( paramFieldPair.getKey( ) + \".\" ) ) {\n              final String currentValue = params.remove( k );\n              final String setKey = k.replaceAll( paramFieldPair.getKey( ) + \"\\\\.(\\\\d+)\\\\..*\", \"$1\" );\n              final String subKey = k.replaceAll( paramFieldPair.getKey( ) + \"\\\\.\\\\d+\\\\.\" , \"\" );\n              Map<String,String> subMap = subParamMaps.get( setKey );\n              if ( subMap == null ) {\n                subParamMaps.put( setKey, subMap = Maps.newHashMap() );  \n              }\n\n              subMap.put( subKey, currentValue );\n            }\n          }\n          \n          for ( final Map<String,String> subParams : subParamMaps.values() ) {\n            failedMappings.addAll( this.populateEmbedded( genericType, subParams, theList ) );\n          }\n        } else {\n          failedMappings.addAll( this.populateEmbedded( genericType, params, theList ) );\n        }\n      }\n    } catch ( final Exception e1 ) {\n      LOG.debug( \"FAILED HERE : \", e1 );\n      failedMappings.add( paramFieldPair.getKey( ) );\n    }\n    return failedMappings;\n  }","id":32220,"modified_method":"@SuppressWarnings( \"rawtypes\" )\n  private List<String> populateObjectList( final GroovyObject obj, final Map.Entry<String, String> paramFieldPair, final Map<String, String> params, final int paramSize ) {\n    final List<String> failedMappings = new ArrayList<String>( );\n    try {\n      final Field declaredField = getRecursiveField( obj.getClass( ), paramFieldPair.getValue( ) );\n      final ArrayList theList = ( ArrayList ) obj.getProperty( paramFieldPair.getValue( ) );\n      final Class genericType = ( Class ) ( ( ParameterizedType ) declaredField.getGenericType( ) ).getActualTypeArguments( )[0];\n      // :: simple case: FieldName.# :://\n      if ( String.class.equals( genericType ) ||\n           Boolean.class.equals( genericType ) ||\n           Integer.class.equals( genericType ) ||\n           Long.class.equals( genericType ) ||\n           Double.class.equals( genericType ) ||\n           Date.class.equals( genericType ) ) {\n        if ( params.containsKey( paramFieldPair.getKey( ) ) ) {\n          theList.add( convertToType( Suppliers.ofInstance(params.remove( paramFieldPair.getKey() )), genericType ) );\n        } else {\n          final List<String> keys = Lists.newArrayList( params.keySet( ) );\n          final Pattern paramPattern = Pattern.compile( Pattern.quote(paramFieldPair.getKey( )) + \"\\\\.([1-9][0-9]*)\" );\n          final Map<String,Object> indexToValueMap = new TreeMap<String,Object>( Ordering.natural().onResultOf( FunctionToInteger.INSTANCE ) );\n          for ( final String k : keys ) {    \n            final Matcher matcher = paramPattern.matcher( k );\n            if ( matcher.matches() ) {\n              indexToValueMap.put( matcher.group(1), convertToType( Suppliers.ofInstance(params.remove( k )), genericType )  );\n            }\n          }\n          theList.addAll( indexToValueMap.values() );\n        }\n      } else if ( declaredField.isAnnotationPresent( HttpEmbedded.class ) ) {\n        final HttpEmbedded annoteEmbedded = declaredField.getAnnotation( HttpEmbedded.class );\n        // :: build the parameter map and call populate object recursively :://\n        if ( annoteEmbedded.multiple( ) ) {\n          final List<String> keys = Lists.newArrayList( params.keySet( ) );\n          final Map<String,Map<String,String>> subParamMaps = new TreeMap<String,Map<String,String>>( Ordering.natural().onResultOf( FunctionToInteger.INSTANCE ) );\n          for ( final String k : keys ) {            \n            if ( k.startsWith( paramFieldPair.getKey( ) + \".\" ) ) {\n              final String currentValue = params.remove( k );\n              final String setKey = k.replaceAll( paramFieldPair.getKey( ) + \"\\\\.(\\\\d+)\\\\..*\", \"$1\" );\n              final String subKey = k.replaceAll( paramFieldPair.getKey( ) + \"\\\\.\\\\d+\\\\.\" , \"\" );\n              Map<String,String> subMap = subParamMaps.get( setKey );\n              if ( subMap == null ) {\n                subParamMaps.put( setKey, subMap = Maps.newHashMap() );  \n              }\n\n              subMap.put( subKey, currentValue );\n            }\n          }\n          \n          for ( final Map<String,String> subParams : subParamMaps.values() ) {\n            failedMappings.addAll( this.populateEmbedded( genericType, subParams, theList ) );\n          }\n        } else {\n          failedMappings.addAll( this.populateEmbedded( genericType, params, theList ) );\n        }\n      }\n    } catch ( final Exception e1 ) {\n      LOG.debug( \"FAILED HERE : \", e1 );\n      failedMappings.add( paramFieldPair.getKey( ) );\n    }\n    return failedMappings;\n  }","commit_id":"45189a1ea3e4461ce52e131ac0975fbf2b570312","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private List<String> populateObject( final GroovyObject obj, final Map<String, String> paramFieldMap, final Map<String, String> params ) {\n    final List<String> failedMappings = new ArrayList<String>( );\n    for ( final Map.Entry<String, String> e : paramFieldMap.entrySet( ) ) {\n      try {\n        if ( getRecursiveField( obj.getClass( ), e.getValue( ) ).getType( ).equals( ArrayList.class ) ) {\n          failedMappings.addAll( this.populateObjectList( obj, e, params, params.size( ) ) );\n        }\n      } catch ( final Exception e1 ) {\n        LOG.debug( \"Failed mapping : \", e1 );\n        failedMappings.add( e.getKey( ) );\n      }\n    }\n    \n    Class<?> declaredType = null;\n    \n    for ( final Map.Entry<String, String> e : paramFieldMap.entrySet( ) ) {\n      \n      try {\n        declaredType = getRecursiveField( obj.getClass( ), e.getValue( ) ).getType( );\n      } catch ( final Exception e2 ) {\n        e2.printStackTrace( );\n      }\n      \n      if ( params.containsKey( e.getKey( ) )\n           && !this.populateObjectField( obj, e, params ) ) {\n        failedMappings.add( e.getKey( ) );\n      } else if ( ( declaredType != null )\n                  && EucalyptusData.class.isAssignableFrom( declaredType ) ) {\n        try {\n          final Map<String, String> fieldMap = this\n                                                   .buildFieldMap( declaredType );\n          final Object newInstance = declaredType.newInstance( );\n          final Map<String, String> subParams = Maps.newHashMap( );\n          \n          for ( final String item : Sets.newHashSet( params.keySet( ) ) ) {\n            if ( item.startsWith( e.getKey( ) ) ) {\n              params.get( item );\n              subParams.put( item.replace( e.getKey( ) + \".\", \"\" ), params.remove( item ) );\n            }\n          }\n          this.populateObject( ( GroovyObject ) newInstance, fieldMap, subParams );\n          obj.setProperty( e.getValue( ), newInstance );\n        } catch ( final Exception e1 ) {\n          // TODO Auto-generated catch block\n          e1.printStackTrace( );\n        }\n      } else {\n        failedMappings.remove( e.getKey( ) );\n      }\n      \n    }\n    return failedMappings;\n  }","id":32221,"modified_method":"private List<String> populateObject( final GroovyObject obj, final Map<String, String> paramFieldMap, final Map<String, String> params ) {\n    final List<String> failedMappings = new ArrayList<String>( );\n    for ( final Map.Entry<String, String> e : paramFieldMap.entrySet( ) ) {\n      try {\n        if ( getRecursiveField( obj.getClass( ), e.getValue( ) ).getType( ).equals( ArrayList.class ) ) {\n          failedMappings.addAll( this.populateObjectList( obj, e, params, params.size( ) ) );\n        }\n      } catch ( final Exception e1 ) {\n        LOG.debug( \"Failed mapping : \", e1 );\n        failedMappings.add( e.getKey( ) );\n      }\n    }\n    \n    for ( final Map.Entry<String, String> e : paramFieldMap.entrySet( ) ) {\n      Class<?> declaredType = null;\n      try {\n        declaredType = getRecursiveField( obj.getClass( ), e.getValue( ) ).getType( );\n      } catch ( final Exception e2 ) {\n        LOG.debug( \"Field not found: \" + e.getValue(), e2 );\n      }\n      \n      if ( params.containsKey( e.getKey( ) )\n           && !this.populateObjectField( obj, e, params ) ) {\n        failedMappings.add( e.getKey( ) );\n      } else if ( ( declaredType != null )\n                  && EucalyptusData.class.isAssignableFrom( declaredType ) ) {\n        try {\n          final Map<String, String> fieldMap = this.buildFieldMap( declaredType );\n          final Object newInstance = declaredType.newInstance( );\n          final Map<String, String> subParams = Maps.newHashMap( );\n          \n          for ( final String item : Sets.newHashSet( params.keySet( ) ) ) {\n            if ( item.startsWith( e.getKey( ) ) ) {\n              params.get( item );\n              subParams.put( item.replace( e.getKey( ) + \".\", \"\" ), params.remove( item ) );\n            }\n          }\n          this.populateObject( ( GroovyObject ) newInstance, fieldMap, subParams );\n          obj.setProperty( e.getValue( ), newInstance );\n        } catch ( final Exception e1 ) {\n          LOG.debug( \"Error binding object\", e1 );\n        }\n      } else {\n        failedMappings.remove( e.getKey( ) );\n      }\n      \n    }\n    return failedMappings;\n  }","commit_id":"45189a1ea3e4461ce52e131ac0975fbf2b570312","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public Object bind( final MappingHttpRequest httpRequest ) throws BindingException {\n    final String operationName = this.extractOperationName( httpRequest );\n    final String operationNameType = operationName + \"Type\";\n    for ( final T op : this.possibleParams )\n      httpRequest.getParameters( ).remove( op.name( ) );\n    final Map<String, String> params = httpRequest.getParameters( );\n    \n    BaseMessage eucaMsg = null;\n    Map<String, String> fieldMap = null;\n    Class<?> targetType = null;\n    Binding currentBinding = null;\n    try {\n      if ( this.getBinding( ).hasElementClass( operationName ) ) {\n        currentBinding = this.getBinding( );\n        targetType = currentBinding.getElementClass( operationName );\n      } else if ( this.getBinding( ).hasElementClass( operationNameType ) ) {\n        currentBinding = this.getBinding( );\n        targetType = currentBinding.getElementClass( operationNameType );\n      } else if ( this.getDefaultBinding( ).hasElementClass( operationName ) ) {\n        currentBinding = this.getDefaultBinding( );\n        targetType = currentBinding.getElementClass( operationName );\n      } else if ( this.getDefaultBinding( ).hasElementClass( operationNameType ) ) {\n        currentBinding = this.getDefaultBinding( );\n        targetType = currentBinding.getElementClass( operationNameType );\n      } else if ( BindingManager.getDefaultBinding( ).hasElementClass( operationName ) ) {\n        currentBinding = BindingManager.getDefaultBinding( );\n        targetType = currentBinding.getElementClass( operationName );\n      } else if ( BindingManager.getDefaultBinding( ).hasElementClass( operationNameType ) ) {\n        currentBinding = BindingManager.getDefaultBinding( );\n        targetType = currentBinding.getElementClass( operationNameType );\n      } else {//this will necessarily fault.\n        try {\n          targetType = this.getBinding( ).getElementClass( operationName );\n        } catch ( final BindingException ex ) {\n          LOG.error( ex, ex );\n          throw ex;\n        }\n      }\n      fieldMap = this.buildFieldMap( targetType );\n      eucaMsg = ( BaseMessage ) targetType.newInstance( );\n    } catch ( final BindingException e ) {\n      LOG.debug( \"Failed to construct message of type: \" + operationName, e );\n      LOG.error( e, e );\n      throw e;\n    } catch ( final Exception e ) {\n      throw new BindingException( \"Failed to construct message of type \" + operationName, e );\n    }\n    \n    final List<String> failedMappings = this.populateObject( ( GroovyObject ) eucaMsg, fieldMap, params );\n    \n    if ( !failedMappings.isEmpty( ) || !params.isEmpty( ) ) {\n      final StringBuilder errMsg = new StringBuilder( \"Failed to bind the following fields:\\n\" );\n      for ( final String f : failedMappings )\n        errMsg.append( f ).append( '\\n' );\n      for ( final Map.Entry<String, String> f : params.entrySet( ) )\n        errMsg.append( f.getKey( ) ).append( \" = \" ).append( f.getValue( ) ).append( '\\n' );\n      throw new BindingException( errMsg.toString( ) );\n    }\n    \n    try {\n      currentBinding.toOM( eucaMsg, this.getNamespace( ) );\n    } catch ( final RuntimeException e ) {\n      LOG.error( \"Falling back to default (unvalidated) binding for: \" + operationName + \" with params=\" + params );\n      LOG.error( \"Failed to build a valid message: \" + e.getMessage( ), e );\n      try {\n        BindingManager.getDefaultBinding( ).toOM( eucaMsg, BindingManager.defaultBindingNamespace( ) );\n      } catch ( final RuntimeException ex ) {\n        throw new BindingException( \"Default binding failed to build a valid message: \" + ex.getMessage( ), ex );\n      }\n    }\n    return eucaMsg;\n  }","id":32222,"modified_method":"@Override\n  public Object bind( final MappingHttpRequest httpRequest ) throws BindingException {\n    final String operationName = this.extractOperationName( httpRequest );\n    final String operationNameType = operationName + \"Type\";\n    for ( final T op : this.possibleParams )\n      httpRequest.getParameters( ).remove( op.name( ) );\n    final Map<String, String> params = httpRequest.getParameters( );\n    \n    BaseMessage eucaMsg;\n    Map<String, String> fieldMap;\n    Binding currentBinding;\n    try {\n      currentBinding = getBindingWithElementClass( operationName );\n      Class<?> targetType = currentBinding==null ? null : currentBinding.getElementClass( operationName );\n      if ( currentBinding == null ) {\n        currentBinding = getBindingWithElementClass( operationNameType );\n        targetType = currentBinding==null ? null : currentBinding.getElementClass( operationNameType );\n      }\n      if ( currentBinding == null ) {\n        //this will necessarily fault.\n        try {\n          targetType = this.getBinding( ).getElementClass( operationName );\n        } catch ( final BindingException ex ) {\n          LOG.error( ex, ex );\n          throw ex;\n        }\n      }\n      fieldMap = this.buildFieldMap( targetType );\n      eucaMsg = ( BaseMessage ) targetType.newInstance( );\n    } catch ( final BindingException e ) {\n      LOG.debug( \"Failed to construct message of type: \" + operationName, e );\n      LOG.error( e, e );\n      throw e;\n    } catch ( final Exception e ) {\n      throw new BindingException( \"Failed to construct message of type \" + operationName, e );\n    }\n    \n    final List<String> failedMappings = this.populateObject( ( GroovyObject ) eucaMsg, fieldMap, params );\n    \n    if ( !failedMappings.isEmpty( ) || !params.isEmpty( ) ) {\n      final StringBuilder errMsg = new StringBuilder( \"Failed to bind the following fields:\\n\" );\n      for ( final String f : failedMappings )\n        errMsg.append( f ).append( '\\n' );\n      for ( final Map.Entry<String, String> f : params.entrySet( ) )\n        errMsg.append( f.getKey( ) ).append( \" = \" ).append( f.getValue( ) ).append( '\\n' );\n      throw new BindingException( errMsg.toString( ) );\n    }\n\n    validateBinding( currentBinding, operationName, params, eucaMsg );\n    \n    return eucaMsg;\n  }","commit_id":"45189a1ea3e4461ce52e131ac0975fbf2b570312","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private final String extractOperationName( final MappingHttpRequest httpRequest ) {\n    if ( httpRequest.getParameters( ).containsKey( this.operationParam.toString( ) ) ) {\n      return httpRequest.getParameters( ).get( this.operationParam.toString( ) );\n    } else {\n      for ( final T param : this.altOperationParams ) {\n        if ( httpRequest.getParameters( ).containsKey( param.toString( ) ) ) {\n          return httpRequest.getParameters( ).get( this.operationParam.toString( ) );\n        }\n      }\n    }\n    LOG.error( \"Failed to find operation parameter an \" + Lists.asList( this.operationParam, this.altOperationParams.toArray( ) ).toString( )\n               + \" in HTTP request: \" + httpRequest );\n    return null;\n  }","id":32223,"modified_method":"private String extractOperationName( final MappingHttpRequest httpRequest ) {\n    if ( httpRequest.getParameters( ).containsKey( this.operationParam.toString( ) ) ) {\n      return httpRequest.getParameters( ).get( this.operationParam.toString( ) );\n    } else {\n      for ( final T param : this.altOperationParams ) {\n        if ( httpRequest.getParameters( ).containsKey( param.toString( ) ) ) {\n          return httpRequest.getParameters( ).get( param.toString( ) );\n        }\n      }\n    }\n    LOG.error( \"Failed to find operation parameter an \" + Lists.asList( this.operationParam, this.altOperationParams.toArray( ) ).toString( )\n               + \" in HTTP request: \" + httpRequest );\n    return null;\n  }","commit_id":"45189a1ea3e4461ce52e131ac0975fbf2b570312","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static Field getRecursiveField( Class<?> clazz, final String fieldName ) throws Exception {\n    Field ret = null;\n    Exception e = null;\n    while ( !BaseMessage.class.equals( clazz ) || !Object.class.equals( clazz ) ) {\n      try {\n        ret = clazz.getDeclaredField( fieldName );\n        return ret;\n      } catch ( final Exception e1 ) {\n        e = e1;\n        \n      }\n      clazz = clazz.getSuperclass( );\n    }\n    if ( ret == null ) {\n      throw e;\n    }\n    return ret;\n  }","id":32224,"modified_method":"private static Field getRecursiveField( Class<?> clazz, final String fieldName ) throws Exception {\n    Exception e = null;\n    while ( !BaseMessage.class.equals( clazz ) && !Object.class.equals( clazz ) ) {\n      try {\n        return clazz.getDeclaredField( fieldName );\n      } catch ( final Exception e1 ) {\n        e = e1;        \n      }\n      clazz = clazz.getSuperclass( );\n    }\n    if ( e == null ) throw new Exception(\"Class not supported: \" + clazz);\n    throw e;\n  }","commit_id":"45189a1ea3e4461ce52e131ac0975fbf2b570312","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n  private boolean populateObjectField( final GroovyObject obj, final Map.Entry<String, String> paramFieldPair, final Map<String, String> params ) {\n    try {\n      final Class<?> declaredType = getRecursiveField( obj.getClass( ), paramFieldPair.getValue( ) ).getType( );\n      if ( declaredType.equals( String.class ) )\n        obj.setProperty( paramFieldPair.getValue( ), params.remove( paramFieldPair.getKey( ) ) );\n      else if ( declaredType.getName( ).equals( \"int\" ) )\n        obj.setProperty( paramFieldPair.getValue( ), Integer.parseInt( params.remove( paramFieldPair.getKey( ) ) ) );\n      else if ( declaredType.equals( Integer.class ) )\n        obj.setProperty( paramFieldPair.getValue( ), new Integer( params.remove( paramFieldPair.getKey( ) ) ) );\n      else if ( declaredType.getName( ).equals( \"boolean\" ) )\n        obj.setProperty( paramFieldPair.getValue( ), Boolean.parseBoolean( params.remove( paramFieldPair.getKey( ) ) ) );\n      else if ( declaredType.equals( Boolean.class ) )\n        obj.setProperty( paramFieldPair.getValue( ), new Boolean( params.remove( paramFieldPair.getKey( ) ) ) );\n      else if ( declaredType.getName( ).equals( \"long\" ) )\n        obj.setProperty( paramFieldPair.getValue( ), Long.parseLong( params.remove( paramFieldPair.getKey( ) ) ) );\n      else if ( declaredType.equals( Long.class ) )\n        obj.setProperty( paramFieldPair.getValue( ), new Long( params.remove( paramFieldPair.getKey( ) ) ) );\n      else return false;\n      return true;\n      \n    } catch ( final Exception e1 ) {\n      return false;\n    }\n  }","id":32225,"modified_method":"@SuppressWarnings( \"unchecked\" )\n  private boolean populateObjectField( final GroovyObject obj, final Map.Entry<String, String> paramFieldPair, final Map<String, String> params ) {\n    try {\n      final Class<?> declaredType = getRecursiveField( obj.getClass( ), paramFieldPair.getValue( ) ).getType( );\n      final Object value = convertToType( new Supplier<String>(){\n        @Override\n        public String get() {\n          return params.remove( paramFieldPair.getKey() );\n        }\n      }, declaredType );\n\n      if ( value != null )\n        obj.setProperty( paramFieldPair.getValue( ), value );\n      \n      return !params.containsKey( paramFieldPair.getKey() );\n    } catch ( final Exception e1 ) {\n      return false;\n    }\n  }","commit_id":"45189a1ea3e4461ce52e131ac0975fbf2b570312","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected void setUpDDMFormFieldTypesJSONSerializer() throws Exception {\n\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\tDDMFormFieldTypesJSONSerializerImpl.class,\n\t\t\t\"_ddmFormJSONSerializer\");\n\n\t\tfield.set(\n\t\t\t_ddmFormFieldTypesJSONSerializer, new DDMFormJSONSerializerImpl());\n\n\t\tfield = ReflectionUtil.getDeclaredField(\n\t\t\tDDMFormFieldTypesJSONSerializerImpl.class,\n\t\t\t\"_ddmFormFieldTypeServicesTracker\");\n\n\t\tfield.set(\n\t\t\t_ddmFormFieldTypesJSONSerializer,\n\t\t\tgetMockedDDMFormFieldTypeServicesTracker());\n\t}","id":32226,"modified_method":"protected void setUpDDMFormFieldTypesJSONSerializer() throws Exception {\n\n\t\t// DDMFormFieldType Services Tracker\n\n\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\tDDMFormFieldTypesJSONSerializerImpl.class,\n\t\t\t\"_ddmFormFieldTypeServicesTracker\");\n\n\t\tfield.set(\n\t\t\t_ddmFormFieldTypesJSONSerializer,\n\t\t\tgetMockedDDMFormFieldTypeServicesTracker());\n\n\t\t// DDMForm JSON Serializer\n\n\t\tfield = ReflectionUtil.getDeclaredField(\n\t\t\tDDMFormFieldTypesJSONSerializerImpl.class,\n\t\t\t\"_ddmFormJSONSerializer\");\n\n\t\tfield.set(\n\t\t\t_ddmFormFieldTypesJSONSerializer, new DDMFormJSONSerializerImpl());\n\n\t\t// DDMFormLayout JSON Serializer\n\n\t\tfield = ReflectionUtil.getDeclaredField(\n\t\t\tDDMFormFieldTypesJSONSerializerImpl.class,\n\t\t\t\"_ddmFormLayoutJSONSerializer\");\n\n\t\tfield.set(\n\t\t\t_ddmFormFieldTypesJSONSerializer,\n\t\t\tnew DDMFormLayoutJSONSerializerImpl());\n\n\t\t// JSON factory\n\n\t\tfield = ReflectionUtil.getDeclaredField(\n\t\t\tDDMFormFieldTypesJSONSerializerImpl.class, \"_jsonFactory\");\n\n\t\tfield.set(_ddmFormFieldTypesJSONSerializer, new JSONFactoryImpl());\n\t}","commit_id":"00ab9a60399c621b9687aeffff646c14bddf20ab","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static com.liferay.portlet.trash.model.TrashEntry moveEntry(\n\t\tHttpPrincipal httpPrincipal, java.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(TrashEntryServiceUtil.class,\n\t\t\t\t\t\"moveEntry\", _moveEntryParameterTypes6);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey,\n\t\t\t\t\tclassName, classPK, destinationContainerModelId,\n\t\t\t\t\tserviceContext);\n\n\t\t\tObject returnObj = null;\n\n\t\t\ttry {\n\t\t\t\treturnObj = TunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\n\t\t\treturn (com.liferay.portlet.trash.model.TrashEntry)returnObj;\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","id":32227,"modified_method":"public static void moveEntry(HttpPrincipal httpPrincipal,\n\t\tjava.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(TrashEntryServiceUtil.class,\n\t\t\t\t\t\"moveEntry\", _moveEntryParameterTypes6);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey,\n\t\t\t\t\tclassName, classPK, destinationContainerModelId,\n\t\t\t\t\tserviceContext);\n\n\t\t\ttry {\n\t\t\t\tTunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","commit_id":"7a477c650dea94087e90c191116b5b41a297d0ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t* Moves the trash entry with the entity class name and primary key,\n\t* restoring it to a new location identified by the destination container\n\t* model ID.\n\t*\n\t* <p>\n\t* This method throws a {@link TrashPermissionException} if the user did not\n\t* have the permission to perform one of the necessary operations. The\n\t* exception is created with a type specific to the operation:\n\t* <\/p>\n\t*\n\t* <ul>\n\t* <li>\n\t* {@link TrashPermissionException#MOVE} - if the user did not have\n\t* permission to move the trash entry to the new\n\t* destination\n\t* <\/li>\n\t* <li>\n\t* {@link TrashPermissionException#RESTORE} - if the user did not have\n\t* permission to restore the trash entry\n\t* <\/li>\n\t* <\/ul>\n\t*\n\t* @param className the class name of the entity\n\t* @param classPK the primary key of the entity\n\t* @param destinationContainerModelId the primary key of the new location\n\t* @param serviceContext the service context to be applied (optionally\n\t<code>null<\/code>)\n\t* @throws PortalException if a matching trash entry could not be found, if\n\tthe user did not have permission to move the trash entry to the\n\tnew location, if the user did not have permission to restore the\n\ttrash entry, if a duplicate trash entry exists at the new\n\tlocation, or if a portal exception occurred\n\t*/\n\tpublic static com.liferay.portlet.trash.model.TrashEntrySoap moveEntry(\n\t\tjava.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows RemoteException {\n\t\ttry {\n\t\t\tcom.liferay.portlet.trash.model.TrashEntry returnValue = TrashEntryServiceUtil.moveEntry(className,\n\t\t\t\t\tclassPK, destinationContainerModelId, serviceContext);\n\n\t\t\treturn com.liferay.portlet.trash.model.TrashEntrySoap.toSoapModel(returnValue);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new RemoteException(e.getMessage());\n\t\t}\n\t}","id":32228,"modified_method":"/**\n\t* Moves the trash entry with the entity class name and primary key,\n\t* restoring it to a new location identified by the destination container\n\t* model ID.\n\t*\n\t* <p>\n\t* This method throws a {@link TrashPermissionException} if the user did not\n\t* have the permission to perform one of the necessary operations. The\n\t* exception is created with a type specific to the operation:\n\t* <\/p>\n\t*\n\t* <ul>\n\t* <li>\n\t* {@link TrashPermissionException#MOVE} - if the user did not have\n\t* permission to move the trash entry to the new\n\t* destination\n\t* <\/li>\n\t* <li>\n\t* {@link TrashPermissionException#RESTORE} - if the user did not have\n\t* permission to restore the trash entry\n\t* <\/li>\n\t* <\/ul>\n\t*\n\t* @param className the class name of the entity\n\t* @param classPK the primary key of the entity\n\t* @param destinationContainerModelId the primary key of the new location\n\t* @param serviceContext the service context to be applied (optionally\n\t<code>null<\/code>)\n\t* @throws PortalException if a matching trash entry could not be found, if\n\tthe user did not have permission to move the trash entry to the\n\tnew location, if the user did not have permission to restore the\n\ttrash entry, if a duplicate trash entry exists at the new\n\tlocation, or if a portal exception occurred\n\t*/\n\tpublic static void moveEntry(java.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows RemoteException {\n\t\ttry {\n\t\t\tTrashEntryServiceUtil.moveEntry(className, classPK,\n\t\t\t\tdestinationContainerModelId, serviceContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new RemoteException(e.getMessage());\n\t\t}\n\t}","commit_id":"7a477c650dea94087e90c191116b5b41a297d0ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t* Moves the trash entry with the entity class name and primary key,\n\t* restoring it to a new location identified by the destination container\n\t* model ID.\n\t*\n\t* <p>\n\t* This method throws a {@link TrashPermissionException} if the user did not\n\t* have the permission to perform one of the necessary operations. The\n\t* exception is created with a type specific to the operation:\n\t* <\/p>\n\t*\n\t* <ul>\n\t* <li>\n\t* {@link TrashPermissionException#MOVE} - if the user did not have\n\t* permission to move the trash entry to the new\n\t* destination\n\t* <\/li>\n\t* <li>\n\t* {@link TrashPermissionException#RESTORE} - if the user did not have\n\t* permission to restore the trash entry\n\t* <\/li>\n\t* <\/ul>\n\t*\n\t* @param className the class name of the entity\n\t* @param classPK the primary key of the entity\n\t* @param destinationContainerModelId the primary key of the new location\n\t* @param serviceContext the service context to be applied (optionally\n\t<code>null<\/code>)\n\t* @throws PortalException if a matching trash entry could not be found, if\n\tthe user did not have permission to move the trash entry to the\n\tnew location, if the user did not have permission to restore the\n\ttrash entry, if a duplicate trash entry exists at the new\n\tlocation, or if a portal exception occurred\n\t*/\n\tpublic static com.liferay.portlet.trash.model.TrashEntry moveEntry(\n\t\tjava.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException {\n\t\treturn getService()\n\t\t\t\t   .moveEntry(className, classPK, destinationContainerModelId,\n\t\t\tserviceContext);\n\t}","id":32229,"modified_method":"/**\n\t* Moves the trash entry with the entity class name and primary key,\n\t* restoring it to a new location identified by the destination container\n\t* model ID.\n\t*\n\t* <p>\n\t* This method throws a {@link TrashPermissionException} if the user did not\n\t* have the permission to perform one of the necessary operations. The\n\t* exception is created with a type specific to the operation:\n\t* <\/p>\n\t*\n\t* <ul>\n\t* <li>\n\t* {@link TrashPermissionException#MOVE} - if the user did not have\n\t* permission to move the trash entry to the new\n\t* destination\n\t* <\/li>\n\t* <li>\n\t* {@link TrashPermissionException#RESTORE} - if the user did not have\n\t* permission to restore the trash entry\n\t* <\/li>\n\t* <\/ul>\n\t*\n\t* @param className the class name of the entity\n\t* @param classPK the primary key of the entity\n\t* @param destinationContainerModelId the primary key of the new location\n\t* @param serviceContext the service context to be applied (optionally\n\t<code>null<\/code>)\n\t* @throws PortalException if a matching trash entry could not be found, if\n\tthe user did not have permission to move the trash entry to the\n\tnew location, if the user did not have permission to restore the\n\ttrash entry, if a duplicate trash entry exists at the new\n\tlocation, or if a portal exception occurred\n\t*/\n\tpublic static void moveEntry(java.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException {\n\t\tgetService()\n\t\t\t.moveEntry(className, classPK, destinationContainerModelId,\n\t\t\tserviceContext);\n\t}","commit_id":"7a477c650dea94087e90c191116b5b41a297d0ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t* Moves the trash entry with the entity class name and primary key,\n\t* restoring it to a new location identified by the destination container\n\t* model ID.\n\t*\n\t* <p>\n\t* This method throws a {@link TrashPermissionException} if the user did not\n\t* have the permission to perform one of the necessary operations. The\n\t* exception is created with a type specific to the operation:\n\t* <\/p>\n\t*\n\t* <ul>\n\t* <li>\n\t* {@link TrashPermissionException#MOVE} - if the user did not have\n\t* permission to move the trash entry to the new\n\t* destination\n\t* <\/li>\n\t* <li>\n\t* {@link TrashPermissionException#RESTORE} - if the user did not have\n\t* permission to restore the trash entry\n\t* <\/li>\n\t* <\/ul>\n\t*\n\t* @param className the class name of the entity\n\t* @param classPK the primary key of the entity\n\t* @param destinationContainerModelId the primary key of the new location\n\t* @param serviceContext the service context to be applied (optionally\n\t<code>null<\/code>)\n\t* @throws PortalException if a matching trash entry could not be found, if\n\tthe user did not have permission to move the trash entry to the\n\tnew location, if the user did not have permission to restore the\n\ttrash entry, if a duplicate trash entry exists at the new\n\tlocation, or if a portal exception occurred\n\t*/\n\t@Override\n\tpublic com.liferay.portlet.trash.model.TrashEntry moveEntry(\n\t\tjava.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException {\n\t\treturn _trashEntryService.moveEntry(className, classPK,\n\t\t\tdestinationContainerModelId, serviceContext);\n\t}","id":32230,"modified_method":"/**\n\t* Moves the trash entry with the entity class name and primary key,\n\t* restoring it to a new location identified by the destination container\n\t* model ID.\n\t*\n\t* <p>\n\t* This method throws a {@link TrashPermissionException} if the user did not\n\t* have the permission to perform one of the necessary operations. The\n\t* exception is created with a type specific to the operation:\n\t* <\/p>\n\t*\n\t* <ul>\n\t* <li>\n\t* {@link TrashPermissionException#MOVE} - if the user did not have\n\t* permission to move the trash entry to the new\n\t* destination\n\t* <\/li>\n\t* <li>\n\t* {@link TrashPermissionException#RESTORE} - if the user did not have\n\t* permission to restore the trash entry\n\t* <\/li>\n\t* <\/ul>\n\t*\n\t* @param className the class name of the entity\n\t* @param classPK the primary key of the entity\n\t* @param destinationContainerModelId the primary key of the new location\n\t* @param serviceContext the service context to be applied (optionally\n\t<code>null<\/code>)\n\t* @throws PortalException if a matching trash entry could not be found, if\n\tthe user did not have permission to move the trash entry to the\n\tnew location, if the user did not have permission to restore the\n\ttrash entry, if a duplicate trash entry exists at the new\n\tlocation, or if a portal exception occurred\n\t*/\n\t@Override\n\tpublic void moveEntry(java.lang.String className, long classPK,\n\t\tlong destinationContainerModelId,\n\t\tcom.liferay.portal.service.ServiceContext serviceContext)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException {\n\t\t_trashEntryService.moveEntry(className, classPK,\n\t\t\tdestinationContainerModelId, serviceContext);\n\t}","commit_id":"7a477c650dea94087e90c191116b5b41a297d0ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static HrefResult readHrefWorker(LocationData locationData, String href) {\n\n        HrefResult result = new HrefResult();\n        PatternMatcher matcher = new Perl5Matcher();\n\n        if (href == null) {\n            // href=\"...\" is not always mandatory\n        } else if (matcher.contains(href, ID_REFERENCE)) {\n            // Reference to an id\n            String id = matcher.getMatch().group(1);\n            ASTHrefId hrefId = new ASTHrefId();\n            hrefId.setId(id);\n            result.astHref = hrefId;\n            result.rest = href.substring(matcher.getMatch().endOffset(0));\n        } else if (matcher.contains(href, FUNCTION_CALL)) {\n            // Try to parse this as a \"function call\"\n\n            // Parse function name (\"aggregate\")\n            String functionName = matcher.getMatch().group(1);\n            if (\"aggregate\".equals(functionName)) {\n                href = href.substring(matcher.getMatch().endOffset(0));\n\n                // Parse first argument (root element)\n                if (!matcher.contains(href, ROOT_ELEMENT_WITHOUT_NS))\n                    if (!matcher.contains(href, ROOT_ELEMENT_WITH_NS))\n                        throw new ValidationException(\"Invalid element name in \\\"\" + href + \"\\\"\", locationData);\n                String rootElementName = matcher.getMatch().group(1);\n                href = href.substring(matcher.getMatch().endOffset(0));\n\n                // Parse parameters\n                List<ASTHref> hrefParameters = new ArrayList<ASTHref>();\n                while (true) {\n                    if (matcher.contains(href, FUNCTION_END)) {\n                        // We are at the end of the function call\n                        ASTHrefAggregate hrefAggregate = new ASTHrefAggregate();\n                        hrefAggregate.setRoot(rootElementName);\n                        hrefAggregate.setHrefs(hrefParameters);\n                        result.rest = href.substring(matcher.getMatch().endOffset(0));\n                        result.astHref = hrefAggregate;\n                        break;\n                    } else if (matcher.contains(href, FUNCTION_PARAMETER)) {\n                        // We've got an other parameter\n                        href = href.substring(matcher.getMatch().endOffset(0));\n                        HrefResult parameterResult = readHrefWorker(locationData, href);\n                        hrefParameters.add(parameterResult.astHref);\n                        href = parameterResult.rest;\n                    } else {\n                        throw new ValidationException(\"Can't find \\\")\\\" or other href parameter in \\\"\"\n                            + href + \"\\\"\", locationData);\n                    }\n                }\n            } else if (\"current\".equals(functionName)) {\n                href = href.substring(matcher.getMatch().endOffset(0));\n                if (!matcher.contains(href, FUNCTION_END))\n                    throw new ValidationException(\"Expected ')' in current() function call\", locationData);\n                ASTHrefId hrefId = new ASTHrefId();\n                hrefId.setId(AbstractForEachProcessor.FOR_EACH_CURRENT_INPUT);\n                result.astHref = hrefId;\n                result.rest = href.substring(matcher.getMatch().endOffset(0));\n            } else {\n                throw new ValidationException(\"Unsupported function \\\"\" + functionName + \"\\\"\", locationData);\n            }\n        } else if (matcher.contains(href, URL)) {\n            // URL\n            ASTHrefURL hrefURL = new ASTHrefURL();\n            hrefURL.setURL(matcher.getMatch().group(1));\n            result.astHref = hrefURL;\n            result.rest = href.substring(matcher.getMatch().endOffset(0));\n        } else {\n            throw new ValidationException(\"Can't find id, URL or function call in \\\"\" +\n                    href + \"\\\"\", locationData);\n        }\n\n        // Handle optional XPointer expression\n        if (matcher.contains(result.rest, XPOINTER)) {\n            int parenthesisDepth = 0;\n            boolean inString = false;\n            char quoteType = 0;\n\n            String rest = result.rest.substring(matcher.getMatch().endOffset(0));\n            StringBuilder xpath = new StringBuilder();\n\n            while(true) {\n                if (inString) {\n                    // Look for end of this string\n                    int position = rest.indexOf(quoteType);\n                    if (position == -1)\n                        throw new ValidationException(\"Unterminated string\", locationData);\n                    xpath.append(rest.substring(0, position + 1));\n                    rest = rest.substring(position + 1);\n                    inString = false;\n                } else {\n                    int firstSingleQuote = rest.indexOf('\\'');\n                    int firstDoubleQuote = rest.indexOf('\"');\n                    int firstOpeningParenthesis = rest.indexOf('(');\n                    int firstClosingParenthesis = rest.indexOf(')');\n                    if (firstSingleQuote == -1) firstSingleQuote = Integer.MAX_VALUE;\n                    if (firstDoubleQuote == -1) firstDoubleQuote = Integer.MAX_VALUE;\n                    if (firstOpeningParenthesis == -1) firstOpeningParenthesis = Integer.MAX_VALUE;\n                    if (firstClosingParenthesis == -1) firstClosingParenthesis = Integer.MAX_VALUE;\n\n                    if (firstSingleQuote < firstDoubleQuote && firstSingleQuote < firstOpeningParenthesis\n                            && firstSingleQuote < firstClosingParenthesis) {\n                        // Start single quoted string\n                        quoteType = '\\'';\n                        inString = true;\n                        xpath.append(rest.substring(0, firstSingleQuote + 1));\n                        rest = rest.substring(firstSingleQuote + 1);\n                    } else if (firstDoubleQuote < firstSingleQuote && firstDoubleQuote < firstOpeningParenthesis\n                            && firstDoubleQuote < firstClosingParenthesis) {\n                        // Start double quoted string\n                        quoteType = '\"';\n                        inString = true;\n                        xpath.append(rest.substring(0, firstDoubleQuote + 1));\n                        rest = rest.substring(firstDoubleQuote + 1);\n                    } else if (firstOpeningParenthesis < firstSingleQuote && firstOpeningParenthesis < firstDoubleQuote\n                            && firstOpeningParenthesis < firstClosingParenthesis) {\n                        // Opening parenthesis\n                        parenthesisDepth++;\n                        xpath.append(rest.substring(0, firstOpeningParenthesis + 1));\n                        rest = rest.substring(firstOpeningParenthesis + 1);\n                    } else if (firstClosingParenthesis < firstSingleQuote && firstClosingParenthesis < firstDoubleQuote\n                            && firstClosingParenthesis < firstOpeningParenthesis) {\n                        // Closing parenthesis\n                        if (parenthesisDepth == 0) {\n                            // We're at the end of the XPointer expression\n                            xpath.append(rest.substring(0, firstClosingParenthesis));\n                            ASTHrefXPointer hrefXPointer = new ASTHrefXPointer();\n                            hrefXPointer.setHref(result.astHref);\n                            hrefXPointer.setXpath(xpath.toString());\n                            HrefResult xpointerResult = new HrefResult();\n                            xpointerResult.astHref = hrefXPointer;\n                            xpointerResult.rest = rest.substring(firstClosingParenthesis + 1);\n                            result = xpointerResult;\n                            break;\n                        } else {\n                            parenthesisDepth--;\n                            xpath.append(rest.substring(0, firstClosingParenthesis + 1));\n                            rest = rest.substring(firstClosingParenthesis + 1);\n                        }\n                    } else {\n                        throw new ValidationException(\"Expected single quote, double quote, opening parenthesis \"\n                                + \"or closing parenthesis in XPointer expression: \\\"\" + rest + \"\\\"\", locationData);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }","id":32231,"modified_method":"private static HrefResult readHrefWorker(LocationData locationData, String href) {\n\n        HrefResult result = new HrefResult();\n        Matcher matcher = null;\n\n        if (href == null) {\n            // href=\"...\" is not always mandatory\n        } else {\n            matcher = ID_REFERENCE.matcher(href);\n            if (matcher.find()) {\n                // Reference to an id\n                String id = matcher.group(1);\n                ASTHrefId hrefId = new ASTHrefId();\n                hrefId.setId(id);\n                result.astHref = hrefId;\n                result.rest = href.substring(matcher.end(0));\n            } else {\n                matcher = FUNCTION_CALL.matcher(href);\n                if (matcher.find()) {\n                    // Try to parse this as a \"function call\"\n\n                    // Parse function name (\"aggregate\")\n                    final String functionName = matcher.group(1);\n                    if (\"aggregate\".equals(functionName)) {\n                        href = href.substring(matcher.end(0));\n\n                        // Parse first argument (root element)\n\n                        matcher = ROOT_ELEMENT_WITHOUT_NS.matcher(href);\n                        if (!matcher.find()) {\n                            matcher = ROOT_ELEMENT_WITH_NS.matcher(href);\n                            if (!matcher.find())\n                                throw new ValidationException(\"Invalid element name in \\\"\" + href + \"\\\"\", locationData);\n                        }\n\n                        final String rootElementName = matcher.group(1);\n                        href = href.substring(matcher.end(0));\n\n                        // Parse parameters\n                        List<ASTHref> hrefParameters = new ArrayList<ASTHref>();\n                        while (true) {\n                            matcher = FUNCTION_END.matcher(href);\n                            if (matcher.find()) {\n                                // We are at the end of the function call\n                                ASTHrefAggregate hrefAggregate = new ASTHrefAggregate();\n                                hrefAggregate.setRoot(rootElementName);\n                                hrefAggregate.setHrefs(hrefParameters);\n                                result.rest = href.substring(matcher.end(0));\n                                result.astHref = hrefAggregate;\n                                break;\n                            } else {\n                                matcher = FUNCTION_PARAMETER.matcher(href);\n                                if (matcher.find()) {\n                                    // We've got an other parameter\n                                    href = href.substring(matcher.end(0));\n                                    HrefResult parameterResult = readHrefWorker(locationData, href);\n                                    hrefParameters.add(parameterResult.astHref);\n                                    href = parameterResult.rest;\n                                } else {\n                                    throw new ValidationException(\"Can't find \\\")\\\" or other href parameter in \\\"\"\n                                        + href + \"\\\"\", locationData);\n                                }\n                            }\n                        }\n                    } else if (\"current\".equals(functionName)) {\n                        href = href.substring(matcher.end(0));\n                        matcher = FUNCTION_END.matcher(href);\n                        if (!matcher.find())\n                            throw new ValidationException(\"Expected ')' in current() function call\", locationData);\n                        ASTHrefId hrefId = new ASTHrefId();\n                        hrefId.setId(AbstractForEachProcessor.FOR_EACH_CURRENT_INPUT);\n                        result.astHref = hrefId;\n                        result.rest = href.substring(matcher.end(0));\n                    } else {\n                        throw new ValidationException(\"Unsupported function \\\"\" + functionName + \"\\\"\", locationData);\n                    }\n                } else {\n                    matcher = URL.matcher(href);\n                    if (matcher.find()) {\n                        // URL\n                        ASTHrefURL hrefURL = new ASTHrefURL();\n                        hrefURL.setURL(matcher.group(1));\n                        result.astHref = hrefURL;\n                        result.rest = href.substring(matcher.end(0));\n                    } else {\n                        throw new ValidationException(\"Can't find id, URL or function call in \\\"\" +\n                                href + \"\\\"\", locationData);\n                    }\n                }\n            }\n        }\n\n        // Handle optional XPointer expression\n        matcher = XPOINTER.matcher(result.rest);\n        if (matcher.find()) {\n            int parenthesisDepth = 0;\n            boolean inString = false;\n            char quoteType = 0;\n\n            String rest = result.rest.substring(matcher.end(0));\n            StringBuilder xpath = new StringBuilder();\n\n            while(true) {\n                if (inString) {\n                    // Look for end of this string\n                    int position = rest.indexOf(quoteType);\n                    if (position == -1)\n                        throw new ValidationException(\"Unterminated string\", locationData);\n                    xpath.append(rest.substring(0, position + 1));\n                    rest = rest.substring(position + 1);\n                    inString = false;\n                } else {\n                    int firstSingleQuote = rest.indexOf('\\'');\n                    int firstDoubleQuote = rest.indexOf('\"');\n                    int firstOpeningParenthesis = rest.indexOf('(');\n                    int firstClosingParenthesis = rest.indexOf(')');\n                    if (firstSingleQuote == -1) firstSingleQuote = Integer.MAX_VALUE;\n                    if (firstDoubleQuote == -1) firstDoubleQuote = Integer.MAX_VALUE;\n                    if (firstOpeningParenthesis == -1) firstOpeningParenthesis = Integer.MAX_VALUE;\n                    if (firstClosingParenthesis == -1) firstClosingParenthesis = Integer.MAX_VALUE;\n\n                    if (firstSingleQuote < firstDoubleQuote && firstSingleQuote < firstOpeningParenthesis\n                            && firstSingleQuote < firstClosingParenthesis) {\n                        // Start single quoted string\n                        quoteType = '\\'';\n                        inString = true;\n                        xpath.append(rest.substring(0, firstSingleQuote + 1));\n                        rest = rest.substring(firstSingleQuote + 1);\n                    } else if (firstDoubleQuote < firstSingleQuote && firstDoubleQuote < firstOpeningParenthesis\n                            && firstDoubleQuote < firstClosingParenthesis) {\n                        // Start double quoted string\n                        quoteType = '\"';\n                        inString = true;\n                        xpath.append(rest.substring(0, firstDoubleQuote + 1));\n                        rest = rest.substring(firstDoubleQuote + 1);\n                    } else if (firstOpeningParenthesis < firstSingleQuote && firstOpeningParenthesis < firstDoubleQuote\n                            && firstOpeningParenthesis < firstClosingParenthesis) {\n                        // Opening parenthesis\n                        parenthesisDepth++;\n                        xpath.append(rest.substring(0, firstOpeningParenthesis + 1));\n                        rest = rest.substring(firstOpeningParenthesis + 1);\n                    } else if (firstClosingParenthesis < firstSingleQuote && firstClosingParenthesis < firstDoubleQuote\n                            && firstClosingParenthesis < firstOpeningParenthesis) {\n                        // Closing parenthesis\n                        if (parenthesisDepth == 0) {\n                            // We're at the end of the XPointer expression\n                            xpath.append(rest.substring(0, firstClosingParenthesis));\n                            ASTHrefXPointer hrefXPointer = new ASTHrefXPointer();\n                            hrefXPointer.setHref(result.astHref);\n                            hrefXPointer.setXpath(xpath.toString());\n                            HrefResult xpointerResult = new HrefResult();\n                            xpointerResult.astHref = hrefXPointer;\n                            xpointerResult.rest = rest.substring(firstClosingParenthesis + 1);\n                            result = xpointerResult;\n                            break;\n                        } else {\n                            parenthesisDepth--;\n                            xpath.append(rest.substring(0, firstClosingParenthesis + 1));\n                            rest = rest.substring(firstClosingParenthesis + 1);\n                        }\n                    } else {\n                        throw new ValidationException(\"Expected single quote, double quote, opening parenthesis \"\n                                + \"or closing parenthesis in XPointer expression: \\\"\" + rest + \"\\\"\", locationData);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static List<ASTStatement> readStatements(Element containerElement) {\n\n        List<ASTStatement> result = new ArrayList<ASTStatement>();\n        PatternMatcher matcher = new Perl5Matcher();\n        for (Iterator i = containerElement.elementIterator(); i.hasNext();) {\n            final Element element = (Element) i.next();\n            if (element.getName().equals(\"processor\")) {\n                // Processor\n                ASTProcessorCall processorCall = new ASTProcessorCall(XMLProcessorRegistry.extractProcessorQName(element)); {\n                    result.add(processorCall);\n                    processorCall.setNode(element);\n                    processorCall.setId(element.attributeValue(\"id\"));\n\n                    // Inputs/outputs\n                    for (Iterator j = element.elementIterator(); j.hasNext();) {\n                        final Element inputOutputElement = (Element) j.next();\n\n                        // Read common attributes\n                        class readCommonAttributes {\n                            readCommonAttributes(ASTInputOutput inputOutput) {\n                                inputOutput.setNode(inputOutputElement);\n                                inputOutput.setName(inputOutputElement.attributeValue(\"name\"));\n                                inputOutput.setSchemaHref(inputOutputElement.attributeValue(\"schema-href\"));\n                                inputOutput.setSchemaUri(inputOutputElement.attributeValue(\"schema-uri\"));\n                                inputOutput.setDebug(inputOutputElement.attributeValue(\"debug\"));\n                                Iterator childrenIterator = inputOutputElement.elementIterator();\n                                if(childrenIterator.hasNext())\n                                    inputOutput.setContent((Element) childrenIterator.next());\n                            }\n                        }\n\n                        // Read attributes specific to input or output\n                        if (inputOutputElement.getName().equals(\"input\")) {\n                            ASTInput input = new ASTInput(); {\n                                processorCall.addInput(input);\n                                input.setHref(readHref(inputOutputElement, inputOutputElement.attributeValue(\"href\")));\n                                input.setTransform(Dom4jUtils.extractAttributeValueQName(inputOutputElement, \"transform\"));\n                                new readCommonAttributes(input);\n                            }\n                        } else {\n                            ASTOutput output = new ASTOutput(); {\n                                processorCall.addOutput(output);\n                                String id = inputOutputElement.attributeValue(\"id\");\n                                if (id != null) {\n                                    if (! matcher.contains(id, IDENTIFIER))\n                                        throw new ValidationException(\"Invalid identifier '\" + id\n                                                + \"' in 'id' attribute\",\n                                                (LocationData) (inputOutputElement).getData());\n                                    output.setId(id);\n                                }\n                                String ref = inputOutputElement.attributeValue(\"ref\");\n                                if (ref != null) {\n                                    if (! matcher.contains(ref, IDENTIFIER))\n                                        throw new ValidationException(\"Invalid identifier '\" + ref\n                                                + \"' in 'id' attribute\",\n                                                (LocationData) (inputOutputElement).getData());\n                                    output.setRef(ref);\n                                }\n                                new readCommonAttributes(output);\n                            }\n                        }\n                    }\n                }\n            } else if (element.getName().equals(\"choose\")) {\n\n                // ASTChoose\n                ASTChoose choose = new ASTChoose(); {\n                    result.add(choose);\n                    choose.setNode(element);\n                    choose.setHref(readHref(element, element.attributeValue(\"href\")));\n                    choose.setSchemaHref(element.attributeValue(\"schema-href\"));\n                    choose.setSchemaUri(element.attributeValue(\"schema-uri\"));\n                    choose.setDebug(element.attributeValue(\"debug\"));\n\n                    for (Iterator j = element.elementIterator(); j.hasNext();) {\n                        final Element whenElement = (Element) j.next();\n                        ASTWhen when = new ASTWhen(); {\n                            choose.addWhen(when);\n                            when.setNode(whenElement);\n                            when.setTest(whenElement.attributeValue(\"test\"));\n                            when.getStatements().addAll(readStatements(whenElement));\n                        }\n                    }\n                }\n            } else  if (element.getName().equals(\"for-each\")) {\n\n                // ASTForEach\n                ASTForEach forEach = new ASTForEach(); {\n                    result.add(forEach);\n                    forEach.setNode(element);\n                    forEach.setHref(readHref(element, element.attributeValue(\"href\")));\n                    forEach.setSelect(element.attributeValue(\"select\"));\n                    forEach.setId(element.attributeValue(\"id\"));\n                    forEach.setRef(element.attributeValue(\"ref\"));\n                    forEach.setRoot(element.attributeValue(\"root\"));\n                    forEach.setInputSchemaHref(element.attributeValue(\"input-schema-href\"));\n                    forEach.setInputSchemaUri(element.attributeValue(\"input-schema-uri\"));\n                    forEach.setInputDebug(element.attributeValue(\"input-debug\"));\n                    forEach.setOutputSchemaHref(element.attributeValue(\"output-schema-href\"));\n                    forEach.setOutputSchemaUri(element.attributeValue(\"output-schema-uri\"));\n                    forEach.setOutputDebug(element.attributeValue(\"output-debug\"));\n                    forEach.getStatements().addAll(readStatements(element));\n                }\n            }\n        }\n        return result;\n    }","id":32232,"modified_method":"private static List<ASTStatement> readStatements(Element containerElement) {\n\n        List<ASTStatement> result = new ArrayList<ASTStatement>();\n        for (Iterator i = containerElement.elementIterator(); i.hasNext();) {\n            final Element element = (Element) i.next();\n            if (element.getName().equals(\"processor\")) {\n                // Processor\n                ASTProcessorCall processorCall = new ASTProcessorCall(XMLProcessorRegistry.extractProcessorQName(element)); {\n                    result.add(processorCall);\n                    processorCall.setNode(element);\n                    processorCall.setId(element.attributeValue(\"id\"));\n\n                    // Inputs/outputs\n                    for (Iterator j = element.elementIterator(); j.hasNext();) {\n                        final Element inputOutputElement = (Element) j.next();\n\n                        // Read common attributes\n                        class readCommonAttributes {\n                            readCommonAttributes(ASTInputOutput inputOutput) {\n                                inputOutput.setNode(inputOutputElement);\n                                inputOutput.setName(inputOutputElement.attributeValue(\"name\"));\n                                inputOutput.setSchemaHref(inputOutputElement.attributeValue(\"schema-href\"));\n                                inputOutput.setSchemaUri(inputOutputElement.attributeValue(\"schema-uri\"));\n                                inputOutput.setDebug(inputOutputElement.attributeValue(\"debug\"));\n                                Iterator childrenIterator = inputOutputElement.elementIterator();\n                                if(childrenIterator.hasNext())\n                                    inputOutput.setContent((Element) childrenIterator.next());\n                            }\n                        }\n\n                        // Read attributes specific to input or output\n                        if (inputOutputElement.getName().equals(\"input\")) {\n                            ASTInput input = new ASTInput(); {\n                                processorCall.addInput(input);\n                                input.setHref(readHref(inputOutputElement, inputOutputElement.attributeValue(\"href\")));\n                                input.setTransform(Dom4jUtils.extractAttributeValueQName(inputOutputElement, \"transform\"));\n                                new readCommonAttributes(input);\n                            }\n                        } else {\n                            ASTOutput output = new ASTOutput(); {\n                                processorCall.addOutput(output);\n                                String id = inputOutputElement.attributeValue(\"id\");\n                                if (id != null) {\n                                    if (! IDENTIFIER.matcher(id).find())\n                                        throw new ValidationException(\"Invalid identifier '\" + id\n                                                + \"' in 'id' attribute\",\n                                                (LocationData) (inputOutputElement).getData());\n                                    output.setId(id);\n                                }\n                                String ref = inputOutputElement.attributeValue(\"ref\");\n                                if (ref != null) {\n                                    if (! IDENTIFIER.matcher(ref).find())\n                                        throw new ValidationException(\"Invalid identifier '\" + ref\n                                                + \"' in 'id' attribute\",\n                                                (LocationData) (inputOutputElement).getData());\n                                    output.setRef(ref);\n                                }\n                                new readCommonAttributes(output);\n                            }\n                        }\n                    }\n                }\n            } else if (element.getName().equals(\"choose\")) {\n\n                // ASTChoose\n                ASTChoose choose = new ASTChoose(); {\n                    result.add(choose);\n                    choose.setNode(element);\n                    choose.setHref(readHref(element, element.attributeValue(\"href\")));\n                    choose.setSchemaHref(element.attributeValue(\"schema-href\"));\n                    choose.setSchemaUri(element.attributeValue(\"schema-uri\"));\n                    choose.setDebug(element.attributeValue(\"debug\"));\n\n                    for (Iterator j = element.elementIterator(); j.hasNext();) {\n                        final Element whenElement = (Element) j.next();\n                        ASTWhen when = new ASTWhen(); {\n                            choose.addWhen(when);\n                            when.setNode(whenElement);\n                            when.setTest(whenElement.attributeValue(\"test\"));\n                            when.getStatements().addAll(readStatements(whenElement));\n                        }\n                    }\n                }\n            } else  if (element.getName().equals(\"for-each\")) {\n\n                // ASTForEach\n                ASTForEach forEach = new ASTForEach(); {\n                    result.add(forEach);\n                    forEach.setNode(element);\n                    forEach.setHref(readHref(element, element.attributeValue(\"href\")));\n                    forEach.setSelect(element.attributeValue(\"select\"));\n                    forEach.setId(element.attributeValue(\"id\"));\n                    forEach.setRef(element.attributeValue(\"ref\"));\n                    forEach.setRoot(element.attributeValue(\"root\"));\n                    forEach.setInputSchemaHref(element.attributeValue(\"input-schema-href\"));\n                    forEach.setInputSchemaUri(element.attributeValue(\"input-schema-uri\"));\n                    forEach.setInputDebug(element.attributeValue(\"input-debug\"));\n                    forEach.setOutputSchemaHref(element.attributeValue(\"output-schema-href\"));\n                    forEach.setOutputSchemaUri(element.attributeValue(\"output-schema-uri\"));\n                    forEach.setOutputDebug(element.attributeValue(\"output-debug\"));\n                    forEach.getStatements().addAll(readStatements(element));\n                }\n            }\n        }\n        return result;\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static ASTHref readHref(Node node, String href) {\n\n        LocationData locationData = (LocationData) ((Element) node).getData();\n        HrefResult result = readHrefWorker(locationData, href);\n\n        // Make sure that everything was consumed\n        PatternMatcher matcher = new Perl5Matcher();\n        if (! matcher.contains(result.rest, END))\n            throw new ValidationException(\"Can't parse \\\"\" + result.rest + \"\\\" in href\", locationData);\n        return result.astHref;\n    }","id":32233,"modified_method":"private static ASTHref readHref(Node node, String href) {\n\n        LocationData locationData = (LocationData) ((Element) node).getData();\n        HrefResult result = readHrefWorker(locationData, href);\n\n        // Make sure that everything was consumed\n        if (! END.matcher(result.rest).find())\n            throw new ValidationException(\"Can't parse \\\"\" + result.rest + \"\\\" in href\", locationData);\n        return result.astHref;\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Check if the given path is a platform path (as opposed to a user application path).\n     *\n     * @param absolutePathNoContext path to check\n     * @return                      true iif path is a platform path\n     */\n    public static boolean isPlatformPath(String absolutePathNoContext) {\n        final String regexp = Properties.instance().getPropertySet().getString(REWRITING_PLATFORM_PATHS_PROPERTY, null);\n        // TODO: do not compile the regexp every time\n        return regexp != null && new Perl5MatchProcessor().match(regexp, absolutePathNoContext).matches;\n    }","id":32234,"modified_method":"/**\n     * Check if the given path is a platform path (as opposed to a user application path).\n     *\n     * @param absolutePathNoContext path to check\n     * @return                      true iif path is a platform path\n     */\n    public static boolean isPlatformPath(String absolutePathNoContext) {\n        final String regexp = Properties.instance().getPropertySet().getString(REWRITING_PLATFORM_PATHS_PROPERTY, null);\n        // TODO: do not compile the regexp every time\n        return regexp != null && new RegexpProcessor().regexpMatch(regexp, absolutePathNoContext).matches();\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static String globToPerl5(char[] pattern) {\n        int ch;\n        StringBuffer buffer;\n\n        buffer = new StringBuffer(2 * pattern.length);\n        boolean inCharSet = false;\n\n        boolean questionMatchesZero = false;\n        boolean starCannotMatchNull = false;\n\n        for (ch = 0; ch < pattern.length; ch++) {\n            switch (pattern[ch]) {\n                case '*':\n                    if (inCharSet)\n                        buffer.append('*');\n                    else {\n                        if (starCannotMatchNull)\n                            buffer.append(\".+\");\n                        else\n                            buffer.append(\".*\");\n                    }\n                    break;\n                case '?':\n                    if (inCharSet)\n                        buffer.append('?');\n                    else {\n                        if (questionMatchesZero)\n                            buffer.append(\".?\");\n                        else\n                            buffer.append('.');\n                    }\n                    break;\n                case '[':\n                    inCharSet = true;\n                    buffer.append(pattern[ch]);\n\n                    if (ch + 1 < pattern.length) {\n                        switch (pattern[ch + 1]) {\n                            case '!':\n                            case '^':\n                                buffer.append('^');\n                                ++ch;\n                                continue;\n                            case ']':\n                                buffer.append(']');\n                                ++ch;\n                                continue;\n                        }\n                    }\n                    break;\n                case ']':\n                    inCharSet = false;\n                    buffer.append(pattern[ch]);\n                    break;\n                case '\\\\':\n                    buffer.append('\\\\');\n                    if (ch == pattern.length - 1) {\n                        buffer.append('\\\\');\n                    } else if (__isGlobMetaCharacter(pattern[ch + 1]))\n                        buffer.append(pattern[++ch]);\n                    else\n                        buffer.append('\\\\');\n                    break;\n                default:\n                    if (!inCharSet && __isPerl5MetaCharacter(pattern[ch]))\n                        buffer.append('\\\\');\n                    buffer.append(pattern[ch]);\n                    break;\n            }\n        }\n\n        return buffer.toString();\n    }","id":32235,"modified_method":"public static String globToRegexp(char[] pattern) {\n        int ch;\n        StringBuffer buffer;\n\n        buffer = new StringBuffer(2 * pattern.length);\n        boolean inCharSet = false;\n\n        boolean questionMatchesZero = false;\n        boolean starCannotMatchNull = false;\n\n        for (ch = 0; ch < pattern.length; ch++) {\n            switch (pattern[ch]) {\n                case '*':\n                    if (inCharSet)\n                        buffer.append('*');\n                    else {\n                        if (starCannotMatchNull)\n                            buffer.append(\".+\");\n                        else\n                            buffer.append(\".*\");\n                    }\n                    break;\n                case '?':\n                    if (inCharSet)\n                        buffer.append('?');\n                    else {\n                        if (questionMatchesZero)\n                            buffer.append(\".?\");\n                        else\n                            buffer.append('.');\n                    }\n                    break;\n                case '[':\n                    inCharSet = true;\n                    buffer.append(pattern[ch]);\n\n                    if (ch + 1 < pattern.length) {\n                        switch (pattern[ch + 1]) {\n                            case '!':\n                            case '^':\n                                buffer.append('^');\n                                ++ch;\n                                continue;\n                            case ']':\n                                buffer.append(']');\n                                ++ch;\n                                continue;\n                        }\n                    }\n                    break;\n                case ']':\n                    inCharSet = false;\n                    buffer.append(pattern[ch]);\n                    break;\n                case '\\\\':\n                    buffer.append('\\\\');\n                    if (ch == pattern.length - 1) {\n                        buffer.append('\\\\');\n                    } else if (__isGlobMetaCharacter(pattern[ch + 1]))\n                        buffer.append(pattern[++ch]);\n                    else\n                        buffer.append('\\\\');\n                    break;\n                default:\n                    if (!inCharSet && __isPerl5MetaCharacter(pattern[ch]))\n                        buffer.append('\\\\');\n                    buffer.append(pattern[ch]);\n                    break;\n            }\n        }\n\n        return buffer.toString();\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static boolean isVersionedURL(String absolutePathNoContext, List<URLRewriterUtils.PathMatcher> pathMatchers) {\n        for (final URLRewriterUtils.PathMatcher pathMatcher : pathMatchers) {\n            final Perl5MatchProcessor matcherProcessor = new Perl5MatchProcessor();\n            if (matcherProcessor.match(pathMatcher.regexp, absolutePathNoContext).matches)\n                return true;\n        }\n        \n        return false;\n    }","id":32236,"modified_method":"public static boolean isVersionedURL(String absolutePathNoContext, List<URLRewriterUtils.PathMatcher> pathMatchers) {\n        for (final URLRewriterUtils.PathMatcher pathMatcher : pathMatchers) {\n            final RegexpProcessor regexpProcessor = new RegexpProcessor();\n            if (regexpProcessor.regexpMatch(pathMatcher.regexp, absolutePathNoContext).matches())\n                return true;\n        }\n        \n        return false;\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Check if the given path is an application path, assuming it is not already a platform path.\n     *\n     * @param absolutePathNoContext path to check\n     * @return                      true iif path is a platform path\n     */\n    public static boolean isNonPlatformPathAppPath(String absolutePathNoContext) {\n        final String regexp = Properties.instance().getPropertySet().getString(REWRITING_APP_PATHS_PROPERTY, null);\n        // TODO: do not compile the regexp every time\n        return regexp != null && new Perl5MatchProcessor().match(regexp, absolutePathNoContext).matches;\n    }","id":32237,"modified_method":"/**\n     * Check if the given path is an application path, assuming it is not already a platform path.\n     *\n     * @param absolutePathNoContext path to check\n     * @return                      true iif path is a platform path\n     */\n    public static boolean isNonPlatformPathAppPath(String absolutePathNoContext) {\n        final String regexp = Properties.instance().getPropertySet().getString(REWRITING_APP_PATHS_PROPERTY, null);\n        // TODO: do not compile the regexp every time\n        return regexp != null && new RegexpProcessor().regexpMatch(regexp, absolutePathNoContext).matches();\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static String testParseDate(String value) {\n        final Perl5MatchProcessor matcher = new Perl5MatchProcessor();\n        return parse(matcher, XFormsInputControl.DATE_PARSE_PATTERNS, value);\n    }","id":32238,"modified_method":"public static String testParseDate(String value) {\n        final RegexpProcessor matcher = new RegexpProcessor();\n        return parse(matcher, XFormsInputControl.DATE_PARSE_PATTERNS, value);\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static String testParseTime(String value) {\n        final Perl5MatchProcessor matcher = new Perl5MatchProcessor();\n        return parse(matcher, XFormsInputControl.TIME_PARSE_PATTERNS, value);\n    }","id":32239,"modified_method":"public static String testParseTime(String value) {\n        final RegexpProcessor matcher = new RegexpProcessor();\n        return parse(matcher, XFormsInputControl.TIME_PARSE_PATTERNS, value);\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static String parse(Perl5MatchProcessor matcher, ParsePattern[] patterns, String value) {\n        for (final ParsePattern currentPattern: patterns) {\n            final MatchProcessor.Result result = matcher.match(currentPattern.getRe(), value);\n            if (result.matches) {\n                // Pattern matches\n                return currentPattern.handle(result);\n            }\n        }\n\n        // Return value unmodified\n        return value;\n    }","id":32240,"modified_method":"private static String parse(RegexpProcessor matcher, ParsePattern[] patterns, String value) {\n        for (final ParsePattern currentPattern : patterns) {\n            final RegexpProcessor.MatchResult result = matcher.regexpMatch(currentPattern.getRe(), value);\n            if (result.matches()) {\n                // Pattern matches\n                return currentPattern.handle(result);\n            }\n        }\n\n        // Return value unmodified\n        return value;\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public String handle(MatchProcessor.Result result);","id":32241,"modified_method":"public String handle(RegexpProcessor.MatchResult result);","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private String convertFromExternalValue(String externalValue) {\n        final String typeName = getBuiltinTypeName();\n        if (typeName != null) {\n            if (typeName.equals(\"boolean\")) {\n                // Boolean input\n\n                // NOTE: We have decided that it did not make much sense to encrypt the value for boolean. This also poses\n                // a problem since the server does not send an itemset for new booleans, therefore the client cannot know\n                // the encrypted value of \"true\". So we do not encrypt values.\n\n                // Anything but \"true\" is \"false\"\n                if (!externalValue.equals(\"true\"))\n                    externalValue = \"false\";\n            } else if (containingDocument().getStaticState().isNoscript()) {\n                // Noscript mode: value must be pre-processed on the server (in Ajax mode, ISO value is sent to server if possible)\n\n                if ( \"date\".equals(typeName)) {\n                    // Date input\n                    externalValue = externalValue.trim();\n                    final Perl5MatchProcessor matcher = new Perl5MatchProcessor();\n                    // TODO: like on client, must handle oxf.xforms.format.input.date\n                    externalValue = parse(matcher, DATE_PARSE_PATTERNS, externalValue);\n                } else if (\"time\".equals(typeName)) {\n                    // Time input\n                    externalValue = externalValue.trim();\n                    final Perl5MatchProcessor matcher = new Perl5MatchProcessor();\n                    // TODO: like on client, must handle oxf.xforms.format.input.time\n                    externalValue = parse(matcher, TIME_PARSE_PATTERNS, externalValue);\n                } else if (\"dateTime\".equals(typeName)) {\n                    // Date + time input\n                    externalValue = externalValue.trim();\n\n                    // Split into date and time parts\n                    // We use the same separator as the repeat separator. This is set in xforms-server-submit.xpl.\n                    final String datePart = getDateTimeDatePart(externalValue, XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_1);\n                    final String timePart = getDateTimeTimePart(externalValue, XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_1);\n\n                    if (datePart.length() == 0 && timePart.length() == 0) {\n                        // Special case of empty parts\n                        externalValue = \"\";\n                    } else {\n                        // Parse and recombine with 'T' separator (result may be invalid dateTime, of course!)\n                        final Perl5MatchProcessor matcher = new Perl5MatchProcessor();\n                        externalValue = parse(matcher, DATE_PARSE_PATTERNS, datePart) + 'T' + parse(matcher, TIME_PARSE_PATTERNS, timePart);\n                    }\n                } else {\n                    externalValue = convertFromExternalValueUseUnformat(externalValue);\n                }\n            } else {\n                externalValue = convertFromExternalValueUseUnformat(externalValue);\n            }\n        } else {\n            externalValue = convertFromExternalValueUseUnformat(externalValue);\n        }\n\n        return externalValue;\n    }","id":32242,"modified_method":"private String convertFromExternalValue(String externalValue) {\n        final String typeName = getBuiltinTypeName();\n        if (typeName != null) {\n            if (typeName.equals(\"boolean\")) {\n                // Boolean input\n\n                // NOTE: We have decided that it did not make much sense to encrypt the value for boolean. This also poses\n                // a problem since the server does not send an itemset for new booleans, therefore the client cannot know\n                // the encrypted value of \"true\". So we do not encrypt values.\n\n                // Anything but \"true\" is \"false\"\n                if (!externalValue.equals(\"true\"))\n                    externalValue = \"false\";\n            } else if (containingDocument().getStaticState().isNoscript()) {\n                // Noscript mode: value must be pre-processed on the server (in Ajax mode, ISO value is sent to server if possible)\n\n                if ( \"date\".equals(typeName)) {\n                    // Date input\n                    externalValue = externalValue.trim();\n                    final RegexpProcessor matcher = new RegexpProcessor();\n                    // TODO: like on client, must handle oxf.xforms.format.input.date\n                    externalValue = parse(matcher, DATE_PARSE_PATTERNS, externalValue);\n                } else if (\"time\".equals(typeName)) {\n                    // Time input\n                    externalValue = externalValue.trim();\n                    final RegexpProcessor matcher = new RegexpProcessor();\n                    // TODO: like on client, must handle oxf.xforms.format.input.time\n                    externalValue = parse(matcher, TIME_PARSE_PATTERNS, externalValue);\n                } else if (\"dateTime\".equals(typeName)) {\n                    // Date + time input\n                    externalValue = externalValue.trim();\n\n                    // Split into date and time parts\n                    // We use the same separator as the repeat separator. This is set in xforms-server-submit.xpl.\n                    final String datePart = getDateTimeDatePart(externalValue, XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_1);\n                    final String timePart = getDateTimeTimePart(externalValue, XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_1);\n\n                    if (datePart.length() == 0 && timePart.length() == 0) {\n                        // Special case of empty parts\n                        externalValue = \"\";\n                    } else {\n                        // Parse and recombine with 'T' separator (result may be invalid dateTime, of course!)\n                        final RegexpProcessor matcher = new RegexpProcessor();\n                        externalValue = parse(matcher, DATE_PARSE_PATTERNS, datePart) + 'T' + parse(matcher, TIME_PARSE_PATTERNS, timePart);\n                    }\n                } else {\n                    externalValue = convertFromExternalValueUseUnformat(externalValue);\n                }\n            } else {\n                externalValue = convertFromExternalValueUseUnformat(externalValue);\n            }\n        } else {\n            externalValue = convertFromExternalValueUseUnformat(externalValue);\n        }\n\n        return externalValue;\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"protected void readInput(final PipelineContext pipelineContext, ProcessorInput input, Config config, OutputStream outputStream) {\n        try {\n            final PatternMatcher matcher = new Perl5Matcher();\n            Document dataDocument = readInputAsDOM4J(pipelineContext, INPUT_DATA);\n            final DocumentWrapper wrapper = new DocumentWrapper(dataDocument, null, XPathCache.getGlobalConfiguration());\n\n            Document configDocument = readInputAsDOM4J(pipelineContext, INPUT_CONFIG);\n\n            // Read template sheet\n            String templateName = configDocument.getRootElement().attributeValue(\"template\");\n            //String fileName = configDocument.getRootElement().attributeValue(\"filename\");\n            InputStream templateInputStream = URLFactory.createURL(templateName).openStream();\n            final HSSFWorkbook workbook = new HSSFWorkbook(new POIFSFileSystem(templateInputStream));\n            final HSSFDataFormat dataFormat = workbook.createDataFormat();\n            templateInputStream.close();\n\n            int sheetIndex = 0;\n\n            PooledXPathExpression expr = null;\n            List nodes = null;\n            try {\n                expr = XPathCache.getXPathExpression(wrapper.getConfiguration(), wrapper, \"/workbook/sheet\", getLocationData());\n                nodes = expr.evaluate();\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally {\n                if (expr != null)\n                    expr.returnToPool();\n            }\n            for (Iterator i = nodes.iterator(); i.hasNext();) {\n\n                final Element sheetElement = (Element) i.next();\n                HSSFSheet sheet = workbook.cloneSheet(0);\n                workbook.setSheetName(sheetIndex + 1, sheetElement.attributeValue(\"name\"));\n\n                // Duplicate rows if we find a \"repeat-row\" in the config\n                for (Iterator j = configDocument.selectNodes(\"/config/repeat-row\").iterator(); j.hasNext();) {\n\n                    // Get info about row to repeat\n                    Element repeatRowElement = (Element) j.next();\n                    final int rowNum = Integer.parseInt(repeatRowElement.attributeValue(\"row-num\"));\n                    final String forEach = repeatRowElement.attributeValue(\"for-each\");\n                    HSSFRow templateRow = sheet.getRow(rowNum);\n                    int repeatCount = ((Double) sheetElement.selectObject(\"count(\" + forEach + \")\")).intValue();\n\n                    // Move existing rows lower\n                    int lastRowNum = sheet.getLastRowNum();\n                    for (int k = lastRowNum; k > rowNum; k--) {\n                        HSSFRow sourceRow = sheet.getRow(k);\n                        HSSFRow newRow = sheet.createRow(k + repeatCount - 1);\n                        XLSUtils.copyRow(workbook, newRow, sourceRow);\n                    }\n\n                    // Create rows, copying the template row\n                    for (int k = rowNum + 1; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.createRow(k);\n                        XLSUtils.copyRow(workbook, newRow, templateRow);\n                    }\n\n                    // Modify the XPath expression on each row\n                    for (int k = rowNum; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.getRow(k);\n                        for (short m = 0; m <= newRow.getLastCellNum(); m++) {\n                            HSSFCell cell = newRow.getCell(m);\n                            if (cell != null) {\n                                String currentFormat = dataFormat.getFormat(cell.getCellStyle().getDataFormat());\n                                if (matcher.contains(currentFormat, FORMAT_XPATH)) {\n                                    String newFormat = matcher.getMatch().group(1) + \"\\\"\"\n                                            + forEach + \"[\" + (k - rowNum + 1) + \"]/\" + matcher.getMatch().group(2) + \"\\\"\";\n                                    cell.getCellStyle().setDataFormat(dataFormat.getFormat(newFormat));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Set values in cells with an XPath expression\n                XLSUtils.walk(dataFormat, sheet, new XLSUtils.Handler() {\n                    public void cell(HSSFCell cell, String sourceXPath, String targetXPath) {\n                        if (sourceXPath.charAt(0) == '/')\n                            sourceXPath = sourceXPath.substring(1);\n\n                        // Set cell value\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(\n                                wrapper.getConfiguration(), wrapper.wrap(sheetElement), \"string(\" + sourceXPath + \")\", getLocationData());\n                        String newValue;\n                        try {\n                            newValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        if (newValue == null) {\n                            throw new OXFException(\"Nothing matches the XPath expression '\"\n                                    + sourceXPath + \"' in the input document\");\n                        }\n                        try {\n                            cell.setCellValue(Double.parseDouble(newValue));\n                        } catch (NumberFormatException e) {\n                            cell.setCellValue(newValue);\n                        }\n\n                        // Set cell format\n                        Object element = sheetElement.selectObject(sourceXPath);\n                        if (element instanceof Element) {\n                            // NOTE: We might want to support other properties here\n                            String bold = ((Element) element).attributeValue(\"bold\");\n                            if (bold != null) {\n                                HSSFFont originalFont = workbook.getFontAt(cell.getCellStyle().getFontIndex());\n                                HSSFFont newFont = workbook.createFont();\n                                XLSUtils.copyFont(newFont, originalFont);\n                                if (\"true\".equals(bold))\n                                    newFont.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);\n                                cell.getCellStyle().setFont(newFont);\n                            }\n                        }\n                    }\n                });\n                sheetIndex++;\n            }\n\n            workbook.removeSheetAt(0);\n\n            // Write out the workbook\n            workbook.write(outputStream);\n        } catch (IOException e) {\n            throw new OXFException(e);\n        }\n    }","id":32243,"modified_method":"protected void readInput(final PipelineContext pipelineContext, ProcessorInput input, Config config, OutputStream outputStream) {\n        try {\n            Document dataDocument = readInputAsDOM4J(pipelineContext, INPUT_DATA);\n            final DocumentWrapper wrapper = new DocumentWrapper(dataDocument, null, XPathCache.getGlobalConfiguration());\n\n            Document configDocument = readInputAsDOM4J(pipelineContext, INPUT_CONFIG);\n\n            // Read template sheet\n            String templateName = configDocument.getRootElement().attributeValue(\"template\");\n            //String fileName = configDocument.getRootElement().attributeValue(\"filename\");\n            InputStream templateInputStream = URLFactory.createURL(templateName).openStream();\n            final HSSFWorkbook workbook = new HSSFWorkbook(new POIFSFileSystem(templateInputStream));\n            final HSSFDataFormat dataFormat = workbook.createDataFormat();\n            templateInputStream.close();\n\n            int sheetIndex = 0;\n\n            PooledXPathExpression expr = null;\n            List nodes = null;\n            try {\n                expr = XPathCache.getXPathExpression(wrapper.getConfiguration(), wrapper, \"/workbook/sheet\", getLocationData());\n                nodes = expr.evaluate();\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally {\n                if (expr != null)\n                    expr.returnToPool();\n            }\n            for (Iterator i = nodes.iterator(); i.hasNext();) {\n\n                final Element sheetElement = (Element) i.next();\n                HSSFSheet sheet = workbook.cloneSheet(0);\n                workbook.setSheetName(sheetIndex + 1, sheetElement.attributeValue(\"name\"));\n\n                // Duplicate rows if we find a \"repeat-row\" in the config\n                for (Iterator j = configDocument.selectNodes(\"/config/repeat-row\").iterator(); j.hasNext();) {\n\n                    // Get info about row to repeat\n                    Element repeatRowElement = (Element) j.next();\n                    final int rowNum = Integer.parseInt(repeatRowElement.attributeValue(\"row-num\"));\n                    final String forEach = repeatRowElement.attributeValue(\"for-each\");\n                    HSSFRow templateRow = sheet.getRow(rowNum);\n                    int repeatCount = ((Double) sheetElement.selectObject(\"count(\" + forEach + \")\")).intValue();\n\n                    // Move existing rows lower\n                    int lastRowNum = sheet.getLastRowNum();\n                    for (int k = lastRowNum; k > rowNum; k--) {\n                        HSSFRow sourceRow = sheet.getRow(k);\n                        HSSFRow newRow = sheet.createRow(k + repeatCount - 1);\n                        XLSUtils.copyRow(workbook, newRow, sourceRow);\n                    }\n\n                    // Create rows, copying the template row\n                    for (int k = rowNum + 1; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.createRow(k);\n                        XLSUtils.copyRow(workbook, newRow, templateRow);\n                    }\n\n                    // Modify the XPath expression on each row\n                    for (int k = rowNum; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.getRow(k);\n                        for (short m = 0; m <= newRow.getLastCellNum(); m++) {\n                            HSSFCell cell = newRow.getCell(m);\n                            if (cell != null) {\n                                String currentFormat = dataFormat.getFormat(cell.getCellStyle().getDataFormat());\n                                final Matcher matcher = FORMAT_XPATH.matcher(currentFormat);\n                                if (matcher.find()) {\n                                    String newFormat = matcher.group(1) + \"\\\"\"\n                                            + forEach + \"[\" + (k - rowNum + 1) + \"]/\" + matcher.group(2) + \"\\\"\";\n                                    cell.getCellStyle().setDataFormat(dataFormat.getFormat(newFormat));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Set values in cells with an XPath expression\n                XLSUtils.walk(dataFormat, sheet, new XLSUtils.Handler() {\n                    public void cell(HSSFCell cell, String sourceXPath, String targetXPath) {\n                        if (sourceXPath.charAt(0) == '/')\n                            sourceXPath = sourceXPath.substring(1);\n\n                        // Set cell value\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(\n                                wrapper.getConfiguration(), wrapper.wrap(sheetElement), \"string(\" + sourceXPath + \")\", getLocationData());\n                        String newValue;\n                        try {\n                            newValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        if (newValue == null) {\n                            throw new OXFException(\"Nothing matches the XPath expression '\"\n                                    + sourceXPath + \"' in the input document\");\n                        }\n                        try {\n                            cell.setCellValue(Double.parseDouble(newValue));\n                        } catch (NumberFormatException e) {\n                            cell.setCellValue(newValue);\n                        }\n\n                        // Set cell format\n                        Object element = sheetElement.selectObject(sourceXPath);\n                        if (element instanceof Element) {\n                            // NOTE: We might want to support other properties here\n                            String bold = ((Element) element).attributeValue(\"bold\");\n                            if (bold != null) {\n                                HSSFFont originalFont = workbook.getFontAt(cell.getCellStyle().getFontIndex());\n                                HSSFFont newFont = workbook.createFont();\n                                XLSUtils.copyFont(newFont, originalFont);\n                                if (\"true\".equals(bold))\n                                    newFont.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);\n                                cell.getCellStyle().setFont(newFont);\n                            }\n                        }\n                    }\n                });\n                sheetIndex++;\n            }\n\n            workbook.removeSheetAt(0);\n\n            // Write out the workbook\n            workbook.write(outputStream);\n        } catch (IOException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static void walk(boolean[][] merged, HSSFDataFormat dataFormat, HSSFRow row, Handler handler) {\n        final PatternMatcher matcher = new Perl5Matcher();\n        if (row != null) {\n            for (int cellNum = 0; cellNum <= row.getLastCellNum(); cellNum++) {\n                HSSFCell cell = row.getCell((short) cellNum);\n                if (cell != null && !merged[row.getRowNum()][cellNum]) {\n                    short dataFormatId = cell.getCellStyle().getDataFormat();\n                    if (dataFormatId > 0) {\n                        String format = dataFormat.getFormat(dataFormatId);\n                        if (matcher.contains(format, FORMAT_XPATH)) {\n                            // Found XPath expression\n                            String xpath = matcher.getMatch().group(1);\n                            int separtorPosition = xpath.indexOf('|');\n                            String sourceXPath = separtorPosition == -1 ? xpath : xpath.substring(0, separtorPosition);\n                            String targetXPath = separtorPosition == -1 ? null : xpath.substring(separtorPosition + 1);\n                            handler.cell(cell, sourceXPath, targetXPath);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":32244,"modified_method":"private static void walk(boolean[][] merged, HSSFDataFormat dataFormat, HSSFRow row, Handler handler) {\n        if (row != null) {\n            for (int cellNum = 0; cellNum <= row.getLastCellNum(); cellNum++) {\n                HSSFCell cell = row.getCell((short) cellNum);\n                if (cell != null && !merged[row.getRowNum()][cellNum]) {\n                    short dataFormatId = cell.getCellStyle().getDataFormat();\n                    if (dataFormatId > 0) {\n                        String format = dataFormat.getFormat(dataFormatId);\n                        final Matcher matcher = FORMAT_XPATH.matcher(format);\n                        if (matcher.find()) {\n                            // Found XPath expression\n                            String xpath = matcher.group(1);\n                            int separtorPosition = xpath.indexOf('|');\n                            String sourceXPath = separtorPosition == -1 ? xpath : xpath.substring(0, separtorPosition);\n                            String targetXPath = separtorPosition == -1 ? null : xpath.substring(separtorPosition + 1);\n                            handler.cell(cell, sourceXPath, targetXPath);\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"0f11f23328845854f60cc9c4cf2f6b5906d2ed5c","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private GridConstraints getGridConstraints(int row, boolean fill) {\n    return new GridConstraints(row, 0, 1, 1, GridConstraints.ANCHOR_NORTHWEST, (fill ?\n      GridConstraints.FILL_BOTH :\n      GridConstraints.FILL_HORIZONTAL\n    ), GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, (fill ?\n      GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW :\n      GridConstraints.SIZEPOLICY_FIXED\n    ), null, null, null, 0);\n  }","id":32245,"modified_method":"private Object getGridConstraints(int row, boolean fill) {\n    // TODO: resolve problem with GridConstraints in stubs \n    return new GridConstraints(row, 0, 1, 1, GridConstraints.ANCHOR_NORTHWEST, (fill ?\n      GridConstraints.FILL_BOTH :\n      GridConstraints.FILL_HORIZONTAL\n    ), GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, (fill ?\n      GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW :\n      GridConstraints.SIZEPOLICY_FIXED\n    ), null, null, null, 0);\n  }","commit_id":"47d51fb5f7fc6c46ab678ed03dde8b07def0ef37","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initUI() {\n    int rowCount = 2 + ((myExtraPanels == null ?\n      0 :\n      myExtraPanels.length\n    ));\n    int rowIndex = 0;\n    myPanel = new JBPanel(new GridLayoutManager(rowCount, 1, new Insets(5, 5, 5, 5), -1, -1));\n    myPanel.setAutoscrolls(false);\n    myPanel.add(createProjectModulesList(), getGridConstraints(rowIndex++, true));\n    myPanel.add(createTestConfigList(), getGridConstraints(rowIndex++, true));\n    for (ProjectPrefsExtraPanel extraPanel : Sequence.fromIterable(Sequence.fromArray(myExtraPanels))) {\n      myPanel.add(extraPanel.getComponent(), getGridConstraints(rowIndex++, false));\n    }\n  }","id":32246,"modified_method":"private void initUI() {\n    int rowCount = 2 + ((myExtraPanels == null ?\n      0 :\n      myExtraPanels.length\n    ));\n    int rowIndex = 0;\n    myPanel = new JBPanel(new GridLayoutManager(rowCount, 1, new Insets(5, 5, 5, 5), -1, -1));\n    myPanel.setAutoscrolls(false);\n    myPanel.add(createProjectModulesList(), (GridConstraints) getGridConstraints(rowIndex++, true));\n    myPanel.add(createTestConfigList(), (GridConstraints) getGridConstraints(rowIndex++, true));\n    for (ProjectPrefsExtraPanel extraPanel : Sequence.fromIterable(Sequence.fromArray(myExtraPanels))) {\n      myPanel.add(extraPanel.getComponent(), (GridConstraints) getGridConstraints(rowIndex++, false));\n    }\n  }","commit_id":"47d51fb5f7fc6c46ab678ed03dde8b07def0ef37","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected ExpectedResolveData getExpectedResolveData() {\n        Project project = getProject();\n        KotlinBuiltIns builtIns = KotlinBuiltIns.getInstance();\n        Map<String, DeclarationDescriptor> nameToDescriptor = new HashMap<String, DeclarationDescriptor>();\n        nameToDescriptor.put(\"kotlin::Int.plus(Int)\", standardFunction(builtIns.getInt(), \"plus\", builtIns.getIntType()));\n        FunctionDescriptor descriptorForGet = standardFunction(builtIns.getArray(), Collections.singletonList(new TypeProjection(builtIns.getIntType())), \"get\", builtIns.getIntType());\n        nameToDescriptor.put(\"kotlin::Array.get(Int)\", descriptorForGet.getOriginal());\n        nameToDescriptor.put(\"kotlin::Int.compareTo(Double)\", standardFunction(builtIns.getInt(), \"compareTo\", builtIns.getDoubleType()));\n        @NotNull\n        FunctionDescriptor descriptorForSet = standardFunction(builtIns.getArray(), Collections.singletonList(new TypeProjection(builtIns.getIntType())), \"set\", builtIns.getIntType(), builtIns.getIntType());\n        nameToDescriptor.put(\"kotlin::Array.set(Int, Int)\", descriptorForSet.getOriginal());\n\n        Map<String, PsiElement> nameToDeclaration = new HashMap<String, PsiElement>();\n        PsiClass java_util_Collections = findClass(\"java.util.Collections\");\n        nameToDeclaration.put(\"java::java.util.Collections.emptyList()\", findMethod(java_util_Collections, \"emptyList\"));\n        nameToDeclaration.put(\"java::java.util.Collections\", java_util_Collections);\n        PsiClass java_util_List = findClass(\"java.util.ArrayList\");\n        nameToDeclaration.put(\"java::java.util.ArrayList\", java_util_List);\n        nameToDeclaration.put(\"java::java.util.ArrayList.set()\", java_util_List.findMethodsByName(\"set\", true)[0]);\n        nameToDeclaration.put(\"java::java.util.ArrayList.get()\", java_util_List.findMethodsByName(\"get\", true)[0]);\n        nameToDeclaration.put(\"java::java\", findPackage(\"java\"));\n        nameToDeclaration.put(\"java::java.util\", findPackage(\"java.util\"));\n        nameToDeclaration.put(\"java::java.lang\", findPackage(\"java.lang\"));\n        nameToDeclaration.put(\"java::java.lang.Object\", findClass(\"java.lang.Object\"));\n        PsiClass java_lang_System = findClass(\"java.lang.System\");\n        nameToDeclaration.put(\"java::java.lang.System\", java_lang_System);\n        PsiMethod[] methods = findClass(\"java.io.PrintStream\").findMethodsByName(\"print\", true);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(Object)\", methods[8]);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(Int)\", methods[2]);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(char[])\", methods[6]);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(Double)\", methods[5]);\n        nameToDeclaration.put(\"java::java.lang.System.out\", java_lang_System.findFieldByName(\"out\", true));\n        PsiClass java_lang_Number = findClass(\"java.lang.Number\");\n        nameToDeclaration.put(\"java::java.lang.Number\", java_lang_Number);\n        nameToDeclaration.put(\"java::java.lang.Number.intValue()\", java_lang_Number.findMethodsByName(\"intValue\", true)[0]);\n\n        return new ExpectedResolveData(nameToDescriptor, nameToDeclaration, getEnvironment()) {\n            @Override\n            protected JetFile createJetFile(String fileName, String text) {\n                return createCheckAndReturnPsiFile(fileName, null, text);\n            }\n        };\n    }","id":32247,"modified_method":"@Override\n    protected ExpectedResolveData getExpectedResolveData() {\n        Project project = getProject();\n        KotlinBuiltIns builtIns = KotlinBuiltIns.getInstance();\n        Map<String, DeclarationDescriptor> nameToDescriptor = new HashMap<String, DeclarationDescriptor>();\n        nameToDescriptor.put(\"kotlin::Int.plus(Int)\", standardFunction(builtIns.getInt(), \"plus\", builtIns.getIntType()));\n        FunctionDescriptor descriptorForGet = standardFunction(builtIns.getArray(), \"get\", builtIns.getIntType());\n        nameToDescriptor.put(\"kotlin::Array.get(Int)\", descriptorForGet.getOriginal());\n        nameToDescriptor.put(\"kotlin::Int.compareTo(Double)\", standardFunction(builtIns.getInt(), \"compareTo\", builtIns.getDoubleType()));\n        @NotNull\n        FunctionDescriptor descriptorForSet = standardFunction(builtIns.getArray(), \"set\", builtIns.getIntType(), builtIns.getIntType());\n        nameToDescriptor.put(\"kotlin::Array.set(Int, Int)\", descriptorForSet.getOriginal());\n\n        Map<String, PsiElement> nameToDeclaration = new HashMap<String, PsiElement>();\n        PsiClass java_util_Collections = findClass(\"java.util.Collections\");\n        nameToDeclaration.put(\"java::java.util.Collections.emptyList()\", findMethod(java_util_Collections, \"emptyList\"));\n        nameToDeclaration.put(\"java::java.util.Collections\", java_util_Collections);\n        PsiClass java_util_List = findClass(\"java.util.ArrayList\");\n        nameToDeclaration.put(\"java::java.util.ArrayList\", java_util_List);\n        nameToDeclaration.put(\"java::java.util.ArrayList.set()\", java_util_List.findMethodsByName(\"set\", true)[0]);\n        nameToDeclaration.put(\"java::java.util.ArrayList.get()\", java_util_List.findMethodsByName(\"get\", true)[0]);\n        nameToDeclaration.put(\"java::java\", findPackage(\"java\"));\n        nameToDeclaration.put(\"java::java.util\", findPackage(\"java.util\"));\n        nameToDeclaration.put(\"java::java.lang\", findPackage(\"java.lang\"));\n        nameToDeclaration.put(\"java::java.lang.Object\", findClass(\"java.lang.Object\"));\n        PsiClass java_lang_System = findClass(\"java.lang.System\");\n        nameToDeclaration.put(\"java::java.lang.System\", java_lang_System);\n        PsiMethod[] methods = findClass(\"java.io.PrintStream\").findMethodsByName(\"print\", true);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(Object)\", methods[8]);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(Int)\", methods[2]);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(char[])\", methods[6]);\n        nameToDeclaration.put(\"java::java.io.PrintStream.print(Double)\", methods[5]);\n        nameToDeclaration.put(\"java::java.lang.System.out\", java_lang_System.findFieldByName(\"out\", true));\n        PsiClass java_lang_Number = findClass(\"java.lang.Number\");\n        nameToDeclaration.put(\"java::java.lang.Number\", java_lang_Number);\n        nameToDeclaration.put(\"java::java.lang.Number.intValue()\", java_lang_Number.findMethodsByName(\"intValue\", true)[0]);\n\n        return new ExpectedResolveData(nameToDescriptor, nameToDeclaration, getEnvironment()) {\n            @Override\n            protected JetFile createJetFile(String fileName, String text) {\n                return createCheckAndReturnPsiFile(fileName, null, text);\n            }\n        };\n    }","commit_id":"a90db452ff14028454f17ef7fb134cb0dd9936a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private FunctionDescriptor standardFunction(ClassDescriptor classDescriptor, String name, JetType parameterType) {\n        List<TypeProjection> typeArguments = Collections.emptyList();\n        return standardFunction(classDescriptor, typeArguments, name, parameterType);\n    }","id":32248,"modified_method":"@NotNull\n    private FunctionDescriptor standardFunction(ClassDescriptor classDescriptor, String name, JetType... parameterTypes) {\n        List<JetType> parameterTypeList = Arrays.asList(parameterTypes);\n\n        TemporaryBindingTrace traceWithFakeArgumentInfo = TemporaryBindingTrace.create(new BindingTraceContext(),\n                                                                                       \"trace to store fake argument for\", name);\n        int index = 0;\n        List<JetExpression> valueArguments = Lists.newArrayList();\n        for (JetType type : parameterTypeList) {\n            final JetReferenceExpression fakeArgument = JetPsiFactory.createSimpleName(getProject(), \"fakeArgument\" + index++);\n            valueArguments.add(fakeArgument);\n            traceWithFakeArgumentInfo.record(EXPRESSION_TYPE, fakeArgument, type);\n        }\n\n        ExpressionTypingServices expressionTypingServices = new InjectorForTests(getProject()).getExpressionTypingServices();\n\n        ExpressionTypingContext context = ExpressionTypingContext.newContext(\n                expressionTypingServices, traceWithFakeArgumentInfo, classDescriptor.getDefaultType().getMemberScope(),\n                DataFlowInfo.EMPTY, TypeUtils.NO_EXPECTED_TYPE, false);\n\n        OverloadResolutionResults<FunctionDescriptor> functions = resolveFakeCall(\n                ReceiverValue.NO_RECEIVER, context, valueArguments, Name.identifier(name));\n\n        for (ResolvedCall<? extends FunctionDescriptor> resolvedCall : functions.getResultingCalls()) {\n            List<ValueParameterDescriptor> unsubstitutedValueParameters = resolvedCall.getResultingDescriptor().getValueParameters();\n            for (int i = 0, unsubstitutedValueParametersSize = unsubstitutedValueParameters.size(); i < unsubstitutedValueParametersSize; i++) {\n                ValueParameterDescriptor unsubstitutedValueParameter = unsubstitutedValueParameters.get(i);\n                if (unsubstitutedValueParameter.getType().equals(parameterTypes[i])) {\n                    return resolvedCall.getResultingDescriptor();\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"Not found: kotlin::\" + classDescriptor.getName() + \".\" + name + \"(\" + parameterTypeList + \")\");\n    }","commit_id":"a90db452ff14028454f17ef7fb134cb0dd9936a6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    @Override\n    public ParseResult fun(@NotNull Pair<Token<PyElementType>, List<Token<PyElementType>>> value) {\n      final Token<PyElementType> first = value.getFirst();\n      final List<Token<PyElementType>> rest = value.getSecond();\n      final TextRange firstRange = first.getRange();\n      final String firstText = first.getText().toString();\n\n      if (rest.isEmpty()) {\n        final PyBuiltinCache builtinCache = PyBuiltinCache.getInstance(myAnchor);\n\n        if (\"unknown\".equals(firstText)) {\n          return EMPTY_RESULT;\n        }\n        else if (PyNames.NONE.equals(firstText)) {\n          return new ParseResult(PyNoneType.INSTANCE, firstRange);\n        }\n        else if (\"integer\".equals(firstText) || (\"long\".equals(firstText) && LanguageLevel.forElement(myAnchor).isPy3K())) {\n          return new ParseResult(builtinCache.getIntType(), firstRange);\n        }\n        else if (\"string\".equals(firstText)) {\n          return new ParseResult(builtinCache.getStringType(LanguageLevel.forElement(myAnchor)), firstRange);\n        }\n        else if (\"bytes\".equals(firstText)) {\n          return new ParseResult(builtinCache.getBytesType(LanguageLevel.forElement(myAnchor)), firstRange);\n        }\n        else if (\"unicode\".equals(firstText)) {\n          return new ParseResult(builtinCache.getUnicodeType(LanguageLevel.forElement(myAnchor)), firstRange);\n        }\n        else if (\"boolean\".equals(firstText)) {\n          return new ParseResult(builtinCache.getBoolType(), firstRange);\n        }\n        else if (\"dictionary\".equals(firstText)) {\n          return new ParseResult(builtinCache.getDictType(), firstRange);\n        }\n\n        final PyType builtinType = builtinCache.getObjectType(firstText);\n        if (builtinType != null) {\n          return new ParseResult(builtinType, firstRange);\n        }\n      }\n\n      final PsiFile file = myAnchor.getContainingFile();\n\n      if (file instanceof PyFile) {\n        final PyFile pyFile = (PyFile)file;\n\n        PsiElement resolved = pyFile.getElementNamed(firstText);\n        if (resolved == null) {\n          resolved = new QualifiedNameResolverImpl(firstText).fromElement(myAnchor).firstResult();\n        }\n\n        if (resolved instanceof PyTypedElement) {\n          final Map<TextRange, PyType> types = new HashMap<TextRange, PyType>();\n          final Map<PyType, TextRange> fullRanges = new HashMap<PyType, TextRange>();\n          final Map<PyType, PyImportElement> imports = new HashMap<PyType, PyImportElement>();\n          final TypeEvalContext context = TypeEvalContext.codeInsightFallback();\n          PyType type = context.getType((PyTypedElement)resolved);\n          if (type != null) {\n            if (type instanceof PyClassLikeType) {\n              type = ((PyClassLikeType)type).toInstance();\n            }\n            types.put(firstRange, type);\n            fullRanges.put(type, firstRange);\n            for (PyFromImportStatement fromImportStatement : pyFile.getFromImports()) {\n              for (PyImportElement importElement : fromImportStatement.getImportElements()) {\n                if (firstText.equals(importElement.getVisibleName())) {\n                  imports.put(type, importElement);\n                }\n              }\n            }\n\n            final PyResolveContext resolveContext = PyResolveContext.defaultContext().withTypeEvalContext(context);\n            final PyExpression expression = myAnchor instanceof PyExpression ? (PyExpression)myAnchor : null;\n\n            for (Token<PyElementType> token : rest) {\n              final List<? extends RatedResolveResult> results =\n                type.resolveMember(token.getText().toString(), expression, AccessDirection.READ, resolveContext);\n              if (results != null && !results.isEmpty()) {\n                resolved = results.get(0).getElement();\n                if (resolved instanceof PyTypedElement) {\n                  type = context.getType((PyTypedElement)resolved);\n                }\n              }\n              if (type == null) {\n                break;\n              }\n              types.put(token.getRange(), type);\n              fullRanges.put(type, TextRange.create(firstRange.getStartOffset(), token.getRange().getEndOffset()));\n            }\n            if (type != null) {\n              return new ParseResult(type, types, fullRanges, imports);\n            }\n          }\n        }\n      }\n\n      if (rest.isEmpty()) {\n        final Collection<PyClass> classes = PyClassNameIndex.find(firstText, myAnchor.getProject(), true);\n        if (classes.size() == 1) {\n          final PyClassTypeImpl type = new PyClassTypeImpl(classes.iterator().next(), false);\n          type.assertValid(\"PyClassNameIndex.find().iterator().next()\");\n          return new ParseResult(type, firstRange);\n        }\n      }\n\n      return EMPTY_RESULT;\n    }","id":32249,"modified_method":"@Nullable\n    @Override\n    public ParseResult fun(@NotNull Pair<Token<PyElementType>, List<Token<PyElementType>>> value) {\n      final Token<PyElementType> first = value.getFirst();\n      final List<Token<PyElementType>> rest = value.getSecond();\n      final TextRange firstRange = first.getRange();\n      final String firstText = first.getText().toString();\n\n      if (rest.isEmpty()) {\n        final PyBuiltinCache builtinCache = PyBuiltinCache.getInstance(myAnchor);\n\n        if (\"unknown\".equals(firstText)) {\n          return EMPTY_RESULT;\n        }\n        else if (PyNames.NONE.equals(firstText)) {\n          return new ParseResult(PyNoneType.INSTANCE, firstRange);\n        }\n        else if (\"integer\".equals(firstText) || (\"long\".equals(firstText) && LanguageLevel.forElement(myAnchor).isPy3K())) {\n          final PyClassType type = builtinCache.getIntType();\n          return type != null ? new ParseResult(type, firstRange) : EMPTY_RESULT;\n        }\n        else if (\"string\".equals(firstText)) {\n          final PyType type = builtinCache.getStringType(LanguageLevel.forElement(myAnchor));\n          return type != null ? new ParseResult(type, firstRange) : EMPTY_RESULT;\n        }\n        else if (\"bytes\".equals(firstText)) {\n          final PyClassType type = builtinCache.getBytesType(LanguageLevel.forElement(myAnchor));\n          return type != null ? new ParseResult(type, firstRange) : EMPTY_RESULT;\n        }\n        else if (\"unicode\".equals(firstText)) {\n          final PyClassType type = builtinCache.getUnicodeType(LanguageLevel.forElement(myAnchor));\n          return type != null ? new ParseResult(type, firstRange) : EMPTY_RESULT;\n        }\n        else if (\"boolean\".equals(firstText)) {\n          final PyClassType type = builtinCache.getBoolType();\n          return type != null ? new ParseResult(type, firstRange) : EMPTY_RESULT;\n        }\n        else if (\"dictionary\".equals(firstText)) {\n          final PyClassType type = builtinCache.getDictType();\n          return type != null ? new ParseResult(type, firstRange) : EMPTY_RESULT;\n        }\n\n        final PyType builtinType = builtinCache.getObjectType(firstText);\n        if (builtinType != null) {\n          return new ParseResult(builtinType, firstRange);\n        }\n      }\n\n      final PsiFile file = myAnchor.getContainingFile();\n\n      if (file instanceof PyFile) {\n        final PyFile pyFile = (PyFile)file;\n\n        PsiElement resolved = pyFile.getElementNamed(firstText);\n        if (resolved == null) {\n          resolved = new QualifiedNameResolverImpl(firstText).fromElement(myAnchor).firstResult();\n        }\n\n        if (resolved instanceof PyTypedElement) {\n          final Map<TextRange, PyType> types = new HashMap<TextRange, PyType>();\n          final Map<PyType, TextRange> fullRanges = new HashMap<PyType, TextRange>();\n          final Map<PyType, PyImportElement> imports = new HashMap<PyType, PyImportElement>();\n          final TypeEvalContext context = TypeEvalContext.codeInsightFallback();\n          PyType type = context.getType((PyTypedElement)resolved);\n          if (type != null) {\n            if (type instanceof PyClassLikeType) {\n              type = ((PyClassLikeType)type).toInstance();\n            }\n            types.put(firstRange, type);\n            fullRanges.put(type, firstRange);\n            for (PyFromImportStatement fromImportStatement : pyFile.getFromImports()) {\n              for (PyImportElement importElement : fromImportStatement.getImportElements()) {\n                if (firstText.equals(importElement.getVisibleName())) {\n                  imports.put(type, importElement);\n                }\n              }\n            }\n\n            final PyResolveContext resolveContext = PyResolveContext.defaultContext().withTypeEvalContext(context);\n            final PyExpression expression = myAnchor instanceof PyExpression ? (PyExpression)myAnchor : null;\n\n            for (Token<PyElementType> token : rest) {\n              final List<? extends RatedResolveResult> results =\n                type.resolveMember(token.getText().toString(), expression, AccessDirection.READ, resolveContext);\n              if (results != null && !results.isEmpty()) {\n                resolved = results.get(0).getElement();\n                if (resolved instanceof PyTypedElement) {\n                  type = context.getType((PyTypedElement)resolved);\n                }\n              }\n              if (type == null) {\n                break;\n              }\n              types.put(token.getRange(), type);\n              fullRanges.put(type, TextRange.create(firstRange.getStartOffset(), token.getRange().getEndOffset()));\n            }\n            if (type != null) {\n              return new ParseResult(type, types, fullRanges, imports);\n            }\n          }\n        }\n      }\n\n      if (rest.isEmpty()) {\n        final Collection<PyClass> classes = PyClassNameIndex.find(firstText, myAnchor.getProject(), true);\n        if (classes.size() == 1) {\n          final PyClassTypeImpl type = new PyClassTypeImpl(classes.iterator().next(), false);\n          type.assertValid(\"PyClassNameIndex.find().iterator().next()\");\n          return new ParseResult(type, firstRange);\n        }\n      }\n\n      return EMPTY_RESULT;\n    }","commit_id":"145f40b6df0f429e35ec7f71445bef19b776e49e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void deleteFolder(BookmarksFolder folder)\n\t\tthrows PortalException, SystemException {\n\n\t\tdeleteFolder(folder, true);\n\t}","id":32250,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic BookmarksFolder deleteFolder(BookmarksFolder folder)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn deleteFolder(folder, true);\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tdeleteFolder(folder);\n\t}","id":32251,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic BookmarksFolder deleteFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = bookmarksFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\treturn deleteFolder(folder);\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(\n\t\t\tBookmarksFolder folder, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tList<BookmarksFolder> folders = bookmarksFolderPersistence.findByG_P_S(\n\t\t\tfolder.getGroupId(), folder.getFolderId(),\n\t\t\tWorkflowConstants.STATUS_ANY);\n\n\t\tfor (BookmarksFolder curFolder : folders) {\n\t\t\tif (includeTrashedEntries || !curFolder.isInTrash()) {\n\t\t\t\tdeleteFolder(curFolder);\n\t\t\t}\n\t\t}\n\n\t\t// Folder\n\n\t\tbookmarksFolderPersistence.remove(folder);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tfolder, ResourceConstants.SCOPE_INDIVIDUAL);\n\n\t\t// Entries\n\n\t\tbookmarksEntryLocalService.deleteEntries(\n\t\t\tfolder.getGroupId(), folder.getFolderId(), includeTrashedEntries);\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tBookmarksFolder.class.getName(), folder.getFolderId());\n\n\t\t// Subscriptions\n\n\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\tfolder.getCompanyId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getFolderId());\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(\n\t\t\tBookmarksFolder.class.getName(), folder.getFolderId());\n\t}","id":32252,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic BookmarksFolder deleteFolder(\n\t\t\tBookmarksFolder folder, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tList<BookmarksFolder> folders = bookmarksFolderPersistence.findByG_P_S(\n\t\t\tfolder.getGroupId(), folder.getFolderId(),\n\t\t\tWorkflowConstants.STATUS_ANY);\n\n\t\tfor (BookmarksFolder curFolder : folders) {\n\t\t\tif (includeTrashedEntries || !curFolder.isInTrash()) {\n\t\t\t\tdeleteFolder(curFolder);\n\t\t\t}\n\t\t}\n\n\t\t// Folder\n\n\t\tbookmarksFolderPersistence.remove(folder);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tfolder, ResourceConstants.SCOPE_INDIVIDUAL);\n\n\t\t// Entries\n\n\t\tbookmarksEntryLocalService.deleteEntries(\n\t\t\tfolder.getGroupId(), folder.getFolderId(), includeTrashedEntries);\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tBookmarksFolder.class.getName(), folder.getFolderId());\n\n\t\t// Subscriptions\n\n\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\tfolder.getCompanyId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getFolderId());\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(\n\t\t\tBookmarksFolder.class.getName(), folder.getFolderId());\n\n\t\treturn folder;\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolders(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<BookmarksFolder> folders = bookmarksFolderPersistence.findByG_P(\n\t\t\tgroupId, BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\tfor (BookmarksFolder folder : folders) {\n\t\t\tdeleteFolder(folder);\n\t\t}\n\t}","id":32253,"modified_method":"public void deleteFolders(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<BookmarksFolder> folders = bookmarksFolderPersistence.findByG_P(\n\t\t\tgroupId, BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\tfor (BookmarksFolder folder : folders) {\n\t\t\tbookmarksFolderLocalService.deleteFolder(folder);\n\t\t}\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void mergeFolders(BookmarksFolder fromFolder, long toFolderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<BookmarksFolder> folders = bookmarksFolderPersistence.findByG_P(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (BookmarksFolder folder : folders) {\n\t\t\tmergeFolders(folder, toFolderId);\n\t\t}\n\n\t\tList<BookmarksEntry> entries = bookmarksEntryPersistence.findByG_F(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (BookmarksEntry entry : entries) {\n\t\t\tentry.setFolderId(toFolderId);\n\n\t\t\tbookmarksEntryPersistence.update(entry);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\tBookmarksEntry.class);\n\n\t\t\tindexer.reindex(entry);\n\t\t}\n\n\t\tdeleteFolder(fromFolder);\n\t}","id":32254,"modified_method":"protected void mergeFolders(BookmarksFolder fromFolder, long toFolderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<BookmarksFolder> folders = bookmarksFolderPersistence.findByG_P(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (BookmarksFolder folder : folders) {\n\t\t\tmergeFolders(folder, toFolderId);\n\t\t}\n\n\t\tList<BookmarksEntry> entries = bookmarksEntryPersistence.findByG_F(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (BookmarksEntry entry : entries) {\n\t\t\tentry.setFolderId(toFolderId);\n\n\t\t\tbookmarksEntryPersistence.update(entry);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\tBookmarksEntry.class);\n\n\t\t\tindexer.reindex(entry);\n\t\t}\n\n\t\tbookmarksFolderLocalService.deleteFolder(fromFolder);\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(long folderId, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = bookmarksFolderLocalService.getFolder(\n\t\t\tfolderId);\n\n\t\tdeleteFolder(folder, includeTrashedEntries);\n\t}","id":32255,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic BookmarksFolder deleteFolder(\n\t\t\tlong folderId, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = bookmarksFolderLocalService.getFolder(\n\t\t\tfolderId);\n\n\t\treturn deleteFolder(folder, includeTrashedEntries);\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public BookmarksFolder updateStatus(\n\t\t\tlong userId, BookmarksFolder folder, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tint oldStatus = folder.getStatus();\n\n\t\tfolder.setStatus(status);\n\t\tfolder.setStatusByUserId(userId);\n\t\tfolder.setStatusByUserName(user.getFullName());\n\t\tfolder.setStatusDate(new Date());\n\n\t\tbookmarksFolderPersistence.update(folder);\n\n\t\t// Folders and entries\n\n\t\tList<Object> foldersAndEntries =\n\t\t\tbookmarksFolderLocalService.getFoldersAndEntries(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tupdateDependentStatus(foldersAndEntries, status);\n\n\t\t// Trash\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.deleteEntry(\n\t\t\t\tBookmarksFolder.class.getName(), folder.getFolderId());\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\t\tfolder.getFolderId(), oldStatus, null, null);\n\t\t}\n\n\t\treturn folder;\n\t}","id":32256,"modified_method":"public BookmarksFolder updateStatus(\n\t\t\tlong userId, BookmarksFolder folder, int status)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tint oldStatus = folder.getStatus();\n\n\t\tfolder.setStatus(status);\n\t\tfolder.setStatusByUserId(userId);\n\t\tfolder.setStatusByUserName(user.getFullName());\n\t\tfolder.setStatusDate(new Date());\n\n\t\tbookmarksFolderPersistence.update(folder);\n\n\t\t// Folders and entries\n\n\t\tList<Object> foldersAndEntries =\n\t\t\tbookmarksFolderLocalService.getFoldersAndEntries(\n\t\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tupdateDependentStatus(foldersAndEntries, status);\n\n\t\t// Trash\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.deleteEntry(\n\t\t\t\tBookmarksFolder.class.getName(), folder.getFolderId());\n\t\t}\n\t\telse if (status == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\tuserId, folder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\t\tfolder.getFolderId(), oldStatus, null, null);\n\t\t}\n\n\t\t// Index\n\n\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\tBookmarksFolder.class);\n\n\t\tindexer.reindex(folder);\n\n\t\treturn folder;\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void initServices() {\n\t\tInitUtil.initWithSpring();\n\n\t\t_deleteDLDirectories();\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\tJCRFactoryUtil.prepare();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tFileUtil.mkdirs(\n\t\t\t\tPropsValues.LUCENE_DIR + TestPropsValues.getCompanyId());\n\n\t\t\tLuceneHelperUtil.startup(TestPropsValues.getCompanyId());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Template manager\n\n\t\ttry {\n\t\t\tTemplateManagerUtil.init();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Indexers\n\n\t\tIndexerRegistryUtil.register(new BlogsIndexer());\n\t\tIndexerRegistryUtil.register(new ContactIndexer());\n\t\tIndexerRegistryUtil.register(new UserIndexer());\n\t\tIndexerRegistryUtil.register(new BookmarksEntryIndexer());\n\t\tIndexerRegistryUtil.register(new DLFileEntryIndexer());\n\t\tIndexerRegistryUtil.register(new DLFolderIndexer());\n\t\tIndexerRegistryUtil.register(new MBMessageIndexer());\n\t\tIndexerRegistryUtil.register(new TrashIndexer());\n\t\tIndexerRegistryUtil.register(new WikiNodeIndexer());\n\t\tIndexerRegistryUtil.register(new WikiPageIndexer());\n\t\tIndexerRegistryUtil.register(new JournalIndexer());\n\n\t\t// Upgrade\n\n\t\ttry {\n\t\t\tDBUpgrader.upgrade();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender synchronousMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(\n\t\t\tmessageBus, messageSender, synchronousMessageSender);\n\n\t\t// Scheduler\n\n\t\ttry {\n\t\t\tSchedulerEngineHelperUtil.start();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Verify\n\n\t\ttry {\n\t\t\tDBUpgrader.verify();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Class names\n\n\t\t_checkClassNames();\n\n\t\t// Resource actions\n\n\t\ttry {\n\t\t\t_checkResourceActions();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Asset\n\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew BlogsEntryAssetRendererFactory());\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew DLFileEntryAssetRendererFactory());\n\n\t\t// Trash\n\n\t\tTrashHandlerRegistryUtil.register(new BlogsEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileShortcutTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFolderTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new JournalArticleTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBCategoryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBThreadTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiNodeTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiPageTrashHandler());\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.register(new BlogsEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new DLFileEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(\n\t\t\tnew JournalArticleWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBDiscussionWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBMessageWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new UserWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new WikiPageWorkflowHandler());\n\n\t\t// Company\n\n\t\ttry {\n\t\t\tCompanyLocalServiceUtil.checkCompany(\n\t\t\t\tTestPropsValues.COMPANY_WEB_ID);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":32257,"modified_method":"public static void initServices() {\n\t\tInitUtil.initWithSpring();\n\n\t\t_deleteDLDirectories();\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\tJCRFactoryUtil.prepare();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tFileUtil.mkdirs(\n\t\t\t\tPropsValues.LUCENE_DIR + TestPropsValues.getCompanyId());\n\n\t\t\tLuceneHelperUtil.startup(TestPropsValues.getCompanyId());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Template manager\n\n\t\ttry {\n\t\t\tTemplateManagerUtil.init();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Indexers\n\n\t\tIndexerRegistryUtil.register(new BlogsIndexer());\n\t\tIndexerRegistryUtil.register(new ContactIndexer());\n\t\tIndexerRegistryUtil.register(new UserIndexer());\n\t\tIndexerRegistryUtil.register(new BookmarksEntryIndexer());\n\t\tIndexerRegistryUtil.register(new BookmarksFolderIndexer());\n\t\tIndexerRegistryUtil.register(new DLFileEntryIndexer());\n\t\tIndexerRegistryUtil.register(new DLFolderIndexer());\n\t\tIndexerRegistryUtil.register(new MBMessageIndexer());\n\t\tIndexerRegistryUtil.register(new TrashIndexer());\n\t\tIndexerRegistryUtil.register(new WikiNodeIndexer());\n\t\tIndexerRegistryUtil.register(new WikiPageIndexer());\n\t\tIndexerRegistryUtil.register(new JournalIndexer());\n\n\t\t// Upgrade\n\n\t\ttry {\n\t\t\tDBUpgrader.upgrade();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender synchronousMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(\n\t\t\tmessageBus, messageSender, synchronousMessageSender);\n\n\t\t// Scheduler\n\n\t\ttry {\n\t\t\tSchedulerEngineHelperUtil.start();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Verify\n\n\t\ttry {\n\t\t\tDBUpgrader.verify();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Class names\n\n\t\t_checkClassNames();\n\n\t\t// Resource actions\n\n\t\ttry {\n\t\t\t_checkResourceActions();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Asset\n\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew BlogsEntryAssetRendererFactory());\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew DLFileEntryAssetRendererFactory());\n\n\t\t// Trash\n\n\t\tTrashHandlerRegistryUtil.register(new BlogsEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileShortcutTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFolderTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new JournalArticleTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBCategoryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBThreadTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiNodeTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiPageTrashHandler());\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.register(new BlogsEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new DLFileEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(\n\t\t\tnew JournalArticleWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBDiscussionWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBMessageWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new UserWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new WikiPageWorkflowHandler());\n\n\t\t// Company\n\n\t\ttry {\n\t\t\tCompanyLocalServiceUtil.checkCompany(\n\t\t\t\tTestPropsValues.COMPANY_WEB_ID);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"655a44002276b117c3261b0750c8de0b3f3b3ff2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFolder(long folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().deleteFolder(folderId);\n\t}","id":32258,"modified_method":"public static com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tlong folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().deleteFolder(folderId);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().deleteFolder(folder);\n\t}","id":32259,"modified_method":"public static com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().deleteFolder(folder);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder,\n\t\tboolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().deleteFolder(folder, includeTrashedEntries);\n\t}","id":32260,"modified_method":"public static com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder,\n\t\tboolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().deleteFolder(folder, includeTrashedEntries);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFolder(long folderId, boolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().deleteFolder(folderId, includeTrashedEntries);\n\t}","id":32261,"modified_method":"public static com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tlong folderId, boolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().deleteFolder(folderId, includeTrashedEntries);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder,\n\t\tboolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_bookmarksFolderLocalService.deleteFolder(folder, includeTrashedEntries);\n\t}","id":32262,"modified_method":"public com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder,\n\t\tboolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _bookmarksFolderLocalService.deleteFolder(folder,\n\t\t\tincludeTrashedEntries);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(long folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_bookmarksFolderLocalService.deleteFolder(folderId);\n\t}","id":32263,"modified_method":"public com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tlong folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _bookmarksFolderLocalService.deleteFolder(folderId);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(long folderId, boolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_bookmarksFolderLocalService.deleteFolder(folderId,\n\t\t\tincludeTrashedEntries);\n\t}","id":32264,"modified_method":"public com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tlong folderId, boolean includeTrashedEntries)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _bookmarksFolderLocalService.deleteFolder(folderId,\n\t\t\tincludeTrashedEntries);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_bookmarksFolderLocalService.deleteFolder(folder);\n\t}","id":32265,"modified_method":"public com.liferay.portlet.bookmarks.model.BookmarksFolder deleteFolder(\n\t\tcom.liferay.portlet.bookmarks.model.BookmarksFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _bookmarksFolderLocalService.deleteFolder(folder);\n\t}","commit_id":"5470875a255eb9877feca096581f00ec3e5a8a93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic void deleteFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tdeleteFolder(folderId, true);\n\t}","id":32266,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic DLFolder deleteFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn deleteFolder(folderId, true);\n\t}","commit_id":"6a9ba4c38904697cd1eee871e82f73784306ecf8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic void deleteFolder(DLFolder dlFolder, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tList<DLFolder> dlFolders = dlFolderPersistence.findByG_P(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId());\n\n\t\tfor (DLFolder curDLFolder : dlFolders) {\n\t\t\tif (includeTrashedEntries || !curDLFolder.isInTrash()) {\n\t\t\t\tdlFolderLocalService.deleteFolder(\n\t\t\t\t\tcurDLFolder, includeTrashedEntries);\n\t\t\t}\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tdlFolder.getCompanyId(), DLFolder.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, dlFolder.getFolderId());\n\n\t\t// WebDAVProps\n\n\t\twebDAVPropsLocalService.deleteWebDAVProps(\n\t\t\tDLFolder.class.getName(), dlFolder.getFolderId());\n\n\t\t// File entries\n\n\t\tdlFileEntryLocalService.deleteFileEntries(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(),\n\t\t\tincludeTrashedEntries);\n\n\t\t// File entry types\n\n\t\tdlFileEntryTypeLocalService.unsetFolderFileEntryTypes(\n\t\t\tdlFolder.getFolderId());\n\n\t\t// File shortcuts\n\n\t\tdlFileShortcutLocalService.deleteFileShortcuts(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(),\n\t\t\tincludeTrashedEntries);\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFolder.class.getName(), dlFolder.getFolderId());\n\n\t\t// App helper\n\n\t\tdlAppHelperLocalService.deleteFolder(new LiferayFolder(dlFolder));\n\n\t\t// Folder\n\n\t\tdlFolderPersistence.remove(dlFolder);\n\n\t\t// Directory\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteDirectory(\n\t\t\t\tdlFolder.getCompanyId(), dlFolder.getFolderId(),\n\t\t\t\tStringPool.BLANK);\n\t\t}\n\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t}\n\t\t}\n\t}","id":32267,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic DLFolder deleteFolder(\n\t\t\tDLFolder dlFolder, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tList<DLFolder> dlFolders = dlFolderPersistence.findByG_P(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId());\n\n\t\tfor (DLFolder curDLFolder : dlFolders) {\n\t\t\tif (includeTrashedEntries || !curDLFolder.isInTrash()) {\n\t\t\t\tdlFolderLocalService.deleteFolder(\n\t\t\t\t\tcurDLFolder, includeTrashedEntries);\n\t\t\t}\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tdlFolder.getCompanyId(), DLFolder.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, dlFolder.getFolderId());\n\n\t\t// WebDAVProps\n\n\t\twebDAVPropsLocalService.deleteWebDAVProps(\n\t\t\tDLFolder.class.getName(), dlFolder.getFolderId());\n\n\t\t// File entries\n\n\t\tdlFileEntryLocalService.deleteFileEntries(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(),\n\t\t\tincludeTrashedEntries);\n\n\t\t// File entry types\n\n\t\tdlFileEntryTypeLocalService.unsetFolderFileEntryTypes(\n\t\t\tdlFolder.getFolderId());\n\n\t\t// File shortcuts\n\n\t\tdlFileShortcutLocalService.deleteFileShortcuts(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(),\n\t\t\tincludeTrashedEntries);\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFolder.class.getName(), dlFolder.getFolderId());\n\n\t\t// App helper\n\n\t\tdlAppHelperLocalService.deleteFolder(new LiferayFolder(dlFolder));\n\n\t\t// Folder\n\n\t\tdlFolderPersistence.remove(dlFolder);\n\n\t\t// Directory\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteDirectory(\n\t\t\t\tdlFolder.getCompanyId(), dlFolder.getFolderId(),\n\t\t\t\tStringPool.BLANK);\n\t\t}\n\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t}\n\t\t}\n\n\t\treturn dlFolder;\n\t}","commit_id":"6a9ba4c38904697cd1eee871e82f73784306ecf8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic void deleteFolder(DLFolder dlFolder)\n\t\tthrows PortalException, SystemException {\n\n\t\tdeleteFolder(dlFolder, true);\n\t}","id":32268,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic DLFolder deleteFolder(DLFolder dlFolder)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn deleteFolder(dlFolder, true);\n\t}","commit_id":"6a9ba4c38904697cd1eee871e82f73784306ecf8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic void deleteFolder(long folderId, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\tdeleteFolder(dlFolder, includeTrashedEntries);\n\t}","id":32269,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic DLFolder deleteFolder(long folderId, boolean includeTrashedEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\treturn deleteFolder(dlFolder, includeTrashedEntries);\n\t}","commit_id":"6a9ba4c38904697cd1eee871e82f73784306ecf8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolders(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<JournalFolder> folders = journalFolderPersistence.findByG_P(\n\t\t\tgroupId, JournalFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\tfor (JournalFolder folder : folders) {\n\t\t\tdeleteFolder(folder);\n\t\t}\n\t}","id":32270,"modified_method":"public void deleteFolders(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<JournalFolder> folders = journalFolderPersistence.findByG_P(\n\t\t\tgroupId, JournalFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\tfor (JournalFolder folder : folders) {\n\t\t\tjournalFolderLocalService.deleteFolder(folder);\n\t\t}\n\t}","commit_id":"935280f05e24ed7f8ac09c0de7771e30e5004aea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\tdeleteFolder(folder);\n\t}","id":32271,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic JournalFolder deleteFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tJournalFolder folder = journalFolderPersistence.findByPrimaryKey(\n\t\t\tfolderId);\n\n\t\treturn deleteFolder(folder);\n\t}","commit_id":"935280f05e24ed7f8ac09c0de7771e30e5004aea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void mergeFolders(JournalFolder fromFolder, long toFolderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<JournalFolder> folders = journalFolderPersistence.findByG_P(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (JournalFolder folder : folders) {\n\t\t\tmergeFolders(folder, toFolderId);\n\t\t}\n\n\t\tList<JournalArticle> articles = journalArticlePersistence.findByG_F(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (JournalArticle article : articles) {\n\t\t\tarticle.setFolderId(toFolderId);\n\n\t\t\tjournalArticlePersistence.update(article);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\tJournalArticle.class);\n\n\t\t\tindexer.reindex(article);\n\t\t}\n\n\t\tdeleteFolder(fromFolder);\n\t}","id":32272,"modified_method":"protected void mergeFolders(JournalFolder fromFolder, long toFolderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<JournalFolder> folders = journalFolderPersistence.findByG_P(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (JournalFolder folder : folders) {\n\t\t\tmergeFolders(folder, toFolderId);\n\t\t}\n\n\t\tList<JournalArticle> articles = journalArticlePersistence.findByG_F(\n\t\t\tfromFolder.getGroupId(), fromFolder.getFolderId());\n\n\t\tfor (JournalArticle article : articles) {\n\t\t\tarticle.setFolderId(toFolderId);\n\n\t\t\tjournalArticlePersistence.update(article);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\tJournalArticle.class);\n\n\t\t\tindexer.reindex(article);\n\t\t}\n\n\t\tjournalFolderLocalService.deleteFolder(fromFolder);\n\t}","commit_id":"935280f05e24ed7f8ac09c0de7771e30e5004aea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(JournalFolder folder)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tList<JournalFolder> folders = journalFolderPersistence.findByG_P(\n\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tfor (JournalFolder curFolder : folders) {\n\t\t\tdeleteFolder(curFolder);\n\t\t}\n\n\t\t// Folder\n\n\t\tjournalFolderPersistence.remove(folder);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tfolder, ResourceConstants.SCOPE_INDIVIDUAL);\n\n\t\t// Entries\n\n\t\tjournalArticleLocalService.deleteArticles(\n\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tJournalFolder.class.getName(), folder.getFolderId());\n\t}","id":32273,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic JournalFolder deleteFolder(JournalFolder folder)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tList<JournalFolder> folders = journalFolderPersistence.findByG_P(\n\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\tfor (JournalFolder curFolder : folders) {\n\t\t\tdeleteFolder(curFolder);\n\t\t}\n\n\t\t// Folder\n\n\t\tjournalFolderPersistence.remove(folder);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tfolder, ResourceConstants.SCOPE_INDIVIDUAL);\n\n\t\t// Entries\n\n\t\tjournalArticleLocalService.deleteArticles(\n\t\t\tfolder.getGroupId(), folder.getFolderId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tJournalFolder.class.getName(), folder.getFolderId());\n\n\t\treturn folder;\n\t}","commit_id":"935280f05e24ed7f8ac09c0de7771e30e5004aea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void initServices() {\n\t\tInitUtil.initWithSpring();\n\n\t\t_deleteDLDirectories();\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\tJCRFactoryUtil.prepare();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tFileUtil.mkdirs(\n\t\t\t\tPropsValues.LUCENE_DIR + TestPropsValues.getCompanyId());\n\n\t\t\tLuceneHelperUtil.startup(TestPropsValues.getCompanyId());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Template manager\n\n\t\ttry {\n\t\t\tTemplateManagerUtil.init();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Indexers\n\n\t\tIndexerRegistryUtil.register(new BlogsIndexer());\n\t\tIndexerRegistryUtil.register(new ContactIndexer());\n\t\tIndexerRegistryUtil.register(new UserIndexer());\n\t\tIndexerRegistryUtil.register(new BookmarksEntryIndexer());\n\t\tIndexerRegistryUtil.register(new BookmarksFolderIndexer());\n\t\tIndexerRegistryUtil.register(new DLFileEntryIndexer());\n\t\tIndexerRegistryUtil.register(new DLFolderIndexer());\n\t\tIndexerRegistryUtil.register(new MBMessageIndexer());\n\t\tIndexerRegistryUtil.register(new TrashIndexer());\n\t\tIndexerRegistryUtil.register(new WikiNodeIndexer());\n\t\tIndexerRegistryUtil.register(new WikiPageIndexer());\n\t\tIndexerRegistryUtil.register(new JournalArticleIndexer());\n\n\t\t// Upgrade\n\n\t\ttry {\n\t\t\tDBUpgrader.upgrade();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender synchronousMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(\n\t\t\tmessageBus, messageSender, synchronousMessageSender);\n\n\t\t// Scheduler\n\n\t\ttry {\n\t\t\tSchedulerEngineHelperUtil.start();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Verify\n\n\t\ttry {\n\t\t\tDBUpgrader.verify();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Class names\n\n\t\t_checkClassNames();\n\n\t\t// Resource actions\n\n\t\ttry {\n\t\t\t_checkResourceActions();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Asset\n\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew BlogsEntryAssetRendererFactory());\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew DLFileEntryAssetRendererFactory());\n\n\t\t// Trash\n\n\t\tTrashHandlerRegistryUtil.register(new BlogsEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileShortcutTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFolderTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new JournalArticleTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBCategoryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBThreadTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiNodeTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiPageTrashHandler());\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.register(new BlogsEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new DLFileEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(\n\t\t\tnew JournalArticleWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBDiscussionWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBMessageWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new UserWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new WikiPageWorkflowHandler());\n\n\t\t// Company\n\n\t\ttry {\n\t\t\tCompanyLocalServiceUtil.checkCompany(\n\t\t\t\tTestPropsValues.COMPANY_WEB_ID);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":32274,"modified_method":"public static void initServices() {\n\t\tInitUtil.initWithSpring();\n\n\t\t_deleteDLDirectories();\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\tJCRFactoryUtil.prepare();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tFileUtil.mkdirs(\n\t\t\t\tPropsValues.LUCENE_DIR + TestPropsValues.getCompanyId());\n\n\t\t\tLuceneHelperUtil.startup(TestPropsValues.getCompanyId());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Template manager\n\n\t\ttry {\n\t\t\tTemplateManagerUtil.init();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Indexers\n\n\t\tIndexerRegistryUtil.register(new BlogsIndexer());\n\t\tIndexerRegistryUtil.register(new ContactIndexer());\n\t\tIndexerRegistryUtil.register(new UserIndexer());\n\t\tIndexerRegistryUtil.register(new BookmarksEntryIndexer());\n\t\tIndexerRegistryUtil.register(new BookmarksFolderIndexer());\n\t\tIndexerRegistryUtil.register(new DLFileEntryIndexer());\n\t\tIndexerRegistryUtil.register(new DLFolderIndexer());\n\t\tIndexerRegistryUtil.register(new MBMessageIndexer());\n\t\tIndexerRegistryUtil.register(new TrashIndexer());\n\t\tIndexerRegistryUtil.register(new WikiNodeIndexer());\n\t\tIndexerRegistryUtil.register(new WikiPageIndexer());\n\t\tIndexerRegistryUtil.register(new JournalArticleIndexer());\n\t\tIndexerRegistryUtil.register(new JournalFolderIndexer());\n\n\t\t// Upgrade\n\n\t\ttry {\n\t\t\tDBUpgrader.upgrade();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender synchronousMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(\n\t\t\tmessageBus, messageSender, synchronousMessageSender);\n\n\t\t// Scheduler\n\n\t\ttry {\n\t\t\tSchedulerEngineHelperUtil.start();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Verify\n\n\t\ttry {\n\t\t\tDBUpgrader.verify();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Class names\n\n\t\t_checkClassNames();\n\n\t\t// Resource actions\n\n\t\ttry {\n\t\t\t_checkResourceActions();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Asset\n\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew BlogsEntryAssetRendererFactory());\n\t\tAssetRendererFactoryRegistryUtil.register(\n\t\t\tnew DLFileEntryAssetRendererFactory());\n\n\t\t// Trash\n\n\t\tTrashHandlerRegistryUtil.register(new BlogsEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileEntryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFileShortcutTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new DLFolderTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new JournalArticleTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBCategoryTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new MBThreadTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiNodeTrashHandler());\n\t\tTrashHandlerRegistryUtil.register(new WikiPageTrashHandler());\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.register(new BlogsEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new DLFileEntryWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(\n\t\t\tnew JournalArticleWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBDiscussionWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new MBMessageWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new UserWorkflowHandler());\n\t\tWorkflowHandlerRegistryUtil.register(new WikiPageWorkflowHandler());\n\n\t\t// Company\n\n\t\ttry {\n\t\t\tCompanyLocalServiceUtil.checkCompany(\n\t\t\t\tTestPropsValues.COMPANY_WEB_ID);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"935280f05e24ed7f8ac09c0de7771e30e5004aea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFolder(\n\t\tcom.liferay.portlet.journal.model.JournalFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().deleteFolder(folder);\n\t}","id":32275,"modified_method":"public static com.liferay.portlet.journal.model.JournalFolder deleteFolder(\n\t\tcom.liferay.portlet.journal.model.JournalFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().deleteFolder(folder);\n\t}","commit_id":"fd0c24a83027bb60142d650c905b40c28ea48edc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFolder(long folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().deleteFolder(folderId);\n\t}","id":32276,"modified_method":"public static com.liferay.portlet.journal.model.JournalFolder deleteFolder(\n\t\tlong folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().deleteFolder(folderId);\n\t}","commit_id":"fd0c24a83027bb60142d650c905b40c28ea48edc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(\n\t\tcom.liferay.portlet.journal.model.JournalFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_journalFolderLocalService.deleteFolder(folder);\n\t}","id":32277,"modified_method":"public com.liferay.portlet.journal.model.JournalFolder deleteFolder(\n\t\tcom.liferay.portlet.journal.model.JournalFolder folder)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _journalFolderLocalService.deleteFolder(folder);\n\t}","commit_id":"fd0c24a83027bb60142d650c905b40c28ea48edc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(long folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_journalFolderLocalService.deleteFolder(folderId);\n\t}","id":32278,"modified_method":"public com.liferay.portlet.journal.model.JournalFolder deleteFolder(\n\t\tlong folderId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _journalFolderLocalService.deleteFolder(folderId);\n\t}","commit_id":"fd0c24a83027bb60142d650c905b40c28ea48edc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    ourMap.clear();\n    ourRendererColors.clear();\n    final List children = element.getChildren(INFO);\n    if (children != null){\n      for (Object child : children) {\n        final Element infoElement = (Element)child;\n\n        final SeverityBasedTextAttributes highlightInfo = new SeverityBasedTextAttributes();\n        highlightInfo.readExternal(infoElement);\n\n        Color color = null;\n        final String colorStr = infoElement.getAttributeValue(COLOR);\n        if (colorStr != null){\n          color = new Color(Integer.parseInt(colorStr, 16));\n        }\n        registerSeverity(highlightInfo, color);\n      }\n    }\n    myOrder.clear();\n    myOrder.readExternal(element);\n\n    myReadOrder = new JDOMExternalizableStringList();\n    myReadOrder.addAll(myOrder);\n\n    final Set<String> knownSeverities = new HashSet<String>(ourMap.keySet()); //remove all irrelevant\n    knownSeverities.addAll(STANDART_SEVERITIES.keySet());\n    myOrder.retainAll(knownSeverities);\n\n    if (myOrder.isEmpty()) {\n      initOrder();\n    } else {//enforce include all known\n      List<HighlightSeverity> order = new ArrayList<HighlightSeverity>();\n      for (HighlightInfoType type : STANDART_SEVERITIES.values()) {\n        order.add(type.getSeverity(null));\n      }\n      Collections.sort(order);\n      for (int i = 0; i < order.size(); i++) {\n        HighlightSeverity stdSeverity = order.get(i);\n        if (!myOrder.contains(stdSeverity.toString())) {\n          for (int oIdx = 0; oIdx < myOrder.size(); oIdx++) {\n            final HighlightInfoType type = STANDART_SEVERITIES.get(myOrder.get(oIdx));\n            if (type != null && order.indexOf(type.getSeverity(null)) > i) {\n              myOrder.add(oIdx, stdSeverity.toString());\n              myReadOrder = null;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }","id":32279,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    ourMap.clear();\n    ourRendererColors.clear();\n    final List children = element.getChildren(INFO);\n    if (children != null){\n      for (Object child : children) {\n        final Element infoElement = (Element)child;\n\n        final SeverityBasedTextAttributes highlightInfo = new SeverityBasedTextAttributes();\n        highlightInfo.readExternal(infoElement);\n\n        Color color = null;\n        final String colorStr = infoElement.getAttributeValue(COLOR);\n        if (colorStr != null){\n          color = new Color(Integer.parseInt(colorStr, 16));\n        }\n        registerSeverity(highlightInfo, color);\n      }\n    }\n    myOrder.clear();\n    myOrder.readExternal(element);\n\n    myReadOrder = new JDOMExternalizableStringList();\n    myReadOrder.addAll(myOrder);\n\n    final List<String> knownSeverities = createCurrentSeverities();\n    myOrder.retainAll(knownSeverities);\n\n    if (myOrder.isEmpty()) {\n      initOrder();\n    }\n    //enforce include all known\n    for (int i = 0; i < knownSeverities.size(); i++) {\n      String stdSeverity = knownSeverities.get(i);\n      if (!myOrder.contains(stdSeverity)) {\n        for (int oIdx = 0; oIdx < myOrder.size(); oIdx++) {\n          final String orderSeverity = myOrder.get(oIdx);\n          final HighlightInfoType type = STANDART_SEVERITIES.get(orderSeverity);\n          if (type != null && knownSeverities.indexOf(type.getSeverity(null).toString()) > i) {\n            myOrder.add(oIdx, stdSeverity);\n            myReadOrder = null;\n            break;\n          }\n        }\n      }\n    }\n  }","commit_id":"83931f07a469df18749fac3c525b263be7fe792f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo createHighlightInfo(HighlightInfoType type, TextRange textRange, String description, TextAttributes textAttributes) {\n    // do not use HighlightInfoFilter\n    HighlightInfo highlightInfo = new HighlightInfo(type, textRange.getStartOffset(), textRange.getEndOffset(), description, htmlEscapeToolTip(description));\n    highlightInfo.forcedTextAttributes = textAttributes;\n    return highlightInfo;\n  }","id":32280,"modified_method":"public static HighlightInfo createHighlightInfo(@NotNull HighlightInfoType type, @NotNull TextRange textRange, String description, TextAttributes textAttributes) {\n    // do not use HighlightInfoFilter\n    return new HighlightInfo(textAttributes, type, textRange.getStartOffset(), textRange.getEndOffset(), description, htmlEscapeToolTip(description),type.getSeverity(null), false, null);\n  }","commit_id":"8694269c55568faf4881240e8595ef74cb26531b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo createHighlightInfo(final HighlightInfoType type,\n                                                  final PsiElement element,\n                                                  final String message,\n                                                  final TextAttributes attributes) {\n    TextRange textRange = element.getTextRange();\n    // do not use HighlightInfoFilter\n    TextAttributes textAttributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(type.getAttributesKey());\n    HighlightInfo highlightInfo = new HighlightInfo(textAttributes, type, textRange.getStartOffset(), textRange.getEndOffset(), message, htmlEscapeToolTip(message), type.getSeverity(element), false, false);\n    highlightInfo.forcedTextAttributes = attributes;\n    return highlightInfo;\n  }","id":32281,"modified_method":"public static HighlightInfo createHighlightInfo(@NotNull final HighlightInfoType type,\n                                                  @NotNull final PsiElement element,\n                                                  final String message,\n                                                  final TextAttributes attributes) {\n    TextRange textRange = element.getTextRange();\n    // do not use HighlightInfoFilter\n    return new HighlightInfo(attributes, type, textRange.getStartOffset(), textRange.getEndOffset(), message, htmlEscapeToolTip(message), type.getSeverity(element), false, false);\n  }","commit_id":"8694269c55568faf4881240e8595ef74cb26531b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HighlightInfo(TextAttributes textAttributes,\n                       HighlightInfoType type,\n                       int startOffset,\n                       int endOffset,\n                       String description,\n                       String toolTip,\n                       HighlightSeverity severity,\n                       boolean afterEndOfLine,\n                       boolean needsUpdateOnTyping) {\n    forcedTextAttributes = textAttributes;\n    this.type = type;\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.description = description;\n    this.toolTip = toolTip;\n    this.severity = severity;\n    isAfterEndOfLine = afterEndOfLine;\n    myNeedsUpdateOnTyping = needsUpdateOnTyping;\n  }","id":32282,"modified_method":"public HighlightInfo(TextAttributes textAttributes,\n                       HighlightInfoType type,\n                       int startOffset,\n                       int endOffset,\n                       String description,\n                       String toolTip,\n                       HighlightSeverity severity,\n                       boolean afterEndOfLine,\n                       Boolean needsUpdateOnTyping) {\n    LOG.assertTrue(startOffset >= 0);\n    LOG.assertTrue(startOffset <= endOffset);\n    forcedTextAttributes = textAttributes;\n    this.type = type;\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.description = description;\n    this.toolTip = toolTip;\n    this.severity = severity;\n    isAfterEndOfLine = afterEndOfLine;\n    myNeedsUpdateOnTyping = needsUpdateOnTyping;\n  }","commit_id":"8694269c55568faf4881240e8595ef74cb26531b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HighlightInfo(HighlightInfoType type, int startOffset, int endOffset, String description, String toolTip) {\n    this.type = type;\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    fixStartOffset = startOffset;\n    fixEndOffset = endOffset;\n    this.description = description;\n    severity = type.getSeverity(null);\n    this.toolTip = toolTip;\n    LOG.assertTrue(startOffset >= 0);\n    LOG.assertTrue(startOffset <= endOffset);\n  }","id":32283,"modified_method":"public HighlightInfo(HighlightInfoType type, int startOffset, int endOffset, String description, String toolTip) {\n    this(null, type, startOffset, endOffset, description, toolTip, type.getSeverity(null), false, null);\n  }","commit_id":"8694269c55568faf4881240e8595ef74cb26531b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void apply(@NotNull final PsiFile psiFile, @Nullable final ServerResult serverResult, @NotNull final AnnotationHolder holder) {\n    if (serverResult == null || serverResult.getPairs().isEmpty()) return;\n\n    final Document document = PsiDocumentManager.getInstance(psiFile.getProject()).getCachedDocument(psiFile);\n    if (document == null) return;\n\n    for (Pair<AnalysisError, List<AnalysisErrorFixes>> result : serverResult.getPairs()) {\n      final AnalysisError error = result.first;\n      if (shouldIgnoreMessageFromDartAnalyzer(error)) continue;\n      final List<AnalysisErrorFixes> fixes = result.second;\n      final Annotation annotation = annotate(document, holder, error);\n      if (annotation != null && fixes != null) {\n        for (AnalysisErrorFixes fixList : fixes) {\n          for (SourceChange change : fixList.getFixes()) {\n            annotation.registerFix(new DartServerFixIntention(change));\n          }\n        }\n      }\n    }\n  }","id":32284,"modified_method":"@Override\n  public void apply(@NotNull final PsiFile psiFile, @Nullable final ServerResult serverResult, @NotNull final AnnotationHolder holder) {\n    if (serverResult == null || serverResult.getErrorsAndFixes().isEmpty()) return;\n\n    final Document document = PsiDocumentManager.getInstance(psiFile.getProject()).getCachedDocument(psiFile);\n    if (document == null) return;\n\n    for (Map.Entry<AnalysisError, List<AnalysisErrorFixes>> entry : serverResult.getErrorsAndFixes().entrySet()) {\n      final AnalysisError error = entry.getKey();\n      final List<AnalysisErrorFixes> fixes = entry.getValue();\n\n      final Annotation annotation = annotate(document, holder, error);\n      if (annotation != null && fixes != null) {\n        for (AnalysisErrorFixes fixList : fixes) {\n          for (SourceChange change : fixList.getFixes()) {\n            annotation.registerFix(new DartServerFixIntention(change));\n          }\n        }\n      }\n    }\n  }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private static Annotation annotate(@NotNull final Document document,\n                                     @NotNull final AnnotationHolder holder,\n                                     @NotNull final AnalysisError error) {\n    final String severity = error.getSeverity();\n    if (severity != null) {\n      final TextRange textRange = getRealTextRange(document, error.getLocation());\n      if (severity.equals(AnalysisErrorSeverity.INFO)) {\n        return holder.createWeakWarningAnnotation(textRange, error.getMessage());\n      }\n      else if (severity.equals(AnalysisErrorSeverity.WARNING)) {\n        return holder.createWarningAnnotation(textRange, error.getMessage());\n      }\n      else if (severity.equals(AnalysisErrorSeverity.ERROR)) {\n        return holder.createErrorAnnotation(textRange, error.getMessage());\n      }\n    }\n    return null;\n  }","id":32285,"modified_method":"@Nullable\n  private static Annotation annotate(@NotNull final Document document,\n                                     @NotNull final AnnotationHolder holder,\n                                     @NotNull final AnalysisError error) {\n    final TextRange textRange = getRealTextRange(document, error.getLocation());\n    if (AnalysisErrorSeverity.INFO.equals(error.getSeverity())) {\n      final Annotation annotation = holder.createWeakWarningAnnotation(textRange, error.getMessage());\n      if (\"Unused import\".equals(error.getMessage()) || \"Duplicate import\".equals(error.getMessage())) {\n        annotation.setHighlightType(ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n      }\n      return annotation;\n    }\n    else if (AnalysisErrorSeverity.WARNING.equals(error.getSeverity())) {\n      return holder.createWarningAnnotation(textRange, error.getMessage());\n    }\n    else if (AnalysisErrorSeverity.ERROR.equals(error.getSeverity())) {\n      return holder.createErrorAnnotation(textRange, error.getMessage());\n    }\n\n    return null;\n  }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public Pair<PsiFile, Document> collectInformation(@NotNull final PsiFile psiFile, @NotNull final Editor editor, final boolean hasErrors) {\n    if (psiFile instanceof DartExpressionCodeFragment) return null;\n\n    final VirtualFile annotatedFile = DartResolveUtil.getRealVirtualFile(psiFile);\n    if (annotatedFile == null) return null;\n\n    final Module module = ModuleUtilCore.findModuleForPsiElement(psiFile);\n    if (module == null) return null;\n\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n    if (sdk == null) return null;\n\n    if (psiFile instanceof XmlFile && !containsDartEmbeddedContent((XmlFile)psiFile)) return null;\n\n    if (FileUtil.isAncestor(sdk.getHomePath(), annotatedFile.getPath(), true)) return null;\n\n    if (PsiDocumentManager.getInstance(psiFile.getProject()).getCachedDocument(psiFile) == null) return null;\n\n    return Pair.create(psiFile, editor.getDocument());\n  }","id":32286,"modified_method":"@Nullable\n  @Override\n  public AnnotatorInfo collectInformation(@NotNull final PsiFile psiFile, @NotNull final Editor editor, final boolean hasErrors) {\n    if (hasErrors) return null;\n\n    if (psiFile instanceof DartExpressionCodeFragment) return null;\n\n    final VirtualFile annotatedFile = DartResolveUtil.getRealVirtualFile(psiFile);\n    if (annotatedFile == null) return null;\n\n    final Module module = ModuleUtilCore.findModuleForPsiElement(psiFile);\n    if (module == null) return null;\n\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n    if (sdk == null || StringUtil.compareVersionNumbers(sdk.getVersion(), \"1.7\") < 0) return null;\n\n    if (psiFile instanceof XmlFile && !DartInProcessAnnotator.containsDartEmbeddedContent((XmlFile)psiFile)) return null;\n\n    if (FileUtil.isAncestor(sdk.getHomePath(), annotatedFile.getPath(), true)) return null;\n\n    // todo iterate FileDocumentManager.getInstance().getUnsavedDocuments() and send contents to server for documents where Document.getModificationStamp() changed since previous upload\n    return new AnnotatorInfo(psiFile.getProject(), annotatedFile.getPath(), sdk.getHomePath());\n  }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"void add(@NotNull Pair<AnalysisError, List<AnalysisErrorFixes>> errorListPair) {\n      myPairs.add(errorListPair);\n    }","id":32287,"modified_method":"void add(@NotNull final AnalysisError error, @NotNull final List<AnalysisErrorFixes> fixes) {\n      myErrorsAndFixes.put(error, fixes);\n    }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public List<AnalysisErrorFixes> analysis_getFixes(@NotNull final PsiFile psiFile, final int offset) {\n    final VirtualFile vFile = DartResolveUtil.getRealVirtualFile(psiFile);\n    if (vFile == null) return null;\n\n    final Ref<List<AnalysisErrorFixes>> resultFixes = new Ref<List<AnalysisErrorFixes>>();\n\n    final Semaphore semaphore = new Semaphore();\n    semaphore.down();\n\n    final String path = FileUtil.toSystemDependentName(vFile.getPath());\n    myServer.edit_getFixes(path, offset, new GetFixesConsumer() {\n      @Override\n      public void computedFixes(final List<AnalysisErrorFixes> fixes) {\n        semaphore.up();\n        resultFixes.set(fixes);\n      }\n\n      @Override\n      public void onError(final RequestError error) {\n        semaphore.up();\n        LOG.warn(\"Error from edit_getFixes() for file \" + path + \", code=\" + error.getCode() + \": \" + error.getMessage());\n      }\n    });\n\n    final long t0 = System.currentTimeMillis();\n    semaphore.waitFor(GET_FIXES_TIMEOUT);\n\n    if (semaphore.tryUp()) {\n      LOG.info(\"edit_getFixes() took too long for file \" + path + \": \" + (System.currentTimeMillis() - t0) + \"ms\");\n      return null;\n    }\n\n    return resultFixes.get();\n  }","id":32288,"modified_method":"@Nullable\n  public List<AnalysisErrorFixes> analysis_getFixes(@NotNull final String filePath, final int offset) {\n    final Ref<List<AnalysisErrorFixes>> resultFixes = new Ref<List<AnalysisErrorFixes>>();\n\n    final Semaphore semaphore = new Semaphore();\n    semaphore.down();\n\n    final String path = FileUtil.toSystemDependentName(filePath);\n    myServer.edit_getFixes(path, offset, new GetFixesConsumer() {\n      @Override\n      public void computedFixes(final List<AnalysisErrorFixes> fixes) {\n        semaphore.up();\n        resultFixes.set(fixes);\n      }\n\n      @Override\n      public void onError(final RequestError error) {\n        semaphore.up();\n        LOG.warn(\"Error from edit_getFixes() for file \" + path + \", code=\" + error.getCode() + \": \" + error.getMessage());\n      }\n    });\n\n    final long t0 = System.currentTimeMillis();\n    semaphore.waitFor(GET_FIXES_TIMEOUT);\n\n    if (semaphore.tryUp()) {\n      LOG.info(\"edit_getFixes() took too long for file \" + path + \": \" + (System.currentTimeMillis() - t0) + \"ms\");\n      return null;\n    }\n\n    return resultFixes.get();\n  }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void startServer() {\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n    if (sdk == null) {\n      LOG.error(\"No SDK\");\n      return;\n    }\n\n    final String sdkPath = sdk.getHomePath();\n    final String runtimePath = sdkPath + \"/bin/dart\";\n    final String analysisServerPath = sdkPath + \"/bin/snapshots/analysis_server.dart.snapshot\";\n    final DebugPrintStream debugStream = new DebugPrintStream() {\n      @Override\n      public void println(String str) {\n        //System.out.println(\"debugStream: \" + str);\n      }\n    };\n\n    final StdioServerSocket serverSocket;\n    if (!ApplicationManager.getApplication().isInternal()) {\n      serverSocket = new StdioServerSocket(runtimePath, analysisServerPath, null, debugStream, new String[]{}, false, false, 0, false);\n    }\n    else {\n      int availablePort = 10000;\n      try {\n        availablePort = NetUtils.findAvailableSocketPort();\n      }\n      catch (IOException e) {\n        LOG.error(e.getMessage(), e);\n      }\n      LOG.debug(\"Go to http://localhost:\" + availablePort + \"/status to see status of analysis server\");\n      serverSocket =\n        new StdioServerSocket(runtimePath, analysisServerPath, null, debugStream, new String[]{\"--port=\" + availablePort}, false, false, 0,\n                              false);\n    }\n\n    myServer = new RemoteAnalysisServerImpl(serverSocket);\n    try {\n      myServer.start();\n    }\n    catch (Exception e) {\n      LOG.debug(e.getMessage(), e);\n    }\n    setAnalysisRoots(ProjectManager.getInstance().getOpenProjects());\n    setOptions();\n    myServer.addAnalysisServerListener(myListener);\n  }","id":32289,"modified_method":"private void startServer() {\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n    if (sdk == null) {\n      LOG.error(\"No SDK\");\n      return;\n    }\n\n    final String sdkPath = ApplicationManager.getApplication().isUnitTestMode() ? System.getProperty(\"dart.sdk\") : sdk.getHomePath();\n    final String runtimePath = sdkPath + \"/bin/dart\";\n    final String analysisServerPath = sdkPath + \"/bin/snapshots/analysis_server.dart.snapshot\";\n    final DebugPrintStream debugStream = new DebugPrintStream() {\n      @Override\n      public void println(String str) {\n        //System.out.println(\"debugStream: \" + str);\n      }\n    };\n\n    final StdioServerSocket serverSocket;\n    if (!ApplicationManager.getApplication().isInternal()) {\n      serverSocket = new StdioServerSocket(runtimePath, analysisServerPath, null, debugStream, new String[]{}, false, false, 0, false);\n    }\n    else {\n      int availablePort = 10000;\n      try {\n        availablePort = NetUtils.findAvailableSocketPort();\n      }\n      catch (IOException e) {\n        LOG.error(e.getMessage(), e);\n      }\n      LOG.debug(\"Go to http://localhost:\" + availablePort + \"/status to see status of analysis server\");\n      serverSocket =\n        new StdioServerSocket(runtimePath, analysisServerPath, null, debugStream, new String[]{\"--port=\" + availablePort}, false, false, 0,\n                              false);\n    }\n\n    myServer = new RemoteAnalysisServerImpl(serverSocket);\n    try {\n      myServer.start();\n    }\n    catch (Exception e) {\n      LOG.debug(e.getMessage(), e);\n    }\n    setAnalysisRoots(ProjectManager.getInstance().getOpenProjects());\n    setOptions();\n    myServer.addAnalysisServerListener(myListener);\n  }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static boolean containsDartEmbeddedContent(@NotNull final XmlFile file) {\n    final String text = file.getText();\n    int i = -1;\n    while ((i = text.indexOf(DartLanguage.DART_MIME_TYPE, i + 1)) != -1) {\n      final PsiElement element = file.findElementAt(i);\n      final XmlTag tag = element == null ? null : PsiTreeUtil.getParentOfType(element, XmlTag.class);\n      if (tag != null && HtmlUtil.isScriptTag(tag) && PsiTreeUtil.getChildOfType(tag, DartEmbeddedContent.class) != null) {\n        return true;\n      }\n    }\n    return false;\n  }","id":32290,"modified_method":"static boolean containsDartEmbeddedContent(@NotNull final XmlFile file) {\n    final String text = file.getText();\n    int i = -1;\n    while ((i = text.indexOf(DartLanguage.DART_MIME_TYPE, i + 1)) != -1) {\n      final PsiElement element = file.findElementAt(i);\n      final XmlTag tag = element == null ? null : PsiTreeUtil.getParentOfType(element, XmlTag.class);\n      if (tag != null && HtmlUtil.isScriptTag(tag) && PsiTreeUtil.getChildOfType(tag, DartEmbeddedContent.class) != null) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {\n    final Document document = editor.getDocument();\n    for (SourceFileEdit fileEdit : myChange.getEdits()) {\n      for (SourceEdit edit : fileEdit.getEdits()) {\n\n        // Templates can only grow source, so we trim first if necessary\n        if (edit.getLength() > 0) {\n          document.deleteString(edit.getOffset(), edit.getOffset() + edit.getLength());\n        }\n\n        final TemplateManager templateManager = TemplateManager.getInstance(project);\n        Template template = templateManager.createTemplate(\"\", \"\");\n        template.setToReformat(true);\n\n        addContents(template, edit);\n\n        try {\n          final VirtualFile virtualFile = VfsUtil.findFileByURL(new URL(\"file://\" + fileEdit.getFile()));\n          if (virtualFile != null) {\n            final Editor targetEditor = BaseCreateFix.navigate(project, edit.getOffset(), virtualFile);\n            if (targetEditor != null) {\n              templateManager.startTemplate(targetEditor, template);\n            }\n          }\n        }\n        catch (MalformedURLException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":32291,"modified_method":"@Override\n  public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {\n    final Document document = editor.getDocument();\n    for (SourceFileEdit fileEdit : myChange.getEdits()) {\n      for (SourceEdit edit : fileEdit.getEdits()) {\n\n        // Templates can only grow source, so we trim first if necessary\n        if (edit.getLength() > 0) {\n          document.deleteString(edit.getOffset(), edit.getOffset() + edit.getLength());\n        }\n\n        final TemplateManager templateManager = TemplateManager.getInstance(project);\n        Template template = templateManager.createTemplate(\"\", \"\");\n        template.setToReformat(true);\n\n        addContents(template, edit);\n\n        final VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(FileUtil.toSystemIndependentName(fileEdit.getFile()));\n        if (virtualFile != null) {\n          final Editor targetEditor = BaseCreateFix.navigate(project, edit.getOffset(), virtualFile);\n          if (targetEditor != null) {\n            templateManager.startTemplate(targetEditor, template);\n          }\n        }\n      }\n    }\n  }","commit_id":"ef69b5be832d10b1e771e8e677cf079d1f1c8a5c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Test\n  public void select_non_closed_issues_by_module_uuid() {\n    setupData(\"shared\", \"select_non_closed_issues_by_module_uuid\");\n\n    // BCDE is a non-root module, we should find 2 issues from classes and one on itself\n    DefaultResultHandler handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByModuleUuid(session, \"BCDE\", handler);\n    assertThat(handler.getResultList()).extracting(\"key\").containsOnly(\"100\", \"101\", \"103\");\n\n    // DBCA is a a simple project with a single file\n    handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByModuleUuid(session, \"DBCA\", handler);\n    assertThat(handler.getResultList()).hasSize(1);\n\n    BatchIssueDto batchIssueDto = (BatchIssueDto) handler.getResultList().get(0);\n    assertThat(batchIssueDto.getKey()).isEqualTo(\"1000\");\n    assertThat(batchIssueDto.getRuleKey()).isEqualTo(\"AvoidCycle\");\n    assertThat(batchIssueDto.getRuleRepo()).isEqualTo(\"squid\");\n    assertThat(batchIssueDto.getMessage()).isEqualTo(\"Avoid this\");\n    assertThat(batchIssueDto.getLine()).isEqualTo(200);\n    assertThat(batchIssueDto.getResolution()).isEqualTo(Issue.RESOLUTION_FALSE_POSITIVE);\n    assertThat(batchIssueDto.getStatus()).isEqualTo(Issue.STATUS_RESOLVED);\n    assertThat(batchIssueDto.getSeverity()).isEqualTo(Severity.BLOCKER);\n    assertThat(batchIssueDto.isManualSeverity()).isTrue();\n    assertThat(batchIssueDto.getComponentKey()).isEqualTo(\"Sample.java\");\n    assertThat(batchIssueDto.getChecksum()).isEqualTo(\"123456\");\n    assertThat(batchIssueDto.getAssigneeLogin()).isEqualTo(\"john\");\n  }","id":32292,"modified_method":"@Test\n  public void select_non_closed_issues_by_module_uuid() {\n    setupData(\"shared\", \"select_non_closed_issues_by_module_uuid\");\n\n    // BCDE is a non-root module, we should find 2 issues from classes and one on itself\n    DefaultResultHandler handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByModuleUuid(session, \"BCDE\", handler);\n    assertThat(handler.getResultList()).extracting(\"key\").containsOnly(\"100\", \"101\", \"103\");\n\n    // DBCA is a a simple project with a single file\n    handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByModuleUuid(session, \"DBCA\", handler);\n    assertThat(handler.getResultList()).hasSize(1);\n\n    BatchIssueDto batchIssueDto = (BatchIssueDto) handler.getResultList().get(0);\n    assertThat(batchIssueDto.getKey()).isEqualTo(\"1000\");\n    assertThat(batchIssueDto.getRuleKey()).isEqualTo(\"AvoidCycle\");\n    assertThat(batchIssueDto.getRuleRepo()).isEqualTo(\"squid\");\n    assertThat(batchIssueDto.getMessage()).isEqualTo(\"Avoid this\");\n    assertThat(batchIssueDto.getLine()).isEqualTo(200);\n    assertThat(batchIssueDto.getResolution()).isEqualTo(Issue.RESOLUTION_FALSE_POSITIVE);\n    assertThat(batchIssueDto.getStatus()).isEqualTo(Issue.STATUS_RESOLVED);\n    assertThat(batchIssueDto.getSeverity()).isEqualTo(Severity.BLOCKER);\n    assertThat(batchIssueDto.isManualSeverity()).isTrue();\n    assertThat(batchIssueDto.getComponentKey()).isEqualTo(\"Sample.java\");\n    assertThat(batchIssueDto.getChecksum()).isEqualTo(\"123456\");\n    assertThat(batchIssueDto.getAssigneeLogin()).isEqualTo(\"john\");\n    assertThat(batchIssueDto.getCreationDate()).isNotNull();\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void select_non_closed_issues_by_project_uuid() {\n    setupData(\"shared\", \"select_non_closed_issues_by_project_uuid\");\n\n    // ABCD is the root module, we should find all 4 issues\n    DefaultResultHandler handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByProjectUuid(session, \"ABCD\", handler);\n    assertThat(handler.getResultList()).hasSize(4);\n\n    // DBCA is a a simple project with a single file\n    handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByProjectUuid(session, \"DBCA\", handler);\n    assertThat(handler.getResultList()).hasSize(1);\n\n    BatchIssueDto batchIssueDto = (BatchIssueDto) handler.getResultList().get(0);\n    assertThat(batchIssueDto.getKey()).isEqualTo(\"1000\");\n    assertThat(batchIssueDto.getRuleKey()).isEqualTo(\"AvoidCycle\");\n    assertThat(batchIssueDto.getRuleRepo()).isEqualTo(\"squid\");\n    assertThat(batchIssueDto.getMessage()).isEqualTo(\"Avoid this\");\n    assertThat(batchIssueDto.getLine()).isEqualTo(200);\n    assertThat(batchIssueDto.getResolution()).isEqualTo(Issue.RESOLUTION_FALSE_POSITIVE);\n    assertThat(batchIssueDto.getStatus()).isEqualTo(Issue.STATUS_RESOLVED);\n    assertThat(batchIssueDto.getSeverity()).isEqualTo(Severity.BLOCKER);\n    assertThat(batchIssueDto.isManualSeverity()).isTrue();\n    assertThat(batchIssueDto.getComponentKey()).isEqualTo(\"Sample.java\");\n    assertThat(batchIssueDto.getChecksum()).isEqualTo(\"123456\");\n    assertThat(batchIssueDto.getAssigneeLogin()).isEqualTo(\"john\");\n  }","id":32293,"modified_method":"@Test\n  public void select_non_closed_issues_by_project_uuid() {\n    setupData(\"shared\", \"select_non_closed_issues_by_project_uuid\");\n\n    // ABCD is the root module, we should find all 4 issues\n    DefaultResultHandler handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByProjectUuid(session, \"ABCD\", handler);\n    assertThat(handler.getResultList()).hasSize(4);\n\n    // DBCA is a a simple project with a single file\n    handler = new DefaultResultHandler();\n    sut.selectNonClosedIssuesByProjectUuid(session, \"DBCA\", handler);\n    assertThat(handler.getResultList()).hasSize(1);\n\n    BatchIssueDto batchIssueDto = (BatchIssueDto) handler.getResultList().get(0);\n    assertThat(batchIssueDto.getKey()).isEqualTo(\"1000\");\n    assertThat(batchIssueDto.getRuleKey()).isEqualTo(\"AvoidCycle\");\n    assertThat(batchIssueDto.getRuleRepo()).isEqualTo(\"squid\");\n    assertThat(batchIssueDto.getMessage()).isEqualTo(\"Avoid this\");\n    assertThat(batchIssueDto.getLine()).isEqualTo(200);\n    assertThat(batchIssueDto.getResolution()).isEqualTo(Issue.RESOLUTION_FALSE_POSITIVE);\n    assertThat(batchIssueDto.getStatus()).isEqualTo(Issue.STATUS_RESOLVED);\n    assertThat(batchIssueDto.getSeverity()).isEqualTo(Severity.BLOCKER);\n    assertThat(batchIssueDto.isManualSeverity()).isTrue();\n    assertThat(batchIssueDto.getComponentKey()).isEqualTo(\"Sample.java\");\n    assertThat(batchIssueDto.getChecksum()).isEqualTo(\"123456\");\n    assertThat(batchIssueDto.getAssigneeLogin()).isEqualTo(\"john\");\n    assertThat(batchIssueDto.getCreationDate()).isNotNull();\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public PreviousIssue apply(@Nullable BatchIssueDto batchIssueDto) {\n      if (batchIssueDto != null) {\n        return new PreviousIssue()\n          .setKey(batchIssueDto.getKey())\n          .setComponentKey(batchIssueDto.getComponentKey())\n          .setChecksum(batchIssueDto.getChecksum())\n          .setAssigneeLogin(batchIssueDto.getAssigneeLogin())\n          .setLine(batchIssueDto.getLine())\n          .setRuleKey(batchIssueDto.getRuleRepo(), batchIssueDto.getRuleKey())\n          .setMessage(batchIssueDto.getMessage())\n          .setResolution(batchIssueDto.getResolution())\n          .setOverriddenSeverity(batchIssueDto.isManualSeverity() ? batchIssueDto.getSeverity() : null)\n          .setStatus(batchIssueDto.getStatus());\n      }\n      return null;\n    }","id":32294,"modified_method":"@Override\n    public PreviousIssue apply(@Nullable BatchIssueDto batchIssueDto) {\n      if (batchIssueDto != null) {\n        return new PreviousIssue()\n          .setKey(batchIssueDto.getKey())\n          .setComponentKey(batchIssueDto.getComponentKey())\n          .setChecksum(batchIssueDto.getChecksum())\n          .setAssigneeLogin(batchIssueDto.getAssigneeLogin())\n          .setLine(batchIssueDto.getLine())\n          .setRuleKey(batchIssueDto.getRuleRepo(), batchIssueDto.getRuleKey())\n          .setMessage(batchIssueDto.getMessage())\n          .setResolution(batchIssueDto.getResolution())\n          .setSeverity(batchIssueDto.getSeverity())\n          .setManualSeverity(batchIssueDto.isManualSeverity())\n          .setStatus(batchIssueDto.getStatus())\n          .setCreationDate(batchIssueDto.getCreationDate());\n      }\n      return null;\n    }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_only_manual_severity() throws Exception {\n    db.prepareDbUnit(getClass(), \"return_only_manual_severity.xml\");\n\n    MockUserSession.set().setLogin(\"henry\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION).addComponentPermission(UserRole.USER, PROJECT_KEY, PROJECT_KEY);\n\n    WsTester.TestRequest request = tester.newGetRequest(\"batch\", \"issues\").setParam(\"key\", PROJECT_KEY);\n    request.execute().assertJson(getClass(), \"return_only_manual_severity-expected.json\");\n  }","id":32295,"modified_method":"@Test\n  public void return_only_manual_severity() throws Exception {\n    db.prepareDbUnit(getClass(), \"return_only_manual_severity.xml\");\n\n    MockUserSession.set().setLogin(\"henry\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION).addComponentPermission(UserRole.USER, PROJECT_KEY, PROJECT_KEY);\n\n    WsTester.TestRequest request = tester.newGetRequest(\"batch\", \"issues\").setParam(\"key\", PROJECT_KEY);\n    request.execute().assertJson(getClass(), \"return_only_manual_severity-expected.json\", false);\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_issues_on_project() throws Exception {\n    db.prepareDbUnit(getClass(), \"shared.xml\");\n\n    MockUserSession.set().setLogin(\"henry\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION).addComponentPermission(UserRole.USER, PROJECT_KEY, PROJECT_KEY);\n\n    WsTester.TestRequest request = tester.newGetRequest(\"batch\", \"issues\").setParam(\"key\", PROJECT_KEY);\n    request.execute().assertJson(getClass(), \"issues_on_project-expected.json\");\n  }","id":32296,"modified_method":"@Test\n  public void return_issues_on_project() throws Exception {\n    db.prepareDbUnit(getClass(), \"shared.xml\");\n\n    MockUserSession.set().setLogin(\"henry\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION).addComponentPermission(UserRole.USER, PROJECT_KEY, PROJECT_KEY);\n\n    WsTester.TestRequest request = tester.newGetRequest(\"batch\", \"issues\").setParam(\"key\", PROJECT_KEY);\n    request.execute().assertJson(getClass(), \"issues_on_project-expected.json\", false);\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_issues_on_module() throws Exception {\n    db.prepareDbUnit(getClass(), \"shared.xml\");\n\n    MockUserSession.set().setLogin(\"henry\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION).addComponentPermission(UserRole.USER, PROJECT_KEY, MODULE_KEY);\n\n    WsTester.TestRequest request = tester.newGetRequest(\"batch\", \"issues\").setParam(\"key\", MODULE_KEY);\n    request.execute().assertJson(getClass(), \"issues_on_module-expected.json\");\n  }","id":32297,"modified_method":"@Test\n  public void return_issues_on_module() throws Exception {\n    db.prepareDbUnit(getClass(), \"shared.xml\");\n\n    MockUserSession.set().setLogin(\"henry\").setGlobalPermissions(GlobalPermissions.PREVIEW_EXECUTION).addComponentPermission(UserRole.USER, PROJECT_KEY, MODULE_KEY);\n\n    WsTester.TestRequest request = tester.newGetRequest(\"batch\", \"issues\").setParam(\"key\", MODULE_KEY);\n    request.execute().assertJson(getClass(), \"issues_on_module-expected.json\", false);\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private DefaultIssue toUnmatchedIssue(org.sonar.batch.protocol.input.issues.PreviousIssue previous) {\n    DefaultIssue issue = new DefaultIssue();\n    issue.setKey(previous.key());\n    issue.setStatus(previous.status());\n    issue.setResolution(previous.resolution());\n    issue.setMessage(previous.message());\n    issue.setLine(previous.line());\n    String overriddenSeverity = previous.overriddenSeverity();\n    if (overriddenSeverity != null) {\n      issue.setSeverity(overriddenSeverity);\n    } else {\n      ActiveRule activeRule = activeRules.find(RuleKey.of(previous.ruleRepo(), previous.ruleKey()));\n      if (activeRule != null) {\n        // FIXME if rule was removed we can't guess what was the severity of the issue\n        issue.setSeverity(activeRule.severity());\n      }\n    }\n    issue.setAssignee(previous.assigneeLogin());\n    issue.setComponentKey(previous.componentKey());\n    issue.setManualSeverity(overriddenSeverity != null);\n    issue.setRuleKey(RuleKey.of(previous.ruleRepo(), previous.ruleKey()));\n    issue.setNew(false);\n    return issue;\n  }","id":32298,"modified_method":"private DefaultIssue toUnmatchedIssue(org.sonar.batch.protocol.input.issues.PreviousIssue previous) {\n    DefaultIssue issue = new DefaultIssue();\n    issue.setKey(previous.key());\n    issue.setStatus(previous.status());\n    issue.setResolution(previous.resolution());\n    issue.setMessage(previous.message());\n    issue.setLine(previous.line());\n    String overriddenSeverity = previous.severity();\n    if (overriddenSeverity != null) {\n      issue.setSeverity(overriddenSeverity);\n    } else {\n      ActiveRule activeRule = activeRules.find(RuleKey.of(previous.ruleRepo(), previous.ruleKey()));\n      if (activeRule != null) {\n        // FIXME if rule was removed we can't guess what was the severity of the issue\n        issue.setSeverity(activeRule.severity());\n      }\n    }\n    issue.setAssignee(previous.assigneeLogin());\n    issue.setComponentKey(previous.componentKey());\n    issue.setManualSeverity(overriddenSeverity != null);\n    issue.setRuleKey(RuleKey.of(previous.ruleRepo(), previous.ruleKey()));\n    issue.setNew(false);\n    return issue;\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  protected void mergeMatched(IssueTrackingResult result) {\n    for (DefaultIssue issue : result.matched()) {\n      org.sonar.batch.protocol.input.issues.PreviousIssue ref = ((PreviousIssueFromWs) result.matching(issue)).getDto();\n\n      // invariant fields\n      issue.setKey(ref.key());\n\n      // non-persisted fields\n      issue.setNew(false);\n      issue.setEndOfLife(false);\n      issue.setOnDisabledRule(false);\n\n      // fields to update with old values\n      issue.setResolution(ref.resolution());\n      issue.setStatus(ref.status());\n      issue.setAssignee(ref.assigneeLogin());\n\n      String overriddenSeverity = ref.overriddenSeverity();\n      if (overriddenSeverity != null) {\n        // Severity overriden by user\n        issue.setSeverity(overriddenSeverity);\n      }\n    }\n  }","id":32299,"modified_method":"@VisibleForTesting\n  protected void mergeMatched(IssueTrackingResult result) {\n    for (DefaultIssue issue : result.matched()) {\n      org.sonar.batch.protocol.input.issues.PreviousIssue ref = ((PreviousIssueFromWs) result.matching(issue)).getDto();\n\n      // invariant fields\n      issue.setKey(ref.key());\n\n      // non-persisted fields\n      issue.setNew(false);\n      issue.setEndOfLife(false);\n      issue.setOnDisabledRule(false);\n\n      // fields to update with old values\n      issue.setResolution(ref.resolution());\n      issue.setStatus(ref.status());\n      issue.setAssignee(ref.assigneeLogin());\n\n      String overriddenSeverity = ref.severity();\n      if (overriddenSeverity != null) {\n        // Severity overriden by user\n        issue.setSeverity(overriddenSeverity);\n      }\n    }\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public String overriddenSeverity() {\n    return overriddenSeverity;\n  }","id":32300,"modified_method":"public String severity() {\n    return severity;\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public PreviousIssue setOverriddenSeverity(@Nullable String overriddenSeverity) {\n    this.overriddenSeverity = overriddenSeverity;\n    return this;\n  }","id":32301,"modified_method":"public PreviousIssue setSeverity(@Nullable String severity) {\n    this.severity = severity;\n    return this;\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void writeIssues() throws JSONException {\n    StringWriter out = new StringWriter();\n    PreviousIssueHelper helper = PreviousIssueHelper.create(out);\n\n    PreviousIssue issue1 = new PreviousIssue();\n    issue1.setKey(\"key1\");\n    issue1.setComponentKey(\"key\");\n    issue1.setRuleKey(\"repokey\", \"rulekey\");\n    issue1.setLine(2);\n    issue1.setMessage(\"message\");\n    issue1.setOverriddenSeverity(\"severity\");\n    issue1.setResolution(\"resolution\");\n    issue1.setStatus(\"status\");\n    issue1.setChecksum(\"checksum\");\n    issue1.setAssigneeLogin(\"login\");\n    PreviousIssue issue2 = new PreviousIssue();\n    issue2.setKey(\"key2\");\n\n    PreviousIssueFunction previousIssueFunction = new PreviousIssueFunction();\n    helper.addIssue(issue1, previousIssueFunction);\n    helper.addIssue(issue2, previousIssueFunction);\n    helper.close();\n\n    JSONAssert\n      .assertEquals(\n        \"[{\\\"key\\\": \\\"key1\\\", \\\"componentKey\\\": \\\"key\\\", \\\"ruleKey\\\": \\\"rulekey\\\", \\\"ruleRepo\\\": \\\"repokey\\\", \\\"line\\\": 2,\\\"message\\\": \\\"message\\\", \\\"overriddenSeverity\\\": \\\"severity\\\", \\\"resolution\\\": \\\"resolution\\\", \\\"status\\\": \\\"status\\\", \\\"checksum\\\": \\\"checksum\\\",\\\"assigneeLogin\\\": \\\"login\\\"},\"\n          +\n          \"{\\\"key\\\": \\\"key2\\\"}]\",\n        out.getBuffer().toString(), true);\n\n  }","id":32302,"modified_method":"@Test\n  public void writeIssues() throws JSONException {\n    StringWriter out = new StringWriter();\n    PreviousIssueHelper helper = PreviousIssueHelper.create(out);\n\n    PreviousIssue issue1 = new PreviousIssue();\n    issue1.setKey(\"key1\");\n    issue1.setComponentKey(\"key\");\n    issue1.setRuleKey(\"repokey\", \"rulekey\");\n    issue1.setLine(2);\n    issue1.setMessage(\"message\");\n    issue1.setSeverity(\"severity\");\n    issue1.setManualSeverity(true);\n    issue1.setResolution(\"resolution\");\n    issue1.setStatus(\"status\");\n    issue1.setChecksum(\"checksum\");\n    issue1.setAssigneeLogin(\"login\");\n    PreviousIssue issue2 = new PreviousIssue();\n    issue2.setKey(\"key2\");\n\n    PreviousIssueFunction previousIssueFunction = new PreviousIssueFunction();\n    helper.addIssue(issue1, previousIssueFunction);\n    helper.addIssue(issue2, previousIssueFunction);\n    helper.close();\n\n    JSONAssert\n      .assertEquals(\n        \"[{\\\"key\\\": \\\"key1\\\", \\\"componentKey\\\": \\\"key\\\", \\\"ruleKey\\\": \\\"rulekey\\\", \\\"ruleRepo\\\": \\\"repokey\\\", \\\"line\\\": 2,\\\"message\\\": \\\"message\\\", \" +\n          \"\\\"severity\\\": \\\"severity\\\", \\\"manualSeverity\\\": true, \\\"resolution\\\": \\\"resolution\\\", \\\"status\\\": \\\"status\\\", \\\"checksum\\\": \\\"checksum\\\",\\\"assigneeLogin\\\": \\\"login\\\"},\"\n          +\n          \"{\\\"key\\\": \\\"key2\\\"}]\",\n        out.getBuffer().toString(), true);\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void readIssues() {\n    StringWriter out = new StringWriter();\n    PreviousIssueHelper helper = PreviousIssueHelper.create(out);\n    StringReader reader = new StringReader(\n      \"[{\\\"key\\\": \\\"key1\\\", \\\"componentKey\\\": \\\"key\\\", \\\"ruleKey\\\": \\\"rulekey\\\", \\\"ruleRepo\\\": \\\"repokey\\\", \\\"line\\\": 2,\\\"message\\\": \\\"message\\\", \\\"overriddenSeverity\\\": \\\"severity\\\", \\\"resolution\\\": \\\"resolution\\\", \\\"status\\\": \\\"status\\\", \\\"checksum\\\": \\\"checksum\\\",\\\"assigneeLogin\\\": \\\"login\\\"},\"\n        +\n        \"{\\\"key\\\": \\\"key2\\\"}]\");\n\n    Iterator<PreviousIssue> iterator = helper.getIssues(reader).iterator();\n    PreviousIssue issue1 = iterator.next();\n    assertThat(iterator.hasNext()).isTrue();\n    PreviousIssue issue2 = iterator.next();\n    assertThat(iterator.hasNext()).isFalse();\n\n    assertThat(issue1.key()).isEqualTo(\"key1\");\n    assertThat(issue1.componentKey()).isEqualTo(\"key\");\n    assertThat(issue1.ruleRepo()).isEqualTo(\"repokey\");\n    assertThat(issue1.ruleKey()).isEqualTo(\"rulekey\");\n    assertThat(issue1.line()).isEqualTo(2);\n    assertThat(issue1.message()).isEqualTo(\"message\");\n    assertThat(issue1.overriddenSeverity()).isEqualTo(\"severity\");\n    assertThat(issue1.resolution()).isEqualTo(\"resolution\");\n    assertThat(issue1.status()).isEqualTo(\"status\");\n    assertThat(issue1.checksum()).isEqualTo(\"checksum\");\n    assertThat(issue1.assigneeLogin()).isEqualTo(\"login\");\n\n    assertThat(issue2.key()).isEqualTo(\"key2\");\n    helper.close();\n  }","id":32303,"modified_method":"@Test\n  public void readIssues() {\n    StringWriter out = new StringWriter();\n    PreviousIssueHelper helper = PreviousIssueHelper.create(out);\n    StringReader reader = new StringReader(\n      \"[{\\\"key\\\": \\\"key1\\\", \\\"componentKey\\\": \\\"key\\\", \\\"ruleKey\\\": \\\"rulekey\\\", \\\"ruleRepo\\\": \\\"repokey\\\", \\\"line\\\": 2,\\\"message\\\": \\\"message\\\", \" +\n        \"\\\"severity\\\": \\\"severity\\\", \\\"manualSeverity\\\": true, \\\"resolution\\\": \\\"resolution\\\", \\\"status\\\": \\\"status\\\", \\\"checksum\\\": \\\"checksum\\\",\\\"assigneeLogin\\\": \\\"login\\\"},\"\n        +\n        \"{\\\"key\\\": \\\"key2\\\"}]\");\n\n    Iterator<PreviousIssue> iterator = helper.getIssues(reader).iterator();\n    PreviousIssue issue1 = iterator.next();\n    assertThat(iterator.hasNext()).isTrue();\n    PreviousIssue issue2 = iterator.next();\n    assertThat(iterator.hasNext()).isFalse();\n\n    assertThat(issue1.key()).isEqualTo(\"key1\");\n    assertThat(issue1.componentKey()).isEqualTo(\"key\");\n    assertThat(issue1.ruleRepo()).isEqualTo(\"repokey\");\n    assertThat(issue1.ruleKey()).isEqualTo(\"rulekey\");\n    assertThat(issue1.line()).isEqualTo(2);\n    assertThat(issue1.message()).isEqualTo(\"message\");\n    assertThat(issue1.severity()).isEqualTo(\"severity\");\n    assertThat(issue1.isManualSeverity()).isTrue();\n    assertThat(issue1.resolution()).isEqualTo(\"resolution\");\n    assertThat(issue1.status()).isEqualTo(\"status\");\n    assertThat(issue1.checksum()).isEqualTo(\"checksum\");\n    assertThat(issue1.assigneeLogin()).isEqualTo(\"login\");\n\n    assertThat(issue2.key()).isEqualTo(\"key2\");\n    helper.close();\n  }","commit_id":"34e46e58156289bcdf868971b1d650d88e2477a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Element doOnAdd() {\n        LOG.info(\"AlarmControl.doOnAdd()\");\n        final AlarmControlCss css = AlarmControlBundle.INSTANCE.css();\n        css.ensureInjected();\n\n        m_eventManager.addHandler(AlarmSeverityUpdatedEvent.TYPE, this);\n\n        this.setStylePrimaryName(\"leaflet-control-alarm\");\n        this.addStyleName(\"leaflet-bar\");\n        this.addStyleName(\"leaflet-control\");\n\n        final Label label = new Label(\"Show Severity >=\");\n        label.getElement().setAttribute(\"for\", \"alarmControl\");\n        label.addStyleName(css.label());\n\n        m_severityBox = new ListBox(false);\n        m_severityBox.getElement().setId(\"alarmControl\");\n        m_severityBox.addItem(\"Normal\", \"0\");\n        m_severityBox.addItem(\"Warning\", \"4\");\n        m_severityBox.addItem(\"Minor\", \"5\");\n        m_severityBox.addItem(\"Major\", \"6\");\n        m_severityBox.addItem(\"Critical\", \"7\");\n\n        m_severityBox.addChangeHandler(new ChangeHandler() {\n            @Override public void onChange(final ChangeEvent event) {\n                final int selected = m_severityBox.getSelectedIndex();\n                LOG.info(\"new selection index = \" + selected);\n                final String value = m_severityBox.getValue(selected);\n                LOG.info(\"new severity = \" + value);\n                final int intValue = value == null? 0 : Integer.valueOf(value).intValue();\n                m_eventManager.fireEvent(new AlarmSeverityUpdatedEvent(intValue));\n                event.stopPropagation();\n            }\n        });\n\n        m_severityBox.addStyleName(css.label());\n\n        this.add(label);\n        this.add(m_severityBox);\n\n        LOG.info(\"AlarmControl.doOnAdd(): finished, returning: \" + this.getElement());\n\n        m_eventManager.fireEvent(new ComponentInitializedEvent(AlarmControl.class.getName()));\n        return this.getElement();\n    }","id":32304,"modified_method":"public Element doOnAdd() {\n        LOG.info(\"AlarmControl.doOnAdd()\");\n        final AlarmControlCss css = AlarmControlBundle.INSTANCE.css();\n        css.ensureInjected();\n\n        m_eventManager.addHandler(AlarmSeverityUpdatedEvent.TYPE, this);\n\n        this.setStylePrimaryName(\"leaflet-control-alarm\");\n        this.addStyleName(\"leaflet-bar\");\n        this.addStyleName(\"leaflet-control\");\n\n        final Label label = new Label(\"Show Severity >=\");\n        label.getElement().setAttribute(\"for\", \"alarmControl\");\n        label.addStyleName(css.label());\n\n        m_severityBox = new ListBox(false);\n        m_severityBox.getElement().setId(\"alarmControl\");\n        for (final AlarmSeverity sev : AlarmSeverity.values()) {\n            m_severityBox.addItem(sev.getLabel());\n        }\n\n        m_severityBox.addChangeHandler(new ChangeHandler() {\n            @Override public void onChange(final ChangeEvent event) {\n                final int selected = m_severityBox.getSelectedIndex();\n                LOG.info(\"new selection index = \" + selected);\n                final String value = m_severityBox.getValue(selected);\n                LOG.info(\"new severity = \" + value);\n                m_eventManager.fireEvent(new AlarmSeverityUpdatedEvent(AlarmSeverity.get(value)));\n                event.stopPropagation();\n            }\n        });\n\n        m_severityBox.addStyleName(css.label());\n\n        this.add(label);\n        this.add(m_severityBox);\n\n        LOG.info(\"AlarmControl.doOnAdd(): finished, returning: \" + this.getElement());\n\n        m_eventManager.fireEvent(new ComponentInitializedEvent(AlarmControl.class.getName()));\n        return this.getElement();\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void onAlarmSeverityUpdated(final AlarmSeverityUpdatedEvent event) {\n        m_severityBox.setItemSelected(event.getSeverity(), true);\n    }","id":32305,"modified_method":"@Override\n    public void onAlarmSeverityUpdated(final AlarmSeverityUpdatedEvent event) {\n        m_severityBox.setItemSelected(event.getSeverity().ordinal(), true);\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public int getSeverity() {\n        return m_severity;\n    }","id":32306,"modified_method":"public AlarmSeverity getSeverity() {\n        return m_severity;\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AlarmSeverityUpdatedEvent(final int severity) {\n        m_severity = severity;\n    }","id":32307,"modified_method":"public AlarmSeverityUpdatedEvent(final int severity) {\n        m_severity = AlarmSeverity.get(severity);\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setMinimumSeverity(final int minimumSeverity) {\n        if (Util.hasChanged(m_minimumSeverity, minimumSeverity)) {\n            LOG.info(\"MarkerFilterImpl.setMinimumSeverity(\" + minimumSeverity + \"): minimum severity modified (old = '\" + m_minimumSeverity + \"'\");\n            m_minimumSeverity = minimumSeverity;\n            sendFilterUpdatedEvent();\n        } else {\n            LOG.info(\"MarkerFilterImpl.setMinimumSeverity(\" + minimumSeverity + \"): minimum severity unmodified.\");\n        }\n    }","id":32308,"modified_method":"public void setMinimumSeverity(final AlarmSeverity minimumSeverity) {\n        if (Util.hasChanged(m_minimumSeverity, minimumSeverity)) {\n            LOG.info(\"MarkerFilterImpl.setMinimumSeverity(\" + minimumSeverity + \"): minimum severity modified (old = '\" + m_minimumSeverity + \"'\");\n            m_minimumSeverity = minimumSeverity;\n            sendFilterUpdatedEvent();\n        } else {\n            LOG.info(\"MarkerFilterImpl.setMinimumSeverity(\" + minimumSeverity + \"): minimum severity unmodified.\");\n        }\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public MarkerFilterImpl(final String searchString, final int minimumSeverity, final OpenNMSEventManager openNMSEventManager) {\n        m_searchString = searchString;\n        m_minimumSeverity = minimumSeverity;\n        m_eventManager = openNMSEventManager;\n    }","id":32309,"modified_method":"public MarkerFilterImpl(final String searchString, final AlarmSeverity minimumSeverity, final OpenNMSEventManager openNMSEventManager) {\n        m_searchString = searchString;\n        m_minimumSeverity = minimumSeverity;\n        m_eventManager = openNMSEventManager;\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean matches(final NodeMarker marker) {\n        if (marker.getSeverity() != null && marker.getSeverity() < m_minimumSeverity) return false;\n        if (m_searchString == null || \"\".equals(m_searchString)) return true;\n\n        final String searchProperty;\n        final MatchType matchType;\n        final List<String> searchFor = new ArrayList<String>();\n\n        final MatchResult m = m_searchPattern.exec(m_searchString);\n        if (m != null) {\n            searchProperty = m.getGroup(1);\n            matchType = MatchType.fromToken(m.getGroup(2));\n\n            final String searchCriteria = m.getGroup(3);\n            if (matchType == MatchType.IN) {\n                final String ignoreParens = searchCriteria.replaceAll(\"^\\\\s*\\\\(\\\\s*(.*)\\\\s*\\\\)\\\\s*$\", \"$1\");\n                for (final String s : ignoreParens.split(\"\\\\s*,\\\\s*\")) {\n                    searchFor.add(s);\n                }\n            } else {\n                searchFor.add(searchCriteria);\n            }\n        } else {\n            searchProperty = null;\n            matchType = MatchType.SUBSTRING;\n            searchFor.add(m_searchString);\n        }\n\n        final Map<String, String> markerProperties = marker.getProperties();\n\n        if (searchProperty != null) {\n            return matchProperty(matchType, searchProperty, searchFor, markerProperties);\n        } else {\n            for (final String key : markerProperties.keySet()) {\n                if (matchProperty(matchType, key, searchFor, markerProperties)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }","id":32310,"modified_method":"@Override\n    public boolean matches(final NodeMarker marker) {\n        if (marker == null) return false;\n\n        final AlarmSeverity severity;\n        if (marker.getSeverity() == null) {\n            severity = AlarmSeverity.NORMAL;\n        } else {\n            severity = AlarmSeverity.get(marker.getSeverity());\n        }\n        if (severity.isLessThan(m_minimumSeverity)) return false;\n        if (m_searchString == null || \"\".equals(m_searchString)) return true;\n\n        final String searchProperty;\n        final MatchType matchType;\n        final List<String> searchFor = new ArrayList<String>();\n\n        final MatchResult m = m_searchPattern.exec(m_searchString);\n        if (m != null) {\n            searchProperty = m.getGroup(1);\n            matchType = MatchType.fromToken(m.getGroup(2));\n\n            final String searchCriteria = m.getGroup(3);\n            if (matchType == MatchType.IN) {\n                final String ignoreParens = searchCriteria.replaceAll(\"^\\\\s*\\\\(\\\\s*(.*)\\\\s*\\\\)\\\\s*$\", \"$1\");\n                for (final String s : ignoreParens.split(\"\\\\s*,\\\\s*\")) {\n                    searchFor.add(s);\n                }\n            } else {\n                searchFor.add(searchCriteria);\n            }\n        } else {\n            searchProperty = null;\n            matchType = MatchType.SUBSTRING;\n            searchFor.add(m_searchString);\n        }\n\n        final Map<String, String> markerProperties = marker.getProperties();\n\n        if (searchProperty != null) {\n            return matchProperty(matchType, searchProperty, searchFor, markerProperties);\n        } else {\n            for (final String key : markerProperties.keySet()) {\n                if (matchProperty(matchType, key, searchFor, markerProperties)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public WrappedMarkerFilterImpl(final String searchString, final int minimumSeverity, final OpenNMSEventManager eventManager) {\n            super(searchString, minimumSeverity, eventManager);\n        }","id":32311,"modified_method":"public WrappedMarkerFilterImpl(final String searchString, final AlarmSeverity minimumSeverity, final OpenNMSEventManager eventManager) {\n            super(searchString, minimumSeverity, eventManager);\n        }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testExactMatch() {\n        final MarkerFilterImpl filter = new WrappedMarkerFilterImpl(\"nodeLabel=blah\", 0, m_eventManager);\n        final SimpleNodeMarker marker = new SimpleNodeMarker();\n\n        marker.setNodeLabel(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"ablah\");\n        assertFalse(filter.matches(marker));\n\n        filter.setSearchString(\"category=blah\");\n        marker.setNodeLabel(null);\n        marker.addCategory(\"ablah\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"blah\");\n        assertTrue(filter.matches(marker));\n    }","id":32312,"modified_method":"@Test\n    public void testExactMatch() {\n        final MarkerFilterImpl filter = new WrappedMarkerFilterImpl(\"nodeLabel=blah\", AlarmSeverity.NORMAL, m_eventManager);\n        final SimpleNodeMarker marker = new SimpleNodeMarker();\n\n        marker.setNodeLabel(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"ablah\");\n        assertFalse(filter.matches(marker));\n\n        filter.setSearchString(\"category=blah\");\n        marker.setNodeLabel(null);\n        marker.addCategory(\"ablah\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"blah\");\n        assertTrue(filter.matches(marker));\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testInMatch() {\n        final MarkerFilterImpl filter = new WrappedMarkerFilterImpl(\"nodeLabel in foo, bar, baz\", 0, m_eventManager);\n        final SimpleNodeMarker marker = new SimpleNodeMarker();\n\n        marker.setNodeLabel(\"fo\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"foo\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bara\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"baz\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"nodeLabel in (foo, bar, baz)\");\n\n        marker.setNodeLabel(\"fo\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"foo\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bara\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"baz\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"category in foo, bar, baz\");\n        marker.setNodeLabel(null);\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"ba\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"bar\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"baz\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"categories in foo, bar, baz\");\n        marker.setNodeLabel(null);\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"ba\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"bar\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"baz\");\n        assertTrue(filter.matches(marker));\n    }","id":32313,"modified_method":"@Test\n    public void testInMatch() {\n        final MarkerFilterImpl filter = new WrappedMarkerFilterImpl(\"nodeLabel in foo, bar, baz\", AlarmSeverity.NORMAL, m_eventManager);\n        final SimpleNodeMarker marker = new SimpleNodeMarker();\n\n        marker.setNodeLabel(\"fo\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"foo\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bara\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"baz\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"nodeLabel in (foo, bar, baz)\");\n\n        marker.setNodeLabel(\"fo\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"foo\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bara\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"baz\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"category in foo, bar, baz\");\n        marker.setNodeLabel(null);\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"ba\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"bar\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"baz\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"categories in foo, bar, baz\");\n        marker.setNodeLabel(null);\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"ba\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"bar\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"baz\");\n        assertTrue(filter.matches(marker));\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testEmptySearch() {\n        // empty searches should always match\n        final WrappedMarkerFilterImpl filter = new WrappedMarkerFilterImpl(null, 0, m_eventManager);\n\n        final NodeMarker marker = new SimpleNodeMarker();\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"\");\n        assertTrue(filter.matches(marker));\n        assertEquals(1, filter.getFilterUpdatedCalls());\n    }","id":32314,"modified_method":"@Test\n    public void testEmptySearch() {\n        // empty searches should always match\n        final WrappedMarkerFilterImpl filter = new WrappedMarkerFilterImpl(null, AlarmSeverity.NORMAL, m_eventManager);\n\n        final NodeMarker marker = new SimpleNodeMarker();\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"\");\n        assertTrue(filter.matches(marker));\n        assertEquals(1, filter.getFilterUpdatedCalls());\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSubstringMatch() {\n        final MarkerFilterImpl filter = new WrappedMarkerFilterImpl(\"blah\", 0, m_eventManager);\n\n        final SimpleNodeMarker marker = new SimpleNodeMarker();\n\n        marker.setNodeLabel(\"this has the string blah in it\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bla\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"nodeLabel: blah\");\n\n        marker.setNodeLabel(\"this has the string blah in it\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bla\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        // now try categories\n        filter.setSearchString(\"blah\");\n        marker.setNodeLabel(\"notMatching\");\n        marker.addCategory(\"bla\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"this has the string 'blah' in it too!\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"category: blah\");\n        marker.setNodeLabel(\"notMatching\");\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"bla\");\n        assertFalse(marker.getCategoryList() + \" should contain blah\", filter.matches(marker));\n\n        marker.addCategory(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"this has the string 'blah' in it too!\");\n        assertTrue(filter.matches(marker));\n    }","id":32315,"modified_method":"@Test\n    public void testSubstringMatch() {\n        final MarkerFilterImpl filter = new WrappedMarkerFilterImpl(\"blah\", AlarmSeverity.NORMAL, m_eventManager);\n\n        final SimpleNodeMarker marker = new SimpleNodeMarker();\n\n        marker.setNodeLabel(\"this has the string blah in it\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bla\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"nodeLabel: blah\");\n\n        marker.setNodeLabel(\"this has the string blah in it\");\n        assertTrue(filter.matches(marker));\n\n        marker.setNodeLabel(\"bla\");\n        assertFalse(filter.matches(marker));\n\n        marker.setNodeLabel(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        // now try categories\n        filter.setSearchString(\"blah\");\n        marker.setNodeLabel(\"notMatching\");\n        marker.addCategory(\"bla\");\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"this has the string 'blah' in it too!\");\n        assertTrue(filter.matches(marker));\n\n        filter.setSearchString(\"category: blah\");\n        marker.setNodeLabel(\"notMatching\");\n        marker.setCategoryList(new ArrayList<String>());\n        marker.addCategory(\"bla\");\n        assertFalse(marker.getCategoryList() + \" should contain blah\", filter.matches(marker));\n\n        marker.addCategory(\"blah\");\n        assertTrue(filter.matches(marker));\n\n        marker.setCategoryList(new ArrayList<String>());\n        assertFalse(filter.matches(marker));\n\n        marker.addCategory(\"this has the string 'blah' in it too!\");\n        assertTrue(filter.matches(marker));\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public NodeMapWidget() {\n        m_eventManager = new OpenNMSEventManager();\n        m_eventManager.addHandler(FilteredMarkersUpdatedEvent.TYPE, this);\n\n        m_mapPanel.setWidth(\"100%\");\n        m_mapPanel.setHeight(\"100%\");\n        final Style mapStyle = m_mapPanel.getElement().getStyle();\n        mapStyle.setPosition(Position.ABSOLUTE);\n        mapStyle.setTop(0, Unit.PX);\n        mapStyle.setLeft(0, Unit.PX);\n\n        this.setWidth(\"100%\");\n        this.setHeight(\"100%\");\n\n        this.add(m_mapPanel);\n        m_div = m_mapPanel.getElement().cast();\n        m_div.setId(\"gwt-map\");\n\n        setStyleName(\"v-openlayers\");\n        LOG.info(\"NodeMapWidget(): div ID = \" + m_div.getId());\n\n        // addPassThroughHandlers();\n\n        addAttachHandler(new Handler() {\n            @Override\n            public void onAttachOrDetach(final AttachEvent event) {\n                if (event.isAttached()) {\n                    LOG.info(\"NodeMapWidget.onAttach()\");\n\n                    m_filter = new MarkerFilterImpl(\"\", 0, m_eventManager);\n                    m_markerContainer = new MarkerContainer(m_filter, m_eventManager);\n\n                    m_filter.onLoad();\n                    m_markerContainer.onLoad();\n\n                    Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n                        @Override public void execute() {\n                            initializeMap(m_div.getId());\n                        }\n                    });\n                } else {\n                    LOG.info(\"NodeMapwidget.onDetach()\");\n                    if (m_markerContainer != null) m_markerContainer.onUnload();\n                    if (m_filter != null) m_filter.onUnload();\n                    destroyMap();\n                }\n            }\n        });\n        LOG.info(\"NodeMapWidget(): initialized\");\n    }","id":32316,"modified_method":"public NodeMapWidget() {\n        m_eventManager = new OpenNMSEventManager();\n        m_eventManager.addHandler(FilteredMarkersUpdatedEvent.TYPE, this);\n\n        m_mapPanel.setWidth(\"100%\");\n        m_mapPanel.setHeight(\"100%\");\n        final Style mapStyle = m_mapPanel.getElement().getStyle();\n        mapStyle.setPosition(Position.ABSOLUTE);\n        mapStyle.setTop(0, Unit.PX);\n        mapStyle.setLeft(0, Unit.PX);\n\n        this.setWidth(\"100%\");\n        this.setHeight(\"100%\");\n\n        this.add(m_mapPanel);\n        m_div = m_mapPanel.getElement().cast();\n        m_div.setId(\"gwt-map\");\n\n        setStyleName(\"v-openlayers\");\n        LOG.info(\"NodeMapWidget(): div ID = \" + m_div.getId());\n\n        // addPassThroughHandlers();\n\n        addAttachHandler(new Handler() {\n            @Override\n            public void onAttachOrDetach(final AttachEvent event) {\n                if (event.isAttached()) {\n                    LOG.info(\"NodeMapWidget.onAttach()\");\n\n                    m_filter = new MarkerFilterImpl(\"\", AlarmSeverity.NORMAL, m_eventManager);\n                    m_markerContainer = new MarkerContainer(m_filter, m_eventManager);\n\n                    m_filter.onLoad();\n                    m_markerContainer.onLoad();\n\n                    Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n                        @Override public void execute() {\n                            initializeMap(m_div.getId());\n                        }\n                    });\n                } else {\n                    LOG.info(\"NodeMapwidget.onDetach()\");\n                    if (m_markerContainer != null) m_markerContainer.onUnload();\n                    if (m_filter != null) m_filter.onUnload();\n                    destroyMap();\n                }\n            }\n        });\n        LOG.info(\"NodeMapWidget(): initialized\");\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static boolean hasChanged(final String a, final String b) {\n        if (a == null && b == null) return false;\n        if (a == null && b != null) return true;\n        if (a != null && b == null) return true;\n        return !a.equals(b);\n    }","id":32317,"modified_method":"public static <T> boolean hasChanged(final T a, final T b) {\n        if (a == null && b == null) return false;\n        if (a == null && b != null) return true;\n        if (a != null && b == null) return true;\n        return !a.equals(b);\n    }","commit_id":"0036e2cd495830678882a57f9d8e5ef2c7cc6955","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public LibraryRuntimeClasspathScope(@NotNull Project project, @NotNull LibraryOrderEntry entry) {\n    super(project);\n    myIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    Collections.addAll(myEntries, entry.getRootFiles(OrderRootType.CLASSES));\n  }","id":32318,"modified_method":"public LibraryRuntimeClasspathScope(@NotNull Project project, @NotNull LibraryOrderEntry entry) {\n    super(project);\n    myIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    Collections.addAll(myEntries, entry.getRootFiles(OrderRootType.CLASSES));\n    Collections.addAll(myEntries, entry.getRootFiles(OrderRootType.SOURCES));\n  }","commit_id":"2a7de4377390f364725d897316105d56d9a61f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile getFileRoot(@NotNull VirtualFile file) {\n    if (myIndex.isInContent(file)) {\n      return myIndex.getSourceRootForFile(file);\n    }\n    if (myIndex.isInLibraryClasses(file)) {\n      return myIndex.getClassRootForFile(file);\n    }\n    return null;\n  }","id":32319,"modified_method":"@Nullable\n  private VirtualFile getFileRoot(@NotNull VirtualFile file) {\n    if (myIndex.isInContent(file) || myIndex.isInLibrarySource(file)) {\n      return myIndex.getSourceRootForFile(file);\n    }\n    if (myIndex.isInLibraryClasses(file)) {\n      return myIndex.getClassRootForFile(file);\n    }\n    return null;\n  }","commit_id":"2a7de4377390f364725d897316105d56d9a61f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildEntries(@NotNull final Module module,\n                            @NotNull final Set<Module> processedModules,\n                            @NotNull final Set<Library> processedLibraries,\n                            @NotNull final Set<Sdk> processedSdk,\n                            @NotNull Condition<OrderEntry> condition) {\n    if (!processedModules.add(module)) return;\n\n    ModuleRootManager.getInstance(module).orderEntries().recursively().satisfying(condition).process(new RootPolicy<Set<VirtualFile>>() {\n      @Override\n      public Set<VirtualFile> visitLibraryOrderEntry(final LibraryOrderEntry libraryOrderEntry,\n                                                               final Set<VirtualFile> value) {\n        final Library library = libraryOrderEntry.getLibrary();\n        if (library != null && processedLibraries.add(library)) {\n          ContainerUtil.addAll(value, libraryOrderEntry.getRootFiles(OrderRootType.CLASSES));\n        }\n        return value;\n      }\n\n      @Override\n      public Set<VirtualFile> visitModuleSourceOrderEntry(final ModuleSourceOrderEntry moduleSourceOrderEntry,\n                                                                    final Set<VirtualFile> value) {\n        processedModules.add(moduleSourceOrderEntry.getOwnerModule());\n        ContainerUtil.addAll(value, moduleSourceOrderEntry.getRootModel().getSourceRoots());\n        return value;\n      }\n\n      @Override\n      public Set<VirtualFile> visitModuleOrderEntry(ModuleOrderEntry moduleOrderEntry, Set<VirtualFile> value) {\n        final Module depModule = moduleOrderEntry.getModule();\n        if (depModule != null) {\n          ContainerUtil.addAll(value, ModuleRootManager.getInstance(depModule).getSourceRoots());\n        }\n        return value;\n      }\n\n      @Override\n      public Set<VirtualFile> visitJdkOrderEntry(final JdkOrderEntry jdkOrderEntry, final Set<VirtualFile> value) {\n        final Sdk jdk = jdkOrderEntry.getJdk();\n        if (jdk != null && processedSdk.add(jdk)) {\n          ContainerUtil.addAll(value, jdkOrderEntry.getRootFiles(OrderRootType.CLASSES));\n        }\n        return value;\n      }\n    }, myEntries);\n  }","id":32320,"modified_method":"private void buildEntries(@NotNull final Module module,\n                            @NotNull final Set<Module> processedModules,\n                            @NotNull final Set<Library> processedLibraries,\n                            @NotNull final Set<Sdk> processedSdk,\n                            @NotNull Condition<OrderEntry> condition) {\n    if (!processedModules.add(module)) return;\n\n    ModuleRootManager.getInstance(module).orderEntries().recursively().satisfying(condition).process(new RootPolicy<Set<VirtualFile>>() {\n      @Override\n      public Set<VirtualFile> visitLibraryOrderEntry(final LibraryOrderEntry libraryOrderEntry,\n                                                               final Set<VirtualFile> value) {\n        final Library library = libraryOrderEntry.getLibrary();\n        if (library != null && processedLibraries.add(library)) {\n          ContainerUtil.addAll(value, libraryOrderEntry.getRootFiles(OrderRootType.CLASSES));\n          ContainerUtil.addAll(value, libraryOrderEntry.getRootFiles(OrderRootType.SOURCES));\n        }\n        return value;\n      }\n\n      @Override\n      public Set<VirtualFile> visitModuleSourceOrderEntry(final ModuleSourceOrderEntry moduleSourceOrderEntry,\n                                                                    final Set<VirtualFile> value) {\n        processedModules.add(moduleSourceOrderEntry.getOwnerModule());\n        ContainerUtil.addAll(value, moduleSourceOrderEntry.getRootModel().getSourceRoots());\n        return value;\n      }\n\n      @Override\n      public Set<VirtualFile> visitModuleOrderEntry(ModuleOrderEntry moduleOrderEntry, Set<VirtualFile> value) {\n        final Module depModule = moduleOrderEntry.getModule();\n        if (depModule != null) {\n          ContainerUtil.addAll(value, ModuleRootManager.getInstance(depModule).getSourceRoots());\n        }\n        return value;\n      }\n\n      @Override\n      public Set<VirtualFile> visitJdkOrderEntry(final JdkOrderEntry jdkOrderEntry, final Set<VirtualFile> value) {\n        final Sdk jdk = jdkOrderEntry.getJdk();\n        if (jdk != null && processedSdk.add(jdk)) {\n          ContainerUtil.addAll(value, jdkOrderEntry.getRootFiles(OrderRootType.CLASSES));\n          ContainerUtil.addAll(value, jdkOrderEntry.getRootFiles(OrderRootType.SOURCES));\n        }\n        return value;\n      }\n    }, myEntries);\n  }","commit_id":"2a7de4377390f364725d897316105d56d9a61f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testLibraryScopeForTwoDependentModules() throws IOException {\n    VirtualFile m1 = createModulePom(\"m1\", \"<groupId>test<\/groupId>\" +\n                                           \"<artifactId>m1<\/artifactId>\" +\n                                           \"<version>1<\/version>\" +\n\n                                           \"<dependencies>\" +\n                                           \"  <dependency>\" +\n                                           \"    <groupId>test<\/groupId>\" +\n                                           \"    <artifactId>m2<\/artifactId>\" +\n                                           \"    <version>1<\/version>\" +\n                                           \"  <\/dependency>\" +\n                                           \"<\/dependencies>\");\n\n    VirtualFile m2 = createModulePom(\"m2\", \"<groupId>test<\/groupId>\" +\n                                           \"<artifactId>m2<\/artifactId>\" +\n                                           \"<version>1<\/version>\" +\n                                           \"    <dependencies>\" +\n                                           \"        <dependency>\" +\n                                           \"            <groupId>junit<\/groupId>\" +\n                                           \"            <artifactId>junit<\/artifactId>\" +\n                                           \"            <version>4.0<\/version>\" +\n                                           \"            <scope>provided<\/scope>\" +\n                                           \"        <\/dependency>\" +\n                                           \"    <\/dependencies>\");\n    importProjects(m1, m2);\n    assertModules(\"m1\", \"m2\");\n\n    Module m1m = ModuleManager.getInstance(myProject).findModuleByName(\"m1\");\n    List<OrderEntry> modules1 = new ArrayList<>();\n    ModuleRootManager.getInstance(m1m).orderEntries().withoutSdk().withoutModuleSourceEntries().forEach(\n      new CommonProcessors.CollectProcessor<>(modules1));\n    GlobalSearchScope scope1 = LibraryScopeCache.getInstance(myProject).getLibraryScope(modules1);\n    assertSearchScope(scope1,\n                      getProjectPath() + \"/m1/src/main/java\",\n                      getProjectPath() + \"/m1/src/test/java\",\n                      getProjectPath() + \"/m2/src/main/java\",\n                      getProjectPath() + \"/m2/src/test/java\"\n                      );\n\n    String libraryPath = getRepositoryPath() + \"/junit/junit/4.0/junit-4.0.jar\";\n    Module m2m = ModuleManager.getInstance(myProject).findModuleByName(\"m2\");\n    List<OrderEntry> modules2 = new ArrayList<>();\n    ModuleRootManager.getInstance(m2m).orderEntries().withoutSdk().withoutModuleSourceEntries().forEach(\n      new CommonProcessors.CollectProcessor<>(modules2));\n    GlobalSearchScope scope2 = LibraryScopeCache.getInstance(myProject).getLibraryScope(modules2);\n    assertSearchScope(scope2,\n                      getProjectPath() + \"/m2/src/main/java\",\n                      getProjectPath() + \"/m2/src/test/java\",\n                      libraryPath\n    );\n  }","id":32321,"modified_method":"public void testLibraryScopeForTwoDependentModules() throws IOException {\n    VirtualFile m1 = createModulePom(\"m1\", \"<groupId>test<\/groupId>\" +\n                                           \"<artifactId>m1<\/artifactId>\" +\n                                           \"<version>1<\/version>\" +\n\n                                           \"<dependencies>\" +\n                                           \"  <dependency>\" +\n                                           \"    <groupId>test<\/groupId>\" +\n                                           \"    <artifactId>m2<\/artifactId>\" +\n                                           \"    <version>1<\/version>\" +\n                                           \"  <\/dependency>\" +\n                                           \"<\/dependencies>\");\n\n    VirtualFile m2 = createModulePom(\"m2\", \"<groupId>test<\/groupId>\" +\n                                           \"<artifactId>m2<\/artifactId>\" +\n                                           \"<version>1<\/version>\" +\n                                           \"    <dependencies>\" +\n                                           \"        <dependency>\" +\n                                           \"            <groupId>junit<\/groupId>\" +\n                                           \"            <artifactId>junit<\/artifactId>\" +\n                                           \"            <version>4.0<\/version>\" +\n                                           \"            <scope>provided<\/scope>\" +\n                                           \"        <\/dependency>\" +\n                                           \"    <\/dependencies>\");\n    importProjects(m1, m2);\n    assertModules(\"m1\", \"m2\");\n\n    Module m1m = ModuleManager.getInstance(myProject).findModuleByName(\"m1\");\n    List<OrderEntry> modules1 = new ArrayList<>();\n    ModuleRootManager.getInstance(m1m).orderEntries().withoutSdk().withoutModuleSourceEntries().forEach(\n      new CommonProcessors.CollectProcessor<>(modules1));\n    GlobalSearchScope scope1 = LibraryScopeCache.getInstance(myProject).getLibraryScope(modules1);\n    assertSearchScope(scope1,\n                      getProjectPath() + \"/m1/src/main/java\",\n                      getProjectPath() + \"/m1/src/test/java\",\n                      getProjectPath() + \"/m2/src/main/java\",\n                      getProjectPath() + \"/m2/src/test/java\"\n                      );\n\n    String libraryPath = getRepositoryPath() + \"/junit/junit/4.0/junit-4.0.jar\";\n    String librarySrcPath = getRepositoryPath() + \"/junit/junit/4.0/junit-4.0-sources.jar\";\n    Module m2m = ModuleManager.getInstance(myProject).findModuleByName(\"m2\");\n    List<OrderEntry> modules2 = new ArrayList<>();\n    ModuleRootManager.getInstance(m2m).orderEntries().withoutSdk().withoutModuleSourceEntries().forEach(\n      new CommonProcessors.CollectProcessor<>(modules2));\n    GlobalSearchScope scope2 = LibraryScopeCache.getInstance(myProject).getLibraryScope(modules2);\n\n    List<String> expectedPaths = ContainerUtil.newArrayList(getProjectPath() + \"/m2/src/main/java\", getProjectPath() + \"/m2/src/test/java\", libraryPath);\n    if (new File(librarySrcPath).exists()) {\n      expectedPaths.add(librarySrcPath);\n    }\n    assertSearchScope(scope2, ArrayUtil.toStringArray(expectedPaths));\n  }","commit_id":"2a7de4377390f364725d897316105d56d9a61f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile initPackageRootsAndReturnPubspecYamlFile(final @NotNull VirtualFile contextFile) {\n    final Module module = ModuleUtilCore.findModuleForFile(contextFile, myProject);\n    if (module == null) return null;\n\n    final VirtualFile[] customPackageRoots = DartConfigurable.getCustomPackageRoots(module);\n    if (customPackageRoots.length > 0) {\n      Collections.addAll(myPackageRoots, customPackageRoots);\n      return null;\n    }\n\n    final VirtualFile pubspecYamlFile = findPubspecYamlFile(myProject, contextFile);\n    final VirtualFile parentFolder = pubspecYamlFile == null ? null : pubspecYamlFile.getParent();\n    final VirtualFile packagesFolder = parentFolder == null ? null : parentFolder.findChild(PACKAGES_FOLDER_NAME);\n    if (packagesFolder != null && packagesFolder.isDirectory()) {\n      myPackageRoots.add(packagesFolder);\n    }\n\n    return pubspecYamlFile;\n  }","id":32322,"modified_method":"@Nullable\n  private VirtualFile initPackageRootsAndReturnPubspecYamlFile(final @NotNull VirtualFile contextFile) {\n    final Module module = ModuleUtilCore.findModuleForFile(contextFile, myProject);\n    if (module == null) return null;\n\n    final VirtualFile[] customPackageRoots = DartConfigurable.getCustomPackageRoots(module);\n    if (customPackageRoots.length > 0) {\n      Collections.addAll(myPackageRoots, customPackageRoots);\n      return null;\n    }\n\n    final VirtualFile pubspecYamlFile = PubspecYamlUtil.findPubspecYamlFile(myProject, contextFile);\n    final VirtualFile parentFolder = pubspecYamlFile == null ? null : pubspecYamlFile.getParent();\n    final VirtualFile packagesFolder = parentFolder == null ? null : parentFolder.findChild(PACKAGES_FOLDER_NAME);\n    if (packagesFolder != null && packagesFolder.isDirectory()) {\n      myPackageRoots.add(packagesFolder);\n    }\n\n    return pubspecYamlFile;\n  }","commit_id":"e46b1a1012ae725726740a1746514d6eae91644d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void initLivePackageNameToDirMap() {\n    if (myPubspecYamlFile == null) return;\n\n    final VirtualFile baseDir = myPubspecYamlFile.getParent();\n    final Map<String, Object> yamlInfo = getPubspecYamlInfo(myPubspecYamlFile);\n    if (baseDir != null && yamlInfo != null) {\n      fillLivePackageNameToDirMap(myProject, myLivePackageNameToDirMap, baseDir, yamlInfo);\n    }\n  }","id":32323,"modified_method":"private void initLivePackageNameToDirMap() {\n    final VirtualFile baseDir = myPubspecYamlFile == null ? null : myPubspecYamlFile.getParent();\n    if (myPubspecYamlFile == null || baseDir == null) return;\n\n    final String name = PubspecYamlUtil.getDartProjectName(myPubspecYamlFile);\n    final VirtualFile libFolder = baseDir.findChild(PubspecYamlUtil.LIB_DIR_NAME);\n\n    if (name != null && libFolder != null && libFolder.isDirectory()) {\n      myLivePackageNameToDirMap.put(name, libFolder);\n    }\n\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n\n    PubspecYamlUtil.processPathPackages(myPubspecYamlFile, new PairConsumer<String, VirtualFile>() {\n      @Override\n      public void consume(@NotNull final String packageName, @NotNull final VirtualFile packageDir) {\n        if (fileIndex.isInContent(packageDir)) {\n          myLivePackageNameToDirMap.put(packageName, packageDir);\n        }\n      }\n    });\n  }","commit_id":"e46b1a1012ae725726740a1746514d6eae91644d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  static Map<String, Object> getPubspecYamlInfo(final @NotNull VirtualFile pubspecYamlFile) {\n    // do not use Yaml plugin here - IntelliJ IDEA Community Edition doesn't contain it.\n    Pair<Long, Map<String, Object>> data = pubspecYamlFile.getUserData(MOD_STAMP_TO_PUBSPEC_NAME);\n\n    final FileDocumentManager documentManager = FileDocumentManager.getInstance();\n    final Document cachedDocument = documentManager.getCachedDocument(pubspecYamlFile);\n    final Long currentTimestamp = cachedDocument != null ? cachedDocument.getModificationStamp() : pubspecYamlFile.getModificationCount();\n    final Long cachedTimestamp = data == null ? null : data.first;\n\n    if (cachedTimestamp == null || !cachedTimestamp.equals(currentTimestamp)) {\n      data = null;\n      pubspecYamlFile.putUserData(MOD_STAMP_TO_PUBSPEC_NAME, null);\n      try {\n        final Map<String, Object> pubspecYamlInfo;\n        if (cachedDocument != null) {\n          pubspecYamlInfo = loadPubspecYamlInfo(cachedDocument.getText());\n        }\n        else {\n          pubspecYamlInfo = loadPubspecYamlInfo(VfsUtilCore.loadText(pubspecYamlFile));\n        }\n\n        if (pubspecYamlInfo != null) {\n          data = Pair.create(currentTimestamp, pubspecYamlInfo);\n          pubspecYamlFile.putUserData(MOD_STAMP_TO_PUBSPEC_NAME, data);\n        }\n      }\n      catch (IOException ignored) {/* unlucky */}\n    }\n\n    return data == null ? null : data.second;\n  }","id":32324,"modified_method":"@Nullable\n  private static Map<String, Object> getPubspecYamlInfo(final @NotNull VirtualFile pubspecYamlFile) {\n    // do not use Yaml plugin here - IntelliJ IDEA Community Edition doesn't contain it.\n    Pair<Long, Map<String, Object>> data = pubspecYamlFile.getUserData(MOD_STAMP_TO_PUBSPEC_NAME);\n\n    final FileDocumentManager documentManager = FileDocumentManager.getInstance();\n    final Document cachedDocument = documentManager.getCachedDocument(pubspecYamlFile);\n    final Long currentTimestamp = cachedDocument != null ? cachedDocument.getModificationStamp() : pubspecYamlFile.getModificationCount();\n    final Long cachedTimestamp = data == null ? null : data.first;\n\n    if (cachedTimestamp == null || !cachedTimestamp.equals(currentTimestamp)) {\n      data = null;\n      pubspecYamlFile.putUserData(MOD_STAMP_TO_PUBSPEC_NAME, null);\n      try {\n        final Map<String, Object> pubspecYamlInfo;\n        if (cachedDocument != null) {\n          pubspecYamlInfo = loadPubspecYamlInfo(cachedDocument.getText());\n        }\n        else {\n          pubspecYamlInfo = loadPubspecYamlInfo(VfsUtilCore.loadText(pubspecYamlFile));\n        }\n\n        if (pubspecYamlInfo != null) {\n          data = Pair.create(currentTimestamp, pubspecYamlInfo);\n          pubspecYamlFile.putUserData(MOD_STAMP_TO_PUBSPEC_NAME, data);\n        }\n      }\n      catch (IOException ignored) {/* unlucky */}\n    }\n\n    return data == null ? null : data.second;\n  }","commit_id":"e46b1a1012ae725726740a1746514d6eae91644d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public static VirtualFile findPubspecYamlFile(@NotNull final Project project, @NotNull final VirtualFile contextFile) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    VirtualFile parent = contextFile;\n    while ((parent = parent.getParent()) != null && fileIndex.isInContent(parent)) {\n      final VirtualFile file = parent.findChild(PUBSPEC_YAML);\n      if (file != null && !file.isDirectory()) return file;\n    }\n\n    return null;\n  }","id":32325,"modified_method":"@Nullable\n  public static VirtualFile findPubspecYamlFile(@NotNull final Project project, @NotNull final VirtualFile contextFile) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    VirtualFile current = contextFile;\n    VirtualFile parent;\n    while ((parent = current.getParent()) != null && (LIB_DIR_NAME.equals(current.getName()) || fileIndex.isInContent(parent))) {\n      current = parent;\n      final VirtualFile file = parent.findChild(PUBSPEC_YAML);\n      if (file != null && !file.isDirectory()) return file;\n    }\n\n    return null;\n  }","commit_id":"e46b1a1012ae725726740a1746514d6eae91644d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Resolve relative imports from sdk root to the skeleton dir\n   */\n  private void addRelativeImportResultsFromSkeletons(@NotNull final PsiFile foothold) {\n    final boolean inSource = FileIndexFacade.getInstance(foothold.getProject()).isInContent(foothold.getVirtualFile());\n    if (inSource) return;\n    PsiDirectory containingDirectory = foothold.getContainingDirectory();\n    if (myRelativeLevel > 0) {\n      containingDirectory = ResolveImportUtil.stepBackFrom(foothold, myRelativeLevel);\n    }\n    if (containingDirectory != null) {\n      final QualifiedName containingQName = QualifiedNameFinder.findCanonicalImportPath(containingDirectory, null);\n      if (containingQName != null && containingQName.getComponentCount() > 0) {\n        final QualifiedName absoluteQName = containingQName.append(myQualifiedName.toString());\n        final QualifiedNameResolverImpl absoluteVisitor =\n          (QualifiedNameResolverImpl)new QualifiedNameResolverImpl(absoluteQName).fromElement(foothold);\n\n        final Sdk sdk = PythonSdkType.getSdk(foothold);\n        if (sdk == null) return;\n        final VirtualFile skeletonsDir = PySdkUtil.findSkeletonsDir(sdk);\n        if (skeletonsDir == null) return;\n        final PsiDirectory directory = myContext.getPsiManager().findDirectory(skeletonsDir);\n        final PsiElement psiElement = absoluteVisitor.resolveModuleAt(directory);\n        if (psiElement != null)\n          myLibResults.add(psiElement);\n      }\n    }\n  }","id":32326,"modified_method":"/**\n   * Resolve relative imports from sdk root to the skeleton dir\n   */\n  private void addRelativeImportResultsFromSkeletons(@NotNull final PsiFile foothold) {\n    final VirtualFile vFile = foothold.getVirtualFile();\n    if (vFile == null || FileIndexFacade.getInstance(foothold.getProject()).isInContent(vFile)) {\n      return;\n    }\n    PsiDirectory containingDirectory = foothold.getContainingDirectory();\n    if (myRelativeLevel > 0) {\n      containingDirectory = ResolveImportUtil.stepBackFrom(foothold, myRelativeLevel);\n    }\n    if (containingDirectory != null) {\n      final QualifiedName containingQName = QualifiedNameFinder.findCanonicalImportPath(containingDirectory, null);\n      if (containingQName != null && containingQName.getComponentCount() > 0) {\n        final QualifiedName absoluteQName = containingQName.append(myQualifiedName.toString());\n        final QualifiedNameResolverImpl absoluteVisitor =\n          (QualifiedNameResolverImpl)new QualifiedNameResolverImpl(absoluteQName).fromElement(foothold);\n\n        final Sdk sdk = PythonSdkType.getSdk(foothold);\n        if (sdk == null) return;\n        final VirtualFile skeletonsDir = PySdkUtil.findSkeletonsDir(sdk);\n        if (skeletonsDir == null) return;\n        final PsiDirectory directory = myContext.getPsiManager().findDirectory(skeletonsDir);\n        final PsiElement psiElement = absoluteVisitor.resolveModuleAt(directory);\n        if (psiElement != null)\n          myLibResults.add(psiElement);\n      }\n    }\n  }","commit_id":"3b7a90ebb7a4ae92ede4dc5961bec1f5fcac5659","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean contains(@NotNull VirtualFile file) {\n      return myFileIndexFacade.isInContent(file);\n    }","id":32327,"modified_method":"@Override\n    public boolean contains(@NotNull VirtualFile file) {\n      return myFileIndexFacade.isInContent(file) &&\n             // skip libraries that can be under our project content (IDEA-147584)\n             !myFileIndexFacade.isInLibraryClasses(file) &&\n             !myFileIndexFacade.isInLibrarySource(file);\n    }","commit_id":"c5036590077a174c7e53d516875f84e947072251","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testAccessToFilesUnderProjectRootAndDotIdea() throws Exception {\n    saveProject();\n    VirtualFile fileUnderProjectDir = new WriteAction<VirtualFile>() {\n      @Override\n      protected void run(@NotNull Result<VirtualFile> result) throws Throwable {\n        result.setResult(getProject().getBaseDir().createChildData(this, \"fileUnderProjectDir.txt\"));\n      }\n    }.execute().getResultObject();\n    \n    assertFalse(ProjectFileIndex.SERVICE.getInstance(getProject()).isInContent(fileUnderProjectDir));\n\n    typeAndCheck(getProject().getProjectFile(), true);\n    typeAndCheck(getProject().getWorkspaceFile(), true);\n    typeAndCheck(fileUnderProjectDir, false);\n  }","id":32328,"modified_method":"public void testAccessToProjectSystemFiles() throws Exception {\n    saveProject();\n    VirtualFile fileUnderProjectDir = new WriteAction<VirtualFile>() {\n      @Override\n      protected void run(@NotNull Result<VirtualFile> result) throws Throwable {\n        result.setResult(getProject().getBaseDir().createChildData(this, \"fileUnderProjectDir.txt\"));\n      }\n    }.execute().getResultObject();\n    \n    assertFalse(ProjectFileIndex.SERVICE.getInstance(getProject()).isInContent(fileUnderProjectDir));\n\n    typeAndCheck(getProject().getProjectFile(), true);\n    typeAndCheck(getProject().getWorkspaceFile(), true);\n    typeAndCheck(fileUnderProjectDir, false);\n  }","commit_id":"a0125dc5cc57ed05d0b9804221f68662016363ba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isProjectFile(@NotNull VirtualFile file) {\n    if (myProject instanceof ProjectEx) {\n      IProjectStore store = ((ProjectEx)myProject).getStateStore();\n\n      if (store.getStorageScheme() == StorageScheme.DIRECTORY_BASED) {\n        VirtualFile baseDir = myProject.getBaseDir();\n        VirtualFile dotIdea = baseDir == null ? null : baseDir.findChild(Project.DIRECTORY_STORE_FOLDER);\n        if (dotIdea != null && VfsUtilCore.isAncestor(dotIdea, file, false)) return true;\n      }\n\n      if (file.equals(store.getWorkspaceFile()) || file.equals(store.getProjectFile())) return true;\n    }\n\n    return ProjectFileIndex.SERVICE.getInstance(myProject).isInContent(file);\n  }","id":32329,"modified_method":"private boolean isProjectFile(@NotNull VirtualFile file) {\n    if (ProjectFileIndex.SERVICE.getInstance(myProject).isInContent(file)) return true;\n    \n    if (myProject instanceof ProjectEx) {\n      IProjectStore store = ((ProjectEx)myProject).getStateStore();\n\n      if (store.getStorageScheme() == StorageScheme.DIRECTORY_BASED) {\n        VirtualFile baseDir = myProject.getBaseDir();\n        VirtualFile dotIdea = baseDir == null ? null : baseDir.findChild(Project.DIRECTORY_STORE_FOLDER);\n        if (dotIdea != null && VfsUtilCore.isAncestor(dotIdea, file, false)) return true;\n      }\n\n      if (file.equals(store.getWorkspaceFile()) || file.equals(store.getProjectFile())) return true;\n      for (Module each : ModuleManager.getInstance(myProject).getModules()) {\n        if (file.equals(each.getModuleFile())) return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"a0125dc5cc57ed05d0b9804221f68662016363ba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean underProject(final File file) {\n    return ExcludedFileIndex.getInstance(myProject).isInContent(SvnUtil.getVirtualFile(file.getAbsolutePath()));\n  }","id":32330,"modified_method":"private boolean underProject(final File file) {\n    final VirtualFile vf = SvnUtil.getVirtualFile(file.getAbsolutePath());\n    return (vf == null) || ExcludedFileIndex.getInstance(myProject).isInContent(vf);\n  }","commit_id":"d354470b7603ee99465868c53d6d4a173d320e9e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    private JComboBox createTestTypeComboBox(TestTypeListItem[] testTypeListItems) {\n      JComboBox comboBox = new JComboBox(testTypeListItems);\n      final ListCellRenderer oldRenderer = comboBox.getRenderer();\n      comboBox.setRenderer(new ListCellRenderer() {\n        @Override\n        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n          return oldRenderer.getListCellRendererComponent(list, ((TestTypeListItem) value).getDisplayName(), index, isSelected, cellHasFocus);\n        }\n      });\n      comboBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          selectTestType(getSelectedTestType());\n        }\n      });\n      return comboBox;\n    }","id":32331,"modified_method":"@NotNull\n    private JComboBox createTestTypeComboBox(TestTypeListItem[] testTypeListItems) {\n      JComboBox comboBox = new JComboBox(testTypeListItems);\n      comboBox.setRenderer(new ListCellRendererWrapper<TestTypeListItem>(comboBox.getRenderer()) {\n        @Override\n        public void customize(JList list, TestTypeListItem value, int index, boolean selected, boolean hasFocus) {\n          setText(value.getDisplayName());\n        }\n      });\n      comboBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          selectTestType(getSelectedTestType());\n        }\n      });\n      return comboBox;\n    }","commit_id":"6340f7ff6b6818114bceb8a5bf795ee4ba50a381","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@TaskAction\n    public void generate() {\n        try {\n            ReportRenderer renderer = getRenderer();\n            renderer.setClientMetaData(getClientMetaData());\n            File outputFile = getOutputFile();\n            if (outputFile != null) {\n                renderer.setOutputFile(outputFile);\n            } else {\n                renderer.setOutput(getTextOutputFactory().create(getClass()));\n            }\n            Set<Project> projects = new TreeSet<Project>(getProjects());\n            for (Project project : projects) {\n                renderer.startProject(project);\n                generate(project);\n                renderer.completeProject(project);\n            }\n            renderer.complete();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }","id":32332,"modified_method":"@TaskAction\n    public void generate() {\n        ProjectReportGenerator projectReportGenerator = new ProjectReportGenerator() {\n            @Override\n            public void generateReport(Project project) throws IOException {\n                generate(project);\n            }\n        };\n\n        ReportGenerator reportGenerator = new ReportGenerator(getRenderer(), getClientMetaData(), getOutputFile(),\n                getTextOutputFactory(), projectReportGenerator);\n        reportGenerator.generateReport(new TreeSet<Project>(getProjects()));\n    }","commit_id":"e4ee7b10a8a2ee1ae40244aa298a1e3103c2b991","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected void realRun() throws SAXException, IOException, OsmTransferException {\n            final List<Locale> locales = new ArrayList<Locale>(\n                    Arrays.asList(I18n.getAvailableTranslations(getProgressMonitor()))\n            );\n            locales.add(0,Locale.ENGLISH);\n            Runnable r = new Runnable() {\n                public void run() {\n                    langCombo.removeAll();\n                    langCombo.addItem(null); // the default enry\n                    for (Locale locale : locales) {\n                        langCombo.addItem(locale);\n                    }\n                    String ln = Main.pref.get(\"language\");\n                    langCombo.setSelectedIndex(0);\n                    if (ln != null) {\n                        for (int i = 1; i < langCombo.getItemCount(); ++i) {\n                            if (((Locale) langCombo.getItemAt(i)).toString().equals(ln)) {\n                                langCombo.setSelectedIndex(i);\n                                break;\n                            }\n                        }\n                    }\n                }\n            };\n            try {\n                SwingUtilities.invokeAndWait(r);\n            } catch(InvocationTargetException e) {\n                throw new RuntimeException(e.getCause());\n            } catch(InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }","id":32333,"modified_method":"@Override\n        protected void realRun() throws SAXException, IOException, OsmTransferException {\n            final List<Locale> locales = new ArrayList<Locale>(\n                    Arrays.asList(I18n.getAvailableTranslations(getProgressMonitor()))\n            );\n            locales.add(0,Locale.ENGLISH);\n            Runnable r = new Runnable() {\n                public void run() {\n                    model.setAvailableLocales(locales);\n                    model.selectLanguage(Main.pref.get(\"language\"));\n                }\n            };\n            try {\n                SwingUtilities.invokeAndWait(r);\n            } catch(InvocationTargetException e) {\n                throw new RuntimeException(e.getCause());\n            } catch(InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }","commit_id":"be57b8cec8066a1f22f6895c0301fc38d2ba349e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void addGui(final PreferenceDialog gui) {\n        //langCombo = new JComboBox(I18n.getAvailableTranslations());\n        langCombo = new JComboBox(new Locale[0]);\n\n        final ListCellRenderer oldRenderer = langCombo.getRenderer();\n        langCombo.setRenderer(new DefaultListCellRenderer() {\n            @Override\n            public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,\n                    boolean cellHasFocus) {\n                Locale l = (Locale) value;\n                return oldRenderer.getListCellRendererComponent(list,\n                        l == null ? tr(\"Default (Auto determined)\") : l.getDisplayName(),\n                                index, isSelected, cellHasFocus);\n            }\n        });\n\n        LafPreference lafPreference = gui.getSetting(LafPreference.class);\n        final JPanel panel = lafPreference.panel;\n        panel.add(new JLabel(tr(\"Language\")), GBC.std().insets(20, 0, 0, 0));\n        panel.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\n        panel.add(langCombo, GBC.eol().fill(GBC.HORIZONTAL));\n        panel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n\n        // this defers loading of available translations to the first time the tab\n        // with the available translations is selected by the user\n        //\n        gui.displaycontent.addChangeListener(\n                new ChangeListener() {\n                    public void stateChanged(ChangeEvent e) {\n                        int i = gui.displaycontent.getSelectedIndex();\n                        String title = gui.displaycontent.getTitleAt(i);\n                        if (title.equals(tr(\"Look and Feel\"))) {\n                            initiallyLoadAvailableTranslations();\n                        }\n                    }\n                }\n        );\n    }","id":32334,"modified_method":"public void addGui(final PreferenceDialog gui) {\n        model = new LanguageComboBoxModel();\n        langCombo = new JComboBox(model);\n        langCombo.setRenderer(new LanguageCellRenderer(langCombo.getRenderer()));\n\n        LafPreference lafPreference = gui.getSetting(LafPreference.class);\n        final JPanel panel = lafPreference.panel;\n        panel.add(new JLabel(tr(\"Language\")), GBC.std().insets(20, 0, 0, 0));\n        panel.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\n        panel.add(langCombo, GBC.eol().fill(GBC.HORIZONTAL));\n        panel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n\n        // this defers loading of available translations to the first time the tab\n        // with the available translations is selected by the user\n        //\n        gui.displaycontent.addChangeListener(\n                new ChangeListener() {\n                    public void stateChanged(ChangeEvent e) {\n                        int i = gui.displaycontent.getSelectedIndex();\n                        String title = gui.displaycontent.getTitleAt(i);\n                        if (title.equals(tr(\"Look and Feel\"))) {\n                            initiallyLoadAvailableTranslations();\n                        }\n                    }\n                }\n        );\n    }","commit_id":"be57b8cec8066a1f22f6895c0301fc38d2ba349e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public boolean ok() {\n        if(langCombo.getSelectedItem() == null)\n            return Main.pref.put(\"language\", null);\n        else\n            return Main.pref.put(\"language\",\n                    ((Locale)langCombo.getSelectedItem()).toString());\n    }","id":32335,"modified_method":"public boolean ok() {\n        if (!translationsLoaded)\n            // keep the current language, don't update preferences\n            return true;\n        if(langCombo.getSelectedItem() == null)\n            return Main.pref.put(\"language\", null);\n        else\n            return Main.pref.put(\"language\",\n                    ((Locale)langCombo.getSelectedItem()).toString());\n    }","commit_id":"be57b8cec8066a1f22f6895c0301fc38d2ba349e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void initiallyLoadAvailableTranslations() {\n        if (!translationsLoaded) {\n            reloadAvailableTranslations();\n        }\n        translationsLoaded = true;\n    }","id":32336,"modified_method":"/**\n     * Load available translations if not loaded yet.\n     */\n    public void initiallyLoadAvailableTranslations() {\n        if (!translationsLoaded) {\n            reloadAvailableTranslations();\n        }\n        translationsLoaded = true;\n    }","commit_id":"be57b8cec8066a1f22f6895c0301fc38d2ba349e","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void reloadAvailableTranslations() {\n        Main.worker.submit(new AvailableTranslationsLoader());\n    }","id":32337,"modified_method":"/**\n     * Asynchronously loads available translations\n     * \n     */\n    protected void reloadAvailableTranslations() {\n        Main.worker.submit(new AvailableTranslationsLoader());\n    }","commit_id":"be57b8cec8066a1f22f6895c0301fc38d2ba349e","url":"https://github.com/openstreetmap/josm"},{"original_method":"SettingsEditor(Disposable parent, Project project, ConfigurableGroup[] groups, Configurable configurable, String filter) {\n    super(parent);\n\n    myProperties = PropertiesComponent.getInstance(project);\n    mySettings = new Settings(groups) {\n      @Override\n      protected ActionCallback selectImpl(Configurable configurable) {\n        myFilter.update(null, false, true);\n        return myTreeView.select(configurable);\n      }\n    };\n    mySearch = new SettingsSearch() {\n      @Override\n      void onTextKeyEvent(KeyEvent event) {\n        myTreeView.myTree.processKeyEvent(event);\n      }\n    };\n    myFilter = new SettingsFilter(project, groups, mySearch) {\n      @Override\n      Configurable getConfigurable(SimpleNode node) {\n        return SettingsTreeView.getConfigurable(node);\n      }\n\n      @Override\n      SimpleNode findNode(Configurable configurable) {\n        return myTreeView.findNode(configurable);\n      }\n\n      @Override\n      void updateSpotlight(boolean now) {\n        if (!myDisposed && mySpotlightPainter != null) {\n          if (!now) {\n            mySpotlightPainter.updateLater();\n          }\n          else {\n            mySpotlightPainter.updateNow();\n          }\n        }\n      }\n    };\n    myFilter.myContext.addColleague(new OptionsEditorColleague() {\n      @Override\n      public ActionCallback onSelected(@Nullable Configurable configurable, Configurable oldConfigurable) {\n        if (configurable != null) {\n          myProperties.setValue(SELECTED_CONFIGURABLE, ConfigurableVisitor.ByID.getID(configurable));\n        }\n        checkModified(oldConfigurable);\n        return myEditor.select(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedAdded(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedRemoved(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onErrorsChanged() {\n        return updateIfCurrent(myFilter.myContext.getCurrentConfigurable());\n      }\n\n      private ActionCallback updateIfCurrent(Configurable configurable) {\n        if (configurable != null && configurable == myFilter.myContext.getCurrentConfigurable()) {\n          updateStatus(configurable);\n          return ActionCallback.DONE;\n        }\n        else {\n          return ActionCallback.REJECTED;\n        }\n      }\n    });\n    myTreeView = new SettingsTreeView(myFilter, groups);\n    myTreeView.myTree.addKeyListener(mySearch);\n    myTreeView.addComponentListener(new ComponentAdapter() {\n      @Override\n      public void componentResized(ComponentEvent event) {\n        Dimension size = mySearch.getPreferredSize();\n        size.width = myTreeView.getWidth() - 10;\n        mySearch.setPreferredSize(size);\n        mySearch.setSize(size);\n        mySearch.revalidate();\n        mySearch.repaint();\n      }\n    });\n    myEditor = new ConfigurableEditor(this, null) {\n      @Override\n      boolean apply() {\n        checkModified(myFilter.myContext.getCurrentConfigurable());\n        if (myFilter.myContext.getModified().isEmpty()) {\n          return true;\n        }\n        Map<Configurable, ConfigurationException> map = new LinkedHashMap<Configurable, ConfigurationException>();\n        for (Configurable configurable : myFilter.myContext.getModified()) {\n          ConfigurationException exception = ConfigurableEditor.apply(configurable);\n          if (exception != null) {\n            map.put(configurable, exception);\n          }\n          else if (!configurable.isModified()) {\n            myFilter.myContext.fireModifiedRemoved(configurable, null);\n          }\n        }\n        myFilter.myContext.fireErrorsChanged(map, null);\n        if (!map.isEmpty()) {\n          myTreeView.select(map.keySet().iterator().next());\n          return false;\n        }\n        updateStatus(myFilter.myContext.getCurrentConfigurable());\n        return true;\n      }\n\n      @Override\n      void updateCurrent(Configurable configurable, boolean reset) {\n        if (reset && configurable != null) {\n          myFilter.myContext.fireReset(configurable);\n        }\n        checkModified(configurable);\n      }\n\n      @Override\n      void openLink(Configurable configurable) {\n        mySettings.select(configurable);\n      }\n    };\n    mySplitter = new OnePixelSplitter(false, myProperties.getFloat(SPLITTER_PROPORTION, .2f));\n    mySplitter.setHonorComponentsMinimumSize(true);\n    mySplitter.setFirstComponent(myTreeView);\n    mySplitter.setSecondComponent(myEditor);\n    mySpotlightPainter = new SpotlightPainter(myEditor, this) {\n      void updateNow() {\n        Configurable configurable = myFilter.myContext.getCurrentConfigurable();\n        update(myFilter, configurable, myEditor.getContent(configurable));\n      }\n    };\n    myBanner = new Banner(myEditor.getResetAction());\n    myBanner.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));\n\n    JPanel panel = new JPanel(new BorderLayout(10, 10));\n    panel.add(BorderLayout.WEST, mySearch);\n    panel.add(BorderLayout.CENTER, myBanner);\n    panel.setBorder(BorderFactory.createCompoundBorder(\n      new CustomLineBorder(OnePixelDivider.BACKGROUND, 0, 0, 1, 0),\n      BorderFactory.createEmptyBorder(5, 5, 5, 5)));\n\n    add(BorderLayout.NORTH, panel);\n    add(BorderLayout.CENTER, mySplitter);\n\n    if (configurable == null) {\n      String id = myProperties.getValue(SELECTED_CONFIGURABLE);\n      configurable = new ConfigurableVisitor.ByID(id != null ? id : \"preferences.lookFeel\").find(groups);\n      if (configurable == null) {\n        configurable = ConfigurableVisitor.ALL.find(groups);\n      }\n    }\n    myFilter.update(filter, false, true);\n    myTreeView.select(configurable);\n    Disposer.register(this, myTreeView);\n  }","id":32338,"modified_method":"SettingsEditor(Disposable parent, Project project, ConfigurableGroup[] groups, Configurable configurable, String filter) {\n    super(parent);\n\n    myProperties = PropertiesComponent.getInstance(project);\n    mySettings = new Settings(groups) {\n      @Override\n      protected ActionCallback selectImpl(Configurable configurable) {\n        myFilter.update(null, false, true);\n        return myTreeView.select(configurable);\n      }\n    };\n    mySearch = new SettingsSearch() {\n      @Override\n      void onTextKeyEvent(KeyEvent event) {\n        myTreeView.myTree.processKeyEvent(event);\n      }\n    };\n    myFilter = new SettingsFilter(project, groups, mySearch) {\n      @Override\n      Configurable getConfigurable(SimpleNode node) {\n        return SettingsTreeView.getConfigurable(node);\n      }\n\n      @Override\n      SimpleNode findNode(Configurable configurable) {\n        return myTreeView.findNode(configurable);\n      }\n\n      @Override\n      void updateSpotlight(boolean now) {\n        if (!myDisposed && mySpotlightPainter != null) {\n          if (!now) {\n            mySpotlightPainter.updateLater();\n          }\n          else {\n            mySpotlightPainter.updateNow();\n          }\n        }\n      }\n    };\n    myFilter.myContext.addColleague(new OptionsEditorColleague() {\n      @Override\n      public ActionCallback onSelected(@Nullable Configurable configurable, Configurable oldConfigurable) {\n        if (configurable != null) {\n          myProperties.setValue(SELECTED_CONFIGURABLE, ConfigurableVisitor.ByID.getID(configurable));\n        }\n        checkModified(oldConfigurable);\n        return myEditor.select(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedAdded(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedRemoved(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onErrorsChanged() {\n        return updateIfCurrent(myFilter.myContext.getCurrentConfigurable());\n      }\n\n      private ActionCallback updateIfCurrent(Configurable configurable) {\n        if (configurable != null && configurable == myFilter.myContext.getCurrentConfigurable()) {\n          updateStatus(configurable);\n          return ActionCallback.DONE;\n        }\n        else {\n          return ActionCallback.REJECTED;\n        }\n      }\n    });\n    myTreeView = new SettingsTreeView(myFilter, groups);\n    myTreeView.myTree.addKeyListener(mySearch);\n    myEditor = new ConfigurableEditor(this, null) {\n      @Override\n      boolean apply() {\n        checkModified(myFilter.myContext.getCurrentConfigurable());\n        if (myFilter.myContext.getModified().isEmpty()) {\n          return true;\n        }\n        Map<Configurable, ConfigurationException> map = new LinkedHashMap<Configurable, ConfigurationException>();\n        for (Configurable configurable : myFilter.myContext.getModified()) {\n          ConfigurationException exception = ConfigurableEditor.apply(configurable);\n          if (exception != null) {\n            map.put(configurable, exception);\n          }\n          else if (!configurable.isModified()) {\n            myFilter.myContext.fireModifiedRemoved(configurable, null);\n          }\n        }\n        myFilter.myContext.fireErrorsChanged(map, null);\n        if (!map.isEmpty()) {\n          myTreeView.select(map.keySet().iterator().next());\n          return false;\n        }\n        updateStatus(myFilter.myContext.getCurrentConfigurable());\n        return true;\n      }\n\n      @Override\n      void updateCurrent(Configurable configurable, boolean reset) {\n        if (reset && configurable != null) {\n          myFilter.myContext.fireReset(configurable);\n        }\n        checkModified(configurable);\n      }\n\n      @Override\n      void openLink(Configurable configurable) {\n        mySettings.select(configurable);\n      }\n    };\n    myBanner = new Banner(myEditor.getResetAction());\n    myBanner.setBorder(BorderFactory.createEmptyBorder(0, 10, 0, 10));\n    mySearch.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n    mySearch.setBackground(myTreeView.myTree.getBackground());\n    mySearch.addComponentListener(new ComponentAdapter() {\n      @Override\n      public void componentResized(ComponentEvent event) {\n        Dimension size = myBanner.getPreferredSize();\n        size.height = mySearch.getHeight();\n        myBanner.setPreferredSize(size);\n        myBanner.setSize(size);\n        myBanner.revalidate();\n        myBanner.repaint();\n      }\n    });\n    JPanel left = new JPanel(new BorderLayout());\n    left.add(BorderLayout.NORTH, mySearch);\n    left.add(BorderLayout.CENTER, myTreeView);\n\n    JPanel right = new JPanel(new BorderLayout());\n    right.add(BorderLayout.NORTH, myBanner);\n    right.add(BorderLayout.CENTER, myEditor);\n\n    mySplitter = new OnePixelSplitter(false, myProperties.getFloat(SPLITTER_PROPORTION, .2f));\n    mySplitter.setHonorComponentsMinimumSize(true);\n    mySplitter.setFirstComponent(left);\n    mySplitter.setSecondComponent(right);\n    mySpotlightPainter = new SpotlightPainter(myEditor, this) {\n      void updateNow() {\n        Configurable configurable = myFilter.myContext.getCurrentConfigurable();\n        update(myFilter, configurable, myEditor.getContent(configurable));\n      }\n    };\n    add(BorderLayout.CENTER, mySplitter);\n\n    if (configurable == null) {\n      String id = myProperties.getValue(SELECTED_CONFIGURABLE);\n      configurable = new ConfigurableVisitor.ByID(id != null ? id : \"preferences.lookFeel\").find(groups);\n      if (configurable == null) {\n        configurable = ConfigurableVisitor.ALL.find(groups);\n      }\n    }\n    myFilter.update(filter, false, true);\n    myTreeView.select(configurable);\n    Disposer.register(this, myTreeView);\n  }","commit_id":"260258c3f5528ba412cb6dd11ab9a3a064aad056","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"SettingsEditor(Disposable parent, Project project, ConfigurableGroup[] groups, Configurable configurable, String filter) {\n    super(parent);\n\n    myProperties = PropertiesComponent.getInstance(project);\n    mySettings = new Settings(groups) {\n      @Override\n      protected ActionCallback selectImpl(Configurable configurable) {\n        myFilter.update(null, false, true);\n        return myTreeView.select(configurable);\n      }\n    };\n    mySearch = new SettingsSearch() {\n      @Override\n      void onTextKeyEvent(KeyEvent event) {\n        myTreeView.myTree.processKeyEvent(event);\n      }\n    };\n    myFilter = new SettingsFilter(project, groups, mySearch) {\n      @Override\n      Configurable getConfigurable(SimpleNode node) {\n        return SettingsTreeView.getConfigurable(node);\n      }\n\n      @Override\n      SimpleNode findNode(Configurable configurable) {\n        return myTreeView.findNode(configurable);\n      }\n\n      @Override\n      void updateSpotlight(boolean now) {\n        if (!myDisposed && mySpotlightPainter != null) {\n          if (!now) {\n            mySpotlightPainter.updateLater();\n          }\n          else {\n            mySpotlightPainter.updateNow();\n          }\n        }\n      }\n    };\n    myFilter.myContext.addColleague(new OptionsEditorColleague() {\n      @Override\n      public ActionCallback onSelected(@Nullable Configurable configurable, Configurable oldConfigurable) {\n        if (configurable != null) {\n          myProperties.setValue(SELECTED_CONFIGURABLE, ConfigurableVisitor.ByID.getID(configurable));\n        }\n        checkModified(oldConfigurable);\n        return myEditor.select(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedAdded(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedRemoved(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onErrorsChanged() {\n        return updateIfCurrent(myFilter.myContext.getCurrentConfigurable());\n      }\n\n      private ActionCallback updateIfCurrent(Configurable configurable) {\n        if (configurable != null && configurable == myFilter.myContext.getCurrentConfigurable()) {\n          updateStatus(configurable);\n          return ActionCallback.DONE;\n        }\n        else {\n          return ActionCallback.REJECTED;\n        }\n      }\n    });\n    myTreeView = new SettingsTreeView(myFilter, groups);\n    myTreeView.myTree.addKeyListener(mySearch);\n    myEditor = new ConfigurableEditor(this, null) {\n      @Override\n      boolean apply() {\n        checkModified(myFilter.myContext.getCurrentConfigurable());\n        if (myFilter.myContext.getModified().isEmpty()) {\n          return true;\n        }\n        Map<Configurable, ConfigurationException> map = new LinkedHashMap<Configurable, ConfigurationException>();\n        for (Configurable configurable : myFilter.myContext.getModified()) {\n          ConfigurationException exception = ConfigurableEditor.apply(configurable);\n          if (exception != null) {\n            map.put(configurable, exception);\n          }\n          else if (!configurable.isModified()) {\n            myFilter.myContext.fireModifiedRemoved(configurable, null);\n          }\n        }\n        myFilter.myContext.fireErrorsChanged(map, null);\n        if (!map.isEmpty()) {\n          myTreeView.select(map.keySet().iterator().next());\n          return false;\n        }\n        updateStatus(myFilter.myContext.getCurrentConfigurable());\n        return true;\n      }\n\n      @Override\n      void updateCurrent(Configurable configurable, boolean reset) {\n        if (reset && configurable != null) {\n          myFilter.myContext.fireReset(configurable);\n        }\n        checkModified(configurable);\n      }\n\n      @Override\n      void openLink(Configurable configurable) {\n        mySettings.select(configurable);\n      }\n    };\n    myBanner = new Banner(myEditor.getResetAction());\n    myBanner.setBorder(BorderFactory.createEmptyBorder(5, 10, 0, 10));\n    mySearch.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n    mySearch.setBackground(myTreeView.myTree.getBackground());\n    mySearch.addComponentListener(new ComponentAdapter() {\n      @Override\n      public void componentResized(ComponentEvent event) {\n        Dimension size = myBanner.getPreferredSize();\n        size.height = mySearch.getHeight() - 5;\n        myBanner.setPreferredSize(size);\n        myBanner.setSize(size);\n        myBanner.revalidate();\n        myBanner.repaint();\n      }\n    });\n    JPanel left = new JPanel(new BorderLayout());\n    left.add(BorderLayout.NORTH, mySearch);\n    left.add(BorderLayout.CENTER, myTreeView);\n\n    JPanel right = new JPanel(new BorderLayout());\n    right.add(BorderLayout.NORTH, myBanner);\n    right.add(BorderLayout.CENTER, myEditor);\n\n    mySplitter = new OnePixelSplitter(false, myProperties.getFloat(SPLITTER_PROPORTION, .2f));\n    mySplitter.setHonorComponentsMinimumSize(true);\n    mySplitter.setFirstComponent(left);\n    mySplitter.setSecondComponent(right);\n    mySpotlightPainter = new SpotlightPainter(myEditor, this) {\n      void updateNow() {\n        Configurable configurable = myFilter.myContext.getCurrentConfigurable();\n        update(myFilter, configurable, myEditor.getContent(configurable));\n      }\n    };\n    add(BorderLayout.CENTER, mySplitter);\n\n    if (configurable == null) {\n      String id = myProperties.getValue(SELECTED_CONFIGURABLE);\n      configurable = new ConfigurableVisitor.ByID(id != null ? id : \"preferences.lookFeel\").find(groups);\n      if (configurable == null) {\n        configurable = ConfigurableVisitor.ALL.find(groups);\n      }\n    }\n    myFilter.update(filter, false, true);\n    myTreeView.select(configurable);\n    Disposer.register(this, myTreeView);\n  }","id":32339,"modified_method":"SettingsEditor(Disposable parent, Project project, ConfigurableGroup[] groups, Configurable configurable, String filter) {\n    super(parent);\n\n    myProperties = PropertiesComponent.getInstance(project);\n    mySettings = new Settings(groups) {\n      @Override\n      protected ActionCallback selectImpl(Configurable configurable) {\n        myFilter.update(null, false, true);\n        return myTreeView.select(configurable);\n      }\n    };\n    mySearch = new SettingsSearch() {\n      @Override\n      void onTextKeyEvent(KeyEvent event) {\n        myTreeView.myTree.processKeyEvent(event);\n      }\n    };\n    myFilter = new SettingsFilter(project, groups, mySearch) {\n      @Override\n      Configurable getConfigurable(SimpleNode node) {\n        return SettingsTreeView.getConfigurable(node);\n      }\n\n      @Override\n      SimpleNode findNode(Configurable configurable) {\n        return myTreeView.findNode(configurable);\n      }\n\n      @Override\n      void updateSpotlight(boolean now) {\n        if (!myDisposed && mySpotlightPainter != null) {\n          if (!now) {\n            mySpotlightPainter.updateLater();\n          }\n          else {\n            mySpotlightPainter.updateNow();\n          }\n        }\n      }\n    };\n    myFilter.myContext.addColleague(new OptionsEditorColleague() {\n      @Override\n      public ActionCallback onSelected(@Nullable Configurable configurable, Configurable oldConfigurable) {\n        if (configurable != null) {\n          myProperties.setValue(SELECTED_CONFIGURABLE, ConfigurableVisitor.ByID.getID(configurable));\n        }\n        checkModified(oldConfigurable);\n        return myEditor.select(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedAdded(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onModifiedRemoved(Configurable configurable) {\n        return updateIfCurrent(configurable);\n      }\n\n      @Override\n      public ActionCallback onErrorsChanged() {\n        return updateIfCurrent(myFilter.myContext.getCurrentConfigurable());\n      }\n\n      private ActionCallback updateIfCurrent(Configurable configurable) {\n        if (configurable != null && configurable == myFilter.myContext.getCurrentConfigurable()) {\n          updateStatus(configurable);\n          return ActionCallback.DONE;\n        }\n        else {\n          return ActionCallback.REJECTED;\n        }\n      }\n    });\n    myTreeView = new SettingsTreeView(myFilter, groups);\n    myTreeView.myTree.addKeyListener(mySearch);\n    myEditor = new ConfigurableEditor(this, null) {\n      @Override\n      boolean apply() {\n        checkModified(myFilter.myContext.getCurrentConfigurable());\n        if (myFilter.myContext.getModified().isEmpty()) {\n          return true;\n        }\n        Map<Configurable, ConfigurationException> map = new LinkedHashMap<Configurable, ConfigurationException>();\n        for (Configurable configurable : myFilter.myContext.getModified()) {\n          ConfigurationException exception = ConfigurableEditor.apply(configurable);\n          if (exception != null) {\n            map.put(configurable, exception);\n          }\n          else if (!configurable.isModified()) {\n            myFilter.myContext.fireModifiedRemoved(configurable, null);\n          }\n        }\n        myFilter.myContext.fireErrorsChanged(map, null);\n        if (!map.isEmpty()) {\n          myTreeView.select(map.keySet().iterator().next());\n          return false;\n        }\n        updateStatus(myFilter.myContext.getCurrentConfigurable());\n        return true;\n      }\n\n      @Override\n      void updateCurrent(Configurable configurable, boolean reset) {\n        if (reset && configurable != null) {\n          myFilter.myContext.fireReset(configurable);\n        }\n        checkModified(configurable);\n      }\n\n      @Override\n      void openLink(Configurable configurable) {\n        mySettings.select(configurable);\n      }\n    };\n    myBanner = new Banner(myEditor.getResetAction());\n    mySearch.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n    JComponent left = myTreeView;\n    JComponent right = myEditor;\n    if (Registry.is(\"ide.settings.old.style\")) {\n      myBanner.setBorder(BorderFactory.createEmptyBorder(5, 10, 0, 10));\n      mySearch.setBackground(myTreeView.myTree.getBackground());\n      mySearch.addComponentListener(new ComponentAdapter() {\n        @Override\n        public void componentResized(ComponentEvent event) {\n          Dimension size = myBanner.getPreferredSize();\n          size.height = mySearch.getHeight() - 5;\n          myBanner.setPreferredSize(size);\n          myBanner.setSize(size);\n          myBanner.revalidate();\n          myBanner.repaint();\n        }\n      });\n      left = new JPanel(new BorderLayout());\n      left.add(BorderLayout.NORTH, mySearch);\n      left.add(BorderLayout.CENTER, myTreeView);\n\n      right = new JPanel(new BorderLayout());\n      right.add(BorderLayout.NORTH, myBanner);\n      right.add(BorderLayout.CENTER, myEditor);\n    }\n    else {\n      myBanner.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));\n      myTreeView.addComponentListener(new ComponentAdapter() {\n        @Override\n        public void componentResized(ComponentEvent event) {\n          Dimension size = mySearch.getPreferredSize();\n          size.width = myTreeView.getWidth();\n          mySearch.setPreferredSize(size);\n          mySearch.setSize(size);\n          mySearch.revalidate();\n          mySearch.repaint();\n        }\n      });\n      JPanel panel = new JPanel(new BorderLayout());\n      panel.add(BorderLayout.WEST, mySearch);\n      panel.add(BorderLayout.CENTER, myBanner);\n      panel.setBorder(new CustomLineBorder(OnePixelDivider.BACKGROUND, 0, 0, 1, 0));\n      add(BorderLayout.NORTH, panel);\n    }\n    mySplitter = new OnePixelSplitter(false, myProperties.getFloat(SPLITTER_PROPORTION, .2f));\n    mySplitter.setHonorComponentsMinimumSize(true);\n    mySplitter.setFirstComponent(left);\n    mySplitter.setSecondComponent(right);\n    mySpotlightPainter = new SpotlightPainter(myEditor, this) {\n      void updateNow() {\n        Configurable configurable = myFilter.myContext.getCurrentConfigurable();\n        update(myFilter, configurable, myEditor.getContent(configurable));\n      }\n    };\n    add(BorderLayout.CENTER, mySplitter);\n\n    if (configurable == null) {\n      String id = myProperties.getValue(SELECTED_CONFIGURABLE);\n      configurable = new ConfigurableVisitor.ByID(id != null ? id : \"preferences.lookFeel\").find(groups);\n      if (configurable == null) {\n        configurable = ConfigurableVisitor.ALL.find(groups);\n      }\n    }\n    myFilter.update(filter, false, true);\n    myTreeView.select(configurable);\n    Disposer.register(this, myTreeView);\n  }","commit_id":"cf0df7032707d7935f65cf74be9b8116799ed054","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Closes this <tt>PlugIn<\/tt> and releases the resources it has retained\n     * during its execution. No more data will be accepted by this\n     * <tt>PlugIn<\/tt> afterwards. A closed <tt>PlugIn<\/tt> can be reinstated by\n     * calling <tt>open<\/tt> again.\n     */\n    public synchronized void close()\n    {\n        if (handle != 0)\n        {\n            try\n            {\n                /*\n                 * It may or may not be necessary to ensure that #removeNotify()\n                 * is delivered to the native counterpart of this JAWTRenderer.\n                 * Anyway, do so for the sake of completeness.\n                 */\n                if (JComponent.isLightweightComponent(component))\n                {\n                    Container parent = component.getParent();\n\n                    parent.remove(component);\n                }\n            }\n            finally\n            {\n                close(handle, component);\n                handle = 0;\n            }\n        }\n    }","id":32340,"modified_method":"/**\n     * Closes this <tt>PlugIn<\/tt> and releases the resources it has retained\n     * during its execution. No more data will be accepted by this\n     * <tt>PlugIn<\/tt> afterwards. A closed <tt>PlugIn<\/tt> can be reinstated by\n     * calling <tt>open<\/tt> again.\n     */\n    public synchronized void close()\n    {\n        if (handle != 0)\n        {\n            try\n            {\n                /*\n                 * It may or may not be necessary to ensure that #removeNotify()\n                 * is delivered to the native counterpart of this JAWTRenderer.\n                 * Anyway, do so for the sake of completeness.\n                 */\n                /*\n                 * Unfortunately, doing so in the synchronized block leads to a\n                 * deadlock.\n                 */\n//                if (JComponent.isLightweightComponent(component))\n//                {\n//                    Container parent = component.getParent();\n//\n//                    if (parent != null)\n//                        parent.remove(component);\n//                }\n            }\n            finally\n            {\n                close(handle, component);\n                handle = 0;\n            }\n        }\n    }","commit_id":"41b3a9ade6a57b3ce0856974dae62e94b944cfe2","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n        public void addNotify()\n        {\n            super.addNotify();\n\n            wantsPaint = true;\n\n            synchronized (JAWTRenderer.this)\n            {\n                if (handle != 0)\n                {\n                    SwingVideoComponentCanvas canvas = findCanvas();\n\n                    if (canvas == null)\n                    {\n                        JAWTRenderer.addNotifyLightweightComponent(\n                                handle, this,\n                                0);\n                    }\n                    else\n                    {\n                        long canvasHandle;\n\n                        synchronized (canvas.getHandleLock())\n                        {\n                            canvasHandle = canvas.getHandle();\n                            JAWTRenderer.addNotifyLightweightComponent(\n                                    handle, this,\n                                    canvasHandle);\n                        }\n                        if (canvasHandle != 0)\n                            this.canvas = canvas;\n                    }\n\n                    /*\n                     * Emulate a ComponentEvent so that, for example, the native\n                     * counterpart of this Component gets its bounds up to date.\n                     */\n                    processLightweightComponentEvent();\n                }\n            }\n\n            parent = getParent();\n            if (parent != null)\n                parent.addComponentListener(parentComponentListener);\n        }","id":32341,"modified_method":"@Override\n        public void addNotify()\n        {\n            Container parent = getParent();\n\n            if (parent == null)\n                return;\n\n            super.addNotify();\n\n            wantsPaint = true;\n\n            synchronized (JAWTRenderer.this)\n            {\n                if (handle != 0)\n                {\n                    SwingVideoComponentCanvas canvas = findCanvas();\n\n                    if (canvas == null)\n                    {\n                        JAWTRenderer.addNotifyLightweightComponent(\n                                handle, this,\n                                0);\n                    }\n                    else\n                    {\n                        long canvasHandle;\n\n                        synchronized (canvas.getHandleLock())\n                        {\n                            canvasHandle = canvas.getHandle();\n                            JAWTRenderer.addNotifyLightweightComponent(\n                                    handle, this,\n                                    canvasHandle);\n                        }\n                        if ((canvasHandle != 0) && (this.canvas != canvas))\n                        {\n                            this.canvas = canvas;\n                        }\n                    }\n\n                    /*\n                     * Emulate a ComponentEvent so that, for example, the native\n                     * counterpart of this Component gets its bounds up to date.\n                     */\n                    processLightweightComponentEvent();\n                }\n            }\n\n            parent.addComponentListener(parentComponentListener);\n        }","commit_id":"41b3a9ade6a57b3ce0856974dae62e94b944cfe2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Opens this <tt>PlugIn<\/tt> and acquires the resources that it needs to\n     * operate. The input format of this <tt>Renderer<\/tt> has to be set before\n     * <tt>open<\/tt> is called. Buffers should not be passed into this\n     * <tt>PlugIn<\/tt> without first calling <tt>open<\/tt>.\n     *\n     * @throws ResourceUnavailableException if there is a problem during opening\n     */\n    public synchronized void open()\n        throws ResourceUnavailableException\n    {\n        if (handle == 0)\n        {\n            /*\n             * If this JAWTRenderer gets opened after its visual/video Component\n             * has been created, send addNotify to the Component once this\n             * JAWTRenderer gets opened so that the Component may use the handle\n             * if it needs to.\n             */\n            boolean addNotify\n                = (this.component != null)\n                    && (this.component.getParent() != null);\n\n            handle = open(getComponent());\n            if (handle == 0)\n            {\n                throw new ResourceUnavailableException(\n                        \"Failed to open the native counterpart of JAWTRenderer\");\n            }\n\n            if (addNotify)\n                this.component.addNotify();\n        }\n    }","id":32342,"modified_method":"/**\n     * Opens this <tt>PlugIn<\/tt> and acquires the resources that it needs to\n     * operate. The input format of this <tt>Renderer<\/tt> has to be set before\n     * <tt>open<\/tt> is called. Buffers should not be passed into this\n     * <tt>PlugIn<\/tt> without first calling <tt>open<\/tt>.\n     *\n     * @throws ResourceUnavailableException if there is a problem during opening\n     */\n    public void open()\n        throws ResourceUnavailableException\n    {\n        boolean addNotify;\n        final Component component;\n\n        synchronized (this)\n        {\n            if (handle == 0)\n            {\n                /*\n                 * If this JAWTRenderer gets opened after its visual/video\n                 * Component has been created, send addNotify to the Component\n                 * once this JAWTRenderer gets opened so that the Component may\n                 * use the handle if it needs to.\n                 */\n                addNotify\n                    = (this.component != null)\n                        && (this.component.getParent() != null);\n                component = getComponent();\n\n                handle = open(component);\n                if (handle == 0)\n                {\n                    throw new ResourceUnavailableException(\n                            \"Failed to open the native counterpart of JAWTRenderer\");\n                }\n            }\n            else\n            {\n                addNotify = false;\n                component = null;\n            }\n        }\n        /*\n         * The #addNotify() invocation, if any, shoud happen outside the\n         * synchronized block in order to avoid a deadlock.\n         */\n        if (addNotify)\n        {\n            SwingUtilities.invokeLater(\n                    new Runnable()\n                    {\n                        public void run()\n                        {\n                            component.addNotify();\n                        }\n                    });\n        }\n    }","commit_id":"41b3a9ade6a57b3ce0856974dae62e94b944cfe2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows/hides the local video component.\n     *\n     * @param isVisible <tt>true<\/tt> to show the local video, <tt>false<\/tt> -\n     * otherwise\n     */\n    public void setLocalVideoVisible(boolean isVisible)\n    {\n        synchronized (videoContainers)\n        {\n            this.localVideoVisible = isVisible;\n\n            if (isVisible\n                != callRenderer.getCallContainer()\n                    .isShowHideVideoButtonSelected())\n            {\n                callRenderer.getCallContainer()\n                    .setShowHideVideoButtonSelected(isVisible);\n            }\n\n            int videoContainerCount;\n\n            if ((videoTelephony != null)\n                    && ((videoContainerCount = videoContainers.size()) > 0))\n            {\n                Container videoContainer\n                    = videoContainers.get(videoContainerCount - 1);\n\n                if (localVideo != null)\n                {\n                    if (isVisible)\n                    {\n                        Container parent = localVideo.getParent();\n\n                        if (parent != null)\n                        {\n                            parent.remove(parent);\n                            parent.remove(closeButton);\n                        }\n\n                        videoContainer.add(\n                            closeButton, VideoLayout.CLOSE_LOCAL_BUTTON, 0);\n                        videoContainer.add(localVideo, VideoLayout.LOCAL, 1);\n                    }\n                    else\n                    {\n                        if (localVideo != null)\n                        {\n                            videoContainer.remove(localVideo);\n                            videoContainer.remove(closeButton);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":32343,"modified_method":"/**\n     * Shows/hides the local video component.\n     *\n     * @param isVisible <tt>true<\/tt> to show the local video, <tt>false<\/tt> -\n     * otherwise\n     */\n    public void setLocalVideoVisible(boolean isVisible)\n    {\n        synchronized (videoContainers)\n        {\n            this.localVideoVisible = isVisible;\n\n            if (isVisible\n                != callRenderer.getCallContainer()\n                    .isShowHideVideoButtonSelected())\n            {\n                callRenderer.getCallContainer()\n                    .setShowHideVideoButtonSelected(isVisible);\n            }\n\n            int videoContainerCount;\n\n            if ((videoTelephony != null)\n                    && ((videoContainerCount = videoContainers.size()) > 0))\n            {\n                Container videoContainer\n                    = videoContainers.get(videoContainerCount - 1);\n\n                if (localVideo != null)\n                {\n                    if (isVisible)\n                    {\n                        if (OSUtils.IS_MAC\n                                && (localVideo instanceof JComponent))\n                        {\n                            /*\n                             * There are overlapping issues on Mac OS X so we'd\n                             * better take the safest route.\n                             */\n                            handleVideoEvent(null, videoContainer);\n                        }\n                        else\n                        {\n                            Container localVideoParent = localVideo.getParent();\n\n                            if (localVideoParent != null)\n                                localVideoParent.remove(localVideo);\n\n                            Container closeButtonParent\n                                = closeButton.getParent();\n\n                            if (closeButtonParent != null)\n                                closeButtonParent.remove(closeButton);\n\n                            videoContainer.add(localVideo, VideoLayout.LOCAL);\n                            videoContainer.add(\n                                    closeButton,\n                                    VideoLayout.CLOSE_LOCAL_BUTTON);\n                        }\n                    }\n                    else\n                    {\n                        videoContainer.remove(localVideo);\n                        videoContainer.remove(closeButton);\n                    }\n                }\n            }\n        }\n    }","commit_id":"41b3a9ade6a57b3ce0856974dae62e94b944cfe2","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Nullable\n  public Icon getIcon(int flags) {\n    if (isScript()) {\n      return GroovyScriptType.getScriptType(this).getScriptIcon();\n    }\n    return GroovyIcons.GROOVY_ICON_16x16;\n  }","id":32344,"modified_method":"@Nullable\n  public Icon getIcon(int flags) {\n    final Icon baseIcon = isScript() ? GroovyScriptType.getScriptType(this).getScriptIcon() : GroovyIcons.GROOVY_ICON_16x16;\n    return ElementBase.createLayeredIcon(baseIcon, ElementBase.transformFlags(this, flags));\n  }","commit_id":"3861eadf4ecc11a0d5554801005b455c42a9cb12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isScript() {\n    final StubElement stub = getStub();\n    if (stub instanceof GrFileStub) {\n      return ((GrFileStub)stub).isScript();\n    }\n\n    Boolean isScript = myScript;\n    if (isScript == null) {\n      isScript = Boolean.FALSE;\n      for (GrTopStatement st : findChildrenByClass(GrTopStatement.class)) {\n        if (!(st instanceof GrTypeDefinition || st instanceof GrImportStatement || st instanceof GrPackageDefinition)) {\n          isScript = Boolean.TRUE;\n          break;\n        }\n      }\n      myScript = isScript;\n    }\n\n    return isScript;\n  }","id":32345,"modified_method":"public boolean isScript() {\n    final StubElement stub = getStub();\n    if (stub instanceof GrFileStub) {\n      return ((GrFileStub)stub).isScript();\n    }\n\n    Boolean isScript = myScript;\n    if (isScript == null) {\n      final GrTopStatement[] topStatements = findChildrenByClass(GrTopStatement.class);\n      isScript = topStatements.length == 0;\n      for (GrTopStatement st : topStatements) {\n        if (!(st instanceof GrTypeDefinition || st instanceof GrImportStatement || st instanceof GrPackageDefinition)) {\n          isScript = Boolean.TRUE;\n          break;\n        }\n      }\n      myScript = isScript;\n    }\n\n    return isScript;\n  }","commit_id":"3861eadf4ecc11a0d5554801005b455c42a9cb12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public GroovyScriptClass getScriptClass() {\n    if (isScript()) {\n      if (myScriptClass == null) {\n        GroovyScriptClass candidate = new GroovyScriptClass(this);\n        synchronized (lock) {\n          if (myScriptClass == null) {\n            myScriptClass = candidate;\n          }\n        }\n      }\n      return myScriptClass;\n    }\n    else {\n      return null;\n    }\n  }","id":32346,"modified_method":"@Override\n  public GroovyScriptClass getScriptClass() {\n    if (!isScript()) {\n      return null;\n    }\n\n    GroovyScriptClass aClass = myScriptClass;\n    if (aClass == null) {\n      aClass = new GroovyScriptClass(this);\n      myScriptClass = aClass;\n    }\n\n    return aClass;\n  }","commit_id":"7ec418c63f5c07d2810e734a09fe89229cc9ce8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void subtreeChanged() {\n    synchronized (lock) {\n      myScript = null;\n    }\n    super.subtreeChanged();\n  }","id":32347,"modified_method":"@Override\n  public void subtreeChanged() {\n    myScript = null;\n    super.subtreeChanged();\n  }","commit_id":"7ec418c63f5c07d2810e734a09fe89229cc9ce8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GrParameter getSyntheticArgsParameter() {\n    if (mySyntheticArgsParameter == null) {\n      final PsiType psiType = JavaPsiFacade.getElementFactory(getProject()).createTypeFromText(\"java.lang.String[]\", this);\n      final GrParameter candidate = new GrLightParameter(SYNTHETIC_PARAMETER_NAME, psiType, this);\n      synchronized (lock) {\n        if (mySyntheticArgsParameter == null) {\n          mySyntheticArgsParameter = candidate;\n        }\n      }\n    }\n    return mySyntheticArgsParameter;\n  }","id":32348,"modified_method":"private GrParameter getSyntheticArgsParameter() {\n    GrParameter parameter = mySyntheticArgsParameter;\n    if (parameter == null) {\n      final PsiType psiType = JavaPsiFacade.getElementFactory(getProject()).createTypeFromText(\"java.lang.String[]\", this);\n      parameter = new GrLightParameter(SYNTHETIC_PARAMETER_NAME, psiType, this);\n      mySyntheticArgsParameter = parameter;\n    }\n    return parameter;\n  }","commit_id":"7ec418c63f5c07d2810e734a09fe89229cc9ce8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isScript() {\n    final StubElement stub = getStub();\n    if (stub instanceof GrFileStub) {\n      return ((GrFileStub)stub).isScript();\n    }\n\n    if (myScript == null) {\n      synchronized (lock) {\n        boolean isScript = checkIsScript();\n        if (myScript == null) {\n          myScript = isScript;\n        }\n      }\n    }\n    return myScript;\n  }","id":32349,"modified_method":"@Override\n  public boolean isScript() {\n    final StubElement stub = getStub();\n    if (stub instanceof GrFileStub) {\n      return ((GrFileStub)stub).isScript();\n    }\n\n    Boolean isScript = myScript;\n    if (isScript == null) {\n      isScript = checkIsScript();\n      myScript = isScript;\n    }\n    return isScript;\n  }","commit_id":"7ec418c63f5c07d2810e734a09fe89229cc9ce8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void clearCaches() {\n    super.clearCaches();\n    synchronized (lock) {\n      myScriptClass = null;\n      mySyntheticArgsParameter = null;\n    }\n  }","id":32350,"modified_method":"@Override\n  public void clearCaches() {\n    super.clearCaches();\n    myScriptClass = null;\n    mySyntheticArgsParameter = null;\n  }","commit_id":"7ec418c63f5c07d2810e734a09fe89229cc9ce8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setPackageName(String packageName) {\n    final ASTNode fileNode = getNode();\n    assert fileNode != null;\n    final GrPackageDefinition currentPackage = getPackageDefinition();\n    if (packageName == null || packageName.isEmpty()) {\n      if (currentPackage != null) {\n        final ASTNode currNode = currentPackage.getNode();\n        fileNode.removeChild(currNode);\n      }\n      return;\n    }\n\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(getProject());\n    final GrPackageDefinition newPackage = (GrPackageDefinition)factory.createTopElementFromText(\"package \" + packageName);\n\n    if (currentPackage != null) {\n      final GrCodeReferenceElement packageReference = currentPackage.getPackageReference();\n      if (packageReference != null) {\n        GrCodeReferenceElement ref = newPackage.getPackageReference();\n        if (ref != null) {\n          packageReference.replace(ref);\n        }\n        return;\n      }\n    }\n\n    final ASTNode newNode = newPackage.getNode();\n    if (currentPackage != null) {\n      final ASTNode currNode = currentPackage.getNode();\n      fileNode.replaceChild(currNode, newNode);\n    } else {\n      ASTNode anchor = fileNode.getFirstChildNode();\n      if (anchor != null && anchor.getElementType() == GroovyTokenTypes.mSH_COMMENT) {\n        anchor = anchor.getTreeNext();\n        fileNode.addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor);\n      }\n      fileNode.addChild(newNode, anchor);\n      if (anchor != null && !anchor.getText().startsWith(\"\\n\\n\")) {\n        fileNode.addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor);\n      }\n    }\n  }","id":32351,"modified_method":"@Override\n  public void setPackageName(String packageName) {\n    final ASTNode fileNode = getNode();\n    final GrPackageDefinition currentPackage = getPackageDefinition();\n    if (packageName == null || packageName.isEmpty()) {\n      if (currentPackage != null) {\n        final ASTNode currNode = currentPackage.getNode();\n        fileNode.removeChild(currNode);\n      }\n      return;\n    }\n\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(getProject());\n    final GrPackageDefinition newPackage = (GrPackageDefinition)factory.createTopElementFromText(\"package \" + packageName);\n\n    if (currentPackage != null) {\n      final GrCodeReferenceElement packageReference = currentPackage.getPackageReference();\n      if (packageReference != null) {\n        GrCodeReferenceElement ref = newPackage.getPackageReference();\n        if (ref != null) {\n          packageReference.replace(ref);\n        }\n        return;\n      }\n    }\n\n    final ASTNode newNode = newPackage.getNode();\n    if (currentPackage != null) {\n      final ASTNode currNode = currentPackage.getNode();\n      fileNode.replaceChild(currNode, newNode);\n    } else {\n      ASTNode anchor = fileNode.getFirstChildNode();\n      if (anchor != null && anchor.getElementType() == GroovyTokenTypes.mSH_COMMENT) {\n        anchor = anchor.getTreeNext();\n        fileNode.addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor);\n      }\n      fileNode.addChild(newNode, anchor);\n      if (anchor != null && !anchor.getText().startsWith(\"\\n\\n\")) {\n        fileNode.addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor);\n      }\n    }\n  }","commit_id":"7ec418c63f5c07d2810e734a09fe89229cc9ce8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public static List<Module> loadModuleScript(String moduleScriptFile, MessageCollector messageCollector) {\n        Disposable disposable = new Disposable() {\n            @Override\n            public void dispose() {\n\n            }\n        };\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        File defaultRuntimePath = CompilerPathUtil.getRuntimePath();\n        if (defaultRuntimePath != null) {\n            configuration.add(JVMConfigurationKeys.CLASSPATH_KEY, defaultRuntimePath);\n        }\n        configuration.add(JVMConfigurationKeys.CLASSPATH_KEY, PathUtil.findRtJar());\n        File jdkAnnotationsPath = CompilerPathUtil.getJdkAnnotationsPath();\n        if (jdkAnnotationsPath != null) {\n            configuration.add(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY, jdkAnnotationsPath);\n        }\n        configuration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, moduleScriptFile);\n        JetCoreEnvironment scriptEnvironment = JetCoreEnvironment.createCoreEnvironmentForJVM(disposable, configuration);\n\n        GenerationState generationState = KotlinToJVMBytecodeCompiler\n                .analyzeAndGenerate(new K2JVMCompileEnvironmentConfiguration(scriptEnvironment, messageCollector, false,\n                                                                             BuiltinsScopeExtensionMode.ALL, false,\n                                                                             BuiltinToJavaTypesMapping.ENABLED), false);\n        if (generationState == null) {\n            throw new CompileEnvironmentException(\"Module script \" + moduleScriptFile + \" analyze failed\");\n        }\n\n        List<Module> modules = runDefineModules(moduleScriptFile, generationState.getFactory());\n\n        Disposer.dispose(disposable);\n\n        if (modules == null) {\n            throw new CompileEnvironmentException(\"Module script \" + moduleScriptFile + \" compilation failed\");\n        }\n\n        if (modules.isEmpty()) {\n            throw new CompileEnvironmentException(\"No modules where defined by \" + moduleScriptFile);\n        }\n        return modules;\n    }","id":32352,"modified_method":"@NotNull\n    public static List<Module> loadModuleScript(String moduleScriptFile, MessageCollector messageCollector) {\n        Disposable disposable = new Disposable() {\n            @Override\n            public void dispose() {\n\n            }\n        };\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        File defaultRuntimePath = CompilerPathUtil.getRuntimePath();\n        if (defaultRuntimePath != null) {\n            configuration.add(JVMConfigurationKeys.CLASSPATH_KEY, defaultRuntimePath);\n        }\n        configuration.add(JVMConfigurationKeys.CLASSPATH_KEY, PathUtil.findRtJar());\n        File jdkAnnotationsPath = CompilerPathUtil.getJdkAnnotationsPath();\n        if (jdkAnnotationsPath != null) {\n            configuration.add(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY, jdkAnnotationsPath);\n        }\n        configuration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, moduleScriptFile);\n        JetCoreEnvironment scriptEnvironment = JetCoreEnvironment.createCoreEnvironmentForJVM(disposable, configuration);\n\n        GenerationState generationState = KotlinToJVMBytecodeCompiler\n                .analyzeAndGenerate(new K2JVMCompileEnvironmentConfiguration(scriptEnvironment, messageCollector, Collections.<AnalyzerScriptParameter>emptyList(),\n                                                                             BuiltinsScopeExtensionMode.ALL, false,\n                                                                             BuiltinToJavaTypesMapping.ENABLED), false);\n        if (generationState == null) {\n            throw new CompileEnvironmentException(\"Module script \" + moduleScriptFile + \" analyze failed\");\n        }\n\n        List<Module> modules = runDefineModules(moduleScriptFile, generationState.getFactory());\n\n        Disposer.dispose(disposable);\n\n        if (modules == null) {\n            throw new CompileEnvironmentException(\"Module script \" + moduleScriptFile + \" compilation failed\");\n        }\n\n        if (modules.isEmpty()) {\n            throw new CompileEnvironmentException(\"No modules where defined by \" + moduleScriptFile);\n        }\n        return modules;\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean isScript() {\n        return script;\n    }","id":32353,"modified_method":"public boolean isScript() {\n        return scriptParameters != null;\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * NOTE: It's very important to call dispose for every object of this class or there will be memory leaks.\n     *\n     * @see Disposer\n     */\n    public K2JVMCompileEnvironmentConfiguration(@NotNull JetCoreEnvironment environment, @NotNull MessageCollector messageCollector,\n            boolean script, BuiltinsScopeExtensionMode builtinsScopeExtensionMode, boolean stubs, BuiltinToJavaTypesMapping builtinToJavaTypesMapping) {\n        super(messageCollector);\n        this.environment = environment;\n        this.script = script;\n        this.builtinsScopeExtensionMode = builtinsScopeExtensionMode;\n        this.stubs = stubs;\n        this.builtinToJavaTypesMapping = builtinToJavaTypesMapping;\n    }","id":32354,"modified_method":"/**\n     * NOTE: It's very important to call dispose for every object of this class or there will be memory leaks.\n     *\n     * @see Disposer\n     */\n    public K2JVMCompileEnvironmentConfiguration(@NotNull JetCoreEnvironment environment, @NotNull MessageCollector messageCollector,\n            List<AnalyzerScriptParameter> scriptParameters, BuiltinsScopeExtensionMode builtinsScopeExtensionMode, boolean stubs, BuiltinToJavaTypesMapping builtinToJavaTypesMapping) {\n        super(messageCollector);\n        this.environment = environment;\n        this.scriptParameters = scriptParameters;\n        this.builtinsScopeExtensionMode = builtinsScopeExtensionMode;\n        this.stubs = stubs;\n        this.builtinToJavaTypesMapping = builtinToJavaTypesMapping;\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @NotNull\n    protected ExitCode doExecute(K2JVMCompilerArguments arguments, PrintingMessageCollector messageCollector, Disposable rootDisposable) {\n        CompilerConfiguration compilerConfiguration = createCompilerConfiguration(arguments);\n\n        final List<String> argumentsSourceDirs = arguments.getSourceDirs();\n        if (!arguments.script &&\n            arguments.module == null &&\n            arguments.src == null &&\n            arguments.freeArgs.isEmpty() &&\n            (argumentsSourceDirs == null || argumentsSourceDirs.size() == 0)) {\n\n            ReplFromTerminal.run(rootDisposable, compilerConfiguration);\n            return ExitCode.OK;\n        }\n        else if (arguments.module != null) {\n            // TODO add sources from modules\n        }\n        else if (arguments.script) {\n            compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, arguments.freeArgs.get(0));\n        }\n        else {\n            // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n            if (arguments.getSourceDirs() != null) {\n                for (String source : arguments.getSourceDirs()) {\n                    compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, source);\n                }\n            }\n            else {\n                if (arguments.src != null) {\n                    compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, arguments.src);\n                }\n                for (String freeArg : arguments.freeArgs) {\n                    compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, freeArg);\n                }\n            }\n        }\n\n        JetCoreEnvironment environment = JetCoreEnvironment.createCoreEnvironmentForJVM(rootDisposable, compilerConfiguration);\n        boolean builtins = arguments.builtins;\n        K2JVMCompileEnvironmentConfiguration configuration = new K2JVMCompileEnvironmentConfiguration(\n                environment, messageCollector, arguments.script,\n                builtins ? BuiltinsScopeExtensionMode.ONLY_STANDARD_CLASSES : BuiltinsScopeExtensionMode.ALL,\n                builtins,\n                builtins ? BuiltinToJavaTypesMapping.DISABLED : BuiltinToJavaTypesMapping.ENABLED);\n\n        messageCollector.report(CompilerMessageSeverity.LOGGING, \"Configuring the compilation environment\",\n                                CompilerMessageLocation.NO_LOCATION);\n        try {\n            configureEnvironment(configuration, arguments);\n\n            File jar = arguments.jar != null ? new File(arguments.jar) : null;\n            File outputDir = arguments.outputDir != null ? new File(arguments.outputDir) : null;\n\n            boolean noErrors;\n            if (arguments.module != null) {\n                boolean oldVerbose = messageCollector.isVerbose();\n                messageCollector.setVerbose(false);\n                List<Module> modules = CompileEnvironmentUtil.loadModuleScript(arguments.module, messageCollector);\n                messageCollector.setVerbose(oldVerbose);\n                File directory = new File(arguments.module).getParentFile();\n                noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,\n                                                                      directory, jar, outputDir,\n                                                                      arguments.includeRuntime);\n            }\n            else if (arguments.script) {\n                List<String> scriptArgs = arguments.freeArgs.subList(1, arguments.freeArgs.size());\n                noErrors = KotlinToJVMBytecodeCompiler.compileAndExecuteScript(configuration, scriptArgs);\n            }\n            else {\n                noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration, jar, outputDir, arguments.includeRuntime);\n            }\n            return noErrors ? OK : COMPILATION_ERROR;\n        }\n        catch (CompilationException e) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),\n                                    MessageUtil.psiElementToMessageLocation(e.getElement()));\n            return INTERNAL_ERROR;\n        }\n        catch (Throwable t) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t),\n                                    CompilerMessageLocation.NO_LOCATION);\n            return INTERNAL_ERROR;\n        }\n    }","id":32355,"modified_method":"@Override\n    @NotNull\n    protected ExitCode doExecute(K2JVMCompilerArguments arguments, PrintingMessageCollector messageCollector, Disposable rootDisposable) {\n        CompilerConfiguration compilerConfiguration = createCompilerConfiguration(arguments);\n\n        final List<String> argumentsSourceDirs = arguments.getSourceDirs();\n        if (!arguments.script &&\n            arguments.module == null &&\n            arguments.src == null &&\n            arguments.freeArgs.isEmpty() &&\n            (argumentsSourceDirs == null || argumentsSourceDirs.size() == 0)) {\n\n            ReplFromTerminal.run(rootDisposable, compilerConfiguration);\n            return ExitCode.OK;\n        }\n        else if (arguments.module != null) {\n            // TODO add sources from modules\n        }\n        else if (arguments.script) {\n            compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, arguments.freeArgs.get(0));\n        }\n        else {\n            // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n            if (arguments.getSourceDirs() != null) {\n                for (String source : arguments.getSourceDirs()) {\n                    compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, source);\n                }\n            }\n            else {\n                if (arguments.src != null) {\n                    compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, arguments.src);\n                }\n                for (String freeArg : arguments.freeArgs) {\n                    compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, freeArg);\n                }\n            }\n        }\n\n        JetCoreEnvironment environment = JetCoreEnvironment.createCoreEnvironmentForJVM(rootDisposable, compilerConfiguration);\n        boolean builtins = arguments.builtins;\n        K2JVMCompileEnvironmentConfiguration configuration = new K2JVMCompileEnvironmentConfiguration(\n                environment, messageCollector, arguments.script ? CommandLineScriptUtils.scriptParameters() : Collections.<AnalyzerScriptParameter>emptyList(),\n                builtins ? BuiltinsScopeExtensionMode.ONLY_STANDARD_CLASSES : BuiltinsScopeExtensionMode.ALL,\n                builtins,\n                builtins ? BuiltinToJavaTypesMapping.DISABLED : BuiltinToJavaTypesMapping.ENABLED);\n\n        messageCollector.report(CompilerMessageSeverity.LOGGING, \"Configuring the compilation environment\",\n                                CompilerMessageLocation.NO_LOCATION);\n        try {\n            configureEnvironment(configuration, arguments);\n\n            File jar = arguments.jar != null ? new File(arguments.jar) : null;\n            File outputDir = arguments.outputDir != null ? new File(arguments.outputDir) : null;\n\n            boolean noErrors;\n            if (arguments.module != null) {\n                boolean oldVerbose = messageCollector.isVerbose();\n                messageCollector.setVerbose(false);\n                List<Module> modules = CompileEnvironmentUtil.loadModuleScript(arguments.module, messageCollector);\n                messageCollector.setVerbose(oldVerbose);\n                File directory = new File(arguments.module).getParentFile();\n                noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,\n                                                                      directory, jar, outputDir,\n                                                                      arguments.includeRuntime);\n            }\n            else if (arguments.script) {\n                List<String> scriptArgs = arguments.freeArgs.subList(1, arguments.freeArgs.size());\n                noErrors = KotlinToJVMBytecodeCompiler.compileAndExecuteScript(configuration, scriptArgs);\n            }\n            else {\n                noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration, jar, outputDir, arguments.includeRuntime);\n            }\n            return noErrors ? OK : COMPILATION_ERROR;\n        }\n        catch (CompilationException e) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),\n                                    MessageUtil.psiElementToMessageLocation(e.getElement()));\n            return INTERNAL_ERROR;\n        }\n        catch (Throwable t) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t),\n                                    CompilerMessageLocation.NO_LOCATION);\n            return INTERNAL_ERROR;\n        }\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static GenerationState analyzeAndGenerate(K2JVMCompileEnvironmentConfiguration configuration) {\n        return analyzeAndGenerate(configuration, configuration.isStubs());\n    }","id":32356,"modified_method":"@Nullable\n    public static GenerationState analyzeAndGenerate(K2JVMCompileEnvironmentConfiguration configuration) {\n        return analyzeAndGenerate(configuration, configuration.isStubs(), configuration.getScript());\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static GenerationState generate(\n            final K2JVMCompileEnvironmentConfiguration configuration,\n            AnalyzeExhaust exhaust,\n            boolean stubs) {\n        JetCoreEnvironment environment = configuration.getEnvironment();\n        Project project = environment.getProject();\n        Progress backendProgress = new Progress() {\n            @Override\n            public void log(String message) {\n                configuration.getMessageCollector().report(CompilerMessageSeverity.LOGGING, message, CompilerMessageLocation.NO_LOCATION);\n            }\n        };\n        GenerationState generationState = new GenerationState(project, ClassBuilderFactories.binaries(stubs), backendProgress,\n                                                              exhaust, environment.getSourceFiles(),\n                                                              configuration.getBuiltinToJavaTypesMapping());\n        generationState.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);\n\n        List<CompilerPlugin> plugins = configuration.getCompilerPlugins();\n        if (plugins != null) {\n            CompilerPluginContext context = new CompilerPluginContext(project, exhaust.getBindingContext(), environment.getSourceFiles());\n            for (CompilerPlugin plugin : plugins) {\n                plugin.processFiles(context);\n            }\n        }\n        return generationState;\n    }","id":32357,"modified_method":"@NotNull\n    private static GenerationState generate(\n            final K2JVMCompileEnvironmentConfiguration configuration,\n            AnalyzeExhaust exhaust,\n            boolean stubs) {\n        JetCoreEnvironment environment = configuration.getEnvironment();\n        Project project = environment.getProject();\n        Progress backendProgress = new Progress() {\n            @Override\n            public void log(String message) {\n                configuration.getMessageCollector().report(CompilerMessageSeverity.LOGGING, message, CompilerMessageLocation.NO_LOCATION);\n            }\n        };\n        GenerationState generationState = new GenerationState(project, ClassBuilderFactories.binaries(stubs), backendProgress,\n                                                              exhaust, environment.getSourceFiles(),\n                                                              configuration.getBuiltinToJavaTypesMapping());\n        generationState.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);\n\n        List<CompilerPlugin> plugins = configuration.getCompilerPlugins();\n        CompilerPluginContext context = new CompilerPluginContext(project, exhaust.getBindingContext(), environment.getSourceFiles());\n        for (CompilerPlugin plugin : plugins) {\n            plugin.processFiles(context);\n        }\n        return generationState;\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static GenerationState analyzeAndGenerate(\n            K2JVMCompileEnvironmentConfiguration configuration,\n            boolean stubs\n    ) {\n        AnalyzeExhaust exhaust = analyze(configuration, configuration.isScript(), stubs);\n\n        if (exhaust == null) {\n            return null;\n        }\n\n        exhaust.throwIfError();\n\n        return generate(configuration, exhaust, stubs);\n    }","id":32358,"modified_method":"@Nullable\n    public static GenerationState analyzeAndGenerate(\n            K2JVMCompileEnvironmentConfiguration configuration,\n            boolean stubs\n    ) {\n        return analyzeAndGenerate(configuration, stubs, configuration.isScript()\n                                                        ? CommandLineScriptUtils.scriptParameters()\n                                                        : Collections.<AnalyzerScriptParameter>emptyList());\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static ClassFileFactory compileModule(\n            K2JVMCompileEnvironmentConfiguration configuration,\n            Module moduleBuilder,\n            File directory\n    ) {\n        if (moduleBuilder.getSourceFiles().isEmpty()) {\n            throw new CompileEnvironmentException(\"No source files where defined\");\n        }\n\n        // TODO creating environment copy each time - not good. original environment shouldn't be passed at all\n        CompilerConfiguration compilerConfiguration = configuration.getEnvironment().getConfiguration().copy();\n        for (String sourceFile : moduleBuilder.getSourceFiles()) {\n            File source = new File(sourceFile);\n            if (!source.isAbsolute()) {\n                source = new File(directory, sourceFile);\n            }\n\n            if (!source.exists()) {\n                throw new CompileEnvironmentException(\"'\" + source + \"' does not exist\");\n            }\n\n            compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, source.getPath());\n        }\n\n        for (String classpathRoot : moduleBuilder.getClasspathRoots()) {\n            compilerConfiguration.add(JVMConfigurationKeys.CLASSPATH_KEY, new File(classpathRoot));\n        }\n\n        for (String annotationsRoot : moduleBuilder.getAnnotationsRoots()) {\n            compilerConfiguration.add(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY, new File(annotationsRoot));\n        }\n\n        Disposable parentDisposable = new Disposable() {\n            @Override\n            public void dispose() {\n            }\n        };\n        JetCoreEnvironment environment = null;\n        try {\n            environment = JetCoreEnvironment.createCoreEnvironmentForJVM(parentDisposable,\n                                                                         compilerConfiguration);\n\n\n            K2JVMCompileEnvironmentConfiguration currentK2JVMConfiguration = new K2JVMCompileEnvironmentConfiguration(\n                    environment, configuration.getMessageCollector(), configuration.isScript(),\n                    configuration.getBuiltinsScopeExtensionMode(), configuration.isStubs(),\n                    configuration.getBuiltinToJavaTypesMapping());\n            GenerationState generationState = analyzeAndGenerate(currentK2JVMConfiguration);\n            if (generationState == null) {\n                return null;\n            }\n            return generationState.getFactory();\n        } finally {\n            if (environment != null) {\n                Disposer.dispose(parentDisposable);\n            }\n        }\n    }","id":32359,"modified_method":"@Nullable\n    public static ClassFileFactory compileModule(\n            K2JVMCompileEnvironmentConfiguration configuration,\n            Module moduleBuilder,\n            File directory\n    ) {\n        if (moduleBuilder.getSourceFiles().isEmpty()) {\n            throw new CompileEnvironmentException(\"No source files where defined\");\n        }\n\n        // TODO creating environment copy each time - not good. original environment shouldn't be passed at all\n        CompilerConfiguration compilerConfiguration = configuration.getEnvironment().getConfiguration().copy();\n        for (String sourceFile : moduleBuilder.getSourceFiles()) {\n            File source = new File(sourceFile);\n            if (!source.isAbsolute()) {\n                source = new File(directory, sourceFile);\n            }\n\n            if (!source.exists()) {\n                throw new CompileEnvironmentException(\"'\" + source + \"' does not exist\");\n            }\n\n            compilerConfiguration.add(CommonConfigurationKeys.SOURCE_ROOTS_KEY, source.getPath());\n        }\n\n        for (String classpathRoot : moduleBuilder.getClasspathRoots()) {\n            compilerConfiguration.add(JVMConfigurationKeys.CLASSPATH_KEY, new File(classpathRoot));\n        }\n\n        for (String annotationsRoot : moduleBuilder.getAnnotationsRoots()) {\n            compilerConfiguration.add(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY, new File(annotationsRoot));\n        }\n\n        Disposable parentDisposable = new Disposable() {\n            @Override\n            public void dispose() {\n            }\n        };\n        JetCoreEnvironment environment = null;\n        try {\n            environment = JetCoreEnvironment.createCoreEnvironmentForJVM(parentDisposable,\n                                                                         compilerConfiguration);\n\n\n            K2JVMCompileEnvironmentConfiguration currentK2JVMConfiguration = new K2JVMCompileEnvironmentConfiguration(\n                    environment, configuration.getMessageCollector(), Collections.<AnalyzerScriptParameter>emptyList(),\n                    configuration.getBuiltinsScopeExtensionMode(), configuration.isStubs(),\n                    configuration.getBuiltinToJavaTypesMapping());\n            GenerationState generationState = analyzeAndGenerate(currentK2JVMConfiguration);\n            if (generationState == null) {\n                return null;\n            }\n            return generationState.getFactory();\n        } finally {\n            if (environment != null) {\n                Disposer.dispose(parentDisposable);\n            }\n        }\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean compileAndExecuteScript(\n            @NotNull K2JVMCompileEnvironmentConfiguration configuration,\n            @NotNull List<String> scriptArgs) {\n\n        GenerationState generationState = analyzeAndGenerate(configuration);\n        if (generationState == null) {\n            return false;\n        }\n\n        try {\n            ClassFileFactory factory = generationState.getFactory();\n            try {\n                GeneratedClassLoader classLoader = new GeneratedClassLoader(factory, new URLClassLoader(new URL[]{\n                        // TODO: add all classpath\n                        CompilerPathUtil.getRuntimePath().toURI().toURL()\n                },\n                        AllModules.class.getClassLoader()));\n                Class<?> scriptClass = classLoader.loadClass(ScriptCodegen.SCRIPT_DEFAULT_CLASS_NAME.getFqName().getFqName());\n                scriptClass.getConstructor(String[].class).newInstance(new Object[]{scriptArgs.toArray(new String[0])});\n            }\n            catch (Exception e) {\n                throw new RuntimeException(\"Failed to evaluate script: \" + e, e);\n            }\n            return true;\n        }\n        finally {\n            generationState.destroy();\n        }\n    }","id":32360,"modified_method":"public static boolean compileAndExecuteScript(\n            @NotNull K2JVMCompileEnvironmentConfiguration configuration,\n            @NotNull List<String> scriptArgs) {\n        Class<?> scriptClass = compileScript(configuration, null);\n        if(scriptClass == null)\n            return false;\n\n        try {\n            scriptClass.getConstructor(String[].class).newInstance(new Object[]{scriptArgs.toArray(new String[0])});\n        }\n        catch (RuntimeException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            throw new RuntimeException(\"Failed to evaluate script: \" + e, e);\n        }\n        return true;\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private static AnalyzeExhaust analyze(\n            final K2JVMCompileEnvironmentConfiguration configuration,\n            boolean script, boolean stubs) {\n        final JetCoreEnvironment environment = configuration.getEnvironment();\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = new AnalyzerWithCompilerReport(configuration.getMessageCollector());\n        final Predicate<PsiFile> filesToAnalyzeCompletely =\n                stubs ? Predicates.<PsiFile>alwaysFalse() : Predicates.<PsiFile>alwaysTrue();\n        final List<AnalyzerScriptParameter> scriptParameters =\n                script ? CommandLineScriptUtils.scriptParameters() : Collections.<AnalyzerScriptParameter>emptyList();\n        analyzerWithCompilerReport.analyzeAndReport(\n                new Function0<AnalyzeExhaust>() {\n                    @NotNull\n                    @Override\n                    public AnalyzeExhaust invoke() {\n                        return AnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(\n                                environment.getProject(),\n                                environment.getSourceFiles(),\n                                scriptParameters,\n                                filesToAnalyzeCompletely,\n                                configuration.getBuiltinsScopeExtensionMode());\n                    }\n                }, environment.getSourceFiles()\n        );\n\n        return analyzerWithCompilerReport.hasErrors() ? null : analyzerWithCompilerReport.getAnalyzeExhaust();\n    }","id":32361,"modified_method":"@Nullable\n    private static AnalyzeExhaust analyze(\n            final K2JVMCompileEnvironmentConfiguration configuration,\n            final List<AnalyzerScriptParameter> scriptParameters,\n            boolean stubs) {\n        final JetCoreEnvironment environment = configuration.getEnvironment();\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = new AnalyzerWithCompilerReport(configuration.getMessageCollector());\n        final Predicate<PsiFile> filesToAnalyzeCompletely =\n                stubs ? Predicates.<PsiFile>alwaysFalse() : Predicates.<PsiFile>alwaysTrue();\n        analyzerWithCompilerReport.analyzeAndReport(\n                new Function0<AnalyzeExhaust>() {\n                    @NotNull\n                    @Override\n                    public AnalyzeExhaust invoke() {\n                        return AnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(\n                                environment.getProject(),\n                                environment.getSourceFiles(),\n                                scriptParameters,\n                                filesToAnalyzeCompletely,\n                                configuration.getBuiltinsScopeExtensionMode());\n                    }\n                }, environment.getSourceFiles()\n        );\n\n        return analyzerWithCompilerReport.hasErrors() ? null : analyzerWithCompilerReport.getAnalyzeExhaust();\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private TestSuite doBuildSuite() {\n        try {\n            GenerationState generationState = KotlinToJVMBytecodeCompiler\n                    .analyzeAndGenerate(new K2JVMCompileEnvironmentConfiguration(myEnvironment, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR,\n                                                                                 false, BuiltinsScopeExtensionMode.ALL, false,\n                                                                                 BuiltinToJavaTypesMapping.ENABLED), false);\n\n            if (generationState == null) {\n                throw new RuntimeException(\"There were compilation errors\");\n            }\n\n            ClassFileFactory classFileFactory = generationState.getFactory();\n\n            final GeneratedClassLoader loader = new GeneratedClassLoader(\n                    classFileFactory,\n                    new URLClassLoader(new URL[]{ForTestCompileRuntime.runtimeJarForTests().toURI().toURL(), junitJar.toURI().toURL()},\n                                       TestCase.class.getClassLoader()));\n\n            JetTypeMapper typeMapper = generationState.getInjector().getJetTypeMapper();\n            TestSuite suite = new TestSuite(\"stdlib_test\");\n            try {\n                for(JetFile jetFile : myEnvironment.getSourceFiles()) {\n                    for(JetDeclaration decl : jetFile.getDeclarations()) {\n                        if (decl instanceof JetClass) {\n                            JetClass jetClass = (JetClass) decl;\n\n                            ClassDescriptor descriptor = (ClassDescriptor) generationState.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, jetClass);\n                            Set<JetType> allSuperTypes = new THashSet<JetType>();\n                            DescriptorUtils.addSuperTypes(descriptor.getDefaultType(), allSuperTypes);\n\n                            for(JetType type : allSuperTypes) {\n                                String internalName = typeMapper.mapType(type, MapTypeMode.IMPL).getInternalName();\n                                if(internalName.equals(\"junit/framework/Test\")) {\n                                    String name = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n                                    System.out.println(name);\n                                    Class<TestCase> aClass = (Class<TestCase>) loader.loadClass(name.replace('/', '.'));\n                                    if ((aClass.getModifiers() & Modifier.ABSTRACT) == 0\n                                     && (aClass.getModifiers() & Modifier.PUBLIC) != 0) {\n                                        try {\n                                            Constructor<TestCase> constructor = aClass.getConstructor();\n                                            if (constructor != null && (constructor.getModifiers() & Modifier.PUBLIC) != 0) {\n                                                suite.addTestSuite(aClass);\n                                            }\n                                        }\n                                        //catch (final VerifyError e) {\n                                        //    suite.addTest(new TestCase(aClass.getName()) {\n                                        //        @Override\n                                        //        public int countTestCases() {\n                                        //            return 1;\n                                        //        }\n                                        //\n                                        //        @Override\n                                        //        public void run(TestResult result) {\n                                        //            result.addError(this, new RuntimeException(e));\n                                        //        }\n                                        //    });\n                                        //}\n                                        catch (NoSuchMethodException e) {\n                                        }\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            finally {\n                typeMapper = null;\n            }\n\n            return suite;\n        } catch (Exception e) {\n            throw ExceptionUtils.rethrow(e);\n        }\n    }","id":32362,"modified_method":"private TestSuite doBuildSuite() {\n        try {\n            GenerationState generationState = KotlinToJVMBytecodeCompiler\n                    .analyzeAndGenerate(new K2JVMCompileEnvironmentConfiguration(myEnvironment, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR,\n                                                                                 Collections.<AnalyzerScriptParameter>emptyList(), BuiltinsScopeExtensionMode.ALL, false,\n                                                                                 BuiltinToJavaTypesMapping.ENABLED), false);\n\n            if (generationState == null) {\n                throw new RuntimeException(\"There were compilation errors\");\n            }\n\n            ClassFileFactory classFileFactory = generationState.getFactory();\n\n            final GeneratedClassLoader loader = new GeneratedClassLoader(\n                    classFileFactory,\n                    new URLClassLoader(new URL[]{ForTestCompileRuntime.runtimeJarForTests().toURI().toURL(), junitJar.toURI().toURL()},\n                                       TestCase.class.getClassLoader()));\n\n            JetTypeMapper typeMapper = generationState.getInjector().getJetTypeMapper();\n            TestSuite suite = new TestSuite(\"stdlib_test\");\n            try {\n                for(JetFile jetFile : myEnvironment.getSourceFiles()) {\n                    for(JetDeclaration decl : jetFile.getDeclarations()) {\n                        if (decl instanceof JetClass) {\n                            JetClass jetClass = (JetClass) decl;\n\n                            ClassDescriptor descriptor = (ClassDescriptor) generationState.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, jetClass);\n                            Set<JetType> allSuperTypes = new THashSet<JetType>();\n                            DescriptorUtils.addSuperTypes(descriptor.getDefaultType(), allSuperTypes);\n\n                            for(JetType type : allSuperTypes) {\n                                String internalName = typeMapper.mapType(type, MapTypeMode.IMPL).getInternalName();\n                                if(internalName.equals(\"junit/framework/Test\")) {\n                                    String name = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n                                    System.out.println(name);\n                                    Class<TestCase> aClass = (Class<TestCase>) loader.loadClass(name.replace('/', '.'));\n                                    if ((aClass.getModifiers() & Modifier.ABSTRACT) == 0\n                                     && (aClass.getModifiers() & Modifier.PUBLIC) != 0) {\n                                        try {\n                                            Constructor<TestCase> constructor = aClass.getConstructor();\n                                            if (constructor != null && (constructor.getModifiers() & Modifier.PUBLIC) != 0) {\n                                                suite.addTestSuite(aClass);\n                                            }\n                                        }\n                                        //catch (final VerifyError e) {\n                                        //    suite.addTest(new TestCase(aClass.getName()) {\n                                        //        @Override\n                                        //        public int countTestCases() {\n                                        //            return 1;\n                                        //        }\n                                        //\n                                        //        @Override\n                                        //        public void run(TestResult result) {\n                                        //            result.addError(this, new RuntimeException(e));\n                                        //        }\n                                        //    });\n                                        //}\n                                        catch (NoSuchMethodException e) {\n                                        }\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            finally {\n                typeMapper = null;\n            }\n\n            return suite;\n        } catch (Exception e) {\n            throw ExceptionUtils.rethrow(e);\n        }\n    }","commit_id":"b8bfde3102323a01c2c47f1701347383a18b6f10","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\n    serverObjects prop = new serverObjects();\n    plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\n    int MAX_COUNT=10; //TODO: Changeable per Interface\n    String tagName=\"\";\n    int start=0;\n    \n    //defaultvalues\n    prop.put(\"mode\", 0);\n    prop.put(\"mode_edit\", 0);\n    prop.put(\"mode_title\", \"\");\n    prop.put(\"mode_description\", \"\");\n    prop.put(\"mode_url\", \"\");\n    prop.put(\"mode_tags\", \"\");\n    prop.put(\"mode_public\", 1); //1=is public\n    if(post != null){\n        if(post.containsKey(\"mode\")){\n            String mode=(String) post.get(\"mode\");\n            if(mode.equals(\"add\")){\n            \tprop.put(\"mode\", 1);\n            }else if(mode.equals(\"importxml\")){\n            \tprop.put(\"mode\", 2);\n            }\n        }\n        if(post.containsKey(\"add\")){ //add an Entry\n            String url=(String) post.get(\"url\");\n            String title=(String) post.get(\"title\");\n            String description=(String) post.get(\"description\");\n            String tagsString = (String)post.get(\"tags\");\n            if(tagsString.equals(\"\")){\n                tagsString=\"unsorted\"; //defaulttag\n            }\n            Vector tags=new Vector();\n            String[] tagsArray=tagsString.split(\",\");\n            for(int i=0;i<tagsArray.length; i++){\n                tags.add(tagsArray[i].trim());\n            }\n        \n            bookmarksDB.Bookmark bookmark = switchboard.bookmarksDB.createBookmark(url);\n            if(bookmark != null){\n                bookmark.setProperty(bookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n                bookmark.setProperty(bookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n                bookmark.setProperty(bookmarksDB.Bookmark.BOOKMARK_PUBLIC, (String) post.get(\"public\"));\n                bookmark.setTags(tags);\n                bookmark.setBookmarksTable();\n            }else{\n                //ERROR\n            }\n        }else if(post.containsKey(\"edit\")){\n            String urlHash=(String) post.get(\"edit\");\n            prop.put(\"mode\", 1);\n            if (urlHash.length() == 0) {\n                prop.put(\"mode_edit\", 0); // create mode\n                prop.put(\"mode_title\", (String) post.get(\"title\"));\n                prop.put(\"mode_description\", (String) post.get(\"description\"));\n                prop.put(\"mode_url\", (String) post.get(\"url\"));\n                prop.put(\"mode_tags\", (String) post.get(\"tags\"));\n                prop.put(\"mode_public\", 0);\n            } else {\n                    bookmarksDB.Bookmark bookmark = switchboard.bookmarksDB.getBookmark(urlHash);\n                    if (bookmark == null) {\n                        // try to get the bookmark from the LURL database\n                        try {\n                            plasmaCrawlLURL.Entry urlentry = switchboard.urlPool.loadedURL.getEntry(urlHash, null);\n                            prop.put(\"mode_edit\", 0); // create mode\n                            prop.put(\"mode_title\", urlentry.descr());\n                            prop.put(\"mode_description\", urlentry.descr());\n                            prop.put(\"mode_url\", urlentry.url());\n                            prop.put(\"mode_tags\", \"\");\n                            prop.put(\"mode_public\", 0);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                        // get from the bookmark database\n                        prop.put(\"mode_edit\", 1); // edit mode\n                        prop.put(\"mode_title\", bookmark.getTitle());\n                        prop.put(\"mode_description\", bookmark.getDescription());\n                        prop.put(\"mode_url\", bookmark.getUrl());\n                        prop.put(\"mode_tags\", bookmark.getTags());\n                        if (bookmark.getPublic()) {\n                            prop.put(\"mode_public\", 1);\n                        } else {\n                            prop.put(\"mode_public\", 0);\n                        }\n                    }\n                }\n        }\n        if(post.containsKey(\"xmlfile\")){\n        \tswitchboard.bookmarksDB.importFromXML(new String((byte[])post.get(\"xmlfile$file\")));\n        }\n\n        if(post.containsKey(\"delete\")){\n            String urlHash=(String) post.get(\"delete\");\n            switchboard.bookmarksDB.removeBookmark(urlHash);\n        }\n        if(post.containsKey(\"tag\")){\n            tagName=(String) post.get(\"tag\");\n        }\n        if(post.containsKey(\"start\")){\n            start=Integer.parseInt((String) post.get(\"start\"));\n        }\n    }\n    Iterator it=switchboard.bookmarksDB.getTagIterator(true);\n    int count=0;\n    bookmarksDB.Tag tag;\n    while(it.hasNext()){\n        tag=(Tag) it.next();\n        prop.put(\"taglist_\"+count+\"_name\", tag.getFriendlyName());\n        prop.put(\"taglist_\"+count+\"_tag\", tag.getTagName());\n        count++;\n    }\n    prop.put(\"taglist\", count);\n    count=0;\n    if(!tagName.equals(\"\")){\n        it=switchboard.bookmarksDB.getBookmarksIterator(tagName, true);\n    }else{\n        it=switchboard.bookmarksDB.getBookmarksIterator(true);\n    }\n    bookmarksDB.Bookmark bookmark;\n    //skip the first entries (display next page)\n    count=0;\n    while(count < start && it.hasNext()){\n        it.next();\n        count++;\n    }\n    count=0;\n    Vector tags;\n    Iterator tagsIt;\n    int tagCount;\n    while(count<MAX_COUNT && it.hasNext()){\n        bookmark=switchboard.bookmarksDB.getBookmark((String)it.next());\n        if(bookmark!=null){\n            prop.put(\"bookmarks_\"+count+\"_link\", bookmark.getUrl());\n            prop.put(\"bookmarks_\"+count+\"_title\", bookmark.getTitle());\n            prop.put(\"bookmarks_\"+count+\"_description\", bookmark.getDescription());\n            prop.put(\"bookmarks_\"+count+\"_public\", (bookmark.getPublic()? 1:0));\n            \n            //List Tags.\n            tags=bookmark.getTagsVector();\n            tagsIt=tags.iterator();\n            tagCount=0;\n            while(tagsIt.hasNext()){\n            \tprop.put(\"bookmarks_\"+count+\"_tags_\"+tagCount+\"_tag\", tagsIt.next());\n            \ttagCount++;\n            }\n            prop.put(\"bookmarks_\"+count+\"_tags\", tagCount);\n            \n            prop.put(\"bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n            count++;\n        }\n    }\n    if(it.hasNext()){\n        prop.put(\"next-page\", 1);\n        prop.put(\"next-page_start\", start+10);\n        prop.put(\"next-page_tag\", tagName);\n    }\n    prop.put(\"bookmarks\", count);\n    return prop;\n    }","id":32363,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\n    serverObjects prop = new serverObjects();\n    plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\n    int MAX_COUNT=10; //TODO: Changeable per Interface\n    String tagName=\"\";\n    int start=0;\n    \n    //defaultvalues\n    prop.put(\"mode\", 0);\n    prop.put(\"mode_edit\", 0);\n    prop.put(\"mode_title\", \"\");\n    prop.put(\"mode_description\", \"\");\n    prop.put(\"mode_url\", \"\");\n    prop.put(\"mode_tags\", \"\");\n    prop.put(\"mode_public\", 1); //1=is public\n    if(post != null){\n        if(post.containsKey(\"mode\")){\n            String mode=(String) post.get(\"mode\");\n            if(mode.equals(\"add\")){\n            \tprop.put(\"mode\", 1);\n            }else if(mode.equals(\"importxml\")){\n            \tprop.put(\"mode\", 2);\n            }\n        }\n        if(post.containsKey(\"add\")){ //add an Entry\n            String url=(String) post.get(\"url\");\n            String title=(String) post.get(\"title\");\n            String description=(String) post.get(\"description\");\n            String tagsString = (String)post.get(\"tags\");\n            if(tagsString.equals(\"\")){\n                tagsString=\"unsorted\"; //defaulttag\n            }\n            Vector tags=new Vector();\n            String[] tagsArray=tagsString.split(\",\");\n            for(int i=0;i<tagsArray.length; i++){\n                tags.add(tagsArray[i].trim());\n            }\n        \n            bookmarksDB.Bookmark bookmark = switchboard.bookmarksDB.createBookmark(url);\n            if(bookmark != null){\n                bookmark.setProperty(bookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n                bookmark.setProperty(bookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n                if(((String) post.get(\"public\")).equals(\"public\")){\n                \tbookmark.setPublic(true);\n                }else{\n                \tbookmark.setPublic(false);\n                }\n                bookmark.setTags(tags);\n                bookmark.setBookmarksTable();\n            }else{\n                //ERROR\n            }\n        }else if(post.containsKey(\"edit\")){\n            String urlHash=(String) post.get(\"edit\");\n            prop.put(\"mode\", 1);\n            if (urlHash.length() == 0) {\n                prop.put(\"mode_edit\", 0); // create mode\n                prop.put(\"mode_title\", (String) post.get(\"title\"));\n                prop.put(\"mode_description\", (String) post.get(\"description\"));\n                prop.put(\"mode_url\", (String) post.get(\"url\"));\n                prop.put(\"mode_tags\", (String) post.get(\"tags\"));\n                prop.put(\"mode_public\", 0);\n            } else {\n                    bookmarksDB.Bookmark bookmark = switchboard.bookmarksDB.getBookmark(urlHash);\n                    if (bookmark == null) {\n                        // try to get the bookmark from the LURL database\n                        try {\n                            plasmaCrawlLURL.Entry urlentry = switchboard.urlPool.loadedURL.getEntry(urlHash, null);\n                            prop.put(\"mode_edit\", 0); // create mode\n                            prop.put(\"mode_title\", urlentry.descr());\n                            prop.put(\"mode_description\", urlentry.descr());\n                            prop.put(\"mode_url\", urlentry.url());\n                            prop.put(\"mode_tags\", \"\");\n                            prop.put(\"mode_public\", 0);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                        // get from the bookmark database\n                        prop.put(\"mode_edit\", 1); // edit mode\n                        prop.put(\"mode_title\", bookmark.getTitle());\n                        prop.put(\"mode_description\", bookmark.getDescription());\n                        prop.put(\"mode_url\", bookmark.getUrl());\n                        prop.put(\"mode_tags\", bookmark.getTags());\n                        if (bookmark.getPublic()) {\n                            prop.put(\"mode_public\", 1);\n                        } else {\n                            prop.put(\"mode_public\", 0);\n                        }\n                    }\n                }\n        }else if(post.containsKey(\"xmlfile\")){\n        \tboolean isPublic=false;\n        \tif(((String) post.get(\"public\")).equals(\"public\")){\n            \tisPublic=true;\n            }\n        \tswitchboard.bookmarksDB.importFromXML(new String((byte[])post.get(\"xmlfile$file\")), isPublic);\n        }\n\n        if(post.containsKey(\"delete\")){\n            String urlHash=(String) post.get(\"delete\");\n            switchboard.bookmarksDB.removeBookmark(urlHash);\n        }\n        if(post.containsKey(\"tag\")){\n            tagName=(String) post.get(\"tag\");\n        }\n        if(post.containsKey(\"start\")){\n            start=Integer.parseInt((String) post.get(\"start\"));\n        }\n    }\n    Iterator it=switchboard.bookmarksDB.getTagIterator(true);\n    int count=0;\n    bookmarksDB.Tag tag;\n    while(it.hasNext()){\n        tag=(Tag) it.next();\n        prop.put(\"taglist_\"+count+\"_name\", tag.getFriendlyName());\n        prop.put(\"taglist_\"+count+\"_tag\", tag.getTagName());\n        count++;\n    }\n    prop.put(\"taglist\", count);\n    count=0;\n    if(!tagName.equals(\"\")){\n        it=switchboard.bookmarksDB.getBookmarksIterator(tagName, true);\n    }else{\n        it=switchboard.bookmarksDB.getBookmarksIterator(true);\n    }\n    bookmarksDB.Bookmark bookmark;\n    //skip the first entries (display next page)\n    count=0;\n    while(count < start && it.hasNext()){\n        it.next();\n        count++;\n    }\n    count=0;\n    Vector tags;\n    Iterator tagsIt;\n    int tagCount;\n    while(count<MAX_COUNT && it.hasNext()){\n        bookmark=switchboard.bookmarksDB.getBookmark((String)it.next());\n        if(bookmark!=null){\n            prop.put(\"bookmarks_\"+count+\"_link\", bookmark.getUrl());\n            prop.put(\"bookmarks_\"+count+\"_title\", bookmark.getTitle());\n            prop.put(\"bookmarks_\"+count+\"_description\", bookmark.getDescription());\n            prop.put(\"bookmarks_\"+count+\"_public\", (bookmark.getPublic()? 1:0));\n            \n            //List Tags.\n            tags=bookmark.getTagsVector();\n            tagsIt=tags.iterator();\n            tagCount=0;\n            while(tagsIt.hasNext()){\n            \tprop.put(\"bookmarks_\"+count+\"_tags_\"+tagCount+\"_tag\", tagsIt.next());\n            \ttagCount++;\n            }\n            prop.put(\"bookmarks_\"+count+\"_tags\", tagCount);\n            \n            prop.put(\"bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n            count++;\n        }\n    }\n    if(it.hasNext()){\n        prop.put(\"next-page\", 1);\n        prop.put(\"next-page_start\", start+10);\n        prop.put(\"next-page_tag\", tagName);\n    }\n    prop.put(\"bookmarks\", count);\n    return prop;\n    }","commit_id":"fb5c387368161dbbcf9012ac2b4592e710cf6428","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void importFromXML(String input){\n\n\t\tSAXParser parser;\n\t\ttry {\n\t\t\tByteArrayInputStream is=new ByteArrayInputStream(input.getBytes());\n\t\t\tparser = SAXParserFactory.newInstance().newSAXParser();\n\t\t\txmlImportHandler handler=new xmlImportHandler();\n\t\t\tparser.parse(is, handler);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (SAXException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }","id":32364,"modified_method":"public void importFromXML(String input, boolean isPublic){\n\n\t\tSAXParser parser;\n\t\ttry {\n\t\t\tByteArrayInputStream is=new ByteArrayInputStream(input.getBytes());\n\t\t\tparser = SAXParserFactory.newInstance().newSAXParser();\n\t\t\txmlImportHandler handler=new xmlImportHandler(isPublic);\n\t\t\tparser.parse(is, handler);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (SAXException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    }","commit_id":"fb5c387368161dbbcf9012ac2b4592e710cf6428","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void setBookmarksTable(){\n            try {\n                bookmarksDB.this.bookmarksTable.set(getUrlHash(), mem);\n            } catch (IOException e) {}\n        }","id":32365,"modified_method":"public void setBookmarksTable(){\n            try {\n            \tbookmarksDB.this.bookmarksTable.set(urlHash, mem);\n            } catch (IOException e) {}\n        }","commit_id":"fb5c387368161dbbcf9012ac2b4592e710cf6428","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void startElement(String uri, String localName, String qName, Attributes attributes) {\n\t\t\tSystem.out.println(qName);\n\t\t\tif (qName.equals(\"post\")) {\n\t\t\t\tBookmark bm = new Bookmark(attributes.getValue(\"href\"));\n\t\t\t\tVector tags = listManager.string2vector(attributes.getValue(\"tag\").replace(' ', ','));\n\t\t\t\tbm.setTags(tags);\n\t\t\t\tbm.setTimeStamp(iso8601ToDate(attributes.getValue(\"time\")).getTime());\n\t\t\t\tbm.setProperty(Bookmark.BOOKMARK_TITLE, attributes.getValue(\"description\"));\n\t\t\t\tbm.setProperty(Bookmark.BOOKMARK_DESCRIPTION, attributes.getValue(\"extended\"));\n\t\t\t\tbm.setBookmarksTable();\n\t\t\t\tSystem.out.println(bm.getUrl());\n\t\t\t}\n\t\t}","id":32366,"modified_method":"public void startElement(String uri, String localName, String qName, Attributes attributes) {\n\t\t\tif (qName.equals(\"post\")) {\n\t\t\t\tString url=attributes.getValue(\"href\");\n\t\t\t\tif(url.equals(\"\")){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tBookmark bm = new Bookmark(url);\n\t\t\t\tString tagsString=attributes.getValue(\"tag\").replace(' ', ',');\n\t\t\t\tString title=attributes.getValue(\"description\");\n\t\t\t\tString description=attributes.getValue(\"extended\");\n\t\t\t\tString time=attributes.getValue(\"time\");\n\t\t\t\tVector tags=new Vector();\n\t\t\t\t\n\t\t\t\tif(title != null){\n\t\t\t\t\tbm.setProperty(Bookmark.BOOKMARK_TITLE, title);\n\t\t\t\t}\n\t\t\t\tif(tagsString!=null){\n\t\t\t\t\ttags = listManager.string2vector(tagsString);\n\t\t\t\t}\n\t\t\t\tbm.setTags(tags);\n\t\t\t\tif(time != null){\n\t\t\t\t\tbm.setTimeStamp(iso8601ToDate(time).getTime());\n\t\t\t\t}\n\t\t\t\tif(description!=null){\n\t\t\t\t\tbm.setProperty(Bookmark.BOOKMARK_DESCRIPTION, description);\n\t\t\t\t}\n\t\t\t\tbm.setPublic(importPublic);\n\t\t\t\tbm.setBookmarksTable();\n\t\t\t}\n\t\t}","commit_id":"fb5c387368161dbbcf9012ac2b4592e710cf6428","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private byte[] receive(Socket socket, int timeout) throws IOException\n    {\n        DataInputStream dis = new DataInputStream(socket.getInputStream());\n        if(timeout >= 0) {\n            socket.setSoTimeout(timeout);\n        }\n        ByteArrayOutputStream baos = new ByteArrayOutputStream(connector.getBufferSize());\n        byte[] buffer = new byte[connector.getBufferSize()];\n        int len = 0;\n        try\n        {\n            while ((len = dis.read(buffer, len, buffer.length)) != 0)\n            {\n                if (len == -1)\n                {\n                    logger.debug(\"The socket is closed\");\n                    return null;\n                } else\n                {\n                    baos.write(buffer, 0, len);\n                    if (len != buffer.length) {\n\t\t\t\t\t\tbreak;\n                    }\n                }\n            }\n            baos.flush();\n            return baos.toByteArray();\n        } finally\n        {\n            try\n            {\n                //if(dis!=null) dis.close();\n                if(baos!=null) baos.close();\n            } catch (IOException e)\n            {\n                logger.error(\"failed to close tcp stream: \" + e);\n            }\n        }\n\n    }","id":32367,"modified_method":"protected byte[] receive(Socket socket, int timeout) throws IOException\n    {\n        DataInputStream dis = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n        if (timeout >= 0) {\n            socket.setSoTimeout(timeout);\n        }\n        return connector.getTcpProtocol().read(dis);\n    }","commit_id":"ef62252252a78a3984f26219735c553940b9c9dc","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void write(Socket socket, Object data) throws IOException\n    {\n        if (data instanceof String)\n        {\n\t\t\tPrintWriter printWriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())));\n            printWriter.write(data.toString());\n            printWriter.flush();\n        } else if (data instanceof byte[])\n        {\n            BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n            bos.write((byte[]) data);\n            bos.flush();\n        } else {\n            BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n            bos.write(Utility.objectToByteArray(data));\n            bos.flush();\n        }\n\n    }","id":32368,"modified_method":"protected void write(Socket socket, Object data) throws IOException\n    {\n        TcpProtocol protocol = connector.getTcpProtocol();\n\t\tbyte[] binaryData;\n        if (data instanceof String)\n        {\n\t\t\tbinaryData = data.toString().getBytes();\n        } else if (data instanceof byte[])\n        {\n\t\t\tbinaryData = (byte[]) data;\n        } else {\n\t\t\tbinaryData = Utility.objectToByteArray(data); \n        }\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n\t\tprotocol.write(bos, binaryData);\n        bos.flush();\n    }","commit_id":"ef62252252a78a3984f26219735c553940b9c9dc","url":"https://github.com/mulesoft/mule"},{"original_method":"public void run()\n    {\n        while (!disposing.get())\n        {\n            if (connector.isStarted() && !disposing.get())\n            {\n                Socket socket = null;\n                try\n                {\n                    socket = serverSocket.accept();\n                    logger.trace(\"Server socket Accepted on: \" + serverSocket.getLocalPort());\n                } catch (java.io.InterruptedIOException iie)\n                {\n                    logger.debug(\"Interupted IO doing serverSocket.accept: \" + iie.getMessage());\n                } catch (Exception e)\n                {\n                    if (!connector.isDisposed() && !disposing.get())\n                    {\n                        logger.warn(\"Accept failed on socket: \" + e, e);\n                        handleException(e);\n                    }\n                }\n                if (socket != null)\n                {\n                    Work work = createWork(socket);\n                    try\n                    {\n                        getWorkManager().scheduleWork(work, WorkManager.INDEFINITE, null, null);\n                    } catch (WorkException e)\n                    {\n                        logger.error(\"Tcp Server receiver Work was not processed: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n    }","id":32369,"modified_method":"public void run()\n    {\n        while (!disposing.get())\n        {\n            if (connector.isStarted() && !disposing.get())\n            {\n                Socket socket = null;\n                try\n                {\n                    socket = serverSocket.accept();\n\t\t\t\t\tTcpConnector connector = (TcpConnector) this.connector; \n\t\t\t        socket.setReceiveBufferSize(connector.getBufferSize());\n\t\t\t        socket.setSendBufferSize(connector.getBufferSize());\n\t\t\t\t\tsocket.setSoTimeout(connector.getTimeout());\n                    logger.trace(\"Server socket Accepted on: \" + serverSocket.getLocalPort());\n                } catch (java.io.InterruptedIOException iie)\n                {\n                    logger.debug(\"Interupted IO doing serverSocket.accept: \" + iie.getMessage());\n                } catch (Exception e)\n                {\n                    if (!connector.isDisposed() && !disposing.get())\n                    {\n                        logger.warn(\"Accept failed on socket: \" + e, e);\n                        handleException(e);\n                    }\n                }\n                if (socket != null)\n                {\n                    Work work = createWork(socket);\n                    try\n                    {\n                        getWorkManager().scheduleWork(work, WorkManager.INDEFINITE, null, null);\n                    } catch (WorkException e)\n                    {\n                        logger.error(\"Tcp Server receiver Work was not processed: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ef62252252a78a3984f26219735c553940b9c9dc","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n         * Accept requests from a given TCP port\n         */\n        public void run()\n        {\n            try\n            {\n                dataIn = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n                dataOut = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));\n                int counter = 0;\n                while (!socket.isClosed() && !disposing.get())\n                {\n                    if (isServerSide() && ++counter > 500) {\n                        counter = 0;\n                        Thread.yield();\n                    }\n\n                    byte[] b = readStream(dataIn);\n                    //end of stream\n                    if (b == null) {\n\t\t\t\t\t\tbreak;\n                    }\n\n                    byte[] result = processData(b);\n                    if (result != null) {\n                        dataOut.write(result);\n                    }\n                    dataOut.flush();\n                }\n            } catch (Exception e)\n            {\n                handleException(e);\n            } finally {\n                dispose();\n            }\n        }","id":32370,"modified_method":"/**\n         * Accept requests from a given TCP port\n         */\n        public void run()\n        {\n            try\n            {\n                dataIn = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n                dataOut = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));\n                int counter = 0;\n                while (!socket.isClosed() && !disposing.get())\n                {\n\t\t\t\t\t// TODO: is this loop necessary ?\n                    if (isServerSide() && ++counter > 500) {\n                        counter = 0;\n                        Thread.yield();\n                    }\n\n                    byte[] b = protocol.read(dataIn);\n                    //end of stream\n                    if (b == null) {\n\t\t\t\t\t\tbreak;\n                    }\n\n                    byte[] result = processData(b);\n                    if (result != null) {\n                        protocol.write(dataOut, result);\n                    }\n                    dataOut.flush();\n                }\n            } catch (Exception e)\n            {\n                handleException(e);\n            } finally {\n                dispose();\n            }\n        }","commit_id":"ef62252252a78a3984f26219735c553940b9c9dc","url":"https://github.com/mulesoft/mule"},{"original_method":"public TcpWorker(Socket socket)\n        {\n            this.socket = socket;\n        }","id":32371,"modified_method":"public TcpWorker(Socket socket)\n        {\n            this.socket = socket;\n\t\t\tthis.protocol = ((TcpConnector) connector).getTcpProtocol();\n        }","commit_id":"ef62252252a78a3984f26219735c553940b9c9dc","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * @see org.opencms.setup.comptest.I_CmsSetupTest#execute(org.opencms.setup.CmsSetupBean)\n     */\n    public CmsSetupTestResult execute(CmsSetupBean setupBean) {\n\n        CmsSetupTestResult testResult = new CmsSetupTestResult(this);\n        boolean ok = true;\n        Throwable ex = null;\n        try {\n            RenderSettings settings = new RenderSettings(Simapi.RENDER_QUALITY);\n            settings.setCompressionQuality(0.85f);\n            Simapi simapi = new Simapi(settings);\n\n            ImageIO.scanForPlugins();\n            Iterator<ImageReader> pngReaders = ImageIO.getImageReadersByFormatName(Simapi.TYPE_PNG);\n            if (!pngReaders.hasNext()) {\n                throw (new Exception(\"No Java ImageIO readers for the PNG format are available.\"));\n            }\n            Iterator<ImageWriter> pngWriters = ImageIO.getImageWritersByFormatName(Simapi.TYPE_PNG);\n            if (!pngWriters.hasNext()) {\n                throw (new Exception(\"No Java ImageIO writers for the PNG format are available.\"));\n            }\n\n            String basePath = setupBean.getWebAppRfsPath();\n            if (!basePath.endsWith(File.separator)) {\n                basePath += File.separator;\n            }\n            basePath += \"setup\" + File.separator + \"resources\" + File.separator;\n\n            BufferedImage img1 = Simapi.read(basePath + \"test1.png\");\n            BufferedImage img3 = simapi.applyFilter(img1, new RotateFilter(ImageMath.PI));\n            simapi.write(img3, basePath + \"test3.png\", Simapi.TYPE_PNG);\n            BufferedImage img2 = Simapi.read(basePath + \"test2.png\");\n\n            ok = Arrays.equals(simapi.getBytes(img2, Simapi.TYPE_PNG), simapi.getBytes(img3, Simapi.TYPE_PNG));\n        } catch (Throwable e) {\n            ok = false;\n            ex = e;\n        }\n\n        if (ok) {\n            testResult.setResult(RESULT_PASSED);\n            testResult.setGreen();\n        } else {\n            testResult.setYellow();\n            if (ex != null) {\n                testResult.setResult(RESULT_FAILED);\n                testResult.setHelp(ex.toString());\n                testResult.setInfo(\n                    \"<p><code>-Djava.awt.headless=true<\/code> JVM parameter or X-Server may be missing.<br>\"\n                        + \"<b>You can continue the setup, but image processing will be disabled.<\/b><\/p>\");\n            } else {\n                testResult.setResult(RESULT_WARNING);\n                testResult.setHelp(\"Image processing works but result does not exactly match.\");\n                StringBuffer info = new StringBuffer();\n                info.append(\"<p>Please check the following images for visible differences:<\/p>\");\n                info.append(\"<table width='100%'>\");\n                info.append(\"<tr><th>Expected<\/th><th>Result<\/th><\/tr>\");\n                info.append(\"<tr><td align='center' width='50%'><img src='resources/test2.png'><\/td>\");\n                info.append(\"<td align='center' width='50%'><img src='resources/test3.png'><\/td><\/table>\");\n                info.append(\n                    \"<p><b>You can continue the setup, but image processing may not always work as expected.<\/b><\/p>\");\n                testResult.setInfo(info.toString());\n            }\n        }\n        return testResult;\n    }","id":32372,"modified_method":"/**\n     * @see org.opencms.setup.comptest.I_CmsSetupTest#execute(org.opencms.setup.CmsSetupBean)\n     */\n    public CmsSetupTestResult execute(CmsSetupBean setupBean) {\n\n        CmsSetupTestResult testResult = new CmsSetupTestResult(this);\n        boolean ok = true;\n        Throwable ex = null;\n        try {\n            RenderSettings settings = new RenderSettings(Simapi.RENDER_QUALITY);\n            settings.setCompressionQuality(0.85f);\n            Simapi simapi = new Simapi(settings);\n\n            ImageIO.scanForPlugins();\n            Iterator<ImageReader> pngReaders = ImageIO.getImageReadersByFormatName(Simapi.TYPE_PNG);\n            if (!pngReaders.hasNext()) {\n                throw (new Exception(\"No Java ImageIO readers for the PNG format are available.\"));\n            }\n            Iterator<ImageWriter> pngWriters = ImageIO.getImageWritersByFormatName(Simapi.TYPE_PNG);\n            if (!pngWriters.hasNext()) {\n                throw (new Exception(\"No Java ImageIO writers for the PNG format are available.\"));\n            }\n\n            String basePath = setupBean.getWebAppRfsPath();\n            if (!basePath.endsWith(File.separator)) {\n                basePath += File.separator;\n            }\n            basePath += \"setup\" + File.separator + \"resources\" + File.separator;\n\n            CmsImageScaler scaler = new CmsImageScaler();\n            byte[] scaled;\n            BufferedImage result;\n\n            BufferedImage source = Simapi.read(basePath + \"test1.png\");\n            String targetName = basePath + \"test3.png\";\n            scaler.parseParameters(\"w:50,h:18\");\n            scaled = scaler.scaleImage(simapi.getBytes(source, Simapi.TYPE_PNG), targetName);\n            writeFile(targetName, scaled);\n            result = Simapi.read(targetName);\n\n            BufferedImage expected = Simapi.read(basePath + \"test2.png\");\n\n            ok = Arrays.equals(simapi.getBytes(expected, Simapi.TYPE_PNG), simapi.getBytes(result, Simapi.TYPE_PNG));\n        } catch (Throwable e) {\n            ok = false;\n            ex = e;\n        }\n\n        if (ok) {\n            testResult.setResult(RESULT_PASSED);\n            testResult.setGreen();\n        } else {\n            testResult.setYellow();\n            if (ex != null) {\n                testResult.setResult(RESULT_FAILED);\n                testResult.setHelp(ex.toString());\n                testResult.setInfo(\n                    \"<p><code>-Djava.awt.headless=true<\/code> JVM parameter or X-Server may be missing.<br>\"\n                        + \"<b>You can continue the setup, but image processing will be disabled.<\/b><\/p>\");\n            } else {\n                testResult.setResult(RESULT_WARNING);\n                testResult.setHelp(\"Image processing works but result does not exactly match.\");\n                StringBuffer info = new StringBuffer();\n                info.append(\"<p>Please check the following images for visible differences:<\/p>\");\n                info.append(\"<table width='100%'>\");\n                info.append(\"<tr><th>Expected<\/th><th>Result<\/th><\/tr>\");\n                info.append(\"<tr><td align='center' width='50%'><img src='resources/test2.png'><\/td>\");\n                info.append(\"<td align='center' width='50%'><img src='resources/test3.png'><\/td><\/table>\");\n                info.append(\n                    \"<p><b>You can continue the setup, but image processing may not always work as expected.<\/b><\/p>\");\n                testResult.setInfo(info.toString());\n            }\n        }\n        return testResult;\n    }","commit_id":"d881da6a2a37c1d74db9e9438b7f2ce203a579a1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.setup.comptest.I_CmsSetupTest#execute(org.opencms.setup.CmsSetupBean)\n     */\n    public CmsSetupTestResult execute(CmsSetupBean setupBean) {\n\n        CmsSetupTestResult testResult = new CmsSetupTestResult(this);\n        boolean ok = true;\n        Throwable ex = null;\n        try {\n            RenderSettings settings = new RenderSettings(Simapi.RENDER_QUALITY);\n            settings.setCompressionQuality(0.85f);\n            Simapi simapi = new Simapi(settings);\n\n            ImageIO.scanForPlugins();\n            Iterator<ImageReader> pngReaders = ImageIO.getImageReadersByFormatName(Simapi.TYPE_PNG);\n            if (!pngReaders.hasNext()) {\n                throw (new Exception(\"No Java ImageIO readers for the PNG format are available.\"));\n            }\n            Iterator<ImageWriter> pngWriters = ImageIO.getImageWritersByFormatName(Simapi.TYPE_PNG);\n            if (!pngWriters.hasNext()) {\n                throw (new Exception(\"No Java ImageIO writers for the PNG format are available.\"));\n            }\n\n            String basePath = setupBean.getWebAppRfsPath();\n            if (!basePath.endsWith(File.separator)) {\n                basePath += File.separator;\n            }\n            basePath += \"setup\" + File.separator + \"resources\" + File.separator;\n\n            BufferedImage img1 = Simapi.read(basePath + \"test1.png\");\n            BufferedImage img3 = simapi.applyFilter(img1, new RotateFilter(ImageMath.PI));\n            simapi.write(img3, basePath + \"test3.png\", Simapi.TYPE_PNG);\n            BufferedImage img2 = Simapi.read(basePath + \"test2.png\");\n\n            ok = Arrays.equals(simapi.getBytes(img2, Simapi.TYPE_PNG), simapi.getBytes(img3, Simapi.TYPE_PNG));\n        } catch (Throwable e) {\n            ok = false;\n            ex = e;\n        }\n\n        if (ok) {\n            testResult.setResult(RESULT_PASSED);\n            testResult.setGreen();\n        } else {\n            testResult.setYellow();\n            if (ex != null) {\n                testResult.setResult(RESULT_FAILED);\n                testResult.setHelp(ex.toString());\n                testResult.setInfo(\n                    \"<p><code>-Djava.awt.headless=true<\/code> JVM parameter or X-Server may be missing.<br>\"\n                        + \"<b>You can continue the setup, but image processing will be disabled.<\/b><\/p>\");\n            } else {\n                testResult.setResult(RESULT_WARNING);\n                testResult.setHelp(\"Image processing works but result does not exactly match.\");\n                StringBuffer info = new StringBuffer();\n                info.append(\"<p>Please check the following images for visible differences:<\/p>\");\n                info.append(\"<table width='100%'>\");\n                info.append(\"<tr><th>Expected<\/th><th>Result<\/th><\/tr>\");\n                info.append(\"<tr><td align='center' width='50%'><img src='resources/test2.png'><\/td>\");\n                info.append(\"<td align='center' width='50%'><img src='resources/test3.png'><\/td><\/table>\");\n                info.append(\n                    \"<p><b>You can continue the setup, but image processing may not always work as expected.<\/b><\/p>\");\n                testResult.setInfo(info.toString());\n            }\n        }\n        return testResult;\n    }","id":32373,"modified_method":"/**\n     * @see org.opencms.setup.comptest.I_CmsSetupTest#execute(org.opencms.setup.CmsSetupBean)\n     */\n    public CmsSetupTestResult execute(CmsSetupBean setupBean) {\n\n        CmsSetupTestResult testResult = new CmsSetupTestResult(this);\n        boolean ok = true;\n        Throwable ex = null;\n        try {\n            RenderSettings settings = new RenderSettings(Simapi.RENDER_QUALITY);\n            settings.setCompressionQuality(0.85f);\n            Simapi simapi = new Simapi(settings);\n\n            ImageIO.scanForPlugins();\n            Iterator<ImageReader> pngReaders = ImageIO.getImageReadersByFormatName(Simapi.TYPE_PNG);\n            if (!pngReaders.hasNext()) {\n                throw (new Exception(\"No Java ImageIO readers for the PNG format are available.\"));\n            }\n            Iterator<ImageWriter> pngWriters = ImageIO.getImageWritersByFormatName(Simapi.TYPE_PNG);\n            if (!pngWriters.hasNext()) {\n                throw (new Exception(\"No Java ImageIO writers for the PNG format are available.\"));\n            }\n\n            String basePath = setupBean.getWebAppRfsPath();\n            if (!basePath.endsWith(File.separator)) {\n                basePath += File.separator;\n            }\n            basePath += \"setup\" + File.separator + \"resources\" + File.separator;\n\n            CmsImageScaler scaler = new CmsImageScaler();\n            byte[] scaled;\n            BufferedImage result;\n\n            BufferedImage source = Simapi.read(basePath + \"test1.png\");\n            String targetName = basePath + \"test3.png\";\n            scaler.parseParameters(\"w:50,h:18\");\n            scaled = scaler.scaleImage(simapi.getBytes(source, Simapi.TYPE_PNG), targetName);\n            writeFile(targetName, scaled);\n            result = Simapi.read(targetName);\n\n            BufferedImage expected = Simapi.read(basePath + \"test2.png\");\n\n            ok = Arrays.equals(simapi.getBytes(expected, Simapi.TYPE_PNG), simapi.getBytes(result, Simapi.TYPE_PNG));\n        } catch (Throwable e) {\n            ok = false;\n            ex = e;\n        }\n\n        if (ok) {\n            testResult.setResult(RESULT_PASSED);\n            testResult.setGreen();\n        } else {\n            testResult.setYellow();\n            if (ex != null) {\n                testResult.setResult(RESULT_FAILED);\n                testResult.setHelp(ex.toString());\n                testResult.setInfo(\n                    \"<p><code>-Djava.awt.headless=true<\/code> JVM parameter or X-Server may be missing.<br>\"\n                        + \"<b>You can continue the setup, but image processing will be disabled.<\/b><\/p>\");\n            } else {\n                testResult.setResult(RESULT_WARNING);\n                testResult.setHelp(\"Image processing works but result does not exactly match.\");\n                StringBuffer info = new StringBuffer();\n                info.append(\"<p>Please check the following images for visible differences:<\/p>\");\n                info.append(\"<table width='100%'>\");\n                info.append(\"<tr><th>Expected<\/th><th>Result<\/th><\/tr>\");\n                info.append(\"<tr><td align='center' width='50%'><img src='resources/test2.png'><\/td>\");\n                info.append(\"<td align='center' width='50%'><img src='resources/test3.png'><\/td><\/table>\");\n                info.append(\n                    \"<p><b>You can continue the setup, but image processing may not always work as expected.<\/b><\/p>\");\n                testResult.setInfo(info.toString());\n            }\n        }\n        return testResult;\n    }","commit_id":"bf34f0a4ec6435c6d9ccf9c674cdb586f6a04dec","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public BreakpointPanel createBreakpointPanel(Project project) {\n    return null;\n  }","id":32374,"modified_method":"public @Nullable BreakpointPanel createBreakpointPanel(Project project, DialogWrapper parentDialog) {\n    return null;\n  }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract @Nullable BreakpointPanel createBreakpointPanel(Project project);","id":32375,"modified_method":"public abstract @Nullable BreakpointPanel createBreakpointPanel(Project project, DialogWrapper parentDialog);","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BreakpointPanel(BreakpointPropertiesPanel propertiesPanel, final BreakpointPanelAction[] actions) {\n    myPropertiesPanel = propertiesPanel;\n    myActions = actions;\n\n    myTable = new BreakpointTable();\n    myTree = new BreakpointTree();\n\n    myTablePlace.setLayout(new CardLayout());\n    myTablePlace.add(ScrollPaneFactory.createScrollPane(myTable), TABLE_VIEW);\n\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateCurrentBreakpointPropertiesPanel();\n      }\n    });\n    myTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        updateCurrentBreakpointPropertiesPanel();\n      }\n    });\n    myTable.getModel().addTableModelListener(new TableModelListener() {\n      public void tableChanged(TableModelEvent e) {\n        if (e.getType() == TableModelEvent.UPDATE) {\n          updateCurrentBreakpointPropertiesPanel();\n        }\n      }\n    });\n    myTree.getModel().addTreeModelListener(new TreeModelListener() {\n      public void treeNodesChanged(TreeModelEvent e) {\n      }\n\n      public void treeNodesInserted(TreeModelEvent e) {\n      }\n\n      public void treeNodesRemoved(TreeModelEvent e) {\n      }\n\n      public void treeStructureChanged(TreeModelEvent e) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            ensureSelectionExists();\n            updateButtons();\n          }\n        });\n      }\n    });\n    myPropertiesPanelPlace.setLayout(new CardLayout());\n    final JPanel stubPanel = new JPanel();\n    stubPanel.setMinimumSize(myPropertiesPanel.getPanel().getMinimumSize());\n    myPropertiesPanelPlace.add(stubPanel, PROPERTIES_STUB);\n    myPropertiesPanelPlace.add(myPropertiesPanel.getPanel(), PROPERTIES_DATA);\n\n    myBreakPointsPanel.setBorder(IdeBorderFactory.createEmptyBorder(6, 6, 0, 6));\n\n    myButtonsPanel.setLayout(new GridBagLayout());\n    for (int idx = 0; idx < actions.length; idx++) {\n      final BreakpointPanelAction action = actions[idx];\n      action.setPanel(this);\n      final AbstractButton button = action.isStateAction()? new JCheckBox(action.getName()) : new JButton(action.getName());\n      action.setButton(button);\n      button.addActionListener(action);\n      final double weighty = (idx == actions.length - 1) ? 1.0 : 0.0;\n      myButtonsPanel.add(button, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, weighty, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(0, 2, 2, 2), 0, 0));\n    }\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateButtons();\n      }\n    });\n\n    myTable.getModel().addTableModelListener(new TableModelListener() {\n      public void tableChanged(TableModelEvent e) {\n        myEventDispatcher.getMulticaster().breakpointsChanged();\n      }\n    });\n\n    myTablePlace.add(ScrollPaneFactory.createScrollPane(myTree), TREE_VIEW);\n\n    updateCurrentBreakpointPropertiesPanel();\n  }","id":32376,"modified_method":"public BreakpointPanel(BreakpointPropertiesPanel propertiesPanel, final BreakpointPanelAction[] actions, String breakpointCategory, String displayName, String helpId) {\n    myPropertiesPanel = propertiesPanel;\n    myActions = actions;\n    myBreakpointCategory = breakpointCategory;\n    myDisplayName = displayName;\n    myHelpID = helpId;\n\n    myTable = new BreakpointTable();\n    myTree = new BreakpointTree();\n\n    myTablePlace.setLayout(new CardLayout());\n    myTablePlace.add(ScrollPaneFactory.createScrollPane(myTable), TABLE_VIEW);\n\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateCurrentBreakpointPropertiesPanel();\n      }\n    });\n    myTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        updateCurrentBreakpointPropertiesPanel();\n      }\n    });\n    myTable.getModel().addTableModelListener(new TableModelListener() {\n      public void tableChanged(TableModelEvent e) {\n        if (e.getType() == TableModelEvent.UPDATE) {\n          updateCurrentBreakpointPropertiesPanel();\n        }\n      }\n    });\n    myTree.getModel().addTreeModelListener(new TreeModelListener() {\n      public void treeNodesChanged(TreeModelEvent e) {\n      }\n\n      public void treeNodesInserted(TreeModelEvent e) {\n      }\n\n      public void treeNodesRemoved(TreeModelEvent e) {\n      }\n\n      public void treeStructureChanged(TreeModelEvent e) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            ensureSelectionExists();\n            updateButtons();\n          }\n        });\n      }\n    });\n    myPropertiesPanelPlace.setLayout(new CardLayout());\n    final JPanel stubPanel = new JPanel();\n    stubPanel.setMinimumSize(myPropertiesPanel.getPanel().getMinimumSize());\n    myPropertiesPanelPlace.add(stubPanel, PROPERTIES_STUB);\n    myPropertiesPanelPlace.add(myPropertiesPanel.getPanel(), PROPERTIES_DATA);\n\n    myBreakPointsPanel.setBorder(IdeBorderFactory.createEmptyBorder(6, 6, 0, 6));\n\n    myButtonsPanel.setLayout(new GridBagLayout());\n    for (int idx = 0; idx < actions.length; idx++) {\n      final BreakpointPanelAction action = actions[idx];\n      action.setPanel(this);\n      final AbstractButton button = action.isStateAction()? new JCheckBox(action.getName()) : new JButton(action.getName());\n      action.setButton(button);\n      button.addActionListener(action);\n      final double weighty = (idx == actions.length - 1) ? 1.0 : 0.0;\n      myButtonsPanel.add(button, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, weighty, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(0, 2, 2, 2), 0, 0));\n    }\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateButtons();\n      }\n    });\n\n    myTable.getModel().addTableModelListener(new TableModelListener() {\n      public void tableChanged(TableModelEvent e) {\n        myEventDispatcher.getMulticaster().breakpointsChanged();\n      }\n    });\n\n    myTablePlace.add(ScrollPaneFactory.createScrollPane(myTree), TREE_VIEW);\n\n    updateCurrentBreakpointPropertiesPanel();\n  }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateButtons() {\n    for (int idx = 0; idx < myActions.length; idx++) {\n      final BreakpointPanelAction action = myActions[idx];\n      final AbstractButton button = action.getButton();\n      action.update();\n      if (!button.isEnabled() && button.hasFocus()) {\n        button.transferFocus();\n      }\n    }\n  }","id":32377,"modified_method":"public void updateButtons() {\n    for (final BreakpointPanelAction action : myActions) {\n      final AbstractButton button = action.getButton();\n      action.update();\n      if (!button.isEnabled() && button.hasFocus()) {\n        button.transferFocus();\n      }\n    }\n  }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setupPanelUI(BreakpointPanel panel, String category) {\n      final BreakpointManager breakpointManager = getBreakpointManager();\n\n      final BreakpointTree tree = panel.getTree();\n      final String flattenPackages = breakpointManager.getProperty(category + \"_flattenPackages\");\n      if (flattenPackages != null) {\n        tree.setFlattenPackages(\"true\".equalsIgnoreCase(flattenPackages));\n      }\n      final String groupByClasses = breakpointManager.getProperty(category + \"_groupByClasses\");\n      if (groupByClasses != null) {\n        tree.setGroupByClasses(\"true\".equalsIgnoreCase(groupByClasses));\n      }\n      final String groupByMethods = breakpointManager.getProperty(category + \"_groupByMethods\");\n      if (groupByMethods != null) {\n        tree.setGroupByMethods(\"true\".equalsIgnoreCase(groupByMethods));\n      }\n\n      final String viewId = breakpointManager.getProperty(category + \"_viewId\");\n      if (viewId != null) {\n        panel.showView(viewId);\n      }\n    }","id":32378,"modified_method":"private void setupPanelUI(BreakpointPanel panel) {\n      final BreakpointManager breakpointManager = getBreakpointManager();\n      final String category = panel.getBreakpointCategory();\n      final BreakpointTree tree = panel.getTree();\n      final String flattenPackages = breakpointManager.getProperty(category + \"_flattenPackages\");\n      if (flattenPackages != null) {\n        tree.setFlattenPackages(\"true\".equalsIgnoreCase(flattenPackages));\n      }\n      final String groupByClasses = breakpointManager.getProperty(category + \"_groupByClasses\");\n      if (groupByClasses != null) {\n        tree.setGroupByClasses(\"true\".equalsIgnoreCase(groupByClasses));\n      }\n      final String groupByMethods = breakpointManager.getProperty(category + \"_groupByMethods\");\n      if (groupByMethods != null) {\n        tree.setGroupByMethods(\"true\".equalsIgnoreCase(groupByMethods));\n      }\n\n      final String viewId = breakpointManager.getProperty(category + \"_viewId\");\n      if (viewId != null) {\n        panel.showView(viewId);\n      }\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void selectBreakpoint(Breakpoint breakpoint) {\n      if (breakpoint == null) return;\n      if (breakpoint instanceof LineBreakpoint) {\n        myTabbedPane.setSelectedComponent(myLineBreakpointsPanel.getPanel());\n        myLineBreakpointsPanel.selectBreakpoint(breakpoint);\n      }\n      else if (breakpoint instanceof ExceptionBreakpoint) {\n        myTabbedPane.setSelectedComponent(myExceptionBreakpointsPanel.getPanel());\n        myExceptionBreakpointsPanel.selectBreakpoint(breakpoint);\n      }\n      else if (breakpoint instanceof FieldBreakpoint) {\n        myTabbedPane.setSelectedComponent(myFieldBreakpointsPanel.getPanel());\n        myFieldBreakpointsPanel.selectBreakpoint(breakpoint);\n      }\n      else if (breakpoint instanceof MethodBreakpoint) {\n        myTabbedPane.setSelectedComponent(myMethodBreakpointsPanel.getPanel());\n        myMethodBreakpointsPanel.selectBreakpoint(breakpoint);\n      }\n    }","id":32379,"modified_method":"private void selectBreakpoint(Breakpoint breakpoint) {\n      if (breakpoint == null) {\n        return;\n      }\n      final String category = breakpoint.getCategory();\n      for (BreakpointPanel breakpointPanel : myPanels) {\n        if (category.equals(breakpointPanel.getBreakpointCategory())) {\n          myTabbedPane.setSelectedComponent(breakpointPanel.getPanel());\n          breakpointPanel.selectBreakpoint(breakpoint);\n          break;\n        }\n      }\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateTabTitle(final int idx) {\n      JComponent component = myTabbedPane.getComponentAt(idx);\n      if (component == myLineBreakpointsPanel.getPanel()) {\n        myTabbedPane.setIconAt(idx, hasEnabledBreakpoints(myLineBreakpointsPanel)? LineBreakpoint.ICON : LineBreakpoint.DISABLED_ICON);\n      }\n      else if (component == myExceptionBreakpointsPanel.getPanel()) {\n        myTabbedPane.setIconAt(idx, hasEnabledBreakpoints(myExceptionBreakpointsPanel)? ExceptionBreakpoint.ICON : ExceptionBreakpoint.DISABLED_ICON);\n      }\n      else if (component == myFieldBreakpointsPanel.getPanel()) {\n        myTabbedPane.setIconAt(idx, hasEnabledBreakpoints(myFieldBreakpointsPanel)? FieldBreakpoint.ICON : FieldBreakpoint.DISABLED_ICON);\n      }\n      else if (component == myMethodBreakpointsPanel.getPanel()) {\n        myTabbedPane.setIconAt(idx, hasEnabledBreakpoints(myMethodBreakpointsPanel)? MethodBreakpoint.ICON : MethodBreakpoint.DISABLED_ICON);\n      }\n    }","id":32380,"modified_method":"private void updateTabTitle(final int idx) {\n      JComponent component = myTabbedPane.getComponentAt(idx);\n      for (BreakpointPanel breakpointPanel : myPanels) {\n        if (component == breakpointPanel.getPanel()) {\n          final BreakpointFactory factory = BreakpointFactory.getInstance(breakpointPanel.getBreakpointCategory());\n          myTabbedPane.setIconAt(idx, hasEnabledBreakpoints(breakpointPanel)? factory.getIcon() : factory.getDisabledIcon());\n          break;\n        }\n      }\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doHelpAction() {\n      if (myLineBreakpointsPanel.getPanel().isShowing()) {\n        HelpManager.getInstance().invokeHelp(HelpID.LINE_BREAKPOINTS);\n      }\n      else if (myMethodBreakpointsPanel.getPanel().isShowing()) {\n        HelpManager.getInstance().invokeHelp(HelpID.METHOD_BREAKPOINTS);\n      }\n      else if (myExceptionBreakpointsPanel.getPanel().isShowing()) {\n        HelpManager.getInstance().invokeHelp(HelpID.EXCEPTION_BREAKPOINTS);\n      }\n      else if (myFieldBreakpointsPanel.getPanel().isShowing()) {\n        HelpManager.getInstance().invokeHelp(HelpID.FIELD_WATCHPOINTS);\n      }\n      else {\n        super.doHelpAction();\n      }\n    }","id":32381,"modified_method":"protected void doHelpAction() {\n      final JComponent selectedComponent = myTabbedPane.getSelectedComponent();\n      BreakpointPanel currentPanel = null;\n      for (BreakpointPanel breakpointPanel : myPanels) {\n        if (selectedComponent == breakpointPanel.getPanel()) {\n          currentPanel = breakpointPanel;\n          break;\n        }\n      }\n      if (currentPanel != null && currentPanel.getHelpID() != null) {\n        HelpManager.getInstance().invokeHelp(currentPanel.getHelpID());\n      }\n      else {\n        super.doHelpAction();\n      }\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void apply() {\n      if (myLineBreakpointsPanel != null) {\n        myLineBreakpointsPanel.saveChanges();\n      }\n      if (myExceptionBreakpointsPanel != null) {\n        myExceptionBreakpointsPanel.saveChanges();\n      }\n      if (myFieldBreakpointsPanel != null) {\n        myFieldBreakpointsPanel.saveChanges();\n      }\n      if (myMethodBreakpointsPanel != null) {\n        myMethodBreakpointsPanel.saveChanges();\n      }\n      BreakpointManager breakpointManager = getBreakpointManager();\n      breakpointManager.updateAllRequests();\n    }","id":32382,"modified_method":"private void apply() {\n      for (BreakpointPanel panel : myPanels) {\n        panel.saveChanges();\n      }\n      BreakpointManager breakpointManager = getBreakpointManager();\n      breakpointManager.updateAllRequests();\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reset() {\n      BreakpointManager breakpointManager = getBreakpointManager();\n      myLineBreakpointsPanel.setBreakpoints(breakpointManager.getBreakpoints(LineBreakpoint.CATEGORY));\n      myExceptionBreakpointsPanel.setBreakpoints(breakpointManager.getBreakpoints(ExceptionBreakpoint.CATEGORY));\n      myExceptionBreakpointsPanel.insertBreakpointAt(breakpointManager.getAnyExceptionBreakpoint(), 0);\n      myFieldBreakpointsPanel.setBreakpoints(breakpointManager.getBreakpoints(FieldBreakpoint.CATEGORY));\n      myMethodBreakpointsPanel.setBreakpoints(breakpointManager.getBreakpoints(MethodBreakpoint.CATEGORY));\n      updateAllTabTitles();\n      if (myLastSelectedTabIndex >= myTabbedPane.getTabCount() && myLastSelectedTabIndex < 0) {\n        myLastSelectedTabIndex = 0;\n      }\n      myTabbedPane.setSelectedIndex(myLastSelectedTabIndex);\n    }","id":32383,"modified_method":"private void reset() {\n      final BreakpointManager breakpointManager = DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager();\n      for (BreakpointPanel panel : myPanels) {\n        panel.setBreakpoints(breakpointManager.getBreakpoints(panel.getBreakpointCategory()));\n      }\n      updateAllTabTitles();\n      if (myLastSelectedTabIndex >= myTabbedPane.getTabCount() && myLastSelectedTabIndex < 0) {\n        myLastSelectedTabIndex = 0;\n      }\n      myTabbedPane.setSelectedIndex(myLastSelectedTabIndex);\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void dispose() {\n      apply();\n      if (myPanel != null) {\n        if (myLineBreakpointsPanel != null) {\n          myLineBreakpointsPanel.dispose();\n          savePanelSettings(myLineBreakpointsPanel, LineBreakpoint.CATEGORY);\n        }\n        if (myExceptionBreakpointsPanel != null) {\n          myExceptionBreakpointsPanel.dispose();\n          savePanelSettings(myExceptionBreakpointsPanel, ExceptionBreakpoint.CATEGORY);\n        }\n        if (myFieldBreakpointsPanel != null) {\n          myFieldBreakpointsPanel.dispose();\n          savePanelSettings(myFieldBreakpointsPanel, FieldBreakpoint.CATEGORY);\n        }\n        if (myMethodBreakpointsPanel != null) {\n          myMethodBreakpointsPanel.dispose();\n          savePanelSettings(myMethodBreakpointsPanel, MethodBreakpoint.CATEGORY);\n        }\n        myTabbedPane.uninstallKeyboardNavigation();\n        myLastSelectedTabIndex = myTabbedPane.getSelectedIndex();\n        myPanel.removeAll();\n        myPanel = null;\n        myTabbedPane = null;\n      }\n      super.dispose();\n    }","id":32384,"modified_method":"protected void dispose() {\n      apply();\n      if (myPanel != null) {\n        for (BreakpointPanel panel : myPanels) {\n          panel.dispose();\n          savePanelSettings(panel, panel.getBreakpointCategory());\n        }\n        myTabbedPane.uninstallKeyboardNavigation();\n        myLastSelectedTabIndex = myTabbedPane.getSelectedIndex();\n        myPanel.removeAll();\n        myPanel = null;\n        myTabbedPane = null;\n      }\n      super.dispose();\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n      myTabbedPane = new TabbedPaneWrapper();\n      myPanel = new JPanel(new BorderLayout());\n      myLineBreakpointsPanel = new BreakpointPanel(new LineBreakpointPropertiesPanel(myProject), new BreakpointPanelAction[] {\n        new SwitchViewAction(),\n        new GotoSourceAction(myProject) {\n          public void actionPerformed(ActionEvent e) {\n            super.actionPerformed(e);\n            close(OK_EXIT_CODE);\n          }\n        },\n        new ViewSourceAction(myProject),\n        new RemoveAction(myProject),\n        new ToggleGroupByMethodsAction(),\n        new ToggleGroupByClassesAction(),\n        new ToggleFlattenPackagesAction(),\n      });\n      setupPanelUI(myLineBreakpointsPanel, LineBreakpoint.CATEGORY);\n      \n      myExceptionBreakpointsPanel = new BreakpointPanel(new ExceptionBreakpointPropertiesPanel(myProject), new BreakpointPanelAction[] {\n        new SwitchViewAction(),\n        new AddExceptionBreakpointAction(),\n        new RemoveAction(myProject) {\n          public void update() {\n            super.update();\n            if(getButton().isEnabled()) {\n              Breakpoint[] selectedBreakpoints = getPanel().getSelectedBreakpoints();\n              for (int i = 0; i < selectedBreakpoints.length; i++) {\n                Breakpoint bp = selectedBreakpoints[i];\n                if (bp instanceof AnyExceptionBreakpoint) {\n                  getButton().setEnabled(false);\n                }\n              }\n            }\n          }\n        },\n        new ToggleGroupByClassesAction(),\n        new ToggleFlattenPackagesAction(),\n      });\n      setupPanelUI(myExceptionBreakpointsPanel, ExceptionBreakpoint.CATEGORY);\n      myExceptionBreakpointsPanel.getTree().setGroupByMethods(false);\n\n      myFieldBreakpointsPanel = new BreakpointPanel(new FieldBreakpointPropertiesPanel(myProject), new BreakpointPanelAction[] {\n        new SwitchViewAction(),\n        new AddFieldBreakpointAction(),\n        new GotoSourceAction(myProject) {\n          public void actionPerformed(ActionEvent e) {\n            super.actionPerformed(e);\n            close(OK_EXIT_CODE);\n          }\n        },\n        new ViewSourceAction(myProject),\n        new RemoveAction(myProject),\n        new ToggleGroupByClassesAction(),\n        new ToggleFlattenPackagesAction(),\n      });\n      setupPanelUI(myFieldBreakpointsPanel, FieldBreakpoint.CATEGORY);\n      myFieldBreakpointsPanel.getTree().setGroupByMethods(false);\n\n      myMethodBreakpointsPanel = new BreakpointPanel(new MethodBreakpointPropertiesPanel(myProject), new BreakpointPanelAction[] {\n        new SwitchViewAction(),\n        new GotoSourceAction(myProject) {\n          public void actionPerformed(ActionEvent e) {\n            super.actionPerformed(e);\n            close(OK_EXIT_CODE);\n          }\n        },\n        new ViewSourceAction(myProject),\n        new RemoveAction(myProject),\n        new ToggleGroupByClassesAction(),\n        new ToggleFlattenPackagesAction(),\n      });\n      setupPanelUI(myMethodBreakpointsPanel, MethodBreakpoint.CATEGORY);\n      myMethodBreakpointsPanel.getTree().setGroupByMethods(false);\n\n      addPanel(myLineBreakpointsPanel, LINE_BREAKPOINTS_NAME);\n      addPanel(myExceptionBreakpointsPanel, EXCEPTION_BREAKPOINTS_NAME);\n      addPanel(myFieldBreakpointsPanel, FIELD_WATCHPOINTS_NAME);\n      addPanel(myMethodBreakpointsPanel, METHOD_BREAKPOINTS_NAME);\n\n      myTabbedPane.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          BreakpointPanel panel = getSelectedPanel();\n          panel.ensureSelectionExists();\n        }\n      });\n      myPanel.add(myTabbedPane.getComponent(), BorderLayout.CENTER);\n\n      myTabbedPane.installKeyboardNavigation();\n\n      // \"Enter\" and \"Esc\" keys work like \"Close\" button.\n      ActionListener closeAction = new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          close(CANCEL_EXIT_CODE);\n        }\n      };\n      myPanel.registerKeyboardAction(\n        closeAction,\n        KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0),\n        JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT\n      );\n      myPanel.setPreferredSize(new Dimension(600, 500));\n      return myPanel;\n    }","id":32385,"modified_method":"protected JComponent createCenterPanel() {\n      myTabbedPane = new TabbedPaneWrapper();\n      myPanel = new JPanel(new BorderLayout());\n\n      final BreakpointFactory[] allFactories = ApplicationManager.getApplication().getComponents(BreakpointFactory.class);\n      for (final BreakpointFactory breakpointFactory : allFactories) {\n        final BreakpointPanel breakpointPanel = breakpointFactory.createBreakpointPanel(myProject, this);\n        if (breakpointPanel != null) {\n          setupPanelUI(breakpointPanel);\n          myPanels.add(breakpointPanel);\n          addPanel(breakpointPanel, breakpointPanel.getDisplayName());\n        }\n      }\n\n      myTabbedPane.addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          BreakpointPanel panel = getSelectedPanel();\n          panel.ensureSelectionExists();\n        }\n      });\n      myPanel.add(myTabbedPane.getComponent(), BorderLayout.CENTER);\n\n      myTabbedPane.installKeyboardNavigation();\n\n      // \"Enter\" and \"Esc\" keys work like \"Close\" button.\n      ActionListener closeAction = new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          close(CANCEL_EXIT_CODE);\n        }\n      };\n      myPanel.registerKeyboardAction(\n        closeAction,\n        KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0),\n        JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT\n      );\n      myPanel.setPreferredSize(new Dimension(600, 500));\n      return myPanel;\n    }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BreakpointPanel createBreakpointPanel(Project project) {\n    return null;\n  }","id":32386,"modified_method":"public BreakpointPanel createBreakpointPanel(final Project project, DialogWrapper parentDialog) {\n    BreakpointPanel panel = new BreakpointPanel(new ExceptionBreakpointPropertiesPanel(project), createActions(project), getBreakpointCategory(), \"Exception Breakpoints\", HelpID.EXCEPTION_BREAKPOINTS) {\n      public void setBreakpoints(Breakpoint[] breakpoints) {\n        super.setBreakpoints(breakpoints);\n        final AnyExceptionBreakpoint anyExceptionBreakpoint = DebuggerManagerEx.getInstanceEx(project).getBreakpointManager().getAnyExceptionBreakpoint();\n        boolean found = false;\n        for (Breakpoint breakpoint : breakpoints) {\n          if (breakpoint.equals(anyExceptionBreakpoint)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          insertBreakpointAt(anyExceptionBreakpoint, 0);\n        }\n      }\n    };\n    panel.getTree().setGroupByMethods(false);\n    return panel;\n  }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BreakpointPanel createBreakpointPanel(Project project) {\n    return null;\n  }","id":32387,"modified_method":"public BreakpointPanel createBreakpointPanel(final Project project, final DialogWrapper parentDialog) {\n    BreakpointPanel panel = new BreakpointPanel(new FieldBreakpointPropertiesPanel(project), new BreakpointPanelAction[] {\n      new SwitchViewAction(),\n      new AddFieldBreakpointAction(project),\n      new GotoSourceAction(project) {\n        public void actionPerformed(ActionEvent e) {\n          super.actionPerformed(e);\n          parentDialog.close(DialogWrapper.OK_EXIT_CODE);\n        }\n      },\n      new ViewSourceAction(project),\n      new RemoveAction(project),\n      new ToggleGroupByClassesAction(),\n      new ToggleFlattenPackagesAction(),\n    }, getBreakpointCategory(), \"Field Watchpoints\", HelpID.FIELD_WATCHPOINTS);\n    panel.getTree().setGroupByMethods(false);\n    return panel;\n  }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BreakpointPanel createBreakpointPanel(Project project) {\n    return null;\n  }","id":32388,"modified_method":"public BreakpointPanel createBreakpointPanel(Project project, final DialogWrapper parentDialog) {\n    final BreakpointPanel panel = new BreakpointPanel(new LineBreakpointPropertiesPanel(project), new BreakpointPanelAction[]{\n      new SwitchViewAction(),\n      new GotoSourceAction(project) {\n        public void actionPerformed(ActionEvent e) {\n          super.actionPerformed(e);\n          parentDialog.close(DialogWrapper.OK_EXIT_CODE);\n        }\n      },\n      new ViewSourceAction(project),\n      new RemoveAction(project),\n      new ToggleGroupByMethodsAction(),\n      new ToggleGroupByClassesAction(),\n      new ToggleFlattenPackagesAction(),\n    }, getBreakpointCategory(), \"Line Breakpoints\", HelpID.LINE_BREAKPOINTS);\n    return panel;\n  }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BreakpointPanel createBreakpointPanel(Project project) {\n    return null;\n  }","id":32389,"modified_method":"public BreakpointPanel createBreakpointPanel(Project project, final DialogWrapper parentDialog) {\n    BreakpointPanel panel = new BreakpointPanel(new MethodBreakpointPropertiesPanel(project), new BreakpointPanelAction[]{\n      new SwitchViewAction(),\n      new GotoSourceAction(project) {\n        public void actionPerformed(ActionEvent e) {\n          super.actionPerformed(e);\n          parentDialog.close(DialogWrapper.OK_EXIT_CODE);\n        }\n      },\n      new ViewSourceAction(project),\n      new RemoveAction(project),\n      new ToggleGroupByClassesAction(),\n      new ToggleFlattenPackagesAction(),\n    }, getBreakpointCategory(), \"Method Breakpoints\", HelpID.METHOD_BREAKPOINTS);\n    panel.getTree().setGroupByMethods(false);\n    return panel;\n  }","commit_id":"e0a2fa5e402025b4c8346a5e25075813033a7224","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void displayMap(LWMap map)\n    {\n        //System.out.println(\"VUE.displayMap \" + map);\n        MapViewer mapViewer = null;\n        // todo: figure out if we're already displaying this map\n        /*\n        for (int i = 0; i < tabbedPane.getTabCount(); i++) {\n            MapViewer mv = (MapViewer) tabbedPane.getComponentAt(i);\n            if (mv.getMap() == map) {\n                mapViewer = mv;\n                System.out.println(\"VUE.displayMap found existing \" + map + \" in \" + mv);\n                break;\n            }\n        }\n        */\n        if (mapViewer == null) {\n            mapViewer = new tufts.vue.MapViewer(map);\n            if (VUE.ActiveViewer == null)\n                VUE.ActiveViewer = mapViewer;\n            tabbedPane.addTab(map.getLabel(), mapViewer);\n            MapViewer mv2 = new tufts.vue.MapViewer(map, true);\n            tabbedPane2.addTab(map.getLabel(), mv2);\n        }\n        int idx = tabbedPane.indexOfComponent(mapViewer);\n        /*\n        //tabbedPane.setBackgroundAt(idx, Color.blue);\n        tabbedPane.setForegroundAt(tabbedPane.getSelectedIndex(), Color.black);\n        tabbedPane.setForegroundAt(idx, Color.blue);\n        // need to add a listener to change colors -- PC gui feedback of which\n        // tab is selected is completely horrible.\n        */\n        tabbedPane.setSelectedComponent(mapViewer);\n\n    }","id":32390,"modified_method":"public static void displayMap(LWMap map)\n    {\n        //System.out.println(\"VUE.displayMap \" + map);\n        MapViewer mapViewer = null;\n        // todo: figure out if we're already displaying this map\n        /*\n        for (int i = 0; i < tabbedPane.getTabCount(); i++) {\n            MapViewer mv = (MapViewer) tabbedPane.getComponentAt(i);\n            if (mv.getMap() == map) {\n                mapViewer = mv;\n                System.out.println(\"VUE.displayMap found existing \" + map + \" in \" + mv);\n                break;\n            }\n        }\n        */\n        \n        final boolean useScrollbars = false; // in-progress feature\n        JScrollPane sp = null;\n        if (mapViewer == null) {\n            mapViewer = new tufts.vue.MapViewer(map);\n            if (VUE.ActiveViewer == null)\n                VUE.ActiveViewer = mapViewer;\n\n            if (useScrollbars)\n                tabbedPane.addTab(map.getLabel(), sp = new JScrollPane(mapViewer));\n            else\n                tabbedPane.addTab(map.getLabel(), mapViewer);\n\n            // put BACKINGSTORE mode on a diag switch and test\n            // performance difference -- the obvious difference is\n            // vastly better performance if an inspector window is\n            // obscuring any part of the canvas (or any other window\n            // for that mater), which kills off a huge chunk of\n            // BLIT_SCROLL_MODE's optimization.  However, using\n            // backing store completely fucks up if we start\n            // hand-panning the map, tho I'm presuming that's because\n            // the hand panning isn't being done thru the viewport\n            // yet.\n            //\n            //sp.getViewport().setScrollMode(javax.swing.JViewport.BACKINGSTORE_SCROLL_MODE);\n            \n            MapViewer mv2 = new tufts.vue.MapViewer(map, true);\n            tabbedPane2.addTab(map.getLabel(), mv2);\n        }\n        int idx = tabbedPane.indexOfComponent(mapViewer);\n        /*\n        //tabbedPane.setBackgroundAt(idx, Color.blue);\n        tabbedPane.setForegroundAt(tabbedPane.getSelectedIndex(), Color.black);\n        tabbedPane.setForegroundAt(idx, Color.blue);\n        // need to add a listener to change colors -- PC gui feedback of which\n        // tab is selected is completely horrible.\n        */\n        if (useScrollbars)\n            tabbedPane.setSelectedComponent(sp);\n        else\n            tabbedPane.setSelectedComponent(mapViewer);\n\n    }","commit_id":"1ec7099a998580b05cffc02283440a4d708de6d8","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * updatePanels\n     * This method updates the panel's content pased on the selected\n     * Map\n     *\n     **/\n    public void updatePanels() {\n        mInfoPanel.updatePanel( mComponent);\n        mTreePanel.updatePanel( mComponent);\n        mNotePanel.updatePanel( mComponent);\n        mNodeFilterPanel.updatePanel(mComponent);\n    }","id":32391,"modified_method":"/**\n     * updatePanels\n     * This method updates the panel's content pased on the selected\n     * Map\n     *\n     **/\n    public void updatePanels() {\n        //mInfoPanel.updatePanel( mComponent);\n        mTreePanel.updatePanel( mComponent);\n        mNotePanel.updatePanel( mComponent);\n        mNodeFilterPanel.updatePanel(mComponent);\n    }","commit_id":"9c063cff1851470139630b56a328633cd1e9067f","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * setTab\n     * Sets the selected Tab for teh panel to the specifided ObjectInspector panel key\n     **/\n    public void setTab( int pTabKey) {\n        if (pTabKey == NOTES_TAB ) {\n            mTabbedPane.setSelectedComponent( mNotePanel);\n        } else if (pTabKey == INFO_TAB ) {\n            mTabbedPane.setSelectedComponent( mInfoPanel );\n        } else if (pTabKey == TREE_TAB ) {\n            mTabbedPane.setSelectedComponent( mTreePanel );\n        } else if(pTabKey == FILTER_TAB) {\n            mTabbedPane.setSelectedComponent(mNodeFilterPanel);\n        }\n        Window w = javax.swing.SwingUtilities.getWindowAncestor(this);\n        if (w != null)\n            w.setVisible(true);\n    }","id":32392,"modified_method":"/**\n     * setTab\n     * Sets the selected Tab for teh panel to the specifided ObjectInspector panel key\n     **/\n    public void setTab( int pTabKey) {\n        JComponent picked = null;\n        if (pTabKey == NOTES_TAB ) {\n            picked = mNotePanel;\n        } else if (pTabKey == INFO_TAB ) {\n            picked = mInfoPanel;\n        } else if (pTabKey == TREE_TAB ) {\n            picked = mTreePanel;\n        } else if(pTabKey == FILTER_TAB) {\n            picked = mNodeFilterPanel;\n        }\n        if (picked != null) {\n            if (WidgetStackImpl)\n                Widget.setExpanded(picked, true);\n            else\n                mTabbedPane.setSelectedComponent(picked);\n        }\n        Window w = javax.swing.SwingUtilities.getWindowAncestor(this);\n        if (w != null)\n            w.setVisible(true);\n    }","commit_id":"9c063cff1851470139630b56a328633cd1e9067f","url":"https://github.com/VUE/VUE"},{"original_method":"public ObjectInspectorPanel() {\n        super();\n        \n        setOpaque(false);\n        setMinimumSize( new Dimension( 240,200) );\n        setLayout( new BorderLayout() );\n        setBorder( new EmptyBorder( 5,5,5,5) );\n        mTabbedPane = new JTabbedPane();\n        VueResources.initComponent( mTabbedPane, \"tabPane\");\n        \n        mInfoPanel = new InfoPanel();\n        mTreePanel = new TreePanel();\n        mNotePanel = new NotePanel();\n        mNodeFilterPanel = new NodeFilterPanel();\n        \n        mTabbedPane.addTab( mInfoPanel.getName(), mInfoPanel);\n        mTabbedPane.addTab( mTreePanel.getName(),  mTreePanel);\n        mTabbedPane.addTab( mNotePanel.getName(), mNotePanel);\n        mTabbedPane.addTab(mNodeFilterPanel.getName(),mNodeFilterPanel);\n        add( BorderLayout.CENTER, mTabbedPane );\n        if (DEBUG.INIT) System.out.println(\"Created \" + this);\n    }","id":32393,"modified_method":"public ObjectInspectorPanel()\n    {\n        setMinimumSize( new Dimension( 240,200) );\n        \n        //mInfoPanel = new InfoPanel();\n        mTreePanel = new TreePanel();\n        mNotePanel = new NotePanel();\n        mNodeFilterPanel = new NodeFilterPanel();\n            \n        setLayout( new BorderLayout() );\n        \n        if (WidgetStackImpl) {\n            WidgetStack stack = new WidgetStack();\n            stack.addPane(mNotePanel);\n            stack.addPane(mNodeFilterPanel);\n            stack.addPane(mTreePanel);\n            add(stack);\n            Widget.setExpanded(mTreePanel, false);\n        } else {\n            setOpaque(false);\n            setBorder( new EmptyBorder( 5,5,5,5) );\n            mTabbedPane = new JTabbedPane();\n            VueResources.initComponent( mTabbedPane, \"tabPane\");\n        \n            //mTabbedPane.addTab( mInfoPanel.getName(), mInfoPanel);\n            mTabbedPane.addTab( mTreePanel.getName(),  mTreePanel);\n            mTabbedPane.addTab( mNotePanel.getName(), mNotePanel);\n            mTabbedPane.addTab(mNodeFilterPanel.getName(),mNodeFilterPanel);\n            add( BorderLayout.CENTER, mTabbedPane );\n        } \n        if (DEBUG.INIT) System.out.println(\"Created \" + this);\n    }","commit_id":"9c063cff1851470139630b56a328633cd1e9067f","url":"https://github.com/VUE/VUE"},{"original_method":"public File tempFile(File parent, String name) throws IOException {\n        String path;\n        if (parent != null) {\n            path = parent.getAbsolutePath() + File.separator + name;\n        } else {\n            path = name;\n        }\n        \n        File f = new File(path);\n        assertTrue(\"createNewFile: \" + f.getAbsolutePath(), f.createNewFile());\n        m_deleteMe.add(f);\n        return f;\n    }","id":32394,"modified_method":"public File tempFile(File parent, String name) throws IOException {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempFile(parent, name);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempFile(String name) throws IOException {\n        return tempFile(m_tempDir, name);\n    }","id":32395,"modified_method":"public File tempFile(String name) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n\n        assertInitialized();\n\n        return internalTempFile(m_tempDir, name);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File getTempDir() {\n        return m_tempDir;\n    }","id":32396,"modified_method":"public File getTempDir() {\n        assertInitialized();\n        \n        return m_tempDir;\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempFile(String name, String contents) throws IOException {\n        return tempFile(m_tempDir, name, contents);\n    }","id":32397,"modified_method":"public File tempFile(String name, String contents) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        if (contents == null) {\n            throw new IllegalArgumentException(\"contents argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempFile(m_tempDir, name, contents);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempDir(String name) throws IOException {\n        return tempDir(m_tempDir, name);\n    }","id":32398,"modified_method":"public File tempDir(String name) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        return tempDir(m_tempDir, name);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void deleteExpected() {\n        for (ListIterator i = m_expecting.listIterator(m_expecting.size());\n             i.hasPrevious(); ) {\n            File f = (File) i.previous();\n            assertTrue(\"\\\"\" + f.getAbsolutePath() + \"\\\" deleted\", f.delete());\n            i.remove();\n        }\n        assertEquals(\"No expected files left over\", m_expecting.size(), 0);\n    }","id":32399,"modified_method":"public void deleteExpected() {\n        assertInitialized();\n\n        for (ListIterator<File> i = m_expecting.listIterator(m_expecting.size()); i.hasPrevious(); ) {\n            File f = i.previous();\n            assertTrue(\"\\\"\" + f.getAbsolutePath() + \"\\\" deleted\", f.delete());\n            i.remove();\n        }\n        assertEquals(\"No expected files left over\", m_expecting.size(), 0);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempFile(File parent, String name, String contents)\n        throws IOException {\n        File f = tempFile(parent, name);\n        PrintWriter w = new PrintWriter(new FileWriter(f));\n        w.print(contents);\n        w.close();\n        return f;\n    }","id":32400,"modified_method":"public File tempFile(File parent, String name, String contents) throws IOException {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        if (contents == null) {\n            throw new IllegalArgumentException(\"contents argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempFile(parent, name, contents);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void tearDown() {\n        try {\n            for (ListIterator i = m_deleteMe.listIterator(m_deleteMe.size());\n                 i.hasPrevious(); ) {\n                File f = (File) i.previous();\n                if (!f.delete()) {\n                    fail(\"Could not delete \" + f.getAbsolutePath()\n                         + \": is it a non-empty directory?\");\n                }\n            }\n            if (m_tempDir != null) {\n                assertFalse(m_tempDir + \" exists\", m_tempDir.exists());\n            }\n        } catch (UndeclaredThrowableException e) {\n            if (m_tempDir != null && m_tempDir.exists()) {\n                ProcessExec ex = new ProcessExec(System.out, System.err);\n                String[] cmd = new String[3];\n                cmd[0] = \"rm\";\n                cmd[1] = \"-r\";\n                cmd[2] = m_tempDir.getAbsolutePath();\n                try {\n                    ex.exec(cmd);\n                } catch (Throwable t) {\n                    // ignore\n                }\n            }\n            throw e;\n        }\n    }","id":32401,"modified_method":"public void tearDown() {\n        if (!isInitialized()) {\n            return;\n        }\n        \n        try {\n            for (ListIterator<File> i = m_deleteMe.listIterator(m_deleteMe.size()); i.hasPrevious(); ) {\n                File f = i.previous();\n                if (!f.delete()) {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"Could not delete \" + f.getAbsolutePath() + \": is it a non-empty directory?  Output from 'ls -l':\\n\");\n                    fail(b.toString());\n                }\n            }\n            if (m_tempDir != null) {\n                assertFalse(m_tempDir + \" exists\", m_tempDir.exists());\n            }\n        } catch (UndeclaredThrowableException e) {\n            if (m_tempDir != null && m_tempDir.exists()) {\n                ProcessExec ex = new ProcessExec(System.out, System.err);\n                String[] cmd = new String[3];\n                cmd[0] = \"rm\";\n                cmd[1] = \"-r\";\n                cmd[2] = m_tempDir.getAbsolutePath();\n                try {\n                    ex.exec(cmd);\n                } catch (Throwable t) {\n                    // ignore\n                }\n            }\n            throw e;\n        }\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempDir(File parent, String name) throws IOException {\n        String path;\n        if (parent != null) {\n            path = parent.getAbsolutePath() + File.separator + name;\n        } else {\n            path = name;\n        }\n        \n        File f = new File(path);\n        assertTrue(\"mkdir: \" + f.getAbsolutePath(), f.mkdir());\n        m_deleteMe.add(f);\n        return f;\n    }","id":32402,"modified_method":"public File tempDir(File parent, String name) throws IOException {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempDir(parent, name);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File expecting(File parent, String name) {\n        String path;\n        if (parent != null) {\n            path = parent.getAbsolutePath() + File.separator + name;\n        } else {\n            path = name;\n        }\n        \n        File f = new File(path);\n        m_expecting.add(f);\n        return f;\n    }","id":32403,"modified_method":"public File expecting(File parent, String name) {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        assertInitialized();\n\n        return internalExpecting(parent, name);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public FileAnticipator() throws IOException {\n        createTempDir();\n    }","id":32404,"modified_method":"public FileAnticipator() throws IOException {\n        this(true);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testTempFileContents() throws IOException {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        String contents = \"yay!\";\n        File yay = m_anticipator.tempFile(file, contents);\n        \n        StringBuffer b = new StringBuffer();\n        FileInputStream is = new FileInputStream(yay);\n        int i;\n        while ((i = is.read()) != -1) {\n            b.append(new Character((char) i));\n        }\n        is.close();\n        \n        assertEquals(\"file contents\", contents, b.toString());\n        \n        m_anticipator.deleteExpected();\n    }","id":32405,"modified_method":"public void testTempFileWithContents() throws Exception {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        String contents = \"yay!\";\n        File f = m_anticipator.tempFile(file, contents);\n        assertEquals(\"temporary file name\", m_anticipator.getTempDir() + File.separator + file, f.getAbsolutePath());\n        assertTrue(\"temporary file should exist at \" + f.getAbsolutePath(), f.isFile());\n        \n        StringBuffer b = new StringBuffer();\n        FileInputStream is = new FileInputStream(f);\n        int i;\n        while ((i = is.read()) != -1) {\n            b.append(new Character((char) i));\n        }\n        is.close();\n        \n        assertEquals(\"file contents\", contents, b.toString());\n        \n        m_anticipator.deleteExpected();\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testTempDir() throws IOException {\n        String file = \"FileAnticipatorTest_tempDir_\" + System.currentTimeMillis();\n        m_anticipator.tempDir(file);\n        m_anticipator.deleteExpected();\n    }","id":32406,"modified_method":"public void testTempDir() throws Exception {\n        String file = \"FileAnticipatorTest_tempDir_\" + System.currentTimeMillis();\n        File f = m_anticipator.tempDir(file);\n        assertEquals(\"temporary directory name\", m_anticipator.getTempDir() + File.separator + file, f.getAbsolutePath());\n        assertTrue(\"temporary directory should exist at \" + f.getAbsolutePath(), f.isDirectory());\n        m_anticipator.deleteExpected();\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testExpectingDeleteExpected() throws IOException {\n        String file = \"FileAnticipatorTest_\" + System.currentTimeMillis();\n        File tempFile = m_anticipator.expecting(null, file);\n        assertTrue(\"createNewFile: \" + tempFile.getAbsolutePath(),\n                   tempFile.createNewFile());\n        m_anticipator.deleteExpected();\n    }","id":32407,"modified_method":"public void testExpectingDeleteExpected() throws Exception {\n        String file = \"FileAnticipatorTest_\" + System.currentTimeMillis();\n        File tempFile = m_anticipator.expecting(file);\n        assertTrue(\"createNewFile: \" + tempFile.getAbsolutePath(),\n                   tempFile.createNewFile());\n        m_anticipator.deleteExpected();\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testExpectingDeleteExpectedBogus() {\n        String file = \"/FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n        String expected = \"\\\"\" + file + \"\\\" deleted\";\n                \n        try {\n            m_anticipator.expecting(null, file);\n            m_anticipator.deleteExpected();\n        } catch (Throwable t) {\n            if (expected.equals(t.getMessage())) {\n                return; // This is the exception we were expecting\n            }\n            fail(\"Received unexpected exception.  Was expecting:\\n\" + expected +\n                 \"\\nReceived:\\n\" + t.getMessage());\n        }\n        fail(\"Did not receive excpected exception\");\n    }","id":32408,"modified_method":"public void testExpectingDeleteExpectedBogus() {\n        String file = \"FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new AssertionFailedError(\"\\\"\" + m_anticipator.getTempDir() + File.separator + file + \"\\\" deleted\"));\n\n        m_anticipator.expecting(file);\n\n        try {\n            m_anticipator.deleteExpected();\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testExpecting() {\n        String file = \"/FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n        m_anticipator.expecting(null, file);\n    }","id":32409,"modified_method":"public void testExpecting() {\n        String file = \"/FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n        m_anticipator.expecting(file);\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testTempFile() throws IOException {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        m_anticipator.tempFile(file);\n        m_anticipator.deleteExpected();\n    }","id":32410,"modified_method":"public void testTempFile() throws Exception {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        File f = m_anticipator.tempFile(file);\n        assertEquals(\"temporary file name\", m_anticipator.getTempDir() + File.separator + file, f.getAbsolutePath());\n        assertTrue(\"temporary file should exist at \" + f.getAbsolutePath(), f.isFile());\n        m_anticipator.deleteExpected();\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testConstructor() {\n        // Empty... this effectively tests that setUp() works.\n    }","id":32411,"modified_method":"public void testConstructor() {\n        // Empty... this effectively tests that setUp() works.\n        assertTrue(\"anticipator should be initialized, but said it wasn't\", m_anticipator.isInitialized());\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setUp() throws IOException {\n        m_anticipator = new FileAnticipator();\n    }","id":32412,"modified_method":"public void setUp() throws Exception {\n        m_anticipator = new FileAnticipator();\n    }","commit_id":"74257e205d300b7d048df67981b93e2571ff0dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\r\n   * Returns ordinal characters.\r\n   * @param pic picture\r\n   * @param p position\r\n   * @return ordinal bytes\r\n   */\r\n  private byte[] ord(final byte[] pic, final int p) {\r\n    return charAt(pic, p)  != 'o' ? null :\r\n      charAt(pic, p + 1) != '(' || charAt(pic, pic.length - 1) != ')' ? EMPTY :\r\n      substring(pic, p + 2, pic.length - 1);\r\n  }","id":32413,"modified_method":"/**\r\n   * Returns ordinal characters.\r\n   * @param pic picture\r\n   * @param p position\r\n   * @return ordinal bytes\r\n   */\r\n  protected static byte[] ord(final byte[] pic, final int p) {\r\n    return charAt(pic, p)  != 'o' ? null :\r\n      charAt(pic, p + 1) != '(' || charAt(pic, pic.length - 1) != ')' ? EMPTY :\r\n      substring(pic, p + 2, pic.length - 1);\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a number character sequence.\r\n   * @param tb token builder\r\n   * @param n number to be formatted\r\n   * @param pic picture\r\n   */\r\n  private void number(final TokenBuilder tb, final long n, final byte[] pic) {\r\n    // find optional ordinal modifier\r\n    int p = 0;\r\n    for(; p < pic.length && pic[p] != 'o'; p += cl(pic, p));\r\n\r\n    // find optional ordinal modifier\r\n    final byte[] s = token(n);\r\n    for(int i = p - s.length; i > 0; i--) tb.add('0');\r\n    tb.add(s);\r\n\r\n    // ordinal found; add suffix\r\n    if(ord(pic, p) != null) {\r\n      final int f = (int) (n % 10);\r\n      tb.add(ORDSUFFIX[f > 0 && f < 4 && n % 100 / 10 != 1 ? f - 1 : 3]);\r\n    }\r\n  }","id":32414,"modified_method":"/**\r\n   * Returns a number character sequence.\r\n   * @param tb token builder\r\n   * @param n number to be formatted\r\n   * @param pic picture\r\n   * @param form language-dependent formatter\r\n   */\r\n  private static void number(final TokenBuilder tb, final long n,\r\n      final byte[] pic, final Formatter form) {\r\n\r\n    // find optional ordinal modifier\r\n    int p = 0;\r\n    for(; p < pic.length && pic[p] != 'o'; p += cl(pic, p));\r\n\r\n    // find optional-digit-signs\r\n    int o = 0;\r\n    for(; o < pic.length && pic[o] == '#'; o += cl(pic, o));\r\n\r\n    // create string representation\r\n    final byte[] str = token(n);\r\n    // ordinal\r\n    final byte[] ord = form.ordinal(n, ord(pic, p));\r\n\r\n    final int d = p - str.length - ord.length;\r\n    for(int i = Math.min(o, d); i > 0; i--) tb.add(' ');\r\n    for(int i = d; i > o; i--) tb.add('0');\r\n    tb.add(str);\r\n    tb.add(ord);\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a formatted integer.\r\n   * @param ctx query context\r\n   * @return string\r\n   * @throws QueryException query exception\r\n   */\r\n  private Str formatInt(final QueryContext ctx) throws QueryException {\r\n    final byte[] pic = checkStr(expr[1], ctx);\r\n    if(expr[0].e()) return Str.ZERO;\r\n\r\n    long num = checkItr(expr[0], ctx);\r\n    if(pic.length == 0 || num == 0) return Str.get(token(num));\r\n\r\n    // choose sign\r\n    final boolean sign = num < 0;\r\n    if(sign) num = -num;\r\n\r\n    // choose first character and case\r\n    final int ch = cp(pic, 0);\r\n    Case cs = (ch & 0x20) != 0 ? Case.LOWER : Case.STANDARD;\r\n\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    if((ch & 0xDF) == 'A') {\r\n      latin(tb, num);\r\n    } else if((ch & 0xDF) == 'I') {\r\n      roman(tb, num);\r\n    } else if((ch & 0xDF) == 'W') {\r\n      final boolean up = pic.length == 1 || pic[1] != 'w';\r\n      if(up) cs = Case.UPPER;\r\n      word(tb, num, ord(pic, up ? 1 : 2));\r\n    } else {\r\n      number(tb, num, pic);\r\n    }\r\n\r\n    // finalize formatted string\r\n    byte[] result = tb.finish();\r\n    if(sign) result = concat(new byte[] { '-' }, result);\r\n    if(cs == Case.LOWER) result = lc(result);\r\n    if(cs == Case.UPPER) result = uc(result);\r\n    return Str.get(result);\r\n  }","id":32415,"modified_method":"/**\r\n   * Returns a formatted integer.\r\n   * @param ctx query context\r\n   * @return string\r\n   * @throws QueryException query exception\r\n   */\r\n  private Str formatInt(final QueryContext ctx) throws QueryException {\r\n    final byte[] pic = checkStr(expr[1], ctx);\r\n    if(expr[0].e()) return Str.ZERO;\r\n\r\n    final Formatter f = Formatter.get(\r\n        string(expr.length == 2 ? EMPTY : checkStr(expr[2], ctx)));\r\n\r\n    long num = checkItr(expr[0], ctx);\r\n    if(pic.length == 0 || num == 0) return Str.get(token(num));\r\n\r\n    // choose sign\r\n    final boolean sign = num < 0;\r\n    if(sign) num = -num;\r\n\r\n    // choose first character and case\r\n    final int ch = cp(pic, 0);\r\n    Case cs = (ch & 0x20) != 0 ? Case.LOWER : Case.STANDARD;\r\n\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    if((ch & 0xDF) == 'A') {\r\n      latin(tb, num);\r\n    } else if((ch & 0xDF) == 'I') {\r\n      roman(tb, num);\r\n    } else if((ch & 0xDF) == 'W') {\r\n      if(ch == 'W' && charAt(pic, 1) != 'w') cs = Case.UPPER;\r\n      tb.add(f.word(num, ord(pic, cs == Case.STANDARD ? 2 : 1)));\r\n    } else {\r\n      number(tb, num, pic, f);\r\n    }\r\n\r\n    // finalize formatted string\r\n    byte[] result = tb.finish();\r\n    if(sign) result = concat(new byte[] { '-' }, result);\r\n    if(cs == Case.LOWER) result = lc(result);\r\n    if(cs == Case.UPPER) result = uc(result);\r\n    return Str.get(result);\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Item atomic(final QueryContext ctx) throws QueryException {\r\n    switch(func) {\r\n      case FORMINT: return formatInt(ctx);\r\n      case FORMNUM:\r\n      case FORMDTM:\r\n      case FORMDAT:\r\n      case FORMTIM: Err.or(NOTIMPL, func.desc); return null;\r\n      default:      return super.atomic(ctx);\r\n    }\r\n  }","id":32416,"modified_method":"@Override\r\n  public Item atomic(final QueryContext ctx) throws QueryException {\r\n    switch(func) {\r\n      case FORMINT: return formatInt(ctx);\r\n      case FORMNUM: return formatNum(ctx);\r\n      case FORMDTM:\r\n      case FORMDAT:\r\n      case FORMTIM: Err.or(NOTIMPL, func.desc); return null;\r\n      default:      return super.atomic(ctx);\r\n    }\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Item atomic(final QueryContext ctx) throws QueryException {\r\n    final Item it = expr[0].atomic(ctx);\r\n    if(it == null) return null;\r\n\r\n    if(!it.u() && !it.n()) Err.num(info(), it);\r\n    final double d = it.dbl();\r\n    switch(func) {\r\n      case ABS:    return abs(it);\r\n      case CEIL:   return num(it, d, Math.ceil(d));\r\n      case FLOOR:  return num(it, d, Math.floor(d));\r\n      case RND:    return rnd(it, d, ctx, false);\r\n      case RNDHLF: return rnd(it, d, ctx, true);\r\n      default:     return super.atomic(ctx);\r\n    }\r\n  }","id":32417,"modified_method":"@Override\r\n  public Item atomic(final QueryContext ctx) throws QueryException {\r\n    final Item it = expr[0].atomic(ctx);\r\n    if(it == null) return null;\r\n\r\n    if(!it.u() && !it.n()) Err.num(info(), it);\r\n    final double d = it.dbl();\r\n    switch(func) {\r\n      case ABS:    return abs(it);\r\n      case CEIL:   return num(it, d, Math.ceil(d));\r\n      case FLOOR:  return num(it, d, Math.floor(d));\r\n      case RND:    return rnd(it, d, false, ctx);\r\n      case RNDHLF: return rnd(it, d, true, ctx);\r\n      default:     return super.atomic(ctx);\r\n    }\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a rounded item.\r\n   * @param it input item\r\n   * @param d input double value\r\n   * @param h2e half-to-even flag\r\n   * @param ctx query context\r\n   * @return absolute item\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item rnd(final Item it, final double d, final QueryContext ctx,\r\n      final boolean h2e) throws QueryException {\r\n\r\n    final int pp = expr.length == 1 ? 0 : (int) checkItr(expr[1], ctx);\r\n    if(it.type == Type.DEC && pp >= 0) {\r\n      final BigDecimal bd = it.dec();\r\n      final int m = h2e ? BigDecimal.ROUND_HALF_EVEN : bd.signum() > 0 ?\r\n          BigDecimal.ROUND_HALF_UP : BigDecimal.ROUND_HALF_DOWN;\r\n      return Dec.get(bd.setScale(pp, m));\r\n    }\r\n\r\n    // calculate precision factor\r\n    double p = 1;\r\n    for(long i = pp; i > 0; i--) p *= 10;\r\n    for(long i = pp; i < 0; i++) p /= 10;\r\n\r\n    double c = d;\r\n    if(h2e) {\r\n      c = p == 1 && (c % 2 == .5 || c % 2 == -1.5) ? c - .5 :\r\n        Math.floor(c * p + .5) / p;\r\n    } else if(d == d && d != 0 && d >= Long.MIN_VALUE && d < Long.MAX_VALUE) {\r\n      final double dp = d * p;\r\n      c = (dp >= -.5d && dp < 0 ? -0d : Math.round(dp)) / p;\r\n    }\r\n    return num(it, d, c);\r\n  }","id":32418,"modified_method":"/**\r\n   * Returns a rounded item.\r\n   * @param it input item\r\n   * @param d input double value\r\n   * @param h2e half-to-even flag\r\n   * @param ctx query context\r\n   * @return absolute item\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item rnd(final Item it, final double d, final boolean h2e,\r\n      final QueryContext ctx) throws QueryException {\r\n    final int p = expr.length == 1 ? 0 : (int) checkItr(expr[1], ctx);\r\n    return round(it, d, p, h2e);\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the absolute item.\r\n   * @param it input item\r\n   * @return absolute item\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item abs(final Item it) throws QueryException {\r\n    final double d = it.dbl();\r\n    final boolean s = d > 0d || 1 / d > 0;\r\n\r\n    switch(it.type) {\r\n      case DBL: return s ? it : Dbl.get(Math.abs(it.dbl()));\r\n      case FLT: return s ? it : Flt.get(Math.abs(it.flt()));\r\n      case DEC: return s ? it : Dec.get(it.dec().abs());\r\n      case ITR: return s ? it : Itr.get(Math.abs(it.itr()));\r\n      default:  return Itr.get(Math.abs(it.itr()));\r\n    }\r\n  }","id":32419,"modified_method":"/**\r\n   * Returns an absolute number.\r\n   * @param it input item\r\n   * @return absolute item\r\n   * @throws QueryException query exception\r\n   */\r\n  public static Item abs(final Item it) throws QueryException {\r\n    final double d = it.dbl();\r\n    final boolean s = d > 0d || 1 / d > 0;\r\n\r\n    switch(it.type) {\r\n      case DBL: return s ? it : Dbl.get(Math.abs(it.dbl()));\r\n      case FLT: return s ? it : Flt.get(Math.abs(it.flt()));\r\n      case DEC: return s ? it : Dec.get(it.dec().abs());\r\n      case ITR: return s ? it : Itr.get(Math.abs(it.itr()));\r\n      default:  return Itr.get(Math.abs(it.itr()));\r\n    }\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns an instance of this class.\r\n   * @param d value\r\n   * @return instance\r\n   */\r\n  public static Flt get(final float d) {\r\n    return d == 0 && d == 1 / 0.0 ? ZERO : new Flt(d);\r\n  }","id":32420,"modified_method":"/**\r\n   * Returns an instance of this class.\r\n   * @param f value\r\n   * @return instance\r\n   */\r\n  public static Flt get(final float f) {\r\n    return f == 0 && f == 1 / 0d ? ZERO : f != f ? NAN : new Flt(f);\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates an iterator for the specified string.\r\n   * @param str string\r\n   * @return iterator\r\n   */\r\n  static SeqIter string(final String str) {\r\n    return item(Str.get(str));\r\n  }","id":32421,"modified_method":"/**\r\n   * Creates an iterator for the specified string.\r\n   * @param str string\r\n   * @return iterator\r\n   */\r\n  static SeqIter str(final String str) {\r\n    return item(Str.get(str));\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates a container for the specified node values.\r\n   * @param nodes node values\r\n   * @return node array\r\n   */\r\n  static Nodes nodes(final int... nodes) {\r\n    return new Nodes(nodes);\r\n  }","id":32422,"modified_method":"/**\r\n   * Creates a container for the specified node values.\r\n   * @param nodes node values\r\n   * @return node array\r\n   */\r\n  static Nodes nod(final int... nodes) {\r\n    return new Nodes(nodes);\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Tests the specified instance.\r\n   * @throws BaseXException database exception\r\n   */\r\n  @Test\r\n  public void test() throws BaseXException {\r\n    final String file = doc.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n    final String name = Main.name(this);\r\n    final boolean up = this instanceof XQUPTest;\r\n    new CreateDB(name, file).execute(context);\r\n\r\n    for(final Object[] qu : queries) {\r\n      // added to renew document after each update test\r\n      if(up && ((String) qu[0]).startsWith(\"xxx\")) {\r\n        new CreateDB(name, file).execute(context);\r\n      }\r\n\r\n      final boolean correct = qu.length == 3;\r\n      final String query = qu[correct ? 2 : 1].toString();\r\n      final String cmd = qu[0] + \": \" + query;\r\n\r\n      final Command c = new XQuery(query);\r\n      try {\r\n        c.execute(context);\r\n        final Result val = c.result();\r\n        final Result cmp = correct ? (Result) qu[1] : null;\r\n        if(val instanceof Nodes && cmp instanceof Nodes) {\r\n          ((Nodes) cmp).data = ((Nodes) val).data;\r\n        }\r\n        if(!correct || !val.same(cmp)) {\r\n          fail(cmd + \": Right: \" + (correct ? qu[1] : \"error\") + \"\\n  Found: \" +\r\n              val + \"\\n\" + details());\r\n        }\r\n      } catch(final BaseXException ex) {\r\n        if(correct) fail(qu[0] + \": \" + ex.getMessage() + details());\r\n      }\r\n    }\r\n  }","id":32423,"modified_method":"/**\r\n   * Tests the specified instance.\r\n   * @throws BaseXException database exception\r\n   */\r\n  @Test\r\n  public void test() throws BaseXException {\r\n    final String file = doc.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n    final String name = Main.name(this);\r\n    final boolean up = this instanceof XQUPTest;\r\n    new CreateDB(name, file).execute(context);\r\n\r\n    final StringBuilder sb = new StringBuilder();\r\n\r\n    for(final Object[] qu : queries) {\r\n      // added to renew document after each update test\r\n      if(up && ((String) qu[0]).startsWith(\"xxx\")) {\r\n        new CreateDB(name, file).execute(context);\r\n      }\r\n\r\n      final boolean correct = qu.length == 3;\r\n      final String query = qu[correct ? 2 : 1].toString();\r\n\r\n      final Command c = new XQuery(query);\r\n      try {\r\n        c.execute(context);\r\n        final Result val = c.result();\r\n        final Result cmp = correct ? (Result) qu[1] : null;\r\n        if(val instanceof Nodes && cmp instanceof Nodes) {\r\n          ((Nodes) cmp).data = ((Nodes) val).data;\r\n        }\r\n        if(!correct || !val.same(cmp)) {\r\n          sb.append(\"-- \" + qu[0] + \": \" + query + \"\\nExpected: \" + (correct ?\r\n              qu[1] : \"error\") + \"\\nFound: \" + val + \" \" + details() + \"\\n\");\r\n        }\r\n      } catch(final BaseXException ex) {\r\n        if(correct) {\r\n          sb.append(\"-- \" + qu[0] + \": \" + query + \"\\n\" +\r\n              ex.getMessage() + \" \" + details() + \"\\n\");\r\n        }\r\n      }\r\n    }\r\n    if(sb.length() != 0) fail(\"\\n\" + sb.toString().trim());\r\n  }","commit_id":"a8bab74ac4d7271edeb65bd8cedadb3b3f21dd6b","url":"https://github.com/BaseXdb/basex"},{"original_method":"public File tempFile(File parent, String name) throws IOException {\n        String path;\n        if (parent != null) {\n            path = parent.getAbsolutePath() + File.separator + name;\n        } else {\n            path = name;\n        }\n        \n        File f = new File(path);\n        assertTrue(\"createNewFile: \" + f.getAbsolutePath(), f.createNewFile());\n        m_deleteMe.add(f);\n        return f;\n    }","id":32424,"modified_method":"public File tempFile(File parent, String name) throws IOException {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempFile(parent, name);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempDir(File parent, String name) throws IOException {\n        String path;\n        if (parent != null) {\n            path = parent.getAbsolutePath() + File.separator + name;\n        } else {\n            path = name;\n        }\n        \n        File f = new File(path);\n        assertTrue(\"mkdir: \" + f.getAbsolutePath(), f.mkdir());\n        m_deleteMe.add(f);\n        return f;\n    }","id":32425,"modified_method":"public File tempDir(File parent, String name) throws IOException {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempDir(parent, name);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempDir(String name) throws IOException {\n        return tempDir(m_tempDir, name);\n    }","id":32426,"modified_method":"public File tempDir(String name) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        return tempDir(m_tempDir, name);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempFile(String name, String contents) throws IOException {\n        return tempFile(m_tempDir, name, contents);\n    }","id":32427,"modified_method":"public File tempFile(String name, String contents) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        if (contents == null) {\n            throw new IllegalArgumentException(\"contents argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempFile(m_tempDir, name, contents);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void tearDown() {\n        try {\n            for (ListIterator i = m_deleteMe.listIterator(m_deleteMe.size());\n                 i.hasPrevious(); ) {\n                File f = (File) i.previous();\n                if (!f.delete()) {\n                    fail(\"Could not delete \" + f.getAbsolutePath()\n                         + \": is it a non-empty directory?\");\n                }\n            }\n            if (m_tempDir != null) {\n                assertFalse(m_tempDir + \" exists\", m_tempDir.exists());\n            }\n        } catch (UndeclaredThrowableException e) {\n            if (m_tempDir != null && m_tempDir.exists()) {\n                ProcessExec ex = new ProcessExec(System.out, System.err);\n                String[] cmd = new String[3];\n                cmd[0] = \"rm\";\n                cmd[1] = \"-r\";\n                cmd[2] = m_tempDir.getAbsolutePath();\n                try {\n                    ex.exec(cmd);\n                } catch (Throwable t) {\n                    // ignore\n                }\n            }\n            throw e;\n        }\n    }","id":32428,"modified_method":"public void tearDown() {\n        if (!isInitialized()) {\n            return;\n        }\n        \n        try {\n            for (ListIterator<File> i = m_deleteMe.listIterator(m_deleteMe.size()); i.hasPrevious(); ) {\n                File f = i.previous();\n                if (!f.delete()) {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"Could not delete \" + f.getAbsolutePath() + \": is it a non-empty directory?  Output from 'ls -l':\\n\");\n                    fail(b.toString());\n                }\n            }\n            if (m_tempDir != null) {\n                assertFalse(m_tempDir + \" exists\", m_tempDir.exists());\n            }\n        } catch (UndeclaredThrowableException e) {\n            if (m_tempDir != null && m_tempDir.exists()) {\n                ProcessExec ex = new ProcessExec(System.out, System.err);\n                String[] cmd = new String[3];\n                cmd[0] = \"rm\";\n                cmd[1] = \"-r\";\n                cmd[2] = m_tempDir.getAbsolutePath();\n                try {\n                    ex.exec(cmd);\n                } catch (Throwable t) {\n                    // ignore\n                }\n            }\n            throw e;\n        }\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File expecting(File parent, String name) {\n        String path;\n        if (parent != null) {\n            path = parent.getAbsolutePath() + File.separator + name;\n        } else {\n            path = name;\n        }\n        \n        File f = new File(path);\n        m_expecting.add(f);\n        return f;\n    }","id":32429,"modified_method":"public File expecting(File parent, String name) {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        \n        assertInitialized();\n\n        return internalExpecting(parent, name);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File getTempDir() {\n        return m_tempDir;\n    }","id":32430,"modified_method":"public File getTempDir() {\n        assertInitialized();\n        \n        return m_tempDir;\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempFile(File parent, String name, String contents)\n        throws IOException {\n        File f = tempFile(parent, name);\n        PrintWriter w = new PrintWriter(new FileWriter(f));\n        w.print(contents);\n        w.close();\n        return f;\n    }","id":32431,"modified_method":"public File tempFile(File parent, String name, String contents) throws IOException {\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent argument cannot be null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n        if (contents == null) {\n            throw new IllegalArgumentException(\"contents argument cannot be null\");\n        }\n        \n        assertInitialized();\n        \n        return internalTempFile(parent, name, contents);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void deleteExpected() {\n        for (ListIterator i = m_expecting.listIterator(m_expecting.size());\n             i.hasPrevious(); ) {\n            File f = (File) i.previous();\n            assertTrue(\"\\\"\" + f.getAbsolutePath() + \"\\\" deleted\", f.delete());\n            i.remove();\n        }\n        assertEquals(\"No expected files left over\", m_expecting.size(), 0);\n    }","id":32432,"modified_method":"public void deleteExpected() {\n        assertInitialized();\n\n        for (ListIterator<File> i = m_expecting.listIterator(m_expecting.size()); i.hasPrevious(); ) {\n            File f = i.previous();\n            assertTrue(\"\\\"\" + f.getAbsolutePath() + \"\\\" deleted\", f.delete());\n            i.remove();\n        }\n        assertEquals(\"No expected files left over\", m_expecting.size(), 0);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public FileAnticipator() throws IOException {\n        createTempDir();\n    }","id":32433,"modified_method":"public FileAnticipator() throws IOException {\n        this(true);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public File tempFile(String name) throws IOException {\n        return tempFile(m_tempDir, name);\n    }","id":32434,"modified_method":"public File tempFile(String name) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name argument cannot be null\");\n        }\n\n        assertInitialized();\n\n        return internalTempFile(m_tempDir, name);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testConstructor() {\n        // Empty... this effectively tests that setUp() works.\n    }","id":32435,"modified_method":"public void testConstructor() {\n        // Empty... this effectively tests that setUp() works.\n        assertTrue(\"anticipator should be initialized, but said it wasn't\", m_anticipator.isInitialized());\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testExpecting() {\n        String file = \"/FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n        m_anticipator.expecting(null, file);\n    }","id":32436,"modified_method":"public void testExpecting() {\n        String file = \"/FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n        m_anticipator.expecting(file);\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testTempFile() throws IOException {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        m_anticipator.tempFile(file);\n        m_anticipator.deleteExpected();\n    }","id":32437,"modified_method":"public void testTempFile() throws Exception {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        File f = m_anticipator.tempFile(file);\n        assertEquals(\"temporary file name\", m_anticipator.getTempDir() + File.separator + file, f.getAbsolutePath());\n        assertTrue(\"temporary file should exist at \" + f.getAbsolutePath(), f.isFile());\n        m_anticipator.deleteExpected();\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testTempFileContents() throws IOException {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        String contents = \"yay!\";\n        File yay = m_anticipator.tempFile(file, contents);\n        \n        StringBuffer b = new StringBuffer();\n        FileInputStream is = new FileInputStream(yay);\n        int i;\n        while ((i = is.read()) != -1) {\n            b.append(new Character((char) i));\n        }\n        is.close();\n        \n        assertEquals(\"file contents\", contents, b.toString());\n        \n        m_anticipator.deleteExpected();\n    }","id":32438,"modified_method":"public void testTempFileWithContents() throws Exception {\n        String file = \"FileAnticipatorTest_tempFile_\" + System.currentTimeMillis();\n        String contents = \"yay!\";\n        File f = m_anticipator.tempFile(file, contents);\n        assertEquals(\"temporary file name\", m_anticipator.getTempDir() + File.separator + file, f.getAbsolutePath());\n        assertTrue(\"temporary file should exist at \" + f.getAbsolutePath(), f.isFile());\n        \n        StringBuffer b = new StringBuffer();\n        FileInputStream is = new FileInputStream(f);\n        int i;\n        while ((i = is.read()) != -1) {\n            b.append(new Character((char) i));\n        }\n        is.close();\n        \n        assertEquals(\"file contents\", contents, b.toString());\n        \n        m_anticipator.deleteExpected();\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testExpectingDeleteExpectedBogus() {\n        String file = \"/FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n        String expected = \"\\\"\" + file + \"\\\" deleted\";\n                \n        try {\n            m_anticipator.expecting(null, file);\n            m_anticipator.deleteExpected();\n        } catch (Throwable t) {\n            if (expected.equals(t.getMessage())) {\n                return; // This is the exception we were expecting\n            }\n            fail(\"Received unexpected exception.  Was expecting:\\n\" + expected +\n                 \"\\nReceived:\\n\" + t.getMessage());\n        }\n        fail(\"Did not receive excpected exception\");\n    }","id":32439,"modified_method":"public void testExpectingDeleteExpectedBogus() {\n        String file = \"FileAnticipatorTest_bogus_\" + System.currentTimeMillis();\n\n        ThrowableAnticipator ta = new ThrowableAnticipator();\n        ta.anticipate(new AssertionFailedError(\"\\\"\" + m_anticipator.getTempDir() + File.separator + file + \"\\\" deleted\"));\n\n        m_anticipator.expecting(file);\n\n        try {\n            m_anticipator.deleteExpected();\n        } catch (Throwable t) {\n            ta.throwableReceived(t);\n        }\n        ta.verifyAnticipated();\n\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testTempDir() throws IOException {\n        String file = \"FileAnticipatorTest_tempDir_\" + System.currentTimeMillis();\n        m_anticipator.tempDir(file);\n        m_anticipator.deleteExpected();\n    }","id":32440,"modified_method":"public void testTempDir() throws Exception {\n        String file = \"FileAnticipatorTest_tempDir_\" + System.currentTimeMillis();\n        File f = m_anticipator.tempDir(file);\n        assertEquals(\"temporary directory name\", m_anticipator.getTempDir() + File.separator + file, f.getAbsolutePath());\n        assertTrue(\"temporary directory should exist at \" + f.getAbsolutePath(), f.isDirectory());\n        m_anticipator.deleteExpected();\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testExpectingDeleteExpected() throws IOException {\n        String file = \"FileAnticipatorTest_\" + System.currentTimeMillis();\n        File tempFile = m_anticipator.expecting(null, file);\n        assertTrue(\"createNewFile: \" + tempFile.getAbsolutePath(),\n                   tempFile.createNewFile());\n        m_anticipator.deleteExpected();\n    }","id":32441,"modified_method":"public void testExpectingDeleteExpected() throws Exception {\n        String file = \"FileAnticipatorTest_\" + System.currentTimeMillis();\n        File tempFile = m_anticipator.expecting(file);\n        assertTrue(\"createNewFile: \" + tempFile.getAbsolutePath(),\n                   tempFile.createNewFile());\n        m_anticipator.deleteExpected();\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setUp() throws IOException {\n        m_anticipator = new FileAnticipator();\n    }","id":32442,"modified_method":"public void setUp() throws Exception {\n        m_anticipator = new FileAnticipator();\n    }","commit_id":"9b3a2b77b9e1bc270a6d4f041dce8142e3f85719","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public UpdateRequest normalize(RuleDto rule) {\n    try {\n      XContentBuilder document = jsonBuilder().startObject();\n      indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n      indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n      indexField(RuleField.NAME.key(), rule.getName(), document);\n      indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n      indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n      indexField(RuleField.HTML_DESCRIPTION.key(), rule.getDescription(), document);\n      indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n      indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n      indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n      indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n      indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n      document.startArray(RuleField.TAGS.key()).endArray();\n      document.startArray(RuleField.SYSTEM_TAGS.key()).endArray();\n      document.startObject(RuleField.PARAMS.key()).endObject();\n      document.startObject(RuleField.ACTIVE.key()).endObject();\n\n    /* Done normalizing for Rule */\n      document.endObject();\n\n    /* Creating updateRequest */\n      UpdateRequest request = new UpdateRequest().doc(document);\n      request.docAsUpsert(true);\n      return request;\n    } catch (Exception e) {\n      throw new IllegalStateException(String.format(\"Could not normalize RuleDto with key %s\", rule.getKey().toString()), e);\n    }\n  }","id":32443,"modified_method":"@Override\n  public UpdateRequest normalize(RuleDto rule) {\n    try {\n      XContentBuilder document = jsonBuilder().startObject();\n      indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n      indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n      indexField(RuleField.NAME.key(), rule.getName(), document);\n      indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n      indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n      indexField(RuleField.HTML_DESCRIPTION.key(), rule.getDescription(), document);\n      indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n      indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n      indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n      indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n      indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n      document.array(RuleField.TAGS.key(), rule.getTags());\n      document.array(RuleField.SYSTEM_TAGS.key(), rule.getSystemTags());\n      document.startObject(RuleField.PARAMS.key()).endObject();\n      document.startObject(RuleField.ACTIVE.key()).endObject();\n\n    /* Done normalizing for Rule */\n      document.endObject();\n\n    /* Creating updateRequest */\n      UpdateRequest request = new UpdateRequest().doc(document);\n      request.docAsUpsert(true);\n      return request;\n    } catch (Exception e) {\n      throw new IllegalStateException(String.format(\"Could not normalize RuleDto with key %s\", rule.getKey().toString()), e);\n    }\n  }","commit_id":"571284bed52c0b263fd5ce2e17de3a1466fc7e9e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private RuleDto newRuleDto(RuleKey ruleKey) {\n    return new RuleDto()\n      .setRuleKey(ruleKey.rule())\n      .setRepositoryKey(ruleKey.repository())\n      .setName(\"Rule \" + ruleKey.rule())\n      .setDescription(\"Description \" + ruleKey.rule())\n      .setStatus(RuleStatus.READY.toString())\n      .setConfigKey(\"InternalKey\" + ruleKey.rule())\n      .setSeverity(Severity.INFO)\n      .setCardinality(Cardinality.SINGLE)\n      .setLanguage(\"js\")\n      .setRemediationFunction(\"linear\")\n      .setDefaultRemediationFunction(\"linear_offset\")\n      .setRemediationCoefficient(\"1h\")\n      .setDefaultRemediationCoefficient(\"5d\")\n      .setRemediationOffset(\"5min\")\n      .setDefaultRemediationOffset(\"10h\")\n      .setEffortToFixDescription(ruleKey.repository() + \".\" + ruleKey.rule() + \".effortToFix\")\n      .setCreatedAt(DateUtils.parseDate(\"2013-12-16\"))\n      .setUpdatedAt(DateUtils.parseDate(\"2013-12-17\"));\n  }","id":32444,"modified_method":"private RuleDto newRuleDto(RuleKey ruleKey) {\n    return new RuleDto()\n      .setRuleKey(ruleKey.rule())\n      .setRepositoryKey(ruleKey.repository())\n      .setName(\"Rule \" + ruleKey.rule())\n      .setDescription(\"Description \" + ruleKey.rule())\n      .setStatus(RuleStatus.READY.toString())\n      .setConfigKey(\"InternalKey\" + ruleKey.rule())\n      .setSeverity(Severity.INFO)\n      .setCardinality(Cardinality.SINGLE)\n      .setLanguage(\"js\")\n      .setRemediationFunction(\"linear\")\n      .setDefaultRemediationFunction(\"linear_offset\")\n      .setRemediationCoefficient(\"1h\")\n      .setDefaultRemediationCoefficient(\"5d\")\n      .setRemediationOffset(\"5min\")\n      .setDefaultRemediationOffset(\"10h\")\n      .setEffortToFixDescription(ruleKey.repository() + \".\" + ruleKey.rule() + \".effortToFix\")\n      .setTags(new String[]{\"tag1\", \"tag2\"})\n      .setSystemTags(new String[]{\"systag1\", \"systag2\"})\n      .setCreatedAt(DateUtils.parseDate(\"2013-12-16\"))\n      .setUpdatedAt(DateUtils.parseDate(\"2013-12-17\"));\n  }","commit_id":"571284bed52c0b263fd5ce2e17de3a1466fc7e9e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void insert_in_db_and_index_in_es() {\n    // insert db\n    RuleKey ruleKey = RuleKey.of(\"javascript\", \"S001\");\n    dao.insert(newRuleDto(ruleKey), dbSession);\n    dbSession.commit();\n\n    // verify that rule is persisted in db\n    RuleDto persistedDto = dao.getByKey(ruleKey, dbSession);\n    assertThat(persistedDto).isNotNull();\n    assertThat(persistedDto.getId()).isGreaterThanOrEqualTo(0);\n    assertThat(persistedDto.getRuleKey()).isEqualTo(ruleKey.rule());\n    assertThat(persistedDto.getLanguage()).isEqualTo(\"js\");\n\n    // verify that rule is indexed in es\n    index.refresh();\n    Rule hit = index.getByKey(ruleKey);\n    assertThat(hit).isNotNull();\n    assertThat(hit.key().repository()).isEqualTo(ruleKey.repository());\n    assertThat(hit.key().rule()).isEqualTo(ruleKey.rule());\n    assertThat(hit.language()).isEqualTo(\"js\");\n    assertThat(hit.name()).isEqualTo(\"Rule S001\");\n    assertThat(hit.htmlDescription()).isEqualTo(\"Description S001\");\n    assertThat(hit.status()).isEqualTo(RuleStatus.READY);\n    //TODO fix date in ES\n//    assertThat(hit.createdAt()).isNotNull();\n//    assertThat(hit.updatedAt()).isNotNull();\n    assertThat(hit.internalKey()).isEqualTo(\"InternalKeyS001\");\n    assertThat(hit.severity()).isEqualTo(\"INFO\");\n    assertThat(hit.template()).isFalse();\n\n    //TODO    assertThat((Collection) hit.getField(RuleNormalizer.RuleField.SYSTEM_TAGS.key())).isEmpty();\n    //TODO    assertThat((Collection) hit.getField(RuleNormalizer.RuleField.TAGS.key())).isEmpty();\n\n  }","id":32445,"modified_method":"@Test\n  public void insert_in_db_and_index_in_es() {\n    // insert db\n    RuleKey ruleKey = RuleKey.of(\"javascript\", \"S001\");\n    dao.insert(newRuleDto(ruleKey), dbSession);\n    dbSession.commit();\n\n    // verify that rule is persisted in db\n    RuleDto persistedDto = dao.getByKey(ruleKey, dbSession);\n    assertThat(persistedDto).isNotNull();\n    assertThat(persistedDto.getId()).isGreaterThanOrEqualTo(0);\n    assertThat(persistedDto.getRuleKey()).isEqualTo(ruleKey.rule());\n    assertThat(persistedDto.getLanguage()).isEqualTo(\"js\");\n    assertThat(persistedDto.getTags()).containsOnly(\"tag1\", \"tag2\");\n    assertThat(persistedDto.getSystemTags()).containsOnly(\"systag1\", \"systag2\");\n\n    // verify that rule is indexed in es\n    index.refresh();\n    Rule hit = index.getByKey(ruleKey);\n    assertThat(hit).isNotNull();\n    assertThat(hit.key().repository()).isEqualTo(ruleKey.repository());\n    assertThat(hit.key().rule()).isEqualTo(ruleKey.rule());\n    assertThat(hit.language()).isEqualTo(\"js\");\n    assertThat(hit.name()).isEqualTo(\"Rule S001\");\n    assertThat(hit.htmlDescription()).isEqualTo(\"Description S001\");\n    assertThat(hit.status()).isEqualTo(RuleStatus.READY);\n    //TODO fix date in ES\n//    assertThat(hit.createdAt()).isNotNull();\n//    assertThat(hit.updatedAt()).isNotNull();\n    assertThat(hit.internalKey()).isEqualTo(\"InternalKeyS001\");\n    assertThat(hit.severity()).isEqualTo(\"INFO\");\n    assertThat(hit.template()).isFalse();\n    assertThat(hit.tags()).containsOnly(\"tag1\", \"tag2\");\n    assertThat(hit.systemTags()).containsOnly(\"systag1\", \"systag2\");\n\n  }","commit_id":"571284bed52c0b263fd5ce2e17de3a1466fc7e9e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private boolean mergeTags(RulesDefinition.Rule ruleDef, RuleDto dto) {\n    boolean changed = false;\n\n    if (RuleStatus.REMOVED == ruleDef.status()) {\n      dto.setSystemTags(Collections.EMPTY_SET);\n      changed = true;\n    } else if (!dto.getSystemTags().containsAll(ruleDef.tags())) {\n      dto.setSystemTags(ruleDef.tags());\n      // remove end-user tags that are now declared as system\n      RuleTagHelper.applyTags(dto, ImmutableSet.copyOf(dto.getTags()));\n      changed = true;\n    }\n    return changed;\n  }","id":32446,"modified_method":"private boolean mergeTags(RulesDefinition.Rule ruleDef, RuleDto dto) {\n    boolean changed = false;\n\n    if (RuleStatus.REMOVED == ruleDef.status()) {\n      dto.setSystemTags(Collections.<String>emptySet());\n      changed = true;\n    } else if (!dto.getSystemTags().containsAll(ruleDef.tags())) {\n      dto.setSystemTags(ruleDef.tags());\n      // remove end-user tags that are now declared as system\n      RuleTagHelper.applyTags(dto, ImmutableSet.copyOf(dto.getTags()));\n      changed = true;\n    }\n    return changed;\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private RuleKey createCustomRule(NewRule newRule, RuleDto templateRuleDto, DbSession dbSession){\n    RuleKey ruleKey = RuleKey.of(templateRuleDto.getRepositoryKey(), templateRuleDto.getRuleKey() + \"_\" + system.now());\n    RuleDto ruleDto = RuleDto.createFor(ruleKey)\n      .setConfigKey(templateRuleDto.getConfigKey())\n      .setName(newRule.name())\n      .setDescription(newRule.htmlDescription())\n      .setSeverity(newRule.severity())\n      .setCardinality(Cardinality.SINGLE)\n      .setStatus(newRule.status())\n      .setLanguage(templateRuleDto.getLanguage())\n      .setDefaultSubCharacteristicId(templateRuleDto.getDefaultSubCharacteristicId())\n      .setDefaultRemediationFunction(templateRuleDto.getDefaultRemediationFunction())\n      .setDefaultRemediationCoefficient(templateRuleDto.getDefaultRemediationCoefficient())\n      .setDefaultRemediationOffset(templateRuleDto.getDefaultRemediationOffset())\n      .setEffortToFixDescription(templateRuleDto.getEffortToFixDescription());\n    dbClient.ruleDao().insert(dbSession, ruleDto);\n\n    // TODO add tags from template rule\n\n    for (RuleParamDto templateRuleParamDto : dbClient.ruleDao().findRuleParamsByRuleKey(dbSession, templateRuleDto.getKey())) {\n      NewRuleParam newRuleParam = newRule.param(templateRuleParamDto.getName());\n      if (newRuleParam == null) {\n        throw new IllegalArgumentException(String.format(\"The parameter '%s' has not been set\", templateRuleParamDto.getName()));\n      }\n      createCustomRuleParams(newRuleParam, ruleDto, templateRuleParamDto, dbSession);\n    }\n    return ruleKey;\n  }","id":32447,"modified_method":"private RuleKey createCustomRule(NewRule newRule, RuleDto templateRuleDto, DbSession dbSession){\n    RuleKey ruleKey = RuleKey.of(templateRuleDto.getRepositoryKey(), templateRuleDto.getRuleKey() + \"_\" + system.now());\n    RuleDto ruleDto = RuleDto.createFor(ruleKey)\n      .setConfigKey(templateRuleDto.getConfigKey())\n      .setName(newRule.name())\n      .setDescription(newRule.htmlDescription())\n      .setSeverity(newRule.severity())\n      .setCardinality(Cardinality.SINGLE)\n      .setStatus(newRule.status())\n      .setLanguage(templateRuleDto.getLanguage())\n      .setDefaultSubCharacteristicId(templateRuleDto.getDefaultSubCharacteristicId())\n      .setDefaultRemediationFunction(templateRuleDto.getDefaultRemediationFunction())\n      .setDefaultRemediationCoefficient(templateRuleDto.getDefaultRemediationCoefficient())\n      .setDefaultRemediationOffset(templateRuleDto.getDefaultRemediationOffset())\n      .setEffortToFixDescription(templateRuleDto.getEffortToFixDescription())\n      .setTags(templateRuleDto.getTags())\n      .setSystemTags(templateRuleDto.getSystemTags());\n    dbClient.ruleDao().insert(dbSession, ruleDto);\n\n    for (RuleParamDto templateRuleParamDto : dbClient.ruleDao().findRuleParamsByRuleKey(dbSession, templateRuleDto.getKey())) {\n      NewRuleParam newRuleParam = newRule.param(templateRuleParamDto.getName());\n      if (newRuleParam == null) {\n        throw new IllegalArgumentException(String.format(\"The parameter '%s' has not been set\", templateRuleParamDto.getName()));\n      }\n      createCustomRuleParams(newRuleParam, ruleDto, templateRuleParamDto, dbSession);\n    }\n    return ruleKey;\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public RuleCreator(RuleIndex index, DbClient dbClient, System2 system) {\n    this.index = index;\n    this.dbClient = dbClient;\n    this.system = system;\n  }","id":32448,"modified_method":"public RuleCreator(DbClient dbClient, System2 system) {\n    this.dbClient = dbClient;\n    this.system = system;\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Rule create(NewRule newRule) {\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      RuleKey templateKey = newRule.templateKey();\n      if (templateKey != null) {\n        RuleDto templateRule = dbClient.ruleDao().getByKey(dbSession, newRule.templateKey());\n        if (templateRule == null) {\n          throw new IllegalArgumentException(\"Template rule does not exists: \" + templateKey.toString());\n        }\n        if (!Cardinality.MULTIPLE.equals(templateRule.getCardinality())) {\n          throw new IllegalArgumentException(\"This rule is not a template rule: \" + templateKey.toString());\n        }\n        RuleKey customRuleKey = createCustomRule(newRule, templateRule, dbSession);\n        dbSession.commit();\n        return index.getByKey(customRuleKey);\n      }\n      throw new IllegalArgumentException(\"Not supported\");\n    } finally {\n      dbSession.close();\n    }\n  }","id":32449,"modified_method":"public RuleKey create(NewRule newRule) {\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      RuleKey templateKey = newRule.templateKey();\n      if (templateKey != null) {\n        RuleDto templateRule = dbClient.ruleDao().getByKey(dbSession, newRule.templateKey());\n        if (!Cardinality.MULTIPLE.equals(templateRule.getCardinality())) {\n          throw new IllegalArgumentException(\"This rule is not a template rule: \" + templateKey.toString());\n        }\n        validateRule(newRule);\n        RuleKey customRuleKey = createCustomRule(newRule, templateRule, dbSession);\n        dbSession.commit();\n        return customRuleKey;\n      }\n      throw new IllegalArgumentException(\"Not supported\");\n    } finally {\n      dbSession.close();\n    }\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_a_param_is_missing() throws Exception {\n    // TODO\n  }","id":32450,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_a_param_is_missing() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY);\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The parameter 'regex' has not been set\");\n    }\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_no_param() throws Exception {\n    // TODO\n  }","id":32451,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_name() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without name\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParams(newArrayList(new NewRuleParam(\"regex\").setDefaultValue(\"a.*\")));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The name is missing\");\n    }\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_custom_rule() throws Exception {\n    // insert template rule\n    RuleKey key = RuleKey.of(\"java\", \"S001\");\n    RuleDto templateRule = dao.insert(dbSession,\n      RuleTesting.newDto(key).setCardinality(Cardinality.MULTIPLE).setLanguage(\"java\")\n    );\n    RuleParamDto ruleParamDto = RuleParamDto.createFor(templateRule).setName(\"regex\").setType(\"STRING\").setDescription(\"Reg ex\").setDefaultValue(\".*\");\n    dao.addRuleParam(dbSession, templateRule, ruleParamDto);\n    dbSession.commit();\n\n    NewRule newRule = new NewRule()\n      .setTemplateKey(key)\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParams(newArrayList(new NewRuleParam(\"regex\").setDefaultValue(\"a.*\")));\n    Rule result = creator.create(newRule);\n\n    dbSession.clearCache();\n\n    RuleDto rule = db.ruleDao().getNullableByKey(dbSession, result.key());\n    assertThat(rule).isNotNull();\n    assertThat(rule.getName()).isEqualTo(\"My custom\");\n    assertThat(rule.getDescription()).isEqualTo(\"Some description\");\n    assertThat(rule.getSeverityString()).isEqualTo(\"MAJOR\");\n    assertThat(rule.getStatus()).isEqualTo(RuleStatus.READY);\n    assertThat(rule.getLanguage()).isEqualTo(\"java\");\n\n    List<RuleParamDto> params = db.ruleDao().findRuleParamsByRuleKey(dbSession, result.key());\n    assertThat(params).hasSize(1);\n  }","id":32452,"modified_method":"@Test\n  public void create_custom_rule() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParams(newArrayList(new NewRuleParam(\"regex\").setDefaultValue(\"a.*\")));\n    RuleKey customRuleKey = creator.create(newRule);\n\n    dbSession.clearCache();\n\n    RuleDto rule = db.ruleDao().getNullableByKey(dbSession, customRuleKey);\n    assertThat(rule).isNotNull();\n    assertThat(rule.getName()).isEqualTo(\"My custom\");\n    assertThat(rule.getDescription()).isEqualTo(\"Some description\");\n    assertThat(rule.getSeverityString()).isEqualTo(\"MAJOR\");\n    assertThat(rule.getStatus()).isEqualTo(RuleStatus.READY);\n    assertThat(rule.getLanguage()).isEqualTo(\"java\");\n    assertThat(rule.getConfigKey()).isEqualTo(\"S001\");\n    assertThat(rule.getDefaultSubCharacteristicId()).isEqualTo(1);\n    assertThat(rule.getDefaultRemediationFunction()).isEqualTo(\"LINEAR_OFFSET\");\n    assertThat(rule.getDefaultRemediationCoefficient()).isEqualTo(\"1h\");\n    assertThat(rule.getDefaultRemediationOffset()).isEqualTo(\"5min\");\n    assertThat(rule.getEffortToFixDescription()).isEqualTo(\"desc\");\n    assertThat(rule.getTags()).containsOnly(\"usertag1\", \"usertag2\");\n    assertThat(rule.getSystemTags()).containsOnly(\"tag1\", \"tag4\");\n\n    List<RuleParamDto> params = db.ruleDao().findRuleParamsByRuleKey(dbSession, customRuleKey);\n    assertThat(params).hasSize(1);\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_rule_template_does_not_exists() throws Exception {\n    // TODO\n  }","id":32453,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_description() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without description\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParams(newArrayList(new NewRuleParam(\"regex\").setDefaultValue(\"a.*\")));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The description is missing\");\n    }\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_wrong_rule_template() throws Exception {\n    // TODO\n  }","id":32454,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_wrong_rule_template() throws Exception {\n    // insert rule\n    RuleDto rule = dao.insert(dbSession,\n      RuleTesting.newDto(RuleKey.of(\"java\", \"S001\"))\n        .setCardinality(Cardinality.SINGLE));\n    dbSession.commit();\n\n    // Create custom rule with unknown template rule\n    NewRule newRule = new NewRule()\n      .setTemplateKey(rule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParams(newArrayList(new NewRuleParam(\"regex\").setDefaultValue(\"a.*\")));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"This rule is not a template rule: java:S001\");\n    }\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_mandatory_fields() throws Exception {\n    // TODO\n  }","id":32455,"modified_method":"@Test\n  public void fail_to_create_custom_rule_when_missing_status() throws Exception {\n    // insert template rule\n    RuleDto templateRule = createTemplateRule();\n\n    // Create custom rule without description\n    NewRule newRule = new NewRule()\n      .setTemplateKey(templateRule.getKey())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setParams(newArrayList(new NewRuleParam(\"regex\").setDefaultValue(\"a.*\")));\n\n    try {\n      creator.create(newRule);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessage(\"The status is missing\");\n    }\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public RuleService(RuleIndex index, RuleUpdater ruleUpdater) {\n    this.index = index;\n    this.ruleUpdater = ruleUpdater;\n  }","id":32456,"modified_method":"public RuleService(RuleIndex index, RuleUpdater ruleUpdater, RuleCreator ruleCreator) {\n    this.index = index;\n    this.ruleUpdater = ruleUpdater;\n    this.ruleCreator = ruleCreator;\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void startLevel4Components(ComponentContainer pico) {\n    pico.addSingleton(PluginDownloader.class);\n    pico.addSingleton(ChartFactory.class);\n    pico.addSingleton(Languages.class);\n    pico.addSingleton(Views.class);\n    pico.addSingleton(CodeColorizers.class);\n    pico.addSingleton(ResourceTypes.class);\n    pico.addSingleton(SettingsChangeNotifier.class);\n    pico.addSingleton(PageDecorations.class);\n    pico.addSingleton(PreviewCache.class);\n    pico.addSingleton(DefaultResourcePermissions.class);\n    pico.addSingleton(Periods.class);\n    pico.addSingleton(ServerWs.class);\n\n    // update center\n    pico.addSingleton(UpdateCenterClient.class);\n    pico.addSingleton(UpdateCenterMatrixFactory.class);\n    pico.addSingleton(UpdateCenterWs.class);\n\n    // quality profile\n    pico.addSingleton(XMLProfileParser.class);\n    pico.addSingleton(XMLProfileSerializer.class);\n    pico.addComponent(ProfilesDao.class, false);\n    pico.addComponent(ProfilesManager.class, false);\n    pico.addSingleton(AnnotationProfileParser.class);\n    pico.addSingleton(QProfiles.class);\n    pico.addSingleton(QProfileLookup.class);\n    pico.addSingleton(QProfileOperations.class);\n    pico.addSingleton(QProfileActiveRuleOperations.class);\n    pico.addSingleton(QProfileProjectOperations.class);\n    pico.addSingleton(QProfileProjectLookup.class);\n    pico.addSingleton(QProfileBackup.class);\n    pico.addSingleton(QProfileRepositoryExporter.class);\n    pico.addSingleton(DefaultProfilesCache.class);\n    pico.addSingleton(QProfileRecreateBuiltInAction.class);\n    pico.addSingleton(QProfilesWs.class);\n    pico.addSingleton(ProfilesWs.class);\n    pico.addSingleton(RuleActivationActions.class);\n    pico.addSingleton(BulkRuleActivationActions.class);\n    pico.addSingleton(RuleActivator.class);\n    pico.addSingleton(QProfileService.class);\n    pico.addSingleton(RuleActivationContextFactory.class);\n    pico.addSingleton(QProfileCopier.class);\n    pico.addSingleton(QProfileBackuper.class);\n\n    // rule\n    pico.addSingleton(AnnotationRuleParser.class);\n    pico.addSingleton(XMLRuleParser.class);\n    pico.addComponent(RulesDao.class, false);\n    pico.addSingleton(DefaultRuleFinder.class);\n    pico.addSingleton(RuleOperations.class);\n    pico.addSingleton(RubyRuleService.class);\n    pico.addSingleton(RuleRepositories.class);\n    pico.addSingleton(DeprecatedRulesDefinition.class);\n    pico.addSingleton(RuleDefinitionsLoader.class);\n    pico.addSingleton(RulesDefinitionXmlLoader.class);\n    pico.addSingleton(RuleService.class);\n    pico.addSingleton(RuleUpdater.class);\n    pico.addSingleton(RuleCreator.class);\n    pico.addSingleton(UpdateAction.class);\n    pico.addSingleton(RulesWebService.class);\n    pico.addSingleton(SearchAction.class);\n    pico.addSingleton(org.sonar.server.rule.ws.ShowAction.class);\n    pico.addSingleton(TagsAction.class);\n    pico.addSingleton(RuleMapping.class);\n    pico.addSingleton(ActiveRuleCompleter.class);\n    pico.addSingleton(AppAction.class);\n\n    // measure\n    pico.addComponent(MeasuresDao.class, false);\n    pico.addSingleton(MeasureFilterFactory.class);\n    pico.addSingleton(MeasureFilterExecutor.class);\n    pico.addSingleton(MeasureFilterEngine.class);\n    pico.addSingleton(DefaultMetricFinder.class);\n    pico.addSingleton(ServerLifecycleNotifier.class);\n    pico.addSingleton(TimeMachineWs.class);\n\n    // quality gates\n    pico.addSingleton(QualityGateDao.class);\n    pico.addSingleton(QualityGateConditionDao.class);\n    pico.addSingleton(QualityGates.class);\n    pico.addSingleton(ProjectQgateAssociationDao.class);\n    pico.addSingleton(QgateProjectFinder.class);\n\n    pico.addSingleton(QGatesListAction.class);\n    pico.addSingleton(QGatesSearchAction.class);\n    pico.addSingleton(QGatesShowAction.class);\n    pico.addSingleton(QGatesCreateAction.class);\n    pico.addSingleton(QGatesRenameAction.class);\n    pico.addSingleton(QGatesCopyAction.class);\n    pico.addSingleton(QGatesDestroyAction.class);\n    pico.addSingleton(QGatesSetAsDefaultAction.class);\n    pico.addSingleton(QGatesUnsetDefaultAction.class);\n    pico.addSingleton(QGatesSelectAction.class);\n    pico.addSingleton(QGatesDeselectAction.class);\n    pico.addSingleton(QGatesCreateConditionAction.class);\n    pico.addSingleton(QGatesDeleteConditionAction.class);\n    pico.addSingleton(QGatesUpdateConditionAction.class);\n    pico.addSingleton(QGatesAppAction.class);\n    pico.addSingleton(QGatesWs.class);\n\n    // web services\n    pico.addSingleton(WebServiceEngine.class);\n    pico.addSingleton(ListingWs.class);\n\n    // localization\n    pico.addSingleton(L10nWs.class);\n\n    // authentication\n    pico.addSingleton(AuthenticationWs.class);\n\n    // users\n    pico.addSingleton(SecurityRealmFactory.class);\n    pico.addSingleton(HibernateUserFinder.class);\n    pico.addSingleton(NewUserNotifier.class);\n    pico.addSingleton(DefaultUserFinder.class);\n    pico.addSingleton(DefaultUserService.class);\n    pico.addSingleton(UsersWs.class);\n\n    // groups\n    pico.addSingleton(GroupMembershipService.class);\n    pico.addSingleton(GroupMembershipFinder.class);\n\n    // permissions\n    pico.addSingleton(PermissionFacade.class);\n    pico.addSingleton(InternalPermissionService.class);\n    pico.addSingleton(InternalPermissionTemplateService.class);\n    pico.addSingleton(PermissionFinder.class);\n    pico.addSingleton(PermissionsWs.class);\n\n    // components\n    pico.addSingleton(DefaultComponentFinder.class);\n    pico.addSingleton(DefaultRubyComponentService.class);\n    pico.addSingleton(ComponentDao.class);\n    pico.addSingleton(ResourcesWs.class);\n    pico.addSingleton(ComponentsWs.class);\n    pico.addSingleton(ProjectsWs.class);\n    pico.addSingleton(ComponentAppAction.class);\n\n    // issues\n    pico.addSingleton(ServerIssueStorage.class);\n    pico.addSingleton(IssueUpdater.class);\n    pico.addSingleton(FunctionExecutor.class);\n    pico.addSingleton(IssueWorkflow.class);\n    pico.addSingleton(IssueService.class);\n    pico.addSingleton(IssueCommentService.class);\n    pico.addSingleton(DefaultIssueFinder.class);\n    pico.addSingleton(IssueStatsFinder.class);\n    pico.addSingleton(PublicRubyIssueService.class);\n    pico.addSingleton(InternalRubyIssueService.class);\n    pico.addSingleton(IssueChangelogService.class);\n    pico.addSingleton(IssueNotifications.class);\n    pico.addSingleton(ActionService.class);\n    pico.addSingleton(Actions.class);\n    pico.addSingleton(IssueBulkChangeService.class);\n    pico.addSingleton(IssueChangelogFormatter.class);\n    pico.addSingleton(IssuesWs.class);\n    pico.addSingleton(IssueShowAction.class);\n    pico.addSingleton(IssueSearchAction.class);\n    pico.addSingleton(IssueActionsWriter.class);\n\n    // issue filters\n    pico.addSingleton(IssueFilterService.class);\n    pico.addSingleton(IssueFilterSerializer.class);\n    pico.addSingleton(IssueFilterWs.class);\n    pico.addSingleton(IssueFilterWriter.class);\n    pico.addSingleton(org.sonar.server.issue.filter.AppAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.ShowAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.FavoritesAction.class);\n\n    // action plan\n    pico.addSingleton(ActionPlanWs.class);\n    pico.addSingleton(ActionPlanService.class);\n\n    // issues actions\n    pico.addSingleton(AssignAction.class);\n    pico.addSingleton(PlanAction.class);\n    pico.addSingleton(SetSeverityAction.class);\n    pico.addSingleton(CommentAction.class);\n    pico.addSingleton(TransitionAction.class);\n\n    // technical debt\n    pico.addSingleton(DebtModelService.class);\n    pico.addSingleton(DebtModelOperations.class);\n    pico.addSingleton(DebtModelLookup.class);\n    pico.addSingleton(DebtModelBackup.class);\n    pico.addSingleton(DebtModelPluginRepository.class);\n    pico.addSingleton(DebtModelXMLExporter.class);\n    pico.addSingleton(DebtRulesXMLImporter.class);\n    pico.addSingleton(DebtCharacteristicsXMLImporter.class);\n\n    // source\n    pico.addSingleton(HtmlSourceDecorator.class);\n    pico.addSingleton(DeprecatedSourceDecorator.class);\n    pico.addSingleton(SourceService.class);\n    pico.addSingleton(SourcesWs.class);\n    pico.addSingleton(ShowAction.class);\n    pico.addSingleton(ScmWriter.class);\n    pico.addSingleton(ScmAction.class);\n\n    // Duplications\n    pico.addSingleton(DuplicationsParser.class);\n    pico.addSingleton(DuplicationsWs.class);\n    pico.addSingleton(DuplicationsWriter.class);\n    pico.addSingleton(org.sonar.server.duplication.ws.ShowAction.class);\n\n    // text\n    pico.addSingleton(MacroInterpreter.class);\n    pico.addSingleton(RubyTextService.class);\n\n    // Notifications\n    pico.addSingleton(EmailSettings.class);\n    pico.addSingleton(NotificationService.class);\n    pico.addSingleton(NotificationCenter.class);\n    pico.addSingleton(DefaultNotificationManager.class);\n\n    // Tests\n    pico.addSingleton(CoverageService.class);\n    pico.addSingleton(CoverageWs.class);\n    pico.addSingleton(CoverageShowAction.class);\n    pico.addSingleton(TestsWs.class);\n    pico.addSingleton(TestsTestCasesAction.class);\n    pico.addSingleton(TestsCoveredFilesAction.class);\n    pico.addSingleton(TestsShowAction.class);\n\n    // graphs and perspective related classes\n    pico.addSingleton(TestablePerspectiveLoader.class);\n    pico.addSingleton(TestPlanPerspectiveLoader.class);\n    pico.addSingleton(SnapshotPerspectives.class);\n\n    // Type validation\n    pico.addSingleton(TypeValidations.class);\n    pico.addSingleton(IntegerTypeValidation.class);\n    pico.addSingleton(FloatTypeValidation.class);\n    pico.addSingleton(BooleanTypeValidation.class);\n    pico.addSingleton(TextTypeValidation.class);\n    pico.addSingleton(StringTypeValidation.class);\n    pico.addSingleton(StringListTypeValidation.class);\n\n    for (Object components : level4AddedComponents) {\n      pico.addSingleton(components);\n    }\n\n\n    ServerExtensionInstaller extensionInstaller = pico.getComponentByType(ServerExtensionInstaller.class);\n    extensionInstaller.installExtensions(pico);\n\n    pico.startComponents();\n    executeStartupTaks(pico);\n  }","id":32457,"modified_method":"void startLevel4Components(ComponentContainer pico) {\n    pico.addSingleton(PluginDownloader.class);\n    pico.addSingleton(ChartFactory.class);\n    pico.addSingleton(Languages.class);\n    pico.addSingleton(Views.class);\n    pico.addSingleton(CodeColorizers.class);\n    pico.addSingleton(ResourceTypes.class);\n    pico.addSingleton(SettingsChangeNotifier.class);\n    pico.addSingleton(PageDecorations.class);\n    pico.addSingleton(PreviewCache.class);\n    pico.addSingleton(DefaultResourcePermissions.class);\n    pico.addSingleton(Periods.class);\n    pico.addSingleton(ServerWs.class);\n\n    // update center\n    pico.addSingleton(UpdateCenterClient.class);\n    pico.addSingleton(UpdateCenterMatrixFactory.class);\n    pico.addSingleton(UpdateCenterWs.class);\n\n    // quality profile\n    pico.addSingleton(XMLProfileParser.class);\n    pico.addSingleton(XMLProfileSerializer.class);\n    pico.addComponent(ProfilesDao.class, false);\n    pico.addComponent(ProfilesManager.class, false);\n    pico.addSingleton(AnnotationProfileParser.class);\n    pico.addSingleton(QProfiles.class);\n    pico.addSingleton(QProfileLookup.class);\n    pico.addSingleton(QProfileOperations.class);\n    pico.addSingleton(QProfileActiveRuleOperations.class);\n    pico.addSingleton(QProfileProjectOperations.class);\n    pico.addSingleton(QProfileProjectLookup.class);\n    pico.addSingleton(QProfileBackup.class);\n    pico.addSingleton(QProfileRepositoryExporter.class);\n    pico.addSingleton(DefaultProfilesCache.class);\n    pico.addSingleton(QProfileRecreateBuiltInAction.class);\n    pico.addSingleton(QProfilesWs.class);\n    pico.addSingleton(ProfilesWs.class);\n    pico.addSingleton(RuleActivationActions.class);\n    pico.addSingleton(BulkRuleActivationActions.class);\n    pico.addSingleton(RuleActivator.class);\n    pico.addSingleton(QProfileService.class);\n    pico.addSingleton(RuleActivationContextFactory.class);\n    pico.addSingleton(QProfileCopier.class);\n    pico.addSingleton(QProfileBackuper.class);\n\n    // rule\n    pico.addSingleton(AnnotationRuleParser.class);\n    pico.addSingleton(XMLRuleParser.class);\n    pico.addComponent(RulesDao.class, false);\n    pico.addSingleton(DefaultRuleFinder.class);\n    pico.addSingleton(RuleOperations.class);\n    pico.addSingleton(RubyRuleService.class);\n    pico.addSingleton(RuleRepositories.class);\n    pico.addSingleton(DeprecatedRulesDefinition.class);\n    pico.addSingleton(RuleDefinitionsLoader.class);\n    pico.addSingleton(RulesDefinitionXmlLoader.class);\n    pico.addSingleton(RuleService.class);\n    pico.addSingleton(RuleUpdater.class);\n    pico.addSingleton(RuleCreator.class);\n    pico.addSingleton(UpdateAction.class);\n    pico.addSingleton(RulesWebService.class);\n    pico.addSingleton(SearchAction.class);\n    pico.addSingleton(org.sonar.server.rule.ws.ShowAction.class);\n    pico.addSingleton(org.sonar.server.rule.ws.CreateAction.class);\n    pico.addSingleton(TagsAction.class);\n    pico.addSingleton(RuleMapping.class);\n    pico.addSingleton(ActiveRuleCompleter.class);\n    pico.addSingleton(AppAction.class);\n\n    // measure\n    pico.addComponent(MeasuresDao.class, false);\n    pico.addSingleton(MeasureFilterFactory.class);\n    pico.addSingleton(MeasureFilterExecutor.class);\n    pico.addSingleton(MeasureFilterEngine.class);\n    pico.addSingleton(DefaultMetricFinder.class);\n    pico.addSingleton(ServerLifecycleNotifier.class);\n    pico.addSingleton(TimeMachineWs.class);\n\n    // quality gates\n    pico.addSingleton(QualityGateDao.class);\n    pico.addSingleton(QualityGateConditionDao.class);\n    pico.addSingleton(QualityGates.class);\n    pico.addSingleton(ProjectQgateAssociationDao.class);\n    pico.addSingleton(QgateProjectFinder.class);\n\n    pico.addSingleton(QGatesListAction.class);\n    pico.addSingleton(QGatesSearchAction.class);\n    pico.addSingleton(QGatesShowAction.class);\n    pico.addSingleton(QGatesCreateAction.class);\n    pico.addSingleton(QGatesRenameAction.class);\n    pico.addSingleton(QGatesCopyAction.class);\n    pico.addSingleton(QGatesDestroyAction.class);\n    pico.addSingleton(QGatesSetAsDefaultAction.class);\n    pico.addSingleton(QGatesUnsetDefaultAction.class);\n    pico.addSingleton(QGatesSelectAction.class);\n    pico.addSingleton(QGatesDeselectAction.class);\n    pico.addSingleton(QGatesCreateConditionAction.class);\n    pico.addSingleton(QGatesDeleteConditionAction.class);\n    pico.addSingleton(QGatesUpdateConditionAction.class);\n    pico.addSingleton(QGatesAppAction.class);\n    pico.addSingleton(QGatesWs.class);\n\n    // web services\n    pico.addSingleton(WebServiceEngine.class);\n    pico.addSingleton(ListingWs.class);\n\n    // localization\n    pico.addSingleton(L10nWs.class);\n\n    // authentication\n    pico.addSingleton(AuthenticationWs.class);\n\n    // users\n    pico.addSingleton(SecurityRealmFactory.class);\n    pico.addSingleton(HibernateUserFinder.class);\n    pico.addSingleton(NewUserNotifier.class);\n    pico.addSingleton(DefaultUserFinder.class);\n    pico.addSingleton(DefaultUserService.class);\n    pico.addSingleton(UsersWs.class);\n\n    // groups\n    pico.addSingleton(GroupMembershipService.class);\n    pico.addSingleton(GroupMembershipFinder.class);\n\n    // permissions\n    pico.addSingleton(PermissionFacade.class);\n    pico.addSingleton(InternalPermissionService.class);\n    pico.addSingleton(InternalPermissionTemplateService.class);\n    pico.addSingleton(PermissionFinder.class);\n    pico.addSingleton(PermissionsWs.class);\n\n    // components\n    pico.addSingleton(DefaultComponentFinder.class);\n    pico.addSingleton(DefaultRubyComponentService.class);\n    pico.addSingleton(ComponentDao.class);\n    pico.addSingleton(ResourcesWs.class);\n    pico.addSingleton(ComponentsWs.class);\n    pico.addSingleton(ProjectsWs.class);\n    pico.addSingleton(ComponentAppAction.class);\n\n    // issues\n    pico.addSingleton(ServerIssueStorage.class);\n    pico.addSingleton(IssueUpdater.class);\n    pico.addSingleton(FunctionExecutor.class);\n    pico.addSingleton(IssueWorkflow.class);\n    pico.addSingleton(IssueService.class);\n    pico.addSingleton(IssueCommentService.class);\n    pico.addSingleton(DefaultIssueFinder.class);\n    pico.addSingleton(IssueStatsFinder.class);\n    pico.addSingleton(PublicRubyIssueService.class);\n    pico.addSingleton(InternalRubyIssueService.class);\n    pico.addSingleton(IssueChangelogService.class);\n    pico.addSingleton(IssueNotifications.class);\n    pico.addSingleton(ActionService.class);\n    pico.addSingleton(Actions.class);\n    pico.addSingleton(IssueBulkChangeService.class);\n    pico.addSingleton(IssueChangelogFormatter.class);\n    pico.addSingleton(IssuesWs.class);\n    pico.addSingleton(IssueShowAction.class);\n    pico.addSingleton(IssueSearchAction.class);\n    pico.addSingleton(IssueActionsWriter.class);\n\n    // issue filters\n    pico.addSingleton(IssueFilterService.class);\n    pico.addSingleton(IssueFilterSerializer.class);\n    pico.addSingleton(IssueFilterWs.class);\n    pico.addSingleton(IssueFilterWriter.class);\n    pico.addSingleton(org.sonar.server.issue.filter.AppAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.ShowAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.FavoritesAction.class);\n\n    // action plan\n    pico.addSingleton(ActionPlanWs.class);\n    pico.addSingleton(ActionPlanService.class);\n\n    // issues actions\n    pico.addSingleton(AssignAction.class);\n    pico.addSingleton(PlanAction.class);\n    pico.addSingleton(SetSeverityAction.class);\n    pico.addSingleton(CommentAction.class);\n    pico.addSingleton(TransitionAction.class);\n\n    // technical debt\n    pico.addSingleton(DebtModelService.class);\n    pico.addSingleton(DebtModelOperations.class);\n    pico.addSingleton(DebtModelLookup.class);\n    pico.addSingleton(DebtModelBackup.class);\n    pico.addSingleton(DebtModelPluginRepository.class);\n    pico.addSingleton(DebtModelXMLExporter.class);\n    pico.addSingleton(DebtRulesXMLImporter.class);\n    pico.addSingleton(DebtCharacteristicsXMLImporter.class);\n\n    // source\n    pico.addSingleton(HtmlSourceDecorator.class);\n    pico.addSingleton(DeprecatedSourceDecorator.class);\n    pico.addSingleton(SourceService.class);\n    pico.addSingleton(SourcesWs.class);\n    pico.addSingleton(ShowAction.class);\n    pico.addSingleton(ScmWriter.class);\n    pico.addSingleton(ScmAction.class);\n\n    // Duplications\n    pico.addSingleton(DuplicationsParser.class);\n    pico.addSingleton(DuplicationsWs.class);\n    pico.addSingleton(DuplicationsWriter.class);\n    pico.addSingleton(org.sonar.server.duplication.ws.ShowAction.class);\n\n    // text\n    pico.addSingleton(MacroInterpreter.class);\n    pico.addSingleton(RubyTextService.class);\n\n    // Notifications\n    pico.addSingleton(EmailSettings.class);\n    pico.addSingleton(NotificationService.class);\n    pico.addSingleton(NotificationCenter.class);\n    pico.addSingleton(DefaultNotificationManager.class);\n\n    // Tests\n    pico.addSingleton(CoverageService.class);\n    pico.addSingleton(CoverageWs.class);\n    pico.addSingleton(CoverageShowAction.class);\n    pico.addSingleton(TestsWs.class);\n    pico.addSingleton(TestsTestCasesAction.class);\n    pico.addSingleton(TestsCoveredFilesAction.class);\n    pico.addSingleton(TestsShowAction.class);\n\n    // graphs and perspective related classes\n    pico.addSingleton(TestablePerspectiveLoader.class);\n    pico.addSingleton(TestPlanPerspectiveLoader.class);\n    pico.addSingleton(SnapshotPerspectives.class);\n\n    // Type validation\n    pico.addSingleton(TypeValidations.class);\n    pico.addSingleton(IntegerTypeValidation.class);\n    pico.addSingleton(FloatTypeValidation.class);\n    pico.addSingleton(BooleanTypeValidation.class);\n    pico.addSingleton(TextTypeValidation.class);\n    pico.addSingleton(StringTypeValidation.class);\n    pico.addSingleton(StringListTypeValidation.class);\n\n    for (Object components : level4AddedComponents) {\n      pico.addSingleton(components);\n    }\n\n\n    ServerExtensionInstaller extensionInstaller = pico.getComponentByType(ServerExtensionInstaller.class);\n    extensionInstaller.installExtensions(pico);\n\n    pico.startComponents();\n    executeStartupTaks(pico);\n  }","commit_id":"b526708cabd9d6a4ee127f52188e07590558298d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_update_custom_rule_from_template_if_no_change() throws Exception {\n    RuleIndex index = tester.get(RuleIndex.class);\n    Rule templateRule = index.getByKey(RuleKey.of(\"xoo\", \"template1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = tester.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", templateRule.key())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Store updated at date\n    Date updatedAt = index.getByKey(customRuleKey).updatedAt();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify custom rule has not been updated\n    Rule customRuleReloaded = index.getByKey(customRuleKey);\n    assertThat(customRuleReloaded.updatedAt()).isEqualTo(updatedAt);\n  }","id":32458,"modified_method":"@Test\n  public void not_update_custom_rule_from_template_if_no_change() throws Exception {\n    Rule templateRule = index.getByKey(RuleKey.of(\"xoo\", \"template1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = tester.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", templateRule.key())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Store updated at date\n    Date updatedAt = index.getByKey(customRuleKey).updatedAt();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify custom rule has not been updated\n    Rule customRuleReloaded = index.getByKey(customRuleKey);\n    assertThat(customRuleReloaded.updatedAt()).isEqualTo(updatedAt);\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_update_custom_rule_params_from_template() throws Exception {\n    RuleIndex index = tester.get(RuleIndex.class);\n    Rule templateRule = index.getByKey(RuleKey.of(\"xoo\", \"template1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = tester.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", templateRule.key())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Update custom rule param name\n    RuleDto customRuleDto = db.ruleDao().getByKey(dbSession, customRuleKey);\n    RuleParamDto customRuleParamDto = db.ruleDao().findRuleParamsByRuleKey(dbSession, customRuleKey).get(0);\n    db.ruleDao().removeRuleParam(dbSession, customRuleDto, customRuleParamDto);\n    db.ruleDao().addRuleParam(dbSession, customRuleDto, customRuleParamDto.setName(\"format2\"));\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Verify param has been updated\n    Rule customRule = index.getByKey(customRuleKey);\n    assertThat(customRule.params()).hasSize(1);\n    assertThat(customRule.params().get(0).key()).isEqualTo(\"format2\");\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify custom rule param has not been changed!\n    Rule customRuleReloaded = index.getByKey(customRuleKey);\n    assertThat(customRuleReloaded.params().get(0).key()).isEqualTo(\"format2\");\n  }","id":32459,"modified_method":"@Test\n  public void not_update_custom_rule_params_from_template() throws Exception {\n    Rule templateRule = index.getByKey(RuleKey.of(\"xoo\", \"template1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = tester.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", templateRule.key())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Update custom rule param name\n    RuleDto customRuleDto = db.ruleDao().getByKey(dbSession, customRuleKey);\n    RuleParamDto customRuleParamDto = db.ruleDao().findRuleParamsByRuleKey(dbSession, customRuleKey).get(0);\n    db.ruleDao().removeRuleParam(dbSession, customRuleDto, customRuleParamDto);\n    db.ruleDao().addRuleParam(dbSession, customRuleDto, customRuleParamDto.setName(\"format2\"));\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Verify param has been updated\n    Rule customRule = index.getByKey(customRuleKey);\n    assertThat(customRule.params()).hasSize(1);\n    assertThat(customRule.params().get(0).key()).isEqualTo(\"format2\");\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify custom rule param has not been changed!\n    Rule customRuleReloaded = index.getByKey(customRuleKey);\n    assertThat(customRuleReloaded.params().get(0).key()).isEqualTo(\"format2\");\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_debt_rule() throws Exception {\n    verifyRulesInDb();\n\n    RuleIndex index = tester.get(RuleIndex.class);\n\n    // Update x1 rule\n    RuleDto ruleDto = db.ruleDao().getByKey(dbSession, RuleTesting.XOO_X1);\n    db.ruleDao().update(dbSession, ruleDto\n        .setDefaultSubCharacteristicId(123456)\n        .setDefaultRemediationFunction(\"LINEAR_OFFSET\")\n        .setDefaultRemediationCoefficient(\"2h\")\n        .setDefaultRemediationOffset(\"35min\")\n    );\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify default debt has been reset to plugin definition\n    Rule ruleReloaded = index.getByKey(RuleTesting.XOO_X1);\n    assertThat(ruleReloaded.debtSubCharacteristicKey()).isEqualTo(RulesDefinition.SubCharacteristics.INTEGRATION_TESTABILITY);\n    assertThat(ruleReloaded.debtRemediationFunction().type()).isEqualTo(DebtRemediationFunction.Type.LINEAR_OFFSET);\n    assertThat(ruleReloaded.debtRemediationFunction().coefficient()).isEqualTo(\"1h\");\n    assertThat(ruleReloaded.debtRemediationFunction().offset()).isEqualTo(\"30min\");\n  }","id":32460,"modified_method":"@Test\n  public void update_debt_rule() throws Exception {\n    verifyRulesInDb();\n\n    // Update x1 rule\n    RuleDto ruleDto = db.ruleDao().getByKey(dbSession, RuleTesting.XOO_X1);\n    db.ruleDao().update(dbSession, ruleDto\n      .setDefaultSubCharacteristicId(123456)\n      .setDefaultRemediationFunction(\"LINEAR_OFFSET\")\n      .setDefaultRemediationCoefficient(\"2h\")\n      .setDefaultRemediationOffset(\"35min\")\n      );\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify default debt has been reset to plugin definition\n    Rule ruleReloaded = index.getByKey(RuleTesting.XOO_X1);\n    assertThat(ruleReloaded.debtSubCharacteristicKey()).isEqualTo(RulesDefinition.SubCharacteristics.INTEGRATION_TESTABILITY);\n    assertThat(ruleReloaded.debtRemediationFunction().type()).isEqualTo(DebtRemediationFunction.Type.LINEAR_OFFSET);\n    assertThat(ruleReloaded.debtRemediationFunction().coefficient()).isEqualTo(\"1h\");\n    assertThat(ruleReloaded.debtRemediationFunction().offset()).isEqualTo(\"30min\");\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void remove_debt_rule() throws Exception {\n    verifyRulesInDb();\n\n    RuleIndex index = tester.get(RuleIndex.class);\n\n    // Set some default debt on x2 rule, which has no debt provided by th plugin\n    RuleDto ruleDto = db.ruleDao().getByKey(dbSession, RuleTesting.XOO_X2);\n    db.ruleDao().update(dbSession, ruleDto\n        .setDefaultSubCharacteristicId(db.debtCharacteristicDao().selectByKey(RulesDefinition.SubCharacteristics.INTEGRATION_TESTABILITY, dbSession).getId())\n        .setDefaultRemediationFunction(\"LINEAR_OFFSET\")\n        .setDefaultRemediationCoefficient(\"2h\")\n        .setDefaultRemediationOffset(\"35min\")\n    );\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify default debt has been removed\n    Rule ruleReloaded = index.getByKey(RuleTesting.XOO_X2);\n    assertThat(ruleReloaded.debtSubCharacteristicKey()).isNull();\n    assertThat(ruleReloaded.debtRemediationFunction()).isNull();\n  }","id":32461,"modified_method":"@Test\n  public void remove_debt_rule() throws Exception {\n    verifyRulesInDb();\n\n    // Set some default debt on x2 rule, which has no debt provided by th plugin\n    RuleDto ruleDto = db.ruleDao().getByKey(dbSession, RuleTesting.XOO_X2);\n    db.ruleDao().update(dbSession, ruleDto\n      .setDefaultSubCharacteristicId(db.debtCharacteristicDao().selectByKey(RulesDefinition.SubCharacteristics.INTEGRATION_TESTABILITY, dbSession).getId())\n      .setDefaultRemediationFunction(\"LINEAR_OFFSET\")\n      .setDefaultRemediationCoefficient(\"2h\")\n      .setDefaultRemediationOffset(\"35min\")\n      );\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify default debt has been removed\n    Rule ruleReloaded = index.getByKey(RuleTesting.XOO_X2);\n    assertThat(ruleReloaded.debtSubCharacteristicKey()).isNull();\n    assertThat(ruleReloaded.debtRemediationFunction()).isNull();\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void define(Context context) {\n      if (includeX1 || includeX2 || includeTemplate1) {\n        NewRepository repository = context.createRepository(\"xoo\", \"xoo\").setName(\"Xoo Repo\");\n        if (includeX1) {\n          NewRule x1Rule = repository.createRule(RuleTesting.XOO_X1.rule())\n            .setName(\"x1 name\")\n            .setHtmlDescription(\"x1 desc\")\n            .setSeverity(Severity.MINOR)\n            .setEffortToFixDescription(\"x1 effort to fix\");\n          x1Rule.createParam(\"acceptWhitespace\")\n            .setType(RuleParamType.BOOLEAN)\n            .setDefaultValue(\"false\")\n            .setDescription(\"Accept whitespaces on the line\");\n          x1Rule\n            .setDebtSubCharacteristic(SubCharacteristics.INTEGRATION_TESTABILITY)\n            .setDebtRemediationFunction(x1Rule.debtRemediationFunctions().linearWithOffset(\"1h\", \"30min\"));\n        }\n\n        if (includeX2) {\n          repository.createRule(RuleTesting.XOO_X2.rule())\n            .setName(\"x2 name\")\n            .setHtmlDescription(\"x2 desc\")\n            .setSeverity(Severity.MAJOR);\n        }\n\n        if (includeRuleLinkedToRootCharacteristic) {\n          NewRule x1Rule = repository.createRule(\"RuleLinkedToRootCharacteristic\")\n            .setName(\"RuleLinkedToRootCharacteristic name\")\n            .setHtmlDescription(\"RuleLinkedToRootCharacteristic desc\")\n            .setSeverity(Severity.MINOR);\n          x1Rule\n            // Link to a root characteristic -> fail\n            .setDebtSubCharacteristic(\"REUSABILITY\")\n            .setDebtRemediationFunction(x1Rule.debtRemediationFunctions().linearWithOffset(\"1h\", \"30min\"));\n        }\n\n        if (includeTemplate1) {\n          repository.createRule(\"template1\")\n            .setName(\"template1 name\")\n            .setHtmlDescription(\"template1 desc\")\n            .setSeverity(Severity.MAJOR)\n            .setTemplate(true)\n            .createParam(\"format\")\n            .setDefaultValue(\"csv\")\n            .setType(RuleParamType.STRING)\n            .setDescription(\"format parameter\");\n        }\n\n        repository.done();\n      }\n    }","id":32462,"modified_method":"@Override\n    public void define(Context context) {\n      if (includeX1 || includeX1bis || includeX2 || includeTemplate1 || includeRuleLinkedToRootCharacteristic) {\n        NewRepository repository = context.createRepository(\"xoo\", \"xoo\").setName(\"Xoo Repo\");\n        if (includeX1) {\n          NewRule x1Rule = repository.createRule(RuleTesting.XOO_X1.rule())\n            .setName(\"x1 name\")\n            .setHtmlDescription(\"x1 desc\")\n            .setSeverity(Severity.MINOR)\n            .setEffortToFixDescription(\"x1 effort to fix\")\n            .setTags(\"tag1\");\n          x1Rule.createParam(\"acceptWhitespace\")\n            .setType(RuleParamType.BOOLEAN)\n            .setDefaultValue(\"false\")\n            .setDescription(\"Accept whitespaces on the line\");\n          x1Rule\n            .setDebtSubCharacteristic(SubCharacteristics.INTEGRATION_TESTABILITY)\n            .setDebtRemediationFunction(x1Rule.debtRemediationFunctions().linearWithOffset(\"1h\", \"30min\"));\n        }\n\n        // X1 having fields updated to simulate an update from the plugin\n        if (includeX1bis) {\n          NewRule x1Rule = repository.createRule(RuleTesting.XOO_X1.rule())\n            .setName(\"x1 name updated\")\n            .setHtmlDescription(\"x1 desc updated\")\n            .setSeverity(Severity.INFO)\n            .setEffortToFixDescription(\"x1 effort to fix updated\")\n            .setTags(\"tag1\", \"tag2\");\n          x1Rule.createParam(\"acceptWhitespace\")\n            .setType(RuleParamType.BOOLEAN)\n            .setDefaultValue(\"true\")\n            .setDescription(\"Accept whitespaces on the line updated\");\n          // New param\n          x1Rule.createParam(\"format\")\n            .setType(RuleParamType.TEXT)\n            .setDefaultValue(\"txt\")\n            .setDescription(\"Format\");\n          x1Rule\n            .setDebtSubCharacteristic(SubCharacteristics.INSTRUCTION_RELIABILITY)\n            .setDebtRemediationFunction(x1Rule.debtRemediationFunctions().linear(\"2h\"));\n        }\n\n        if (includeX2) {\n          repository.createRule(RuleTesting.XOO_X2.rule())\n            .setName(\"x2 name\")\n            .setHtmlDescription(\"x2 desc\")\n            .setSeverity(Severity.MAJOR);\n        }\n\n        if (includeRuleLinkedToRootCharacteristic) {\n          NewRule x1Rule = repository.createRule(\"RuleLinkedToRootCharacteristic\")\n            .setName(\"RuleLinkedToRootCharacteristic name\")\n            .setHtmlDescription(\"RuleLinkedToRootCharacteristic desc\")\n            .setSeverity(Severity.MINOR);\n          x1Rule\n            // Link to a root characteristic -> fail\n            .setDebtSubCharacteristic(\"REUSABILITY\")\n            .setDebtRemediationFunction(x1Rule.debtRemediationFunctions().linearWithOffset(\"1h\", \"30min\"));\n        }\n\n        if (includeTemplate1) {\n          repository.createRule(\"template1\")\n            .setName(\"template1 name\")\n            .setHtmlDescription(\"template1 desc\")\n            .setSeverity(Severity.MAJOR)\n            .setTemplate(true)\n            .createParam(\"format\")\n            .setDefaultValue(\"csv\")\n            .setType(RuleParamType.STRING)\n            .setDescription(\"format parameter\");\n        }\n\n        repository.done();\n      }\n    }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * support the use-case:\n   * 1. start server\n   * 2. stop server\n   * 3. drop elasticsearch index: rm -rf data/es\n   * 4. start server -> db is up-to-date (no changes) but rules must be re-indexed\n   */\n  @Test\n  public void index_even_if_no_changes() throws Exception {\n    RuleIndex index = tester.get(RuleIndex.class);\n\n    verifyRulesInDb();\n\n    // clear ES but keep db\n    tester.clearIndexes();\n    verifyRulesInDb();\n    Result<Rule> searchResult = index.search(new RuleQuery(), new QueryOptions());\n    assertThat(searchResult.getTotal()).isEqualTo(0);\n    assertThat(searchResult.getHits()).hasSize(0);\n\n    // db is not updated (same rules) but es must be reindexed\n    tester.get(Platform.class).executeStartupTasks();\n\n    index = tester.get(RuleIndex.class);\n\n    verifyRulesInDb();\n    searchResult = index.search(new RuleQuery().setKey(\"xoo:x1\"), new QueryOptions());\n    assertThat(searchResult.getTotal()).isEqualTo(1);\n    assertThat(searchResult.getHits()).hasSize(1);\n    assertThat(searchResult.getHits().get(0).params()).hasSize(1);\n  }","id":32463,"modified_method":"/**\n   * support the use-case:\n   * 1. start server\n   * 2. stop server\n   * 3. drop elasticsearch index: rm -rf data/es\n   * 4. start server -> db is up-to-date (no changes) but rules must be re-indexed\n   */\n  @Test\n  public void index_even_if_no_changes() throws Exception {\n    verifyRulesInDb();\n\n    // clear ES but keep db\n    tester.clearIndexes();\n    verifyRulesInDb();\n    Result<Rule> searchResult = index.search(new RuleQuery(), new QueryOptions());\n    assertThat(searchResult.getTotal()).isEqualTo(0);\n    assertThat(searchResult.getHits()).hasSize(0);\n\n    // db is not updated (same rules) but es must be reindexed\n    tester.get(Platform.class).executeStartupTasks();\n\n    index = tester.get(RuleIndex.class);\n\n    verifyRulesInDb();\n    searchResult = index.search(new RuleQuery().setKey(\"xoo:x1\"), new QueryOptions());\n    assertThat(searchResult.getTotal()).isEqualTo(1);\n    assertThat(searchResult.getHits()).hasSize(1);\n    assertThat(searchResult.getHits().get(0).params()).hasSize(1);\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_custom_rule_from_template() throws Exception {\n    RuleIndex index = tester.get(RuleIndex.class);\n    Rule templateRule = index.getByKey(RuleKey.of(\"xoo\", \"template1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = tester.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", templateRule.key())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n\n    // Update custom rule\n    RuleDto customRuleDto = db.ruleDao().getByKey(dbSession, customRuleKey);\n    db.ruleDao().update(dbSession, customRuleDto\n      .setLanguage(\"other language\")\n      .setConfigKey(\"other config key\")\n      .setDefaultSubCharacteristicId(45)\n      .setDefaultRemediationFunction(\"LINEAR_OFFSET\")\n      .setDefaultRemediationCoefficient(\"1h\")\n      .setDefaultRemediationOffset(\"5min\")\n      .setEffortToFixDescription(\"effort to fix desc\")\n      );\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify custom rule has been restore from the template\n    Rule customRule = index.getByKey(customRuleKey);\n    assertThat(customRule.language()).isEqualTo(\"xoo\");\n    assertThat(customRule.internalKey()).isNull();\n    assertThat(customRule.debtSubCharacteristicKey()).isNull();\n    assertThat(customRule.debtRemediationFunction()).isNull();\n  }","id":32464,"modified_method":"@Test\n  public void update_custom_rule_from_template() throws Exception {\n    Rule templateRule = index.getByKey(RuleKey.of(\"xoo\", \"template1\"));\n\n    // Create custom rule\n    RuleKey customRuleKey = tester.get(RuleCreator.class).create(NewRule.createForCustomRule(\"CUSTOM_RULE\", templateRule.key())\n      .setName(\"My custom\")\n      .setHtmlDescription(\"Some description\")\n      .setSeverity(Severity.MAJOR)\n      .setStatus(RuleStatus.READY)\n      .setParameters(ImmutableMap.of(\"format\", \"txt\")));\n\n    // Update custom rule\n    RuleDto customRuleDto = db.ruleDao().getByKey(dbSession, customRuleKey);\n    db.ruleDao().update(dbSession, customRuleDto\n      .setLanguage(\"other language\")\n      .setConfigKey(\"other config key\")\n      .setDefaultSubCharacteristicId(45)\n      .setDefaultRemediationFunction(\"LINEAR_OFFSET\")\n      .setDefaultRemediationCoefficient(\"1h\")\n      .setDefaultRemediationOffset(\"5min\")\n      .setEffortToFixDescription(\"effort to fix desc\")\n      );\n    dbSession.commit();\n    dbSession.clearCache();\n\n    // Re-execute startup tasks\n    tester.get(Platform.class).executeStartupTasks();\n\n    // Verify custom rule has been restore from the template\n    Rule customRule = index.getByKey(customRuleKey);\n    assertThat(customRule.language()).isEqualTo(\"xoo\");\n    assertThat(customRule.internalKey()).isNull();\n    assertThat(customRule.debtSubCharacteristicKey()).isNull();\n    assertThat(customRule.debtRemediationFunction()).isNull();\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void register_rules_at_startup() throws Exception {\n    verifyRulesInDb();\n\n    RuleIndex index = tester.get(RuleIndex.class);\n\n    Result<Rule> searchResult = index.search(new RuleQuery(), new QueryOptions());\n    assertThat(searchResult.getTotal()).isEqualTo(3);\n    assertThat(searchResult.getHits()).hasSize(3);\n  }","id":32465,"modified_method":"@Test\n  public void register_rules_at_startup() throws Exception {\n    verifyRulesInDb();\n\n    Result<Rule> searchResult = index.search(new RuleQuery(), new QueryOptions());\n    assertThat(searchResult.getTotal()).isEqualTo(3);\n    assertThat(searchResult.getHits()).hasSize(3);\n\n    Rule rule = index.getByKey(RuleTesting.XOO_X1);\n    assertThat(rule.severity()).isEqualTo(Severity.MINOR);\n    assertThat(rule.name()).isEqualTo(\"x1 name\");\n    assertThat(rule.htmlDescription()).isEqualTo(\"x1 desc\");\n    assertThat(rule.systemTags()).contains(\"tag1\");\n\n    assertThat(rule.params()).hasSize(1);\n    assertThat(rule.param(\"acceptWhitespace\").type()).isEqualTo(RuleParamType.BOOLEAN);\n    assertThat(rule.param(\"acceptWhitespace\").defaultValue()).isEqualTo(\"false\");\n    assertThat(rule.param(\"acceptWhitespace\").description()).isEqualTo(\"Accept whitespaces on the line\");\n\n    assertThat(rule.debtSubCharacteristicKey()).isEqualTo(RulesDefinition.SubCharacteristics.INTEGRATION_TESTABILITY);\n    assertThat(rule.debtRemediationFunction().type()).isEqualTo(DebtRemediationFunction.Type.LINEAR_OFFSET);\n    assertThat(rule.debtRemediationFunction().coefficient()).isEqualTo(\"1h\");\n    assertThat(rule.debtRemediationFunction().offset()).isEqualTo(\"30min\");\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void before() {\n    tester.clearDbAndIndexes();\n    rulesDefinition.includeX1 = true;\n    rulesDefinition.includeX2 = true;\n    rulesDefinition.includeTemplate1 = true;\n    rulesDefinition.includeRuleLinkedToRootCharacteristic = false;\n    tester.get(Platform.class).executeStartupTasks();\n    db = tester.get(DbClient.class);\n    dbSession = tester.get(DbClient.class).openSession(false);\n    dbSession.clearCache();\n  }","id":32466,"modified_method":"@Before\n  public void before() {\n    tester.clearDbAndIndexes();\n    rulesDefinition.includeX1 = true;\n    rulesDefinition.includeX1bis = false;\n    rulesDefinition.includeX2 = true;\n    rulesDefinition.includeTemplate1 = true;\n    rulesDefinition.includeRuleLinkedToRootCharacteristic = false;\n    tester.get(Platform.class).executeStartupTasks();\n    db = tester.get(DbClient.class);\n    dbSession = tester.get(DbClient.class).openSession(false);\n    dbSession.clearCache();\n\n    index = tester.get(RuleIndex.class);\n  }","commit_id":"9e3e3636c9a66b1bd1e3d1331f97450e51a5159a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void markNotSpamMBMessages(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tcheckMBMessagePermission(themeDisplay.getScopeGroupId());\n\n\t\tlong[] mbMessageIds = ParamUtil.getLongValues(\n\t\t\tactionRequest, \"notSpamMBMessageIds\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tactionRequest);\n\n\t\tfor (long mbMessageId : mbMessageIds) {\n\t\t\tMBMessage mbMessage = MBMessageLocalServiceUtil.updateStatus(\n\t\t\t\tthemeDisplay.getUserId(), mbMessageId,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, serviceContext);\n\n\t\t\tAkismetUtil.submitHam(mbMessage);\n\t\t}\n\t}","id":32467,"modified_method":"public void markNotSpamMBMessages(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tcheckMBMessagePermission(themeDisplay.getScopeGroupId());\n\n\t\tlong[] mbMessageIds = ParamUtil.getLongValues(\n\t\t\tactionRequest, \"notSpamMBMessageIds\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tactionRequest);\n\n\t\tfor (long mbMessageId : mbMessageIds) {\n\t\t\tMBMessage mbMessage = MBMessageLocalServiceUtil.updateStatus(\n\t\t\t\tthemeDisplay.getUserId(), mbMessageId,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, serviceContext);\n\n\t\t\tif (AkismetUtil.isMessageBoardsEnabled(mbMessage.getCompanyId())) {\n\t\t\t\tAkismetUtil.submitHam(mbMessage);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a5aa8729fcfd33e6e652f659d36b39b105a3ff18","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void markNotSpamWikiPages(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tcheckWikiPagePermission(themeDisplay.getScopeGroupId());\n\n\t\tlong[] wikiPageIds = ParamUtil.getLongValues(\n\t\t\tactionRequest, \"notSpamWikiPageIds\");\n\n\t\tList<String> wikiPageLinks = new ArrayList<String>();\n\n\t\tfor (long wikiPageId : wikiPageIds) {\n\t\t\tWikiPage wikiPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\t\twikiPageId);\n\n\t\t\tWikiPage latestVersionWikiPage = AkismetUtil.getWikiPage(\n\t\t\t\twikiPage.getNodeId(), wikiPage.getTitle(),\n\t\t\t\twikiPage.getVersion(), false);\n\n\t\t\tString latestContent = null;\n\n\t\t\tif (latestVersionWikiPage != null) {\n\t\t\t\tlatestContent = latestVersionWikiPage.getContent();\n\t\t\t}\n\n\t\t\tWikiPage previousVersionWikiPage = AkismetUtil.getWikiPage(\n\t\t\t\twikiPage.getNodeId(), wikiPage.getTitle(),\n\t\t\t\twikiPage.getVersion(), true);\n\n\t\t\tString previousContent = null;\n\n\t\t\tif (previousVersionWikiPage != null) {\n\t\t\t\tpreviousContent = previousVersionWikiPage.getContent();\n\t\t\t}\n\n\t\t\t// Latest version\n\n\t\t\tif ((latestContent != null) && ((previousContent == null) ||\n\t\t\t\t latestContent.equals(previousContent))) {\n\n\t\t\t\tServiceContext serviceContext =\n\t\t\t\t\tServiceContextFactory.getInstance(actionRequest);\n\n\t\t\t\tWikiPageLocalServiceUtil.revertPage(\n\t\t\t\t\tthemeDisplay.getUserId(), wikiPage.getNodeId(),\n\t\t\t\t\twikiPage.getTitle(), wikiPage.getVersion(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(\"<a href=\\\"\");\n\n\t\t\t\tlong plid = PortalUtil.getPlidFromPortletId(\n\t\t\t\t\twikiPage.getGroupId(), PortletKeys.WIKI);\n\n\t\t\t\tLiferayPortletURL liferayPortletURL =\n\t\t\t\t\tPortletURLFactoryUtil.create(\n\t\t\t\t\t\tactionRequest, PortletKeys.WIKI, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tWikiNode wikiNode = wikiPage.getNode();\n\n\t\t\t\tliferayPortletURL.setParameter(\"struts_action\", \"/wiki/view\");\n\t\t\t\tliferayPortletURL.setParameter(\"nodeName\", wikiNode.getName());\n\t\t\t\tliferayPortletURL.setParameter(\"title\", wikiPage.getTitle());\n\t\t\t\tliferayPortletURL.setParameter(\n\t\t\t\t\t\"version\", String.valueOf(wikiPage.getVersion()));\n\n\t\t\t\tsb.append(liferayPortletURL.toString());\n\t\t\t\tsb.append(\"\\\" target=\\\"_blank\\\">\");\n\t\t\t\tsb.append(HtmlUtil.escape(wikiPage.getTitle()));\n\t\t\t\tsb.append(\"<\/a>\");\n\n\t\t\t\twikiPageLinks.add(sb.toString());\n\t\t\t}\n\n\t\t\t// Selected version\n\n\t\t\twikiPage.setStatus(WorkflowConstants.STATUS_APPROVED);\n\t\t\twikiPage.setSummary(StringPool.BLANK);\n\n\t\t\twikiPage = WikiPageLocalServiceUtil.updateWikiPage(wikiPage);\n\n\t\t\t// Akismet\n\n\t\t\tAkismetUtil.submitHam(wikiPage);\n\t\t}\n\n\t\tif (!wikiPageLinks.isEmpty()) {\n\t\t\tSessionMessages.add(actionRequest, \"requestProcessed\");\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest, \"anotherUserHasMadeChangesToThesePages\",\n\t\t\t\tStringUtil.merge(wikiPageLinks, \"<br />\"));\n\n\t\t\tsuper.sendRedirect(actionRequest, actionResponse);\n\t\t}\n\t}","id":32468,"modified_method":"public void markNotSpamWikiPages(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tcheckWikiPagePermission(themeDisplay.getScopeGroupId());\n\n\t\tlong[] wikiPageIds = ParamUtil.getLongValues(\n\t\t\tactionRequest, \"notSpamWikiPageIds\");\n\n\t\tList<String> wikiPageLinks = new ArrayList<String>();\n\n\t\tfor (long wikiPageId : wikiPageIds) {\n\t\t\tWikiPage wikiPage = WikiPageLocalServiceUtil.getPageByPageId(\n\t\t\t\twikiPageId);\n\n\t\t\tWikiPage latestVersionWikiPage = AkismetUtil.getWikiPage(\n\t\t\t\twikiPage.getNodeId(), wikiPage.getTitle(),\n\t\t\t\twikiPage.getVersion(), false);\n\n\t\t\tString latestContent = null;\n\n\t\t\tif (latestVersionWikiPage != null) {\n\t\t\t\tlatestContent = latestVersionWikiPage.getContent();\n\t\t\t}\n\n\t\t\tWikiPage previousVersionWikiPage = AkismetUtil.getWikiPage(\n\t\t\t\twikiPage.getNodeId(), wikiPage.getTitle(),\n\t\t\t\twikiPage.getVersion(), true);\n\n\t\t\tString previousContent = null;\n\n\t\t\tif (previousVersionWikiPage != null) {\n\t\t\t\tpreviousContent = previousVersionWikiPage.getContent();\n\t\t\t}\n\n\t\t\t// Latest version\n\n\t\t\tif ((latestContent != null) && ((previousContent == null) ||\n\t\t\t\t latestContent.equals(previousContent))) {\n\n\t\t\t\tServiceContext serviceContext =\n\t\t\t\t\tServiceContextFactory.getInstance(actionRequest);\n\n\t\t\t\tWikiPageLocalServiceUtil.revertPage(\n\t\t\t\t\tthemeDisplay.getUserId(), wikiPage.getNodeId(),\n\t\t\t\t\twikiPage.getTitle(), wikiPage.getVersion(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(\"<a href=\\\"\");\n\n\t\t\t\tlong plid = PortalUtil.getPlidFromPortletId(\n\t\t\t\t\twikiPage.getGroupId(), PortletKeys.WIKI);\n\n\t\t\t\tLiferayPortletURL liferayPortletURL =\n\t\t\t\t\tPortletURLFactoryUtil.create(\n\t\t\t\t\t\tactionRequest, PortletKeys.WIKI, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tWikiNode wikiNode = wikiPage.getNode();\n\n\t\t\t\tliferayPortletURL.setParameter(\"struts_action\", \"/wiki/view\");\n\t\t\t\tliferayPortletURL.setParameter(\"nodeName\", wikiNode.getName());\n\t\t\t\tliferayPortletURL.setParameter(\"title\", wikiPage.getTitle());\n\t\t\t\tliferayPortletURL.setParameter(\n\t\t\t\t\t\"version\", String.valueOf(wikiPage.getVersion()));\n\n\t\t\t\tsb.append(liferayPortletURL.toString());\n\t\t\t\tsb.append(\"\\\" target=\\\"_blank\\\">\");\n\t\t\t\tsb.append(HtmlUtil.escape(wikiPage.getTitle()));\n\t\t\t\tsb.append(\"<\/a>\");\n\n\t\t\t\twikiPageLinks.add(sb.toString());\n\t\t\t}\n\n\t\t\t// Selected version\n\n\t\t\twikiPage.setStatus(WorkflowConstants.STATUS_APPROVED);\n\t\t\twikiPage.setSummary(StringPool.BLANK);\n\n\t\t\twikiPage = WikiPageLocalServiceUtil.updateWikiPage(wikiPage);\n\n\t\t\t// Akismet\n\n\t\t\tif (AkismetUtil.isWikiEnabled(wikiPage.getCompanyId())) {\n\t\t\t\tAkismetUtil.submitHam(wikiPage);\n\t\t\t}\n\t\t}\n\n\t\tif (!wikiPageLinks.isEmpty()) {\n\t\t\tSessionMessages.add(actionRequest, \"requestProcessed\");\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest, \"anotherUserHasMadeChangesToThesePages\",\n\t\t\t\tStringUtil.merge(wikiPageLinks, \"<br />\"));\n\n\t\t\tsuper.sendRedirect(actionRequest, actionResponse);\n\t\t}\n\t}","commit_id":"4f24772ee7417a7d000ab85319c5d61440a45a3e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public String toString() {\r\n\t\treturn \"{Edge p1=\" + this.p1 + \", p2=\" + this.p2 + \", joined=\"\r\n\t\t\t\t+ this.joined + \", label=\" + this.label + \", plotted\"\r\n\t\t\t\t+ this.plotted + \"}\";\r\n\t}","id":32469,"modified_method":"public String toString() {\r\n\t\treturn \"Edge p1=\" + this.p1 + \", p2=\" + this.p2 + \", joined=\"\r\n\t\t\t\t+ this.joined + \", label=\" + this.label + \", plotted=\"\r\n\t\t\t\t+ this.plotted;\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\tthis.h1 = new FactHandleImpl(1, \"one\");\r\n\t\tthis.h2 = new FactHandleImpl(2, \"two\");\r\n\t\tthis.h3 = new FactHandleImpl(3, \"three\");\r\n\t\tthis.h4 = new FactHandleImpl(4, \"four\");\r\n\t\tFactHandleImpl arr[] = { this.h1, this.h2, this.h3, this.h4 };\r\n\t\tthis.tuple = new LeapsTuple(arr);\r\n\r\n\t\tthis.hOutsider = new FactHandleImpl(9876, \"outsider\");\r\n\t}","id":32470,"modified_method":"protected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\tthis.h1 = new FactHandleImpl(1, \"one\");\r\n\t\tthis.h2 = new FactHandleImpl(2, \"two\");\r\n\t\tthis.h3 = new FactHandleImpl(3, \"three\");\r\n\t\tthis.h4 = new FactHandleImpl(4, \"four\");\r\n\t\tFactHandleImpl arr[] = { this.h1, this.h2, this.h3, this.h4 };\r\n\t\tthis.tuple = new LeapsTuple(arr, null, null, null);\r\n\r\n\t\tthis.hOutsider = new FactHandleImpl(9876, \"outsider\");\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testEqualsObject() {\r\n\t\tFactHandleImpl arr[] = { this.h1, this.h2, this.h3, this.h4 };\r\n\t\tLeapsTuple tupleToCompare = new LeapsTuple(arr);\r\n\t\tassertEquals(this.tuple, tupleToCompare);\r\n\r\n\t}","id":32471,"modified_method":"public void testEqualsObject() {\r\n\t\tFactHandleImpl arr[] = { this.h1, this.h2, this.h3, this.h4 };\r\n\t\tLeapsTuple tupleToCompare = new LeapsTuple(arr, null, null, null);\r\n\t\tassertEquals(this.tuple, tupleToCompare);\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testWaltz() throws DuplicateRuleNameException,\r\n                             InvalidRuleException,\r\n                             IntrospectionException,\r\n                             RuleIntegrationException,\r\n                             PackageIntegrationException,\r\n                             InvalidPatternException,\r\n                             FactException,\r\n                             IOException,\r\n                             InterruptedException {\r\n\r\n        final org.drools.leaps.RuleBaseImpl ruleBase = new org.drools.leaps.RuleBaseImpl();\r\n        ruleBase.addRuleSet( this.pkg );\r\n        WorkingMemory workingMemory = ruleBase.newWorkingMemory();\r\n//\r\n//        InputStream is = getClass().getResourceAsStream( \"/waltz12.dat\" );\r\n//        List list = getInputObjects( is );\r\n//        for ( Iterator it = list.iterator(); it.hasNext(); ) {\r\n//            Object object = it.next();\r\n//            workingMemory.assertObject( object );\r\n//        }\r\n\r\n        workingMemory.assertObject( new Stage(Stage.START) );\r\n\r\n        long start = System.currentTimeMillis();\r\n        workingMemory.fireAllRules();\r\n        System.err.println( System.currentTimeMillis() - start );\r\n\r\n    }","id":32472,"modified_method":"public void testWaltz() throws PackageIntegrationException,\r\n                             InvalidPatternException,\r\n                             FactException,\r\n                             IOException {\r\n\r\n        final org.drools.leaps.RuleBaseImpl ruleBase = new org.drools.leaps.RuleBaseImpl();\r\n        ruleBase.addRuleSet( this.pkg );\r\n        WorkingMemory workingMemory = ruleBase.newWorkingMemory();\r\n\r\n        InputStream is = getClass().getResourceAsStream( \"/waltz12.dat\" );\r\n        List list = getInputObjects( is );\r\n        for ( Iterator it = list.iterator(); it.hasNext(); ) {\r\n            Object object = it.next();\r\n            workingMemory.assertObject( object );\r\n        }\r\n\r\n//        workingMemory.assertObject( new Stage(Stage.START) );\r\n\r\n        long start = System.currentTimeMillis();\r\n        workingMemory.fireAllRules();\r\n//\t\tSystem.out.println(workingMemory);\r\n        System.out.println( \"Elapsed time - \" +( ( System.currentTimeMillis() - start ) / 1000.) + \" sec.\");\r\n\r\n    }","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testManners() throws DuplicateRuleNameException,\r\n                             InvalidRuleException,\r\n                             IntrospectionException,\r\n                             RuleIntegrationException,\r\n                             PackageIntegrationException,\r\n                             InvalidPatternException,\r\n                             FactException,\r\n                             IOException,\r\n                             InterruptedException {\r\n\r\n        final org.drools.reteoo.RuleBaseImpl ruleBase = new org.drools.reteoo.RuleBaseImpl();\r\n        ruleBase.addRuleSet( this.pkg );\r\n        WorkingMemory workingMemory = ruleBase.newWorkingMemory();\r\n\r\n        InputStream is = getClass().getResourceAsStream( \"/manners5.dat\" );\r\n        List list = getInputObjects( is );\r\n        for ( Iterator it = list.iterator(); it.hasNext(); ) {\r\n            Object object = it.next();\r\n            workingMemory.assertObject( object );\r\n        }\r\n\r\n        workingMemory.assertObject( new Count( 1 ) );\r\n\r\n        long start = System.currentTimeMillis();\r\n        workingMemory.fireAllRules();\r\n        System.err.println( System.currentTimeMillis() - start );\r\n\r\n        //        final ReteooJungViewer viewer = new ReteooJungViewer(ruleBase); \r\n        //        \r\n        //        javax.swing.SwingUtilities.invokeLater(new Runnable() { \r\n        //        \t\tpublic void run() {\r\n        //        \t\t\tviewer.showGUI();\r\n        //        \t\t}\r\n        //        });\r\n        //        \r\n        //        Thread.sleep( 10000 );\r\n    }","id":32473,"modified_method":"public void testManners() throws DuplicateRuleNameException,\r\n                             InvalidRuleException,\r\n                             IntrospectionException,\r\n                             RuleIntegrationException,\r\n                             PackageIntegrationException,\r\n                             InvalidPatternException,\r\n                             FactException,\r\n                             IOException,\r\n                             InterruptedException {\r\n\r\n        final org.drools.reteoo.RuleBaseImpl ruleBase = new org.drools.reteoo.RuleBaseImpl();\r\n        ruleBase.addRuleSet( this.pkg );\r\n        WorkingMemory workingMemory = ruleBase.newWorkingMemory();\r\n\r\n        InputStream is = getClass().getResourceAsStream( \"/manners64.dat\" );\r\n        List list = getInputObjects( is );\r\n        for ( Iterator it = list.iterator(); it.hasNext(); ) {\r\n            Object object = it.next();\r\n            workingMemory.assertObject( object );\r\n        }\r\n\r\n        workingMemory.assertObject( new Count( 1 ) );\r\n\r\n        long start = System.currentTimeMillis();\r\n        workingMemory.fireAllRules();\r\n        System.err.println( System.currentTimeMillis() - start );\r\n\r\n        //        final ReteooJungViewer viewer = new ReteooJungViewer(ruleBase); \r\n        //        \r\n        //        javax.swing.SwingUtilities.invokeLater(new Runnable() { \r\n        //        \t\tpublic void run() {\r\n        //        \t\t\tviewer.showGUI();\r\n        //        \t\t}\r\n        //        });\r\n        //        \r\n        //        Thread.sleep( 10000 );\r\n    }","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testIsEmpty() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tTableIterator it = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tit = new TableIterator(this.testTable.tailRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.headRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tit = new TableIterator();\r\n\t\tassertTrue(it.isEmpty());\r\n\r\n\t}","id":32474,"modified_method":"public void testIsEmpty() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tit = new BaseTableIterator(this.testTable.tailRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.headRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tit = new BaseTableIterator(null, null, null);\r\n\t\tassertTrue(it.isEmpty());\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testTableIterator() {\r\n\t\tTableIterator it = new TableIterator();\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertTrue(it.isEmpty());\r\n\t}","id":32475,"modified_method":"public void testTableIterator() {\r\n\t\tBaseTableIterator it = new BaseTableIterator(null, null,null);\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertTrue(it.isEmpty());\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testGetDominantFactIterator() {\r\n\t\tIterator it = TableIterator.baseFactIterator(this.h1000);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(it.next(), this.h1000);\r\n\t\tassertFalse(it.hasNext());\r\n\t}","id":32476,"modified_method":"public void testGetDominantFactIterator() {\r\n\t\tIterator it = Table.singleItemIterator(this.h1000);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(it.next(), this.h1000);\r\n\t\tassertFalse(it.hasNext());\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testReset() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tTableIterator it = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tit.next();\r\n\t\tit.next();\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tit = new TableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1, it.next());\r\n\r\n\t}","id":32477,"modified_method":"public void testReset() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tit.next();\r\n\t\tit.next();\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tit = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit.reset();\r\n\t\tassertEquals(this.h1, it.next());\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testPeekNext() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tTableIterator it = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.peekNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.peekNext());\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.peekNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit = new TableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.peekNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\r\n\t}","id":32478,"modified_method":"public void testPeekNext() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.peekNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.peekNext());\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.peekNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.peekNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testTableIteratorTableRecord() {\r\n\t\tTableIterator it = new TableIterator(new TableRecord(this.h1));\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\r\n\t}","id":32479,"modified_method":"public void testTableIteratorTableRecord() {\r\n\t\tBaseTableIterator it = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testTableIteratorTableRecordTableRecordTableRecord() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tTableIterator it = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h100, it.next());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h10, it.next());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\r\n\t}","id":32480,"modified_method":"public void testTableIteratorTableRecordTableRecordTableRecord() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h100, it.next());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h10, it.next());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testHasNext() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tTableIterator it = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tit = new TableIterator();\r\n\t\tassertFalse(it.hasNext());\r\n\t\tit = new TableIterator(new TableRecord(this.h1));\r\n\t\tassertTrue(it.hasNext());\r\n\r\n\t}","id":32481,"modified_method":"public void testHasNext() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertFalse(it.hasNext());\r\n\t\tassertFalse(it.isEmpty());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertTrue(it.hasNext());\r\n\t\tit = new BaseTableIterator(null, null, null);\r\n\t\tassertFalse(it.hasNext());\r\n\t\tit = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertTrue(it.hasNext());\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testCurrent() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tTableIterator it = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tassertEquals(this.h1000, it.current());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\t\tit = new TableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\r\n\t}","id":32482,"modified_method":"public void testCurrent() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tassertEquals(this.h1000, it.current());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\t\tit = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testNext() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tTableIterator it = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new TableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit = new TableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t}","id":32483,"modified_method":"public void testNext() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/***************************************************************************\r\n\t * This function is passed two points and calculates the angle between the\r\n\t * line defined by these points and the x-axis.\r\n\t **************************************************************************/\r\n\tprivate static double get_angle(int p1, int p2) {\r\n\t\tint delta_x, delta_y;\r\n\t\tdouble ret = 0.0;\r\n\t\t/*\r\n\t\t * Calculate (x2 - x1) and (y2 - y1). The points are passed in the form\r\n\t\t * x1y1 and x2y2. get_x() and get_y() are passed these points and return\r\n\t\t * the x and y values respectively. For example, get_x(1020) returns 10.\r\n\t\t */\r\n\t\tdelta_x = get_x(p2) - get_x(p1);\r\n\t\tdelta_y = get_y(p2) - get_y(p1);\r\n\r\n\t\tif (delta_x == 0) {\r\n\t\t\tif (delta_y > 0) {\r\n\t\t\t\tret = PI / 2;\r\n\t\t\t} else if (delta_y < 0) {\r\n\t\t\t\tret = -PI / 2;\r\n\t\t\t}\r\n\t\t} else if (delta_y == 0) {\r\n\t\t\tif (delta_x > 0) {\r\n\t\t\t\tret = 0.0;\r\n\t\t\t} else if (delta_x < 0) {\r\n\t\t\t\tret = PI;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tret = (double) Math.atan2(delta_y, delta_x);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}","id":32484,"modified_method":"/***************************************************************************\r\n\t * This function is passed two points and calculates the angle between the\r\n\t * line defined by these points and the x-axis.\r\n\t **************************************************************************/\r\n\tprivate static double get_angle(int p1, int p2) {\r\n\t\tint delta_x, delta_y;\r\n\t\tdouble ret = 0.0;\r\n\t\t/*\r\n\t\t * Calculate (x2 - x1) and (y2 - y1). The points are passed in the form\r\n\t\t * x1y1 and x2y2. get_x() and get_y() are passed these points and return\r\n\t\t * the x and y values respectively. For example, get_x(1020) returns 10.\r\n\t\t */\r\n\t\tdelta_x = get_x(p2) - get_x(p1);\r\n\t\tdelta_y = get_y(p2) - get_y(p1);\r\n\r\n\t\tif (delta_x == 0) {\r\n\t\t\tif (delta_y > 0) {\r\n\t\t\t\tret = PI / 2;\r\n\t\t\t} else if (delta_y < 0) {\r\n\t\t\t\tret = -PI / 2;\r\n\t\t\t}\r\n\t\t} else if (delta_y == 0) {\r\n\t\t\tif (delta_x > 0) {\r\n\t\t\t\tret = 0.0;\r\n\t\t\t} else if (delta_x < 0) {\r\n\t\t\t\tret = PI;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tret = Math.atan2(delta_y, delta_x);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}","commit_id":"d2dd74ae15d6dae4dbe00ef82763be41eedf68f3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void initUI() {\n\t\tpaint = new Paint();\n\t\tpaint.setStyle(Style.STROKE);\n\t\tpaint.setAntiAlias(true);\n\t\tpaint.setStrokeCap(Cap.ROUND);\n\t\tpaint.setStrokeJoin(Join.ROUND);\n\t\tactionArrow = BitmapFactory.decodeResource(view.getResources(), R.drawable.map_action_arrow, null);\n\t\t\n\t\tactionPaint = new Paint();\n\t\tactionPaint.setStyle(Style.STROKE);\n\t\tactionPaint.setAntiAlias(true);\n\t\tactionPaint.setStrokeCap(Cap.BUTT);\n\t\tactionPaint.setStrokeJoin(Join.ROUND);\n\t\tactionPaint.setStrokeWidth(7 * view.getDensity());\n\t\tactionPaint.setColor(Color.WHITE);\n\t\tpath = new Path();\n\t\t\n\t\tpaintIcon = new Paint();\n\t\tpaintIcon.setFilterBitmap(true);\n\t\tpaintIcon.setAntiAlias(true);\n\t\tpaintIcon.setColor(Color.BLACK);\n\t\tpaintIcon.setStrokeWidth(3);\n\t\t\n\t}","id":32485,"modified_method":"private void initUI() {\n\t\tpaint = new Paint();\n\t\tpaint.setStyle(Style.STROKE);\n\t\tpaint.setAntiAlias(true);\n\t\tpaint.setStrokeCap(Cap.ROUND);\n\t\tpaint.setStrokeJoin(Join.ROUND);\n\t\tactionArrow = BitmapFactory.decodeResource(view.getResources(), R.drawable.map_action_arrow, null);\n\t\t\n\t\tactionPaint = new Paint();\n\t\tactionPaint.setStyle(Style.STROKE);\n\t\tactionPaint.setAntiAlias(true);\n\t\tactionPaint.setStrokeCap(Cap.BUTT);\n\t\tactionPaint.setStrokeJoin(Join.ROUND);\n\t\tactionPaint.setStrokeWidth(7 * view.getScaleCoefficient());\n\t\tactionPaint.setColor(Color.WHITE);\n\t\tpath = new Path();\n\t\t\n\t\tpaintIcon = new Paint();\n\t\tpaintIcon.setFilterBitmap(true);\n\t\tpaintIcon.setAntiAlias(true);\n\t\tpaintIcon.setColor(Color.BLACK);\n\t\tpaintIcon.setStrokeWidth(3);\n\t\t\n\n\t\tpaintIconAction = new Paint();\n\t\tpaintIconAction.setFilterBitmap(true);\n\t\tpaintIconAction.setAntiAlias(true);\n\t\t\n\t}","commit_id":"a2aa63e3b6cc7ef020d2e81da3879af1ceb215e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawAction(RotatedTileBox tb, Canvas canvas) {\n\t\tif (actionPoints.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\tPath pth = new Path();\n\t\t\tMatrix matrix = new Matrix();\n\t\t\tboolean first = true;\n\t\t\tint x = 0, px = 0, py = 0, y = 0;\n\t\t\tfor (int i = 0; i < actionPoints.size(); i++) {\n\t\t\t\tLocation o = actionPoints.get(i);\n\t\t\t\tif (o == null) {\n\t\t\t\t\tcanvas.drawPath(pth, actionPaint);\n\t\t\t\t\tfloat angleRad = (float) Math.atan2(y - py, x - px);\n\t\t\t\t\tfloat angle = (float) (angleRad * 180 / Math.PI) + 90f;\n\t\t\t\t\tfloat distSegment = FloatMath.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\t\t\tif (distSegment == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// int len = (int) (distSegment / pxStep);\n\t\t\t\t\tfloat pdx = x - px;\n\t\t\t\t\tfloat pdy = y - py;\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -actionArrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate(angle, actionArrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + pdx - actionArrow.getWidth() / 2, py + pdy);\n\t\t\t\t\tcanvas.drawBitmap(actionArrow, matrix, paintIcon);\n\t\t\t\t\tfirst = true;\n\t\t\t\t} else {\n\t\t\t\t\tpx = x;\n\t\t\t\t\tpy = y;\n\t\t\t\t\tx = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\ty = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\tif(first) {\n\t\t\t\t\t\tpth.reset();\n\t\t\t\t\t\tpth.moveTo(x, y);\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpth.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t}\n\t}","id":32486,"modified_method":"private void drawAction(RotatedTileBox tb, Canvas canvas) {\n\t\tif (actionPoints.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\tPath pth = new Path();\n\t\t\tMatrix matrix = new Matrix();\n\t\t\tboolean first = true;\n\t\t\tint x = 0, px = 0, py = 0, y = 0;\n\t\t\tfor (int i = 0; i < actionPoints.size(); i++) {\n\t\t\t\tLocation o = actionPoints.get(i);\n\t\t\t\tif (o == null) {\n\t\t\t\t\tcanvas.drawPath(pth, actionPaint);\n\t\t\t\t\tdouble angleRad = Math.atan2(y - py, x - px);\n\t\t\t\t\tdouble angle = (angleRad * 180 / Math.PI) + 90f;\n\t\t\t\t\tdouble distSegment = FloatMath.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\t\t\tif (distSegment == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// int len = (int) (distSegment / pxStep);\n\t\t\t\t\tfloat pdx = x - px;\n\t\t\t\t\tfloat pdy = y - py;\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -actionArrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate((float) angle, actionArrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + pdx - actionArrow.getWidth() / 2, py + pdy);\n\t\t\t\t\tcanvas.drawBitmap(actionArrow, matrix, paintIconAction);\n\t\t\t\t\tfirst = true;\n\t\t\t\t} else {\n\t\t\t\t\tpx = x;\n\t\t\t\t\tpy = y;\n\t\t\t\t\tx = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\ty = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\tif(first) {\n\t\t\t\t\t\tpth.reset();\n\t\t\t\t\t\tpth.moveTo(x, y);\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpth.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t}\n\t}","commit_id":"a2aa63e3b6cc7ef020d2e81da3879af1ceb215e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n\t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n\t\t\tIterator<RouteDirectionInfo> it) {\n\t\tRouteDirectionInfo nf = null;\n\t\tdouble DISTANCE_ACTION = 35;\n\t\tdouble actionDist = 0;\n\t\tLocation previousAction = null; \n\t\tactionPoints.clear();\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tif(nf != null && nf.routePointOffset < i + cd) {\n\t\t\t\tnf = null;\n\t\t\t}\n\t\t\twhile (nf == null && it.hasNext()) {\n\t\t\t\tnf = it.next();\n\t\t\t\tif (nf.routePointOffset < i + cd) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean action = nf != null && nf.routePointOffset == i + cd;\n\t\t\tif(!action && previousAction == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean visible = leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n\t\t\t\t\t&& ls.getLatitude() <= topLatitude;\n\t\t\tif(!action) {\n\t\t\t\tif(previousAction != null) {\n\t\t\t\t\tfloat loc = ls.distanceTo(previousAction);\n\t\t\t\t\tactionDist += loc;\n\t\t\t\t\tif(actionDist >= DISTANCE_ACTION) {\n\t\t\t\t\t\t// calculate distance proj?\n\t\t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / loc, previousAction, ls));\n\t\t\t\t\t\tactionPoints.add(null);\n\t\t\t\t\t\tpreviousAction = null;\n\t\t\t\t\t\tactionDist = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// action point\n\t\t\t\tif(visible) {\n\t\t\t\t\tint ind = actionPoints.size();\n\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\tif (previousAction == null) {\n\t\t\t\t\t\tLocation lp = ls;\n\t\t\t\t\t\tdouble dist = 0;\n\t\t\t\t\t\tfor (int k = i - 1; k >= -1; k--) {\n\t\t\t\t\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n\t\t\t\t\t\t\tfloat loc = lp.distanceTo(l);\n\t\t\t\t\t\t\tdist += loc;\n\t\t\t\t\t\t\tif (dist >= DISTANCE_ACTION) {\n\t\t\t\t\t\t\t\tif(loc > 1) {\n\t\t\t\t\t\t\t\t\tactionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lp, l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tactionPoints.add(ind, l);\n\t\t\t\t\t\t\t\tlp = l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\tactionDist = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":32487,"modified_method":"private void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n\t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n\t\t\tIterator<RouteDirectionInfo> it, int zoom) {\n\t\tRouteDirectionInfo nf = null;\n\t\tdouble DISTANCE_ACTION = zoom >= 17 ? 15 : 35;\n\t\tdouble actionDist = 0;\n\t\tLocation previousAction = null; \n\t\tactionPoints.clear();\n\t\tint prevPoint = -1;\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tif(nf != null && nf.routePointOffset < i + cd) {\n\t\t\t\tnf = null;\n\t\t\t}\n\t\t\twhile (nf == null && it.hasNext()) {\n\t\t\t\tnf = it.next();\n\t\t\t\tif (nf.routePointOffset < i + cd) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean action = nf != null && nf.routePointOffset == i + cd;\n\t\t\tif(!action && previousAction == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean visible = leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n\t\t\t\t\t&& ls.getLatitude() <= topLatitude;\n\t\t\tif(!action) {\n\t\t\t\tif(previousAction != null) {\n\t\t\t\t\tfloat loc = ls.distanceTo(previousAction);\n\t\t\t\t\tactionDist += loc;\n\t\t\t\t\tif(actionDist >= DISTANCE_ACTION) {\n\t\t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / loc, previousAction, ls));\n\t\t\t\t\t\tprevPoint = i;\n\t\t\t\t\t\tactionPoints.add(null);\n\t\t\t\t\t\tpreviousAction = null;\n\t\t\t\t\t\tactionDist = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// action point\n\t\t\t\tif(visible) {\n\t\t\t\t\tint ind = actionPoints.size();\n\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\tif (previousAction == null) {\n\t\t\t\t\t\tLocation lp = ls;\n\t\t\t\t\t\tdouble dist = 0;\n\t\t\t\t\t\tfor (int k = i - 1; k >= -1; k--) {\n\t\t\t\t\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n\t\t\t\t\t\t\tfloat loc = lp.distanceTo(l);\n\t\t\t\t\t\t\tdist += loc;\n\t\t\t\t\t\t\tif (dist >= DISTANCE_ACTION) {\n\t\t\t\t\t\t\t\tif(loc > 1) {\n\t\t\t\t\t\t\t\t\tactionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lp, l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(prevPoint == k) {\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 1);\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 1);\n\t\t\t\t\t\t\t\t\tprevPoint = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tactionPoints.add(ind, l);\n\t\t\t\t\t\t\t\tlp = l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\tactionDist = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a2aa63e3b6cc7ef020d2e81da3879af1ceb215e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void updatePaints(DrawSettings nightMode, RotatedTileBox tileBox){\n\t\tRenderingRulesStorage rrs = view.getApplication().getRendererRegistry().getCurrentSelectedRenderer();\n\t\tfinal boolean isNight = nightMode != null && nightMode.isNightMode();\n\t\tint hsh = calculateHash(rrs, isNight, tileBox.getMapDensity());\n\t\tif (hsh != cachedHash) {\n\t\t\tcachedHash = hsh;\n\t\t\t// cachedColor = view.getResources().getColor(R.color.nav_track);\n\t\t\tif (rrs != null) {\n\t\t\t\tRenderingRuleSearchRequest req = new RenderingRuleSearchRequest(rrs);\n\t\t\t\treq.setBooleanFilter(rrs.PROPS.R_NIGHT_MODE, isNight);\n\t\t\t\tif (req.searchRenderingAttribute(\"route\")) {\n\t\t\t\t\tRenderingContext rc = new OsmandRenderer.RenderingContext(view.getContext());\n\t\t\t\t\trc.setDensityValue((float) tileBox.getMapDensity());\n//\t\t\t\t\tcachedColor = req.getIntPropertyValue(rrs.PROPS.R_COLOR);\n\t\t\t\t\tosmandRenderer.updatePaint(req, paint, 0, false, rc);\n\t\t\t\t\tif(paint.getStrokeWidth() == 0) {\n\t\t\t\t\t\tpaint.setStrokeWidth(12 * view.getDensity());\n\t\t\t\t\t}\n\t\t\t\t\tosmandRenderer.updatePaint(req, actionPaint, 2, false, rc);\n\t\t\t\t\t// TODO remove\n\t\t\t\t\tactionPaint.setStrokeWidth(7 * view.getDensity());\n\t\t\t\t\tactionPaint.setColor(Color.WHITE);\n\t\t\t\t\tisPaint2 = osmandRenderer.updatePaint(req, paint2, 1, false, rc);\n\t\t\t\t\tisPaint_1 = osmandRenderer.updatePaint(req, paint_1, -1, false, rc);\n\t\t\t\t\tisShadowPaint = req.isSpecified(rrs.PROPS.R_SHADOW_RADIUS);\n\t\t\t\t\tif(isShadowPaint) {\n\t\t\t\t\t\tColorFilter cf = new PorterDuffColorFilter(req.getIntPropertyValue(rrs.PROPS.R_SHADOW_COLOR), Mode.SRC_IN);\n\t\t\t\t\t\tshadowPaint.setColorFilter(cf);\n\t\t\t\t\t\tshadowPaint.setStrokeWidth(paint.getStrokeWidth() + 2 * rc.getComplexValue(req, rrs.PROPS.R_SHADOW_RADIUS));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.println(\"Rendering attribute route is not found !\");\n\t\t\t\t\tpaint.setStrokeWidth(12 * view.getDensity());\n\t\t\t\t\tactionPaint.setStrokeWidth(7 * view.getDensity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":32488,"modified_method":"private void updatePaints(DrawSettings nightMode, RotatedTileBox tileBox){\n\t\tRenderingRulesStorage rrs = view.getApplication().getRendererRegistry().getCurrentSelectedRenderer();\n\t\tfinal boolean isNight = nightMode != null && nightMode.isNightMode();\n\t\tint hsh = calculateHash(rrs, isNight, tileBox.getMapDensity());\n\t\tif (hsh != cachedHash) {\n\t\t\tcachedHash = hsh;\n\t\t\t// cachedColor = view.getResources().getColor(R.color.nav_track);\n\t\t\tif (rrs != null) {\n\t\t\t\tRenderingRuleSearchRequest req = new RenderingRuleSearchRequest(rrs);\n\t\t\t\treq.setBooleanFilter(rrs.PROPS.R_NIGHT_MODE, isNight);\n\t\t\t\tif (req.searchRenderingAttribute(\"route\")) {\n\t\t\t\t\tRenderingContext rc = new OsmandRenderer.RenderingContext(view.getContext());\n\t\t\t\t\trc.setDensityValue((float) tileBox.getMapDensity());\n//\t\t\t\t\tcachedColor = req.getIntPropertyValue(rrs.PROPS.R_COLOR);\n\t\t\t\t\tosmandRenderer.updatePaint(req, paint, 0, false, rc);\n\t\t\t\t\tif(paint.getStrokeWidth() == 0) {\n\t\t\t\t\t\tpaint.setStrokeWidth(12 * view.getDensity());\n\t\t\t\t\t}\n\t\t\t\t\tosmandRenderer.updatePaint(req, actionPaint, 2, false, rc);\n\t\t\t\t\tactionPaint.setColor(Color.BLUE);\n\t\t\t\t\tpaintIconAction.setColorFilter(new PorterDuffColorFilter(actionPaint.getColor(), Mode.MULTIPLY));\n\t\t\t\t\t// TODO remove\n\t\t\t\t\t// actionPaint.setColor(Color.WHITE);\n\t\t\t\t\t\n\t\t\t\t\tisPaint2 = osmandRenderer.updatePaint(req, paint2, 1, false, rc);\n\t\t\t\t\tisPaint_1 = osmandRenderer.updatePaint(req, paint_1, -1, false, rc);\n\t\t\t\t\tisShadowPaint = req.isSpecified(rrs.PROPS.R_SHADOW_RADIUS);\n\t\t\t\t\tif(isShadowPaint) {\n\t\t\t\t\t\tColorFilter cf = new PorterDuffColorFilter(req.getIntPropertyValue(rrs.PROPS.R_SHADOW_COLOR), Mode.SRC_IN);\n\t\t\t\t\t\tshadowPaint.setColorFilter(cf);\n\t\t\t\t\t\tshadowPaint.setStrokeWidth(paint.getStrokeWidth() + 2 * rc.getComplexValue(req, rrs.PROPS.R_SHADOW_RADIUS));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.println(\"Rendering attribute route is not found !\");\n\t\t\t\t\tpaint.setStrokeWidth(12 * view.getDensity());\n\t\t\t\t}\n\t\t\t\tactionPaint.setStrokeWidth(7 * view.getScaleCoefficient());\n\t\t\t}\n\t\t}\n\t}","commit_id":"a2aa63e3b6cc7ef020d2e81da3879af1ceb215e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void drawLocations(RotatedTileBox tb, Canvas canvas, double topLatitude, double leftLongitude, double bottomLatitude, double rightLongitude) {\n\t\tpoints.clear();\n\t\tactionPoints.clear();\n\t\tboolean previousVisible = false;\n\t\tLocation lastProjection = helper.getLastProjection();\n\t\tif (lastProjection != null) {\n\t\t\tif (leftLongitude <= lastProjection.getLongitude() && lastProjection.getLongitude() <= rightLongitude\n\t\t\t\t\t&& bottomLatitude <= lastProjection.getLatitude() && lastProjection.getLatitude() <= topLatitude) {\n\t\t\t\tpoints.add(lastProjection);\n\t\t\t\tpreviousVisible = true;\n\t\t\t}\n\t\t}\n\t\tList<Location> routeNodes = helper.getRoute().getRouteLocations();\n\t\tint cd = helper.getRoute().getCurrentRoute();\n\t\tList<RouteDirectionInfo> rd = helper.getRouteDirections();\n\t\tIterator<RouteDirectionInfo> it = rd.iterator();\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tif (leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n\t\t\t\t\t&& ls.getLatitude() <= topLatitude) {\n\t\t\t\tpoints.add(ls);\n\t\t\t\t\n\t\t\t\tif (!previousVisible) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tpoints.add(0, routeNodes.get(i - 1));\n\t\t\t\t\t} else if (lastProjection != null) {\n\t\t\t\t\t\tpoints.add(0, lastProjection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousVisible = true;\n\t\t\t} else if (previousVisible) {\n\t\t\t\tpoints.add(ls);\n\t\t\t\tdrawSegment(tb, canvas);\n\t\t\t\tpreviousVisible = false;\n\t\t\t\tpoints.clear();\n\t\t\t}\n\t\t}\n\t\tdrawSegment(tb, canvas);\n\t\tif (tb.getZoom() >= 14) {\n\t\t\tcalculateActionPoints(topLatitude, leftLongitude, bottomLatitude, rightLongitude, lastProjection,\n\t\t\t\t\trouteNodes, cd, it);\n\t\t\tdrawAction(tb, canvas);\n\t\t}\n\t}","id":32489,"modified_method":"public void drawLocations(RotatedTileBox tb, Canvas canvas, double topLatitude, double leftLongitude, double bottomLatitude, double rightLongitude) {\n\t\tpoints.clear();\n\t\tactionPoints.clear();\n\t\tboolean previousVisible = false;\n\t\tLocation lastProjection = helper.getLastProjection();\n\t\tif (lastProjection != null) {\n\t\t\tif (leftLongitude <= lastProjection.getLongitude() && lastProjection.getLongitude() <= rightLongitude\n\t\t\t\t\t&& bottomLatitude <= lastProjection.getLatitude() && lastProjection.getLatitude() <= topLatitude) {\n\t\t\t\tpoints.add(lastProjection);\n\t\t\t\tpreviousVisible = true;\n\t\t\t}\n\t\t}\n\t\tList<Location> routeNodes = helper.getRoute().getRouteLocations();\n\t\tint cd = helper.getRoute().getCurrentRoute();\n\t\tList<RouteDirectionInfo> rd = helper.getRouteDirections();\n\t\tIterator<RouteDirectionInfo> it = rd.iterator();\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tif (leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n\t\t\t\t\t&& ls.getLatitude() <= topLatitude) {\n\t\t\t\tpoints.add(ls);\n\t\t\t\t\n\t\t\t\tif (!previousVisible) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tpoints.add(0, routeNodes.get(i - 1));\n\t\t\t\t\t} else if (lastProjection != null) {\n\t\t\t\t\t\tpoints.add(0, lastProjection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousVisible = true;\n\t\t\t} else if (previousVisible) {\n\t\t\t\tpoints.add(ls);\n\t\t\t\tdrawSegment(tb, canvas);\n\t\t\t\tpreviousVisible = false;\n\t\t\t\tpoints.clear();\n\t\t\t}\n\t\t}\n\t\tdrawSegment(tb, canvas);\n\t\tif (tb.getZoom() >= 14) {\n\t\t\tcalculateActionPoints(topLatitude, leftLongitude, bottomLatitude, rightLongitude, lastProjection,\n\t\t\t\t\trouteNodes, cd, it, tb.getZoom());\n\t\t\tdrawAction(tb, canvas);\n\t\t}\n\t}","commit_id":"a2aa63e3b6cc7ef020d2e81da3879af1ceb215e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public int calculateSplitPaths(RotatedTileBox tb, TIntArrayList xs, TIntArrayList ys,\n\t\t\t\t\t\t\t\t   TIntArrayList results) {\n\t\tint px = xs.get(0);\n\t\tint py = ys.get(0);\n\t\tint h = tb.getPixHeight();\n\t\tint w = tb.getPixWidth();\n\t\tint cnt = 0;\n\t\tboolean pin = isIn(px, py, 0, 0, w, h);\n\t\tPath path = null;\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tint x = xs.get(i);\n\t\t\tint y = ys.get(i);\n\t\t\tboolean in = isIn(x, y, 0, 0, w, h);\n\t\t\tboolean draw = false;\n\t\t\tif (pin && in) {\n\t\t\t\tdraw = true;\n\t\t\t} else {\n\t\t\t\tlong intersection = MapAlgorithms.calculateIntersection(x, y,\n\t\t\t\t\t\tpx, py, 0, w, h, 0);\n\t\t\t\tif (intersection != -1) {\n\t\t\t\t\tdraw = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (draw) {\n\t\t\t\tpath = new Path();\n\t\t\t\tresults.add(px);\n\t\t\t\tresults.add(py);\n\t\t\t\tresults.add(x);\n\t\t\t\tresults.add(y);\n\t\t\t}\n\t\t\tpin = in;\n\t\t\tpx = x;\n\t\t\tpy = y;\n\t\t}\n\t\treturn cnt;\n\t}","id":32490,"modified_method":"public int calculateSplitPaths(RotatedTileBox tb, TIntArrayList xs, TIntArrayList ys,\n\t\t\t\t\t\t\t\t   TIntArrayList results) {\n\t\tint px = xs.get(0);\n\t\tint py = ys.get(0);\n\t\tint h = tb.getPixHeight();\n\t\tint w = tb.getPixWidth();\n\t\tint left =  -w / 4;\n\t\tint right = w + w / 4;\n\t\tint top = - h/4;\n\t\tint bottom = h + h/4;\n\t\tint cnt = 0;\n\t\t\n\t\tboolean pin = isIn(px, py, left, top, right, bottom);\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tint x = xs.get(i);\n\t\t\tint y = ys.get(i);\n\t\t\tboolean in = isIn(x, y, left, top, right, bottom);\n\t\t\tboolean draw = false;\n\t\t\tif (pin && in) {\n\t\t\t\tdraw = true;\n\t\t\t} else {\n\t\t\t\tlong intersection = MapAlgorithms.calculateIntersection(x, y,\n\t\t\t\t\t\tpx, py, left, right, bottom, top);\n\t\t\t\tif (intersection != -1) {\n\t\t\t\t\tdraw = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (draw) {\n\t\t\t\tresults.add(px);\n\t\t\t\tresults.add(py);\n\t\t\t\tresults.add(x);\n\t\t\t\tresults.add(y);\n\t\t\t}\n\t\t\tpin = in;\n\t\t\tpx = x;\n\t\t\tpy = y;\n\t\t}\n\t\treturn cnt;\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void updateLayerStyle() {\n\t\tcachedHash = -1;\n\t}","id":32491,"modified_method":"public void updateLayerStyle() {\n\t\tattrs.cachedHash = -1;\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawAction(RotatedTileBox tb, Canvas canvas) {\n\t\tif (actionPoints.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\ttry {\n\t\t\t\tPath pth = new Path();\n\t\t\t\tMatrix matrix = new Matrix();\n\t\t\t\tboolean first = true;\n\t\t\t\tint x = 0, px = 0, py = 0, y = 0;\n\t\t\t\tfor (int i = 0; i < actionPoints.size(); i++) {\n\t\t\t\t\tLocation o = actionPoints.get(i);\n\t\t\t\t\tif (o == null) {\n\t\t\t\t\t\tfirst = true;\n\t\t\t\t\t\tcanvas.drawPath(pth, actionPaint);\n\t\t\t\t\t\tdouble angleRad = Math.atan2(y - py, x - px);\n\t\t\t\t\t\tdouble angle = (angleRad * 180 / Math.PI) + 90f;\n\t\t\t\t\t\tdouble distSegment = Math.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\t\t\t\tif (distSegment == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// int len = (int) (distSegment / pxStep);\n\t\t\t\t\t\tfloat pdx = x - px;\n\t\t\t\t\t\tfloat pdy = y - py;\n\t\t\t\t\t\tmatrix.reset();\n\t\t\t\t\t\tmatrix.postTranslate(0, -actionArrow.getHeight() / 2);\n\t\t\t\t\t\tmatrix.postRotate((float) angle, actionArrow.getWidth() / 2, 0);\n\t\t\t\t\t\tmatrix.postTranslate(px + pdx - actionArrow.getWidth() / 2, py + pdy);\n\t\t\t\t\t\tcanvas.drawBitmap(actionArrow, matrix, paintIconAction);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpx = x;\n\t\t\t\t\t\tpy = y;\n\t\t\t\t\t\tx = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\ty = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tpth.reset();\n\t\t\t\t\t\t\tpth.moveTo(x, y);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpth.lineTo(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} finally {\n\t\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\t}\n\t\t}\n\t}","id":32492,"modified_method":"private void drawAction(RotatedTileBox tb, Canvas canvas) {\n\t\tif (actionPoints.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\ttry {\n\t\t\t\tPath pth = new Path();\n\t\t\t\tMatrix matrix = new Matrix();\n\t\t\t\tboolean first = true;\n\t\t\t\tint x = 0, px = 0, py = 0, y = 0;\n\t\t\t\tfor (int i = 0; i < actionPoints.size(); i++) {\n\t\t\t\t\tLocation o = actionPoints.get(i);\n\t\t\t\t\tif (o == null) {\n\t\t\t\t\t\tfirst = true;\n\t\t\t\t\t\tcanvas.drawPath(pth, attrs.paint3);\n\t\t\t\t\t\tdouble angleRad = Math.atan2(y - py, x - px);\n\t\t\t\t\t\tdouble angle = (angleRad * 180 / Math.PI) + 90f;\n\t\t\t\t\t\tdouble distSegment = Math.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\t\t\t\tif (distSegment == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// int len = (int) (distSegment / pxStep);\n\t\t\t\t\t\tfloat pdx = x - px;\n\t\t\t\t\t\tfloat pdy = y - py;\n\t\t\t\t\t\tmatrix.reset();\n\t\t\t\t\t\tmatrix.postTranslate(0, -actionArrow.getHeight() / 2);\n\t\t\t\t\t\tmatrix.postRotate((float) angle, actionArrow.getWidth() / 2, 0);\n\t\t\t\t\t\tmatrix.postTranslate(px + pdx - actionArrow.getWidth() / 2, py + pdy);\n\t\t\t\t\t\tcanvas.drawBitmap(actionArrow, matrix, paintIconAction);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpx = x;\n\t\t\t\t\t\tpy = y;\n\t\t\t\t\t\tx = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\ty = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tpth.reset();\n\t\t\t\t\t\t\tpth.moveTo(x, y);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpth.lineTo(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} finally {\n\t\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\t}\n\t\t}\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void initLayer(OsmandMapTileView view) {\n\t\tthis.view = view;\n\t\tosmandRenderer = view.getApplication().getResourceManager().getRenderer().getRenderer();\n\t\tinitUI();\n\t}","id":32493,"modified_method":"@Override\n\tpublic void initLayer(OsmandMapTileView view) {\n\t\tthis.view = view;\n\t\tinitUI();\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawArrowsOverPath(Canvas canvas, TIntArrayList lst, Bitmap arrow) {\n\t\tfloat pxStep = arrow.getHeight() * 4f;\n\t\tMatrix matrix = new Matrix();\n\t\tfloat dist = 0;\n\t\tfor (int i = 0; i < lst.size(); i += 4) {\n\t\t\tint px = lst.get(i);\n\t\t\tint py = lst.get(i + 1);\n\t\t\tint x = lst.get(i + 2);\n\t\t\tint y = lst.get(i + 3);\n\t\t\tfloat angleRad = (float) Math.atan2(y - py, x - px);\n\t\t\tfloat angle = (float) (angleRad * 180 / Math.PI) + 90f;\n\t\t\tfloat distSegment = (float) Math.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\tif(distSegment == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint len = (int) (distSegment / pxStep);\n\t\t\tif (len > 0) {\n\t\t\t\tfloat pdx = ((x - px) / len);\n\t\t\t\tfloat pdy = ((y - py) / len);\n\t\t\t\tfor (int k = 1; k <= len; k++) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate(angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + k * pdx- arrow.getWidth() / 2 , py + pdy * k);\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(dist > pxStep) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate(angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + (x - px) / 2 - arrow.getWidth() / 2, py + (y - py) / 2);\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist += distSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":32494,"modified_method":"private void drawArrowsOverPath(Canvas canvas, TIntArrayList lst, Bitmap arrow) {\n\t\tdouble pxStep = arrow.getHeight() * 4f;\n\t\tMatrix matrix = new Matrix();\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < lst.size(); i += 4) {\n\t\t\tint px = lst.get(i);\n\t\t\tint py = lst.get(i + 1);\n\t\t\tint x = lst.get(i + 2);\n\t\t\tint y = lst.get(i + 3);\n\t\t\tdouble angleRad = Math.atan2(y - py, x - px);\n\t\t\tdouble angle = (angleRad * 180 / Math.PI) + 90f;\n\t\t\tdouble distSegment = Math.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\tif(distSegment == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint len = (int) (distSegment / pxStep);\n\t\t\tif (len > 0) {\n\t\t\t\tdouble pdx = ((x - px) / len);\n\t\t\t\tdouble pdy = ((y - py) / len);\n\t\t\t\tfor (int k = 1; k <= len; k++) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate((float) angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate((float)(px + k * pdx- arrow.getWidth() / 2) , (float)(py + pdy * k));\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(dist > pxStep) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate((float) angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + (x - px) / 2 - arrow.getWidth() / 2, py + (y - py) / 2);\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist += distSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawSegment(RotatedTileBox tb, Canvas canvas) {\n\t\tif (points.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\ttry {\n\t\t\t\tTIntArrayList tx = new TIntArrayList();\n\t\t\t\tTIntArrayList ty = new TIntArrayList();\n\t\t\t\tfor (int i = 0; i < points.size(); i++) {\n\t\t\t\t\tLocation o = points.get(i);\n\t\t\t\t\tint x = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\tint y = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\ttx.add(x);\n\t\t\t\t\tty.add(y);\n\t\t\t\t}\n\t\t\t\tcalculatePath(tb, tx, ty, path);\n\n\t\t\t\tif (isPaint_1) {\n\t\t\t\t\tcanvas.drawPath(path, paint_1);\n\t\t\t\t}\n\t\t\t\tif (isShadowPaint) {\n\t\t\t\t\tcanvas.drawPath(path, shadowPaint);\n\t\t\t\t}\n\t\t\t\tcanvas.drawPath(path, paint);\n\t\t\t\tif (isPaint2) {\n\t\t\t\t\tcanvas.drawPath(path, paint2);\n\t\t\t\t}\n\t\t\t\tif (tb.getZoomAnimation() == 0) {\n\t\t\t\t\tTIntArrayList lst = new TIntArrayList(50);\n\t\t\t\t\tcalculateSplitPaths(tb, tx, ty, lst);\n\t\t\t\t\tdrawArrowsOverPath(canvas, lst, coloredArrowUp);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\t}\n\t\t}\n\t}","id":32495,"modified_method":"private void drawSegment(RotatedTileBox tb, Canvas canvas) {\n\t\tif (points.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\ttry {\n\t\t\t\tTIntArrayList tx = new TIntArrayList();\n\t\t\t\tTIntArrayList ty = new TIntArrayList();\n\t\t\t\tfor (int i = 0; i < points.size(); i++) {\n\t\t\t\t\tLocation o = points.get(i);\n\t\t\t\t\tint x = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\tint y = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\ttx.add(x);\n\t\t\t\t\tty.add(y);\n\t\t\t\t}\n\t\t\t\tcalculatePath(tb, tx, ty, path);\n\t\t\t\tattrs.drawPath(canvas, path);\n\t\t\t\tif (tb.getZoomAnimation() == 0) {\n\t\t\t\t\tTIntArrayList lst = new TIntArrayList(50);\n\t\t\t\t\tcalculateSplitPaths(tb, tx, ty, lst);\n\t\t\t\t\tdrawArrowsOverPath(canvas, lst, coloredArrowUp);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\t}\n\t\t}\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void initUI() {\n\t\tpaint = new Paint();\n\t\tpaint.setStyle(Style.STROKE);\n\t\tpaint.setAntiAlias(true);\n\t\tpaint.setStrokeCap(Cap.ROUND);\n\t\tpaint.setStrokeJoin(Join.ROUND);\n\t\tactionArrow = BitmapFactory.decodeResource(view.getResources(), R.drawable.map_action_arrow, null);\n\t\t\n\t\tactionPaint = new Paint();\n\t\tactionPaint.setStyle(Style.STROKE);\n\t\tactionPaint.setAntiAlias(true);\n\t\tactionPaint.setStrokeCap(Cap.BUTT);\n\t\tactionPaint.setStrokeJoin(Join.ROUND);\n\t\tactionPaint.setStrokeWidth(7 * view.getScaleCoefficient());\n\t\tactionPaint.setColor(Color.WHITE);\n\t\tpath = new Path();\n\t\t\n\t\tpaintIcon = new Paint();\n\t\tpaintIcon.setFilterBitmap(true);\n\t\tpaintIcon.setAntiAlias(true);\n\t\tpaintIcon.setColor(Color.BLACK);\n\t\tpaintIcon.setStrokeWidth(3);\n\t\t\n\n\t\tpaintIconAction = new Paint();\n\t\tpaintIconAction.setFilterBitmap(true);\n\t\tpaintIconAction.setAntiAlias(true);\n\t\t\n\t}","id":32496,"modified_method":"private void initUI() {\n\t\tactionArrow = BitmapFactory.decodeResource(view.getResources(), R.drawable.map_action_arrow, null);\n\t\tpath = new Path();\n\t\t\n\t\tpaintIcon = new Paint();\n\t\tpaintIcon.setFilterBitmap(true);\n\t\tpaintIcon.setAntiAlias(true);\n\t\tpaintIcon.setColor(Color.BLACK);\n\t\tpaintIcon.setStrokeWidth(3);\n\t\t\n\t\tpaintIconAction = new Paint();\n\t\tpaintIconAction.setFilterBitmap(true);\n\t\tpaintIconAction.setAntiAlias(true);\n\t\t\n\t\tattrs = new RenderingLineAttributes(\"route\");\n\t\tattrs.defaultWidth = (int) (12 * view.getDensity());\n\t\tattrs.defaultWidth3 = (int) (7 * view.getDensity());\n\t\tattrs.defaultColor = view.getResources().getColor(R.color.nav_track);\n\t\tattrs.paint3.setStrokeCap(Cap.BUTT);\n\t\tattrs.paint3.setColor(Color.WHITE);\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onPrepareBufferImage(Canvas canvas, RotatedTileBox tileBox, DrawSettings settings) {\n\t\tpath.reset();\n\t\tif (helper.getFinalLocation() != null && helper.getRoute().isCalculated()) {\n\t\t\tupdatePaints(settings, tileBox);\n\t\t\tif(coloredArrowUp == null) {\n\t\t\t\tBitmap originalArrowUp = BitmapFactory.decodeResource(view.getResources(), R.drawable.h_arrow, null);\n\t\t\t\tcoloredArrowUp = originalArrowUp;\n//\t\t\t\tcoloredArrowUp = Bitmap.createScaledBitmap(originalArrowUp, originalArrowUp.getWidth() * 3 / 4,\t\n//\t\t\t\t\t\toriginalArrowUp.getHeight() * 3 / 4, true);\n\t\t\t}\n\t\t\tint w = tileBox.getPixWidth();\n\t\t\tint h = tileBox.getPixHeight();\n\t\t\tLocation lastProjection = helper.getLastProjection();\n\t\t\tfinal RotatedTileBox cp ;\n\t\t\tif(lastProjection != null &&\n\t\t\t\t\ttileBox.containsLatLon(lastProjection.getLatitude(), lastProjection.getLongitude())){\n\t\t\t\tcp = tileBox.copy();\n\t\t\t\tcp.increasePixelDimensions(w /2, h);\n\t\t\t} else {\n\t\t\t\tcp = tileBox;\n\t\t\t}\n\n\t\t\tfinal QuadRect latlonRect = cp.getLatLonBounds();\n\t\t\tdouble topLatitude = latlonRect.top;\n\t\t\tdouble leftLongitude = latlonRect.left;\n\t\t\tdouble bottomLatitude = latlonRect.bottom;\n\t\t\tdouble rightLongitude = latlonRect.right;\n\t\t\tdouble lat = topLatitude - bottomLatitude + 0.1;\n\t\t\tdouble lon = rightLongitude - leftLongitude + 0.1;\n\t\t\tdrawLocations(tileBox, canvas, topLatitude + lat, leftLongitude - lon, bottomLatitude - lat, rightLongitude + lon);\n\t\t}\n\t\n\t}","id":32497,"modified_method":"@Override\n\tpublic void onPrepareBufferImage(Canvas canvas, RotatedTileBox tileBox, DrawSettings settings) {\n\t\tpath.reset();\n\t\tif (helper.getFinalLocation() != null && helper.getRoute().isCalculated()) {\n\t\t\tboolean updatePaints = attrs.updatePaints(view, settings, tileBox);\n\t\t\tattrs.isPaint3 = false;\n\t\t\tif(updatePaints) {\n\t\t\t\tpaintIconAction.setColorFilter(new PorterDuffColorFilter(attrs.paint3.getColor(), Mode.MULTIPLY));\n\t\t\t}\n\t\t\t\n\t\t\tif(coloredArrowUp == null) {\n\t\t\t\tBitmap originalArrowUp = BitmapFactory.decodeResource(view.getResources(), R.drawable.h_arrow, null);\n\t\t\t\tcoloredArrowUp = originalArrowUp;\n//\t\t\t\tcoloredArrowUp = Bitmap.createScaledBitmap(originalArrowUp, originalArrowUp.getWidth() * 3 / 4,\t\n//\t\t\t\t\t\toriginalArrowUp.getHeight() * 3 / 4, true);\n\t\t\t}\n\t\t\tint w = tileBox.getPixWidth();\n\t\t\tint h = tileBox.getPixHeight();\n\t\t\tLocation lastProjection = helper.getLastProjection();\n\t\t\tfinal RotatedTileBox cp ;\n\t\t\tif(lastProjection != null &&\n\t\t\t\t\ttileBox.containsLatLon(lastProjection.getLatitude(), lastProjection.getLongitude())){\n\t\t\t\tcp = tileBox.copy();\n\t\t\t\tcp.increasePixelDimensions(w /2, h);\n\t\t\t} else {\n\t\t\t\tcp = tileBox;\n\t\t\t}\n\n\t\t\tfinal QuadRect latlonRect = cp.getLatLonBounds();\n\t\t\tdouble topLatitude = latlonRect.top;\n\t\t\tdouble leftLongitude = latlonRect.left;\n\t\t\tdouble bottomLatitude = latlonRect.bottom;\n\t\t\tdouble rightLongitude = latlonRect.right;\n\t\t\tdouble lat = topLatitude - bottomLatitude + 0.1;\n\t\t\tdouble lon = rightLongitude - leftLongitude + 0.1;\n\t\t\tdrawLocations(tileBox, canvas, topLatitude + lat, leftLongitude - lon, bottomLatitude - lat, rightLongitude + lon);\n\t\t}\n\t\n\t}","commit_id":"d2a982398bcd148702b66e296c64a2e4c98a4838","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[] startColumn,\n      byte[] stopColumn) {\n    return this.table.get(row, startColumn, stopColumn,\n        new SimpleReadPointer(this.oracle.getTimestamp()));\n  }","id":32498,"modified_method":"@Override\n  public OperationResult<Map<byte[], byte[]>>\n  get(byte[] row, byte[] startColumn, byte[] stopColumn) {\n    return this.table.get(row, startColumn, stopColumn,\n        new SimpleReadPointer(this.oracle.getTimestamp()));\n  }","commit_id":"6d3fbbdf1b655a8f68d7ef43a731b78bcbd3e40a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean compareAndSwap(byte[] row, byte[] column,\n      byte[] expectedValue, byte[] newValue) {\n    long now = this.oracle.getTimestamp();\n    try {\n      return this.table.compareAndSwap(row, column, expectedValue, newValue,\n          new SimpleReadPointer(now), now);\n    } catch (com.continuuity.api.data.OperationException e) {\n      e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n    }\n  }","id":32499,"modified_method":"@Override\n  public void compareAndSwap(byte[] row, byte[] column,\n                             byte[] expectedValue, byte[] newValue)\n      throws OperationException {\n\n    long now = this.oracle.getTimestamp();\n    this.table.compareAndSwap(row, column, expectedValue, newValue,\n        new SimpleReadPointer(now), now);\n  }","commit_id":"6d3fbbdf1b655a8f68d7ef43a731b78bcbd3e40a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[][] columns) {\n    return this.table.get(row, columns,\n        new SimpleReadPointer(this.oracle.getTimestamp()));\n  }","id":32500,"modified_method":"@Override\n  public OperationResult<Map<byte[], byte[]>> get(byte[] row, byte[][] columns) {\n    return this.table.get(row, columns,\n        new SimpleReadPointer(this.oracle.getTimestamp()));\n  }","commit_id":"6d3fbbdf1b655a8f68d7ef43a731b78bcbd3e40a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row) {\n    return this.table.get(row,\n        new SimpleReadPointer(this.oracle.getTimestamp()));\n  }","id":32501,"modified_method":"@Override\n  public OperationResult<Map<byte[], byte[]>> get(byte[] row) {\n    return this.table.get(row,\n        new SimpleReadPointer(this.oracle.getTimestamp()));\n  }","commit_id":"6d3fbbdf1b655a8f68d7ef43a731b78bcbd3e40a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean compareAndSwap(byte[] key, byte[] expectedValue,\n      byte[] newValue) {\n    return columnarTable.compareAndSwap(key, COLUMN, expectedValue, newValue);\n  }","id":32502,"modified_method":"@Override\n  public void compareAndSwap(byte[] key, byte[] expectedValue,\n                             byte[] newValue) throws OperationException {\n    columnarTable.compareAndSwap(key, COLUMN, expectedValue, newValue);\n  }","commit_id":"6d3fbbdf1b655a8f68d7ef43a731b78bcbd3e40a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<Long, byte[]> getPoints(byte[] key, long startTime, long endTime) {\n    Map<byte[],byte[]> columns = table.get(key, Bytes.toBytes(reverse(endTime)),\n        Bytes.toBytes(reverse(startTime)));\n    Map<Long,byte[]> ret = new TreeMap<Long,byte[]>();\n    for (Map.Entry<byte[], byte[]> entry : columns.entrySet()) {\n      ret.put(Bytes.toLong(entry.getKey()), entry.getValue());\n    }\n    return ret;\n  }","id":32503,"modified_method":"@Override\n  public Map<Long, byte[]> getPoints(byte[] key, long startTime, long endTime) {\n    OperationResult<Map<byte[], byte[]>> columns =\n        table.get(key, Bytes.toBytes(reverse(endTime)),\n            Bytes.toBytes(reverse(startTime)));\n    Map<Long,byte[]> ret = new TreeMap<Long,byte[]>();\n    for (Map.Entry<byte[], byte[]> entry : columns.getValue().entrySet()) {\n      ret.put(Bytes.toLong(entry.getKey()), entry.getValue());\n    }\n    return ret;\n  }","commit_id":"6d3fbbdf1b655a8f68d7ef43a731b78bcbd3e40a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean compareAndSwap(byte[] key, byte[] expectedValue,\n      byte[] newValue, ReadPointer readPointer, long writeVersion) {\n    try {\n      return this.table.compareAndSwap(key, COLUMN, expectedValue, newValue,\n          readPointer, writeVersion);\n    } catch (com.continuuity.api.data.OperationException e) {\n      e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n    }\n  }","id":32504,"modified_method":"@Override\n  public void compareAndSwap(byte[] key,\n                             byte[] expectedValue, byte[] newValue,\n                             ReadPointer readPointer, long writeVersion)\n      throws OperationException {\n    this.table.compareAndSwap(key, COLUMN, expectedValue, newValue,\n        readPointer, writeVersion);\n  }","commit_id":"6d3fbbdf1b655a8f68d7ef43a731b78bcbd3e40a","url":"https://github.com/caskdata/cdap"},{"original_method":"private static void executeQuery(@NotNull Project project,\n                                   @NotNull VirtualFile file,\n                                   @NotNull Editor editor,\n                                   @NotNull ScriptEngine engine) {\n\n    TextRange selectedRange = EditorUtil.getSelectionInAnyMode(editor);\n    Document document = editor.getDocument();\n    if (selectedRange.getLength() == 0) {\n      int line = document.getLineNumber(selectedRange.getStartOffset());\n      selectedRange = TextRange.create(document.getLineStartOffset(line), document.getLineEndOffset(line));\n    }\n    String command = document.getText(selectedRange);\n    final ConsoleView consoleView = getConsoleView(project, file, engine);\n    try {\n      class IDE {\n        public void print(String s) {\n          consoleView.print(s + \"\\n\", ConsoleViewContentType.NORMAL_OUTPUT);\n        }\n        public void error(String s) {\n          consoleView.print(s + \"\\n\", ConsoleViewContentType.ERROR_OUTPUT);\n        }\n      }\n\n      // todo\n      //myHistoryController.getModel().addToHistory(command);\n      consoleView.print(\"> \" + command, ConsoleViewContentType.USER_INPUT);\n      consoleView.print(\"\\n\", ConsoleViewContentType.USER_INPUT);\n      engine.getBindings(ScriptContext.ENGINE_SCOPE).put(\"IDE\", new IDE());\n      Object o = engine.eval(command);\n      consoleView.print(\"=> \" + o, ConsoleViewContentType.NORMAL_OUTPUT);\n      consoleView.print(\"\\n\", ConsoleViewContentType.NORMAL_OUTPUT);\n      consoleView.print(\"\\n\", ConsoleViewContentType.NORMAL_OUTPUT);\n    }\n    catch (Exception e) {\n      consoleView.print(e.getMessage(), ConsoleViewContentType.ERROR_OUTPUT);\n      //consoleView.print(ExceptionUtil.getThrowableText(e), ConsoleViewContentType.ERROR_OUTPUT);\n      consoleView.print(\"\\n\", ConsoleViewContentType.ERROR_OUTPUT);\n    }\n    ((ConsoleViewImpl)consoleView).scrollToEnd();\n  }","id":32505,"modified_method":"private static void executeQuery(@NotNull final Project project_,\n                                   @NotNull VirtualFile file,\n                                   @NotNull Editor editor,\n                                   @NotNull ScriptEngine engine) {\n\n    TextRange selectedRange = EditorUtil.getSelectionInAnyMode(editor);\n    Document document = editor.getDocument();\n    if (selectedRange.getLength() == 0) {\n      int line = document.getLineNumber(selectedRange.getStartOffset());\n      selectedRange = TextRange.create(document.getLineStartOffset(line), document.getLineEndOffset(line));\n    }\n    VirtualFile profileChild = file.getParent().findChild(\".profile.\" + file.getExtension());\n    String profile = null;\n    try {\n      profile = profileChild == null ? \"\" : VfsUtilCore.loadText(profileChild);\n    }\n    catch (IOException ignored) {\n    }\n    String command = document.getText(selectedRange);\n    final RunContentDescriptor descriptor = getConsoleView(project_, file, engine);\n    ConsoleViewImpl consoleView = (ConsoleViewImpl)descriptor.getExecutionConsole();\n    try {\n      class IDE {\n        public final Application application = ApplicationManager.getApplication();\n        public final Project project = project_;\n        public void print(String s) {\n          printInContent(descriptor, s + \"\\n\", ConsoleViewContentType.NORMAL_OUTPUT);\n        }\n        public void error(String s) {\n          printInContent(descriptor, s + \"\\n\", ConsoleViewContentType.ERROR_OUTPUT);\n        }\n      }\n\n      //myHistoryController.getModel().addToHistory(command);\n      consoleView.print(\"> \" + command, ConsoleViewContentType.USER_INPUT);\n      consoleView.print(\"\\n\", ConsoleViewContentType.USER_INPUT);\n      engine.getBindings(ScriptContext.ENGINE_SCOPE).put(\"IDE\", new IDE());\n      Object o = engine.eval(profile == null ? command : profile + \"\\n\" + command);\n      consoleView.print(\"=> \" + o, ConsoleViewContentType.NORMAL_OUTPUT);\n      consoleView.print(\"\\n\", ConsoleViewContentType.NORMAL_OUTPUT);\n    }\n    catch (Exception e) {\n      consoleView.print(ExceptionUtil.getRootCause(e).getMessage(), ConsoleViewContentType.ERROR_OUTPUT);\n      consoleView.print(\"\\n\", ConsoleViewContentType.ERROR_OUTPUT);\n    }\n    selectContent(descriptor);\n    consoleView.scrollToEnd();\n  }","commit_id":"afad35dd4e8b6e3388e6345c4a853971e87650a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static ConsoleView getConsoleView(@NotNull Project project, @NotNull VirtualFile file, @NotNull ScriptEngine engine) {\n    PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    WeakReference<ConsoleView> ref = psiFile == null ? null : psiFile.getCopyableUserData(CONSOLE_VIEW_KEY);\n    ConsoleView existing = ref == null ? null : ref.get();\n    if (existing != null && !Disposer.isDisposed(existing)) return existing;\n    ConsoleView consoleView = TextConsoleBuilderFactory.getInstance().createBuilder(project).getConsole();\n    if (psiFile != null) psiFile.putCopyableUserData(CONSOLE_VIEW_KEY, new WeakReference<ConsoleView>(consoleView));\n    DefaultActionGroup toolbarActions = new DefaultActionGroup();\n    JComponent consoleComponent = new JPanel(new BorderLayout());\n    consoleComponent.add(consoleView.getComponent(), BorderLayout.CENTER);\n    consoleComponent.add(ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, toolbarActions, false).getComponent(),\n                         BorderLayout.WEST);\n    final RunContentDescriptor descriptor = new RunContentDescriptor(consoleView, null, consoleComponent, file.getName()) {\n      @Override\n      public boolean isContentReuseProhibited() {\n        return true;\n      }\n    };\n\n    final Executor executor = DefaultRunExecutor.getRunExecutorInstance();\n    //toolbarActions.add(new DumbAwareAction(\"Rerun\", null, AllIcons.Actions.Rerun) {\n    //  @Override\n    //  public void update(@NotNull AnActionEvent e) {\n    //    ProgressIndicator indicator = indicatorRef.get();\n    //    e.getPresentation().setEnabled(file.isValid() && (indicator == null || !indicator.isRunning()));\n    //  }\n    //\n    //  @Override\n    //  public void actionPerformed(@NotNull AnActionEvent e) {\n    //    consoleView.clear();\n    //    rerunRunnable.run();\n    //  }\n    //});\n    toolbarActions.add(new CloseAction(executor, descriptor, project));\n    for (AnAction action : consoleView.createConsoleActions()) {\n      toolbarActions.add(action);\n    }\n    ExecutionManager.getInstance(project).getContentManager().showRunContent(executor, descriptor);\n    return consoleView;\n  }","id":32506,"modified_method":"@NotNull\n  private static RunContentDescriptor getConsoleView(@NotNull Project project, @NotNull VirtualFile file, @NotNull ScriptEngine engine) {\n    PsiFile psiFile = ObjectUtils.assertNotNull(PsiManager.getInstance(project).findFile(file));\n\n    WeakReference<RunContentDescriptor> ref = psiFile.getCopyableUserData(DESCRIPTOR_KEY);\n    RunContentDescriptor existing = ref == null ? null : ref.get();\n    if (existing != null && existing.getExecutionConsole() != null) return existing;\n    ConsoleView consoleView = TextConsoleBuilderFactory.getInstance().createBuilder(project).getConsole();\n\n    DefaultActionGroup toolbarActions = new DefaultActionGroup();\n    JComponent consoleComponent = new JPanel(new BorderLayout());\n    consoleComponent.add(consoleView.getComponent(), BorderLayout.CENTER);\n    consoleComponent.add(ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, toolbarActions, false).getComponent(),\n                         BorderLayout.WEST);\n    final RunContentDescriptor descriptor = new RunContentDescriptor(consoleView, null, consoleComponent, file.getName()) {\n      @Override\n      public boolean isContentReuseProhibited() {\n        return true;\n      }\n    };\n\n    Executor executor = DefaultRunExecutor.getRunExecutorInstance();\n    //toolbarActions.add(new DumbAwareAction(\"Rerun\", null, AllIcons.Actions.Rerun) {\n    //  @Override\n    //  public void update(@NotNull AnActionEvent e) {\n    //    ProgressIndicator indicator = indicatorRef.get();\n    //    e.getPresentation().setEnabled(file.isValid() && (indicator == null || !indicator.isRunning()));\n    //  }\n    //\n    //  @Override\n    //  public void actionPerformed(@NotNull AnActionEvent e) {\n    //    consoleView.clear();\n    //    rerunRunnable.run();\n    //  }\n    //});\n    toolbarActions.add(new CloseAction(executor, descriptor, project));\n    for (AnAction action : consoleView.createConsoleActions()) {\n      toolbarActions.add(action);\n    }\n    psiFile.putCopyableUserData(DESCRIPTOR_KEY, new WeakReference<RunContentDescriptor>(descriptor));\n    ExecutionManager.getInstance(project).getContentManager().showRunContent(executor, descriptor);\n    return descriptor;\n  }","commit_id":"afad35dd4e8b6e3388e6345c4a853971e87650a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public Spacing getSpacing(@Nullable Block child1, @NotNull Block child2) {\n    if (child1 instanceof ASTBlock && child2 instanceof ASTBlock) {\n      final ASTNode node1 = ((ASTBlock)child1).getNode();\n      ASTNode node2 = ((ASTBlock)child2).getNode();\n      final IElementType childType1 = node1.getElementType();\n      final PsiElement psi1 = node1.getPsi();\n\n      PsiElement psi2 = node2.getPsi();\n      // skip not inline comments to handles blank lines between various declarations\n      if (psi2 instanceof PsiComment && hasLineBreaksBeforeInSameParent(node2, 1)) {\n        final PsiElement nonCommentAfter = PyPsiUtils.getNextNonCommentSibling(psi2, true);\n        if (nonCommentAfter != null) {\n          psi2 = nonCommentAfter;\n        }\n      }\n      node2 = psi2.getNode();\n      final IElementType childType2 = psi2.getNode().getElementType();\n      //noinspection ConstantConditions\n      child2 = getSubBlockByNode(node2);\n      final CommonCodeStyleSettings settings = myContext.getSettings();\n\n      if ((childType1 == PyTokenTypes.EQ || childType2 == PyTokenTypes.EQ)) {\n        final PyNamedParameter namedParameter = as(myNode.getPsi(), PyNamedParameter.class);\n        if (namedParameter != null && namedParameter.getAnnotation() != null) {\n          return Spacing.createSpacing(1, 1, 0, settings.KEEP_LINE_BREAKS, settings.KEEP_BLANK_LINES_IN_CODE);\n        }\n      }\n      \n      if (childType1 == PyTokenTypes.COLON && psi2 instanceof PyStatementList) {\n        if (needLineBreakInStatement()) {\n          return Spacing.createSpacing(0, 0, 1, true, settings.KEEP_BLANK_LINES_IN_CODE);\n        }\n      }\n\n      if ((PyElementTypes.CLASS_OR_FUNCTION.contains(childType1) && STATEMENT_OR_DECLARATION.contains(childType2)) ||\n          STATEMENT_OR_DECLARATION.contains(childType1) && PyElementTypes.CLASS_OR_FUNCTION.contains(childType2)) {\n        if (PyUtil.isTopLevel(psi1)) {\n          return getBlankLinesForOption(myContext.getPySettings().BLANK_LINES_AROUND_TOP_LEVEL_CLASSES_FUNCTIONS);\n        }\n      }\n\n      if (psi1 instanceof PyImportStatementBase) {\n        if (psi2 instanceof PyImportStatementBase) {\n          if (psi2.getCopyableUserData(IMPORT_GROUP_BEGIN) != null) {\n            return Spacing.createSpacing(0, 0, 2, true, 1);\n          }\n          else if (psi1.getCopyableUserData(IMPORT_GROUP_BEGIN) != null) {\n            // It's a trick to keep spacing consistent when new import statement is inserted\n            // at the beginning of an import group, i.e. if there is a blank line before the next\n            // import we want to save it, but remove line *after* inserted import.\n            return Spacing.createSpacing(0, 0, 1, false, 0);\n          }\n        }\n        if (psi2 instanceof PyStatement && !(psi2 instanceof PyImportStatementBase)) {\n          if (PyUtil.isTopLevel(psi1)) {\n            return getBlankLinesForOption(settings.BLANK_LINES_AFTER_IMPORTS);\n          }\n          else {\n            return getBlankLinesForOption(myContext.getPySettings().BLANK_LINES_AFTER_LOCAL_IMPORTS);\n          }\n        }\n      }\n\n      if (psi2 instanceof PsiComment && !hasLineBreaksBeforeInSameParent(psi2.getNode(), 1) && myContext.getPySettings().SPACE_BEFORE_NUMBER_SIGN) {\n        return Spacing.createSpacing(2, 0, 0, false, 0);\n      }\n    }\n    return myContext.getSpacingBuilder().getSpacing(this, child1, child2);\n  }","id":32507,"modified_method":"@Override\n  @Nullable\n  public Spacing getSpacing(@Nullable Block child1, @NotNull Block child2) {\n    if (child1 instanceof ASTBlock && child2 instanceof ASTBlock) {\n      final ASTNode node1 = ((ASTBlock)child1).getNode();\n      ASTNode node2 = ((ASTBlock)child2).getNode();\n      final IElementType childType1 = node1.getElementType();\n      final PsiElement psi1 = node1.getPsi();\n\n      PsiElement psi2 = node2.getPsi();\n      // skip not inline comments to handles blank lines between various declarations\n      if (psi2 instanceof PsiComment && hasLineBreaksBeforeInSameParent(node2, 1)) {\n        final PsiElement nonCommentAfter = PyPsiUtils.getNextNonCommentSibling(psi2, true);\n        if (nonCommentAfter != null) {\n          psi2 = nonCommentAfter;\n        }\n      }\n      node2 = psi2.getNode();\n      final IElementType childType2 = psi2.getNode().getElementType();\n      //noinspection ConstantConditions\n      child2 = getSubBlockByNode(node2);\n      final CommonCodeStyleSettings settings = myContext.getSettings();\n\n      if ((childType1 == PyTokenTypes.EQ || childType2 == PyTokenTypes.EQ)) {\n        final PyNamedParameter namedParameter = as(myNode.getPsi(), PyNamedParameter.class);\n        if (namedParameter != null && namedParameter.getAnnotation() != null) {\n          return Spacing.createSpacing(1, 1, 0, settings.KEEP_LINE_BREAKS, settings.KEEP_BLANK_LINES_IN_CODE);\n        }\n      }\n      \n      if (childType1 == PyTokenTypes.COLON && psi2 instanceof PyStatementList) {\n        if (needLineBreakInStatement()) {\n          return Spacing.createSpacing(0, 0, 1, true, settings.KEEP_BLANK_LINES_IN_CODE);\n        }\n      }\n\n      if ((PyElementTypes.CLASS_OR_FUNCTION.contains(childType1) && STATEMENT_OR_DECLARATION.contains(childType2)) ||\n          STATEMENT_OR_DECLARATION.contains(childType1) && PyElementTypes.CLASS_OR_FUNCTION.contains(childType2)) {\n        if (PyUtil.isTopLevel(psi1)) {\n          return getBlankLinesForOption(myContext.getPySettings().BLANK_LINES_AROUND_TOP_LEVEL_CLASSES_FUNCTIONS);\n        }\n      }\n\n      if (psi1 instanceof PyImportStatementBase) {\n        if (psi2 instanceof PyImportStatementBase) {\n          final Boolean leftImportIsGroupStart = psi1.getCopyableUserData(IMPORT_GROUP_BEGIN);\n          final Boolean rightImportIsGroupStart = psi2.getCopyableUserData(IMPORT_GROUP_BEGIN);\n          // Cleanup user data, it's no longer needed\n          psi1.putCopyableUserData(IMPORT_GROUP_BEGIN, null);\n          // Don't remove IMPORT_GROUP_BEGIN from the element psi2 yet, because spacing is constructed pairwise: \n          // it might be needed on the next iteration.\n          //psi2.putCopyableUserData(IMPORT_GROUP_BEGIN, null);\n          if (rightImportIsGroupStart != null) {\n            return Spacing.createSpacing(0, 0, 2, true, 1);\n          }\n          else if (leftImportIsGroupStart != null) {\n            // It's a trick to keep spacing consistent when new import statement is inserted\n            // at the beginning of an import group, i.e. if there is a blank line before the next\n            // import we want to save it, but remove line *after* inserted import.\n            return Spacing.createSpacing(0, 0, 1, false, 0);\n          }\n        }\n        if (psi2 instanceof PyStatement && !(psi2 instanceof PyImportStatementBase)) {\n          if (PyUtil.isTopLevel(psi1)) {\n            return getBlankLinesForOption(settings.BLANK_LINES_AFTER_IMPORTS);\n          }\n          else {\n            return getBlankLinesForOption(myContext.getPySettings().BLANK_LINES_AFTER_LOCAL_IMPORTS);\n          }\n        }\n      }\n\n      if (psi2 instanceof PsiComment && !hasLineBreaksBeforeInSameParent(psi2.getNode(), 1) && myContext.getPySettings().SPACE_BEFORE_NUMBER_SIGN) {\n        return Spacing.createSpacing(2, 0, 0, false, 0);\n      }\n    }\n    return myContext.getSpacingBuilder().getSpacing(this, child1, child2);\n  }","commit_id":"4128424a5f8ebeb783a476ebf763ea9548656b3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateStars(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tlong starredGroupId = ParamUtil.getLong(\n\t\t\tactionRequest, \"starredGroupId\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\tactionResponse);\n\n\t\ttry {\n\t\t\tGroupServiceUtil.getGroup(starredGroupId);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tjsonObject.put(\"result\", \"failure\");\n\n\t\t\tServletResponseUtil.write(response, jsonObject.toString());\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tif (Validator.isNotNull(portletResource)) {\n\t\t\tpreferences = PortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tactionRequest, portletResource);\n\t\t}\n\n\t\tString starredGroupIds = preferences.getValue(\n\t\t\t\"starredGroupIds\", StringPool.BLANK);\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tstarredGroupIds = StringUtil.add(\n\t\t\t\tstarredGroupIds, String.valueOf(starredGroupId));\n\t\t}\n\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\tstarredGroupIds = StringUtil.remove(\n\t\t\t\tstarredGroupIds, String.valueOf(starredGroupId));\n\t\t}\n\n\t\tpreferences.setValue(\"starredGroupIds\", starredGroupIds);\n\n\t\tpreferences.store();\n\n\t\tjsonObject.put(\"result\", \"success\");\n\n\t\tServletResponseUtil.write(response, jsonObject.toString());\n\t}","id":32508,"modified_method":"public void updateStars(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tlong starredGroupId = ParamUtil.getLong(\n\t\t\tactionRequest, \"starredGroupId\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\tactionResponse);\n\n\t\ttry {\n\t\t\tGroupServiceUtil.getGroup(starredGroupId);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tjsonObject.put(\"result\", \"failure\");\n\n\t\t\tServletResponseUtil.write(response, jsonObject.toString());\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tactionRequest, \"5_WAR_soportlet\");\n\n\t\tString starredGroupIds = preferences.getValue(\n\t\t\t\"starredGroupIds\", StringPool.BLANK);\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tstarredGroupIds = StringUtil.add(\n\t\t\t\tstarredGroupIds, String.valueOf(starredGroupId));\n\t\t}\n\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\tstarredGroupIds = StringUtil.remove(\n\t\t\t\tstarredGroupIds, String.valueOf(starredGroupId));\n\t\t}\n\n\t\tpreferences.setValue(\"starredGroupIds\", starredGroupIds);\n\n\t\tpreferences.store();\n\n\t\tjsonObject.put(\"result\", \"success\");\n\n\t\tServletResponseUtil.write(response, jsonObject.toString());\n\t}","commit_id":"bffbf74dde020ac7a0f588e5346b5048a93486a6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void getSites(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tboolean directory = ParamUtil.getBoolean(resourceRequest, \"directory\");\n\t\tString keywords = DAOParamUtil.getLike(resourceRequest, \"keywords\");\n\t\tboolean userGroups = ParamUtil.getBoolean(\n\t\t\tresourceRequest, \"userGroups\");\n\t\tint maxResultSize = ParamUtil.getInteger(\n\t\t\tresourceRequest, \"maxResultSize\", 10);\n\t\tint start = ParamUtil.getInteger(resourceRequest, \"start\");\n\t\tint end = ParamUtil.getInteger(resourceRequest, \"end\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONObject optionsJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\toptionsJSONObject.put(\"directory\", directory);\n\t\toptionsJSONObject.put(\"keywords\", keywords);\n\t\toptionsJSONObject.put(\"userGroups\", userGroups);\n\t\toptionsJSONObject.put(\"maxResultSize\", maxResultSize);\n\t\toptionsJSONObject.put(\"start\", start);\n\t\toptionsJSONObject.put(\"end\", end);\n\n\t\tjsonObject.put(\"options\", optionsJSONObject);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tList<Group> groups = null;\n\t\tint count = 0;\n\n\t\tPortletPreferences preferences = resourceRequest.getPreferences();\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tresourceRequest, \"portletResource\");\n\n\t\tif (Validator.isNotNull(portletResource)) {\n\t\t\tpreferences = PortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tresourceRequest, portletResource);\n\t\t}\n\n\t\tif (directory) {\n\t\t\tLinkedHashMap<String, Object> params =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tif (userGroups) {\n\t\t\t\tparams.put(\"usersGroups\", themeDisplay.getUserId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tList<Integer> types = new ArrayList<Integer>();\n\n\t\t\t\ttypes.add(GroupConstants.TYPE_SITE_OPEN);\n\t\t\t\ttypes.add(GroupConstants.TYPE_SITE_RESTRICTED);\n\n\t\t\t\tparams.put(\"types\", types);\n\t\t\t}\n\n\t\t\tgroups = GroupLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), keywords, null, params, start, end,\n\t\t\t\tnew GroupNameComparator(true));\n\n\t\t\tcount = GroupLocalServiceUtil.searchCount(\n\t\t\t\tthemeDisplay.getCompanyId(), keywords, null, params);\n\t\t}\n\t\telse {\n\t\t\tgroups = SitesUtil.getStarredSites(preferences);\n\n\t\t\tcount = groups.size();\n\n\t\t\tif (groups.isEmpty() || Validator.isNotNull(keywords)) {\n\t\t\t\tgroups = SitesUtil.getVisibleSites(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords, maxResultSize);\n\n\t\t\t\tcount = SitesUtil.getVisibleSitesCount(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords);\n\t\t\t}\n\t\t}\n\n\t\tjsonObject.put(\"count\", count);\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Group group : groups) {\n\t\t\tJSONObject groupJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tgroupJSONObject.put(\"name\", group.getDescriptiveName());\n\t\t\tgroupJSONObject.put(\"description\", group.getDescription());\n\n\t\t\tif (group.hasPrivateLayouts() || group.hasPublicLayouts()) {\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tPortalUtil.getHttpServletRequest(resourceRequest),\n\t\t\t\t\tPortletKeys.MY_SITES, themeDisplay.getLayout().getPlid(),\n\t\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\t\tportletURL.setWindowState(WindowState.NORMAL);\n\n\t\t\t\tportletURL.setParameter(\"struts_action\", \"/my_sites/view\");\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(group.getGroupId()));\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"privateLayout\", String.valueOf(!group.hasPublicLayouts()));\n\n\t\t\t\tgroupJSONObject.put(\"url\", portletURL.toString());\n\t\t\t}\n\n\t\t\tboolean socialOfficeEnabled = GetterUtil.getBoolean(\n\t\t\t\tgroup.getExpandoBridge().getAttribute(\"socialOfficeEnabled\"));\n\n\t\t\tgroupJSONObject.put(\"socialOfficeEnabled\", socialOfficeEnabled);\n\n\t\t\tif (!GroupLocalServiceUtil.hasUserGroup(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId()) &&\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), group.getGroupId(),\n\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tPortalUtil.getHttpServletRequest(resourceRequest),\n\t\t\t\t\tPortletKeys.SITES_ADMIN, themeDisplay.getLayout().getPlid(),\n\t\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\t\tportletURL.setWindowState(WindowState.NORMAL);\n\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\tportletURL.setParameter(Constants.CMD, \"group_users\");\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"redirect\", themeDisplay.getURLCurrent());\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(group.getGroupId()));\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"addUserIds\", String.valueOf(themeDisplay.getUserId()));\n\n\t\t\t\tgroupJSONObject.put(\"joinUrl\", portletURL.toString());\n\t\t\t}\n\n\t\t\tPortletURL starPortletURL = resourceResponse.createActionURL();\n\n\t\t\tstarPortletURL.setWindowState(WindowState.NORMAL);\n\n\t\t\tstarPortletURL.setParameter(\n\t\t\t\tActionRequest.ACTION_NAME, \"updateStars\");\n\t\t\tstarPortletURL.setParameter(\n\t\t\t\t\"redirect\", themeDisplay.getURLCurrent());\n\t\t\tstarPortletURL.setParameter(\n\t\t\t\t\"starredGroupId\", String.valueOf(group.getGroupId()));\n\t\t\tstarPortletURL.setParameter(\"portletResource\", portletResource);\n\n\t\t\tString starredGroupIds = preferences.getValue(\n\t\t\t\t\"starredGroupIds\", StringPool.BLANK);\n\n\t\t\tif (!StringUtil.contains(\n\t\t\t\tstarredGroupIds, String.valueOf(group.getGroupId()))) {\n\n\t\t\t\tstarPortletURL.setParameter(Constants.CMD, Constants.ADD);\n\n\t\t\t\tgroupJSONObject.put(\"starURL\", starPortletURL.toString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstarPortletURL.setParameter(Constants.CMD, Constants.DELETE);\n\n\t\t\t\tgroupJSONObject.put(\"unstarURL\", starPortletURL.toString());\n\t\t\t}\n\n\t\t\tjsonArray.put(groupJSONObject);\n\t\t}\n\n\t\tjsonObject.put(\"sites\", jsonArray);\n\n\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\tresourceResponse);\n\n\t\tServletResponseUtil.write(response, jsonObject.toString());\n\t}","id":32509,"modified_method":"public void getSites(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tboolean directory = ParamUtil.getBoolean(resourceRequest, \"directory\");\n\t\tString keywords = DAOParamUtil.getLike(resourceRequest, \"keywords\");\n\t\tboolean userGroups = ParamUtil.getBoolean(\n\t\t\tresourceRequest, \"userGroups\");\n\t\tint maxResultSize = ParamUtil.getInteger(\n\t\t\tresourceRequest, \"maxResultSize\", 10);\n\t\tint start = ParamUtil.getInteger(resourceRequest, \"start\");\n\t\tint end = ParamUtil.getInteger(resourceRequest, \"end\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONObject optionsJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\toptionsJSONObject.put(\"directory\", directory);\n\t\toptionsJSONObject.put(\"keywords\", keywords);\n\t\toptionsJSONObject.put(\"userGroups\", userGroups);\n\t\toptionsJSONObject.put(\"maxResultSize\", maxResultSize);\n\t\toptionsJSONObject.put(\"start\", start);\n\t\toptionsJSONObject.put(\"end\", end);\n\n\t\tjsonObject.put(\"options\", optionsJSONObject);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tList<Group> groups = null;\n\t\tint count = 0;\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tresourceRequest, \"5_WAR_soportlet\");\n\n\t\tif (directory) {\n\t\t\tLinkedHashMap<String, Object> params =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tif (userGroups) {\n\t\t\t\tparams.put(\"usersGroups\", themeDisplay.getUserId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tList<Integer> types = new ArrayList<Integer>();\n\n\t\t\t\ttypes.add(GroupConstants.TYPE_SITE_OPEN);\n\t\t\t\ttypes.add(GroupConstants.TYPE_SITE_RESTRICTED);\n\n\t\t\t\tparams.put(\"types\", types);\n\t\t\t}\n\n\t\t\tgroups = GroupLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), keywords, null, params, start, end,\n\t\t\t\tnew GroupNameComparator(true));\n\n\t\t\tcount = GroupLocalServiceUtil.searchCount(\n\t\t\t\tthemeDisplay.getCompanyId(), keywords, null, params);\n\t\t}\n\t\telse {\n\t\t\tgroups = SitesUtil.getStarredSites(preferences);\n\n\t\t\tcount = groups.size();\n\n\t\t\tif (groups.isEmpty() || Validator.isNotNull(keywords)) {\n\t\t\t\tgroups = SitesUtil.getVisibleSites(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords, maxResultSize);\n\n\t\t\t\tcount = SitesUtil.getVisibleSitesCount(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords);\n\t\t\t}\n\t\t}\n\n\t\tjsonObject.put(\"count\", count);\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (Group group : groups) {\n\t\t\tJSONObject groupJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tgroupJSONObject.put(\"name\", group.getDescriptiveName());\n\t\t\tgroupJSONObject.put(\"description\", group.getDescription());\n\n\t\t\tif (group.hasPrivateLayouts() || group.hasPublicLayouts()) {\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tPortalUtil.getHttpServletRequest(resourceRequest),\n\t\t\t\t\tPortletKeys.MY_SITES, themeDisplay.getLayout().getPlid(),\n\t\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\t\tportletURL.setWindowState(WindowState.NORMAL);\n\n\t\t\t\tportletURL.setParameter(\"struts_action\", \"/my_sites/view\");\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(group.getGroupId()));\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"privateLayout\", String.valueOf(!group.hasPublicLayouts()));\n\n\t\t\t\tgroupJSONObject.put(\"url\", portletURL.toString());\n\t\t\t}\n\n\t\t\tboolean socialOfficeEnabled = GetterUtil.getBoolean(\n\t\t\t\tgroup.getExpandoBridge().getAttribute(\"socialOfficeEnabled\"));\n\n\t\t\tgroupJSONObject.put(\"socialOfficeEnabled\", socialOfficeEnabled);\n\n\t\t\tif (!GroupLocalServiceUtil.hasUserGroup(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId()) &&\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tthemeDisplay.getPermissionChecker(), group.getGroupId(),\n\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tPortalUtil.getHttpServletRequest(resourceRequest),\n\t\t\t\t\tPortletKeys.SITES_ADMIN, themeDisplay.getLayout().getPlid(),\n\t\t\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\t\t\tportletURL.setWindowState(WindowState.NORMAL);\n\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\tportletURL.setParameter(Constants.CMD, \"group_users\");\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"redirect\", themeDisplay.getURLCurrent());\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(group.getGroupId()));\n\t\t\t\tportletURL.setParameter(\n\t\t\t\t\t\"addUserIds\", String.valueOf(themeDisplay.getUserId()));\n\n\t\t\t\tgroupJSONObject.put(\"joinUrl\", portletURL.toString());\n\t\t\t}\n\n\t\t\tPortletURL starPortletURL = resourceResponse.createActionURL();\n\n\t\t\tstarPortletURL.setWindowState(WindowState.NORMAL);\n\n\t\t\tstarPortletURL.setParameter(\n\t\t\t\tActionRequest.ACTION_NAME, \"updateStars\");\n\t\t\tstarPortletURL.setParameter(\n\t\t\t\t\"redirect\", themeDisplay.getURLCurrent());\n\t\t\tstarPortletURL.setParameter(\n\t\t\t\t\"starredGroupId\", String.valueOf(group.getGroupId()));\n\n\t\t\tString starredGroupIds = preferences.getValue(\n\t\t\t\t\"starredGroupIds\", StringPool.BLANK);\n\n\t\t\tif (!StringUtil.contains(\n\t\t\t\tstarredGroupIds, String.valueOf(group.getGroupId()))) {\n\n\t\t\t\tstarPortletURL.setParameter(Constants.CMD, Constants.ADD);\n\n\t\t\t\tgroupJSONObject.put(\"starURL\", starPortletURL.toString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstarPortletURL.setParameter(Constants.CMD, Constants.DELETE);\n\n\t\t\t\tgroupJSONObject.put(\"unstarURL\", starPortletURL.toString());\n\t\t\t}\n\n\t\t\tjsonArray.put(groupJSONObject);\n\t\t}\n\n\t\tjsonObject.put(\"sites\", jsonArray);\n\n\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\tresourceResponse);\n\n\t\tServletResponseUtil.write(response, jsonObject.toString());\n\t}","commit_id":"bffbf74dde020ac7a0f588e5346b5048a93486a6","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Test\n\tpublic void testPortletPreferencesPropagationWithPreferencesUniquePerLayoutEnabled()\n\t\tthrows Exception {\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tTestPropsValues.getCompanyId(), PortletKeys.NAVIGATION);\n\n\t\tportlet.setPreferencesUniquePerLayout(false);\n\n\t\t_layoutSetPrototypeLayout = LayoutTestUtil.addLayout(\n\t\t\t_layoutSetPrototypeGroup, true, layoutPrototype, true);\n\n\t\tMap<String, String[]> preferenceMap = new HashMap<>();\n\n\t\tpreferenceMap.put(\"bulletStyle\", new String[] {\"Dots\"});\n\n\t\tString navigationPortletId1 = LayoutTestUtil.addPortletToLayout(\n\t\t\tTestPropsValues.getUserId(), _layoutSetPrototypeLayout,\n\t\t\tPortletKeys.NAVIGATION, \"column-1\", preferenceMap);\n\n\t\tpreferenceMap.put(\"bulletStyle\", new String[] {\"Arrows\"});\n\n\t\tString navigationPortletId2 = LayoutTestUtil.addPortletToLayout(\n\t\t\tTestPropsValues.getUserId(), _layoutSetPrototypeLayout,\n\t\t\tPortletKeys.NAVIGATION, \"column-2\", preferenceMap);\n\n\t\tpropagateChanges(group);\n\n\t\tLayout layout = LayoutLocalServiceUtil.getFriendlyURLLayout(\n\t\t\tgroup.getGroupId(), false,\n\t\t\t_layoutSetPrototypeLayout.getFriendlyURL());\n\n\t\tPortletPreferences navigationPortletIdPortletPreferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tgroup.getGroupId(), layout, PortletKeys.NAVIGATION, null);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Arrows\",\n\t\t\tnavigationPortletIdPortletPreferences.getValue(\n\t\t\t\t\"bulletStyle\", StringPool.BLANK));\n\n\t\tPortletPreferences navigationPortletId1PortletPreferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tlayout, navigationPortletId1, null);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Arrows\",\n\t\t\tnavigationPortletId1PortletPreferences.getValue(\n\t\t\t\t\"bulletStyle\", StringPool.BLANK));\n\n\t\tPortletPreferences navigationPortletId2PortletPreferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tlayout, navigationPortletId2, null);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Arrows\",\n\t\t\tnavigationPortletId2PortletPreferences.getValue(\n\t\t\t\t\"bulletStyle\", StringPool.BLANK));\n\t}","id":32510,"modified_method":"@Test\n\tpublic void testPortletPreferencesPropagationWithPreferencesUniquePerLayoutEnabled()\n\t\tthrows Exception {\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tTestPropsValues.getCompanyId(), PortletKeys.TEST);\n\n\t\tboolean preferencesUniquePerLayout =\n\t\t\tportlet.getPreferencesUniquePerLayout();\n\n\t\ttry {\n\t\t\tportlet.setPreferencesUniquePerLayout(false);\n\n\t\t\t_layoutSetPrototypeLayout = LayoutTestUtil.addLayout(\n\t\t\t\t_layoutSetPrototypeGroup, true, layoutPrototype, true);\n\n\t\t\tMap<String, String[]> preferenceMap = new HashMap<>();\n\n\t\t\tpreferenceMap.put(\"bulletStyle\", new String[]{\"Dots\"});\n\n\t\t\tString testPortletId1 = LayoutTestUtil.addPortletToLayout(\n\t\t\t\tTestPropsValues.getUserId(), _layoutSetPrototypeLayout,\n\t\t\t\tPortletKeys.TEST, \"column-1\", preferenceMap);\n\n\t\t\tpreferenceMap.put(\"bulletStyle\", new String[]{\"Arrows\"});\n\n\t\t\tString testPortletId2 = LayoutTestUtil.addPortletToLayout(\n\t\t\t\tTestPropsValues.getUserId(), _layoutSetPrototypeLayout,\n\t\t\t\tPortletKeys.TEST, \"column-2\", preferenceMap);\n\n\t\t\tpropagateChanges(group);\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.getFriendlyURLLayout(\n\t\t\t\tgroup.getGroupId(), false,\n\t\t\t\t_layoutSetPrototypeLayout.getFriendlyURL());\n\n\t\t\tPortletPreferences testPortletIdPortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\tgroup.getGroupId(), layout, PortletKeys.TEST, null);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Arrows\",\n\t\t\t\ttestPortletIdPortletPreferences.getValue(\n\t\t\t\t\t\"bulletStyle\", StringPool.BLANK));\n\n\t\t\tPortletPreferences testPortletId1PortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\tlayout, testPortletId1, null);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Arrows\",\n\t\t\t\ttestPortletId1PortletPreferences.getValue(\n\t\t\t\t\t\"bulletStyle\", StringPool.BLANK));\n\n\t\t\tPortletPreferences testPortletId2PortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\tlayout, testPortletId2, null);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Arrows\",\n\t\t\t\ttestPortletId2PortletPreferences.getValue(\n\t\t\t\t\t\"bulletStyle\", StringPool.BLANK));\n\t\t}\n\t\tfinally {\n\t\t\tportlet.setPreferencesUniquePerLayout(preferencesUniquePerLayout);\n\t\t}\n\t}","commit_id":"0c7cf5b6937cad95223ac7002945365a5a94ce67","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void configure() {\r\n    final File f = new File(OSystemVariableResolver.resolveSystemVariables(configFile));\r\n    if (f.exists()) {\r\n      // READ THE FILE\r\n      try {\r\n        final String configurationContent = OIOUtils.readFileAsString(f);\r\n        configuration = new ODocument().fromJSON(configurationContent);\r\n      } catch (IOException e) {\r\n        OException.wrapException(new OConfigurationException(\"Cannot load Automatic Backup configuration file '\" + configFile\r\n            + \"'. Automatic Backup will be disabled\"), e);\r\n      }\r\n\r\n    } else {\r\n      // AUTO CONVERT XML CONFIGURATION (<v2.2) TO JSON FILE\r\n      try {\r\n        f.getParentFile().mkdirs();\r\n        f.createNewFile();\r\n        OIOUtils.writeFile(f, configuration.toJSON(\"prettyPrint\"));\r\n\r\n        OLogManager.instance().info(this, \"Automatic Backup: migrated configuration to file '%s'\", f);\r\n      } catch (IOException e) {\r\n        OException.wrapException(new OConfigurationException(\"Cannot create Automatic Backup configuration file '\" + configFile\r\n            + \"'. Automatic Backup will be disabled\"), e);\r\n      }\r\n    }\r\n\r\n    // PARSE THE JSON FILE\r\n    for (String settingName : configuration.fieldNames()) {\r\n      final Object settingValue = configuration.field(settingName);\r\n      final String settingValueAsString = settingValue != null ? settingValue.toString() : null;\r\n\r\n      if (settingName.equalsIgnoreCase(\"enabled\")) {\r\n        if (!(Boolean) settingValue)\r\n          // DISABLE IT\r\n          return;\r\n      } else if (settingName.equalsIgnoreCase(\"delay\"))\r\n        delay = OIOUtils.getTimeAsMillisecs(settingValue);\r\n      else if (settingName.equalsIgnoreCase(\"firstTime\")) {\r\n        try {\r\n          firstTime = OIOUtils.getTodayWithTime(settingValueAsString);\r\n          if (firstTime.before(new Date())) {\r\n            Calendar cal = Calendar.getInstance();\r\n            cal.setTime(firstTime);\r\n            cal.add(Calendar.DAY_OF_MONTH, 1);\r\n            firstTime = cal.getTime();\r\n          }\r\n        } catch (ParseException e) {\r\n          throw OException.wrapException(\r\n              new OConfigurationException(\"Parameter 'firstTime' has invalid format, expected: HH:mm:ss\"), e);\r\n        }\r\n      } else if (settingName.equalsIgnoreCase(\"targetDirectory\"))\r\n        targetDirectory = settingValueAsString;\r\n      else if (settingName.equalsIgnoreCase(\"dbInclude\") && settingValueAsString.trim().length() > 0)\r\n        for (String db : settingValueAsString.split(\",\"))\r\n          includeDatabases.add(db);\r\n      else if (settingName.equalsIgnoreCase(\"dbExclude\") && settingValueAsString.trim().length() > 0)\r\n        for (String db : settingValueAsString.split(\",\"))\r\n          excludeDatabases.add(db);\r\n      else if (settingName.equalsIgnoreCase(\"targetFileName\"))\r\n        targetFileName = settingValueAsString;\r\n      else if (settingName.equalsIgnoreCase(\"bufferSize\"))\r\n        bufferSize = (Integer) settingValue;\r\n      else if (settingName.equalsIgnoreCase(\"compressionLevel\"))\r\n        compressionLevel = (Integer) settingValue;\r\n      else if (settingName.equalsIgnoreCase(\"mode\"))\r\n        mode = MODE.valueOf(settingValueAsString.toUpperCase());\r\n      else if (settingName.equalsIgnoreCase(\"exportOptions\"))\r\n        exportOptions = settingValueAsString;\r\n    }\r\n  }","id":32511,"modified_method":"private void configure() {\r\n    final File f = new File(OSystemVariableResolver.resolveSystemVariables(configFile));\r\n    if (f.exists()) {\r\n      // READ THE FILE\r\n      try {\r\n        final String configurationContent = OIOUtils.readFileAsString(f);\r\n        configuration = new ODocument().fromJSON(configurationContent);\r\n      } catch (IOException e) {\r\n        throw OException.wrapException(new OConfigurationException(\"Cannot load Automatic Backup configuration file '\" + configFile\r\n            + \"'. Automatic Backup will be disabled\"), e);\r\n      }\r\n\r\n    } else {\r\n      // AUTO CONVERT XML CONFIGURATION (<v2.2) TO JSON FILE\r\n      try {\r\n        f.getParentFile().mkdirs();\r\n        f.createNewFile();\r\n        OIOUtils.writeFile(f, configuration.toJSON(\"prettyPrint\"));\r\n\r\n        OLogManager.instance().info(this, \"Automatic Backup: migrated configuration to file '%s'\", f);\r\n      } catch (IOException e) {\r\n        throw OException.wrapException(new OConfigurationException(\"Cannot create Automatic Backup configuration file '\" + configFile\r\n            + \"'. Automatic Backup will be disabled\"), e);\r\n      }\r\n    }\r\n\r\n    // PARSE THE JSON FILE\r\n    for (String settingName : configuration.fieldNames()) {\r\n      final Object settingValue = configuration.field(settingName);\r\n      final String settingValueAsString = settingValue != null ? settingValue.toString() : null;\r\n\r\n      if (settingName.equalsIgnoreCase(\"enabled\")) {\r\n        if (!(Boolean) settingValue)\r\n          // DISABLE IT\r\n          return;\r\n      } else if (settingName.equalsIgnoreCase(\"delay\"))\r\n        delay = OIOUtils.getTimeAsMillisecs(settingValue);\r\n      else if (settingName.equalsIgnoreCase(\"firstTime\")) {\r\n        try {\r\n          firstTime = OIOUtils.getTodayWithTime(settingValueAsString);\r\n          if (firstTime.before(new Date())) {\r\n            Calendar cal = Calendar.getInstance();\r\n            cal.setTime(firstTime);\r\n            cal.add(Calendar.DAY_OF_MONTH, 1);\r\n            firstTime = cal.getTime();\r\n          }\r\n        } catch (ParseException e) {\r\n          throw OException.wrapException(\r\n              new OConfigurationException(\"Parameter 'firstTime' has invalid format, expected: HH:mm:ss\"), e);\r\n        }\r\n      } else if (settingName.equalsIgnoreCase(\"targetDirectory\"))\r\n        targetDirectory = settingValueAsString;\r\n      else if (settingName.equalsIgnoreCase(\"dbInclude\") && settingValueAsString.trim().length() > 0)\r\n        for (String db : settingValueAsString.split(\",\"))\r\n          includeDatabases.add(db);\r\n      else if (settingName.equalsIgnoreCase(\"dbExclude\") && settingValueAsString.trim().length() > 0)\r\n        for (String db : settingValueAsString.split(\",\"))\r\n          excludeDatabases.add(db);\r\n      else if (settingName.equalsIgnoreCase(\"targetFileName\"))\r\n        targetFileName = settingValueAsString;\r\n      else if (settingName.equalsIgnoreCase(\"bufferSize\"))\r\n        bufferSize = (Integer) settingValue;\r\n      else if (settingName.equalsIgnoreCase(\"compressionLevel\"))\r\n        compressionLevel = (Integer) settingValue;\r\n      else if (settingName.equalsIgnoreCase(\"mode\"))\r\n        mode = MODE.valueOf(settingValueAsString.toUpperCase());\r\n      else if (settingName.equalsIgnoreCase(\"exportOptions\"))\r\n        exportOptions = settingValueAsString;\r\n    }\r\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void initCache() {\n    configuration = new ODocument();\n    configuration.field(\"enabled\", enable);\n    configuration.field(\"evictStrategy\", evictStrategy.toString());\n    configuration.field(\"minExecutionTime\", minExecutionTime);\n    configuration.field(\"maxResultsetSize\", maxResultsetSize);\n    try {\n      ODocument diskConfig = loadConfiguration();\n      if (diskConfig != null) {\n        configuration = diskConfig;\n        configure();\n      } else {\n        updateCfgOnDisk();\n      }\n    } catch (Exception e) {\n      OException.wrapException(new OConfigurationException(\n          \"Cannot change Command Cache Cache configuration file '\" + CONFIG_FILE + \"'. Command Cache will use default settings\"),\n          e);\n    }\n\n  }","id":32512,"modified_method":"private void initCache() {\n    configuration = new ODocument();\n    configuration.field(\"enabled\", enable);\n    configuration.field(\"evictStrategy\", evictStrategy.toString());\n    configuration.field(\"minExecutionTime\", minExecutionTime);\n    configuration.field(\"maxResultsetSize\", maxResultsetSize);\n    try {\n      ODocument diskConfig = loadConfiguration();\n      if (diskConfig != null) {\n        configuration = diskConfig;\n        configure();\n      } else {\n        updateCfgOnDisk();\n      }\n    } catch (Exception e) {\n      throw OException.wrapException(new OConfigurationException(\n          \"Cannot change Command Cache Cache configuration file '\" + CONFIG_FILE + \"'. Command Cache will use default settings\"),\n          e);\n    }\n\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public OCommandCacheSoftRefs enable() {\n    enable = true;\n\n    configuration.field(\"enabled\", true);\n    try {\n      updateCfgOnDisk();\n    } catch (IOException e) {\n      OException.wrapException(\n          new OConfigurationException(\"Cannot write Command Cache Cache configuration to file '\" + CONFIG_FILE + \"'\"), e);\n    }\n    return this;\n  }","id":32513,"modified_method":"@Override\n  public OCommandCacheSoftRefs enable() {\n    enable = true;\n\n    configuration.field(\"enabled\", true);\n    try {\n      updateCfgOnDisk();\n    } catch (IOException e) {\n      throw OException.wrapException(\n          new OConfigurationException(\"Cannot write Command Cache Cache configuration to file '\" + CONFIG_FILE + \"'\"), e);\n    }\n    return this;\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private ODocument loadConfiguration() {\n    try {\n      final File f = getConfigFile();\n      if (f != null && f.exists()) {\n        final String configurationContent = OIOUtils.readFileAsString(f);\n        return new ODocument().fromJSON(configurationContent);\n      }\n    } catch (Exception e) {\n      OException.wrapException(\n          new OConfigurationException(\n              \"Cannot load Command Cache Cache configuration file '\" + CONFIG_FILE + \"'. Command Cache will use default settings\"),\n          e);\n    }\n    return null;\n  }","id":32514,"modified_method":"private ODocument loadConfiguration() {\n    try {\n      final File f = getConfigFile();\n      if (f != null && f.exists()) {\n        final String configurationContent = OIOUtils.readFileAsString(f);\n        return new ODocument().fromJSON(configurationContent);\n      }\n    } catch (Exception e) {\n      throw OException.wrapException(\n          new OConfigurationException(\n              \"Cannot load Command Cache Cache configuration file '\" + CONFIG_FILE + \"'. Command Cache will use default settings\"),\n          e);\n    }\n    return null;\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public OCommandCacheSoftRefs disable() {\n    enable = false;\n    synchronized (this) {\n      clusters.clear();\n      cache.clear();\n    }\n    configuration.field(\"enabled\", true);\n\n    try {\n      updateCfgOnDisk();\n    } catch (IOException e) {\n      OException.wrapException(\n          new OConfigurationException(\"Cannot write Command Cache Cache configuration to file '\" + CONFIG_FILE + \"'\"), e);\n    }\n    return this;\n  }","id":32515,"modified_method":"@Override\n  public OCommandCacheSoftRefs disable() {\n    enable = false;\n    synchronized (this) {\n      clusters.clear();\n      cache.clear();\n    }\n    configuration.field(\"enabled\", true);\n\n    try {\n      updateCfgOnDisk();\n    } catch (IOException e) {\n      throw OException.wrapException(\n          new OConfigurationException(\"Cannot write Command Cache Cache configuration to file '\" + CONFIG_FILE + \"'\"), e);\n    }\n    return this;\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void changeConfig(ODocument cfg) {\n\n    synchronized (configuration) {\n      ODocument oldConfig = configuration;\n      configuration = cfg;\n      configure();\n      try {\n        updateCfgOnDisk();\n      } catch (IOException e) {\n        OException.wrapException(new OConfigurationException(\n            \"Cannot change Command Cache Cache configuration file '\" + CONFIG_FILE + \"'. Command Cache will use default settings\"),\n            e);\n        configuration = oldConfig;\n        configure();\n      }\n    }\n  }","id":32516,"modified_method":"public void changeConfig(ODocument cfg) {\n\n    synchronized (configuration) {\n      ODocument oldConfig = configuration;\n      configuration = cfg;\n      configure();\n      try {\n        updateCfgOnDisk();\n      } catch (IOException e) {\n        configuration = oldConfig;\n        configure();\n        throw OException.wrapException(new OConfigurationException(\n            \"Cannot change Command Cache Cache configuration file '\" + CONFIG_FILE + \"'. Command Cache will use default settings\"),\n            e);\n      }\n    }\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public List<ORecordOperation> commit(final ODatabaseDocumentTx database, final OTransaction iTx, final Runnable callback,\n      final ODistributedStorageEventListener eventListener) {\n    final String localNodeName = dManager.getLocalNodeName();\n\n    try {\n      OTransactionInternal.setStatus((OTransactionAbstract) iTx, OTransaction.TXSTATUS.BEGUN);\n\n      return (List<ORecordOperation>) storage.executeOperationInLock(new OCallable<Object, Void>() {\n\n        @Override\n        public Object call(final Void nothing) {\n\n          final ODistributedConfiguration dbCfg = dManager.getDatabaseConfiguration(storage.getName());\n\n          // CHECK THE LOCAL NODE IS THE OWNER OF THE CLUSTER IDS\n          checkForClusterIds(iTx, localNodeName, dbCfg);\n\n          // CREATE UNDO CONTENT FOR DISTRIBUTED 2-PHASE ROLLBACK\n          final List<OAbstractRemoteTask> undoTasks = createUndoTasksFromTx(iTx);\n\n          final int maxAutoRetry = OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_MAX_AUTORETRY.getValueAsInteger();\n          final int autoRetryDelay = OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_AUTORETRY_DELAY.getValueAsInteger();\n\n          Boolean executionModeSynch = dbCfg.isExecutionModeSynchronous(null);\n          if (executionModeSynch == null)\n            executionModeSynch = Boolean.TRUE;\n\n          final boolean finalExecutionModeSynch = executionModeSynch;\n\n          final ODistributedRequestId requestId = new ODistributedRequestId(dManager.getLocalNodeId(),\n              dManager.getNextMessageIdCounter());\n\n          final ODistributedTxContext ctx = localDistributedDatabase.registerTxContext(requestId);\n\n          try {\n            acquireMultipleRecordLocks(iTx, maxAutoRetry, autoRetryDelay, eventListener, ctx);\n\n            final List<ORecordOperation> uResult = (List<ORecordOperation>) OScenarioThreadLocal\n                .executeAsDistributed(new Callable() {\n                  @Override\n                  public Object call() throws Exception {\n                    return storage.commit(iTx, callback);\n                  }\n                });\n\n            // REMOVE THE TX OBJECT FROM DATABASE TO AVOID UND OPERATIONS ARE \"LOST IN TRANSACTION\"\n            database.setDefaultTransactionMode();\n\n            // After commit force the clean of dirty managers due to possible copy and miss clean.\n            for (ORecordOperation ent : iTx.getAllRecordEntries()) {\n              ORecordInternal.getDirtyManager(ent.getRecord()).clear();\n            }\n\n            final Set<String> involvedClusters = getInvolvedClusters(uResult);\n            final Set<String> nodes = getAvailableNodesButLocal(dbCfg, involvedClusters, localNodeName);\n            if (nodes.isEmpty()) {\n              // NO FURTHER NODES TO INVOLVE\n              localDistributedDatabase.popTxContext(requestId);\n              ctx.destroy();\n              return null;\n            }\n\n            updateUndoTaskWithCreatedRecords(uResult, undoTasks);\n\n            final OTxTaskResult localResult = createLocalTxResult(uResult);\n\n            final OTxTask txTask = createTxTask(uResult);\n            txTask.setLocalUndoTasks(undoTasks);\n\n            try {\n              txTask.setLastLSN(((OAbstractPaginatedStorage) storage.getUnderlying()).getLSN());\n\n              OTransactionInternal.setStatus((OTransactionAbstract) iTx, OTransaction.TXSTATUS.COMMITTING);\n\n              if (finalExecutionModeSynch) {\n                // SYNCHRONOUS, AUTO-RETRY IN CASE RECORDS ARE LOCKED\n                ODistributedResponse lastResult = null;\n                for (int retry = 1; retry <= maxAutoRetry; ++retry) {\n                  boolean isLastRetry = maxAutoRetry == retry;\n\n                  // SYNCHRONOUS CALL: REPLICATE IT\n                  lastResult = dManager.sendRequest(storage.getName(), involvedClusters, nodes, txTask, requestId.getMessageId(),\n                      EXECUTION_MODE.RESPONSE, localResult, null);\n\n                  if (!processCommitResult(localNodeName, iTx, txTask, involvedClusters, uResult, nodes, autoRetryDelay,\n                      lastResult.getRequestId(), lastResult, isLastRetry)) {\n\n                    // RETRY\n                    continue;\n                  }\n\n                  ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n                      \"Distributed transaction succeeded. Tasks: %s\", txTask.getTasks());\n\n                  // OK, DISTRIBUTED COMMIT SUCCEED\n                  return null;\n                }\n\n                // ONLY CASE: ODistributedRecordLockedException MORE THAN AUTO-RETRY\n                ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n                    \"Distributed transaction retries exceed maximum auto-retries (%d). Task: %s - Payload: %s - Tasks: %s\",\n                    maxAutoRetry, txTask, txTask.getPayload(), txTask.getTasks());\n\n                // ROLLBACK TX\n                storage.executeUndoOnLocalServer(requestId, txTask);\n                sendTxCompleted(localNodeName, involvedClusters, nodes, lastResult.getRequestId(), false, txTask.getPartitionKey());\n\n                throw (ODistributedRecordLockedException) lastResult.getPayload();\n\n              } else {\n                // ASYNC, MANAGE REPLICATION CALLBACK\n                final OCallable<Void, ODistributedRequestId> unlockCallback = new OCallable<Void, ODistributedRequestId>() {\n                  @Override\n                  public Void call(final ODistributedRequestId reqId) {\n                    // FREE THE CONTEXT\n                    localDistributedDatabase.popTxContext(requestId);\n                    ctx.destroy();\n                    return null;\n                  }\n                };\n\n                executeAsyncTx(nodes, localResult, involvedClusters, txTask, requestId.getMessageId(), localNodeName,\n                    unlockCallback);\n              }\n            } catch (Throwable e) {\n              // UNDO LOCAL TX\n              storage.executeUndoOnLocalServer(requestId, txTask);\n\n              localDistributedDatabase.popTxContext(requestId);\n              ctx.destroy();\n\n              if (e instanceof RuntimeException)\n                throw (RuntimeException) e;\n              else\n                OException.wrapException(new ODistributedException(\"Cannot commit transaction\"), e);\n            }\n\n          } catch (RuntimeException e) {\n            localDistributedDatabase.popTxContext(requestId);\n            ctx.destroy();\n            throw e;\n          } catch (Exception e) {\n            localDistributedDatabase.popTxContext(requestId);\n            ctx.destroy();\n            OException.wrapException(new ODistributedException(\"Cannot commit transaction\"), e);\n            // UNREACHABLE\n          } finally {\n            if (finalExecutionModeSynch) {\n              localDistributedDatabase.popTxContext(requestId);\n              ctx.destroy();\n            }\n          }\n          return null;\n        }\n      });\n\n    } catch (OValidationException e) {\n      throw e;\n    } catch (Exception e) {\n      storage.handleDistributedException(\"Cannot route TX operation against distributed node\", e);\n    }\n\n    return null;\n  }","id":32517,"modified_method":"public List<ORecordOperation> commit(final ODatabaseDocumentTx database, final OTransaction iTx, final Runnable callback,\n      final ODistributedStorageEventListener eventListener) {\n    final String localNodeName = dManager.getLocalNodeName();\n\n    try {\n      OTransactionInternal.setStatus((OTransactionAbstract) iTx, OTransaction.TXSTATUS.BEGUN);\n\n      return (List<ORecordOperation>) storage.executeOperationInLock(new OCallable<Object, Void>() {\n\n        @Override\n        public Object call(final Void nothing) {\n\n          final ODistributedConfiguration dbCfg = dManager.getDatabaseConfiguration(storage.getName());\n\n          // CHECK THE LOCAL NODE IS THE OWNER OF THE CLUSTER IDS\n          checkForClusterIds(iTx, localNodeName, dbCfg);\n\n          // CREATE UNDO CONTENT FOR DISTRIBUTED 2-PHASE ROLLBACK\n          final List<OAbstractRemoteTask> undoTasks = createUndoTasksFromTx(iTx);\n\n          final int maxAutoRetry = OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_MAX_AUTORETRY.getValueAsInteger();\n          final int autoRetryDelay = OGlobalConfiguration.DISTRIBUTED_CONCURRENT_TX_AUTORETRY_DELAY.getValueAsInteger();\n\n          Boolean executionModeSynch = dbCfg.isExecutionModeSynchronous(null);\n          if (executionModeSynch == null)\n            executionModeSynch = Boolean.TRUE;\n\n          final boolean finalExecutionModeSynch = executionModeSynch;\n\n          final ODistributedRequestId requestId = new ODistributedRequestId(dManager.getLocalNodeId(),\n              dManager.getNextMessageIdCounter());\n\n          final ODistributedTxContext ctx = localDistributedDatabase.registerTxContext(requestId);\n\n          try {\n            acquireMultipleRecordLocks(iTx, maxAutoRetry, autoRetryDelay, eventListener, ctx);\n\n            final List<ORecordOperation> uResult = (List<ORecordOperation>) OScenarioThreadLocal\n                .executeAsDistributed(new Callable() {\n                  @Override\n                  public Object call() throws Exception {\n                    return storage.commit(iTx, callback);\n                  }\n                });\n\n            // REMOVE THE TX OBJECT FROM DATABASE TO AVOID UND OPERATIONS ARE \"LOST IN TRANSACTION\"\n            database.setDefaultTransactionMode();\n\n            // After commit force the clean of dirty managers due to possible copy and miss clean.\n            for (ORecordOperation ent : iTx.getAllRecordEntries()) {\n              ORecordInternal.getDirtyManager(ent.getRecord()).clear();\n            }\n\n            final Set<String> involvedClusters = getInvolvedClusters(uResult);\n            final Set<String> nodes = getAvailableNodesButLocal(dbCfg, involvedClusters, localNodeName);\n            if (nodes.isEmpty()) {\n              // NO FURTHER NODES TO INVOLVE\n              localDistributedDatabase.popTxContext(requestId);\n              ctx.destroy();\n              return null;\n            }\n\n            updateUndoTaskWithCreatedRecords(uResult, undoTasks);\n\n            final OTxTaskResult localResult = createLocalTxResult(uResult);\n\n            final OTxTask txTask = createTxTask(uResult);\n            txTask.setLocalUndoTasks(undoTasks);\n\n            try {\n              txTask.setLastLSN(((OAbstractPaginatedStorage) storage.getUnderlying()).getLSN());\n\n              OTransactionInternal.setStatus((OTransactionAbstract) iTx, OTransaction.TXSTATUS.COMMITTING);\n\n              if (finalExecutionModeSynch) {\n                // SYNCHRONOUS, AUTO-RETRY IN CASE RECORDS ARE LOCKED\n                ODistributedResponse lastResult = null;\n                for (int retry = 1; retry <= maxAutoRetry; ++retry) {\n                  boolean isLastRetry = maxAutoRetry == retry;\n\n                  // SYNCHRONOUS CALL: REPLICATE IT\n                  lastResult = dManager.sendRequest(storage.getName(), involvedClusters, nodes, txTask, requestId.getMessageId(),\n                      EXECUTION_MODE.RESPONSE, localResult, null);\n\n                  if (!processCommitResult(localNodeName, iTx, txTask, involvedClusters, uResult, nodes, autoRetryDelay,\n                      lastResult.getRequestId(), lastResult, isLastRetry)) {\n\n                    // RETRY\n                    continue;\n                  }\n\n                  ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n                      \"Distributed transaction succeeded. Tasks: %s\", txTask.getTasks());\n\n                  // OK, DISTRIBUTED COMMIT SUCCEED\n                  return null;\n                }\n\n                // ONLY CASE: ODistributedRecordLockedException MORE THAN AUTO-RETRY\n                ODistributedServerLog.debug(this, localNodeName, null, ODistributedServerLog.DIRECTION.NONE,\n                    \"Distributed transaction retries exceed maximum auto-retries (%d). Task: %s - Payload: %s - Tasks: %s\",\n                    maxAutoRetry, txTask, txTask.getPayload(), txTask.getTasks());\n\n                // ROLLBACK TX\n                storage.executeUndoOnLocalServer(requestId, txTask);\n                sendTxCompleted(localNodeName, involvedClusters, nodes, lastResult.getRequestId(), false, txTask.getPartitionKey());\n\n                throw (ODistributedRecordLockedException) lastResult.getPayload();\n\n              } else {\n                // ASYNC, MANAGE REPLICATION CALLBACK\n                final OCallable<Void, ODistributedRequestId> unlockCallback = new OCallable<Void, ODistributedRequestId>() {\n                  @Override\n                  public Void call(final ODistributedRequestId reqId) {\n                    // FREE THE CONTEXT\n                    localDistributedDatabase.popTxContext(requestId);\n                    ctx.destroy();\n                    return null;\n                  }\n                };\n\n                executeAsyncTx(nodes, localResult, involvedClusters, txTask, requestId.getMessageId(), localNodeName,\n                    unlockCallback);\n              }\n            } catch (Throwable e) {\n              // UNDO LOCAL TX\n              storage.executeUndoOnLocalServer(requestId, txTask);\n\n              localDistributedDatabase.popTxContext(requestId);\n              ctx.destroy();\n\n              if (e instanceof RuntimeException)\n                throw (RuntimeException) e;\n              else\n                throw OException.wrapException(new ODistributedException(\"Cannot commit transaction\"), e);\n            }\n\n          } catch (RuntimeException e) {\n            localDistributedDatabase.popTxContext(requestId);\n            ctx.destroy();\n            throw e;\n          } catch (Exception e) {\n            localDistributedDatabase.popTxContext(requestId);\n            ctx.destroy();\n            throw OException.wrapException(new ODistributedException(\"Cannot commit transaction\"), e);\n          } finally {\n            if (finalExecutionModeSynch) {\n              localDistributedDatabase.popTxContext(requestId);\n              ctx.destroy();\n            }\n          }\n          return null;\n        }\n      });\n\n    } catch (OValidationException e) {\n      throw e;\n    } catch (Exception e) {\n      storage.handleDistributedException(\"Cannot route TX operation against distributed node\", e);\n    }\n\n    return null;\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void changeConfig(ODocument document) {\r\n\r\n    ODocument oldConfig = configuration;\r\n    configuration = document;\r\n\r\n    try {\r\n      writeConfiguration();\r\n    } catch (IOException e) {\r\n      OException.wrapException(new OConfigurationException(\"Cannot Write Mail configuration file '\" + configFile\r\n          + \"'. Restoring old configuration.\"), e);\r\n\r\n      configuration = oldConfig;\r\n    }\r\n    configure();\r\n  }","id":32518,"modified_method":"@Override\r\n  public void changeConfig(ODocument document) {\r\n\r\n    ODocument oldConfig = configuration;\r\n    configuration = document;\r\n\r\n    try {\r\n      writeConfiguration();\r\n    } catch (IOException e) {\r\n      configuration = oldConfig;\r\n\r\n      throw OException.wrapException(new OConfigurationException(\"Cannot Write Mail configuration file '\" + configFile\r\n          + \"'. Restoring old configuration.\"), e);\r\n    }\r\n    configure();\r\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void configure() {\r\n    final File f = new File(OSystemVariableResolver.resolveSystemVariables(configFile));\r\n    if (f.exists()) {\r\n      // READ THE FILE\r\n      try {\r\n        final String configurationContent = OIOUtils.readFileAsString(f);\r\n        configuration = new ODocument().fromJSON(configurationContent);\r\n      } catch (IOException e) {\r\n        OException.wrapException(new OConfigurationException(\"Cannot load Mail configuration file '\" + configFile\r\n            + \"'. Mail Plugin will be disabled\"), e);\r\n      }\r\n\r\n    } else {\r\n      try {\r\n        f.getParentFile().mkdirs();\r\n        f.createNewFile();\r\n        OIOUtils.writeFile(f, configuration.toJSON(\"prettyPrint\"));\r\n\r\n        OLogManager.instance().info(this, \"Mail plugin: migrated configuration to file '%s'\", f);\r\n      } catch (IOException e) {\r\n        OException.wrapException(new OConfigurationException(\"Cannot create Mail plugin configuration file '\" + configFile\r\n            + \"'. Mail Plugin will be disabled\"), e);\r\n      }\r\n    }\r\n\r\n    profiles.clear();\r\n\r\n    Collection<Map<String, Object>> profilesInDocs = configuration.field(\"profiles\");\r\n\r\n    for (Map<String, Object> profile : profilesInDocs) {\r\n      String name = (String) profile.get(\"name\");\r\n      OMailProfile p = profiles.get(name);\r\n      if (p == null) {\r\n        p = new OMailProfile();\r\n        profiles.put(name, p);\r\n      }\r\n\r\n      for (String s : profile.keySet()) {\r\n        if (!s.equalsIgnoreCase(\"name\")) {\r\n          p.put(s, profile.get(s).toString());\r\n        }\r\n      }\r\n    }\r\n\r\n  }","id":32519,"modified_method":"private void configure() {\r\n    final File f = new File(OSystemVariableResolver.resolveSystemVariables(configFile));\r\n    if (f.exists()) {\r\n      // READ THE FILE\r\n      try {\r\n        final String configurationContent = OIOUtils.readFileAsString(f);\r\n        configuration = new ODocument().fromJSON(configurationContent);\r\n      } catch (IOException e) {\r\n        throw OException.wrapException(new OConfigurationException(\"Cannot load Mail configuration file '\" + configFile\r\n            + \"'. Mail Plugin will be disabled\"), e);\r\n      }\r\n\r\n    } else {\r\n      try {\r\n        f.getParentFile().mkdirs();\r\n        f.createNewFile();\r\n        OIOUtils.writeFile(f, configuration.toJSON(\"prettyPrint\"));\r\n\r\n        OLogManager.instance().info(this, \"Mail plugin: migrated configuration to file '%s'\", f);\r\n      } catch (IOException e) {\r\n        throw OException.wrapException(new OConfigurationException(\"Cannot create Mail plugin configuration file '\" + configFile\r\n            + \"'. Mail Plugin will be disabled\"), e);\r\n      }\r\n    }\r\n\r\n    profiles.clear();\r\n\r\n    Collection<Map<String, Object>> profilesInDocs = configuration.field(\"profiles\");\r\n\r\n    for (Map<String, Object> profile : profilesInDocs) {\r\n      String name = (String) profile.get(\"name\");\r\n      OMailProfile p = profiles.get(name);\r\n      if (p == null) {\r\n        p = new OMailProfile();\r\n        profiles.put(name, p);\r\n      }\r\n\r\n      for (String s : profile.keySet()) {\r\n        if (!s.equalsIgnoreCase(\"name\")) {\r\n          p.put(s, profile.get(s).toString());\r\n        }\r\n      }\r\n    }\r\n\r\n  }","commit_id":"a128db23797232185f085fbaeb47de0cdc5325f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n\tprotected void onBind() {\n\t\ttransMemorypresenter.bind();\n\t\tdisplay.getWidgets().add(transMemorypresenter.getDisplay().asWidget());\n\t\tdisplay.getVisibilityHandlers().addVisibilityHandler(new VisibilityHandler(){\n\t\t\t@Override\n\t\t\tpublic void onVisibilityChange(VisibilityEvent tabSelectionEvent) {\n\t\t\t\ttransMemorypresenter.isTransMemoryVisible(true);\n\t\t\t}\n\t\t});\n\t\t\t\n\t\tregisterHandler(eventBus.addHandler(SelectionEvent.getType(), new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\ttransMemorypresenter.isTransUnitSelected(true);\n\t\t\t}\n\t\t})); \n\t\trefreshDisplay();\n\t}","id":32520,"modified_method":"@Override\n\tprotected void onBind() {\n\t\ttransMemorypresenter.bind();\n\t\tdisplay.getWidgets().add(transMemorypresenter.getDisplay().asWidget());\n\t\tdisplay.getValueChangeHandlers().addValueChangeHandler(new ValueChangeHandler<Boolean>() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onValueChange(ValueChangeEvent<Boolean> event) {\n\t\t\t\t\tif(event.getValue())\n\t\t\t\t\t\teventBus.fireEvent(new VisibilityEvent(true));\n\t\t\t\t\telse\n\t\t\t\t\t\teventBus.fireEvent(new VisibilityEvent(false));\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\trefreshDisplay();\n\t}","commit_id":"0fa833df02be791a41406034cac40973422388a7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public SouthView() {\n\t\tdisclosurePanel.setWidth(\"100%\");\n\t\tdisclosurePanel.setOpen(false);\n\t\ttabPanel.add(transPanel, \"Translation Memory\");\n\t\tglossary.setText(\"glossary............................................................\\nglossary\\nglossary\");\n\t\ttabPanel.add(glossary, \"Glossary\");\n\t\trelated.setText(\"related\\nrelated................................................................\\nrelated\");\n\t\ttabPanel.add(related, \"Related\");\n\t\tdisclosurePanel.add(tabPanel);\n\t\ttabPanel.setWidth(\"100%\");\n\t\tint glossIndex = tabPanel.getWidgetIndex(glossary);\n\t\ttabPanel.addSelectionHandler(new SelectionHandler<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<Integer> event) {\n\t\t\t\tif(event.getSelectedItem()==tabPanel.getWidgetIndex(transPanel) && disclosurePanel.isOpen()) {\n\t\t\t\t\tVisibilityEvent.fire(getVisibilityHandlers(), true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttabPanel.selectTab(glossIndex);\n\t}","id":32521,"modified_method":"public SouthView() {\n\t\tdisclosurePanel.setWidth(\"100%\");\n\t\tdisclosurePanel.setOpen(false);\n\t\ttabPanel.add(transPanel, \"Translation Memory\");\n\t\tglossary.setText(\"glossary............................................................\\nglossary\\nglossary\");\n\t\ttabPanel.add(glossary, \"Glossary\");\n\t\tdisclosurePanel.add(tabPanel);\n\t\ttabPanel.setWidth(\"100%\");\n\t\t//int glossIndex = tabPanel.getWidgetIndex(glossary);\n\t\ttabPanel.addSelectionHandler(new SelectionHandler<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<Integer> event) {\n\t\t\t\tif(disclosurePanel.isOpen()) {\n\t\t\t\t\tif (event.getSelectedItem() == tabPanel.getWidgetIndex(transPanel)) {\n\t\t\t\t\t\tValueChangeEvent.fire(SouthView.this, true);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tValueChangeEvent.fire(SouthView.this, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tValueChangeEvent.fire(SouthView.this, false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t//transPanel is set default\n\t\ttabPanel.selectTab(tabPanel.getWidgetIndex(transPanel));\n\t}","commit_id":"0fa833df02be791a41406034cac40973422388a7","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tprotected void onBind() {\n\t\t\n\t\tdisplay.getSearchButton().addClickHandler(new ClickHandler() {\n\t\t\t@Override\n\t\t\tpublic void onClick(ClickEvent event) {\n\t\t\tif(transMemoryVisible && transUnitSelected) {\n\t\t\t\tdisplay.clearResults();\n\t\t\t\tGetTranslationMemory action = new GetTranslationMemory(\n\t\t\t\t\t\tdisplay.getTmTextBox().getText(), \n\t\t\t\t\t\tworkspaceContext.getLocaleId(), false);\n\t\t\t\tdispatcher.execute(action, new AsyncCallback<GetTranslationMemoryResult>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onSuccess(GetTranslationMemoryResult result) {\n\t\t\t\t\t\tArrayList<TransMemory> memories = result.getMemories();\n\t\t\t\t\t\tdisplay.createTable(memories);\n\t\t\t\t\t}\n\t\t\t});\n\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":32522,"modified_method":"@Override\n\tprotected void onBind() {\n\t\t\n\t\tdisplay.getSearchButton().addClickHandler(new ClickHandler() {\n\t\t\t@Override\n\t\t\tpublic void onClick(ClickEvent event) {\n\t\t\t\tdisplay.clearResults();\n\t\t\t\tGetTranslationMemory action = new GetTranslationMemory(\n\t\t\t\t\t\tdisplay.getTmTextBox().getText(), \n\t\t\t\t\t\tworkspaceContext.getLocaleId(), false);\n\t\t\t\tdispatcher.execute(action, new AsyncCallback<GetTranslationMemoryResult>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onSuccess(GetTranslationMemoryResult result) {\n\t\t\t\t\t\tArrayList<TransMemory> memories = result.getMemories();\n\t\t\t\t\t\tdisplay.createTable(memories);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\tregisterHandler(eventBus.addHandler(SelectionEvent.getType(), new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\tif(transMemoryVisible) {\n\t\t\t\t\t//Start automatically fuzzy search\n\t\t\t\t\t//FixME: retrieve the query from Source\n\t\t\t\t\tdispatcher.execute(new GetTranslationMemory(display.getTmTextBox().getText(), workspaceContext.getLocaleId(), true), new AsyncCallback<GetTranslationMemoryResult>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onSuccess(GetTranslationMemoryResult result) {\n\t\t\t\t\t\t\tArrayList<TransMemory> memories = result.getMemories();\n\t\t\t\t\t\t\tdisplay.createTable(memories);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t})); \n\t\t\n\t\tregisterHandler(eventBus.addHandler(VisibilityEvent.getType(), new VisibilityHandler(){\n\t\t\t@Override\n\t\t\tpublic void onVisibilityChange(VisibilityEvent tabSelectionEvent) {\n\t\t\t\tif(tabSelectionEvent.isVisible())\n\t\t\t\t\ttransMemoryVisible = true;\n\t\t\t\telse\n\t\t\t\t\ttransMemoryVisible = false;\n\t\t\t}\n\t\t}));\n\t}","commit_id":"0fa833df02be791a41406034cac40973422388a7","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    @Category(BasicAcceptanceTest.class)\n    public void changePasswordSuccessful() {\n        DashboardBasePage dashboard =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\");\n        dashboard.gotoSettingsTab()\n                 .typeOldPassword(\"translator\")\n                 .typeNewPassword(\"newpassword\")\n                 .clickUpdatePasswordButton();\n\n        HomePage homePage = dashboard.logout();\n        assertThat(\"User is logged out\", !homePage.hasLoggedIn());\n        DashboardBasePage dashboardPage =\n                new LoginWorkFlow().signIn(\"translator\", \"newpassword\");\n        assertThat(\"User has logged in with the new password\",\n                dashboardPage.hasLoggedIn());\n    }","id":32523,"modified_method":"@Test\n    @Category(BasicAcceptanceTest.class)\n    public void changePasswordSuccessful() {\n        DashboardBasePage dashboard =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\");\n        dashboard.goToSettingsTab()\n                .gotoSettingsAccountTab()\n                .typeOldPassword(\"translator\")\n                .typeNewPassword(\"newpassword\")\n                .clickUpdatePasswordButton();\n\n        HomePage homePage = dashboard.logout();\n        assertThat(\"User is logged out\", !homePage.hasLoggedIn());\n        DashboardBasePage dashboardPage =\n                new LoginWorkFlow().signIn(\"translator\", \"newpassword\");\n        assertThat(\"User has logged in with the new password\",\n                dashboardPage.hasLoggedIn());\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changePasswordRequiredFieldsAreNotEmpty() {\n        String mayNotBeEmpty = \"may not be empty\";\n        List<String> fieldErrors =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\")\n                        .gotoSettingsTab()\n                        .clickUpdatePasswordButton()\n                        .getFieldErrors();\n\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.contains(mayNotBeEmpty, mayNotBeEmpty));\n    }","id":32524,"modified_method":"@Test\n    public void changePasswordRequiredFieldsAreNotEmpty() {\n        String mayNotBeEmpty = \"may not be empty\";\n        List<String> fieldErrors =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\")\n                        .goToSettingsTab()\n                        .gotoSettingsAccountTab()\n                        .clickUpdatePasswordButton()\n                        .getFieldErrors();\n\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.contains(mayNotBeEmpty, mayNotBeEmpty));\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changePasswordAreOfRequiredLength() {\n        String passwordSizeError = \"size must be between 6 and 20\";\n        String tooShort = \"test5\";\n        String tooLong = \"t12345678901234567890\";\n        DashboardSettingsTab dashboardSettingsTab =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\")\n                        .gotoSettingsTab()\n                        .typeOldPassword(\"translator\");\n\n        List<String> fieldErrors =\n            dashboardSettingsTab\n                        .typeNewPassword(tooShort)\n                        .clickUpdatePasswordButton()\n                        .waitForFieldErrors();\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.hasItem(passwordSizeError));\n\n        fieldErrors =\n                dashboardSettingsTab\n                        .typeNewPassword(tooLong)\n                        .clickUpdatePasswordButton()\n                        .waitForFieldErrors();\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.hasItem(passwordSizeError));\n    }","id":32525,"modified_method":"@Test\n    public void changePasswordAreOfRequiredLength() {\n        String passwordSizeError = \"size must be between 6 and 20\";\n        String tooShort = \"test5\";\n        String tooLong = \"t12345678901234567890\";\n        DashboardAccountTab dashboardAccountTab =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\")\n                        .goToSettingsTab()\n                        .gotoSettingsAccountTab()\n                        .typeOldPassword(\"translator\");\n\n        List<String> fieldErrors =\n            dashboardAccountTab\n                        .typeNewPassword(tooShort)\n                        .clickUpdatePasswordButton()\n                        .waitForFieldErrors();\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.hasItem(passwordSizeError));\n\n        fieldErrors =\n                dashboardAccountTab\n                        .typeNewPassword(tooLong)\n                        .clickUpdatePasswordButton()\n                        .waitForFieldErrors();\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.hasItem(passwordSizeError));\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changePasswordCurrentPasswordFailure() {\n        String incorrectPassword =\n                \"Old password is incorrect, please check and try again.\";\n        List<String> fieldErrors =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\")\n                        .gotoSettingsTab()\n                        .typeOldPassword(\"nottherightpassword\")\n                        .typeNewPassword(\"somenewpassword\")\n                        .clickUpdatePasswordButton()\n                        .getFieldErrors();\n\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.contains(incorrectPassword));\n    }","id":32526,"modified_method":"@Test\n    public void changePasswordCurrentPasswordFailure() {\n        String incorrectPassword =\n                \"Old password is incorrect, please check and try again.\";\n        List<String> fieldErrors =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\")\n                        .goToSettingsTab()\n                        .gotoSettingsAccountTab()\n                        .typeOldPassword(\"nottherightpassword\")\n                        .typeNewPassword(\"somenewpassword\")\n                        .clickUpdatePasswordButton()\n                        .getFieldErrors();\n\n        assertThat(\"Incorrect password message displayed\",\n                fieldErrors,\n                Matchers.contains(incorrectPassword));\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DashboardSettingsTab gotoSettingsTab() {\n        settingsTab.click();\n        return new DashboardSettingsTab(getDriver());\n    }","id":32527,"modified_method":"public DashboardBasePage goToSettingsTab() {\n        clickWhenTabEnabled(settingsTab);\n        return new DashboardBasePage(getDriver());\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void accountEmailModification() throws Exception {\n        final String successMessage =\n                \"You will soon receive an email with a link to activate your email account change.\";\n        dashboard.gotoSettingsTab()\n                 .typeNewAccountEmailAddress(\"new@fakeemail.com\")\n                 .clickUpdateEmailButton()\n                 .waitForNotificationMessage(successMessage);\n        assertThat(dashboard.getNotificationMessage())\n                .isEqualTo(successMessage);\n    }","id":32528,"modified_method":"@Test\n    public void accountEmailModification() throws Exception {\n        final String successMessage =\n                \"You will soon receive an email with a link to activate your email account change.\";\n        dashboard.goToSettingsTab()\n                .gotoSettingsAccountTab()\n                .typeNewAccountEmailAddress(\"new@fakeemail.com\")\n                .clickUpdateEmailButton()\n                .waitForNotificationMessage(successMessage);\n        assertThat(dashboard.getNotificationMessage())\n                .isEqualTo(successMessage);\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void passwordChange() throws Exception {\n        final String passwordChanged =\n                \"Your password has been successfully changed.\";\n        dashboard.gotoSettingsTab()\n                 .typeOldPassword(\"admin\")\n                 .typeNewPassword(\"admin2\")\n                 .clickUpdatePasswordButton()\n                 .waitForNotificationMessage(passwordChanged);\n        assertThat(dashboard.getNotificationMessage()).isEqualTo(\n                passwordChanged);\n    }","id":32529,"modified_method":"@Test\n    public void passwordChange() throws Exception {\n        final String passwordChanged =\n                \"Your password has been successfully changed.\";\n        dashboard.goToSettingsTab()\n                .gotoSettingsAccountTab()\n                .typeOldPassword(\"admin\")\n                .typeNewPassword(\"admin2\")\n                .clickUpdatePasswordButton()\n                .waitForNotificationMessage(passwordChanged);\n        assertThat(dashboard.getNotificationMessage()).isEqualTo(\n                passwordChanged);\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"public EditProfilePage enterEmail(String email) {\n        emailField.clear();\n        emailField.sendKeys(email);\n        return new EditProfilePage(getDriver());\n    }","id":32530,"modified_method":"public EditProfilePage enterEmail(String email) {\n        emailField.clear();\n        emailField.sendKeys(email);\n        defocus();\n        return new EditProfilePage(getDriver());\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"public EditProfilePage enterName(String name) {\n        nameField.clear();\n        nameField.sendKeys(name);\n        return new EditProfilePage(getDriver());\n    }","id":32531,"modified_method":"public EditProfilePage enterName(String name) {\n        nameField.clear();\n        nameField.sendKeys(name);\n        defocus();\n        return new EditProfilePage(getDriver());\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n    public void before() {\n        googlePassword1 = getSignIn(googleUsername1);\n        assumeFalse(\"Environment has Google login data\",\n                googlePassword1.isEmpty());\n        assumeTrue(\"Google can be reached\", googleIsReachable());\n\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n\n        GoogleManagePermissionsPage googleManagePermissionsPage =\n                new GoogleWorkFlow().resetGooglePermissions(googleUsername1,\n                        googlePassword1);\n\n        assumeFalse(\"Google contains localhost permissions\",\n                googleManagePermissionsPage.pageContainsPermission(\"localhost\"));\n\n        GoogleAccountPage googleAccountPage =\n                new GoogleWorkFlow().forceLogout();\n\n        assumeTrue(googleAccountPage.getUrl().contains(\"/Login\"));\n\n    }","id":32532,"modified_method":"@Before\n    public void before() {\n        googlePassword1 = getSignIn(googleUsername1);\n        assertThat(\"Environment has Google login data\",\n                !googlePassword1.isEmpty());\n        assertThat(\"Google can be reached\", googleIsReachable());\n\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n\n        GoogleManagePermissionsPage googleManagePermissionsPage =\n                new GoogleWorkFlow().resetGooglePermissions(googleUsername1,\n                        googlePassword1);\n\n        assumeFalse(\"Google contains localhost permissions\",\n                googleManagePermissionsPage.pageContainsPermission(\"localhost\"));\n\n        GoogleAccountPage googleAccountPage =\n                new GoogleWorkFlow().forceLogout();\n\n        assumeTrue(googleAccountPage.getUrl().contains(\"/ServiceLogin\"));\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void signInWithGoogleOpenID() {\n        String googleUsername = googleUsername1;\n        String googlePassword = googlePassword1;\n\n        HomePage homePage =\n                new RegisterWorkFlow().registerGoogleOpenID(\"Zanata OpenID\",\n                        \"openidtest\", googlePassword,\n                        googleUsername.concat(\"@gmail.com\"));\n\n        assertThat(\n                \"The registration message is shown\",\n                homePage.getNotificationMessage(),\n                Matchers.equalTo(\"You will soon receive an email with a link to activate your account.\"));\n    }","id":32533,"modified_method":"@Test\n    public void signInWithGoogleOpenID() {\n        String googleUsername = googleUsername1;\n        String googlePassword = googlePassword1;\n\n        HomePage homePage = new RegisterWorkFlow()\n                .registerGoogleOpenID(\"Zanata OpenID\",\n                        \"openidtest\", googlePassword,\n                        googleUsername.concat(\"@gmail.com\"));\n\n        assertThat(\"The registration message is shown\",\n                homePage.getNotificationMessage(),\n                Matchers.equalTo(\"You will soon receive an email with a link\" +\n                        \" to activate your account.\"));\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Query the property for a GOOGLEID variable and return the stated\n     * password that corresponds to the indicated username. Expects the variable\n     * to be in the form:\n     * <p />\n     * {@literal mvn <goals> -DGOOGLEID=username1:password1;username2:password2;}\n     *\n     * @param username\n     *            Username of username:password pair query\n     * @return password for indicated username, or empty string for a\n     *         query/match failure\n     */\n    public static String getSignIn(String username) {\n        String googlePass;\n        String empty = \"\";\n        googlePass = System.getProperty(\"GOOGLEID\");\n        if (Strings.isNullOrEmpty(googlePass)) {\n            log.info(\"Google open ID credential is not available\");\n            return empty;\n        }\n\n        for (String signIn : googlePass.split(\";\")) {\n            String[] usernamePasswordPair = signIn.split(\":\");\n            if (usernamePasswordPair.length > 0\n                    && usernamePasswordPair[0].equals(username)) {\n                return usernamePasswordPair[1];\n            }\n        }\n        log.warn(\"Cannot find user/password combination for \" + username);\n        return empty;\n    }","id":32534,"modified_method":"/**\n     * Query the properties for a googleopenid.credentials entry and return a\n     * password that corresponds to the indicated username. Expects the variable\n     * to be in the form:\n     * <p />\n     * {@literal mvn <goals>\n     *     -Dgoogleopenid.credentials=username1:password1;username2:password2;}\n     *\n     * @param username\n     *            Username of username:password pair query\n     * @return password for indicated username, or empty string for a\n     *         query/match failure\n     */\n    public static String getSignIn(String username) {\n        String googlePass;\n        String empty = \"\";\n        googlePass = PropertiesHolder.properties\n                .getProperty(\"googleopenid.credentials\");\n        if (Strings.isNullOrEmpty(googlePass)) {\n            log.info(\"Google OpenID credentials not set in properties\");\n            return empty;\n        }\n\n        for (String signIn : googlePass.split(\";\")) {\n            String[] usernamePasswordPair = signIn.split(\":\");\n            if (usernamePasswordPair.length > 0\n                    && usernamePasswordPair[0].equals(username)) {\n                return usernamePasswordPair[1];\n            }\n        }\n        log.warn(\"Cannot find user/password combination for \" + username);\n        return empty;\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void emailValidationIsUsedOnProfileEdit() {\n        EditProfilePage editProfilePage = new LoginWorkFlow()\n                .signIn(\"translator\", \"translator\")\n                .goToMyProfile()\n                .clickEditProfileButton()\n                .enterName(\"Transistor\")\n                .enterEmail(\"admin@example.com\")\n                .clickSaveAndExpectErrors();\n\n        assertThat(\"The email is rejected, being already taken\",\n                editProfilePage.getErrors(),\n                Matchers.contains(\"This email address is already taken\"));\n\n        editProfilePage = editProfilePage\n                .enterEmail(\"test @example.com\")\n                .clickSaveAndExpectErrors();\n\n        assertThat(\"The email is rejected, being of invalid format\",\n                editProfilePage.getErrors(),\n                Matchers.contains(\"not a well-formed email address\"));\n    }","id":32535,"modified_method":"@Test\n    public void emailValidationIsUsedOnProfileEdit() {\n        DashboardAccountTab dashboardAccountTab = new LoginWorkFlow()\n                .signIn(\"translator\", \"translator\")\n                .goToSettingsTab()\n                .gotoSettingsAccountTab()\n                .typeNewAccountEmailAddress(\"admin@example.com\")\n                .clickUpdateEmailButton();\n\n        assertThat(dashboardAccountTab.waitForFieldErrors())\n                .contains(\"This email address is already taken\")\n                .as(\"The email is rejected, being already taken\");\n\n        dashboardAccountTab = dashboardAccountTab\n                .goToMyDashboard()\n                .goToSettingsTab()\n                .gotoSettingsAccountTab()\n                .typeNewAccountEmailAddress(\"test @example.com\")\n                .clickUpdateEmailButton();\n\n        assertThat(dashboardAccountTab.waitForFieldErrors())\n                .contains(\"not a well-formed email address\")\n                .as(\"The email is rejected, being of invalid format\");\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changeUsersApiKey() {\n        MyAccountPage myAccountPage =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\")\n                        .goToMyProfile();\n        String currentApiKey = myAccountPage.getApiKey();\n        myAccountPage = myAccountPage.pressApiKeyGenerateButton();\n\n        assertThat(\"The user's api key is different\",\n                myAccountPage.getApiKey(),\n                Matchers.not(Matchers.equalTo(currentApiKey)));\n\n        assertThat(\"The user's api key is not empty\",\n                myAccountPage.getApiKey(),\n                Matchers.not(Matchers.isEmptyString()));\n\n        assertThat(\"The configuration api key matches the label\",\n                myAccountPage.getConfigurationDetails(),\n                Matchers.containsString(\"localhost.key=\".concat(myAccountPage\n                        .getApiKey())));\n    }","id":32536,"modified_method":"@Test\n    public void changeUsersApiKey() {\n        DashboardClientTab dashboardClientTab = new LoginWorkFlow()\n                .signIn(\"translator\", \"translator\")\n                .goToSettingsTab()\n                .goToSettingsClientTab();\n        String currentApiKey = dashboardClientTab.getApiKey();\n        dashboardClientTab = dashboardClientTab.pressApiKeyGenerateButton();\n        dashboardClientTab.waitForLoaderFinished();\n\n        assertThat(dashboardClientTab.getApiKey()).isNotEqualTo(currentApiKey)\n                .as(\"The user's api key is different\");\n\n        assertThat(dashboardClientTab.getApiKey()).isNotEmpty()\n                .as(\"The user's api key is not empty\");\n\n        assertThat(dashboardClientTab.getConfigurationDetails())\n                .contains(\"localhost.key=\"\n                        .concat(dashboardClientTab.getApiKey()))\n                .as(\"The configuration api key matches the label\");\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void verifyProfileData() {\n        MyAccountPage myAccountPage =\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").goToMyProfile();\n\n        assertThat(\"The user's name is displayed in bold\",\n                myAccountPage.getFullName(), Matchers.equalTo(\"Administrator\"));\n\n        assertThat(\"The user's username is displayed in smaller bold\",\n                myAccountPage.getUsername(), Matchers.equalTo(\"admin\"));\n\n        assertThat(\"The correct api key is present\", myAccountPage.getApiKey(),\n                Matchers.equalTo(adminsApiKey));\n\n        assertThat(\n                \"The configuration url is correct\",\n                myAccountPage.getConfigurationDetails(),\n                Matchers.containsString(\"localhost.url=http://localhost:9898/zanata/\"));\n\n        assertThat(\"The configuration username is correct\",\n                myAccountPage.getConfigurationDetails(),\n                Matchers.containsString(\"localhost.username=admin\"));\n\n        assertThat(\"The configuration api key is correct\",\n                myAccountPage.getConfigurationDetails(),\n                Matchers.containsString(\"localhost.key=\".concat(adminsApiKey)));\n    }","id":32537,"modified_method":"@Test\n    public void verifyProfileData() {\n        DashboardClientTab dashboardClientTab = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToSettingsTab()\n                .goToSettingsClientTab();\n\n        assertThat(dashboardClientTab.getApiKey()).isEqualTo(adminsApiKey)\n                .as(\"The correct api key is present\");\n\n        assertThat(dashboardClientTab.getConfigurationDetails())\n                .contains(\"localhost.url=\"+serverUrl)\n                .as(\"The configuration url is correct\");\n\n        assertThat(dashboardClientTab.getConfigurationDetails())\n                .contains(\"localhost.username=admin\")\n                .as(\"The configuration username is correct\");\n\n        assertThat(dashboardClientTab.getConfigurationDetails())\n                .contains(\"localhost.key=\".concat(adminsApiKey))\n                .as(\"The configuration api key is correct\");\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changeUsersName() {\n        MyAccountPage myAccountPage = new LoginWorkFlow()\n                .signIn(\"translator\", \"translator\")\n                .goToMyProfile();\n        myAccountPage = myAccountPage\n                .clickEditProfileButton()\n                .enterName(\"Tranny\")\n                .clickSaveChanges();\n        assertThat(\"The user's name has been changed\",\n                myAccountPage.getFullName(),\n                Matchers.equalTo(\"Tranny\"));\n    }","id":32538,"modified_method":"@Test\n    public void changeUsersName() {\n        DashboardProfileTab dashboardProfileTab = new LoginWorkFlow()\n                .signIn(\"translator\", \"translator\")\n                .goToSettingsTab()\n                .goToSettingsProfileTab()\n                .enterName(\"Tranny\")\n                .clickUpdateProfileButton();\n        dashboardProfileTab.waitForLoaderFinished();\n\n        assertThat(dashboardProfileTab.getUserFullName()).isEqualTo(\"Tranny\")\n                .as(\"The user's name has been changed\");\n    }","commit_id":"624b7c7bd1c3857287cc7afc65e90f5d1b798d89","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n   * Publishes a channel.\n   * @param the channel XML fragment\n   * @param a list of categories that the channel belongs to\n   * @param a list of group keys that are permitted to subscribe to and view the channel\n   * @param the user ID of the channel publisher\n   * @throws java.lang.Exception\n   */\n  public static void publishChannel (Element channel, String[] categoryIDs, IEntityGroup[] groups, IPerson publisher) throws Exception {\n    // Reset the channel registry cache\n    channelRegistryCache.remove(CHANNEL_REGISTRY_CACHE_KEY);\n\n    // Use current channel ID if modifying previously published channel, otherwise get a new ID\n    int ID = 0;\n    String chanID = channel.getAttribute(\"ID\");\n    if (chanID != null && chanID.trim().length() > 0) {\n      ID = Integer.parseInt(chanID.startsWith(\"chan\") ? chanID.substring(4) : chanID);\n      LogService.instance().log(LogService.INFO, \"Attempting to modify channel \" + ID + \"...\");\n    }\n    else {\n      ID = chanRegStore.getNextId();\n      LogService.instance().log(LogService.INFO, \"Attempting to publish new channel \" + ID + \"...\");\n    }\n\n    // Add channel\n    Document channelDoc = DocumentFactory.getNewDocument();\n    channelDoc.appendChild(channelDoc.importNode(channel, true));\n    chanRegStore.addChannel(ID, publisher, channelDoc, categoryIDs);\n\n    // Set groups\n    AuthorizationService authService = AuthorizationService.instance();\n    String owner = \"UP_FRAMEWORK\"; // the whole framework\n    IUpdatingPermissionManager upm = authService.newUpdatingPermissionManager(owner);\n    IPermission[] permissions = new IPermission[groups.length];\n    for (int i = 0; i < groups.length; i++) {\n      String principalKey = groups[i].getKey();\n      IAuthorizationPrincipal authPrincipal = authService.newPrincipal(principalKey, IEntityGroup.class);\n      permissions[i] = upm.newPermission(authPrincipal);\n      permissions[i].setType(\"GRANT\");\n      permissions[i].setActivity(\"SUBSCRIBE\");\n      permissions[i].setTarget(\"CHAN_ID.\" + ID);\n    }\n    upm.addPermissions(permissions);\n\n    // Approve channel - this can be removed when there is a mechanism to approve channels\n    chanRegStore.approveChannel(ID, publisher, new Date(System.currentTimeMillis()));\n\n    LogService.instance().log(LogService.INFO, \"Channel \" + ID + \" has been published/modified.\");\n  }","id":32539,"modified_method":"/**\n   * Publishes a channel.\n   * @param the channel XML fragment\n   * @param a list of categories that the channel belongs to\n   * @param a list of group keys that are permitted to subscribe to and view the channel\n   * @param the user ID of the channel publisher\n   * @throws java.lang.Exception\n   */\n  public static void publishChannel (Element channel, String[] categoryIDs, IEntityGroup[] groups, IPerson publisher) throws Exception {\n    // Reset the channel registry cache\n    channelRegistryCache.remove(CHANNEL_REGISTRY_CACHE_KEY);\n\n    // Use current channel ID if modifying previously published channel, otherwise get a new ID\n    boolean newChannel = true;\n    int ID = 0;\n    String chanID = channel.getAttribute(\"ID\");\n    if (chanID != null && chanID.trim().length() > 0) {\n      newChannel = false;\n      ID = Integer.parseInt(chanID.startsWith(\"chan\") ? chanID.substring(4) : chanID);\n      LogService.instance().log(LogService.INFO, \"Attempting to modify channel \" + ID + \"...\");\n    }\n    else {\n      ID = chanRegStore.getNextId();\n      LogService.instance().log(LogService.INFO, \"Attempting to publish new channel \" + ID + \"...\");\n    }\n\n    // Add channel\n    Document channelDoc = DocumentFactory.getNewDocument();\n    channelDoc.appendChild(channelDoc.importNode(channel, true));\n    chanRegStore.addChannel(ID, publisher, channelDoc, categoryIDs);\n\n    // Set groups\n    AuthorizationService authService = AuthorizationService.instance();\n    String owner = \"UP_FRAMEWORK\"; // the whole framework\n    IUpdatingPermissionManager upm = authService.newUpdatingPermissionManager(owner);\n    IPermission[] permissions = new IPermission[groups.length];\n    for (int i = 0; i < groups.length; i++) {\n      String principalKey = groups[i].getKey();\n      IAuthorizationPrincipal authPrincipal = authService.newPrincipal(principalKey, IEntityGroup.class);\n      permissions[i] = upm.newPermission(authPrincipal);\n      permissions[i].setType(\"GRANT\");\n      permissions[i].setActivity(\"SUBSCRIBE\");\n      permissions[i].setTarget(\"CHAN_ID.\" + ID);\n    }\n\n    if (newChannel)\n       upm.addPermissions(permissions);\n    else\n       upm.updatePermissions(permissions); // this doesn't change the principal! shouldn't it?\n\n    // Approve channel - this can be removed when there is a mechanism to approve channels\n    chanRegStore.approveChannel(ID, publisher, new Date(System.currentTimeMillis()));\n\n    LogService.instance().log(LogService.INFO, \"Channel \" + ID + \" has been \" + (newChannel ? \"published\" : \"modified\") + \".\");\n  }","commit_id":"1ccbdf8761a1f7a80458f25b825a78c228d1a993","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected void addCommunityPermissions(\n\t\t\tlong groupId, String name, long resourceId, boolean portletActions)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 1);\n\n\t\tList actions = null;\n\n\t\tif (portletActions) {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getPortletResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\t\telse {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getModelResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 2);\n\n\t\tString[] actionIds = (String[])actions.toArray(new String[0]);\n\n\t\tList permissions = permissionLocalService.getPermissions(\n\t\t\tgroup.getCompanyId(), actionIds, resourceId);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 3);\n\n\t\tgroupPersistence.addPermissions(groupId, permissions);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 4);\n\t}","id":32540,"modified_method":"protected void addCommunityPermissions(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tResource resource, boolean portletActions)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tlong resourceId = resource.getResourceId();\n\t\tString primKey = resource.getPrimKey();\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 1);\n\n\t\tList actions = null;\n\n\t\tif (portletActions) {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getPortletResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\t\telse {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getModelResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 2);\n\n\t\tString[] actionIds = (String[])actions.toArray(new String[0]);\n\n\t\tList communityPermissionsList = permissionLocalService.getPermissions(\n\t\t\tgroup.getCompanyId(), actionIds, resourceId);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 3);\n\n\t\tPermissionsListFilter permissionsListFilter =\n\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\tcommunityPermissionsList =\n\t\t\tpermissionsListFilter.filterCommunityPermissions(\n\t\t\t\tcompanyId, groupId, userId, name, primKey, portletActions,\n\t\t\t\tcommunityPermissionsList);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 4);\n\n\t\tgroupPersistence.addPermissions(groupId, communityPermissionsList);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 5);\n\t}","commit_id":"69ee38e87c7bc77ddd542c8fd242a1f9d0ee9bbd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addModelResources(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tString primKey, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(companyId, name, false);\n\n\t\t// Company\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceImpl.SCOPE_COMPANY,\n\t\t\tString.valueOf(companyId));\n\n\t\t// Guest\n\n\t\tGroup guestGroup = groupLocalService.getGroup(\n\t\t\tcompanyId, GroupImpl.GUEST);\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceImpl.SCOPE_GROUP,\n\t\t\tString.valueOf(guestGroup.getGroupId()));\n\n\t\t// Group\n\n\t\tif ((groupId > 0) && (guestGroup.getGroupId() != groupId)) {\n\t\t\taddResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_GROUP,\n\t\t\t\tString.valueOf(groupId));\n\t\t}\n\n\t\tif (primKey != null) {\n\n\t\t\t// Individual\n\n\t\t\tResource resource = addResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_INDIVIDUAL, primKey);\n\n\t\t\t// Permissions\n\n\t\t\tList permissions = permissionLocalService.addPermissions(\n\t\t\t\tcompanyId, name, resource.getResourceId(), false);\n\n\t\t\t// User permissions\n\n\t\t\tlong defaultUserId = userLocalService.getDefaultUserId(companyId);\n\n\t\t\tif ((userId > 0) && (userId != defaultUserId)) {\n\t\t\t\tuserPersistence.addPermissions(userId, permissions);\n\t\t\t}\n\n\t\t\t// Community permissions\n\n\t\t\tif ((groupId > 0) && (communityPermissions != null)) {\n\t\t\t\taddModelPermissions(\n\t\t\t\t\tgroupId, resource.getResourceId(), communityPermissions);\n\t\t\t}\n\n\t\t\t// Guest permissions\n\n\t\t\tif (guestPermissions != null) {\n\t\t\t\tList guestPermissionsList =\n\t\t\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\t\t\tcompanyId, guestPermissions, resource.getResourceId());\n\n\t\t\t\tuserPersistence.addPermissions(\n\t\t\t\t\tdefaultUserId, guestPermissionsList);\n\t\t\t}\n\t\t}\n\t}","id":32541,"modified_method":"public void addModelResources(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tString primKey, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(companyId, name, false);\n\n\t\t// Company\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceImpl.SCOPE_COMPANY,\n\t\t\tString.valueOf(companyId));\n\n\t\t// Guest\n\n\t\tGroup guestGroup = groupLocalService.getGroup(\n\t\t\tcompanyId, GroupImpl.GUEST);\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceImpl.SCOPE_GROUP,\n\t\t\tString.valueOf(guestGroup.getGroupId()));\n\n\t\t// Group\n\n\t\tif ((groupId > 0) && (guestGroup.getGroupId() != groupId)) {\n\t\t\taddResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_GROUP,\n\t\t\t\tString.valueOf(groupId));\n\t\t}\n\n\t\tif (primKey != null) {\n\n\t\t\t// Individual\n\n\t\t\tResource resource = addResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_INDIVIDUAL, primKey);\n\n\t\t\t// Permissions\n\n\t\t\tList permissionsList = permissionLocalService.addPermissions(\n\t\t\t\tcompanyId, name, resource.getResourceId(), false);\n\n\t\t\t// User permissions\n\n\t\t\tPermissionsListFilter permissionsListFilter =\n\t\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\t\tlong defaultUserId = userLocalService.getDefaultUserId(companyId);\n\n\t\t\tif ((userId > 0) && (userId != defaultUserId)) {\n\t\t\t\tList userPermissionsList =\n\t\t\t\t\tpermissionsListFilter.filterUserPermissions(\n\t\t\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\t\t\tpermissionsList);\n\n\t\t\t\tuserPersistence.addPermissions(userId, userPermissionsList);\n\t\t\t}\n\n\t\t\t// Community permissions\n\n\t\t\tif (groupId > 0) {\n\t\t\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\t\t\tif (communityPermissions == null) {\n\t\t\t\t\tcommunityPermissions = new String[0];\n\t\t\t\t}\n\n\t\t\t\tList communityPermissionsList =\n\t\t\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\t\t\tcompanyId, communityPermissions,\n\t\t\t\t\t\tresource.getResourceId());\n\n\t\t\t\tcommunityPermissionsList =\n\t\t\t\t\tpermissionsListFilter.filterCommunityPermissions(\n\t\t\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\t\t\tcommunityPermissionsList);\n\n\t\t\t\tgroupPersistence.addPermissions(\n\t\t\t\t\tgroupId, communityPermissionsList);\n\t\t\t}\n\n\t\t\t// Guest permissions\n\n\t\t\tif (guestPermissions == null) {\n\t\t\t\tguestPermissions = new String[0];\n\t\t\t}\n\n\t\t\tList guestPermissionsList =\n\t\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\t\tcompanyId, guestPermissions, resource.getResourceId());\n\n\t\t\tguestPermissionsList = permissionsListFilter.filterGuestPermissions(\n\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\tguestPermissionsList);\n\n\t\t\tuserPersistence.addPermissions(defaultUserId, guestPermissionsList);\n\t\t}\n\t}","commit_id":"69ee38e87c7bc77ddd542c8fd242a1f9d0ee9bbd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addGuestPermissions(\n\t\t\tlong companyId, String name, long resourceId,\n\t\t\tboolean portletActions)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong defaultUserId = userLocalService.getDefaultUserId(companyId);\n\n\t\tList actions = null;\n\n\t\tif (portletActions) {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestDefaultActions(name);\n\t\t}\n\t\telse {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestDefaultActions(name);\n\t\t}\n\n\t\tString[] actionIds = (String[])actions.toArray(new String[0]);\n\n\t\tList permissions = permissionLocalService.getPermissions(\n\t\t\tcompanyId, actionIds, resourceId);\n\n\t\tuserPersistence.addPermissions(defaultUserId, permissions);\n\t}","id":32542,"modified_method":"protected void addGuestPermissions(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tResource resource, boolean portletActions)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong defaultUserId = userLocalService.getDefaultUserId(companyId);\n\n\t\tList actions = null;\n\n\t\tif (portletActions) {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestDefaultActions(name);\n\t\t}\n\t\telse {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestDefaultActions(name);\n\t\t}\n\n\t\tString[] actionIds = (String[])actions.toArray(new String[0]);\n\n\t\tList guestPermissionsList = permissionLocalService.getPermissions(\n\t\t\tcompanyId, actionIds, resource.getResourceId());\n\n\t\tPermissionsListFilter permissionsListFilter =\n\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\tguestPermissionsList =\n\t\t\tpermissionsListFilter.filterGuestPermissions(\n\t\t\t\tcompanyId, groupId, userId, name, resource.getPrimKey(),\n\t\t\t\tportletActions, guestPermissionsList);\n\n\t\tuserPersistence.addPermissions(defaultUserId, guestPermissionsList);\n\t}","commit_id":"69ee38e87c7bc77ddd542c8fd242a1f9d0ee9bbd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addResources(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tString primKey, boolean portletActions,\n\t\t\tboolean addCommunityPermissions, boolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tvalidate(companyId, name, portletActions);\n\n\t\tlogAddResources(name, primKey, stopWatch, 1);\n\n\t\t// Company\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceImpl.SCOPE_COMPANY,\n\t\t\tString.valueOf(companyId));\n\n\t\tlogAddResources(name, primKey, stopWatch, 2);\n\n\t\tif (groupId > 0) {\n\t\t\taddResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_GROUP,\n\t\t\t\tString.valueOf(groupId));\n\t\t}\n\n\t\tlogAddResources(name, primKey, stopWatch, 3);\n\n\t\tif (primKey != null) {\n\n\t\t\t// Individual\n\n\t\t\tResource resource = addResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_INDIVIDUAL, primKey);\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 4);\n\n\t\t\t// Permissions\n\n\t\t\tList permissions = permissionLocalService.addPermissions(\n\t\t\t\tcompanyId, name, resource.getResourceId(), portletActions);\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 5);\n\n\t\t\t// User permissions\n\n\t\t\tlong defaultUserId = userLocalService.getDefaultUserId(companyId);\n\n\t\t\tif ((userId > 0) && (userId != defaultUserId)) {\n\t\t\t\tuserPersistence.addPermissions(userId, permissions);\n\t\t\t}\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 6);\n\n\t\t\t// Community permissions\n\n\t\t\tif ((groupId > 0) && addCommunityPermissions) {\n\t\t\t\taddCommunityPermissions(\n\t\t\t\t\tgroupId, name, resource.getResourceId(), portletActions);\n\t\t\t}\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 7);\n\n\t\t\t// Guest permissions\n\n\t\t\tif (addGuestPermissions) {\n\n\t\t\t\t// Don't add guest permissions when you've already added\n\t\t\t\t// community permissions and the given community is the guest\n\t\t\t\t// community.\n\n\t\t\t\taddGuestPermissions(\n\t\t\t\t\tcompanyId, name, resource.getResourceId(), portletActions);\n\t\t\t}\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 9);\n\t\t}\n\t}","id":32543,"modified_method":"public void addResources(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tString primKey, boolean portletActions,\n\t\t\tboolean addCommunityPermissions, boolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tvalidate(companyId, name, portletActions);\n\n\t\tlogAddResources(name, primKey, stopWatch, 1);\n\n\t\t// Company\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceImpl.SCOPE_COMPANY,\n\t\t\tString.valueOf(companyId));\n\n\t\tlogAddResources(name, primKey, stopWatch, 2);\n\n\t\tif (groupId > 0) {\n\t\t\taddResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_GROUP,\n\t\t\t\tString.valueOf(groupId));\n\t\t}\n\n\t\tlogAddResources(name, primKey, stopWatch, 3);\n\n\t\tif (primKey != null) {\n\n\t\t\t// Individual\n\n\t\t\tResource resource = addResource(\n\t\t\t\tcompanyId, name, ResourceImpl.SCOPE_INDIVIDUAL, primKey);\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 4);\n\n\t\t\t// Permissions\n\n\t\t\tList permissionsList = permissionLocalService.addPermissions(\n\t\t\t\tcompanyId, name, resource.getResourceId(), portletActions);\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 5);\n\n\t\t\t// User permissions\n\n\t\t\tPermissionsListFilter permissionsListFilter =\n\t\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\t\tlong defaultUserId = userLocalService.getDefaultUserId(companyId);\n\n\t\t\tif ((userId > 0) && (userId != defaultUserId)) {\n\t\t\t\tList userPermissionsList =\n\t\t\t\t\tpermissionsListFilter.filterUserPermissions(\n\t\t\t\t\t\tcompanyId, groupId, userId, name, primKey,\n\t\t\t\t\t\tportletActions, permissionsList);\n\n\t\t\t\tuserPersistence.addPermissions(userId, userPermissionsList);\n\t\t\t}\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 6);\n\n\t\t\t// Community permissions\n\n\t\t\tif ((groupId > 0) && addCommunityPermissions) {\n\t\t\t\taddCommunityPermissions(\n\t\t\t\t\tcompanyId, groupId, userId, name, resource, portletActions);\n\t\t\t}\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 7);\n\n\t\t\t// Guest permissions\n\n\t\t\tif (addGuestPermissions) {\n\n\t\t\t\t// Don't add guest permissions when you've already added\n\t\t\t\t// community permissions and the given community is the guest\n\t\t\t\t// community.\n\n\t\t\t\taddGuestPermissions(\n\t\t\t\t\tcompanyId, groupId, userId, name, resource, portletActions);\n\t\t\t}\n\n\t\t\tlogAddResources(name, primKey, stopWatch, 9);\n\t\t}\n\t}","commit_id":"69ee38e87c7bc77ddd542c8fd242a1f9d0ee9bbd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void getRootFolders(\n\t\t\tCommandArgument argument, Document doc, Element foldersEl)\n\t\tthrows Exception {\n\n\t\tLinkedHashMap<String, Object> groupParams =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tgroupParams.put(\"usersGroups\", new Long(argument.getUserId()));\n\n\t\tList<Group> groups = GroupLocalServiceUtil.search(\n\t\t\targument.getCompanyId(), null, null, groupParams, QueryUtil.ALL_POS,\n\t\t\tQueryUtil.ALL_POS);\n\n\t\tList<Organization> userOrgs =\n\t\t\tOrganizationLocalServiceUtil.getUserOrganizations(\n\t\t\t\targument.getUserId(), true);\n\n\t\tfor (Organization organization : userOrgs) {\n\t\t\tgroups.add(0, organization.getGroup());\n\t\t}\n\n\t\tif (PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_ENABLED ||\n\t\t\tPropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_ENABLED) {\n\n\t\t\tGroup userGroup = GroupLocalServiceUtil.getUserGroup(\n\t\t\t\targument.getCompanyId(), argument.getUserId());\n\n\t\t\tgroups.add(0, userGroup);\n\t\t}\n\n\t\tfor (Group group : groups) {\n\t\t\tElement folderEl = doc.createElement(\"Folder\");\n\n\t\t\tfoldersEl.appendChild(folderEl);\n\n\t\t\tlong scopeGroupId = argument.getThemeDisplay().getScopeGroupId();\n\n\t\t\tif (group.hasStagingGroup() &&\n\t\t\t\t(group.getStagingGroup().getGroupId() == scopeGroupId)) {\n\n\t\t\t\tGroup stagingGroup = group.getStagingGroup();\n\n\t\t\t\tfolderEl.setAttribute(\n\t\t\t\t\t\"name\",\n\t\t\t\t\tstagingGroup.getGroupId() + \" - \" +\n\t\t\t\t\t\tHtmlUtil.escape(stagingGroup.getDescriptiveName()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfolderEl.setAttribute(\n\t\t\t\t\t\"name\",\n\t\t\t\t\tgroup.getGroupId() + \" - \" +\n\t\t\t\t\t\tHtmlUtil.escape(group.getDescriptiveName()));\n\t\t\t}\n\t\t}\n\t}","id":32544,"modified_method":"protected void getRootFolders(\n\t\t\tCommandArgument argument, Document doc, Element foldersEl)\n\t\tthrows Exception {\n\n\t\tLinkedHashMap<String, Object> groupParams =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tgroupParams.put(\"usersGroups\", new Long(argument.getUserId()));\n\n\t\tList<Group> groups = GroupLocalServiceUtil.search(\n\t\t\targument.getCompanyId(), null, null, groupParams, QueryUtil.ALL_POS,\n\t\t\tQueryUtil.ALL_POS);\n\n\t\tList<Organization> userOrgs =\n\t\t\tOrganizationLocalServiceUtil.getUserOrganizations(\n\t\t\t\targument.getUserId(), true);\n\n\t\tfor (Organization organization : userOrgs) {\n\t\t\tgroups.add(0, organization.getGroup());\n\t\t}\n\n\t\tif (PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_ENABLED ||\n\t\t\tPropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_ENABLED) {\n\n\t\t\tGroup userGroup = GroupLocalServiceUtil.getUserGroup(\n\t\t\t\targument.getCompanyId(), argument.getUserId());\n\n\t\t\tgroups.add(0, userGroup);\n\t\t}\n\n\t\tThemeDisplay themeDisplay = argument.getThemeDisplay();\n\n\t\tlong scopeGroupId = themeDisplay.getScopeGroupId();\n\n\t\tfor (Group group : groups) {\n\t\t\tElement folderEl = doc.createElement(\"Folder\");\n\n\t\t\tfoldersEl.appendChild(folderEl);\n\n\t\t\tboolean setNameAttribute = false;\n\n\t\t\tif (group.hasStagingGroup()) {\n\t\t\t\tGroup stagingGroup = group.getStagingGroup();\n\n\t\t\t\tif (stagingGroup.getGroupId() == scopeGroupId) {\n\t\t\t\t\tfolderEl.setAttribute(\n\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\tstagingGroup.getGroupId() + \" - \" +\n\t\t\t\t\t\t\tHtmlUtil.escape(stagingGroup.getDescriptiveName()));\n\n\t\t\t\t\tsetNameAttribute = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!setNameAttribute) {\n\t\t\t\tfolderEl.setAttribute(\n\t\t\t\t\t\"name\",\n\t\t\t\t\tgroup.getGroupId() + \" - \" +\n\t\t\t\t\t\tHtmlUtil.escape(group.getDescriptiveName()));\n\t\t\t}\n\t\t}\n\t}","commit_id":"f26c3d20b013b3af1f1432a990cea6bc65a54a28","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _getFiles(\n\t\t\tCommandArgument commandArgument, Document document, Node rootNode)\n\t\tthrows Exception {\n\n\t\tElement filesElement = document.createElement(\"Files\");\n\n\t\trootNode.appendChild(filesElement);\n\n\t\tif (Validator.isNull(commandArgument.getCurrentGroupName())) {\n\t\t\treturn;\n\t\t}\n\n\t\tGroup group = commandArgument.getCurrentGroup();\n\n\t\tFolder folder = _getFolder(\n\t\t\tgroup.getGroupId(), commandArgument.getCurrentFolder());\n\n\t\tList<FileEntry> fileEntries = DLAppServiceUtil.getFileEntries(\n\t\t\tfolder.getRepositoryId(), folder.getFolderId());\n\n\t\tfor (FileEntry fileEntry : fileEntries) {\n\t\t\tElement fileElement = document.createElement(\"File\");\n\n\t\t\tfilesElement.appendChild(fileElement);\n\n\t\t\tString name = fileEntry.getTitle();\n\n\t\t\tString extension = fileEntry.getExtension();\n\n\t\t\tif (Validator.isNotNull(extension)) {\n\t\t\t\tString periodAndExtension = StringPool.PERIOD.concat(extension);\n\n\t\t\t\tif (!name.endsWith(periodAndExtension)) {\n\t\t\t\t\tname = name.concat(periodAndExtension);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfileElement.setAttribute(\"name\", name);\n\t\t\tfileElement.setAttribute(\"desc\", name);\n\n\t\t\tfileElement.setAttribute(\"size\", getSize(fileEntry.getSize()));\n\n\t\t\tThemeDisplay themeDisplay = commandArgument.getThemeDisplay();\n\n\t\t\tString url = DLUtil.getPreviewURL(\n\t\t\t\tfileEntry, fileEntry.getFileVersion(), themeDisplay,\n\t\t\t\tStringPool.BLANK, false, false);\n\n\t\t\tfileElement.setAttribute(\"url\", url);\n\t\t}\n\t}","id":32545,"modified_method":"private void _getFiles(\n\t\t\tCommandArgument commandArgument, Document document, Node rootNode)\n\t\tthrows Exception {\n\n\t\tElement filesElement = document.createElement(\"Files\");\n\n\t\trootNode.appendChild(filesElement);\n\n\t\tif (Validator.isNull(commandArgument.getCurrentGroupName())) {\n\t\t\treturn;\n\t\t}\n\n\t\tGroup group = commandArgument.getCurrentGroup();\n\n\t\tFolder folder = _getFolder(\n\t\t\tgroup.getGroupId(), commandArgument.getCurrentFolder());\n\n\t\tList<Element> fileElements = getFileElements(\n\t\t\tdocument, commandArgument.getThemeDisplay(), folder);\n\n\t\tfor (Element fileElement : fileElements) {\n\t\t\tfilesElement.appendChild(fileElement);\n\t\t}\n\t}","commit_id":"4f40c8d1eb7ce1d49dc0c3d5e599d4c5ae4275b6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _getFiles(\n\t\t\tCommandArgument commandArgument, Document document, Node rootNode)\n\t\tthrows Exception {\n\n\t\tif (commandArgument.getCurrentFolder().equals(StringPool.SLASH)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement filesElement = document.createElement(\"Files\");\n\n\t\trootNode.appendChild(filesElement);\n\n\t\tGroup group = commandArgument.getCurrentGroup();\n\n\t\tList<Layout> layouts = new ArrayList<Layout>();\n\n\t\tlayouts.addAll(\n\t\t\tLayoutServiceUtil.getLayouts(\n\t\t\t\tgroup.getGroupId(), false,\n\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID));\n\n\t\tlayouts.addAll(\n\t\t\tLayoutServiceUtil.getLayouts(\n\t\t\t\tgroup.getGroupId(), true,\n\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID));\n\n\t\tif ((\"/\" + commandArgument.getCurrentGroupName() + \"/\").equals(\n\t\t\t\tcommandArgument.getCurrentFolder())) {\n\n\t\t\tfor (Layout layout : layouts) {\n\t\t\t\tElement fileElement = document.createElement(\"File\");\n\n\t\t\t\tfilesElement.appendChild(fileElement);\n\n\t\t\t\tfileElement.setAttribute(\"name\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"desc\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"size\", StringPool.BLANK);\n\n\t\t\t\tString layoutURL = PortalUtil.getLayoutFullURL(\n\t\t\t\t\tlayout, commandArgument.getThemeDisplay(), false);\n\n\t\t\t\tlayoutURL = PortalUtil.getCanonicalURL(\n\t\t\t\t\tlayoutURL, commandArgument.getThemeDisplay(), layout, true);\n\n\t\t\t\tfileElement.setAttribute(\"url\", layoutURL);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString layoutName = _getLayoutName(\n\t\t\t\tcommandArgument.getCurrentFolder());\n\n\t\t\tLayout layout = _getLayout(group.getGroupId(), layoutName);\n\n\t\t\tif (layout == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tList<Layout> layoutChildren = layout.getChildren();\n\n\t\t\tfor (int i = 0; i < layoutChildren.size(); i++) {\n\t\t\t\tlayout = layoutChildren.get(i);\n\n\t\t\t\tElement fileElement = document.createElement(\"File\");\n\n\t\t\t\tfilesElement.appendChild(fileElement);\n\n\t\t\t\tfileElement.setAttribute(\"name\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"desc\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"size\", getSize());\n\n\t\t\t\tString layoutURL = PortalUtil.getLayoutFullURL(\n\t\t\t\t\tlayout, commandArgument.getThemeDisplay(), false);\n\n\t\t\t\tlayoutURL = PortalUtil.getCanonicalURL(\n\t\t\t\t\tlayoutURL, commandArgument.getThemeDisplay(), layout, true);\n\n\t\t\t\tfileElement.setAttribute(\"url\", layoutURL);\n\t\t\t}\n\t\t}\n\t}","id":32546,"modified_method":"private void _getFiles(\n\t\t\tCommandArgument commandArgument, Document document, Node rootNode)\n\t\tthrows Exception {\n\n\t\tif (commandArgument.getCurrentFolder().equals(StringPool.SLASH)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement filesElement = document.createElement(\"Files\");\n\n\t\trootNode.appendChild(filesElement);\n\n\t\tGroup group = commandArgument.getCurrentGroup();\n\n\t\tList<Layout> layouts = new ArrayList<Layout>();\n\n\t\tlayouts.addAll(\n\t\t\tLayoutServiceUtil.getLayouts(\n\t\t\t\tgroup.getGroupId(), false,\n\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID));\n\n\t\tlayouts.addAll(\n\t\t\tLayoutServiceUtil.getLayouts(\n\t\t\t\tgroup.getGroupId(), true,\n\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID));\n\n\t\tif ((\"/\" + commandArgument.getCurrentGroupName() + \"/\").equals(\n\t\t\t\tcommandArgument.getCurrentFolder())) {\n\n\t\t\tfor (Layout layout : layouts) {\n\t\t\t\tElement fileElement = document.createElement(\"File\");\n\n\t\t\t\tfilesElement.appendChild(fileElement);\n\n\t\t\t\tfileElement.setAttribute(\"name\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"desc\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"size\", StringPool.BLANK);\n\t\t\t\tfileElement.setAttribute(\n\t\t\t\t\t\"url\",\n\t\t\t\t\t_getCanonicalURL(\n\t\t\t\t\t\tlayout, commandArgument.getThemeDisplay()));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString layoutName = _getLayoutName(\n\t\t\t\tcommandArgument.getCurrentFolder());\n\n\t\t\tLayout layout = _getLayout(group.getGroupId(), layoutName);\n\n\t\t\tif (layout == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tList<Layout> layoutChildren = layout.getChildren();\n\n\t\t\tfor (int i = 0; i < layoutChildren.size(); i++) {\n\t\t\t\tlayout = layoutChildren.get(i);\n\n\t\t\t\tElement fileElement = document.createElement(\"File\");\n\n\t\t\t\tfilesElement.appendChild(fileElement);\n\n\t\t\t\tfileElement.setAttribute(\"name\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"desc\", _getLayoutName(layout));\n\t\t\t\tfileElement.setAttribute(\"size\", getSize());\n\t\t\t\tfileElement.setAttribute(\n\t\t\t\t\t\"url\",\n\t\t\t\t\t_getCanonicalURL(\n\t\t\t\t\t\tlayout, commandArgument.getThemeDisplay()));\n\t\t\t}\n\t\t}\n\t}","commit_id":"e2f45bd5b13df20c2c953defa6489a1f7e750455","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Compute the centroid/barycenter of nodes\n     * @param nodes Nodes for which the centroid is wanted\n     * @return the centroid of nodes\n     * @see Geometry#getCenter\n     */\n    public static EastNorth getCentroid(List<Node> nodes) {\n\n        BigDecimal area = BigDecimal.ZERO;\n        BigDecimal north = BigDecimal.ZERO;\n        BigDecimal east = BigDecimal.ZERO;\n\n        // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon for the equation used here\n        for (int i = 0; i < nodes.size(); i++) {\n            EastNorth n0 = nodes.get(i).getEastNorth();\n            EastNorth n1 = nodes.get((i+1) % nodes.size()).getEastNorth();\n\n            if (n0 != null && n1 != null && n0.isValid() && n1.isValid()) {\n                BigDecimal x0 = new BigDecimal(n0.east());\n                BigDecimal y0 = new BigDecimal(n0.north());\n                BigDecimal x1 = new BigDecimal(n1.east());\n                BigDecimal y1 = new BigDecimal(n1.north());\n\n                BigDecimal k = x0.multiply(y1, MathContext.DECIMAL128).subtract(y0.multiply(x1, MathContext.DECIMAL128));\n\n                area = area.add(k, MathContext.DECIMAL128);\n                east = east.add(k.multiply(x0.add(x1, MathContext.DECIMAL128), MathContext.DECIMAL128));\n                north = north.add(k.multiply(y0.add(y1, MathContext.DECIMAL128), MathContext.DECIMAL128));\n            }\n        }\n\n        BigDecimal d = new BigDecimal(3, MathContext.DECIMAL128); // 1/2 * 6 = 3\n        area  = area.multiply(d, MathContext.DECIMAL128);\n        if (area.compareTo(BigDecimal.ZERO) != 0) {\n            north = north.divide(area, MathContext.DECIMAL128);\n            east = east.divide(area, MathContext.DECIMAL128);\n        }\n\n        return new EastNorth(east.doubleValue(), north.doubleValue());\n    }","id":32547,"modified_method":"/**\n     * Compute the centroid/barycenter of nodes\n     * @param nodes Nodes for which the centroid is wanted\n     * @return the centroid of nodes\n     * @see Geometry#getCenter\n     */\n    public static EastNorth getCentroid(List<Node> nodes) {\n\n        BigDecimal area = BigDecimal.ZERO;\n        BigDecimal north = BigDecimal.ZERO;\n        BigDecimal east = BigDecimal.ZERO;\n\n        // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon for the equation used here\n        for (int i = 0; i < nodes.size(); i++) {\n            EastNorth n0 = nodes.get(i).getEastNorth();\n            EastNorth n1 = nodes.get((i+1) % nodes.size()).getEastNorth();\n\n            if (n0 != null && n1 != null && n0.isValid() && n1.isValid()) {\n                BigDecimal x0 = BigDecimal.valueOf(n0.east());\n                BigDecimal y0 = BigDecimal.valueOf(n0.north());\n                BigDecimal x1 = BigDecimal.valueOf(n1.east());\n                BigDecimal y1 = BigDecimal.valueOf(n1.north());\n\n                BigDecimal k = x0.multiply(y1, MathContext.DECIMAL128).subtract(y0.multiply(x1, MathContext.DECIMAL128));\n\n                area = area.add(k, MathContext.DECIMAL128);\n                east = east.add(k.multiply(x0.add(x1, MathContext.DECIMAL128), MathContext.DECIMAL128));\n                north = north.add(k.multiply(y0.add(y1, MathContext.DECIMAL128), MathContext.DECIMAL128));\n            }\n        }\n\n        BigDecimal d = new BigDecimal(3, MathContext.DECIMAL128); // 1/2 * 6 = 3\n        area  = area.multiply(d, MathContext.DECIMAL128);\n        if (area.compareTo(BigDecimal.ZERO) != 0) {\n            north = north.divide(area, MathContext.DECIMAL128);\n            east = east.divide(area, MathContext.DECIMAL128);\n        }\n\n        return new EastNorth(east.doubleValue(), north.doubleValue());\n    }","commit_id":"03e8c4bb2c56580eda0f2adf7bebd6450e6f922f","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        Collection<OsmPrimitive> sel = Main.ds.getSelected();\n        Collection<Node> nodes = new LinkedList<Node>();\n        Collection<Way> ways = new LinkedList<Way>();\n        Node center = null;\n        double radius = 0;\n        boolean regular = false;\n\n        for (OsmPrimitive osm : sel) {\n            if (osm instanceof Node)\n                nodes.add((Node) osm);\n            else if (osm instanceof Way)\n                ways.add((Way) osm);\n        }\n\n        // special case if no single nodes are selected and exactly one way is:\n        // then use the way's nodes\n        if ((nodes.size() <= 2) && (ways.size() == 1)) {\n            Way way = (Way) ways.toArray()[0];\n\n            // some more special combinations:\n            // When is selected node that is part of the way, then make a regular polygon, selected\n            // node doesn't move.\n            // I haven't got better idea, how to activate that function.\n            //\n            // When one way and one node is selected, set center to position of that node.\n            // When one more node, part of the way, is selected, set the radius equal to the\n            // distance between two nodes.\n            if (nodes.size() > 0) {\n                if (nodes.size() == 1 && way.nodes.contains(nodes.toArray()[0])) {\n                    regular = true;\n                } else {\n\n                    center = (Node) nodes.toArray()[way.nodes.contains(nodes.toArray()[0]) ? 1 : 0];\n                    if (nodes.size() == 2)\n                        radius = distance(((Node) nodes.toArray()[0]).eastNorth, ((Node) nodes.toArray()[1]).eastNorth);\n                }\n                nodes = new LinkedList<Node>();\n            }\n\n            for (Node n : way.nodes) {\n                if (!nodes.contains(n))\n                    nodes.add(n);\n            }\n        }\n\n        if (nodes.size() < 4) {\n            JOptionPane.showMessageDialog(Main.parent, tr(\"Please select at least four nodes.\"));\n            return;\n        }\n\n        // Get average position of circumcircles of the triangles of all triplets of neighbour nodes\n        if (center == null) {\n            center = new Node(new LatLon(0, 0));\n            center.eastNorth = new EastNorth(0, 0); // to be independent of projection\n            Node n0 = (Node) nodes.toArray()[nodes.size() - 1];\n            Node n1 = (Node) nodes.toArray()[nodes.size() - 2];\n            Node n2;\n            for (Node n : nodes) {\n                n2 = n1;\n                n1 = n0;\n                n0 = n;\n                EastNorth cc = circumcenter(n0.eastNorth, n1.eastNorth, n2.eastNorth);\n                if (cc == null)\n                    return;\n                center.eastNorth = new EastNorth(center.eastNorth.east() + cc.east(), center.eastNorth.north()\n                        + cc.north());\n            }\n\n            center.eastNorth = new EastNorth(center.eastNorth.east() / nodes.size(), center.eastNorth.north()\n                    / nodes.size());\n            center.coor = Main.proj.eastNorth2latlon(center.eastNorth);\n        }\n\n        // Node \"center\" now is central to all selected nodes.\n\n        // Now calculate the average distance to each node from the\n        // centre. This method is ok as long as distances are short\n        // relative to the distance from the N or S poles.\n        if (radius == 0) {\n            for (Node n : nodes) {\n                radius += distance(center.eastNorth, n.eastNorth);\n            }\n            radius = radius / nodes.size();\n        }\n\n        Collection<Command> cmds = new LinkedList<Command>();\n\n        PolarCoor pc;\n\n        if (regular) { // Make a regular polygon\n            double angle = Math.PI * 2 / nodes.size();\n            pc = new PolarCoor(((Node) nodes.toArray()[0]).eastNorth, center.eastNorth, 0);\n\n            if (pc.angle > (new PolarCoor(((Node) nodes.toArray()[1]).eastNorth, center.eastNorth, 0).angle))\n                angle *= -1;\n\n            pc.radius = radius;\n            for (Node n : nodes) {\n                EastNorth no = pc.toEastNorth();\n                cmds.add(new MoveCommand(n, no.east() - n.eastNorth.east(), no.north() - n.eastNorth.north()));\n                pc.angle += angle;\n            }\n        } else { // Move each node to that distance from the centre.\n            for (Node n : nodes) {\n                pc = new PolarCoor(n.eastNorth, center.eastNorth, 0);\n                pc.radius = radius;\n                EastNorth no = pc.toEastNorth();\n                cmds.add(new MoveCommand(n, no.east() - n.eastNorth.east(), no.north() - n.eastNorth.north()));\n            }\n        }\n\n        Main.main.undoRedo.add(new SequenceCommand(tr(\"Align Nodes in Circle\"), cmds));\n        Main.map.repaint();\n    }","id":32548,"modified_method":"public void actionPerformed(ActionEvent e) {\n        Collection<OsmPrimitive> sel = Main.ds.getSelected();\n        Collection<Node> nodes = new LinkedList<Node>();\n        Collection<Way> ways = new LinkedList<Way>();\n        EastNorth center = null;\n        double radius = 0;\n        boolean regular = false;\n\n        for (OsmPrimitive osm : sel) {\n            if (osm instanceof Node)\n                nodes.add((Node) osm);\n            else if (osm instanceof Way)\n                ways.add((Way) osm);\n        }\n\n        // special case if no single nodes are selected and exactly one way is:\n        // then use the way's nodes\n        if ((nodes.size() <= 2) && (ways.size() == 1)) {\n            Way way = (Way) ways.toArray()[0];\n\n            // some more special combinations:\n            // When is selected node that is part of the way, then make a regular polygon, selected\n            // node doesn't move.\n            // I haven't got better idea, how to activate that function.\n            //\n            // When one way and one node is selected, set center to position of that node.\n            // When one more node, part of the way, is selected, set the radius equal to the\n            // distance between two nodes.\n            if (nodes.size() > 0) {\n                if (nodes.size() == 1 && way.nodes.contains(nodes.toArray()[0])) {\n                    regular = true;\n                } else {\n\n                    center = ((Node) nodes.toArray()[way.nodes.contains(nodes.toArray()[0]) ? 1 : 0]).eastNorth;\n                    if (nodes.size() == 2)\n                        radius = distance(((Node) nodes.toArray()[0]).eastNorth, ((Node) nodes.toArray()[1]).eastNorth);\n                }\n                nodes = new LinkedList<Node>();\n            }\n\n            for (Node n : way.nodes) {\n                if (!nodes.contains(n))\n                    nodes.add(n);\n            }\n        }\n\n        if (nodes.size() < 4) {\n            JOptionPane.showMessageDialog(Main.parent, tr(\"Please select at least four nodes.\"));\n            return;\n        }\n\n        // Get average position of circumcircles of the triangles of all triplets of neighbour nodes\n        if (center == null) {\n            center = new EastNorth(0, 0);\n            Node n0 = (Node) nodes.toArray()[nodes.size() - 1];\n            Node n1 = (Node) nodes.toArray()[nodes.size() - 2];\n            Node n2;\n            for (Node n : nodes) {\n                n2 = n1;\n                n1 = n0;\n                n0 = n;\n                EastNorth cc = circumcenter(n0.eastNorth, n1.eastNorth, n2.eastNorth);\n                if (cc == null)\n                    return;\n                center = new EastNorth(center.east() + cc.east(), center.north()\n                        + cc.north());\n            }\n\n            center = new EastNorth(center.east() / nodes.size(), center.north()\n                    / nodes.size());\n        }\n\n        // Node \"center\" now is central to all selected nodes.\n\n        // Now calculate the average distance to each node from the\n        // centre. This method is ok as long as distances are short\n        // relative to the distance from the N or S poles.\n        if (radius == 0) {\n            for (Node n : nodes) {\n                radius += distance(center, n.eastNorth);\n            }\n            radius = radius / nodes.size();\n        }\n\n        Collection<Command> cmds = new LinkedList<Command>();\n\n        PolarCoor pc;\n\n        if (regular) { // Make a regular polygon\n            double angle = Math.PI * 2 / nodes.size();\n            pc = new PolarCoor(((Node) nodes.toArray()[0]).eastNorth, center, 0);\n\n            if (pc.angle > (new PolarCoor(((Node) nodes.toArray()[1]).eastNorth, center, 0).angle))\n                angle *= -1;\n\n            pc.radius = radius;\n            for (Node n : nodes) {\n                EastNorth no = pc.toEastNorth();\n                cmds.add(new MoveCommand(n, no.east() - n.eastNorth.east(), no.north() - n.eastNorth.north()));\n                pc.angle += angle;\n            }\n        } else { // Move each node to that distance from the centre.\n            for (Node n : nodes) {\n                pc = new PolarCoor(n.eastNorth, center, 0);\n                pc.radius = radius;\n                EastNorth no = pc.toEastNorth();\n                cmds.add(new MoveCommand(n, no.east() - n.eastNorth.east(), no.north() - n.eastNorth.north()));\n            }\n        }\n\n        Main.main.undoRedo.add(new SequenceCommand(tr(\"Align Nodes in Circle\"), cmds));\n        Main.map.repaint();\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Adjusts the position of a node to lie on a segment (or a segment\n     * intersection).\n     *\n     * If one or more than two segments are passed, the node is adjusted\n     * to lie on the first segment that is passed.\n     *\n     * If two segments are passed, the node is adjusted to be at their\n     * intersection.\n     *\n     * No action is taken if no segments are passed.\n     *\n     * @param segs the segments to use as a reference when adjusting\n     * @param n the node to adjust\n     */\n    private static void adjustNode(Collection<Pair<Node,Node>> segs, Node n) {\n\n        switch (segs.size()) {\n        case 0:\n            return;\n        case 2:\n            // This computes the intersection between\n            // the two segments and adjusts the node position.\n            Iterator<Pair<Node,Node>> i = segs.iterator();\n            Pair<Node,Node> seg = i.next();\n            EastNorth A = seg.a.eastNorth;\n            EastNorth B = seg.b.eastNorth;\n            seg = i.next();\n            EastNorth C = seg.a.eastNorth;\n            EastNorth D = seg.b.eastNorth;\n\n            double u=det(B.east() - A.east(), B.north() - A.north(), C.east() - D.east(), C.north() - D.north());\n\n            // Check for parallel segments and do nothing if they are\n            // In practice this will probably only happen when a way has been duplicated\n\n            if (u == 0) return;\n\n            // q is a number between 0 and 1\n            // It is the point in the segment where the intersection occurs\n            // if the segment is scaled to lenght 1\n\n            double q = det(B.north() - C.north(), B.east() - C.east(), D.north() - C.north(), D.east() - C.east()) / u;\n            EastNorth intersection = new EastNorth(\n                    B.east() + q * (A.east() - B.east()),\n                    B.north() + q * (A.north() - B.north()));\n\n            int snapToIntersectionThreshold\n            = Main.pref.getInteger(\"edit.snap-intersection-threshold\",10);\n\n            // only adjust to intersection if within snapToIntersectionThreshold pixel of mouse click; otherwise\n            // fall through to default action.\n            // (for semi-parallel lines, intersection might be miles away!)\n            if (Main.map.mapView.getPoint(n.eastNorth).distance(Main.map.mapView.getPoint(intersection)) < snapToIntersectionThreshold) {\n                n.eastNorth = intersection;\n                return;\n            }\n\n        default:\n            EastNorth P = n.eastNorth;\n            seg = segs.iterator().next();\n            A = seg.a.eastNorth;\n            B = seg.b.eastNorth;\n            double a = P.distanceSq(B);\n            double b = P.distanceSq(A);\n            double c = A.distanceSq(B);\n            q = (a - b + c) / (2*c);\n            n.eastNorth = new EastNorth(\n                B.east() + q * (A.east() - B.east()),\n                B.north() + q * (A.north() - B.north()));\n        }\n    }","id":32549,"modified_method":"/**\n     * Adjusts the position of a node to lie on a segment (or a segment\n     * intersection).\n     *\n     * If one or more than two segments are passed, the node is adjusted\n     * to lie on the first segment that is passed.\n     *\n     * If two segments are passed, the node is adjusted to be at their\n     * intersection.\n     *\n     * No action is taken if no segments are passed.\n     *\n     * @param segs the segments to use as a reference when adjusting\n     * @param n the node to adjust\n     */\n    private static void adjustNode(Collection<Pair<Node,Node>> segs, Node n) {\n\n        switch (segs.size()) {\n        case 0:\n            return;\n        case 2:\n            // This computes the intersection between\n            // the two segments and adjusts the node position.\n            Iterator<Pair<Node,Node>> i = segs.iterator();\n            Pair<Node,Node> seg = i.next();\n            EastNorth A = seg.a.eastNorth;\n            EastNorth B = seg.b.eastNorth;\n            seg = i.next();\n            EastNorth C = seg.a.eastNorth;\n            EastNorth D = seg.b.eastNorth;\n\n            double u=det(B.east() - A.east(), B.north() - A.north(), C.east() - D.east(), C.north() - D.north());\n\n            // Check for parallel segments and do nothing if they are\n            // In practice this will probably only happen when a way has been duplicated\n\n            if (u == 0) return;\n\n            // q is a number between 0 and 1\n            // It is the point in the segment where the intersection occurs\n            // if the segment is scaled to lenght 1\n\n            double q = det(B.north() - C.north(), B.east() - C.east(), D.north() - C.north(), D.east() - C.east()) / u;\n            EastNorth intersection = new EastNorth(\n                    B.east() + q * (A.east() - B.east()),\n                    B.north() + q * (A.north() - B.north()));\n\n            int snapToIntersectionThreshold\n            = Main.pref.getInteger(\"edit.snap-intersection-threshold\",10);\n\n            // only adjust to intersection if within snapToIntersectionThreshold pixel of mouse click; otherwise\n            // fall through to default action.\n            // (for semi-parallel lines, intersection might be miles away!)\n            if (Main.map.mapView.getPoint(n.eastNorth).distance(Main.map.mapView.getPoint(intersection)) < snapToIntersectionThreshold) {\n                n.setEastNorth(intersection);\n                return;\n            }\n\n        default:\n            EastNorth P = n.eastNorth;\n            seg = segs.iterator().next();\n            A = seg.a.eastNorth;\n            B = seg.b.eastNorth;\n            double a = P.distanceSq(B);\n            double b = P.distanceSq(A);\n            double c = A.distanceSq(B);\n            q = (a - b + c) / (2*c);\n            n.setEastNorth(B.east() + q * (A.east() - B.east()), B.north() + q * (A.north() - B.north()));\n        }\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Move the same set of objects again by the specified vector. The vectors\n     * are added together and so the resulting will be moved to the previous\n     * vector plus this one.\n     *\n     * The move is immediately executed and any undo will undo both vectors to\n     * the original position the objects had before first moving.\n     */\n    public void moveAgain(double x, double y) {\n        for (Node n : objects) {\n            n.eastNorth = new EastNorth(n.eastNorth.east()+x, n.eastNorth.north()+y);\n            n.coor = Main.proj.eastNorth2latlon(n.eastNorth);\n        }\n        this.x += x;\n        this.y += y;\n    }","id":32550,"modified_method":"/**\n     * Move the same set of objects again by the specified vector. The vectors\n     * are added together and so the resulting will be moved to the previous\n     * vector plus this one.\n     *\n     * The move is immediately executed and any undo will undo both vectors to\n     * the original position the objects had before first moving.\n     */\n    public void moveAgain(double x, double y) {\n        for (Node n : objects) {\n            n.setEastNorth(n.eastNorth.add(x, y));\n        }\n        this.x += x;\n        this.y += y;\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public boolean executeCommand() {\n        for (Node n : objects) {\n            n.eastNorth = new EastNorth(n.eastNorth.east()+x, n.eastNorth.north()+y);\n            n.coor = Main.proj.eastNorth2latlon(n.eastNorth);\n            n.modified = true;\n        }\n        return true;\n    }","id":32551,"modified_method":"@Override public boolean executeCommand() {\n        for (Node n : objects) {\n            n.setEastNorth(n.eastNorth.add(x, y));\n            n.modified = true;\n        }\n        return true;\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void undoCommand() {\n        Iterator<OldState> it = oldState.iterator();\n        for (Node n : objects) {\n            OldState os = it.next();\n            n.eastNorth = os.eastNorth;\n            n.coor = os.latlon;\n            n.modified = os.modified;\n        }\n    }","id":32552,"modified_method":"@Override public void undoCommand() {\n        Iterator<OldState> it = oldState.iterator();\n        for (Node n : objects) {\n            OldState os = it.next();\n            n.setEastNorth(os.eastNorth);\n            n.modified = os.modified;\n        }\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Node(LatLon latlon) {\n        this.coor = latlon;\n        eastNorth = Main.proj.latlon2eastNorth(latlon);\n    }","id":32553,"modified_method":"public Node(LatLon latlon) {\n        setCoor(latlon);\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void pasteData(DataSet pasteBuffer, Layer source, ActionEvent e) {\n        /* Find the middle of the pasteBuffer area */\n        double maxEast = -1E100, minEast = 1E100, maxNorth = -1E100, minNorth = 1E100;\n        for (Node n : pasteBuffer.nodes) {\n            double east = n.eastNorth.east();\n            double north = n.eastNorth.north();\n            if (east > maxEast) { maxEast = east; }\n            if (east < minEast) { minEast = east; }\n            if (north > maxNorth) { maxNorth = north; }\n            if (north < minNorth) { minNorth = north; }\n        }\n\n        EastNorth mPosition;\n        if((e.getModifiers() & ActionEvent.CTRL_MASK) ==0){\n            /* adjust the coordinates to the middle of the visible map area */\n            mPosition = Main.map.mapView.getCenter();\n        } else {\n            mPosition = Main.map.mapView.getEastNorth(Main.map.mapView.lastMEvent.getX(), Main.map.mapView.lastMEvent.getY());\n        }\n\n        double offsetEast  = mPosition.east() - (maxEast + minEast)/2.0;\n        double offsetNorth = mPosition.north() - (maxNorth + minNorth)/2.0;\n\n        HashMap<OsmPrimitive,OsmPrimitive> map = new HashMap<OsmPrimitive,OsmPrimitive>();\n          /* temporarily maps old nodes to new so we can do a true deep copy */\n\n        /* do the deep copy of the paste buffer contents, leaving the pasteBuffer unchanged */\n        for (Node n : pasteBuffer.nodes) {\n            Node nnew = new Node(n);\n            nnew.id = 0;\n            if (Main.main.editLayer() == source) {\n                nnew.eastNorth = new EastNorth(nnew.eastNorth.east() + offsetEast, nnew.eastNorth.north() + offsetNorth);\n                nnew.coor = Main.proj.eastNorth2latlon(nnew.eastNorth);\n            }\n            map.put(n, nnew);\n        }\n        for (Way w : pasteBuffer.ways) {\n            Way wnew = new Way();\n            wnew.cloneFrom(w);\n            wnew.id = 0;\n            /* make sure we reference the new nodes corresponding to the old ones */\n            List<Node> nodes = new ArrayList<Node>();\n            for (Node n : w.nodes) {\n                nodes.add((Node)map.get(n));\n            }\n            wnew.nodes.clear();\n            wnew.nodes.addAll(nodes);\n            map.put(w, wnew);\n        }\n        for (Relation r : pasteBuffer.relations) {\n            Relation rnew = new Relation(r);\n            rnew.id = 0;\n            List<RelationMember> members = new ArrayList<RelationMember>();\n            for (RelationMember m : r.members) {\n                OsmPrimitive mo = map.get(m.member);\n                if(mo != null) /* TODO - This only prevents illegal data, but kills the relation */\n                {\n                    RelationMember mnew = new RelationMember(m);\n                    mnew.member = map.get(m.member);\n                    members.add(mnew);\n                }\n            }\n            rnew.members.clear();\n            rnew.members.addAll(members);\n            map.put(r, rnew);\n        }\n\n        /* Now execute the commands to add the dupicated contents of the paste buffer to the map */\n        Collection<OsmPrimitive> osms = map.values();\n        Collection<Command> clist = new LinkedList<Command>();\n        for (OsmPrimitive osm : osms) {\n            clist.add(new AddCommand(osm));\n        }\n\n        Main.main.undoRedo.add(new SequenceCommand(tr(\"Paste\"), clist));\n        Main.ds.setSelected(osms);\n        Main.map.mapView.repaint();\n    }","id":32554,"modified_method":"public static void pasteData(DataSet pasteBuffer, Layer source, ActionEvent e) {\n        /* Find the middle of the pasteBuffer area */\n        double maxEast = -1E100, minEast = 1E100, maxNorth = -1E100, minNorth = 1E100;\n        for (Node n : pasteBuffer.nodes) {\n            double east = n.eastNorth.east();\n            double north = n.eastNorth.north();\n            if (east > maxEast) { maxEast = east; }\n            if (east < minEast) { minEast = east; }\n            if (north > maxNorth) { maxNorth = north; }\n            if (north < minNorth) { minNorth = north; }\n        }\n\n        EastNorth mPosition;\n        if((e.getModifiers() & ActionEvent.CTRL_MASK) ==0){\n            /* adjust the coordinates to the middle of the visible map area */\n            mPosition = Main.map.mapView.getCenter();\n        } else {\n            mPosition = Main.map.mapView.getEastNorth(Main.map.mapView.lastMEvent.getX(), Main.map.mapView.lastMEvent.getY());\n        }\n\n        double offsetEast  = mPosition.east() - (maxEast + minEast)/2.0;\n        double offsetNorth = mPosition.north() - (maxNorth + minNorth)/2.0;\n\n        HashMap<OsmPrimitive,OsmPrimitive> map = new HashMap<OsmPrimitive,OsmPrimitive>();\n          /* temporarily maps old nodes to new so we can do a true deep copy */\n\n        /* do the deep copy of the paste buffer contents, leaving the pasteBuffer unchanged */\n        for (Node n : pasteBuffer.nodes) {\n            Node nnew = new Node(n);\n            nnew.id = 0;\n            if (Main.main.editLayer() == source) {\n                nnew.setEastNorth(nnew.eastNorth.add(offsetEast, offsetNorth));\n            }\n            map.put(n, nnew);\n        }\n        for (Way w : pasteBuffer.ways) {\n            Way wnew = new Way();\n            wnew.cloneFrom(w);\n            wnew.id = 0;\n            /* make sure we reference the new nodes corresponding to the old ones */\n            List<Node> nodes = new ArrayList<Node>();\n            for (Node n : w.nodes) {\n                nodes.add((Node)map.get(n));\n            }\n            wnew.nodes.clear();\n            wnew.nodes.addAll(nodes);\n            map.put(w, wnew);\n        }\n        for (Relation r : pasteBuffer.relations) {\n            Relation rnew = new Relation(r);\n            rnew.id = 0;\n            List<RelationMember> members = new ArrayList<RelationMember>();\n            for (RelationMember m : r.members) {\n                OsmPrimitive mo = map.get(m.member);\n                if(mo != null) /* TODO - This only prevents illegal data, but kills the relation */\n                {\n                    RelationMember mnew = new RelationMember(m);\n                    mnew.member = map.get(m.member);\n                    members.add(mnew);\n                }\n            }\n            rnew.members.clear();\n            rnew.members.addAll(members);\n            map.put(r, rnew);\n        }\n\n        /* Now execute the commands to add the dupicated contents of the paste buffer to the map */\n        Collection<OsmPrimitive> osms = map.values();\n        Collection<Command> clist = new LinkedList<Command>();\n        for (OsmPrimitive osm : osms) {\n            clist.add(new AddCommand(osm));\n        }\n\n        Main.main.undoRedo.add(new SequenceCommand(tr(\"Paste\"), clist));\n        Main.ds.setSelected(osms);\n        Main.map.mapView.repaint();\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void apply(OsmPrimitive target, OsmPrimitive other) {\n        if (target instanceof Node) {\n            ((Node)target).coor = ((Node)other).coor;\n            ((Node)target).eastNorth = ((Node)other).eastNorth;\n            int newversion = Math.max(target.version, other.version);\n            // set version on \"other\" as well in case user decides to keep local\n            target.version = newversion;\n            other.version = newversion;\n        }\n    }","id":32555,"modified_method":"@Override public void apply(OsmPrimitive target, OsmPrimitive other) {\n        if (target instanceof Node) {\n            ((Node)target).setEastNorth(((Node)other).eastNorth);\n            int newversion = Math.max(target.version, other.version);\n            // set version on \"other\" as well in case user decides to keep local\n            target.version = newversion;\n            other.version = newversion;\n        }\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void undoCommand() {\n        for (Node n : objects) {\n            MoveCommand.OldState os = oldState.get(n);\n            n.eastNorth = os.eastNorth;\n            n.coor = os.latlon;\n            n.modified = os.modified;\n        }\n    }","id":32556,"modified_method":"@Override public void undoCommand() {\n        for (Node n : objects) {\n            MoveCommand.OldState os = oldState.get(n);\n            n.setEastNorth(os.eastNorth);\n            n.modified = os.modified;\n        }\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates a RotateCommand.\n     * Assign the initial object set, compute pivot point and rotation angle.\n     * Computation of pivot point is done by the same rules that are used in\n     * the \"align nodes in circle\" action.\n     */\n    public RotateCommand(Collection<OsmPrimitive> objects, EastNorth start, EastNorth end) {\n\n        this.objects = AllNodesVisitor.getAllNodes(objects);\n        pivot = new Node(new LatLon(0,0));\n        pivot.eastNorth = new EastNorth(0,0);\n\n        for (Node n : this.objects) {\n            MoveCommand.OldState os = new MoveCommand.OldState();\n            os.eastNorth = n.eastNorth;\n            os.latlon = n.coor;\n            os.modified = n.modified;\n            oldState.put(n, os);\n            pivot.eastNorth = new EastNorth(pivot.eastNorth.east()+os.eastNorth.east(), pivot.eastNorth.north()+os.eastNorth.north());\n        }\n        pivot.eastNorth = new EastNorth(pivot.eastNorth.east()/this.objects.size(), pivot.eastNorth.north()/this.objects.size());\n        pivot.coor = Main.proj.eastNorth2latlon(pivot.eastNorth);\n\n        rotationAngle = Math.PI/2;\n        rotateAgain(start, end);\n    }","id":32557,"modified_method":"/**\n     * Creates a RotateCommand.\n     * Assign the initial object set, compute pivot point and rotation angle.\n     * Computation of pivot point is done by the same rules that are used in\n     * the \"align nodes in circle\" action.\n     */\n    public RotateCommand(Collection<OsmPrimitive> objects, EastNorth start, EastNorth end) {\n\n        this.objects = AllNodesVisitor.getAllNodes(objects);\n        pivot = new EastNorth(0,0);\n\n        for (Node n : this.objects) {\n            MoveCommand.OldState os = new MoveCommand.OldState();\n            os.eastNorth = n.eastNorth;\n            os.latlon = n.coor;\n            os.modified = n.modified;\n            oldState.put(n, os);\n            pivot = pivot.add(os.eastNorth.east(), os.eastNorth.north());\n        }\n        pivot = new EastNorth(pivot.east()/this.objects.size(), pivot.north()/this.objects.size());\n\n        rotationAngle = Math.PI/2;\n        rotateAgain(start, end);\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Rotate the same set of objects again, by the angle between given\n     * start and end nodes. Internally this is added to the existing\n     * rotation so a later undo will undo the whole rotation.\n     */\n    public void rotateAgain(EastNorth start, EastNorth end) {\n        // compute angle\n        startAngle = Math.atan2(start.east()-pivot.eastNorth.east(), start.north()-pivot.eastNorth.north());\n        double endAngle = Math.atan2(end.east()-pivot.eastNorth.east(), end.north()-pivot.eastNorth.north());\n        rotationAngle += startAngle - endAngle;\n        rotateNodes(false);\n    }","id":32558,"modified_method":"/**\n     * Rotate the same set of objects again, by the angle between given\n     * start and end nodes. Internally this is added to the existing\n     * rotation so a later undo will undo the whole rotation.\n     */\n    public void rotateAgain(EastNorth start, EastNorth end) {\n        // compute angle\n        startAngle = Math.atan2(start.east()-pivot.east(), start.north()-pivot.north());\n        double endAngle = Math.atan2(end.east()-pivot.east(), end.north()-pivot.north());\n        rotationAngle += startAngle - endAngle;\n        rotateNodes(false);\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Helper for actually rotationg the nodes.\n     * @param setModified - true if rotated nodes should be flagged \"modified\"\n     */\n    private void rotateNodes(boolean setModified) {\n        for (Node n : objects) {\n            double cosPhi = Math.cos(rotationAngle);\n            double sinPhi = Math.sin(rotationAngle);\n            EastNorth oldEastNorth = oldState.get(n).eastNorth;\n            double x = oldEastNorth.east() - pivot.eastNorth.east();\n            double y = oldEastNorth.north() - pivot.eastNorth.north();\n            double nx =  sinPhi * x + cosPhi * y + pivot.eastNorth.east();\n            double ny = -cosPhi * x + sinPhi * y + pivot.eastNorth.north();\n            n.eastNorth = new EastNorth(nx, ny);\n            n.coor = Main.proj.eastNorth2latlon(n.eastNorth);\n            if (setModified)\n                n.modified = true;\n        }\n    }","id":32559,"modified_method":"/**\n     * Helper for actually rotationg the nodes.\n     * @param setModified - true if rotated nodes should be flagged \"modified\"\n     */\n    private void rotateNodes(boolean setModified) {\n        for (Node n : objects) {\n            double cosPhi = Math.cos(rotationAngle);\n            double sinPhi = Math.sin(rotationAngle);\n            EastNorth oldEastNorth = oldState.get(n).eastNorth;\n            double x = oldEastNorth.east() - pivot.east();\n            double y = oldEastNorth.north() - pivot.north();\n            double nx =  sinPhi * x + cosPhi * y + pivot.east();\n            double ny = -cosPhi * x + sinPhi * y + pivot.north();\n            n.setEastNorth(nx, ny);\n            if (setModified)\n                n.modified = true;\n        }\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Assumes there is one tagged Node stored in selectedNode that it will try to unglue\n     * (= copy node and remove all tags from the old one. Relations will not be removed)\n     */\n    private void unglueNode(ActionEvent e) {\n        LinkedList<Command> cmds = new LinkedList<Command>();\n\n        Node c = new Node(selectedNode);\n        c.keys = null;\n        c.selected = false;\n        cmds.add(new ChangeCommand(selectedNode, c));\n        \n        Node n = new Node(selectedNode);\n        n.id = 0;\n        \n        // If this wasn't called from menu, place it where the cursor is/was\n        if(e.getSource() instanceof JPanel) {\n            MapView mv = Main.map.mapView;\n            n.eastNorth = mv.getEastNorth(mv.lastMEvent.getX(), mv.lastMEvent.getY());\n            n.coor = Main.proj.eastNorth2latlon(n.eastNorth);\n        }\n        \n        cmds.add(new AddCommand(n));\n        \n        fixRelations(selectedNode, cmds, Collections.singletonList(n));\n        \n        Main.main.undoRedo.add(new SequenceCommand(tr(\"Unglued Node\"), cmds));\n        Main.ds.setSelected(n);\n        Main.map.mapView.repaint();\n    }","id":32560,"modified_method":"/**\n     * Assumes there is one tagged Node stored in selectedNode that it will try to unglue\n     * (= copy node and remove all tags from the old one. Relations will not be removed)\n     */\n    private void unglueNode(ActionEvent e) {\n        LinkedList<Command> cmds = new LinkedList<Command>();\n\n        Node c = new Node(selectedNode);\n        c.keys = null;\n        c.selected = false;\n        cmds.add(new ChangeCommand(selectedNode, c));\n        \n        Node n = new Node(selectedNode);\n        n.id = 0;\n        \n        // If this wasn't called from menu, place it where the cursor is/was\n        if(e.getSource() instanceof JPanel) {\n            MapView mv = Main.map.mapView;\n            n.setEastNorth(mv.getEastNorth(mv.lastMEvent.getX(), mv.lastMEvent.getY()));\n        }\n        \n        cmds.add(new AddCommand(n));\n        \n        fixRelations(selectedNode, cmds, Collections.singletonList(n));\n        \n        Main.main.undoRedo.add(new SequenceCommand(tr(\"Unglued Node\"), cmds));\n        Main.ds.setSelected(n);\n        Main.map.mapView.repaint();\n    }","commit_id":"4ddb12fd47b92b6715512aedf0fc412f7a85d7fe","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void handleMessage(SoapMessage message) throws Fault {\n        try {\n            MessageFactory factory = null;\n            if (message.getVersion() instanceof Soap11) {\n                factory = MessageFactory.newInstance();\n            } else {\n                factory = MessageFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);\n            }\n            \n            SOAPMessage soapMessage = factory.createMessage();\n            message.setContent(SOAPMessage.class, soapMessage);\n            \n            SOAPPart part = soapMessage.getSOAPPart();\n            \n            Document node = (Document) message.getContent(Node.class);\n            DOMSource source = new DOMSource(node);\n            part.setContent(source);\n            \n            // TODO: setup mime headers\n            Collection<Attachment> atts = message.getAttachments();\n            if (atts != null) {\n                for (Attachment a : atts) {\n                    AttachmentPart ap = soapMessage.createAttachmentPart(a.getDataHandler());\n                    \n                    soapMessage.addAttachmentPart(ap);\n                }\n            }\n            \n            //replace header element if necessary\n            if (message.hasHeaders()) {\n                replaceHeaders(soapMessage, message);\n            }\n            if (soapMessage.getSOAPHeader() == null) {\n                soapMessage.getSOAPPart().getEnvelope().addHeader();\n            }\n            \n            XMLStreamReader xmlReader = message.getContent(XMLStreamReader.class);\n            StaxUtils.readDocElements(soapMessage.getSOAPBody(), xmlReader, true);\n            DOMSource bodySource = new DOMSource(soapMessage.getSOAPPart().getEnvelope().getBody());\n            xmlReader = StaxUtils.createXMLStreamReader(bodySource);\n            xmlReader.nextTag();\n            xmlReader.nextTag(); // move past body tag\n            message.setContent(XMLStreamReader.class, xmlReader);           \n        } catch (SOAPException soape) {\n            throw new SoapFault(new org.apache.cxf.common.i18n.Message(\n                    \"SOAPHANDLERINTERCEPTOR_EXCEPTION\", BUNDLE), soape,\n                    message.getVersion().getSender());\n        } catch (XMLStreamException e) {\n            throw new SoapFault(new org.apache.cxf.common.i18n.Message(\n                    \"SOAPHANDLERINTERCEPTOR_EXCEPTION\", BUNDLE), e, message\n                    .getVersion().getSender());\n        }\n    }","id":32561,"modified_method":"public void handleMessage(SoapMessage message) throws Fault {\n        try {\n            MessageFactory factory = null;\n            if (message.getVersion() instanceof Soap11) {\n                factory = MessageFactory.newInstance();\n            } else {\n                factory = MessageFactory.newInstance(SOAPConstants.SOAP_1_2_PROTOCOL);\n            }\n            \n            SOAPMessage soapMessage = factory.createMessage();\n            message.setContent(SOAPMessage.class, soapMessage);\n            \n            SOAPPart part = soapMessage.getSOAPPart();\n            \n            Document node = (Document) message.getContent(Node.class);\n            DOMSource source = new DOMSource(node);\n            part.setContent(source);\n            \n            // TODO: setup mime headers\n            Collection<Attachment> atts = message.getAttachments();\n            if (atts != null) {\n                for (Attachment a : atts) {\n                    AttachmentPart ap = soapMessage.createAttachmentPart(a.getDataHandler());\n                    \n                    soapMessage.addAttachmentPart(ap);\n                }\n            }\n            \n            //replace header element if necessary\n            if (message.hasHeaders()) {\n                replaceHeaders(soapMessage, message);\n            }\n            if (soapMessage.getSOAPHeader() == null) {\n                soapMessage.getSOAPPart().getEnvelope().addHeader();\n            }\n            \n            XMLStreamReader xmlReader = message.getContent(XMLStreamReader.class);\n\n            if (hasFault(message, xmlReader)) {\n                SOAPFault soapFault = \n                    soapMessage.getSOAPPart().getEnvelope().getBody().addFault();\n                SoapFault fault = \n                    message.getVersion() instanceof Soap11 \n                    ? Soap11FaultInInterceptor.unmarshalFault(message, xmlReader)\n                    : Soap12FaultInInterceptor.unmarshalFault(message, xmlReader);\n                if (fault.getFaultCode() != null) {\n                    soapFault.setFaultCode(fault.getFaultCode());\n                }\n                if (fault.getMessage() != null) {\n                    soapFault.setFaultString(fault.getMessage());\n                }\n                if (fault.getRole() != null) {\n                    soapFault.setFaultActor(fault.getRole());\n                }\n                if (fault.getDetail() != null) {\n                    soapFault.addDetail().appendChild(\n                        soapMessage.getSOAPPart().importNode(\n                            fault.getDetail().getFirstChild(), true));\n                }\n\n                DOMSource bodySource = new DOMSource(soapFault);\n                xmlReader = StaxUtils.createXMLStreamReader(bodySource);\n            } else { \n                StaxUtils.readDocElements(soapMessage.getSOAPBody(), xmlReader, true);\n                DOMSource bodySource = new DOMSource(soapMessage.getSOAPPart().getEnvelope().getBody());\n                xmlReader = StaxUtils.createXMLStreamReader(bodySource);\n                xmlReader.nextTag();\n                xmlReader.nextTag(); // move past body tag\n            }\n            message.setContent(XMLStreamReader.class, xmlReader);           \n        } catch (SOAPException soape) {\n            throw new SoapFault(new org.apache.cxf.common.i18n.Message(\n                    \"SOAPHANDLERINTERCEPTOR_EXCEPTION\", BUNDLE), soape,\n                    message.getVersion().getSender());\n        } catch (XMLStreamException e) {\n            throw new SoapFault(new org.apache.cxf.common.i18n.Message(\n                    \"SOAPHANDLERINTERCEPTOR_EXCEPTION\", BUNDLE), e, message\n                    .getVersion().getSender());\n        }\n    }","commit_id":"126c04f44bf757e6235f2f1e0951c344e241fafc","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(SoapMessage message) throws Fault {\n        String exMessage = null;\n        QName faultCode = null;\n        String role = null;\n        Element detail = null;\n\n        XMLStreamReader reader = message.getContent(XMLStreamReader.class);\n        \n        try {\n            while (reader.nextTag() == XMLStreamReader.START_ELEMENT) {\n                if (reader.getLocalName().equals(\"faultcode\")) {\n                    faultCode = StaxUtils.readQName(reader);\n                } else if (reader.getLocalName().equals(\"faultstring\")) {\n                    exMessage = reader.getElementText();\n                } else if (reader.getLocalName().equals(\"faultactor\")) {\n                    role = reader.getElementText();\n                } else if (reader.getLocalName().equals(\"detail\")) {\n                    //XMLStreamReader newReader = new DepthXMLStreamReader(reader);\n                    detail = StaxUtils.read(reader).getDocumentElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            throw new SoapFault(\"Could not parse message.\",\n                                e,\n                                message.getVersion().getSender());\n        }\n\n        SoapFault fault = new SoapFault(exMessage, faultCode);\n        fault.setDetail(detail);\n        fault.setRole(role);\n\n        message.setContent(Exception.class, fault);\n    }","id":32562,"modified_method":"public void handleMessage(SoapMessage message) throws Fault {\n        XMLStreamReader reader = message.getContent(XMLStreamReader.class);\n\n        message.setContent(Exception.class, unmarshalFault(message, reader));\n    }","commit_id":"126c04f44bf757e6235f2f1e0951c344e241fafc","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(SoapMessage message) throws Fault {\n        String exMessage = null;\n        QName faultCode = null;\n        QName subCode = null;\n        String role = null;\n        String node = null;\n        Element detail = null;\n\n        XMLStreamReader reader = message.getContent(XMLStreamReader.class);\n        Map<String, String> ns = new HashMap<String, String>();\n        ns.put(\"s\", Soap12.SOAP_NAMESPACE);\n        XPathUtils xu = new XPathUtils(ns);        \n        \n        try {\n            Document fault = StaxUtils.read(new FragmentStreamReader(reader));\n            Element el = (Element)xu.getValue(\"//s:Fault/s:Code/s:Value\", \n                                      fault, \n                                      XPathConstants.NODE);\n            if (el != null) {\n                faultCode = XMLUtils.getQName(el.getTextContent(), el);\n            }\n            \n            el = (Element)xu.getValue(\"//s:Fault/s:Code/s:Subcode/s:Value\", \n                                      fault, \n                                      XPathConstants.NODE);\n            if (el != null) {\n                subCode = XMLUtils.getQName(el.getTextContent(), el);\n            }\n            \n            exMessage = (String) xu.getValue(\"//s:Fault/s:Reason/s:Text/text()\", \n                                             fault,\n                                             XPathConstants.STRING);\n            \n            Node detailNode = (Node) xu.getValue(\"//s:Fault/s:Detail\",\n                                                 fault,\n                                                 XPathConstants.NODE);\n            if (detailNode != null) {\n                detail = (Element) detailNode;\n            }\n            \n            role = (String) xu.getValue(\"//s:Fault/s:Role/text()\", \n                                        fault,\n                                        XPathConstants.STRING);\n\n            node = (String) xu.getValue(\"//s:Fault/s:Node/text()\", \n                                        fault,\n                                        XPathConstants.STRING);                       \n        } catch (XMLStreamException e) {\n            throw new SoapFault(\"Could not parse message.\", \n                                message.getVersion().getSender());\n        }\n\n        SoapFault fault = new SoapFault(exMessage, faultCode);\n        fault.setSubCode(subCode);\n        fault.setDetail(detail);\n        fault.setRole(role);\n        fault.setNode(node);\n\n        message.setContent(Exception.class, fault);\n    }","id":32563,"modified_method":"public void handleMessage(SoapMessage message) throws Fault {\n        XMLStreamReader reader = message.getContent(XMLStreamReader.class);\n        message.setContent(Exception.class, unmarshalFault(message, reader));\n    }","commit_id":"126c04f44bf757e6235f2f1e0951c344e241fafc","url":"https://github.com/apache/cxf"},{"original_method":"public static String getLocalization(\n\t\tString xml, String requestedLanguageId, boolean useDefault) {\n\n\t\tString value = _getCachedValue(xml, requestedLanguageId, useDefault);\n\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\tvalue = StringPool.BLANK;\n\t\t}\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getDefault());\n\n\t\tString defaultValue = StringPool.BLANK;\n\n\t\tXMLStreamReader reader = null;\n\n\t\ttry {\n\t\t\tXMLInputFactory factory = XMLInputFactory.newInstance();\n\n\t\t\treader = factory.createXMLStreamReader(new StringReader(xml));\n\n\t\t\t// Skip root node\n\n\t\t\tif (reader.hasNext()) {\n\t\t\t\treader.nextTag();\n\t\t\t}\n\n\t\t\t// Find specified language and/or default language\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tint event = reader.next();\n\n\t\t\t\tif (event == XMLStreamConstants.START_ELEMENT) {\n\t\t\t\t\tString languageId = reader.getAttributeValue(\n\t\t\t\t\t\tnull, _LANGUAGE_ID);\n\n\t\t\t\t\tif (Validator.isNull(languageId)) {\n\t\t\t\t\t\tlanguageId = defaultLanguageId;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (languageId.equals(defaultLanguageId) ||\n\t\t\t\t\t\tlanguageId.equals(requestedLanguageId)) {\n\n\t\t\t\t\t\twhile (reader.hasNext()) {\n\t\t\t\t\t\t\tevent = reader.next();\n\n\t\t\t\t\t\t\tif (event == XMLStreamConstants.CHARACTERS ||\n\t\t\t\t\t\t\t\tevent == XMLStreamConstants.CDATA) {\n\n\t\t\t\t\t\t\t\tString text = reader.getText();\n\n\t\t\t\t\t\t\t\tif (languageId.equals(defaultLanguageId)) {\n\t\t\t\t\t\t\t\t\tdefaultValue = text;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (languageId.equals(requestedLanguageId)) {\n\t\t\t\t\t\t\t\t\tvalue = text;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (event == XMLStreamConstants.END_ELEMENT) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (event == XMLStreamConstants.END_DOCUMENT) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (useDefault && Validator.isNull(value)) {\n\t\t\t\tvalue = defaultValue;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (reader != null) {\n\t\t\t\ttry {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_setCachedValue(xml, requestedLanguageId, useDefault, value);\n\n\t\treturn value;\n\t}","id":32564,"modified_method":"public static String getLocalization(\n\t\tString xml, String requestedLanguageId, boolean useDefault) {\n\n\t\tString value = _getCachedValue(xml, requestedLanguageId, useDefault);\n\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\tvalue = StringPool.BLANK;\n\t\t}\n\n\t\tString systemDefaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getDefault());\n\n\t\tString defaultValue = StringPool.BLANK;\n\n\t\tXMLStreamReader reader = null;\n\n\t\ttry {\n\t\t\tXMLInputFactory factory = XMLInputFactory.newInstance();\n\n\t\t\treader = factory.createXMLStreamReader(new StringReader(xml));\n\n\t\t\tString defaultLanguageId = StringPool.BLANK;\n\n\t\t\t// Skip root node\n\n\t\t\tif (reader.hasNext()) {\n\t\t\t\treader.nextTag();\n\n\t\t\t\tdefaultLanguageId = reader.getAttributeValue(\n\t\t\t\t\tnull, _DEFAULT_LOCALE);\n\n\t\t\t\tif (Validator.isNull(defaultLanguageId)) {\n\t\t\t\t\tdefaultLanguageId = systemDefaultLanguageId;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Find specified language and/or default language\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tint event = reader.next();\n\n\t\t\t\tif (event == XMLStreamConstants.START_ELEMENT) {\n\t\t\t\t\tString languageId = reader.getAttributeValue(\n\t\t\t\t\t\tnull, _LANGUAGE_ID);\n\n\t\t\t\t\tif (Validator.isNull(languageId)) {\n\t\t\t\t\t\tlanguageId = defaultLanguageId;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (languageId.equals(defaultLanguageId) ||\n\t\t\t\t\t\tlanguageId.equals(requestedLanguageId)) {\n\n\t\t\t\t\t\twhile (reader.hasNext()) {\n\t\t\t\t\t\t\tevent = reader.next();\n\n\t\t\t\t\t\t\tif (event == XMLStreamConstants.CHARACTERS ||\n\t\t\t\t\t\t\t\tevent == XMLStreamConstants.CDATA) {\n\n\t\t\t\t\t\t\t\tString text = reader.getText();\n\n\t\t\t\t\t\t\t\tif (languageId.equals(defaultLanguageId)) {\n\t\t\t\t\t\t\t\t\tdefaultValue = text;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (languageId.equals(requestedLanguageId)) {\n\t\t\t\t\t\t\t\t\tvalue = text;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (event == XMLStreamConstants.END_ELEMENT) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (event == XMLStreamConstants.END_DOCUMENT) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (useDefault && Validator.isNull(value)) {\n\t\t\t\tvalue = defaultValue;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (reader != null) {\n\t\t\t\ttry {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_setCachedValue(xml, requestedLanguageId, useDefault, value);\n\n\t\treturn value;\n\t}","commit_id":"172d1b5a92f2f926196755f8d094b6b3563b0dad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        MuleEvent resultEvent = null;\n        try\n        {\n            connect();\n\n            String prop = (String) event.getMessage().getProperty(MuleProperties.MULE_DISABLE_TRANSPORT_TRANSFORMER_PROPERTY);\n            boolean disableTransportTransformer = (prop != null && Boolean.parseBoolean(prop)) || endpoint.isDisableTransportTransformer();\n                        \n            if (!disableTransportTransformer)\n            {\n                applyOutboundTransformers(event);            \n            }\n            if (endpoint.getExchangePattern().hasResponse())\n            {\n                MuleMessage resultMessage = doSend(event);\n                if (resultMessage != null)\n                {\n                    resultEvent = new DefaultMuleEvent(resultMessage, event);\n                    // TODO It seems like this should go here but it causes unwanted behaviour and breaks test cases.\n                    //if (!disableTransportTransformer)\n                    //{\n                    //    applyResponseTransformers(resultEvent);            \n                    //}\n                }\n            }\n            else\n            {\n                doDispatch(event);\n            }\n        }\n        catch (MuleException muleException)\n        {\n            throw muleException;\n        }\n        catch (Exception e)\n        {\n            throw new DispatchException(event, (OutboundEndpoint) endpoint, e);\n        }\n        return resultEvent;\n    }","id":32565,"modified_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        MuleEvent resultEvent = null;\n        try\n        {\n            connect();\n\n            String prop = event.getMessage().getOutboundProperty(MuleProperties.MULE_DISABLE_TRANSPORT_TRANSFORMER_PROPERTY);\n            boolean disableTransportTransformer = (prop != null && Boolean.parseBoolean(prop)) || endpoint.isDisableTransportTransformer();\n                        \n            if (!disableTransportTransformer)\n            {\n                applyOutboundTransformers(event);            \n            }\n            if (endpoint.getExchangePattern().hasResponse())\n            {\n                MuleMessage resultMessage = doSend(event);\n                if (resultMessage != null)\n                {\n                    resultEvent = new DefaultMuleEvent(resultMessage, event);\n                    // TODO It seems like this should go here but it causes unwanted behaviour and breaks test cases.\n                    //if (!disableTransportTransformer)\n                    //{\n                    //    applyResponseTransformers(resultEvent);            \n                    //}\n                }\n            }\n            else\n            {\n                doDispatch(event);\n            }\n        }\n        catch (MuleException muleException)\n        {\n            throw muleException;\n        }\n        catch (Exception e)\n        {\n            throw new DispatchException(event, (OutboundEndpoint) endpoint, e);\n        }\n        return resultEvent;\n    }","commit_id":"526b8281b2919e9d866babbc01b63686d7cd3ab4","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Object refineMethod(MuleEvent event, Call call, Object method)\n    {\n        if (method instanceof String)\n        {\n            // Set a custome method namespace if one is set. This will be used forthe\n            // parameters too\n            String methodNamespace = (String)event.getMessage().getProperty(SoapConstants.METHOD_NAMESPACE_PROPERTY);\n            if (methodNamespace != null)\n            {\n                call.setOperationName(new QName(methodNamespace, method.toString()));\n            }\n            else\n            {\n                call.setOperationName(new QName(method.toString()));\n            }\n        }\n        else if (method instanceof QName)\n        {\n            call.setOperationName((QName)method);\n            method = ((QName)method).getLocalPart();\n        }\n        else\n        {\n            call.setOperationName(((SoapMethod)method).getName());\n        }\n        return method;\n    }","id":32566,"modified_method":"protected Object refineMethod(MuleEvent event, Call call, Object method)\n    {\n        if (method instanceof String)\n        {\n            // Set a custome method namespace if one is set. This will be used forthe\n            // parameters too\n            String methodNamespace = event.getMessage().getOutboundProperty(SoapConstants.METHOD_NAMESPACE_PROPERTY);\n            if (methodNamespace != null)\n            {\n                call.setOperationName(new QName(methodNamespace, method.toString()));\n            }\n            else\n            {\n                call.setOperationName(new QName(method.toString()));\n            }\n        }\n        else if (method instanceof QName)\n        {\n            call.setOperationName((QName)method);\n            method = ((QName)method).getLocalPart();\n        }\n        else\n        {\n            call.setOperationName(((SoapMethod)method).getName());\n        }\n        return method;\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Object getInitialMethod(MuleEvent event) throws DispatchException\n    {\n        Object method = event.getMessage().getProperty(MuleProperties.MULE_METHOD_PROPERTY);\n        if (method == null)\n        {\n            method = event.getEndpoint().getEndpointURI().getParams().getProperty(MuleProperties.MULE_METHOD_PROPERTY);\n        }\n        if (method == null)\n        {\n            throw new DispatchException(\n                    SoapMessages.cannotInvokeCallWithoutOperation(), event.getMessage(),\n                    event.getEndpoint());\n        }\n        else if (method instanceof SoapMethod)\n        {\n            synchronized (this)\n            {\n                if (callParameters == null)\n                {\n                    callParameters = new HashMap();\n                }\n                callParameters.put(((SoapMethod)method).getName().getLocalPart(), method);\n            }\n        }\n        return method;\n    }","id":32567,"modified_method":"protected Object getInitialMethod(MuleEvent event) throws DispatchException\n    {\n        Object method = event.getMessage().getOutboundProperty(MuleProperties.MULE_METHOD_PROPERTY);\n        if (method == null)\n        {\n            method = event.getEndpoint().getEndpointURI().getParams().getProperty(MuleProperties.MULE_METHOD_PROPERTY);\n        }\n        if (method == null)\n        {\n            throw new DispatchException(\n                    SoapMessages.cannotInvokeCallWithoutOperation(), event.getMessage(),\n                    event.getEndpoint());\n        }\n        else if (method instanceof SoapMethod)\n        {\n            synchronized (this)\n            {\n                if (callParameters == null)\n                {\n                    callParameters = new HashMap();\n                }\n                callParameters.put(((SoapMethod)method).getName().getLocalPart(), method);\n            }\n        }\n        return method;\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void setSoapAction(MuleEvent event, EndpointURI endpointUri, Call call)\n    {\n        // Set custom soap action if set on the event or endpoint\n        String soapAction = (String)event.getMessage().getProperty(SoapConstants.SOAP_ACTION_PROPERTY);\n        if (soapAction != null)\n        {\n            soapAction = parseSoapAction(soapAction, call.getOperationName(), event);\n            call.setSOAPActionURI(soapAction);\n            call.setUseSOAPAction(Boolean.TRUE.booleanValue());\n        }\n        else\n        {\n            call.setSOAPActionURI(endpointUri.getAddress());\n        }\n    }","id":32568,"modified_method":"protected void setSoapAction(MuleEvent event, EndpointURI endpointUri, Call call)\n    {\n        // Set custom soap action if set on the event or endpoint\n        String soapAction = event.getMessage().getOutboundProperty(SoapConstants.SOAP_ACTION_PROPERTY);\n        if (soapAction != null)\n        {\n            soapAction = parseSoapAction(soapAction, call.getOperationName(), event);\n            call.setSOAPActionURI(soapAction);\n            call.setUseSOAPAction(true);\n        }\n        else\n        {\n            call.setSOAPActionURI(endpointUri.getAddress());\n        }\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void parseUse(MuleEvent event, Call call)\n    {\n        // Set use: Endcoded/Literal\n        String use = event.getMessage().getStringProperty(AxisConnector.USE, null);\n        if (use != null)\n        {\n            Use u = Use.getUse(use);\n            if (u == null)\n            {\n                throw new IllegalArgumentException(\n                        CoreMessages.valueIsInvalidFor(use, AxisConnector.USE).toString());\n            }\n            else\n            {\n                call.setOperationUse(u);\n            }\n        }\n    }","id":32569,"modified_method":"protected void parseUse(MuleEvent event, Call call)\n    {\n        // Set use: Endcoded/Literal\n        String use = event.getMessage().getOutboundProperty(AxisConnector.USE, null);\n        if (use != null)\n        {\n            Use u = Use.getUse(use);\n            if (u == null)\n            {\n                throw new IllegalArgumentException(\n                        CoreMessages.valueIsInvalidFor(use, AxisConnector.USE).toString());\n            }\n            else\n            {\n                call.setOperationUse(u);\n            }\n        }\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Call getCall(MuleEvent event, Object[] args) throws Exception\n    {\n        EndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        Object method = getInitialMethod(event); // changes object state\n        Call call = (Call) service.createCall();\n        parseStyle(event, call);\n        parseUse(event, call);\n\n        // set properties on the call from the endpoint properties\n        BeanUtils.populateWithoutFail(call, event.getEndpoint().getProperties(), false);\n        call.setTargetEndpointAddress(endpointUri.getAddress());\n\n        method = refineMethod(event, call, method);\n        String methodNamespace = call.getOperationName().getNamespaceURI();\n\n        // set Mule event here so that handlers can extract info\n        call.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n        call.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint());\n        call.setProperty(MuleProperties.MULE_CONTEXT_PROPERTY, connector.getMuleContext());\n\n        setCustomProperties(event, call);\n        call.setTimeout(new Integer(event.getTimeout()));\n        setUserCredentials(endpointUri, call);\n\n        Map methodCalls = (Map)event.getMessage().getProperty(AxisConnector.SOAP_METHODS);\n        if (methodCalls == null && !(method instanceof SoapMethod))\n        {\n            buildSoapMethods(event, call, method, methodNamespace, args);\n        }\n\n        setCallParams(call, event, call.getOperationName());\n        setSoapAction(event, endpointUri, call);\n        addAttachments(event, call);\n        return call;\n    }","id":32570,"modified_method":"protected Call getCall(MuleEvent event, Object[] args) throws Exception\n    {\n        EndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        Object method = getInitialMethod(event); // changes object state\n        Call call = (Call) service.createCall();\n        parseStyle(event, call);\n        parseUse(event, call);\n\n        // set properties on the call from the endpoint properties\n        BeanUtils.populateWithoutFail(call, event.getEndpoint().getProperties(), false);\n        call.setTargetEndpointAddress(endpointUri.getAddress());\n\n        method = refineMethod(event, call, method);\n        String methodNamespace = call.getOperationName().getNamespaceURI();\n\n        // set Mule event here so that handlers can extract info\n        call.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n        call.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint());\n        call.setProperty(MuleProperties.MULE_CONTEXT_PROPERTY, connector.getMuleContext());\n\n        setCustomProperties(event, call);\n        call.setTimeout(new Integer(event.getTimeout()));\n        setUserCredentials(endpointUri, call);\n\n        Map methodCalls = event.getMessage().getOutboundProperty(AxisConnector.SOAP_METHODS);\n        if (methodCalls == null && !(method instanceof SoapMethod))\n        {\n            buildSoapMethods(event, call, method, methodNamespace, args);\n        }\n\n        setCallParams(call, event, call.getOperationName());\n        setSoapAction(event, endpointUri, call);\n        addAttachments(event, call);\n        return call;\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void parseStyle(MuleEvent event, Call call)\n    {\n        // Note that Axis has specific rules to how these two variables are\n        // combined. This is handled for us\n        // Set style: RPC/wrapped/Doc/Message\n        String style = event.getMessage().getStringProperty(AxisConnector.STYLE, null);\n        if (style != null)\n        {\n            Style s = Style.getStyle(style);\n            if (s == null)\n            {\n                throw new IllegalArgumentException(\n                        CoreMessages.valueIsInvalidFor(style, AxisConnector.STYLE).toString());\n            }\n            else\n            {\n                call.setOperationStyle(s);\n            }\n        }\n    }","id":32571,"modified_method":"protected void parseStyle(MuleEvent event, Call call)\n    {\n        // Note that Axis has specific rules to how these two variables are\n        // combined. This is handled for us\n        // Set style: RPC/wrapped/Doc/Message\n        String style = event.getMessage().getOutboundProperty(AxisConnector.STYLE, null);\n        if (style != null)\n        {\n            Style s = Style.getStyle(style);\n            if (s == null)\n            {\n                throw new IllegalArgumentException(\n                        CoreMessages.valueIsInvalidFor(style, AxisConnector.STYLE).toString());\n            }\n            else\n            {\n                call.setOperationStyle(s);\n            }\n        }\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"private void loadCallParams(MuleEvent event, String namespace) throws ClassNotFoundException\n    {\n        Map methodCalls = (Map)event.getMessage().getProperty(AxisConnector.SOAP_METHODS);\n        if (methodCalls == null)\n        {\n            return;\n        }\n\n        Map.Entry entry;\n        SoapMethod soapMethod;\n        callParameters = new HashMap();\n\n        for (Iterator iterator = methodCalls.entrySet().iterator(); iterator.hasNext();)\n        {\n            entry = (Map.Entry)iterator.next();\n            if (StringUtils.isEmpty(namespace))\n            {\n                if (entry.getValue() instanceof List)\n                {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), (List)entry.getValue());\n                }\n                else\n                {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), entry.getValue().toString());\n                }\n            }\n            else\n            {\n                if (entry.getValue() instanceof List)\n                {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()),\n                        (List)entry.getValue());\n                }\n                else\n                {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()),\n                        entry.getValue().toString());\n                }\n            }\n            callParameters.put(soapMethod.getName().getLocalPart(), soapMethod);\n        }\n    }","id":32572,"modified_method":"private void loadCallParams(MuleEvent event, String namespace) throws ClassNotFoundException\n    {\n        Map methodCalls = event.getMessage().getOutboundProperty(AxisConnector.SOAP_METHODS);\n        if (methodCalls == null)\n        {\n            return;\n        }\n\n        Map.Entry entry;\n        SoapMethod soapMethod;\n        callParameters = new HashMap();\n\n        for (Iterator iterator = methodCalls.entrySet().iterator(); iterator.hasNext();)\n        {\n            entry = (Map.Entry)iterator.next();\n            if (StringUtils.isEmpty(namespace))\n            {\n                if (entry.getValue() instanceof List)\n                {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), (List)entry.getValue());\n                }\n                else\n                {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), entry.getValue().toString());\n                }\n            }\n            else\n            {\n                if (entry.getValue() instanceof List)\n                {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()),\n                        (List)entry.getValue());\n                }\n                else\n                {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()),\n                        entry.getValue().toString());\n                }\n            }\n            callParameters.put(soapMethod.getName().getLocalPart(), soapMethod);\n        }\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void buildSoapMethods(MuleEvent event, Call call, Object method, String methodNamespace, Object[] args)\n    {\n        List params = new ArrayList();\n        for (int i = 0; i < args.length; i++)\n        {\n            if (args[i] == null)\n            {\n                QName qname = call.getTypeMapping().getTypeQName(Object.class);\n                params.add(\"value\" + i + \";qname{\" + qname.getPrefix() + \":\" + qname.getLocalPart() + \":\"\n                        + qname.getNamespaceURI() + \"};in\");\n            }\n            else if (args[i] instanceof DataHandler[])\n            {\n                params.add(\"attachments;qname{DataHandler:http://xml.apache.org/xml-soap};in\");\n                // Convert key/value pairs into the parameters\n            }\n            else if (args[i] instanceof Map && connector.isTreatMapAsNamedParams())\n            {\n                for (Iterator iterator = ((Map)args[i]).entrySet().iterator(); iterator.hasNext();)\n                {\n                    Map.Entry entry = (Map.Entry)iterator.next();\n                    if (call.getTypeMapping().getTypeQName(entry.getValue().getClass()) != null)\n                    {\n                        QName type = call.getTypeMapping().getTypeQName(entry.getValue().getClass());\n                        params.add(\"qname{\" + entry.getKey().toString()\n                                + (methodNamespace == null ? \"\" : \":\" + methodNamespace) + \"};qname{\"\n                                + type.getPrefix() + \":\" + type.getLocalPart() + \":\"\n                                + type.getNamespaceURI() + \"};in\");\n                    }\n                    else\n                    {\n                        params.add(\"value\" + i + \";qname{\"\n                                + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\"\n                                + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                        params.add(\"qname{\" + entry.getKey().toString()\n                                + (methodNamespace == null ? \"\" : \":\" + methodNamespace) + \"};qname{\"\n                                + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\"\n                                + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                    }\n\n                }\n            }\n            else if (call.getTypeMapping().getTypeQName(args[i].getClass()) != null)\n            {\n                QName qname = call.getTypeMapping().getTypeQName(args[i].getClass());\n                params.add(\"value\" + i + \";qname{\" + qname.getPrefix() + \":\" + qname.getLocalPart() + \":\"\n                        + qname.getNamespaceURI() + \"};in\");\n            }\n            else\n            {\n                params.add(\"value\" + i + \";qname{\"\n                        + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\"\n                        + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n            }\n        }\n\n        HashMap map = new HashMap();\n        map.put(method, params);\n        event.getMessage().setProperty(AxisConnector.SOAP_METHODS, map);\n    }","id":32573,"modified_method":"protected void buildSoapMethods(MuleEvent event, Call call, Object method, String methodNamespace, Object[] args)\n    {\n        List params = new ArrayList();\n        for (int i = 0; i < args.length; i++)\n        {\n            if (args[i] == null)\n            {\n                QName qname = call.getTypeMapping().getTypeQName(Object.class);\n                params.add(String.format(\"value%d;qname{%s:%s:%s};in\",\n                                         i, qname.getPrefix(), qname.getLocalPart(), qname.getNamespaceURI()));\n            }\n            else if (args[i] instanceof DataHandler[])\n            {\n                params.add(\"attachments;qname{DataHandler:http://xml.apache.org/xml-soap};in\");\n                // Convert key/value pairs into the parameters\n            }\n            else if (args[i] instanceof Map && connector.isTreatMapAsNamedParams())\n            {\n                for (Iterator iterator = ((Map)args[i]).entrySet().iterator(); iterator.hasNext();)\n                {\n                    Map.Entry entry = (Map.Entry)iterator.next();\n                    if (call.getTypeMapping().getTypeQName(entry.getValue().getClass()) != null)\n                    {\n                        QName type = call.getTypeMapping().getTypeQName(entry.getValue().getClass());\n                        params.add(String.format(\"qname{%s%s};qname{%s:%s:%s};in\",\n                                                 entry.getKey().toString(),\n                                                 (methodNamespace == null ? \"\" : \":\" + methodNamespace),\n                                                 type.getPrefix(), type.getLocalPart(), type.getNamespaceURI()));\n                    }\n                    else\n                    {\n                        params.add(String.format(\"value%d;qname{%s:%s};in\",\n                                                 i, Types.getLocalNameFromFullName(args[i].getClass().getName()),\n                                                 Namespaces.makeNamespace(args[i].getClass().getName())));\n                        params.add(String.format(\"qname{%s%s};qname{%s:%s};in\",\n                                                 entry.getKey().toString(),\n                                                 (methodNamespace == null ? \"\" : \":\" + methodNamespace),\n                                                 Types.getLocalNameFromFullName(args[i].getClass().getName()),\n                                                 Namespaces.makeNamespace(args[i].getClass().getName())));\n                    }\n\n                }\n            }\n            else if (call.getTypeMapping().getTypeQName(args[i].getClass()) != null)\n            {\n                QName qname = call.getTypeMapping().getTypeQName(args[i].getClass());\n                params.add(String.format(\"value%d;qname{%s:%s:%s};in\",\n                                         i, qname.getPrefix(), qname.getLocalPart(), qname.getNamespaceURI()));\n            }\n            else\n            {\n                params.add(String.format(\"value%d;qname{%s:%s};in\",\n                                         i, Types.getLocalNameFromFullName(args[i].getClass().getName()),\n                                         Namespaces.makeNamespace(args[i].getClass().getName())));\n            }\n        }\n\n        HashMap map = new HashMap();\n        map.put(method, params);\n        event.getMessage().setOutboundProperty(AxisConnector.SOAP_METHODS, map);\n    }","commit_id":"d01f4918905b895fc16181524ba3b93d247c5277","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void processReplyTo(MuleEvent event,\n                                  MuleEvent result,\n                                  ReplyToHandler replyToHandler,\n                                  Object replyTo) throws MuleException\n    {\n        if (result != null && replyToHandler != null)\n        {\n            String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n            if ((requestor != null && !requestor.equals(event.getFlowConstruct().getName())) || requestor == null)\n            {\n                replyToHandler.processReplyTo(event, result.getMessage(), replyTo);\n            }\n        }\n    }","id":32574,"modified_method":"protected void processReplyTo(MuleEvent event,\n                                  MuleEvent result,\n                                  ReplyToHandler replyToHandler,\n                                  Object replyTo) throws MuleException\n    {\n        if (result != null && replyToHandler != null)\n        {\n            String requestor = result.getMessage().getOutboundProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n            if ((requestor != null && !requestor.equals(event.getFlowConstruct().getName())) || requestor == null)\n            {\n                replyToHandler.processReplyTo(event, result.getMessage(), replyTo);\n            }\n        }\n    }","commit_id":"2c65f59e39b5897c0392488e8898f579b6e5f7a8","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * @deprecated\n     */\n    @Deprecated\n    public Object getProperty(String name, Object defaultValue)\n    {\n        Object property = message.getOutboundProperty(name);\n\n        if (property == null)\n        {\n            property = session.getProperty(name);\n        }\n\n        return (property == null ? defaultValue : property);\n    }","id":32575,"modified_method":"/**\n     * @see #getMessage()\n     * @deprecated use appropriate scope-aware calls on the MuleMessage (via event.getMessage())\n     */\n    @Deprecated\n    public Object getProperty(String name, Object defaultValue)\n    {\n        throw new UnsupportedOperationException(\"Method's behavior has changed in Mule 3, use \" +\n                                                \"event.getMessage() and suitable scope-aware property access \" +\n                                                \"methods on it\");\n    }","commit_id":"2c65f59e39b5897c0392488e8898f579b6e5f7a8","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * @see org.mule.api.MuleEvent#getProperty(java.lang.String)\n     * @deprecated\n     */\n    @Deprecated\n    public Object getProperty(String name)\n    {\n        return getProperty(name, /* defaultValue */null);\n    }","id":32576,"modified_method":"/**\n     * @see #getMessage()\n     * @deprecated use appropriate scope-aware calls on the MuleMessage (via event.getMessage())\n     */\n    @Deprecated\n    public Object getProperty(String name)\n    {\n        throw new UnsupportedOperationException(\"Method's behavior has changed in Mule 3, use \" +\n                                                \"event.getMessage() and suitable scope-aware property access \" +\n                                                \"methods on it\");\n    }","commit_id":"2c65f59e39b5897c0392488e8898f579b6e5f7a8","url":"https://github.com/mulesoft/mule"},{"original_method":"@Nullable\n  String getPropertyDescription(@NotNull final PsiElement element, @Nullable final String name) {\n    final RegExpLanguageHost host = findRegExpHost(element);\n    return host == null ? null : host.getPropertyDescription(name);\n  }","id":32577,"modified_method":"@Nullable\n  String getPropertyDescription(@NotNull final PsiElement element, @Nullable final String name) {\n    final RegExpLanguageHost host = findRegExpHost(element);\n    return host != null ?  host.getPropertyDescription(name) : myDefaultProvider.getPropertyDescription(name);\n  }","commit_id":"725e07f576fb41ed72f5f66f18f92731d86ec4a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean supportsPossessiveQuantifiers(@Nullable final RegExpQuantifier quantifier) {\n    final RegExpLanguageHost host = findRegExpHost(quantifier);\n    return host != null && host.supportsPossessiveQuantifiers();\n  }","id":32578,"modified_method":"public boolean supportsPossessiveQuantifiers(@Nullable final RegExpQuantifier quantifier) {\n    final RegExpLanguageHost host = findRegExpHost(quantifier);\n    return host == null || host.supportsPossessiveQuantifiers();\n  }","commit_id":"725e07f576fb41ed72f5f66f18f92731d86ec4a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isValidCategory(@NotNull final PsiElement element, @NotNull String category) {\n    final RegExpLanguageHost host = findRegExpHost(element);\n    if (host == null) {\n      return false;\n    }\n    return host.isValidCategory(category);\n  }","id":32579,"modified_method":"public boolean isValidCategory(@NotNull final PsiElement element, @NotNull String category) {\n    final RegExpLanguageHost host = findRegExpHost(element);\n    return host != null ? host.isValidCategory(category) : myDefaultProvider.isValidCategory(category);\n  }","commit_id":"725e07f576fb41ed72f5f66f18f92731d86ec4a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String[][] getAllKnownProperties(@NotNull final PsiElement element) {\n    final RegExpLanguageHost host = findRegExpHost(element);\n    if (host != null) {\n      return host.getAllKnownProperties();\n    }\n    return myDefaultProvider.getAllKnownProperties();\n  }","id":32580,"modified_method":"@NotNull\n  public String[][] getAllKnownProperties(@NotNull final PsiElement element) {\n    final RegExpLanguageHost host = findRegExpHost(element);\n    return host != null ? host.getAllKnownProperties() : myDefaultProvider.getAllKnownProperties();\n  }","commit_id":"725e07f576fb41ed72f5f66f18f92731d86ec4a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n        public Object[] getVariants() {\n            final ASTNode categoryNode = getCategoryNode();\n            if (categoryNode != null && categoryNode.getText().startsWith(\"In\") && !categoryNode.getText().startsWith(\"Intelli\")) {\n                return UNICODE_BLOCKS;\n            } else {\n              final String[][] knownProperties = RegExpLanguageHosts.getInstance().getAllKnownProperties(getElement());\n              final Object[] objects = new Object[knownProperties.length];\n                for (int i = 0; i < objects.length; i++) {\n                    final String[] prop = knownProperties[i];\n                    objects[i] = new MyLookupValue(prop);\n\n                }\n                return objects;\n            }\n        }","id":32581,"modified_method":"@NotNull\n    public Object[] getVariants() {\n      final ASTNode categoryNode = getCategoryNode();\n      if (categoryNode != null && categoryNode.getText().startsWith(\"In\") && !categoryNode.getText().startsWith(\"Intelli\")) {\n        return UNICODE_BLOCKS;\n      }\n      else {\n        boolean startsWithIs = categoryNode != null && categoryNode.getText().startsWith(\"Is\");\n        Collection<LookupElement> result = ContainerUtil.newArrayList();\n        for (String[] properties : RegExpLanguageHosts.getInstance().getAllKnownProperties(getElement())) {\n          String name = ArrayUtil.getFirstElement(properties);\n          if (name != null) {\n            String typeText = properties.length > 1 ? properties[1] : (\"Character.is\" + name.substring(\"java\".length()) + \"()\");\n            result.add(PrioritizedLookupElement.withPriority(LookupElementBuilder.create(name)\n                                                               .withPresentableText(startsWithIs ? \"Is\" + name : name)\n                                                               .withIcon(PlatformIcons.PROPERTY_ICON)\n                                                               .withTypeText(typeText), getPriority(name)));\n          }\n        }\n        return ArrayUtil.toObjectArray(result);\n      }\n    }","commit_id":"1ba222e929e54d0f9729c330ff21cddb290ba99f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void connectToNode(DiscoveryNode node, boolean light) {\n        if (!lifecycle.started()) {\n            throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n        }\n        if (node == null) {\n            throw new ConnectTransportException(null, \"can't connect to a null node\");\n        }\n        globalLock.readLock().lock();\n        try {\n            if (!lifecycle.started()) {\n                throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n            }\n            synchronized (connectLock(node.id())) {\n                if (!lifecycle.started()) {\n                    throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n                }\n                try {\n                    NodeChannels nodeChannels = connectedNodes.get(node);\n                    if (nodeChannels != null) {\n                        return;\n                    }\n\n                    if (light) {\n                        nodeChannels = connectToChannelsLight(node);\n                    } else {\n                        nodeChannels = new NodeChannels(new Channel[connectionsPerNodeLow], new Channel[connectionsPerNodeMed], new Channel[connectionsPerNodeHigh], new Channel[connectionsPerNodePing]);\n                        try {\n                            connectToChannels(nodeChannels, node);\n                        } catch (Exception e) {\n                            nodeChannels.close();\n                            throw e;\n                        }\n                    }\n\n                    NodeChannels existing = connectedNodes.putIfAbsent(node, nodeChannels);\n                    if (existing != null) {\n                        // we are already connected to a node, close this ones\n                        nodeChannels.close();\n                    } else {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"connected to node [{}]\", node);\n                        }\n                        transportServiceAdapter.raiseNodeConnected(node);\n                    }\n\n                } catch (ConnectTransportException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new ConnectTransportException(node, \"General node connection failure\", e);\n                }\n            }\n        } finally {\n            globalLock.readLock().unlock();\n        }\n    }","id":32582,"modified_method":"public void connectToNode(DiscoveryNode node, boolean light) {\n        if (!lifecycle.started()) {\n            throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n        }\n        if (node == null) {\n            throw new ConnectTransportException(null, \"can't connect to a null node\");\n        }\n        globalLock.readLock().lock();\n        try {\n            if (!lifecycle.started()) {\n                throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n            }\n            NodeChannels nodeChannels = connectedNodes.get(node);\n            if (nodeChannels != null) {\n                return;\n            } \n            connectionLock.acquire(node.id());\n            try {\n                if (!lifecycle.started()) {\n                    throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n                }\n                try {\n\n\n                    if (light) {\n                        nodeChannels = connectToChannelsLight(node);\n                    } else {\n                        nodeChannels = new NodeChannels(new Channel[connectionsPerNodeLow], new Channel[connectionsPerNodeMed], new Channel[connectionsPerNodeHigh], new Channel[connectionsPerNodePing]);\n                        try {\n                            connectToChannels(nodeChannels, node);\n                        } catch (Exception e) {\n                            nodeChannels.close();\n                            throw e;\n                        }\n                    }\n\n                    NodeChannels existing = connectedNodes.putIfAbsent(node, nodeChannels);\n                    if (existing != null) {\n                        // we are already connected to a node, close this ones\n                        nodeChannels.close();\n                    } else {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"connected to node [{}]\", node);\n                        }\n                        transportServiceAdapter.raiseNodeConnected(node);\n                    }\n\n                } catch (ConnectTransportException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new ConnectTransportException(node, \"General node connection failure\", e);\n                }\n            } finally {\n                connectionLock.release(node.id());\n            }\n        } finally {\n            globalLock.readLock().unlock();\n        }\n    }","commit_id":"8203d4dbcf8e61a79b72d5e9ac86bda0ff447e77","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Disconnects from a node, only if the relevant channel is found to be part of the node channels.\n     */\n    private void disconnectFromNode(DiscoveryNode node, Channel channel, String reason) {\n        synchronized (connectLock(node.id())) {\n            NodeChannels nodeChannels = connectedNodes.get(node);\n            if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n                connectedNodes.remove(node);\n                try {\n                    nodeChannels.close();\n                } finally {\n                    logger.debug(\"disconnected from [{}], {}\", node, reason);\n                    transportServiceAdapter.raiseNodeDisconnected(node);\n                }\n            }\n        }\n    }","id":32583,"modified_method":"/**\n     * Disconnects from a node, only if the relevant channel is found to be part of the node channels.\n     */\n    private void disconnectFromNode(DiscoveryNode node, Channel channel, String reason) {\n        NodeChannels nodeChannels = connectedNodes.get(node);\n        if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n            connectionLock.acquire(node.id());\n            if (!nodeChannels.hasChannel(channel)){ //might have been removed in the meanwhile, safety check\n                assert !connectedNodes.containsKey(node);\n            } else {\n                try {\n                    connectedNodes.remove(node);\n                    try {\n                        nodeChannels.close();\n                    } finally {\n                        logger.debug(\"disconnected from [{}], {}\", node, reason);\n                        transportServiceAdapter.raiseNodeDisconnected(node);\n                    }\n                } finally {\n                    connectionLock.release(node.id());\n                }\n            }\n        }\n    }","commit_id":"8203d4dbcf8e61a79b72d5e9ac86bda0ff447e77","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public NettyTransport(Settings settings, ThreadPool threadPool, NetworkService networkService, Version version) {\n        super(settings);\n        this.threadPool = threadPool;\n        this.networkService = networkService;\n        this.version = version;\n\n        if (settings.getAsBoolean(\"netty.epollBugWorkaround\", false)) {\n            System.setProperty(\"org.jboss.netty.epollBugWorkaround\", \"true\");\n        }\n\n        this.connectMutex = new Object[500];\n        for (int i = 0; i < connectMutex.length; i++) {\n            connectMutex[i] = new Object();\n        }\n\n        this.workerCount = componentSettings.getAsInt(\"worker_count\", EsExecutors.boundedNumberOfProcessors() * 2);\n        this.bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n        this.blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", settings.getAsBoolean(TCP_BLOCKING_SERVER, settings.getAsBoolean(TCP_BLOCKING, false)));\n        this.blockingClient = settings.getAsBoolean(\"transport.tcp.blocking_client\", settings.getAsBoolean(TCP_BLOCKING_CLIENT, settings.getAsBoolean(TCP_BLOCKING, false)));\n        this.port = componentSettings.get(\"port\", settings.get(\"transport.tcp.port\", \"9300-9400\"));\n        this.bindHost = componentSettings.get(\"bind_host\", settings.get(\"transport.bind_host\", settings.get(\"transport.host\")));\n        this.publishHost = componentSettings.get(\"publish_host\", settings.get(\"transport.publish_host\", settings.get(\"transport.host\")));\n        this.compress = settings.getAsBoolean(\"transport.tcp.compress\", false);\n        this.connectTimeout = componentSettings.getAsTime(\"connect_timeout\", settings.getAsTime(\"transport.tcp.connect_timeout\", settings.getAsTime(TCP_CONNECT_TIMEOUT, TCP_DEFAULT_CONNECT_TIMEOUT)));\n        this.tcpNoDelay = componentSettings.getAsBoolean(\"tcp_no_delay\", settings.getAsBoolean(TCP_NO_DELAY, true));\n        this.tcpKeepAlive = componentSettings.getAsBoolean(\"tcp_keep_alive\", settings.getAsBoolean(TCP_KEEP_ALIVE, true));\n        this.reuseAddress = componentSettings.getAsBoolean(\"reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        this.tcpSendBufferSize = componentSettings.getAsBytesSize(\"tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        this.tcpReceiveBufferSize = componentSettings.getAsBytesSize(\"tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        this.connectionsPerNodeLow = componentSettings.getAsInt(\"connections_per_node.low\", settings.getAsInt(\"transport.connections_per_node.low\", 2));\n        this.connectionsPerNodeMed = componentSettings.getAsInt(\"connections_per_node.med\", settings.getAsInt(\"transport.connections_per_node.med\", 6));\n        this.connectionsPerNodeHigh = componentSettings.getAsInt(\"connections_per_node.high\", settings.getAsInt(\"transport.connections_per_node.high\", 1));\n        this.connectionsPerNodePing = componentSettings.getAsInt(\"connections_per_node.ping\", settings.getAsInt(\"transport.connections_per_node.ping\", 1));\n\n        this.maxCumulationBufferCapacity = componentSettings.getAsBytesSize(\"max_cumulation_buffer_capacity\", null);\n        this.maxCompositeBufferComponents = componentSettings.getAsInt(\"max_composite_buffer_components\", -1);\n\n        long defaultReceiverPredictor = 512 * 1024;\n        if (JvmInfo.jvmInfo().mem().directMemoryMax().bytes() > 0) {\n            // we can guess a better default...\n            long l = (long) ((0.3 * JvmInfo.jvmInfo().mem().directMemoryMax().bytes()) / workerCount);\n            defaultReceiverPredictor = Math.min(defaultReceiverPredictor, Math.max(l, 64 * 1024));\n        }\n\n        // See AdaptiveReceiveBufferSizePredictor#DEFAULT_XXX for default values in netty..., we can use higher ones for us, even fixed one\n        ByteSizeValue receivePredictorMin = componentSettings.getAsBytesSize(\"receive_predictor_min\", componentSettings.getAsBytesSize(\"receive_predictor_size\", new ByteSizeValue(defaultReceiverPredictor)));\n        ByteSizeValue receivePredictorMax = componentSettings.getAsBytesSize(\"receive_predictor_max\", componentSettings.getAsBytesSize(\"receive_predictor_size\", new ByteSizeValue(defaultReceiverPredictor)));\n        if (receivePredictorMax.bytes() == receivePredictorMin.bytes()) {\n            receiveBufferSizePredictorFactory = new FixedReceiveBufferSizePredictorFactory((int) receivePredictorMax.bytes());\n        } else {\n            receiveBufferSizePredictorFactory = new AdaptiveReceiveBufferSizePredictorFactory((int) receivePredictorMin.bytes(), (int) receivePredictorMin.bytes(), (int) receivePredictorMax.bytes());\n        }\n\n        logger.debug(\"using worker_count[{}], port[{}], bind_host[{}], publish_host[{}], compress[{}], connect_timeout[{}], connections_per_node[{}/{}/{}/{}], receive_predictor[{}->{}]\",\n                workerCount, port, bindHost, publishHost, compress, connectTimeout, connectionsPerNodeLow, connectionsPerNodeMed, connectionsPerNodeHigh, connectionsPerNodePing, receivePredictorMin, receivePredictorMax);\n    }","id":32584,"modified_method":"@Inject\n    public NettyTransport(Settings settings, ThreadPool threadPool, NetworkService networkService, Version version) {\n        super(settings);\n        this.threadPool = threadPool;\n        this.networkService = networkService;\n        this.version = version;\n\n        if (settings.getAsBoolean(\"netty.epollBugWorkaround\", false)) {\n            System.setProperty(\"org.jboss.netty.epollBugWorkaround\", \"true\");\n        }\n\n        this.workerCount = componentSettings.getAsInt(\"worker_count\", EsExecutors.boundedNumberOfProcessors() * 2);\n        this.bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n        this.blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", settings.getAsBoolean(TCP_BLOCKING_SERVER, settings.getAsBoolean(TCP_BLOCKING, false)));\n        this.blockingClient = settings.getAsBoolean(\"transport.tcp.blocking_client\", settings.getAsBoolean(TCP_BLOCKING_CLIENT, settings.getAsBoolean(TCP_BLOCKING, false)));\n        this.port = componentSettings.get(\"port\", settings.get(\"transport.tcp.port\", \"9300-9400\"));\n        this.bindHost = componentSettings.get(\"bind_host\", settings.get(\"transport.bind_host\", settings.get(\"transport.host\")));\n        this.publishHost = componentSettings.get(\"publish_host\", settings.get(\"transport.publish_host\", settings.get(\"transport.host\")));\n        this.compress = settings.getAsBoolean(\"transport.tcp.compress\", false);\n        this.connectTimeout = componentSettings.getAsTime(\"connect_timeout\", settings.getAsTime(\"transport.tcp.connect_timeout\", settings.getAsTime(TCP_CONNECT_TIMEOUT, TCP_DEFAULT_CONNECT_TIMEOUT)));\n        this.tcpNoDelay = componentSettings.getAsBoolean(\"tcp_no_delay\", settings.getAsBoolean(TCP_NO_DELAY, true));\n        this.tcpKeepAlive = componentSettings.getAsBoolean(\"tcp_keep_alive\", settings.getAsBoolean(TCP_KEEP_ALIVE, true));\n        this.reuseAddress = componentSettings.getAsBoolean(\"reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        this.tcpSendBufferSize = componentSettings.getAsBytesSize(\"tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        this.tcpReceiveBufferSize = componentSettings.getAsBytesSize(\"tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        this.connectionsPerNodeLow = componentSettings.getAsInt(\"connections_per_node.low\", settings.getAsInt(\"transport.connections_per_node.low\", 2));\n        this.connectionsPerNodeMed = componentSettings.getAsInt(\"connections_per_node.med\", settings.getAsInt(\"transport.connections_per_node.med\", 6));\n        this.connectionsPerNodeHigh = componentSettings.getAsInt(\"connections_per_node.high\", settings.getAsInt(\"transport.connections_per_node.high\", 1));\n        this.connectionsPerNodePing = componentSettings.getAsInt(\"connections_per_node.ping\", settings.getAsInt(\"transport.connections_per_node.ping\", 1));\n\n        this.maxCumulationBufferCapacity = componentSettings.getAsBytesSize(\"max_cumulation_buffer_capacity\", null);\n        this.maxCompositeBufferComponents = componentSettings.getAsInt(\"max_composite_buffer_components\", -1);\n\n        long defaultReceiverPredictor = 512 * 1024;\n        if (JvmInfo.jvmInfo().mem().directMemoryMax().bytes() > 0) {\n            // we can guess a better default...\n            long l = (long) ((0.3 * JvmInfo.jvmInfo().mem().directMemoryMax().bytes()) / workerCount);\n            defaultReceiverPredictor = Math.min(defaultReceiverPredictor, Math.max(l, 64 * 1024));\n        }\n\n        // See AdaptiveReceiveBufferSizePredictor#DEFAULT_XXX for default values in netty..., we can use higher ones for us, even fixed one\n        ByteSizeValue receivePredictorMin = componentSettings.getAsBytesSize(\"receive_predictor_min\", componentSettings.getAsBytesSize(\"receive_predictor_size\", new ByteSizeValue(defaultReceiverPredictor)));\n        ByteSizeValue receivePredictorMax = componentSettings.getAsBytesSize(\"receive_predictor_max\", componentSettings.getAsBytesSize(\"receive_predictor_size\", new ByteSizeValue(defaultReceiverPredictor)));\n        if (receivePredictorMax.bytes() == receivePredictorMin.bytes()) {\n            receiveBufferSizePredictorFactory = new FixedReceiveBufferSizePredictorFactory((int) receivePredictorMax.bytes());\n        } else {\n            receiveBufferSizePredictorFactory = new AdaptiveReceiveBufferSizePredictorFactory((int) receivePredictorMin.bytes(), (int) receivePredictorMin.bytes(), (int) receivePredictorMax.bytes());\n        }\n\n        logger.debug(\"using worker_count[{}], port[{}], bind_host[{}], publish_host[{}], compress[{}], connect_timeout[{}], connections_per_node[{}/{}/{}/{}], receive_predictor[{}->{}]\",\n                workerCount, port, bindHost, publishHost, compress, connectTimeout, connectionsPerNodeLow, connectionsPerNodeMed, connectionsPerNodeHigh, connectionsPerNodePing, receivePredictorMin, receivePredictorMax);\n    }","commit_id":"8203d4dbcf8e61a79b72d5e9ac86bda0ff447e77","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Disconnects from a node if a channel is found as part of that nodes channels.\n     */\n    private void disconnectFromNodeChannel(Channel channel, Throwable failure) {\n        for (DiscoveryNode node : connectedNodes.keySet()) {\n            synchronized (connectLock(node.id())) {\n                NodeChannels nodeChannels = connectedNodes.get(node);\n                if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n                    connectedNodes.remove(node);\n                    try {\n                        nodeChannels.close();\n                    } finally {\n                        logger.debug(\"disconnected from [{}] on channel failure\", failure, node);\n                        transportServiceAdapter.raiseNodeDisconnected(node);\n                    }\n                }\n            }\n        }\n    }","id":32585,"modified_method":"/**\n     * Disconnects from a node if a channel is found as part of that nodes channels.\n     */\n    private void disconnectFromNodeChannel(Channel channel, Throwable failure) {\n        for (DiscoveryNode node : connectedNodes.keySet()) {\n            NodeChannels nodeChannels = connectedNodes.get(node);\n            if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n                connectionLock.acquire(node.id());\n                if (!nodeChannels.hasChannel(channel)) { //might have been removed in the meanwhile, safety check\n                    assert !connectedNodes.containsKey(node);\n                } else {\n                    try {\n                        connectedNodes.remove(node);\n                        try {\n                            nodeChannels.close();\n                        } finally {\n                            logger.debug(\"disconnected from [{}] on channel failure\", failure, node);\n                            transportServiceAdapter.raiseNodeDisconnected(node);\n                        }\n                    } finally {\n                        connectionLock.release(node.id());\n                    }\n                }\n            }\n        }\n    }","commit_id":"8203d4dbcf8e61a79b72d5e9ac86bda0ff447e77","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void disconnectFromNode(DiscoveryNode node) {\n        synchronized (connectLock(node.id())) {\n            NodeChannels nodeChannels = connectedNodes.remove(node);\n            if (nodeChannels != null) {\n                try {\n                    nodeChannels.close();\n                } finally {\n                    logger.debug(\"disconnected from [{}]\", node);\n                    transportServiceAdapter.raiseNodeDisconnected(node);\n                }\n            }\n        }\n    }","id":32586,"modified_method":"@Override\n    public void disconnectFromNode(DiscoveryNode node) {\n        NodeChannels nodeChannels = connectedNodes.remove(node);\n        if (nodeChannels != null) {\n            connectionLock.acquire(node.id());\n            try {\n                    try {\n                        nodeChannels.close();\n                    } finally {\n                        logger.debug(\"disconnected from [{}]\", node);\n                        transportServiceAdapter.raiseNodeDisconnected(node);\n                    }\n            } finally {\n                connectionLock.release(node.id());\n            }\n        }\n    }","commit_id":"8203d4dbcf8e61a79b72d5e9ac86bda0ff447e77","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public MoltenPsycheWatcher(final MoltenPsycheWatcher watcher) {\n        super(watcher);\n        for (Entry<UUID, Integer> entry : watcher.draws.entrySet()) {\n            draws.put(entry.getKey(), entry.getValue());\n        }\n    }","id":32587,"modified_method":"public MoltenPsycheWatcher(final MoltenPsycheWatcher watcher) {\n        super(watcher);\n        this.draws.putAll(watcher.draws);\n    }","commit_id":"7de86944930db66bffb2e2a8d13b85b3a90e8243","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            Map<UUID, Integer> cardsToDraw = new LinkedHashMap<>();\n            for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {\n                Player player = game.getPlayer(playerId);\n                if (player != null) {\n                    int cardsInHand = player.getHand().size();\n                    if (cardsInHand > 0) {\n                        cardsToDraw.put(playerId, cardsInHand);\n                    }\n                    player.moveCards(player.getHand(), Zone.HAND, Zone.LIBRARY, source, game);\n                    player.shuffleLibrary(source, game);\n                }\n            }\n\n            game.applyEffects(); // so effects from creatures that were on the battlefield won't trigger from draw action\n\n            for (UUID playerId : cardsToDraw.keySet()) {\n                Player player = game.getPlayer(playerId);\n                if (player != null) {\n                    player.drawCards(cardsToDraw.get(playerId), game);\n                    if (MetalcraftCondition.getInstance().apply(game, source) && !playerId.equals(source.getControllerId())) {\n                        MoltenPsycheWatcher watcher = (MoltenPsycheWatcher) game.getState().getWatchers().get(\"CardsDrawn\");\n                        player.damage(watcher.getDraws(playerId), source.getSourceId(), game, false, true);\n                    }\n                }\n            }\n            if (MetalcraftCondition.getInstance().apply(game, source)) {\n                MoltenPsycheWatcher watcher = (MoltenPsycheWatcher) game.getState().getWatchers().get(\"CardsDrawn\");\n                for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {\n                    Player player = game.getPlayer(playerId);\n                    if (player != null) {\n                        player.damage(watcher.getDraws(playerId), source.getSourceId(), game, false, true);\n                    }\n                }\n            }\n            return true;\n        }\n\n        return false;\n    }","id":32588,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            Map<UUID, Integer> cardsToDraw = new LinkedHashMap<>();\n            for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {\n                Player player = game.getPlayer(playerId);\n                if (player != null) {\n                    int cardsInHand = player.getHand().size();\n                    if (cardsInHand > 0) {\n                        cardsToDraw.put(playerId, cardsInHand);\n                    }\n                    player.moveCards(player.getHand(), Zone.LIBRARY, source, game);\n                    player.shuffleLibrary(source, game);\n                }\n            }\n\n            game.applyEffects(); // so effects from creatures that were on the battlefield won't trigger from draw action\n\n            for (UUID playerId : cardsToDraw.keySet()) {\n                Player player = game.getPlayer(playerId);\n                if (player != null) {\n                    player.drawCards(cardsToDraw.get(playerId), game);\n                    if (MetalcraftCondition.getInstance().apply(game, source) && !playerId.equals(source.getControllerId())) {\n                        MoltenPsycheWatcher watcher = (MoltenPsycheWatcher) game.getState().getWatchers().get(\"CardsDrawn\");\n                        player.damage(watcher.getDraws(playerId), source.getSourceId(), game, false, true);\n                    }\n                }\n            }\n            if (MetalcraftCondition.getInstance().apply(game, source)) {\n                MoltenPsycheWatcher watcher = (MoltenPsycheWatcher) game.getState().getWatchers().get(\"CardsDrawn\");\n                for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {\n                    if (game.isOpponent(controller, playerId)) {\n                        Player player = game.getPlayer(playerId);\n                        if (player != null) {\n                            player.damage(watcher.getDraws(playerId), source.getSourceId(), game, false, true);\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n\n        return false;\n    }","commit_id":"7de86944930db66bffb2e2a8d13b85b3a90e8243","url":"https://github.com/magefree/mage"},{"original_method":"public static void main(String[] args) throws ResolutionException\n    {\n        Resolver resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG));\n\n        Map<Resource, Wiring> wirings = new HashMap<Resource, Wiring>();\n        Map<Requirement, List<Capability>> candMap = new HashMap<Requirement, List<Capability>>();\n\n        System.out.println(\"\\nSCENARIO 1\\n\");\n        List<Resource> mandatory = populateScenario1(wirings, candMap);\n        ResolveContextImpl rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        Map<Resource, List<Wire>> wireMap = resolver.resolve(rci);\n        System.out.println(\"RESULT \" + wireMap);\n\n        System.out.println(\"\\nSCENARIO 2\\n\");\n        mandatory = populateScenario2(wirings, candMap);\n        rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        wireMap = resolver.resolve(rci);\n        System.out.println(\"RESULT \" + wireMap);\n\n        System.out.println(\"\\nSCENARIO 3\\n\");\n        mandatory = populateScenario3(wirings, candMap);\n        rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        wireMap = resolver.resolve(rci);\n        System.out.println(\"RESULT \" + wireMap);\n    }","id":32589,"modified_method":"public static void main(String[] args) throws ResolutionException\n    {\n        Resolver resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG));\n\n        Map<Resource, Wiring> wirings = new HashMap<Resource, Wiring>();\n        Map<Requirement, List<Capability>> candMap = new HashMap<Requirement, List<Capability>>();\n\n        System.out.println(\"\\nSCENARIO 1\\n\");\n        List<Resource> mandatory = populateScenario1(wirings, candMap);\n        ResolveContextImpl rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        Map<Resource, List<Wire>> wireMap = resolver.resolve(rci);\n        System.out.println(\"RESULT \" + wireMap);\n\n        System.out.println(\"\\nSCENARIO 2\\n\");\n        mandatory = populateScenario2(wirings, candMap);\n        rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        wireMap = resolver.resolve(rci);\n        System.out.println(\"RESULT \" + wireMap);\n\n        System.out.println(\"\\nSCENARIO 3\\n\");\n        mandatory = populateScenario3(wirings, candMap);\n        rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        wireMap = resolver.resolve(rci);\n        System.out.println(\"RESULT \" + wireMap);\n\n        System.out.println(\"\\nSCENARIO 4\\n\");\n        mandatory = populateScenario4(wirings, candMap);\n        rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        try\n        {\n            wireMap = resolver.resolve(rci);\n            System.err.println(\"UNEXPECTED RESULT \" + wireMap);\n        }\n        catch (ResolutionException e)\n        {\n            System.out.println(\"EXPECTED ResolutionException:\");\n            e.printStackTrace(System.out);\n        }\n\n        System.out.println(\"\\nSCENARIO 5\\n\");\n        mandatory = populateScenario5(wirings, candMap);\n        rci = new ResolveContextImpl(wirings, candMap, mandatory, Collections.EMPTY_LIST);\n        try\n        {\n            wireMap = resolver.resolve(rci);\n            System.err.println(\"UNEXPECTED RESULT \" + wireMap);\n        }\n        catch (ResolutionException e)\n        {\n            System.out.println(\"EXPECTED ResolutionException:\");\n            e.printStackTrace(System.out);\n        }\n    }","commit_id":"eed39899f4681840b072df48b52d3340cb7c7c1b","url":"https://github.com/apache/felix"},{"original_method":"public Map<Resource, List<Wire>> resolve(ResolveContext rc) throws ResolutionException\n    {\n        Map<Resource, List<Wire>> wireMap =\n            new HashMap<Resource, List<Wire>>();\n        Map<Resource, Packages> resourcePkgMap =\n            new HashMap<Resource, Packages>();\n\n        // Make copies of arguments in case we want to modify them.\n        Collection<Resource> mandatoryResources = new ArrayList(rc.getMandatoryResources());\n        Collection<Resource> optionalResources = new ArrayList(rc.getOptionalResources());\n// TODO: RFC-112 - Need impl-specific type.\n//        Collection<Resource> ondemandFragments = (rc instanceof ResolveContextImpl)\n//            ? ((ResolveContextImpl) rc).getOndemandResources() : Collections.EMPTY_LIST;\n        Collection<Resource> ondemandFragments =  Collections.EMPTY_LIST;\n\n        boolean retry;\n        do\n        {\n            retry = false;\n\n            try\n            {\n                // Create object to hold all candidates.\n                Candidates allCandidates = new Candidates();\n\n                // Populate mandatory resources; since these are mandatory\n                // resources, failure throws a resolve exception.\n                for (Iterator<Resource> it = mandatoryResources.iterator();\n                    it.hasNext(); )\n                {\n                    Resource resource = it.next();\n                    if (Util.isFragment(resource) || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.MANDATORY);\n                    }\n                    else\n                    {\n                        it.remove();\n                    }\n                }\n\n                // Populate optional resources; since these are optional\n                // resources, failure does not throw a resolve exception.\n                for (Resource resource : optionalResources)\n                {\n                    boolean isFragment = Util.isFragment(resource);\n                    if (isFragment || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.OPTIONAL);\n                    }\n                }\n\n                // Populate ondemand fragments; since these are optional\n                // resources, failure does not throw a resolve exception.\n                for (Resource resource : ondemandFragments)\n                {\n                    boolean isFragment = Util.isFragment(resource);\n                    if (isFragment)\n                    {\n                        allCandidates.populate(rc, resource, Candidates.ON_DEMAND);\n                    }\n                }\n\n                // Merge any fragments into hosts.\n                allCandidates.prepare(rc);\n\n                // Create a combined list of populated resources; for\n                // optional resources. We do not need to consider ondemand\n                // fragments, since they will only be pulled in if their\n                // host is already present.\n                Set<Resource> allResources =\n                    new HashSet<Resource>(mandatoryResources);\n                for (Resource resource : optionalResources)\n                {\n                    if (allCandidates.isPopulated(resource))\n                    {\n                        allResources.add(resource);\n                    }\n                }\n\n                // Record the initial candidate permutation.\n                m_usesPermutations.add(allCandidates);\n\n                ResolutionException rethrow = null;\n\n                // If a populated resource is a fragment, then its host\n                // must ultimately be verified, so store its host requirement\n                // to use for package space calculation.\n                Map<Resource, List<Requirement>> hostReqs =\n                    new HashMap<Resource, List<Requirement>>();\n                for (Resource resource : allResources)\n                {\n                    if (Util.isFragment(resource))\n                    {\n                        hostReqs.put(\n                            resource,\n                            resource.getRequirements(HostNamespace.HOST_NAMESPACE));\n                    }\n                }\n\n                do\n                {\n                    rethrow = null;\n\n                    resourcePkgMap.clear();\n                    m_packageSourcesCache.clear();\n\n                    allCandidates = (m_usesPermutations.size() > 0)\n                        ? m_usesPermutations.remove(0)\n                        : m_importPermutations.remove(0);\n//allCandidates.dump();\n\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then get its\n                        // host candidate and verify it instead.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getCandidates(hostReq.get(0))\n                                .iterator().next().getResource();\n                        }\n\n                        calculatePackageSpaces(\n                            rc, allCandidates.getWrappedHost(target), allCandidates,\n                            resourcePkgMap, new HashMap(), new HashSet());\n//System.out.println(\"+++ PACKAGE SPACES START +++\");\n//dumpResourcePkgMap(resourcePkgMap);\n//System.out.println(\"+++ PACKAGE SPACES END +++\");\n\n                        try\n                        {\n                            checkPackageSpaceConsistency(\n                                rc, allCandidates.getWrappedHost(target),\n                                allCandidates, resourcePkgMap, new HashMap());\n                        }\n                        catch (ResolutionException ex)\n                        {\n                            rethrow = ex;\n                        }\n                    }\n                }\n                while ((rethrow != null)\n                    && ((m_usesPermutations.size() > 0) || (m_importPermutations.size() > 0)));\n\n                // If there is a resolve exception, then determine if an\n                // optionally resolved resource is to blame (typically a fragment).\n                // If so, then remove the optionally resolved resolved and try\n                // again; otherwise, rethrow the resolve exception.\n                if (rethrow != null)\n                {\n                    Collection<Requirement> exReqs = rethrow.getUnresolvedRequirements();\n                    Requirement faultyReq = ((exReqs == null) || (exReqs.isEmpty()))\n                        ? null : exReqs.iterator().next();\n                    Resource faultyResource = (faultyReq == null)\n                        ? null : getDeclaredResource(faultyReq.getResource());\n                    // If the faulty requirement is wrapped, then it may\n                    // be from a fragment, so consider the fragment faulty\n                    // instead of the host.\n                    if (faultyReq instanceof WrappedRequirement)\n                    {\n                        faultyResource =\n                            ((WrappedRequirement) faultyReq)\n                                .getDeclaredRequirement().getResource();\n                    }\n                    // Try to ignore the faulty resource if it is not mandatory.\n                    if (optionalResources.remove(faultyResource))\n                    {\n                        retry = true;\n                    }\n                    else if (ondemandFragments.remove(faultyResource))\n                    {\n                        retry = true;\n                    }\n                    else\n                    {\n                        throw rethrow;\n                    }\n                }\n                // If there is no exception to rethrow, then this was a clean\n                // resolve, so populate the wire map.\n                else\n                {\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then we\n                        // actually want to populate its host's wires.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getCandidates(hostReq.get(0))\n                                .iterator().next().getResource();\n                        }\n\n                        if (allCandidates.isPopulated(target))\n                        {\n                            wireMap =\n                                populateWireMap(\n                                    rc, allCandidates.getWrappedHost(target),\n                                    resourcePkgMap, wireMap, allCandidates);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // Always clear the state.\n                m_usesPermutations.clear();\n                m_importPermutations.clear();\n            }\n        }\n        while (retry);\n\n        return wireMap;\n    }","id":32590,"modified_method":"public Map<Resource, List<Wire>> resolve(ResolveContext rc) throws ResolutionException\n    {\n        Map<Resource, List<Wire>> wireMap =\n            new HashMap<Resource, List<Wire>>();\n        Map<Resource, Packages> resourcePkgMap =\n            new HashMap<Resource, Packages>();\n\n        // Make copies of arguments in case we want to modify them.\n        Collection<Resource> mandatoryResources = new ArrayList(rc.getMandatoryResources());\n        Collection<Resource> optionalResources = new ArrayList(rc.getOptionalResources());\n// TODO: RFC-112 - Need impl-specific type.\n//        Collection<Resource> ondemandFragments = (rc instanceof ResolveContextImpl)\n//            ? ((ResolveContextImpl) rc).getOndemandResources() : Collections.EMPTY_LIST;\n        Collection<Resource> ondemandFragments =  Collections.EMPTY_LIST;\n\n        boolean retry;\n        do\n        {\n            retry = false;\n\n            try\n            {\n                // Create object to hold all candidates.\n                Candidates allCandidates = new Candidates();\n\n                // Populate mandatory resources; since these are mandatory\n                // resources, failure throws a resolve exception.\n                for (Iterator<Resource> it = mandatoryResources.iterator();\n                    it.hasNext(); )\n                {\n                    Resource resource = it.next();\n                    if (Util.isFragment(resource) || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.MANDATORY);\n                    }\n                    else\n                    {\n                        it.remove();\n                    }\n                }\n\n                // Populate optional resources; since these are optional\n                // resources, failure does not throw a resolve exception.\n                for (Resource resource : optionalResources)\n                {\n                    boolean isFragment = Util.isFragment(resource);\n                    if (isFragment || (rc.getWirings().get(resource) == null))\n                    {\n                        allCandidates.populate(rc, resource, Candidates.OPTIONAL);\n                    }\n                }\n\n                // Populate ondemand fragments; since these are optional\n                // resources, failure does not throw a resolve exception.\n                for (Resource resource : ondemandFragments)\n                {\n                    boolean isFragment = Util.isFragment(resource);\n                    if (isFragment)\n                    {\n                        allCandidates.populate(rc, resource, Candidates.ON_DEMAND);\n                    }\n                }\n\n                // Merge any fragments into hosts.\n                allCandidates.prepare(rc);\n\n                // Create a combined list of populated resources; for\n                // optional resources. We do not need to consider ondemand\n                // fragments, since they will only be pulled in if their\n                // host is already present.\n                Set<Resource> allResources =\n                    new HashSet<Resource>(mandatoryResources);\n                for (Resource resource : optionalResources)\n                {\n                    if (allCandidates.isPopulated(resource))\n                    {\n                        allResources.add(resource);\n                    }\n                }\n\n                // Record the initial candidate permutation.\n                m_usesPermutations.add(allCandidates);\n\n                ResolutionException rethrow = null;\n\n                // If a populated resource is a fragment, then its host\n                // must ultimately be verified, so store its host requirement\n                // to use for package space calculation.\n                Map<Resource, List<Requirement>> hostReqs =\n                    new HashMap<Resource, List<Requirement>>();\n                for (Resource resource : allResources)\n                {\n                    if (Util.isFragment(resource))\n                    {\n                        hostReqs.put(\n                            resource,\n                            resource.getRequirements(HostNamespace.HOST_NAMESPACE));\n                    }\n                }\n\n                do\n                {\n                    rethrow = null;\n\n                    resourcePkgMap.clear();\n                    m_packageSourcesCache.clear();\n\n                    allCandidates = (m_usesPermutations.size() > 0)\n                        ? m_usesPermutations.remove(0)\n                        : m_importPermutations.remove(0);\n//allCandidates.dump();\n                    // Reuse a resultCache map for checking package consistency\n                    // for all resources.\n                    Map<Resource, Object> resultCache =\n                        new HashMap<Resource, Object>(allResources.size());\n                    // Check the package space consistency for all 'root' resources.\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then get its\n                        // host candidate and verify it instead.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getCandidates(hostReq.get(0))\n                                .iterator().next().getResource();\n                        }\n\n                        calculatePackageSpaces(\n                            rc, allCandidates.getWrappedHost(target), allCandidates,\n                            resourcePkgMap, new HashMap(), new HashSet());\n//System.out.println(\"+++ PACKAGE SPACES START +++\");\n//dumpResourcePkgMap(resourcePkgMap);\n//System.out.println(\"+++ PACKAGE SPACES END +++\");\n\n                        try\n                        {\n                            checkPackageSpaceConsistency(\n                                rc, allCandidates.getWrappedHost(target),\n                                allCandidates, resourcePkgMap, resultCache);\n                        }\n                        catch (ResolutionException ex)\n                        {\n                            rethrow = ex;\n                        }\n                    }\n                }\n                while ((rethrow != null)\n                    && ((m_usesPermutations.size() > 0) || (m_importPermutations.size() > 0)));\n\n                // If there is a resolve exception, then determine if an\n                // optionally resolved resource is to blame (typically a fragment).\n                // If so, then remove the optionally resolved resolved and try\n                // again; otherwise, rethrow the resolve exception.\n                if (rethrow != null)\n                {\n                    Collection<Requirement> exReqs = rethrow.getUnresolvedRequirements();\n                    Requirement faultyReq = ((exReqs == null) || (exReqs.isEmpty()))\n                        ? null : exReqs.iterator().next();\n                    Resource faultyResource = (faultyReq == null)\n                        ? null : getDeclaredResource(faultyReq.getResource());\n                    // If the faulty requirement is wrapped, then it may\n                    // be from a fragment, so consider the fragment faulty\n                    // instead of the host.\n                    if (faultyReq instanceof WrappedRequirement)\n                    {\n                        faultyResource =\n                            ((WrappedRequirement) faultyReq)\n                                .getDeclaredRequirement().getResource();\n                    }\n                    // Try to ignore the faulty resource if it is not mandatory.\n                    if (optionalResources.remove(faultyResource))\n                    {\n                        retry = true;\n                    }\n                    else if (ondemandFragments.remove(faultyResource))\n                    {\n                        retry = true;\n                    }\n                    else\n                    {\n                        throw rethrow;\n                    }\n                }\n                // If there is no exception to rethrow, then this was a clean\n                // resolve, so populate the wire map.\n                else\n                {\n                    for (Resource resource : allResources)\n                    {\n                        Resource target = resource;\n\n                        // If we are resolving a fragment, then we\n                        // actually want to populate its host's wires.\n                        List<Requirement> hostReq = hostReqs.get(resource);\n                        if (hostReq != null)\n                        {\n                            target = allCandidates.getCandidates(hostReq.get(0))\n                                .iterator().next().getResource();\n                        }\n\n                        if (allCandidates.isPopulated(target))\n                        {\n                            wireMap =\n                                populateWireMap(\n                                    rc, allCandidates.getWrappedHost(target),\n                                    resourcePkgMap, wireMap, allCandidates);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // Always clear the state.\n                m_usesPermutations.clear();\n                m_importPermutations.clear();\n            }\n        }\n        while (retry);\n\n        return wireMap;\n    }","commit_id":"eed39899f4681840b072df48b52d3340cb7c7c1b","url":"https://github.com/apache/felix"},{"original_method":"private void checkDynamicPackageSpaceConsistency(\n        ResolveContext rc,\n        Resource resource,\n        Candidates allCandidates,\n        Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, Object> resultCache) throws ResolutionException\n    {\n        if (resultCache.containsKey(resource))\n        {\n            return;\n        }\n\n        Packages pkgs = resourcePkgMap.get(resource);\n\n        ResolutionException rethrow = null;\n        Candidates permutation = null;\n        Set<Requirement> mutated = null;\n\n        // Check for conflicting imports from fragments.\n        for (Entry<String, List<Blame>> entry : pkgs.m_importedPkgs.entrySet())\n        {\n            if (entry.getValue().size() > 1)\n            {\n                Blame sourceBlame = null;\n                for (Blame blame : entry.getValue())\n                {\n                    if (sourceBlame == null)\n                    {\n                        sourceBlame = blame;\n                    }\n                    else if (!sourceBlame.m_cap.getResource().equals(blame.m_cap.getResource()))\n                    {\n                        // Try to permutate the conflicting requirement.\n                        permutate(allCandidates, blame.m_reqs.get(0), m_importPermutations);\n                        // Try to permutate the source requirement.\n                        permutate(allCandidates, sourceBlame.m_reqs.get(0), m_importPermutations);\n                        // Report conflict.\n                        ResolutionException ex = new ResolutionException(\n                            \"Uses constraint violation. Unable to resolve resource \"\n                            + Util.getSymbolicName(resource)\n                            + \" [\" + resource\n                            + \"] because it is exposed to package '\"\n                            + entry.getKey()\n                            + \"' from resources \"\n                            + Util.getSymbolicName(sourceBlame.m_cap.getResource())\n                            + \" [\" + sourceBlame.m_cap.getResource()\n                            + \"] and \"\n                            + Util.getSymbolicName(blame.m_cap.getResource())\n                            + \" [\" + blame.m_cap.getResource()\n                            + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                            + toStringBlame(rc, allCandidates, sourceBlame)\n                            + \"\\n\\nChain 2:\\n\"\n                            + toStringBlame(rc, allCandidates, blame),\n                            null,\n                            Collections.singleton(blame.m_reqs.get(0)));\n                        m_logger.log(\n                            Logger.LOG_DEBUG,\n                            \"Candidate permutation failed due to a conflict with a \"\n                            + \"fragment import; will try another if possible.\",\n                            ex);\n                        throw ex;\n                    }\n                }\n            }\n        }\n\n        // Check if there are any uses conflicts with exported packages.\n        for (Entry<String, Blame> entry : pkgs.m_exportedPkgs.entrySet())\n        {\n            String pkgName = entry.getKey();\n            Blame exportBlame = entry.getValue();\n            if (!pkgs.m_usedPkgs.containsKey(pkgName))\n            {\n                continue;\n            }\n            for (Blame usedBlame : pkgs.m_usedPkgs.get(pkgName))\n            {\n                if (!isCompatible(rc, exportBlame.m_cap, usedBlame.m_cap, resourcePkgMap))\n                {\n                    // Create a candidate permutation that eliminates all candidates\n                    // that conflict with existing selected candidates.\n                    permutation = (permutation != null)\n                        ? permutation\n                        : allCandidates.copy();\n                    rethrow = (rethrow != null)\n                        ? rethrow\n                        : new ResolutionException(\n                            \"Uses constraint violation. Unable to resolve resource \"\n                            + Util.getSymbolicName(resource)\n                            + \" [\" + resource\n                            + \"] because it exports package '\"\n                            + pkgName\n                            + \"' and is also exposed to it from resource \"\n                            + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                            + \" [\" + usedBlame.m_cap.getResource()\n                            + \"] via the following dependency chain:\\n\\n\"\n                            + toStringBlame(rc, allCandidates, usedBlame),\n                            null,\n                            null);\n\n                    mutated = (mutated != null)\n                        ? mutated\n                        : new HashSet<Requirement>();\n\n                    for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                    {\n                        Requirement req = usedBlame.m_reqs.get(reqIdx);\n\n                        // If we've already permutated this requirement in another\n                        // uses constraint, don't permutate it again just continue\n                        // with the next uses constraint.\n                        if (mutated.contains(req))\n                        {\n                            break;\n                        }\n\n                        // See if we can permutate the candidates for blamed\n                        // requirement; there may be no candidates if the resource\n                        // associated with the requirement is already resolved.\n                        List<Capability> candidates = permutation.getCandidates(req);\n                        if ((candidates != null) && (candidates.size() > 1))\n                        {\n                            mutated.add(req);\n                            // Remove the conflicting candidate.\n                            candidates.remove(0);\n                            // Continue with the next uses constraint.\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (rethrow != null)\n            {\n                if (mutated.size() > 0)\n                {\n                    m_usesPermutations.add(permutation);\n                }\n                m_logger.log(\n                    Logger.LOG_DEBUG,\n                    \"Candidate permutation failed due to a conflict between \"\n                    + \"an export and import; will try another if possible.\",\n                    rethrow);\n                throw rethrow;\n            }\n        }\n\n        // Check if there are any uses conflicts with imported packages.\n        for (Entry<String, List<Blame>> entry : pkgs.m_importedPkgs.entrySet())\n        {\n            for (Blame importBlame : entry.getValue())\n            {\n                String pkgName = entry.getKey();\n                if (!pkgs.m_usedPkgs.containsKey(pkgName))\n                {\n                    continue;\n                }\n                for (Blame usedBlame : pkgs.m_usedPkgs.get(pkgName))\n                {\n                    if (!isCompatible(rc, importBlame.m_cap, usedBlame.m_cap, resourcePkgMap))\n                    {\n                        // Create a candidate permutation that eliminates any candidates\n                        // that conflict with existing selected candidates.\n                        permutation = (permutation != null)\n                            ? permutation\n                            : allCandidates.copy();\n                        rethrow = (rethrow != null)\n                            ? rethrow\n                            : new ResolutionException(\n                                \"Uses constraint violation. Unable to resolve resource \"\n                                + Util.getSymbolicName(resource)\n                                + \" [\" + resource\n                                + \"] because it is exposed to package '\"\n                                + pkgName\n                                + \"' from resources \"\n                                + Util.getSymbolicName(importBlame.m_cap.getResource())\n                                + \" [\" + importBlame.m_cap.getResource()\n                                + \"] and \"\n                                + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                                + \" [\" + usedBlame.m_cap.getResource()\n                                + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                                + toStringBlame(rc, allCandidates, importBlame)\n                                + \"\\n\\nChain 2:\\n\"\n                                + toStringBlame(rc, allCandidates, usedBlame),\n                                null,\n                                null);\n\n                        mutated = (mutated != null)\n                            ? mutated\n                            : new HashSet();\n\n                        for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                        {\n                            Requirement req = usedBlame.m_reqs.get(reqIdx);\n\n                            // If we've already permutated this requirement in another\n                            // uses constraint, don't permutate it again just continue\n                            // with the next uses constraint.\n                            if (mutated.contains(req))\n                            {\n                                break;\n                            }\n\n                            // See if we can permutate the candidates for blamed\n                            // requirement; there may be no candidates if the resource\n                            // associated with the requirement is already resolved.\n                            List<Capability> candidates = permutation.getCandidates(req);\n                            if ((candidates != null) && (candidates.size() > 1))\n                            {\n                                mutated.add(req);\n                                // Remove the conflicting candidate.\n                                candidates.remove(0);\n                                // Continue with the next uses constraint.\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                // If there was a uses conflict, then we should add a uses\n                // permutation if we were able to permutate any candidates.\n                // Additionally, we should try to push an import permutation\n                // for the original import to force a backtracking on the\n                // original candidate decision if no viable candidate is found\n                // for the conflicting uses constraint.\n                if (rethrow != null)\n                {\n                    // Add uses permutation if we mutated any candidates.\n                    if (mutated.size() > 0)\n                    {\n                        m_usesPermutations.add(permutation);\n                    }\n\n                    // Try to permutate the candidate for the original\n                    // import requirement; only permutate it if we haven't\n                    // done so already.\n                    Requirement req = importBlame.m_reqs.get(0);\n                    if (!mutated.contains(req))\n                    {\n                        // Since there may be lots of uses constraint violations\n                        // with existing import decisions, we may end up trying\n                        // to permutate the same import a lot of times, so we should\n                        // try to check if that the case and only permutate it once.\n                        permutateIfNeeded(allCandidates, req, m_importPermutations);\n                    }\n\n                    m_logger.log(\n                        Logger.LOG_DEBUG,\n                        \"Candidate permutation failed due to a conflict between \"\n                        + \"imports; will try another if possible.\",\n                        rethrow);\n                    throw rethrow;\n                }\n            }\n        }\n\n        resultCache.put(resource, Boolean.TRUE);\n\n        // Now check the consistency of all resources on which the\n        // current resource depends. Keep track of the current number\n        // of permutations so we know if the lower level check was\n        // able to create a permutation or not in the case of failure.\n        int permCount = m_usesPermutations.size() + m_importPermutations.size();\n        for (Entry<String, List<Blame>> entry : pkgs.m_importedPkgs.entrySet())\n        {\n            for (Blame importBlame : entry.getValue())\n            {\n                if (!resource.equals(importBlame.m_cap.getResource()))\n                {\n                    try\n                    {\n                        checkPackageSpaceConsistency(\n                            rc, importBlame.m_cap.getResource(),\n                            allCandidates, resourcePkgMap, resultCache);\n                    }\n                    catch (ResolutionException ex)\n                    {\n                        // If the lower level check didn't create any permutations,\n                        // then we should create an import permutation for the\n                        // requirement with the dependency on the failing resource\n                        // to backtrack on our current candidate selection.\n                        if (permCount == (m_usesPermutations.size() + m_importPermutations.size()))\n                        {\n                            Requirement req = importBlame.m_reqs.get(0);\n                            permutate(allCandidates, req, m_importPermutations);\n                        }\n                        throw ex;\n                    }\n                }\n            }\n        }\n    }","id":32591,"modified_method":"private void checkDynamicPackageSpaceConsistency(\n        ResolveContext rc,\n        Resource resource,\n        Candidates allCandidates,\n        Map<Resource, Packages> resourcePkgMap,\n        Map<Resource, Object> resultCache) throws ResolutionException\n    {\n        if (resultCache.containsKey(resource))\n        {\n            return;\n        }\n\n        Packages pkgs = resourcePkgMap.get(resource);\n\n        ResolutionException rethrow = null;\n        Candidates permutation = null;\n        Set<Requirement> mutated = null;\n\n        // Check for conflicting imports from fragments.\n        // TODO: Is this only needed for imports or are generic and bundle requirements also needed?\n        //       I think this is only a special case for fragment imports because they can overlap\n        //       host imports, which is not allowed in normal metadata.\n        for (Entry<String, List<Blame>> entry : pkgs.m_importedPkgs.entrySet())\n        {\n            if (entry.getValue().size() > 1)\n            {\n                Blame sourceBlame = null;\n                for (Blame blame : entry.getValue())\n                {\n                    if (sourceBlame == null)\n                    {\n                        sourceBlame = blame;\n                    }\n                    else if (!sourceBlame.m_cap.getResource().equals(blame.m_cap.getResource()))\n                    {\n                        // Try to permutate the conflicting requirement.\n                        permutate(allCandidates, blame.m_reqs.get(0), m_importPermutations);\n                        // Try to permutate the source requirement.\n                        permutate(allCandidates, sourceBlame.m_reqs.get(0), m_importPermutations);\n                        // Report conflict.\n                        ResolutionException ex = new ResolutionException(\n                            \"Uses constraint violation. Unable to resolve resource \"\n                            + Util.getSymbolicName(resource)\n                            + \" [\" + resource\n                            + \"] because it is exposed to package '\"\n                            + entry.getKey()\n                            + \"' from resources \"\n                            + Util.getSymbolicName(sourceBlame.m_cap.getResource())\n                            + \" [\" + sourceBlame.m_cap.getResource()\n                            + \"] and \"\n                            + Util.getSymbolicName(blame.m_cap.getResource())\n                            + \" [\" + blame.m_cap.getResource()\n                            + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                            + toStringBlame(rc, allCandidates, sourceBlame)\n                            + \"\\n\\nChain 2:\\n\"\n                            + toStringBlame(rc, allCandidates, blame),\n                            null,\n                            Collections.singleton(blame.m_reqs.get(0)));\n                        m_logger.log(\n                            Logger.LOG_DEBUG,\n                            \"Candidate permutation failed due to a conflict with a \"\n                            + \"fragment import; will try another if possible.\",\n                            ex);\n                        throw ex;\n                    }\n                }\n            }\n        }\n\n        // Check if there are any uses conflicts with exported packages.\n        for (Entry<String, Blame> entry : pkgs.m_exportedPkgs.entrySet())\n        {\n            String pkgName = entry.getKey();\n            Blame exportBlame = entry.getValue();\n            if (!pkgs.m_usedPkgs.containsKey(pkgName))\n            {\n                continue;\n            }\n            for (Blame usedBlame : pkgs.m_usedPkgs.get(pkgName))\n            {\n                if (!isCompatible(rc, exportBlame.m_cap, usedBlame.m_cap, resourcePkgMap))\n                {\n                    // Create a candidate permutation that eliminates all candidates\n                    // that conflict with existing selected candidates.\n                    permutation = (permutation != null)\n                        ? permutation\n                        : allCandidates.copy();\n                    rethrow = (rethrow != null)\n                        ? rethrow\n                        : new ResolutionException(\n                            \"Uses constraint violation. Unable to resolve resource \"\n                            + Util.getSymbolicName(resource)\n                            + \" [\" + resource\n                            + \"] because it exports package '\"\n                            + pkgName\n                            + \"' and is also exposed to it from resource \"\n                            + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                            + \" [\" + usedBlame.m_cap.getResource()\n                            + \"] via the following dependency chain:\\n\\n\"\n                            + toStringBlame(rc, allCandidates, usedBlame),\n                            null,\n                            null);\n\n                    mutated = (mutated != null)\n                        ? mutated\n                        : new HashSet<Requirement>();\n\n                    for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                    {\n                        Requirement req = usedBlame.m_reqs.get(reqIdx);\n\n                        // If we've already permutated this requirement in another\n                        // uses constraint, don't permutate it again just continue\n                        // with the next uses constraint.\n                        if (mutated.contains(req))\n                        {\n                            break;\n                        }\n\n                        // See if we can permutate the candidates for blamed\n                        // requirement; there may be no candidates if the resource\n                        // associated with the requirement is already resolved.\n                        List<Capability> candidates = permutation.getCandidates(req);\n                        if ((candidates != null) && (candidates.size() > 1))\n                        {\n                            mutated.add(req);\n                            // Remove the conflicting candidate.\n                            candidates.remove(0);\n                            // Continue with the next uses constraint.\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (rethrow != null)\n            {\n                if (!mutated.isEmpty())\n                {\n                    m_usesPermutations.add(permutation);\n                }\n                m_logger.log(\n                    Logger.LOG_DEBUG,\n                    \"Candidate permutation failed due to a conflict between \"\n                    + \"an export and import; will try another if possible.\",\n                    rethrow);\n                throw rethrow;\n            }\n        }\n\n        // Check if there are any uses conflicts with imported and required packages.\n        // We combine the imported and required packages here into one map.\n        // Imported packages are added after required packages because they shadow or override\n        // the packages from required bundles.\n        Map<String, List<Blame>> allImportRequirePkgs = new HashMap<String, List<Blame>>(pkgs.m_requiredPkgs);\n        allImportRequirePkgs.putAll(pkgs.m_importedPkgs);\n\n        for (Entry<String, List<Blame>> pkgEntry: allImportRequirePkgs.entrySet())\n        {\n            String pkgName = pkgEntry.getKey();\n            for (Blame requirementBlame : pkgEntry.getValue())\n            {\n                if (!pkgs.m_usedPkgs.containsKey(pkgName))\n                {\n                    continue;\n                }\n                for (Blame usedBlame : pkgs.m_usedPkgs.get(pkgName))\n                {\n                    if (!isCompatible(rc, requirementBlame.m_cap, usedBlame.m_cap, resourcePkgMap))\n                    {\n                        // Create a candidate permutation that eliminates any candidates\n                        // that conflict with existing selected candidates.\n                        permutation = (permutation != null)\n                            ? permutation\n                            : allCandidates.copy();\n                        rethrow = (rethrow != null)\n                            ? rethrow\n                            : new ResolutionException(\n                                \"Uses constraint violation. Unable to resolve resource \"\n                                + Util.getSymbolicName(resource)\n                                + \" [\" + resource\n                                + \"] because it is exposed to package '\"\n                                + pkgName\n                                + \"' from resources \"\n                                + Util.getSymbolicName(requirementBlame.m_cap.getResource())\n                                + \" [\" + requirementBlame.m_cap.getResource()\n                                + \"] and \"\n                                + Util.getSymbolicName(usedBlame.m_cap.getResource())\n                                + \" [\" + usedBlame.m_cap.getResource()\n                                + \"] via two dependency chains.\\n\\nChain 1:\\n\"\n                                + toStringBlame(rc, allCandidates, requirementBlame)\n                                + \"\\n\\nChain 2:\\n\"\n                                + toStringBlame(rc, allCandidates, usedBlame),\n                                null,\n                                null);\n\n                        mutated = (mutated != null)\n                            ? mutated\n                            : new HashSet();\n\n                        for (int reqIdx = usedBlame.m_reqs.size() - 1; reqIdx >= 0; reqIdx--)\n                        {\n                            Requirement req = usedBlame.m_reqs.get(reqIdx);\n\n                            // If we've already permutated this requirement in another\n                            // uses constraint, don't permutate it again just continue\n                            // with the next uses constraint.\n                            if (mutated.contains(req))\n                            {\n                                break;\n                            }\n\n                            // See if we can permutate the candidates for blamed\n                            // requirement; there may be no candidates if the resource\n                            // associated with the requirement is already resolved.\n                            List<Capability> candidates = permutation.getCandidates(req);\n                            if ((candidates != null) && (candidates.size() > 1))\n                            {\n                                mutated.add(req);\n                                // Remove the conflicting candidate.\n                                candidates.remove(0);\n                                // Continue with the next uses constraint.\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                // If there was a uses conflict, then we should add a uses\n                // permutation if we were able to permutate any candidates.\n                // Additionally, we should try to push an import permutation\n                // for the original import to force a backtracking on the\n                // original candidate decision if no viable candidate is found\n                // for the conflicting uses constraint.\n                if (rethrow != null)\n                {\n                    // Add uses permutation if we mutated any candidates.\n                    if (!mutated.isEmpty())\n                    {\n                        m_usesPermutations.add(permutation);\n                    }\n\n                    // Try to permutate the candidate for the original\n                    // import requirement; only permutate it if we haven't\n                    // done so already.\n                    Requirement req = requirementBlame.m_reqs.get(0);\n                    if (!mutated.contains(req))\n                    {\n                        // Since there may be lots of uses constraint violations\n                        // with existing import decisions, we may end up trying\n                        // to permutate the same import a lot of times, so we should\n                        // try to check if that the case and only permutate it once.\n                        permutateIfNeeded(allCandidates, req, m_importPermutations);\n                    }\n\n                    m_logger.log(\n                        Logger.LOG_DEBUG,\n                        \"Candidate permutation failed due to a conflict between \"\n                        + \"imports; will try another if possible.\",\n                        rethrow);\n                    throw rethrow;\n                }\n            }\n        }\n\n        resultCache.put(resource, Boolean.TRUE);\n\n        // Now check the consistency of all resources on which the\n        // current resource depends. Keep track of the current number\n        // of permutations so we know if the lower level check was\n        // able to create a permutation or not in the case of failure.\n        int permCount = m_usesPermutations.size() + m_importPermutations.size();\n        for (Requirement req : resource.getRequirements(null))\n        {\n            List<Capability> cands = allCandidates.getCandidates(req);\n            if (cands != null && !cands.isEmpty())\n            {\n                Capability cap = cands.get(0);\n                if (!resource.equals(cap.getResource()))\n                {\n                    try\n                    {\n                        checkPackageSpaceConsistency(\n                            rc, cap.getResource(),\n                            allCandidates, resourcePkgMap, resultCache);\n                    }\n                    catch (ResolutionException ex)\n                    {\n                        // If the lower level check didn't create any permutations,\n                        // then we should create an import permutation for the\n                        // requirement with the dependency on the failing resource\n                        // to backtrack on our current candidate selection.\n                        if (permCount == (m_usesPermutations.size() + m_importPermutations.size()))\n                        {\n                            permutate(allCandidates, req, m_importPermutations);\n                        }\n                        throw ex;\n                    }\n                }\n            }\n        }\n    }","commit_id":"eed39899f4681840b072df48b52d3340cb7c7c1b","url":"https://github.com/apache/felix"},{"original_method":"public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {\n            GlobalMatrixAuthorizationStrategy strategy = (GlobalMatrixAuthorizationStrategy)source;\n\n            for (Entry<Permission, Set<String>> e : strategy.grantedPermissions.entrySet()) {\n                String p = e.getKey().getId();\n                for (String sid : e.getValue()) {\n                    writer.startNode(\"permission\");\n                    writer.setValue(p+':'+sid);\n                    writer.endNode();\n                }\n            }\n\n        }","id":32592,"modified_method":"public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {\n            GlobalMatrixAuthorizationStrategy strategy = (GlobalMatrixAuthorizationStrategy)source;\n\n            // Output in alphabetical order for readability.\n            SortedMap<Permission, Set<String>> sortedPermissions = new TreeMap<Permission, Set<String>>(Permission.ID_COMPARATOR);\n            sortedPermissions.putAll(strategy.grantedPermissions);\n            for (Entry<Permission, Set<String>> e : sortedPermissions.entrySet()) {\n                String p = e.getKey().getId();\n                List<String> sids = new ArrayList<String>(e.getValue());\n                Collections.sort(sids);\n                for (String sid : sids) {\n                    writer.startNode(\"permission\");\n                    writer.setValue(p+':'+sid);\n                    writer.endNode();\n                }\n            }\n\n        }","commit_id":"2c1680428a4106ce8a5a53fd5c02374eeb69970b","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void writeIfElse(IfStatement ifElse) {\n        controller.getAcg().onLineNumber(ifElse,\"visitIfElse\");\n        writeStatementLabel(ifElse);\n\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        ifElse.getBooleanExpression().visit(controller.getAcg());\n        Label l0 = controller.getOperandStack().jump(IFEQ);\n\n        // if-else is here handled as a special version\n        // of a boolean expression\n        controller.getCompileStack().pushBooleanExpression();\n        ifElse.getIfBlock().visit(controller.getAcg());\n        controller.getCompileStack().pop();\n\n        Label l1 = new Label();\n        mv.visitJumpInsn(GOTO, l1);\n        mv.visitLabel(l0);\n\n        controller.getCompileStack().pushBooleanExpression();\n        ifElse.getElseBlock().visit(controller.getAcg());\n        controller.getCompileStack().pop();\n\n        mv.visitLabel(l1);\n    }","id":32593,"modified_method":"public void writeIfElse(IfStatement ifElse) {\n        controller.getAcg().onLineNumber(ifElse,\"visitIfElse\");\n        writeStatementLabel(ifElse);\n\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        ifElse.getBooleanExpression().visit(controller.getAcg());\n        Label l0 = controller.getOperandStack().jump(IFEQ);\n\n        // if-else is here handled as a special version\n        // of a boolean expression\n        controller.getCompileStack().pushBooleanExpression();\n        ifElse.getIfBlock().visit(controller.getAcg());\n        controller.getCompileStack().pop();\n\n        if (ifElse.getElseBlock()==EmptyStatement.INSTANCE) {\n            mv.visitLabel(l0);\n        } else {\n            Label l1 = new Label();\n            mv.visitJumpInsn(GOTO, l1);\n            mv.visitLabel(l0);\n    \n            controller.getCompileStack().pushBooleanExpression();\n            ifElse.getElseBlock().visit(controller.getAcg());\n            controller.getCompileStack().pop();\n    \n            mv.visitLabel(l1);\n        } \n    }","commit_id":"537dda1f761e49996054c7489985d0c0f17db91a","url":"https://github.com/apache/groovy"},{"original_method":"public void generate(ClassVisitor cw, String className) {\n        this.cw = cw;\n\n        classInternalName = BytecodeHelper.getClassInternalName(className);\n        cw.visit(ClassGenerator.asmJDKVersion, ACC_PUBLIC + ACC_SUPER, classInternalName, (String)null, \"org/codehaus/groovy/runtime/Reflector\", null);\n\n        cv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n        cv.visitVarInsn(ALOAD, 0);\n        cv.visitMethodInsn(INVOKESPECIAL, \"org/codehaus/groovy/runtime/Reflector\", \"<init>\", \"()V\");\n        cv.visitInsn(RETURN);\n        cv.visitMaxs(1, 1);\n\n        generateInvokeMethod();\n\n        cw.visitEnd();\n    }","id":32594,"modified_method":"public void generate(ClassVisitor cw, String className) {\n        this.cw = cw;\n\n        classInternalName = BytecodeHelper.getClassInternalName(className);\n        cw.visit(ClassGenerator.asmJDKVersion, ACC_PUBLIC + ACC_SUPER, classInternalName, (String)null, \"org/codehaus/groovy/runtime/Reflector\", null);\n\n        MethodVisitor cv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n        cv.visitVarInsn(ALOAD, 0);\n        cv.visitMethodInsn(INVOKESPECIAL, \"org/codehaus/groovy/runtime/Reflector\", \"<init>\", \"()V\");\n        cv.visitInsn(RETURN);\n        cv.visitMaxs(1, 1);\n\n        generateInvokeMethod();\n\n        cw.visitEnd();\n    }","commit_id":"0401a83f05384e5acfb8f308bf5287f4ceb69f73","url":"https://github.com/apache/groovy"},{"original_method":"protected void loadParameters(MetaMethod method, int argumentIndex) {\n        Class[] parameters = method.getParameterTypes();\n        int size = parameters.length;\n        for (int i = 0; i < size; i++) {\n            cv.visitVarInsn(ALOAD, argumentIndex);\n            helper.pushConstant(i);\n            cv.visitInsn(AALOAD);\n\n            // we should cast to something\n            Class type = parameters[i];\n            if (type.isPrimitive()) {\n                helper.unbox(type);\n            }\n            else {\n                helper.doCast(type);\n            }\n        }\n    }","id":32595,"modified_method":"protected void loadParameters(MetaMethod method, int argumentIndex, MethodVisitor cv) {\n        Class[] parameters = method.getParameterTypes();\n        int size = parameters.length;\n        for (int i = 0; i < size; i++) {\n        \t// unpack argument from Object[]\n            cv.visitVarInsn(ALOAD, argumentIndex);\n            helper.pushConstant(i);\n            cv.visitInsn(AALOAD);\n\n            // cast argument to parameter class, inclusive unboxing\n            // for methods with primitive types\n            Class type = parameters[i];\n            if (type.isPrimitive()) {\n                helper.unbox(type);\n            }\n            else {\n                helper.doCast(type);\n            }\n        }\n    }","commit_id":"0401a83f05384e5acfb8f308bf5287f4ceb69f73","url":"https://github.com/apache/groovy"},{"original_method":"protected void invokeMethod(MetaMethod method) {\n        /** simple\n        cv.visitVarInsn(ALOAD, 2);\n        cv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Object\", \"toString\", \"()Ljava/lang/String;\");\n        */\n        Class callClass = method.getInterfaceClass();\n        boolean useInterface = false;\n        if (callClass == null) {\n            callClass = method.getCallClass();\n        }\n        else {\n            useInterface = true;\n        }\n        String type = BytecodeHelper.getClassInternalName(callClass.getName());\n        String descriptor = BytecodeHelper.getMethodDescriptor(method.getReturnType(), method.getParameterTypes());\n\n        //        System.out.println(\"Method: \" + method);\n        //        System.out.println(\"Descriptor: \" + descriptor);\n\n        if (method.isStatic()) {\n            loadParameters(method, 3);\n            cv.visitMethodInsn(INVOKESTATIC, type, method.getName(), descriptor);\n        }\n        else {\n            cv.visitVarInsn(ALOAD, 2);\n            helper.doCast(callClass);\n            loadParameters(method, 3);\n            cv.visitMethodInsn((useInterface) ? INVOKEINTERFACE : INVOKEVIRTUAL, type, method.getName(), descriptor);\n        }\n\n        helper.box(method.getReturnType());\n    }","id":32596,"modified_method":"protected void invokeMethod(MetaMethod method, MethodVisitor cv) {\n    \t// compute class to make the call on\n        Class callClass = method.getInterfaceClass();\n        boolean useInterface = false;\n        if (callClass == null) {\n            callClass = method.getCallClass();\n        }\n        else {\n            useInterface = true;\n        }\n        // get bytecode information\n        String type = BytecodeHelper.getClassInternalName(callClass.getName());\n        String descriptor = BytecodeHelper.getMethodDescriptor(method.getReturnType(), method.getParameterTypes());\n\n        // make call\n        if (method.isStatic()) {\n            loadParameters(method, 3, cv);\n            cv.visitMethodInsn(INVOKESTATIC, type, method.getName(), descriptor);\n        }\n        else {\n            cv.visitVarInsn(ALOAD, 2);\n            helper.doCast(callClass);\n            loadParameters(method, 3, cv);\n            cv.visitMethodInsn((useInterface) ? INVOKEINTERFACE : INVOKEVIRTUAL, type, method.getName(), descriptor);\n        }\n\n        helper.box(method.getReturnType());\n    }","commit_id":"0401a83f05384e5acfb8f308bf5287f4ceb69f73","url":"https://github.com/apache/groovy"},{"original_method":"protected void generateInvokeMethod() {\n        int methodCount = methods.size();\n\n        cv =\n            cw.visitMethod(\n                ACC_PUBLIC,\n                \"invoke\",\n                \"(Lgroovy/lang/MetaMethod;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\",\n                null,\n                null);\n        helper = new BytecodeHelper(cv);\n\n        cv.visitVarInsn(ALOAD, 1);\n        cv.visitMethodInsn(INVOKEVIRTUAL, \"groovy/lang/MetaMethod\", \"getMethodIndex\", \"()I\");\n        Label defaultLabel = new Label();\n        Label[] labels = new Label[methodCount];\n        int[] indices = new int[methodCount];\n        for (int i = 0; i < methodCount; i++) {\n            labels[i] = new Label();\n\n            MetaMethod method = (MetaMethod) methods.get(i);\n            method.setMethodIndex(i + 1);\n            indices[i] = method.getMethodIndex();\n\n            //System.out.println(\"Index: \" + method.getMethodIndex() + \" for: \" + method);\n        }\n\n        cv.visitLookupSwitchInsn(defaultLabel, indices, labels);\n        //cv.visitTableSwitchInsn(minMethodIndex, maxMethodIndex, defaultLabel, labels);\n\n        for (int i = 0; i < methodCount; i++) {\n            cv.visitLabel(labels[i]);\n\n            MetaMethod method = (MetaMethod) methods.get(i);\n            invokeMethod(method);\n            if (method.getReturnType() == void.class) {\n                cv.visitInsn(ACONST_NULL);\n            }\n            cv.visitInsn(ARETURN);\n        }\n\n        cv.visitLabel(defaultLabel);\n        cv.visitVarInsn(ALOAD, 0);\n        cv.visitVarInsn(ALOAD, 1);\n        cv.visitVarInsn(ALOAD, 2);\n        cv.visitVarInsn(ALOAD, 3);\n        cv.visitMethodInsn(\n            INVOKEVIRTUAL,\n            classInternalName,\n            \"noSuchMethod\",\n            \"(Lgroovy/lang/MetaMethod;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\");\n        cv.visitInsn(ARETURN);\n        cv.visitMaxs(4, 4);\n    }","id":32597,"modified_method":"protected void generateInvokeMethod() {\n        int methodCount = methods.size();\n\n        MethodVisitor cv =\n            cw.visitMethod(\n                ACC_PUBLIC,\n                \"invoke\",\n                \"(Lgroovy/lang/MetaMethod;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\",\n                null,\n                null);\n\n        // load parameters for the helper method call\n        cv.visitVarInsn(ALOAD, 0);\n        cv.visitVarInsn(ALOAD, 1);\n        cv.visitVarInsn(ALOAD, 2);\n        cv.visitVarInsn(ALOAD, 3);\n        \n        // get method number for switch\n        cv.visitVarInsn(ALOAD, 1);\n        cv.visitMethodInsn(INVOKEVIRTUAL, \"groovy/lang/MetaMethod\", \"getMethodIndex\", \"()I\");\n\n        // init meta methods with number\n        Label defaultLabel = new Label();\n        Label[] labels = new Label[methodCount];\n        int[] indices = new int[methodCount];\n        for (int i = 0; i < methodCount; i++) {\n            labels[i] = new Label();\n            MetaMethod method = (MetaMethod) methods.get(i);\n            method.setMethodIndex(i + 1);\n            indices[i] = method.getMethodIndex();\n        }\n\n        // do switch\n        cv.visitLookupSwitchInsn(defaultLabel, indices, labels);\n        // create switch cases\n        for (int i = 0; i < methodCount; i++) {\n        \t// call helper for invocation\n            cv.visitLabel(labels[i]);\n            cv.visitMethodInsn(\n            \t\tINVOKESPECIAL, \n            \t\tclassInternalName,\n            \t\t\"m\"+i,\n            \t\t\"(Lgroovy/lang/MetaMethod;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\");\n            cv.visitInsn(ARETURN);\n        }  \n         \n        // call helper for error\n        cv.visitLabel(defaultLabel);\n        cv.visitMethodInsn(\n            INVOKEVIRTUAL,\n            classInternalName,\n            \"noSuchMethod\",\n            \"(Lgroovy/lang/MetaMethod;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\");\n        cv.visitInsn(ARETURN);\n        // end method\n        cv.visitMaxs(4, 4);\n        cv.visitEnd();\n        \n        // create helper methods m*\n        for (int i = 0; i < methodCount; i++) {\n            cv =\n                cw.visitMethod(\n                    ACC_PRIVATE,\n                    \"m\"+i,\n                    \"(Lgroovy/lang/MetaMethod;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\",\n                    null,\n                    null);\n            helper = new BytecodeHelper(cv);\n\n        \tMetaMethod method = (MetaMethod) methods.get(i);\n        \tinvokeMethod(method,cv);\n        \tif (method.getReturnType() == void.class) {\n        \t\tcv.visitInsn(ACONST_NULL);\n        \t}\n        \tcv.visitInsn(ARETURN);\n        \tcv.visitMaxs(0, 0);\n        \tcv.visitEnd();\n        }\n    }","commit_id":"0401a83f05384e5acfb8f308bf5287f4ceb69f73","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Reads the bytecode of a method and makes the given visitor visit it.\n     * \n     * @param mv\n     *            the visitor that must visit the method's code.\n     * @param context\n     *            information about the class being parsed.\n     * @param u\n     *            the start offset of the code attribute in the class file.\n     */\n    private void readCode(final MethodVisitor mv, final Context context, int u) {\n        // reads the header\n        byte[] b = this.b;\n        char[] c = context.buffer;\n        int maxStack = readUnsignedShort(u);\n        int maxLocals = readUnsignedShort(u + 2);\n        int codeLength = readInt(u + 4);\n        u += 8;\n\n        // reads the bytecode to find the labels\n        int codeStart = u;\n        int codeEnd = u + codeLength;\n        Label[] labels = context.labels = new Label[codeLength + 2];\n        readLabel(codeLength + 1, labels);\n        while (u < codeEnd) {\n            int offset = u - codeStart;\n            int opcode = b[u] & 0xFF;\n            switch (ClassWriter.TYPE[opcode]) {\n            case ClassWriter.NOARG_INSN:\n            case ClassWriter.IMPLVAR_INSN:\n                u += 1;\n                break;\n            case ClassWriter.LABEL_INSN:\n                readLabel(offset + readShort(u + 1), labels);\n                u += 3;\n                break;\n            case ClassWriter.LABELW_INSN:\n                readLabel(offset + readInt(u + 1), labels);\n                u += 5;\n                break;\n            case ClassWriter.WIDE_INSN:\n                opcode = b[u + 1] & 0xFF;\n                if (opcode == Opcodes.IINC) {\n                    u += 6;\n                } else {\n                    u += 4;\n                }\n                break;\n            case ClassWriter.TABL_INSN:\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                readLabel(offset + readInt(u), labels);\n                for (int i = readInt(u + 8) - readInt(u + 4) + 1; i > 0; --i) {\n                    readLabel(offset + readInt(u + 12), labels);\n                    u += 4;\n                }\n                u += 12;\n                break;\n            case ClassWriter.LOOK_INSN:\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                readLabel(offset + readInt(u), labels);\n                for (int i = readInt(u + 4); i > 0; --i) {\n                    readLabel(offset + readInt(u + 12), labels);\n                    u += 8;\n                }\n                u += 8;\n                break;\n            case ClassWriter.VAR_INSN:\n            case ClassWriter.SBYTE_INSN:\n            case ClassWriter.LDC_INSN:\n                u += 2;\n                break;\n            case ClassWriter.SHORT_INSN:\n            case ClassWriter.LDCW_INSN:\n            case ClassWriter.FIELDORMETH_INSN:\n            case ClassWriter.TYPE_INSN:\n            case ClassWriter.IINC_INSN:\n                u += 3;\n                break;\n            case ClassWriter.ITFMETH_INSN:\n            case ClassWriter.INDYMETH_INSN:\n                u += 5;\n                break;\n            // case MANA_INSN:\n            default:\n                u += 4;\n                break;\n            }\n        }\n\n        // reads the try catch entries to find the labels, and also visits them\n        for (int i = readUnsignedShort(u); i > 0; --i) {\n            Label start = readLabel(readUnsignedShort(u + 2), labels);\n            Label end = readLabel(readUnsignedShort(u + 4), labels);\n            Label handler = readLabel(readUnsignedShort(u + 6), labels);\n            String type = readUTF8(items[readUnsignedShort(u + 8)], c);\n            mv.visitTryCatchBlock(start, end, handler, type);\n            u += 8;\n        }\n        u += 2;\n\n        // reads the code attributes\n        int[] tanns = null; // start index of each visible type annotation\n        int[] itanns = null; // start index of each invisible type annotation\n        int tann = 0; // current index in tanns array\n        int itann = 0; // current index in itanns array\n        int ntoff = -1; // next visible type annotation code offset\n        int nitoff = -1; // next invisible type annotation code offset\n        int varTable = 0;\n        int varTypeTable = 0;\n        boolean zip = true;\n        boolean unzip = (context.flags & EXPAND_FRAMES) != 0;\n        int stackMap = 0;\n        int stackMapSize = 0;\n        int frameCount = 0;\n        Context frame = null;\n        Attribute attributes = null;\n\n        for (int i = readUnsignedShort(u); i > 0; --i) {\n            String attrName = readUTF8(u + 2, c);\n            if (\"LocalVariableTable\".equals(attrName)) {\n                if ((context.flags & SKIP_DEBUG) == 0) {\n                    varTable = u + 8;\n                    for (int j = readUnsignedShort(u + 8), v = u; j > 0; --j) {\n                        int label = readUnsignedShort(v + 10);\n                        if (labels[label] == null) {\n                            readLabel(label, labels).status |= Label.DEBUG;\n                        }\n                        label += readUnsignedShort(v + 12);\n                        if (labels[label] == null) {\n                            readLabel(label, labels).status |= Label.DEBUG;\n                        }\n                        v += 10;\n                    }\n                }\n            } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                varTypeTable = u + 8;\n            } else if (\"LineNumberTable\".equals(attrName)) {\n                if ((context.flags & SKIP_DEBUG) == 0) {\n                    for (int j = readUnsignedShort(u + 8), v = u; j > 0; --j) {\n                        int label = readUnsignedShort(v + 10);\n                        if (labels[label] == null) {\n                            readLabel(label, labels).status |= Label.DEBUG;\n                        }\n                        labels[label].line = readUnsignedShort(v + 12);\n                        v += 4;\n                    }\n                }\n            } else if (ANNOTATIONS\n                    && \"RuntimeVisibleTypeAnnotations\".equals(attrName)) {\n                tanns = readTypeAnnotations(mv, context, u + 8, true);\n                ntoff = tanns.length == 0 || readByte(tanns[0]) < 0x43 ? -1\n                        : readUnsignedShort(tanns[0] + 1);\n            } else if (ANNOTATIONS\n                    && \"RuntimeInvisibleTypeAnnotations\".equals(attrName)) {\n                itanns = readTypeAnnotations(mv, context, u + 8, false);\n                nitoff = itanns.length == 0 || readByte(itanns[0]) < 0x43 ? -1\n                        : readUnsignedShort(itanns[0] + 1);\n            } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                if ((context.flags & SKIP_FRAMES) == 0) {\n                    stackMap = u + 10;\n                    stackMapSize = readInt(u + 4);\n                    frameCount = readUnsignedShort(u + 8);\n                }\n                /*\n                 * here we do not extract the labels corresponding to the\n                 * attribute content. This would require a full parsing of the\n                 * attribute, which would need to be repeated in the second\n                 * phase (see below). Instead the content of the attribute is\n                 * read one frame at a time (i.e. after a frame has been\n                 * visited, the next frame is read), and the labels it contains\n                 * are also extracted one frame at a time. Thanks to the\n                 * ordering of frames, having only a \"one frame lookahead\" is\n                 * not a problem, i.e. it is not possible to see an offset\n                 * smaller than the offset of the current insn and for which no\n                 * Label exist.\n                 */\n                /*\n                 * This is not true for UNINITIALIZED type offsets. We solve\n                 * this by parsing the stack map table without a full decoding\n                 * (see below).\n                 */\n            } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                if ((context.flags & SKIP_FRAMES) == 0) {\n                    zip = false;\n                    stackMap = u + 10;\n                    stackMapSize = readInt(u + 4);\n                    frameCount = readUnsignedShort(u + 8);\n                }\n                /*\n                 * IMPORTANT! here we assume that the frames are ordered, as in\n                 * the StackMapTable attribute, although this is not guaranteed\n                 * by the attribute format.\n                 */\n            } else {\n                for (int j = 0; j < context.attrs.length; ++j) {\n                    if (context.attrs[j].type.equals(attrName)) {\n                        Attribute attr = context.attrs[j].read(this, u + 8,\n                                readInt(u + 4), c, codeStart - 8, labels);\n                        if (attr != null) {\n                            attr.next = attributes;\n                            attributes = attr;\n                        }\n                    }\n                }\n            }\n            u += 6 + readInt(u + 4);\n        }\n        u += 2;\n\n        // generates the first (implicit) stack map frame\n        if (FRAMES && stackMap != 0) {\n            /*\n             * for the first explicit frame the offset is not offset_delta + 1\n             * but only offset_delta; setting the implicit frame offset to -1\n             * allow the use of the \"offset_delta + 1\" rule in all cases\n             */\n            frame = context;\n            frame.offset = -1;\n            frame.mode = 0;\n            frame.localCount = 0;\n            frame.localDiff = 0;\n            frame.stackCount = 0;\n            frame.local = new Object[maxLocals];\n            frame.stack = new Object[maxStack];\n            if (unzip) {\n                getImplicitFrame(context);\n            }\n            /*\n             * Finds labels for UNINITIALIZED frame types. Instead of decoding\n             * each element of the stack map table, we look for 3 consecutive\n             * bytes that \"look like\" an UNINITIALIZED type (tag 8, offset\n             * within code bounds, NEW instruction at this offset). We may find\n             * false positives (i.e. not real UNINITIALIZED types), but this\n             * should be rare, and the only consequence will be the creation of\n             * an unneeded label. This is better than creating a label for each\n             * NEW instruction, and faster than fully decoding the whole stack\n             * map table.\n             */\n            for (int i = stackMap; i < stackMap + stackMapSize - 2; ++i) {\n                if (b[i] == 8) { // UNINITIALIZED FRAME TYPE\n                    int v = readUnsignedShort(i + 1);\n                    if (v >= 0 && v < codeLength) {\n                        if ((b[codeStart + v] & 0xFF) == Opcodes.NEW) {\n                            readLabel(v, labels);\n                        }\n                    }\n                }\n            }\n        }\n\n        // visits the instructions\n        u = codeStart;\n        while (u < codeEnd) {\n            int offset = u - codeStart;\n\n            // visits the label and line number for this offset, if any\n            Label l = labels[offset];\n            if (l != null) {\n                mv.visitLabel(l);\n                if ((context.flags & SKIP_DEBUG) == 0 && l.line > 0) {\n                    mv.visitLineNumber(l.line, l);\n                }\n            }\n\n            // visits the frame for this offset, if any\n            while (FRAMES && frame != null\n                    && (frame.offset == offset || frame.offset == -1)) {\n                // if there is a frame for this offset, makes the visitor visit\n                // it, and reads the next frame if there is one.\n                if (frame.offset != -1) {\n                    if (!zip || unzip) {\n                        mv.visitFrame(Opcodes.F_NEW, frame.localCount,\n                                frame.local, frame.stackCount, frame.stack);\n                    } else {\n                        mv.visitFrame(frame.mode, frame.localDiff, frame.local,\n                                frame.stackCount, frame.stack);\n                    }\n                }\n                if (frameCount > 0) {\n                    stackMap = readFrame(stackMap, zip, unzip, frame);\n                    --frameCount;\n                } else {\n                    frame = null;\n                }\n            }\n\n            // visits the instruction at this offset\n            int opcode = b[u] & 0xFF;\n            switch (ClassWriter.TYPE[opcode]) {\n            case ClassWriter.NOARG_INSN:\n                mv.visitInsn(opcode);\n                u += 1;\n                break;\n            case ClassWriter.IMPLVAR_INSN:\n                if (opcode > Opcodes.ISTORE) {\n                    opcode -= 59; // ISTORE_0\n                    mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2),\n                            opcode & 0x3);\n                } else {\n                    opcode -= 26; // ILOAD_0\n                    mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                }\n                u += 1;\n                break;\n            case ClassWriter.LABEL_INSN:\n                mv.visitJumpInsn(opcode, labels[offset + readShort(u + 1)]);\n                u += 3;\n                break;\n            case ClassWriter.LABELW_INSN:\n                mv.visitJumpInsn(opcode - 33, labels[offset + readInt(u + 1)]);\n                u += 5;\n                break;\n            case ClassWriter.WIDE_INSN:\n                opcode = b[u + 1] & 0xFF;\n                if (opcode == Opcodes.IINC) {\n                    mv.visitIincInsn(readUnsignedShort(u + 2), readShort(u + 4));\n                    u += 6;\n                } else {\n                    mv.visitVarInsn(opcode, readUnsignedShort(u + 2));\n                    u += 4;\n                }\n                break;\n            case ClassWriter.TABL_INSN: {\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                int label = offset + readInt(u);\n                int min = readInt(u + 4);\n                int max = readInt(u + 8);\n                Label[] table = new Label[max - min + 1];\n                u += 12;\n                for (int i = 0; i < table.length; ++i) {\n                    table[i] = labels[offset + readInt(u)];\n                    u += 4;\n                }\n                mv.visitTableSwitchInsn(min, max, labels[label], table);\n                break;\n            }\n            case ClassWriter.LOOK_INSN: {\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                int label = offset + readInt(u);\n                int len = readInt(u + 4);\n                int[] keys = new int[len];\n                Label[] values = new Label[len];\n                u += 8;\n                for (int i = 0; i < len; ++i) {\n                    keys[i] = readInt(u);\n                    values[i] = labels[offset + readInt(u + 4)];\n                    u += 8;\n                }\n                mv.visitLookupSwitchInsn(labels[label], keys, values);\n                break;\n            }\n            case ClassWriter.VAR_INSN:\n                mv.visitVarInsn(opcode, b[u + 1] & 0xFF);\n                u += 2;\n                break;\n            case ClassWriter.SBYTE_INSN:\n                mv.visitIntInsn(opcode, b[u + 1]);\n                u += 2;\n                break;\n            case ClassWriter.SHORT_INSN:\n                mv.visitIntInsn(opcode, readShort(u + 1));\n                u += 3;\n                break;\n            case ClassWriter.LDC_INSN:\n                mv.visitLdcInsn(readConst(b[u + 1] & 0xFF, c));\n                u += 2;\n                break;\n            case ClassWriter.LDCW_INSN:\n                mv.visitLdcInsn(readConst(readUnsignedShort(u + 1), c));\n                u += 3;\n                break;\n            case ClassWriter.FIELDORMETH_INSN:\n            case ClassWriter.ITFMETH_INSN: {\n                int cpIndex = items[readUnsignedShort(u + 1)];\n                boolean itf = b[cpIndex - 1] == ClassWriter.IMETH;\n                String iowner = readClass(cpIndex, c);\n                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                String iname = readUTF8(cpIndex, c);\n                String idesc = readUTF8(cpIndex + 2, c);\n                if (opcode < Opcodes.INVOKEVIRTUAL) {\n                    mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                } else {\n                    mv.visitMethodInsn(opcode, iowner, iname, idesc, itf);\n                }\n                if (opcode == Opcodes.INVOKEINTERFACE) {\n                    u += 5;\n                } else {\n                    u += 3;\n                }\n                break;\n            }\n            case ClassWriter.INDYMETH_INSN: {\n                int cpIndex = items[readUnsignedShort(u + 1)];\n                int bsmIndex = context.bootstrapMethods[readUnsignedShort(cpIndex)];\n                Handle bsm = (Handle) readConst(readUnsignedShort(bsmIndex), c);\n                int bsmArgCount = readUnsignedShort(bsmIndex + 2);\n                Object[] bsmArgs = new Object[bsmArgCount];\n                bsmIndex += 4;\n                for (int i = 0; i < bsmArgCount; i++) {\n                    bsmArgs[i] = readConst(readUnsignedShort(bsmIndex), c);\n                    bsmIndex += 2;\n                }\n                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                String iname = readUTF8(cpIndex, c);\n                String idesc = readUTF8(cpIndex + 2, c);\n                mv.visitInvokeDynamicInsn(iname, idesc, bsm, bsmArgs);\n                u += 5;\n                break;\n            }\n            case ClassWriter.TYPE_INSN:\n                mv.visitTypeInsn(opcode, readClass(u + 1, c));\n                u += 3;\n                break;\n            case ClassWriter.IINC_INSN:\n                mv.visitIincInsn(b[u + 1] & 0xFF, b[u + 2]);\n                u += 3;\n                break;\n            // case MANA_INSN:\n            default:\n                mv.visitMultiANewArrayInsn(readClass(u + 1, c), b[u + 3] & 0xFF);\n                u += 4;\n                break;\n            }\n\n            // visit the instruction annotations, if any\n            while (tanns != null && tann < tanns.length && ntoff <= offset) {\n                if (ntoff == offset) {\n                    int v = readAnnotationTarget(context, tanns[tann]);\n                    readAnnotationValues(v + 2, c, true,\n                            mv.visitInsnAnnotation(context.typeRef,\n                                    context.typePath, readUTF8(v, c), true));\n                }\n                ntoff = ++tann >= tanns.length || readByte(tanns[tann]) < 0x43 ? -1\n                        : readUnsignedShort(tanns[tann] + 1);\n            }\n            while (itanns != null && itann < itanns.length && nitoff <= offset) {\n                if (nitoff == offset) {\n                    int v = readAnnotationTarget(context, itanns[itann]);\n                    readAnnotationValues(v + 2, c, true,\n                            mv.visitInsnAnnotation(context.typeRef,\n                                    context.typePath, readUTF8(v, c), false));\n                }\n                nitoff = ++itann >= itanns.length\n                        || readByte(itanns[itann]) < 0x43 ? -1\n                        : readUnsignedShort(itanns[itann] + 1);\n            }\n        }\n        if (labels[codeLength] != null) {\n            mv.visitLabel(labels[codeLength]);\n        }\n\n        // visits the local variable tables\n        if ((context.flags & SKIP_DEBUG) == 0 && varTable != 0) {\n            int[] typeTable = null;\n            if (varTypeTable != 0) {\n                u = varTypeTable + 2;\n                typeTable = new int[readUnsignedShort(varTypeTable) * 3];\n                for (int i = typeTable.length; i > 0;) {\n                    typeTable[--i] = u + 6; // signature\n                    typeTable[--i] = readUnsignedShort(u + 8); // index\n                    typeTable[--i] = readUnsignedShort(u); // start\n                    u += 10;\n                }\n            }\n            u = varTable + 2;\n            for (int i = readUnsignedShort(varTable); i > 0; --i) {\n                int start = readUnsignedShort(u);\n                int length = readUnsignedShort(u + 2);\n                int index = readUnsignedShort(u + 8);\n                String vsignature = null;\n                if (typeTable != null) {\n                    for (int j = 0; j < typeTable.length; j += 3) {\n                        if (typeTable[j] == start && typeTable[j + 1] == index) {\n                            vsignature = readUTF8(typeTable[j + 2], c);\n                            break;\n                        }\n                    }\n                }\n                mv.visitLocalVariable(readUTF8(u + 4, c), readUTF8(u + 6, c),\n                        vsignature, labels[start], labels[start + length],\n                        index);\n                u += 10;\n            }\n        }\n\n        // visits the local variables type annotations\n        if (tanns != null) {\n            for (int i = 0; i < tanns.length; ++i) {\n                if ((readByte(tanns[i]) >> 1) == (0x40 >> 1)) {\n                    int v = readAnnotationTarget(context, tanns[i]);\n                    v = readAnnotationValues(v + 2, c, true,\n                            mv.visitLocalVariableAnnotation(context.typeRef,\n                                    context.typePath, context.start,\n                                    context.end, context.index, readUTF8(v, c),\n                                    true));\n                }\n            }\n        }\n        if (itanns != null) {\n            for (int i = 0; i < itanns.length; ++i) {\n                if ((readByte(itanns[i]) >> 1) == (0x40 >> 1)) {\n                    int v = readAnnotationTarget(context, itanns[i]);\n                    v = readAnnotationValues(v + 2, c, true,\n                            mv.visitLocalVariableAnnotation(context.typeRef,\n                                    context.typePath, context.start,\n                                    context.end, context.index, readUTF8(v, c),\n                                    false));\n                }\n            }\n        }\n\n        // visits the code attributes\n        while (attributes != null) {\n            Attribute attr = attributes.next;\n            attributes.next = null;\n            mv.visitAttribute(attributes);\n            attributes = attr;\n        }\n\n        // visits the max stack and max locals values\n        mv.visitMaxs(maxStack, maxLocals);\n    }","id":32598,"modified_method":"/**\n     * Reads the bytecode of a method and makes the given visitor visit it.\n     * \n     * @param mv\n     *            the visitor that must visit the method's code.\n     * @param context\n     *            information about the class being parsed.\n     * @param u\n     *            the start offset of the code attribute in the class file.\n     */\n    private void readCode(final MethodVisitor mv, final Context context, int u) {\n        // reads the header\n        byte[] b = this.b;\n        char[] c = context.buffer;\n        int maxStack = readUnsignedShort(u);\n        int maxLocals = readUnsignedShort(u + 2);\n        int codeLength = readInt(u + 4);\n        u += 8;\n\n        // reads the bytecode to find the labels\n        int codeStart = u;\n        int codeEnd = u + codeLength;\n        Label[] labels = context.labels = new Label[codeLength + 2];\n        readLabel(codeLength + 1, labels);\n        while (u < codeEnd) {\n            int offset = u - codeStart;\n            int opcode = b[u] & 0xFF;\n            switch (ClassWriter.TYPE[opcode]) {\n            case ClassWriter.NOARG_INSN:\n            case ClassWriter.IMPLVAR_INSN:\n                u += 1;\n                break;\n            case ClassWriter.LABEL_INSN:\n                readLabel(offset + readShort(u + 1), labels);\n                u += 3;\n                break;\n            case ClassWriter.LABELW_INSN:\n                readLabel(offset + readInt(u + 1), labels);\n                u += 5;\n                break;\n            case ClassWriter.WIDE_INSN:\n                opcode = b[u + 1] & 0xFF;\n                if (opcode == Opcodes.IINC) {\n                    u += 6;\n                } else {\n                    u += 4;\n                }\n                break;\n            case ClassWriter.TABL_INSN:\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                readLabel(offset + readInt(u), labels);\n                for (int i = readInt(u + 8) - readInt(u + 4) + 1; i > 0; --i) {\n                    readLabel(offset + readInt(u + 12), labels);\n                    u += 4;\n                }\n                u += 12;\n                break;\n            case ClassWriter.LOOK_INSN:\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                readLabel(offset + readInt(u), labels);\n                for (int i = readInt(u + 4); i > 0; --i) {\n                    readLabel(offset + readInt(u + 12), labels);\n                    u += 8;\n                }\n                u += 8;\n                break;\n            case ClassWriter.VAR_INSN:\n            case ClassWriter.SBYTE_INSN:\n            case ClassWriter.LDC_INSN:\n                u += 2;\n                break;\n            case ClassWriter.SHORT_INSN:\n            case ClassWriter.LDCW_INSN:\n            case ClassWriter.FIELDORMETH_INSN:\n            case ClassWriter.TYPE_INSN:\n            case ClassWriter.IINC_INSN:\n                u += 3;\n                break;\n            case ClassWriter.ITFMETH_INSN:\n            case ClassWriter.INDYMETH_INSN:\n                u += 5;\n                break;\n            // case MANA_INSN:\n            default:\n                u += 4;\n                break;\n            }\n        }\n\n        // reads the try catch entries to find the labels, and also visits them\n        for (int i = readUnsignedShort(u); i > 0; --i) {\n            Label start = readLabel(readUnsignedShort(u + 2), labels);\n            Label end = readLabel(readUnsignedShort(u + 4), labels);\n            Label handler = readLabel(readUnsignedShort(u + 6), labels);\n            String type = readUTF8(items[readUnsignedShort(u + 8)], c);\n            mv.visitTryCatchBlock(start, end, handler, type);\n            u += 8;\n        }\n        u += 2;\n\n        // reads the code attributes\n        int[] tanns = null; // start index of each visible type annotation\n        int[] itanns = null; // start index of each invisible type annotation\n        int tann = 0; // current index in tanns array\n        int itann = 0; // current index in itanns array\n        int ntoff = -1; // next visible type annotation code offset\n        int nitoff = -1; // next invisible type annotation code offset\n        int varTable = 0;\n        int varTypeTable = 0;\n        boolean zip = true;\n        boolean unzip = (context.flags & EXPAND_FRAMES) != 0;\n        int stackMap = 0;\n        int stackMapSize = 0;\n        int frameCount = 0;\n        Context frame = null;\n        Attribute attributes = null;\n\n        for (int i = readUnsignedShort(u); i > 0; --i) {\n            String attrName = readUTF8(u + 2, c);\n            if (\"LocalVariableTable\".equals(attrName)) {\n                if ((context.flags & SKIP_DEBUG) == 0) {\n                    varTable = u + 8;\n                    for (int j = readUnsignedShort(u + 8), v = u; j > 0; --j) {\n                        int label = readUnsignedShort(v + 10);\n                        if (labels[label] == null) {\n                            readLabel(label, labels).status |= Label.DEBUG;\n                        }\n                        label += readUnsignedShort(v + 12);\n                        if (labels[label] == null) {\n                            readLabel(label, labels).status |= Label.DEBUG;\n                        }\n                        v += 10;\n                    }\n                }\n            } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n                varTypeTable = u + 8;\n            } else if (\"LineNumberTable\".equals(attrName)) {\n                if ((context.flags & SKIP_DEBUG) == 0) {\n                    for (int j = readUnsignedShort(u + 8), v = u; j > 0; --j) {\n                        int label = readUnsignedShort(v + 10);\n                        if (labels[label] == null) {\n                            readLabel(label, labels).status |= Label.DEBUG;\n                        }\n                        Label l = labels[label];\n                        while (l.line > 0) {\n                            if (l.next == null) {\n                                l.next = new Label();\n                            }\n                            l = l.next;\n                        }\n                        l.line = readUnsignedShort(v + 12);\n                        v += 4;\n                    }\n                }\n            } else if (ANNOTATIONS\n                    && \"RuntimeVisibleTypeAnnotations\".equals(attrName)) {\n                tanns = readTypeAnnotations(mv, context, u + 8, true);\n                ntoff = tanns.length == 0 || readByte(tanns[0]) < 0x43 ? -1\n                        : readUnsignedShort(tanns[0] + 1);\n            } else if (ANNOTATIONS\n                    && \"RuntimeInvisibleTypeAnnotations\".equals(attrName)) {\n                itanns = readTypeAnnotations(mv, context, u + 8, false);\n                nitoff = itanns.length == 0 || readByte(itanns[0]) < 0x43 ? -1\n                        : readUnsignedShort(itanns[0] + 1);\n            } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n                if ((context.flags & SKIP_FRAMES) == 0) {\n                    stackMap = u + 10;\n                    stackMapSize = readInt(u + 4);\n                    frameCount = readUnsignedShort(u + 8);\n                }\n                /*\n                 * here we do not extract the labels corresponding to the\n                 * attribute content. This would require a full parsing of the\n                 * attribute, which would need to be repeated in the second\n                 * phase (see below). Instead the content of the attribute is\n                 * read one frame at a time (i.e. after a frame has been\n                 * visited, the next frame is read), and the labels it contains\n                 * are also extracted one frame at a time. Thanks to the\n                 * ordering of frames, having only a \"one frame lookahead\" is\n                 * not a problem, i.e. it is not possible to see an offset\n                 * smaller than the offset of the current insn and for which no\n                 * Label exist.\n                 */\n                /*\n                 * This is not true for UNINITIALIZED type offsets. We solve\n                 * this by parsing the stack map table without a full decoding\n                 * (see below).\n                 */\n            } else if (FRAMES && \"StackMap\".equals(attrName)) {\n                if ((context.flags & SKIP_FRAMES) == 0) {\n                    zip = false;\n                    stackMap = u + 10;\n                    stackMapSize = readInt(u + 4);\n                    frameCount = readUnsignedShort(u + 8);\n                }\n                /*\n                 * IMPORTANT! here we assume that the frames are ordered, as in\n                 * the StackMapTable attribute, although this is not guaranteed\n                 * by the attribute format.\n                 */\n            } else {\n                for (int j = 0; j < context.attrs.length; ++j) {\n                    if (context.attrs[j].type.equals(attrName)) {\n                        Attribute attr = context.attrs[j].read(this, u + 8,\n                                readInt(u + 4), c, codeStart - 8, labels);\n                        if (attr != null) {\n                            attr.next = attributes;\n                            attributes = attr;\n                        }\n                    }\n                }\n            }\n            u += 6 + readInt(u + 4);\n        }\n        u += 2;\n\n        // generates the first (implicit) stack map frame\n        if (FRAMES && stackMap != 0) {\n            /*\n             * for the first explicit frame the offset is not offset_delta + 1\n             * but only offset_delta; setting the implicit frame offset to -1\n             * allow the use of the \"offset_delta + 1\" rule in all cases\n             */\n            frame = context;\n            frame.offset = -1;\n            frame.mode = 0;\n            frame.localCount = 0;\n            frame.localDiff = 0;\n            frame.stackCount = 0;\n            frame.local = new Object[maxLocals];\n            frame.stack = new Object[maxStack];\n            if (unzip) {\n                getImplicitFrame(context);\n            }\n            /*\n             * Finds labels for UNINITIALIZED frame types. Instead of decoding\n             * each element of the stack map table, we look for 3 consecutive\n             * bytes that \"look like\" an UNINITIALIZED type (tag 8, offset\n             * within code bounds, NEW instruction at this offset). We may find\n             * false positives (i.e. not real UNINITIALIZED types), but this\n             * should be rare, and the only consequence will be the creation of\n             * an unneeded label. This is better than creating a label for each\n             * NEW instruction, and faster than fully decoding the whole stack\n             * map table.\n             */\n            for (int i = stackMap; i < stackMap + stackMapSize - 2; ++i) {\n                if (b[i] == 8) { // UNINITIALIZED FRAME TYPE\n                    int v = readUnsignedShort(i + 1);\n                    if (v >= 0 && v < codeLength) {\n                        if ((b[codeStart + v] & 0xFF) == Opcodes.NEW) {\n                            readLabel(v, labels);\n                        }\n                    }\n                }\n            }\n        }\n\n        // visits the instructions\n        u = codeStart;\n        while (u < codeEnd) {\n            int offset = u - codeStart;\n\n            // visits the label and line number for this offset, if any\n            Label l = labels[offset];\n            if (l != null) {\n                Label next = l.next;\n                l.next = null;\n                mv.visitLabel(l);\n                if ((context.flags & SKIP_DEBUG) == 0 && l.line > 0) {\n                    mv.visitLineNumber(l.line, l);\n                    while (next != null) {\n                        mv.visitLineNumber(next.line, l);\n                        next = next.next;\n                    }\n                }\n            }\n\n            // visits the frame for this offset, if any\n            while (FRAMES && frame != null\n                    && (frame.offset == offset || frame.offset == -1)) {\n                // if there is a frame for this offset, makes the visitor visit\n                // it, and reads the next frame if there is one.\n                if (frame.offset != -1) {\n                    if (!zip || unzip) {\n                        mv.visitFrame(Opcodes.F_NEW, frame.localCount,\n                                frame.local, frame.stackCount, frame.stack);\n                    } else {\n                        mv.visitFrame(frame.mode, frame.localDiff, frame.local,\n                                frame.stackCount, frame.stack);\n                    }\n                }\n                if (frameCount > 0) {\n                    stackMap = readFrame(stackMap, zip, unzip, frame);\n                    --frameCount;\n                } else {\n                    frame = null;\n                }\n            }\n\n            // visits the instruction at this offset\n            int opcode = b[u] & 0xFF;\n            switch (ClassWriter.TYPE[opcode]) {\n            case ClassWriter.NOARG_INSN:\n                mv.visitInsn(opcode);\n                u += 1;\n                break;\n            case ClassWriter.IMPLVAR_INSN:\n                if (opcode > Opcodes.ISTORE) {\n                    opcode -= 59; // ISTORE_0\n                    mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2),\n                            opcode & 0x3);\n                } else {\n                    opcode -= 26; // ILOAD_0\n                    mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                }\n                u += 1;\n                break;\n            case ClassWriter.LABEL_INSN:\n                mv.visitJumpInsn(opcode, labels[offset + readShort(u + 1)]);\n                u += 3;\n                break;\n            case ClassWriter.LABELW_INSN:\n                mv.visitJumpInsn(opcode - 33, labels[offset + readInt(u + 1)]);\n                u += 5;\n                break;\n            case ClassWriter.WIDE_INSN:\n                opcode = b[u + 1] & 0xFF;\n                if (opcode == Opcodes.IINC) {\n                    mv.visitIincInsn(readUnsignedShort(u + 2), readShort(u + 4));\n                    u += 6;\n                } else {\n                    mv.visitVarInsn(opcode, readUnsignedShort(u + 2));\n                    u += 4;\n                }\n                break;\n            case ClassWriter.TABL_INSN: {\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                int label = offset + readInt(u);\n                int min = readInt(u + 4);\n                int max = readInt(u + 8);\n                Label[] table = new Label[max - min + 1];\n                u += 12;\n                for (int i = 0; i < table.length; ++i) {\n                    table[i] = labels[offset + readInt(u)];\n                    u += 4;\n                }\n                mv.visitTableSwitchInsn(min, max, labels[label], table);\n                break;\n            }\n            case ClassWriter.LOOK_INSN: {\n                // skips 0 to 3 padding bytes\n                u = u + 4 - (offset & 3);\n                // reads instruction\n                int label = offset + readInt(u);\n                int len = readInt(u + 4);\n                int[] keys = new int[len];\n                Label[] values = new Label[len];\n                u += 8;\n                for (int i = 0; i < len; ++i) {\n                    keys[i] = readInt(u);\n                    values[i] = labels[offset + readInt(u + 4)];\n                    u += 8;\n                }\n                mv.visitLookupSwitchInsn(labels[label], keys, values);\n                break;\n            }\n            case ClassWriter.VAR_INSN:\n                mv.visitVarInsn(opcode, b[u + 1] & 0xFF);\n                u += 2;\n                break;\n            case ClassWriter.SBYTE_INSN:\n                mv.visitIntInsn(opcode, b[u + 1]);\n                u += 2;\n                break;\n            case ClassWriter.SHORT_INSN:\n                mv.visitIntInsn(opcode, readShort(u + 1));\n                u += 3;\n                break;\n            case ClassWriter.LDC_INSN:\n                mv.visitLdcInsn(readConst(b[u + 1] & 0xFF, c));\n                u += 2;\n                break;\n            case ClassWriter.LDCW_INSN:\n                mv.visitLdcInsn(readConst(readUnsignedShort(u + 1), c));\n                u += 3;\n                break;\n            case ClassWriter.FIELDORMETH_INSN:\n            case ClassWriter.ITFMETH_INSN: {\n                int cpIndex = items[readUnsignedShort(u + 1)];\n                boolean itf = b[cpIndex - 1] == ClassWriter.IMETH;\n                String iowner = readClass(cpIndex, c);\n                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                String iname = readUTF8(cpIndex, c);\n                String idesc = readUTF8(cpIndex + 2, c);\n                if (opcode < Opcodes.INVOKEVIRTUAL) {\n                    mv.visitFieldInsn(opcode, iowner, iname, idesc);\n                } else {\n                    mv.visitMethodInsn(opcode, iowner, iname, idesc, itf);\n                }\n                if (opcode == Opcodes.INVOKEINTERFACE) {\n                    u += 5;\n                } else {\n                    u += 3;\n                }\n                break;\n            }\n            case ClassWriter.INDYMETH_INSN: {\n                int cpIndex = items[readUnsignedShort(u + 1)];\n                int bsmIndex = context.bootstrapMethods[readUnsignedShort(cpIndex)];\n                Handle bsm = (Handle) readConst(readUnsignedShort(bsmIndex), c);\n                int bsmArgCount = readUnsignedShort(bsmIndex + 2);\n                Object[] bsmArgs = new Object[bsmArgCount];\n                bsmIndex += 4;\n                for (int i = 0; i < bsmArgCount; i++) {\n                    bsmArgs[i] = readConst(readUnsignedShort(bsmIndex), c);\n                    bsmIndex += 2;\n                }\n                cpIndex = items[readUnsignedShort(cpIndex + 2)];\n                String iname = readUTF8(cpIndex, c);\n                String idesc = readUTF8(cpIndex + 2, c);\n                mv.visitInvokeDynamicInsn(iname, idesc, bsm, bsmArgs);\n                u += 5;\n                break;\n            }\n            case ClassWriter.TYPE_INSN:\n                mv.visitTypeInsn(opcode, readClass(u + 1, c));\n                u += 3;\n                break;\n            case ClassWriter.IINC_INSN:\n                mv.visitIincInsn(b[u + 1] & 0xFF, b[u + 2]);\n                u += 3;\n                break;\n            // case MANA_INSN:\n            default:\n                mv.visitMultiANewArrayInsn(readClass(u + 1, c), b[u + 3] & 0xFF);\n                u += 4;\n                break;\n            }\n\n            // visit the instruction annotations, if any\n            while (tanns != null && tann < tanns.length && ntoff <= offset) {\n                if (ntoff == offset) {\n                    int v = readAnnotationTarget(context, tanns[tann]);\n                    readAnnotationValues(v + 2, c, true,\n                            mv.visitInsnAnnotation(context.typeRef,\n                                    context.typePath, readUTF8(v, c), true));\n                }\n                ntoff = ++tann >= tanns.length || readByte(tanns[tann]) < 0x43 ? -1\n                        : readUnsignedShort(tanns[tann] + 1);\n            }\n            while (itanns != null && itann < itanns.length && nitoff <= offset) {\n                if (nitoff == offset) {\n                    int v = readAnnotationTarget(context, itanns[itann]);\n                    readAnnotationValues(v + 2, c, true,\n                            mv.visitInsnAnnotation(context.typeRef,\n                                    context.typePath, readUTF8(v, c), false));\n                }\n                nitoff = ++itann >= itanns.length\n                        || readByte(itanns[itann]) < 0x43 ? -1\n                        : readUnsignedShort(itanns[itann] + 1);\n            }\n        }\n        if (labels[codeLength] != null) {\n            mv.visitLabel(labels[codeLength]);\n        }\n\n        // visits the local variable tables\n        if ((context.flags & SKIP_DEBUG) == 0 && varTable != 0) {\n            int[] typeTable = null;\n            if (varTypeTable != 0) {\n                u = varTypeTable + 2;\n                typeTable = new int[readUnsignedShort(varTypeTable) * 3];\n                for (int i = typeTable.length; i > 0;) {\n                    typeTable[--i] = u + 6; // signature\n                    typeTable[--i] = readUnsignedShort(u + 8); // index\n                    typeTable[--i] = readUnsignedShort(u); // start\n                    u += 10;\n                }\n            }\n            u = varTable + 2;\n            for (int i = readUnsignedShort(varTable); i > 0; --i) {\n                int start = readUnsignedShort(u);\n                int length = readUnsignedShort(u + 2);\n                int index = readUnsignedShort(u + 8);\n                String vsignature = null;\n                if (typeTable != null) {\n                    for (int j = 0; j < typeTable.length; j += 3) {\n                        if (typeTable[j] == start && typeTable[j + 1] == index) {\n                            vsignature = readUTF8(typeTable[j + 2], c);\n                            break;\n                        }\n                    }\n                }\n                mv.visitLocalVariable(readUTF8(u + 4, c), readUTF8(u + 6, c),\n                        vsignature, labels[start], labels[start + length],\n                        index);\n                u += 10;\n            }\n        }\n\n        // visits the local variables type annotations\n        if (tanns != null) {\n            for (int i = 0; i < tanns.length; ++i) {\n                if ((readByte(tanns[i]) >> 1) == (0x40 >> 1)) {\n                    int v = readAnnotationTarget(context, tanns[i]);\n                    v = readAnnotationValues(v + 2, c, true,\n                            mv.visitLocalVariableAnnotation(context.typeRef,\n                                    context.typePath, context.start,\n                                    context.end, context.index, readUTF8(v, c),\n                                    true));\n                }\n            }\n        }\n        if (itanns != null) {\n            for (int i = 0; i < itanns.length; ++i) {\n                if ((readByte(itanns[i]) >> 1) == (0x40 >> 1)) {\n                    int v = readAnnotationTarget(context, itanns[i]);\n                    v = readAnnotationValues(v + 2, c, true,\n                            mv.visitLocalVariableAnnotation(context.typeRef,\n                                    context.typePath, context.start,\n                                    context.end, context.index, readUTF8(v, c),\n                                    false));\n                }\n            }\n        }\n\n        // visits the code attributes\n        while (attributes != null) {\n            Attribute attr = attributes.next;\n            attributes.next = null;\n            mv.visitAttribute(attributes);\n            attributes = attr;\n        }\n\n        // visits the max stack and max locals values\n        mv.visitMaxs(maxStack, maxLocals);\n    }","commit_id":"ab5856b6a8d0ab2cd5f8fe906c7735eb9ba1a7ab","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public static void addImportDirective(@NotNull ImportPath importPath, @Nullable String aliasName, @NotNull JetFile file) {\n\n        if (QualifiedNamesUtil.getFirstSegment(importPath.fqnPart().getFqName()).equals(JavaDescriptorResolver.JAVA_ROOT)) {\n            FqName withoutJavaRoot = QualifiedNamesUtil.withoutFirstSegment(importPath.fqnPart());\n            importPath = new ImportPath(withoutJavaRoot, importPath.isAllUnder());\n        }\n\n        if (isImportedByDefault(importPath, aliasName, JetPsiUtil.getFQName(file))) {\n            return;\n        }\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importPath, aliasName);\n\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        if (!importDirectives.isEmpty()) {\n            \n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                ImportPath existentImportPath = JetPsiUtil.getImportPath(directive);\n                if (directive.getAliasName() == null && aliasName == null) {\n                    if (existentImportPath != null && QualifiedNamesUtil.isImported(existentImportPath, importPath)) {\n                        return;\n                    }\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n        }\n        else {\n            List<JetDeclaration> declarations = file.getDeclarations();\n\n            if (!declarations.isEmpty()) {\n                JetDeclaration firstDeclaration = declarations.iterator().next();\n                firstDeclaration.getParent().addBefore(newDirective, firstDeclaration);\n            }\n            else {\n                file.getNamespaceHeader().getParent().addAfter(newDirective, file.getNamespaceHeader());\n            }\n        }\n    }","id":32599,"modified_method":"public static void addImportDirective(@NotNull ImportPath importPath, @Nullable String aliasName, @NotNull JetFile file) {\n\n        if (QualifiedNamesUtil.getFirstSegment(importPath.fqnPart().getFqName()).equals(JavaDescriptorResolver.JAVA_ROOT)) {\n            FqName withoutJavaRoot = QualifiedNamesUtil.withoutFirstSegment(importPath.fqnPart());\n            importPath = new ImportPath(withoutJavaRoot, importPath.isAllUnder());\n        }\n\n        if (isImportedByDefault(importPath, aliasName, JetPsiUtil.getFQName(file))) {\n            return;\n        }\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importPath, aliasName);\n\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        if (!importDirectives.isEmpty()) {\n            \n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                ImportPath existentImportPath = JetPsiUtil.getImportPath(directive);\n                if (directive.getAliasName() == null && aliasName == null) {\n                    if (existentImportPath != null && QualifiedNamesUtil.isImported(existentImportPath, importPath)) {\n                        return;\n                    }\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n        }\n        else {\n            file.getNamespaceHeader().getParent().addAfter(newDirective, file.getNamespaceHeader());\n        }\n    }","commit_id":"856c05b2a8066b170d81997f69c695c2e3fe3336","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n                .between(IMPORT_DIRECTIVE, OBJECT_DECLARATION).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .around(TokenSet.create(PLUS, MINUS)).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                // TODO: Ask for better API\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                ;\n    }","id":32600,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_DIRECTIVE).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .around(TokenSet.create(PLUS, MINUS)).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                // TODO: Ask for better API\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                ;\n    }","commit_id":"856c05b2a8066b170d81997f69c695c2e3fe3336","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Runnable processFile(final PsiFile file) {\n        return new Runnable() {\n\n            @Override\n            public void run() {\n                final JetFile jetFile = (JetFile) file;\n                final Set<FqName> usedQualifiedNames = extractUsedQualifiedNames(jetFile);\n\n                final List<JetImportDirective> sortedDirectives = jetFile.getImportDirectives();\n                Collections.sort(sortedDirectives, new Comparator<JetImportDirective>() {\n                    @Override\n                    public int compare(JetImportDirective directive1, JetImportDirective directive2) {\n                        ImportPath firstPath = JetPsiUtil.getImportPath(directive1);\n                        ImportPath secondPath = JetPsiUtil.getImportPath(directive2);\n\n                        if (firstPath == null || secondPath == null) {\n                            return firstPath == null && secondPath == null ? 0 :\n                                   firstPath == null ? -1 :\n                                   1;\n                        }\n\n                        // import bla.bla.bla.* should be before import bla.bla.bla.something\n                        if (firstPath.isAllUnder() && !secondPath.isAllUnder() && firstPath.fqnPart().equals(secondPath.fqnPart().parent())) {\n                            return -1;\n                        }\n\n                        if (!firstPath.isAllUnder() && secondPath.isAllUnder() && secondPath.fqnPart().equals(firstPath.fqnPart().parent())) {\n                            return 1;\n                        }\n\n                        return firstPath.getPathStr().compareTo(secondPath.getPathStr());\n                    }\n                });\n\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        // Remove imports\n                        List<JetImportDirective> imports = jetFile.getImportDirectives();\n                        if (!imports.isEmpty()) {\n                            jetFile.deleteChildRange(imports.get(0), imports.get(imports.size() - 1));\n                        }\n\n                        // Insert back only necessary imports in correct order\n                        for (JetImportDirective anImport : sortedDirectives) {\n                            ImportPath importPath = JetPsiUtil.getImportPath(anImport);\n                            if (importPath == null) {\n                                continue;\n                            }\n\n                            if (isUseful(importPath, anImport.getAliasName(), usedQualifiedNames)) {\n                                ImportInsertHelper.addImportDirective(importPath, anImport.getAliasName(), jetFile);\n                            }\n                        }\n                    }\n                });\n            }\n        };\n    }","id":32601,"modified_method":"@NotNull\n    @Override\n    public Runnable processFile(final PsiFile file) {\n        return new Runnable() {\n\n            @Override\n            public void run() {\n                final JetFile jetFile = (JetFile) file;\n                final Set<FqName> usedQualifiedNames = extractUsedQualifiedNames(jetFile);\n\n                final List<JetImportDirective> sortedDirectives = jetFile.getImportDirectives();\n                Collections.sort(sortedDirectives, new Comparator<JetImportDirective>() {\n                    @Override\n                    public int compare(JetImportDirective directive1, JetImportDirective directive2) {\n                        ImportPath firstPath = JetPsiUtil.getImportPath(directive1);\n                        ImportPath secondPath = JetPsiUtil.getImportPath(directive2);\n\n                        if (firstPath == null || secondPath == null) {\n                            return firstPath == null && secondPath == null ? 0 :\n                                   firstPath == null ? -1 :\n                                   1;\n                        }\n\n                        // import bla.bla.bla.* should be before import bla.bla.bla.something\n                        if (firstPath.isAllUnder() && !secondPath.isAllUnder() && firstPath.fqnPart().equals(secondPath.fqnPart().parent())) {\n                            return -1;\n                        }\n\n                        if (!firstPath.isAllUnder() && secondPath.isAllUnder() && secondPath.fqnPart().equals(firstPath.fqnPart().parent())) {\n                            return 1;\n                        }\n\n                        return firstPath.getPathStr().compareTo(secondPath.getPathStr());\n                    }\n                });\n\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        // Remove imports\n                        List<JetImportDirective> imports = jetFile.getImportDirectives();\n                        if (!imports.isEmpty()) {\n                            jetFile.deleteChildRange(\n                                    getWithPreviousWhitespaces(imports.get(0)),\n                                    getWithFollowedWhitespaces(imports.get(imports.size() - 1)));\n                        }\n\n                        // Insert back only necessary imports in correct order\n                        for (JetImportDirective anImport : sortedDirectives) {\n                            ImportPath importPath = JetPsiUtil.getImportPath(anImport);\n                            if (importPath == null) {\n                                continue;\n                            }\n\n                            if (isUseful(importPath, anImport.getAliasName(), usedQualifiedNames)) {\n                                ImportInsertHelper.addImportDirective(importPath, anImport.getAliasName(), jetFile);\n                            }\n                        }\n                    }\n                });\n            }\n        };\n    }","commit_id":"856c05b2a8066b170d81997f69c695c2e3fe3336","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void updateStatsUser(long groupId, long userId, Date displayDate)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tint entryCount = blogsEntryPersistence.countByG_U_LtD_S(\n\t\t\tgroupId, userId, now, WorkflowConstants.STATUS_APPROVED);\n\n\t\tif (entryCount == 0) {\n\t\t\ttry {\n\t\t\t\tblogsStatsUserPersistence.removeByG_U(groupId, userId);\n\t\t\t}\n\t\t\tcatch (NoSuchStatsUserException nssue) {\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tBlogsStatsUser statsUser = getStatsUser(groupId, userId);\n\n\t\tstatsUser.setEntryCount(entryCount);\n\n\t\tBlogsEntry blogsEntry = blogsEntryPersistence.findByG_U_LtD_S_First(\n\t\t\tgroupId, userId, now, WorkflowConstants.STATUS_APPROVED,\n\t\t\tnew EntryDisplayDateComparator());\n\n\t\tDate lastDisplayDate = blogsEntry.getDisplayDate();\n\n\t\tDate lastPostDate = statsUser.getLastPostDate();\n\n\t\tif ((displayDate != null) && displayDate.before(now)) {\n\t\t\tif (lastPostDate == null) {\n\t\t\t\tstatsUser.setLastPostDate(displayDate);\n\t\t\t}\n\t\t\telse if (displayDate.after(lastPostDate)) {\n\t\t\t\tstatsUser.setLastPostDate(displayDate);\n\t\t\t}\n\t\t\telse if (lastDisplayDate.before(lastPostDate)) {\n\t\t\t\tstatsUser.setLastPostDate(lastDisplayDate);\n\t\t\t}\n\t\t}\n\t\telse if (displayDate == null) {\n\t\t\tif (lastPostDate == null) {\n\t\t\t\tstatsUser.setLastPostDate(lastDisplayDate);\n\t\t\t}\n\t\t\telse if (lastPostDate.before(lastDisplayDate)) {\n\t\t\t\tstatsUser.setLastPostDate(lastDisplayDate);\n\t\t\t}\n\t\t}\n\n\t\tblogsStatsUserPersistence.update(statsUser, false);\n\t}","id":32602,"modified_method":"public void updateStatsUser(long groupId, long userId, Date displayDate)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tint entryCount = blogsEntryPersistence.countByG_U_LtD_S(\n\t\t\tgroupId, userId, now, WorkflowConstants.STATUS_APPROVED);\n\n\t\tif (entryCount == 0) {\n\t\t\ttry {\n\t\t\t\tblogsStatsUserPersistence.removeByG_U(groupId, userId);\n\t\t\t}\n\t\t\tcatch (NoSuchStatsUserException nssue) {\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tBlogsStatsUser statsUser = getStatsUser(groupId, userId);\n\n\t\tstatsUser.setEntryCount(entryCount);\n\n\t\tBlogsEntry blogsEntry = blogsEntryPersistence.findByG_U_LtD_S_First(\n\t\t\tgroupId, userId, now, WorkflowConstants.STATUS_APPROVED,\n\t\t\tnew EntryDisplayDateComparator());\n\n\t\tDate lastDisplayDate = blogsEntry.getDisplayDate();\n\n\t\tDate lastPostDate = statsUser.getLastPostDate();\n\n\t\tif ((displayDate != null) && displayDate.before(now)) {\n\t\t\tif (lastPostDate == null) {\n\t\t\t\tstatsUser.setLastPostDate(displayDate);\n\t\t\t}\n\t\t\telse if (displayDate.after(lastPostDate)) {\n\t\t\t\tstatsUser.setLastPostDate(displayDate);\n\t\t\t}\n\t\t\telse if (lastDisplayDate.before(lastPostDate)) {\n\t\t\t\tstatsUser.setLastPostDate(lastDisplayDate);\n\t\t\t}\n\t\t}\n\t\telse if ((lastPostDate == null) ||\n\t\t\t\t lastPostDate.before(lastDisplayDate)) {\n\n\t\t\tstatsUser.setLastPostDate(lastDisplayDate);\n\t\t}\n\n\t\tblogsStatsUserPersistence.update(statsUser, false);\n\t}","commit_id":"6c75e6a565452d6a1241d2930cd430f8e13232a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Add import directive into the PSI tree for the given namespace.\n     *\n     * @param importString full name of the import. Can contain .* if necessary.\n     * @param file File where directive should be added.\n     */\n    public static void addImportDirective(@NotNull String importString, @NotNull JetFile file) {\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importString);\n\n        // TODO: Should be processed with formatter\n        final PsiElement newLineWhitespace = JetPsiFactory.createWhiteSpace(file.getProject(), \"\\n\");\n        final PsiElement doubleLineWhitespace = JetPsiFactory.createWhiteSpace(file.getProject(), \"\\n\\n\");\n\n        if (!importDirectives.isEmpty()) {\n\n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                if (directive.getText().endsWith(importString) || directive.getText().endsWith(importString + \";\")) {\n                    return;\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n            lastDirective.getParent().addAfter(newLineWhitespace, lastDirective);\n        }\n        else {\n            List<JetDeclaration> declarations = file.getDeclarations();\n            assert !declarations.isEmpty();\n            JetDeclaration firstDeclaration = declarations.iterator().next();\n            firstDeclaration.getParent().addBefore(newDirective, firstDeclaration);\n            firstDeclaration.getParent().addBefore(doubleLineWhitespace, firstDeclaration);\n        }\n    }","id":32603,"modified_method":"/**\n     * Add import directive into the PSI tree for the given namespace.\n     *\n     * @param importString full name of the import. Can contain .* if necessary.\n     * @param file File where directive should be added.\n     */\n    public static void addImportDirective(@NotNull String importString, @NotNull JetFile file) {\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importString);\n\n        if (!importDirectives.isEmpty()) {\n\n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                if (directive.getText().endsWith(importString) || directive.getText().endsWith(importString + \";\")) {\n                    return;\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n        }\n        else {\n            List<JetDeclaration> declarations = file.getDeclarations();\n            assert !declarations.isEmpty();\n            JetDeclaration firstDeclaration = declarations.iterator().next();\n            firstDeclaration.getParent().addBefore(newDirective, firstDeclaration);\n        }\n    }","commit_id":"2cde87525e6863e8793a3444ad182e3f06fb159a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        return new SpacingBuilder(settings)\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode();\n    }","id":32604,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        return new SpacingBuilder(settings)\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode();\n    }","commit_id":"2cde87525e6863e8793a3444ad182e3f06fb159a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void generateMethods(Project project, Editor editor, JetClassOrObject classOrObject, List<DescriptorClassMember> selectedElements) {\n        final JetClassBody body = classOrObject.getBody();\n        if (body == null) {\n            return;\n        }\n\n        final PsiElement newLineWhitespace = JetPsiFactory.createWhiteSpace(body.getProject(), \"\\n\");\n\n        for (DescriptorClassMember selectedElement : selectedElements) {\n\n            // TODO: Insert spaces should be done by formatter\n            body.addBefore(newLineWhitespace, body.getRBrace());\n\n            final DeclarationDescriptor descriptor = selectedElement.getDescriptor();\n            if (descriptor instanceof NamedFunctionDescriptor) {\n                JetElement target = overrideFunction(project, (NamedFunctionDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n            else if (descriptor instanceof PropertyDescriptor) {\n                JetElement target = overrideProperty(project, (PropertyDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n        }\n    }","id":32605,"modified_method":"public static void generateMethods(Project project, Editor editor, JetClassOrObject classOrObject, List<DescriptorClassMember> selectedElements) {\n        final JetClassBody body = classOrObject.getBody();\n        if (body == null) {\n            return;\n        }\n\n       for (DescriptorClassMember selectedElement : selectedElements) {\n            final DeclarationDescriptor descriptor = selectedElement.getDescriptor();\n            if (descriptor instanceof NamedFunctionDescriptor) {\n                JetElement target = overrideFunction(project, (NamedFunctionDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n            else if (descriptor instanceof PropertyDescriptor) {\n                JetElement target = overrideProperty(project, (PropertyDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n        }\n    }","commit_id":"2cde87525e6863e8793a3444ad182e3f06fb159a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountAndFilterWordApp\")\n      .setDescription(\"\")\n      .withStreams()\n      .add(new Stream(\"text\"))\n      .withDataSets()\n      .add(new KeyValueTable(Common.counterTableName))\n      .withFlows()\n        .add(new CountAndFilterWordFlow())\n      .noProcedure()\n      .build();\n  }","id":32606,"modified_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountAndFilterWordApp\")\n      .setDescription(\"\")\n      .withStreams()\n      .add(new Stream(\"text\"))\n      .withDataSets()\n      .add(new KeyValueTable(Common.counterTableName))\n      .withFlows()\n        .add(new CountAndFilterWordFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"c37e2107c946a528fe6f4746b1714c10e414cdee","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by\n   * returning an {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"DumbProgrammerApp$$$%\")\n      .setDescription(\"Told the name should be an Id\")\n      .noStream()\n      .noDataSet()\n      .noFlow()\n      .noProcedure()\n      .build();\n  }","id":32607,"modified_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by\n   * returning an {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"DumbProgrammerApp$$$%\")\n      .setDescription(\"Told the name should be an Id\")\n      .noStream()\n      .noDataSet()\n      .noFlow()\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"c37e2107c946a528fe6f4746b1714c10e414cdee","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountRandomApp\")\n      .setDescription(\"Count Random Application\")\n      .noStream()\n      .withDataSets().add(new Table(\"counters\"))\n      .withFlows().add(new CountRandom())\n      .noProcedure()\n      .build();\n  }","id":32608,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountRandomApp\")\n      .setDescription(\"Count Random Application\")\n      .noStream()\n      .withDataSets().add(new Table(\"counters\"))\n      .withFlows().add(new CountRandom())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"c37e2107c946a528fe6f4746b1714c10e414cdee","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an\n   * {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"ToyApp\")\n      .setDescription(\"Toy Flow Application\")\n      .withStreams().add(new Stream(\"X\")).add(new Stream(\"Y\"))\n      .withDataSets().add(new KeyValueTable(\"data1\"))\n      .withFlows().add(new ToyFlow())\n      .noProcedure().build();\n  }","id":32609,"modified_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an\n   * {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"ToyApp\")\n      .setDescription(\"Toy Flow Application\")\n      .withStreams().add(new Stream(\"X\")).add(new Stream(\"Y\"))\n      .withDataSets().add(new KeyValueTable(\"data1\"))\n      .withFlows().add(new ToyFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"c37e2107c946a528fe6f4746b1714c10e414cdee","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an\n   * {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"WebCrawlerApp\")\n      .setDescription(\"Web Crawler Application\")\n      .withStreams().add(new Stream(\"urls\"))\n      .withDataSets().add(new KeyValueTable(\"crawled-pages\"))\n      .withFlows().add(new CrawlFlow())\n      .noProcedure().build();\n  }","id":32610,"modified_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an\n   * {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"WebCrawlerApp\")\n      .setDescription(\"Web Crawler Application\")\n      .withStreams().add(new Stream(\"urls\"))\n      .withDataSets().add(new KeyValueTable(\"crawled-pages\"))\n      .withFlows().add(new CrawlFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"c37e2107c946a528fe6f4746b1714c10e414cdee","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an\n   * {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"WordCountApp\")\n      .setDescription(\"Application for counting words\")\n      .withStreams().add(new Stream(\"text\"))\n      .withDataSets().add(new KeyValueTable(\"mydataset\"))\n      .withFlows().add(new WordCountFlow())\n      .withProcedures().add(new WordFrequency()).build();\n  }","id":32611,"modified_method":"/**\n   * Configures the {@link com.continuuity.api.Application} by returning an\n   * {@link com.continuuity.api.ApplicationSpecification}\n   *\n   * @return An instance of {@code ApplicationSpecification}.\n   */\n  @Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"WordCountApp\")\n      .setDescription(\"Application for counting words\")\n      .withStreams().add(new Stream(\"text\"))\n      .withDataSets().add(new KeyValueTable(\"mydataset\"))\n      .withFlows().add(new WordCountFlow())\n      .withProcedures().add(new WordFrequency()).noBatch().build();\n  }","commit_id":"c37e2107c946a528fe6f4746b1714c10e414cdee","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountAndFilterWords\")\n      .setDescription(\"Example word filter and count application\")\n      .withStreams()\n        .add(new Stream(\"text\"))\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new CountAndFilterWordsFlow())\n      .noProcedure()\n      .build();\n  }","id":32612,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountAndFilterWords\")\n      .setDescription(\"Example word filter and count application\")\n      .withStreams()\n        .add(new Stream(\"text\"))\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new CountAndFilterWordsFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountCounts\")\n      .setDescription(\"Application for counting counts of words\")\n      .withStreams()\n        .add(new Stream(\"text\"))\n      .withDataSets()\n        .add(new CountCounterTable(tableName))\n      .withFlows()\n        .add(new CountCountsFlow())\n      .withProcedures()\n        .add(new CountCountsProcedure())\n      .build();\n  }","id":32613,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountCounts\")\n      .setDescription(\"Application for counting counts of words\")\n      .withStreams()\n        .add(new Stream(\"text\"))\n      .withDataSets()\n        .add(new CountCounterTable(tableName))\n      .withFlows()\n        .add(new CountCountsFlow())\n      .withProcedures()\n        .add(new CountCountsProcedure())\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountOddAndEven\")\n      .setDescription(\"Example application that counts odd and even \" +\n          \"random numbers\")\n      .noStream()\n      .noDataSet()\n      .withFlows()\n        .add(new CountOddAndEvenFlow())\n      .noProcedure()\n      .build();\n  }","id":32614,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountOddAndEven\")\n      .setDescription(\"Example application that counts odd and even \" +\n          \"random numbers\")\n      .noStream()\n      .noDataSet()\n      .withFlows()\n        .add(new CountOddAndEvenFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountRandom\")\n      .setDescription(\"Example random count application\")\n      .noStream()\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new CountRandomFlow())\n      .noProcedure()\n      .build();\n  }","id":32615,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountRandom\")\n      .setDescription(\"Example random count application\")\n      .noStream()\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new CountRandomFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountTokens\")\n      .setDescription(\"Example applicaiton that counts tokens\")\n      .withStreams()\n        .add(new Stream(\"text\"))\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new CountTokensFlow())\n      .noProcedure()\n      .build();\n  }","id":32616,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountTokens\")\n      .setDescription(\"Example applicaiton that counts tokens\")\n      .withStreams()\n        .add(new Stream(\"text\"))\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new CountTokensFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with().\n      setName(\"HelloWorld\").\n      setDescription(\"A Hello World program for the App Fabric\").\n      withStreams().add(new Stream(\"who\")).\n      withDataSets().add(new KeyValueTable(\"whom\")).\n      withFlows().add(new WhoFlow()).\n      withProcedures().add(new Greeting()).\n      build();\n  }","id":32617,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with().\n      setName(\"HelloWorld\").\n      setDescription(\"A Hello World program for the App Fabric\").\n      withStreams().add(new Stream(\"who\")).\n      withDataSets().add(new KeyValueTable(\"whom\")).\n      withFlows().add(new WhoFlow()).\n      withProcedures().add(new Greeting()).\n      noBatch().\n      build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n        .setName(APP_NAME)\n        .setDescription(APP_DESC)\n        .withStreams()\n          .add(new Stream(SOCIAL_ACTION_STREAM))\n          .add(new Stream(CLUSTER_STREAM))\n        .withDataSets()\n          .add(new ActivityFeedTable(ACTIVITY_FEED_TABLE))\n          .add(new ClusterTable(CLUSTER_TABLE))\n          .add(new CounterTable(COUNTER_TABLE))\n          .add(new SortedCounterTable(SORTED_COUNTER_TABLE))\n          .add(new CounterTable(PRODUCT_ACTION_TABLE))\n          .add(new CounterTable(ALL_TIME_SCORE_TABLE))\n          .add(new SortedCounterTable(TOP_SCORE_TABLE))\n        .withFlows()\n          .add(new SocialActionFlow())\n          .add(new ClusterWriterFlow())\n        .withProcedures()\n          .add(new ClusterFeedQueryProvider())\n        .build();\n  }","id":32618,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n        .setName(APP_NAME)\n        .setDescription(APP_DESC)\n        .withStreams()\n          .add(new Stream(SOCIAL_ACTION_STREAM))\n          .add(new Stream(CLUSTER_STREAM))\n        .withDataSets()\n          .add(new ActivityFeedTable(ACTIVITY_FEED_TABLE))\n          .add(new ClusterTable(CLUSTER_TABLE))\n          .add(new CounterTable(COUNTER_TABLE))\n          .add(new SortedCounterTable(SORTED_COUNTER_TABLE))\n          .add(new CounterTable(PRODUCT_ACTION_TABLE))\n          .add(new CounterTable(ALL_TIME_SCORE_TABLE))\n          .add(new SortedCounterTable(TOP_SCORE_TABLE))\n        .withFlows()\n          .add(new SocialActionFlow())\n          .add(new ClusterWriterFlow())\n        .withProcedures()\n          .add(new ClusterFeedQueryProvider())\n        .noBatch()\n        .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"SimpleWriteAndRead\")\n      .setDescription(\"Flow that writes key=value then reads back the key\")\n      .withStreams()\n        .add(new Stream(\"keyValues\"))\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new SimpleWriteAndReadFlow())\n      .noProcedure()\n      .build();\n  }","id":32619,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"SimpleWriteAndRead\")\n      .setDescription(\"Flow that writes key=value then reads back the key\")\n      .withStreams()\n        .add(new Stream(\"keyValues\"))\n      .withDataSets()\n        .add(new KeyValueTable(tableName))\n      .withFlows()\n        .add(new SimpleWriteAndReadFlow())\n      .noProcedure()\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"TwitterScanner\")\n      .setDescription(\"Example Twitter application\")\n      .noStream()\n      .withDataSets()\n        .add(new SortedCounterTable(topUsers,\n            new SortedCounterTable.SortedCounterConfig()))\n        .add(new SortedCounterTable(topHashTags,\n            new SortedCounterTable.SortedCounterConfig()))\n        .add(new CounterTable(wordCounts))\n        .add(new CounterTable(hashTagWordAssocs))\n      .withFlows()\n        .add(new TwitterFlow())\n      .withProcedures()\n        .add(new TwitterProcedure())\n      .build();\n  }","id":32620,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"TwitterScanner\")\n      .setDescription(\"Example Twitter application\")\n      .noStream()\n      .withDataSets()\n        .add(new SortedCounterTable(topUsers,\n            new SortedCounterTable.SortedCounterConfig()))\n        .add(new SortedCounterTable(topHashTags,\n            new SortedCounterTable.SortedCounterConfig()))\n        .add(new CounterTable(wordCounts))\n        .add(new CounterTable(hashTagWordAssocs))\n      .withFlows()\n        .add(new TwitterFlow())\n      .withProcedures()\n        .add(new TwitterProcedure())\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"WordCount\")\n      .setDescription(\"Example Word Count Application\")\n      .withStreams()\n        .add(new Stream(\"wordStream\"))\n      .withDataSets()\n        .add(new Table(\"wordStats\"))\n        .add(new KeyValueTable(\"wordCounts\"))\n        .add(new UniqueCountTable(\"uniqueCount\"))\n        .add(new AssociationTable(\"wordAssocs\"))\n      .withFlows()\n        .add(new WordCounter())\n      .withProcedures()\n        .add(new RetrieveCounts())\n      .build();\n  }","id":32621,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"WordCount\")\n      .setDescription(\"Example Word Count Application\")\n      .withStreams()\n        .add(new Stream(\"wordStream\"))\n      .withDataSets()\n        .add(new Table(\"wordStats\"))\n        .add(new KeyValueTable(\"wordCounts\"))\n        .add(new UniqueCountTable(\"uniqueCount\"))\n        .add(new AssociationTable(\"wordAssocs\"))\n      .withFlows()\n        .add(new WordCounter())\n      .withProcedures()\n        .add(new RetrieveCounts())\n      .noBatch()\n      .build();\n  }","commit_id":"84a5b2d37e1575b8343720cde7f932a2b71148ab","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Go over the Document and make sure that there are no two contiguous text nodes so as to ensure that XPath\n     * expressions run correctly. As per XPath 1.0 (http://www.w3.org/TR/xpath):\n     *\n     * \"As much character data as possible is grouped into each text node: a text node never has an immediately\n     * following or preceding sibling that is a text node. \"\n     *\n     * @param document  Document to normalize\n     * @return          normalized Document (the same Document object, but children text nodes may have been adjusted)\n     */\n    public static Document normalizeTextNodes(Document document) {\n        final List nodesToDetatch = new ArrayList();\n        document.accept(new VisitorSupport() {\n            public void visit(Element element) {\n                final List children = element.content();\n                Node previousNode = null;\n                StringBuffer sb = null;\n                for (Iterator i = children.iterator(); i.hasNext();) {\n                    final Node currentNode = (Node) i.next();\n                    if (previousNode != null) {\n                        if (previousNode instanceof Text && currentNode instanceof Text) {\n                            final Text previousNodeText = (Text) previousNode;\n                            if (sb == null)\n                                sb = new StringBuffer(previousNodeText.getText());\n                            sb.append(((Text) currentNode).getText());\n                            nodesToDetatch.add(currentNode);\n                        } else if (previousNode instanceof Text && !(currentNode instanceof Text)) {\n                            // Update node if needed\n                            if (sb != null) {\n                                previousNode.setText(sb.toString());\n                            }\n                            previousNode = currentNode;\n                            sb = null;\n                        } else {\n                            previousNode = currentNode;\n                            sb = null;\n                        }\n                    } else {\n                        previousNode = currentNode;\n                        sb = null;\n                    }\n                }\n                // Update node if needed\n                if (previousNode != null && sb != null) {\n                    previousNode.setText(sb.toString());\n                }\n            }\n        });\n        // Detach nodes in the end so as to not confuse the acceptor above\n        for (Iterator i = nodesToDetatch.iterator(); i.hasNext();) {\n            final Node currentNode = (Node) i.next();\n            currentNode.detach();\n        }\n\n        return document;\n    }","id":32622,"modified_method":"/**\n     * Go over the Node and its children and make sure that there are no two contiguous text nodes so as to ensure that\n     * XPath expressions run correctly. As per XPath 1.0 (http://www.w3.org/TR/xpath):\n     *\n     * \"As much character data as possible is grouped into each text node: a text node never has an immediately\n     * following or preceding sibling that is a text node. \"\n     *\n     * @param nodeToNormalize Node hiearchy to normalize\n     * @return                the input node, normalized\n     */\n    public static Node normalizeTextNodes(Node nodeToNormalize) {\n        final List nodesToDetatch = new ArrayList();\n        nodeToNormalize.accept(new VisitorSupport() {\n            public void visit(Element element) {\n                final List children = element.content();\n                Node previousNode = null;\n                StringBuffer sb = null;\n                for (Iterator i = children.iterator(); i.hasNext();) {\n                    final Node currentNode = (Node) i.next();\n                    if (previousNode != null) {\n                        if (previousNode instanceof Text && currentNode instanceof Text) {\n                            final Text previousNodeText = (Text) previousNode;\n                            if (sb == null)\n                                sb = new StringBuffer(previousNodeText.getText());\n                            sb.append(((Text) currentNode).getText());\n                            nodesToDetatch.add(currentNode);\n                        } else if (previousNode instanceof Text && !(currentNode instanceof Text)) {\n                            // Update node if needed\n                            if (sb != null) {\n                                previousNode.setText(sb.toString());\n                            }\n                            previousNode = currentNode;\n                            sb = null;\n                        } else {\n                            previousNode = currentNode;\n                            sb = null;\n                        }\n                    } else {\n                        previousNode = currentNode;\n                        sb = null;\n                    }\n                }\n                // Update node if needed\n                if (previousNode != null && sb != null) {\n                    previousNode.setText(sb.toString());\n                }\n            }\n        });\n        // Detach nodes only in the end so as to not confuse the acceptor above\n        for (Iterator i = nodesToDetatch.iterator(); i.hasNext();) {\n            final Node currentNode = (Node) i.next();\n            currentNode.detach();\n        }\n\n        return nodeToNormalize;\n    }","commit_id":"08faf65d4dd345d3cd404f89b1ee60ed2aafc64e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        final String atAttribute = actionElement.attributeValue(\"at\");\n        final String positionAttribute = actionElement.attributeValue(\"position\");\n        final String originAttribute = actionElement.attributeValue(\"origin\");\n        final String contextAttribute = actionElement.attributeValue(\"context\");\n\n        final XFormsControls.BindingContext curBindingContext = xformsControls.getCurrentBindingContext();\n\n        // \"2. The Node Set Binding node-set is determined.\"\n        final List collectionToBeUpdated = curBindingContext.isNewBind() ? curBindingContext.getNodeset() : Collections.EMPTY_LIST;\n        final boolean isEmptyNodesetBinding = collectionToBeUpdated == null || collectionToBeUpdated.size() == 0;\n\n        // \"1. The insert context is determined.\"\n\n        // \"The insert action is terminated with no effect if [...] a. The context attribute is not given and the Node\n        // Set Binding node-set is the empty node-set.\"\n        if (contextAttribute == null && isEmptyNodesetBinding)\n            return;\n\n        // Now that we have evaluated the nodeset, restore context to in-scope evaluation context\n        xformsControls.popBinding();\n\n        // Handle @context attribute\n        actionInterpreter.pushContextAttributeIfNeeded(pipelineContext, actionElement);\n\n        // We are now in the insert context\n        final NodeInfo insertContextNode;\n        {\n            final List insertContextNodeset = xformsControls.getCurrentNodeset();\n\n            // \"If the result is an empty nodeset or not a nodeset, then the insert action is terminated with no effect. \"\n            if (insertContextNodeset == null || insertContextNodeset.size() == 0 || !(insertContextNodeset.get(0) instanceof NodeInfo))\n                return;\n\n            insertContextNode = xformsControls.getCurrentSingleNode();\n        }\n\n        // \"The insert action is terminated with no effect if [...] b. The context attribute is given, the insert\n        // context does not evaluate to an element node and the Node Set Binding node-set is the empty node-set.\"\n        if (contextAttribute != null && insertContextNode.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && isEmptyNodesetBinding)\n            return;\n\n        {\n            // \"3. The origin node-set is determined.\"\n            // \"5. Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n            final List sourceNodes;\n            final List clonedNodes;\n            {\n                final List clonedNodesTemp;\n                if (originAttribute == null) {\n                    // There is no @origin attribute, use node from Node Set Binding node-set\n\n                    // \"If the origin attribute is not given and the Node Set Binding node-set is empty, then the origin\n                    // node-set is the empty node-set. [...] The insert action is terminated with no effect if the\n                    // origin node-set is the empty node-set.\"\n\n                    if (isEmptyNodesetBinding)\n                        return;\n\n                    // \"Otherwise, if the origin attribute is not given, then the origin node-set consists of the last\n                    // node of the Node Set Binding node-set.\"\n                    final Node singleSourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1), CANNOT_INSERT_READONLY_MESSAGE);\n                    final Node singleClonedNode = (singleSourceNode instanceof Element) ? ((Node) ((Element) singleSourceNode).createCopy()) : (Node) singleSourceNode.clone();\n\n                    sourceNodes = Collections.singletonList(singleSourceNode);\n                    clonedNodesTemp = Collections.singletonList(singleClonedNode);\n                } else {\n                    // There is an @origin attribute\n\n                    // \"If the origin attribute is given, the origin node-set is the result of the evaluation of the\n                    // origin attribute in the insert context.\"\n\n                    final List originObjects = containingDocument.getEvaluator().evaluate(pipelineContext, insertContextNode,\n                        originAttribute, Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // \"The insert action is terminated with no effect if the origin node-set is the empty node-set.\"\n                    if (originObjects.size() == 0)\n                        return;\n\n                    // \"Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n\n                    sourceNodes = new ArrayList(originObjects.size()); // set to max possible size\n                    clonedNodesTemp = new ArrayList(originObjects.size());\n\n                    for (Iterator i = originObjects.iterator(); i.hasNext();) {\n                        final Object currentObject = i.next();\n\n                        if (currentObject instanceof NodeInfo) {\n                            // This is the regular case covered by XForms 1.1 / XPath 1.0\n\n                            final Node sourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) currentObject, CANNOT_INSERT_READONLY_MESSAGE);\n                            final Node clonedNode = (sourceNode instanceof Element) ? ((Node) ((Element) sourceNode).createCopy()) : (Node) sourceNode.clone();\n\n                            sourceNodes.add(sourceNode);\n                            clonedNodesTemp.add(clonedNode);\n\n                        } else {\n                            // This is an extension: support sequences containing other items\n\n                            // Convert the result to a text node\n//                            final String stringValue = ((Item) currentObject).getStringValue();\n                            final String stringValue = currentObject.toString(); // we get String, Long, etc.\n                            final Text textNode = Dom4jUtils.createText(stringValue);\n\n                            sourceNodes.add(null); // there is no source node for this cloned node, it's a source item\n                            clonedNodesTemp.add(textNode);\n                        }\n                    }\n\n                    xformsControls.popBinding();\n                }\n\n                // We can never really insert a document into anything, but we assume that this means the root element\n                for (int i = 0; i < clonedNodesTemp.size(); i++) {\n                    final Node clonedNodeTemp = (Node) clonedNodesTemp.get(i);\n\n                    if (clonedNodeTemp instanceof Element)\n                        XFormsUtils.setInitialDecoration((Element) clonedNodeTemp);\n                    else if (clonedNodeTemp instanceof Attribute)\n                        XFormsUtils.setInitialDecoration((Attribute) clonedNodeTemp);\n                    else if (clonedNodeTemp instanceof Document) {\n                        XFormsUtils.setInitialDecoration(clonedNodeTemp.getDocument().getRootElement());\n                        clonedNodesTemp.set(i, clonedNodeTemp.getDocument().getRootElement().detach());\n                    }\n                    // TODO: we don't handle instance data on text nodes and other nodes\n                }\n                clonedNodes = clonedNodesTemp;\n            }\n\n            // \"4. The insert location node is determined.\"\n            int insertionIndex;\n            {\n                if (isEmptyNodesetBinding) {\n                    // \"If the Node Set Binding node-set empty, then this attribute is ignored\"\n                    insertionIndex = 0;\n                } else if (atAttribute == null) {\n                    // \"If the attribute is not given, then the default is the size of the Node Set Binding node-set\"\n                    insertionIndex = collectionToBeUpdated.size();\n                } else {\n                    // \"a. The evaluation context node is the first node in document order from the Node Set Binding\n                    // node-set, the context size is the size of the Node Set Binding node-set, and the context\n                    // position is 1.\"\n\n                    // \"b. The return value is processed according to the rules of the XPath function round()\"\n                    final String insertionIndexString = containingDocument.getEvaluator().evaluateAsString(pipelineContext,\n                        collectionToBeUpdated, 1,\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // \"c. If the result is in the range 1 to the Node Set Binding node-set size, then the insert\n                    // location is equal to the result. If the result is non-positive, then the insert location is\n                    // 1. Otherwise, the result is NaN or exceeds the Node Set Binding node-set size, so the insert\n                    // location is the Node Set Binding node-set size.\"\n\n                    // Don't think we will get NaN with XPath 2.0...\n                    insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (insertionIndex > collectionToBeUpdated.size())\n                        insertionIndex = collectionToBeUpdated.size();\n\n                    if (insertionIndex < 1)\n                        insertionIndex = 1;\n                }\n            }\n\n            // Prepare switches\n            for (int i = 0; i < sourceNodes.size(); i++) {\n                final Node sourceNode = (Node) sourceNodes.get(i);\n                if (sourceNode != null) { // may be null when source is an item\n                    final Node clonedNode = (Node) clonedNodes.get(i);\n                    XFormsSwitchUtils.prepareSwitches(xformsControls, sourceNode, clonedNode);\n                }\n            }\n\n            // \"6. The target location of each cloned node or nodes is determined\"\n            // \"7. The cloned node or nodes are inserted in the order they were cloned at their target location\n            // depending on their node type.\"\n\n            // Identify the instance that actually changes\n            final XFormsInstance modifiedInstance;\n            // Find actual insertion point and insert\n            if (isEmptyNodesetBinding) {\n\n                // \"If the Node Set Binding node-set is not specified or empty, the insert location node is the insert\n                // context node.\"\n\n                // \"a. If the Node Set Binding node-set is not specified or empty, the target location depends on the\n                // node type of the cloned node. If the cloned node is an attribute, then the target location is before\n                // the first attribute of the insert location node. If the cloned node is not an attribute, then the\n                // target location is before the first child of the insert location node.\"\n\n                modifiedInstance = containingDocument.getInstanceForNode(insertContextNode);\n                doInsert(XFormsUtils.getNodeFromNodeInfo(insertContextNode, CANNOT_INSERT_READONLY_MESSAGE), clonedNodes);\n            } else {\n                final NodeInfo insertLocationNodeInfo = (NodeInfo) collectionToBeUpdated.get(insertionIndex - 1);\n                final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertLocationNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n                modifiedInstance = containingDocument.getInstanceForNode(insertLocationNodeInfo);\n\n//                if (insertLocationNode.getNodeType() != clonedNode.getNodeType()) {\n//                    // \"2. If the node type of the cloned node does not match the node type of the insert location\n//                    // node, then the target location is before the first child or attribute of the insert location\n//                    // node, based on the node type of the cloned node.\"\n//\n//                    doInsert(insertLocationNode, clonedNode);\n//                } else {\n\n                    if (insertLocationNode.getDocument().getRootElement() == insertLocationNode) {\n                        \n                        // \"c. if insert location node is the root element of an instance, then that instance root element\n                        // location is the target location. If there is more than one cloned node to insert, only the\n                        // first node that does not cause a conflict is considered.\"\n\n                        doInsert(insertLocationNode.getDocument(), clonedNodes);\n                    } else {\n                        // \"d. Otherwise, the target location is immediately before or after the insert location\n                        // node, based on the position attribute setting or its default.\"\n\n                        final Element parentNode = insertLocationNode.getParent();\n                        final List siblingElements = parentNode.content();\n                        final int actualIndex = siblingElements.indexOf(insertLocationNode);\n\n                        // Prepare insertion of new element\n                        final int actualInsertionIndex;\n                        if (positionAttribute == null || \"after\".equals(positionAttribute)) { // \"after\" is the default\n                            actualInsertionIndex = actualIndex + 1;\n                        } else if (\"before\".equals(positionAttribute)) {\n                            actualInsertionIndex = actualIndex;\n                        } else {\n                            throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after' if present.\");\n                        }\n\n                        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target\n                        // location depending on their node type.\"\n                        // TODO: check insertion of attributes!\n                        for (int i = 0; i < clonedNodes.size(); i++) {\n                            final Node clonedNode = (Node) clonedNodes.get(i);\n                            \n                            siblingElements.add(actualInsertionIndex + i, clonedNode);\n                        }\n                    }\n//                }\n            }\n\n            // TODO: Should normalize tree for text nodes or XPath will be messed-up!\n\n            // Rebuild ControlsState\n            xformsControls.rebuildCurrentControlsState(pipelineContext);\n            final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n            // Update repeat indexes\n            XFormsIndexUtils.ajustIndexesAfterInsert(pipelineContext, xformsControls, currentControlsState, clonedNodes);\n\n            // Update switches\n            XFormsSwitchUtils.updateSwitches(xformsControls);\n\n            // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n            containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(modifiedInstance, atAttribute));\n\n            // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n            modifiedInstance.getModel(containingDocument).setAllDeferredFlags(true);\n            containingDocument.getXFormsControls().markDirty();\n        }\n    }","id":32623,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        final String atAttribute = actionElement.attributeValue(\"at\");\n        final String positionAttribute = actionElement.attributeValue(\"position\");\n        final String originAttribute = actionElement.attributeValue(\"origin\");\n        final String contextAttribute = actionElement.attributeValue(\"context\");\n\n        final XFormsControls.BindingContext curBindingContext = xformsControls.getCurrentBindingContext();\n\n        // \"2. The Node Set Binding node-set is determined.\"\n        final List collectionToBeUpdated = curBindingContext.isNewBind() ? curBindingContext.getNodeset() : Collections.EMPTY_LIST;\n        final boolean isEmptyNodesetBinding = collectionToBeUpdated == null || collectionToBeUpdated.size() == 0;\n\n        // \"1. The insert context is determined.\"\n\n        // \"The insert action is terminated with no effect if [...] a. The context attribute is not given and the Node\n        // Set Binding node-set is the empty node-set.\"\n        if (contextAttribute == null && isEmptyNodesetBinding)\n            return;\n\n        // Now that we have evaluated the nodeset, restore context to in-scope evaluation context\n        xformsControls.popBinding();\n\n        // Handle @context attribute\n        actionInterpreter.pushContextAttributeIfNeeded(pipelineContext, actionElement);\n\n        // We are now in the insert context\n        final NodeInfo insertContextNodeInfo;\n        {\n            final List insertContextNodeset = xformsControls.getCurrentNodeset();\n\n            // \"If the result is an empty nodeset or not a nodeset, then the insert action is terminated with no effect. \"\n            if (insertContextNodeset == null || insertContextNodeset.size() == 0 || !(insertContextNodeset.get(0) instanceof NodeInfo))\n                return;\n\n            insertContextNodeInfo = xformsControls.getCurrentSingleNode();\n        }\n\n        // \"The insert action is terminated with no effect if [...] b. The context attribute is given, the insert\n        // context does not evaluate to an element node and the Node Set Binding node-set is the empty node-set.\"\n        if (contextAttribute != null && insertContextNodeInfo.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && isEmptyNodesetBinding)\n            return;\n\n        {\n            // \"3. The origin node-set is determined.\"\n            // \"5. Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n            final List sourceNodes;\n            final List clonedNodes;\n            {\n                final List clonedNodesTemp;\n                if (originAttribute == null) {\n                    // There is no @origin attribute, use node from Node Set Binding node-set\n\n                    // \"If the origin attribute is not given and the Node Set Binding node-set is empty, then the origin\n                    // node-set is the empty node-set. [...] The insert action is terminated with no effect if the\n                    // origin node-set is the empty node-set.\"\n\n                    if (isEmptyNodesetBinding)\n                        return;\n\n                    // \"Otherwise, if the origin attribute is not given, then the origin node-set consists of the last\n                    // node of the Node Set Binding node-set.\"\n                    final Node singleSourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1), CANNOT_INSERT_READONLY_MESSAGE);\n                    final Node singleClonedNode = (singleSourceNode instanceof Element) ? ((Node) ((Element) singleSourceNode).createCopy()) : (Node) singleSourceNode.clone();\n\n                    sourceNodes = Collections.singletonList(singleSourceNode);\n                    clonedNodesTemp = Collections.singletonList(singleClonedNode);\n                } else {\n                    // There is an @origin attribute\n\n                    // \"If the origin attribute is given, the origin node-set is the result of the evaluation of the\n                    // origin attribute in the insert context.\"\n\n                    final List originObjects = containingDocument.getEvaluator().evaluate(pipelineContext, insertContextNodeInfo,\n                        originAttribute, Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // \"The insert action is terminated with no effect if the origin node-set is the empty node-set.\"\n                    if (originObjects.size() == 0)\n                        return;\n\n                    // \"Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n\n                    sourceNodes = new ArrayList(originObjects.size()); // set to max possible size\n                    clonedNodesTemp = new ArrayList(originObjects.size());\n\n                    for (Iterator i = originObjects.iterator(); i.hasNext();) {\n                        final Object currentObject = i.next();\n\n                        if (currentObject instanceof NodeInfo) {\n                            // This is the regular case covered by XForms 1.1 / XPath 1.0\n\n                            final Node sourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) currentObject, CANNOT_INSERT_READONLY_MESSAGE);\n                            final Node clonedNode = (sourceNode instanceof Element) ? ((Node) ((Element) sourceNode).createCopy()) : (Node) sourceNode.clone();\n\n                            sourceNodes.add(sourceNode);\n                            clonedNodesTemp.add(clonedNode);\n\n                        } else {\n                            // This is an extension: support sequences containing other items\n\n                            // Convert the result to a text node\n//                            final String stringValue = ((Item) currentObject).getStringValue();\n                            final String stringValue = currentObject.toString(); // we get String, Long, etc.\n                            final Text textNode = Dom4jUtils.createText(stringValue);\n\n                            sourceNodes.add(null); // there is no source node for this cloned node, it's a source item\n                            clonedNodesTemp.add(textNode);\n                        }\n                    }\n                }\n\n                // We can never really insert a document into anything, but we assume that this means the root element\n                for (int i = 0; i < clonedNodesTemp.size(); i++) {\n                    final Node clonedNodeTemp = (Node) clonedNodesTemp.get(i);\n\n                    if (clonedNodeTemp instanceof Element)\n                        XFormsUtils.setInitialDecoration((Element) clonedNodeTemp);\n                    else if (clonedNodeTemp instanceof Attribute)\n                        XFormsUtils.setInitialDecoration((Attribute) clonedNodeTemp);\n                    else if (clonedNodeTemp instanceof Document) {\n                        XFormsUtils.setInitialDecoration(clonedNodeTemp.getDocument().getRootElement());\n                        clonedNodesTemp.set(i, clonedNodeTemp.getDocument().getRootElement().detach());\n                    }\n                    // TODO: we don't handle instance data on text nodes and other nodes\n                }\n                clonedNodes = clonedNodesTemp;\n            }\n\n            // \"4. The insert location node is determined.\"\n            int insertionIndex;\n            {\n                if (isEmptyNodesetBinding) {\n                    // \"If the Node Set Binding node-set empty, then this attribute is ignored\"\n                    insertionIndex = 0;\n                } else if (atAttribute == null) {\n                    // \"If the attribute is not given, then the default is the size of the Node Set Binding node-set\"\n                    insertionIndex = collectionToBeUpdated.size();\n                } else {\n                    // \"a. The evaluation context node is the first node in document order from the Node Set Binding\n                    // node-set, the context size is the size of the Node Set Binding node-set, and the context\n                    // position is 1.\"\n\n                    // \"b. The return value is processed according to the rules of the XPath function round()\"\n                    final String insertionIndexString = containingDocument.getEvaluator().evaluateAsString(pipelineContext,\n                        collectionToBeUpdated, 1,\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // \"c. If the result is in the range 1 to the Node Set Binding node-set size, then the insert\n                    // location is equal to the result. If the result is non-positive, then the insert location is\n                    // 1. Otherwise, the result is NaN or exceeds the Node Set Binding node-set size, so the insert\n                    // location is the Node Set Binding node-set size.\"\n\n                    // Don't think we will get NaN with XPath 2.0...\n                    insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (insertionIndex > collectionToBeUpdated.size())\n                        insertionIndex = collectionToBeUpdated.size();\n\n                    if (insertionIndex < 1)\n                        insertionIndex = 1;\n                }\n            }\n\n            // Prepare switches\n            for (int i = 0; i < sourceNodes.size(); i++) {\n                final Node sourceNode = (Node) sourceNodes.get(i);\n                if (sourceNode != null) { // may be null when source is an item\n                    final Node clonedNode = (Node) clonedNodes.get(i);\n                    XFormsSwitchUtils.prepareSwitches(xformsControls, sourceNode, clonedNode);\n                }\n            }\n\n            // \"6. The target location of each cloned node or nodes is determined\"\n            // \"7. The cloned node or nodes are inserted in the order they were cloned at their target location\n            // depending on their node type.\"\n\n            // Identify the instance that actually changes\n            final XFormsInstance modifiedInstance;\n            // Find actual insertion point and insert\n            if (isEmptyNodesetBinding) {\n\n                // \"If the Node Set Binding node-set is not specified or empty, the insert location node is the insert\n                // context node.\"\n\n                // \"a. If the Node Set Binding node-set is not specified or empty, the target location depends on the\n                // node type of the cloned node. If the cloned node is an attribute, then the target location is before\n                // the first attribute of the insert location node. If the cloned node is not an attribute, then the\n                // target location is before the first child of the insert location node.\"\n\n                modifiedInstance = containingDocument.getInstanceForNode(insertContextNodeInfo);\n                final Node insertContextNode = XFormsUtils.getNodeFromNodeInfo(insertContextNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n                doInsert(insertContextNode, clonedNodes);\n\n                // Normalize text nodes if needed to respect XPath 1.0 constraint\n                {\n                    boolean hasTextNode = false;\n                    for (int i = 0; i < clonedNodes.size(); i++) {\n                        final Node clonedNode = (Node) clonedNodes.get(i);\n                        hasTextNode |= clonedNode.getNodeType() == org.dom4j.Node.TEXT_NODE;\n                    }\n                    if (hasTextNode)\n                        Dom4jUtils.normalizeTextNodes(insertContextNode);\n                }\n            } else {\n                final NodeInfo insertLocationNodeInfo = (NodeInfo) collectionToBeUpdated.get(insertionIndex - 1);\n                final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertLocationNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n                modifiedInstance = containingDocument.getInstanceForNode(insertLocationNodeInfo);\n\n//                if (insertLocationNode.getNodeType() != clonedNode.getNodeType()) {\n//                    // \"2. If the node type of the cloned node does not match the node type of the insert location\n//                    // node, then the target location is before the first child or attribute of the insert location\n//                    // node, based on the node type of the cloned node.\"\n//\n//                    doInsert(insertLocationNode, clonedNode);\n//                } else {\n\n                    if (insertLocationNode.getDocument().getRootElement() == insertLocationNode) {\n                        \n                        // \"c. if insert location node is the root element of an instance, then that instance root element\n                        // location is the target location. If there is more than one cloned node to insert, only the\n                        // first node that does not cause a conflict is considered.\"\n\n                        doInsert(insertLocationNode.getDocument(), clonedNodes);\n\n                        // NOTE: Don't need to normalize text nodes in this case, as no new text node is inserted\n                    } else {\n                        // \"d. Otherwise, the target location is immediately before or after the insert location\n                        // node, based on the position attribute setting or its default.\"\n\n                        final Element parentNode = insertLocationNode.getParent();\n                        final List siblingElements = parentNode.content();\n                        final int actualIndex = siblingElements.indexOf(insertLocationNode);\n\n                        // Prepare insertion of new element\n                        final int actualInsertionIndex;\n                        if (positionAttribute == null || \"after\".equals(positionAttribute)) { // \"after\" is the default\n                            actualInsertionIndex = actualIndex + 1;\n                        } else if (\"before\".equals(positionAttribute)) {\n                            actualInsertionIndex = actualIndex;\n                        } else {\n                            throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after' if present.\");\n                        }\n\n                        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target\n                        // location depending on their node type.\"\n                        // TODO: check insertion of attributes!\n\n                        // Normalize text nodes if needed to respect XPath 1.0 constraint\n                        {\n                            boolean hasTextNode = false;\n                            for (int i = 0; i < clonedNodes.size(); i++) {\n                                final Node clonedNode = (Node) clonedNodes.get(i);\n                                hasTextNode |= clonedNode.getNodeType() == org.dom4j.Node.TEXT_NODE;\n                                siblingElements.add(actualInsertionIndex + i, clonedNode);\n                            }\n                            if (hasTextNode)\n                                Dom4jUtils.normalizeTextNodes(parentNode);\n                        }\n                    }\n//                }\n            }\n\n            // Rebuild ControlsState\n            xformsControls.rebuildCurrentControlsState(pipelineContext);\n            final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n            // Update repeat indexes\n            XFormsIndexUtils.ajustIndexesAfterInsert(pipelineContext, xformsControls, currentControlsState, clonedNodes);\n\n            // Update switches\n            XFormsSwitchUtils.updateSwitches(xformsControls);\n\n            // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n            containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(modifiedInstance, atAttribute));\n\n            // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n            modifiedInstance.getModel(containingDocument).setAllDeferredFlags(true);\n            containingDocument.getXFormsControls().markDirty();\n        }\n    }","commit_id":"08faf65d4dd345d3cd404f89b1ee60ed2aafc64e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Set the instance document.\n     *\n     * @param instanceDocument  the Document to use\n     * @param initialize        true if initial decoration (MIPs) has to be reset\n     */\n    public void setInstanceDocument(Document instanceDocument, boolean initialize) {\n        setInstanceDocumentInfo(new DocumentWrapper(Dom4jUtils.normalizeTextNodes(instanceDocument), null, new Configuration()), initialize);\n    }","id":32624,"modified_method":"/**\n     * Set the instance document.\n     *\n     * @param instanceDocument  the Document to use\n     * @param initialize        true if initial decoration (MIPs) has to be reset\n     */\n    public void setInstanceDocument(Document instanceDocument, boolean initialize) {\n        setInstanceDocumentInfo(new DocumentWrapper((Document) Dom4jUtils.normalizeTextNodes(instanceDocument), null, new Configuration()), initialize);\n    }","commit_id":"08faf65d4dd345d3cd404f89b1ee60ed2aafc64e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public XFormsInstance(String modelId, String instanceId, Document instanceDocument, String instanceSourceURI, String username, String password, boolean applicationShared) {\n        // We normalize the Document before setting it, so that text nodes follow the XPath constraints\n        this(modelId, instanceId, new DocumentWrapper(Dom4jUtils.normalizeTextNodes(instanceDocument), null, new Configuration()), instanceSourceURI, username, password, applicationShared);\n    }","id":32625,"modified_method":"public XFormsInstance(String modelId, String instanceId, Document instanceDocument, String instanceSourceURI, String username, String password, boolean applicationShared) {\n        // We normalize the Document before setting it, so that text nodes follow the XPath constraints\n        this(modelId, instanceId, new DocumentWrapper((Document) Dom4jUtils.normalizeTextNodes(instanceDocument), null, new Configuration()), instanceSourceURI, username, password, applicationShared);\n    }","commit_id":"08faf65d4dd345d3cd404f89b1ee60ed2aafc64e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Create an XFormsInstance from a container element. The container contains meta-informationa about the instance,\n     * such as id, username, URI, etc.\n     *\n     * <instance readonly=\"true\" shared=\"application\" id=\"instance-id\" model-id=\"model-id\" source-uri=\"http://...\" username=\"jdoe\" password=\"password\">\n     *     x7wer...\n     * <\/instance>\n     *\n     * The instance document may not have been set after this is completed, in case the Element did not contained a\n     * serialized document.\n     *\n     * @param containerElement  container element\n     */\n    public XFormsInstance(Element containerElement) {\n\n        this.instanceId = containerElement.attributeValue(\"id\");\n        this.modelId = containerElement.attributeValue(\"model-id\");\n        this.readonly = \"true\".equals(containerElement.attributeValue(\"readonly\"));\n        this.applicationShared = \"application\".equals(containerElement.attributeValue(\"shared\"));\n        this.sourceURI = containerElement.attributeValue(\"source-uri\");\n        this.username = containerElement.attributeValue(\"username\");\n        this.password = containerElement.attributeValue(\"password\");\n        this.replaced = \"true\".equals(containerElement.attributeValue(\"replaced\"));\n\n        // Create and set instance document on current model\n        final DocumentInfo documentInfo;\n        if (containerElement.elements().size() == 0) {\n            // New serialization (use serialized XML)\n            try {\n                final String xmlString = containerElement.getStringValue();\n                if (!readonly) {\n                    documentInfo = new DocumentWrapper(Dom4jUtils.normalizeTextNodes(Dom4jUtils.readDom4j(xmlString)), null, new Configuration());\n                } else {\n\n                    if (xmlString.length() > 0) {\n                        // Instance document is available in serialized form\n                        documentInfo = TransformerUtils.readTinyTree(new StreamSource(new StringReader(xmlString)));\n                    } else {\n                        // Instance document is not available, defer to later initialization\n                        documentInfo = null;\n                    }\n                }\n            } catch (Exception e) {\n                throw new OXFException(e);\n            }\n        } else {\n            // Old serialization (instance is directly in the DOM)\n            final Document instanceDocument = Dom4jUtils.createDocumentCopyParentNamespaces((Element) containerElement.elements().get(0));\n            documentInfo = new DocumentWrapper(Dom4jUtils.normalizeTextNodes(instanceDocument), null, new Configuration());\n        }\n\n        setInstanceDocumentInfo(documentInfo, true);\n    }","id":32626,"modified_method":"/**\n     * Create an XFormsInstance from a container element. The container contains meta-informationa about the instance,\n     * such as id, username, URI, etc.\n     *\n     * <instance readonly=\"true\" shared=\"application\" id=\"instance-id\" model-id=\"model-id\" source-uri=\"http://...\" username=\"jdoe\" password=\"password\">\n     *     x7wer...\n     * <\/instance>\n     *\n     * The instance document may not have been set after this is completed, in case the Element did not contained a\n     * serialized document.\n     *\n     * @param containerElement  container element\n     */\n    public XFormsInstance(Element containerElement) {\n\n        this.instanceId = containerElement.attributeValue(\"id\");\n        this.modelId = containerElement.attributeValue(\"model-id\");\n        this.readonly = \"true\".equals(containerElement.attributeValue(\"readonly\"));\n        this.applicationShared = \"application\".equals(containerElement.attributeValue(\"shared\"));\n        this.sourceURI = containerElement.attributeValue(\"source-uri\");\n        this.username = containerElement.attributeValue(\"username\");\n        this.password = containerElement.attributeValue(\"password\");\n        this.replaced = \"true\".equals(containerElement.attributeValue(\"replaced\"));\n\n        // Create and set instance document on current model\n        final DocumentInfo documentInfo;\n        if (containerElement.elements().size() == 0) {\n            // New serialization (use serialized XML)\n            try {\n                final String xmlString = containerElement.getStringValue();\n                if (!readonly) {\n                    documentInfo = new DocumentWrapper((Document) Dom4jUtils.normalizeTextNodes(Dom4jUtils.readDom4j(xmlString)), null, new Configuration());\n                } else {\n\n                    if (xmlString.length() > 0) {\n                        // Instance document is available in serialized form\n                        documentInfo = TransformerUtils.readTinyTree(new StreamSource(new StringReader(xmlString)));\n                    } else {\n                        // Instance document is not available, defer to later initialization\n                        documentInfo = null;\n                    }\n                }\n            } catch (Exception e) {\n                throw new OXFException(e);\n            }\n        } else {\n            // Old serialization (instance is directly in the DOM)\n            final Document instanceDocument = Dom4jUtils.createDocumentCopyParentNamespaces((Element) containerElement.elements().get(0));\n            documentInfo = new DocumentWrapper((Document) Dom4jUtils.normalizeTextNodes(instanceDocument), null, new Configuration());\n        }\n\n        setInstanceDocumentInfo(documentInfo, true);\n    }","commit_id":"08faf65d4dd345d3cd404f89b1ee60ed2aafc64e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public SequenceIterator iterate(XPathContext xpathContext) throws XPathException {\n\n        try {\n            // Get XPL URL\n            final URL xplURL;\n            {\n                Expression xplURIExpression = argument[0];\n                //xplURL = new URL(((AnyURIValue) xplURIExpression.evaluateItem(xpathContext)).getStringValue());\n                if (getSystemId() == null)\n                    xplURL = URLFactory.createURL(xplURIExpression.evaluateAsString(xpathContext));\n                else\n                    xplURL = URLFactory.createURL(getSystemId(), xplURIExpression.evaluateAsString(xpathContext));\n            }\n\n            // Get list of input names\n            final List inputNames = new ArrayList();\n            {\n                final Expression inputNamesExpression = argument[1];\n                final SequenceIterator i = inputNamesExpression.iterate(xpathContext);\n\n                Item currentItem;\n                while ((currentItem = (Item) i.next()) != null) {\n                    inputNames.add(currentItem.getStringValue());\n                }\n            }\n\n            // Get list of input documents\n            final List inputNodeInfos = new ArrayList();\n            {\n                final Expression inputDocumentsExpression = argument[2];\n                final SequenceIterator i = inputDocumentsExpression.iterate(xpathContext);\n\n                Item currentItem;\n                while ((currentItem = (Item) i.next()) != null) {\n                    inputNodeInfos.add(currentItem);\n                }\n            }\n\n            if (inputNames.size() != inputNodeInfos.size())\n                throw new OXFException(\"The length of sequence of input names (\" + inputNames.size()\n                        + \") must be equal to the length of the sequence of input nodes (\" + inputNodeInfos.size() + \").\");//getDisplayName()\n\n            // Get list of output names\n            final List outputNames = new ArrayList();\n            {\n                final Expression inputNamesExpression = argument[3];\n                final SequenceIterator i = inputNamesExpression.iterate(xpathContext);\n\n                Item currentItem;\n                while ((currentItem = (Item) i.next()) != null) {\n                    outputNames.add(currentItem.getStringValue());\n                }\n            }\n\n            // Create processor definition and processor\n            Processor processor;\n            {\n                ProcessorDefinition processorDefinition = new ProcessorDefinition();\n                {\n                    processorDefinition.setName(new QName(\"pipeline\", XMLConstants.OXF_PROCESSORS_NAMESPACE));\n                    processorDefinition.addInput(\"config\", xplURL.toExternalForm());\n\n                    Iterator inputNodesIterator = inputNodeInfos.iterator();\n                    for (Iterator i = inputNames.iterator(); i.hasNext();) {\n                        final String inputName = (String) i.next();\n\n                        final NodeInfo inputNodeInfo = (NodeInfo) inputNodesIterator.next();\n\n                        if (!(inputNodeInfo.getNodeKind() == org.w3c.dom.Document.ELEMENT_NODE || inputNodeInfo.getNodeKind() == org.w3c.dom.Document.DOCUMENT_NODE))\n                            throw new OXFException(\"Input node must be a document or element for input name: \" + inputName);\n\n                        // TODO: We should be able to just pass inputNodeInfo to addInput() and avoid the conversions, but that doesn't work!\n\n                        if (inputNodeInfo instanceof NodeWrapper) {\n                            // Get reference to dom4j node\n\n                            final Element inputElement;\n                            final Node inputNode = (Node) ((NodeWrapper) inputNodeInfo).getUnderlyingNode();\n\n                            if (inputNode instanceof Document)\n                                inputElement = ((Document) inputNode).getRootElement();\n                            else if (inputNode instanceof Element && inputNode.getParent() == null)\n                                inputElement = (Element) inputNode;\n                            else if (inputNode instanceof Element)\n                                inputElement = Dom4jUtils.createDocumentCopyParentNamespaces((Element) inputNode).getRootElement();\n                            else\n                                throw new OXFException(\"Input node must be a document or element for input name: \" + inputName);\n\n                            processorDefinition.addInput(inputName, inputElement);\n                        } else {\n                            // Copy to dom4j\n                            \n//                            final DocumentInfo inputDocumentInfo = TransformerUtils.readTinyTree(inputNodeInfo);\n//                            processorDefinition.addInput(inputName, inputDocumentInfo);\n\n                            final Document inputDocument = TransformerUtils.tinyTreeToDom4j2(inputNodeInfo);\n                            processorDefinition.addInput(inputName, inputDocument.getRootElement());\n                        }\n                    }\n                }\n                processor = InitUtils.createProcessor(processorDefinition);\n            }\n\n            // Try to obtain an existing PipelineContext, otherwise create a new one\n            // PipelineContext should be found when this is called from controls. It is likely to\n            // be missing when called from the model.\n            final StaticExternalContext.StaticContext staticContext = StaticExternalContext.getStaticContext();\n            PipelineContext pipelineContext = (staticContext != null) ? staticContext.getPipelineContext() : null;\n            final boolean newPipelineContext = pipelineContext == null;\n            if (newPipelineContext)\n                pipelineContext = new PipelineContext();\n\n            processor.reset(pipelineContext);\n\n            try {\n                if (outputNames.size() == 0) {\n                    // Just run the processor\n                    processor.start(pipelineContext);\n                    if (newPipelineContext && !pipelineContext.isDestroyed())\n                        pipelineContext.destroy(true);\n\n                    return new ListIterator(Collections.EMPTY_LIST);\n                } else {\n                    // Create all outputs to read\n                    List outputs = new ArrayList(outputNames.size());\n                    for (Iterator i = outputNames.iterator(); i.hasNext();) {\n                        String outputName = (String) i.next();\n\n                        ProcessorOutput output = processor.createOutput(outputName);\n                        outputs.add(output);\n                    }\n\n                    // Connect all DOM serializers\n                    List domSerializers = new ArrayList(outputNames.size());\n                    for (Iterator i = outputs.iterator(); i.hasNext();) {\n                        ProcessorOutput output = (ProcessorOutput) i.next();\n\n                        DOMSerializer domSerializer = new DOMSerializer();\n                        PipelineUtils.connect(processor, output.getName(), domSerializer, \"data\");\n                        domSerializers.add(domSerializer);\n                    }\n\n                    // Read all outputs in sequence\n                    List results = new ArrayList(outputNames.size());\n                    for (Iterator i = domSerializers.iterator(); i.hasNext();) {\n                        DOMSerializer domSerializer = (DOMSerializer) i.next();\n\n                        domSerializer.start(pipelineContext);\n                        results.add(new DocumentWrapper(Dom4jUtils.normalizeTextNodes(domSerializer.getDocument(pipelineContext)), null, new Configuration()));\n                    }\n                    if (newPipelineContext && !pipelineContext.isDestroyed())\n                        pipelineContext.destroy(true);\n\n                    return new ListIterator(results);\n                }\n            } catch (Exception e) {\n                try {\n                    if (newPipelineContext && !pipelineContext.isDestroyed())\n                        pipelineContext.destroy(false);\n                } catch (Exception f) {\n                    logger.error(\"Exception while destroying context after exception\", OXFException.getRootThrowable(f));\n                }\n                throw e;\n            }\n        } catch (XPathException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":32627,"modified_method":"public SequenceIterator iterate(XPathContext xpathContext) throws XPathException {\n\n        try {\n            // Get XPL URL\n            final URL xplURL;\n            {\n                Expression xplURIExpression = argument[0];\n                //xplURL = new URL(((AnyURIValue) xplURIExpression.evaluateItem(xpathContext)).getStringValue());\n                if (getSystemId() == null)\n                    xplURL = URLFactory.createURL(xplURIExpression.evaluateAsString(xpathContext));\n                else\n                    xplURL = URLFactory.createURL(getSystemId(), xplURIExpression.evaluateAsString(xpathContext));\n            }\n\n            // Get list of input names\n            final List inputNames = new ArrayList();\n            {\n                final Expression inputNamesExpression = argument[1];\n                final SequenceIterator i = inputNamesExpression.iterate(xpathContext);\n\n                Item currentItem;\n                while ((currentItem = (Item) i.next()) != null) {\n                    inputNames.add(currentItem.getStringValue());\n                }\n            }\n\n            // Get list of input documents\n            final List inputNodeInfos = new ArrayList();\n            {\n                final Expression inputDocumentsExpression = argument[2];\n                final SequenceIterator i = inputDocumentsExpression.iterate(xpathContext);\n\n                Item currentItem;\n                while ((currentItem = (Item) i.next()) != null) {\n                    inputNodeInfos.add(currentItem);\n                }\n            }\n\n            if (inputNames.size() != inputNodeInfos.size())\n                throw new OXFException(\"The length of sequence of input names (\" + inputNames.size()\n                        + \") must be equal to the length of the sequence of input nodes (\" + inputNodeInfos.size() + \").\");//getDisplayName()\n\n            // Get list of output names\n            final List outputNames = new ArrayList();\n            {\n                final Expression inputNamesExpression = argument[3];\n                final SequenceIterator i = inputNamesExpression.iterate(xpathContext);\n\n                Item currentItem;\n                while ((currentItem = (Item) i.next()) != null) {\n                    outputNames.add(currentItem.getStringValue());\n                }\n            }\n\n            // Create processor definition and processor\n            Processor processor;\n            {\n                ProcessorDefinition processorDefinition = new ProcessorDefinition();\n                {\n                    processorDefinition.setName(new QName(\"pipeline\", XMLConstants.OXF_PROCESSORS_NAMESPACE));\n                    processorDefinition.addInput(\"config\", xplURL.toExternalForm());\n\n                    Iterator inputNodesIterator = inputNodeInfos.iterator();\n                    for (Iterator i = inputNames.iterator(); i.hasNext();) {\n                        final String inputName = (String) i.next();\n\n                        final NodeInfo inputNodeInfo = (NodeInfo) inputNodesIterator.next();\n\n                        if (!(inputNodeInfo.getNodeKind() == org.w3c.dom.Document.ELEMENT_NODE || inputNodeInfo.getNodeKind() == org.w3c.dom.Document.DOCUMENT_NODE))\n                            throw new OXFException(\"Input node must be a document or element for input name: \" + inputName);\n\n                        // TODO: We should be able to just pass inputNodeInfo to addInput() and avoid the conversions, but that doesn't work!\n\n                        if (inputNodeInfo instanceof NodeWrapper) {\n                            // Get reference to dom4j node\n\n                            final Element inputElement;\n                            final Node inputNode = (Node) ((NodeWrapper) inputNodeInfo).getUnderlyingNode();\n\n                            if (inputNode instanceof Document)\n                                inputElement = ((Document) inputNode).getRootElement();\n                            else if (inputNode instanceof Element && inputNode.getParent() == null)\n                                inputElement = (Element) inputNode;\n                            else if (inputNode instanceof Element)\n                                inputElement = Dom4jUtils.createDocumentCopyParentNamespaces((Element) inputNode).getRootElement();\n                            else\n                                throw new OXFException(\"Input node must be a document or element for input name: \" + inputName);\n\n                            processorDefinition.addInput(inputName, inputElement);\n                        } else {\n                            // Copy to dom4j\n                            \n//                            final DocumentInfo inputDocumentInfo = TransformerUtils.readTinyTree(inputNodeInfo);\n//                            processorDefinition.addInput(inputName, inputDocumentInfo);\n\n                            final Document inputDocument = TransformerUtils.tinyTreeToDom4j2(inputNodeInfo);\n                            processorDefinition.addInput(inputName, inputDocument.getRootElement());\n                        }\n                    }\n                }\n                processor = InitUtils.createProcessor(processorDefinition);\n            }\n\n            // Try to obtain an existing PipelineContext, otherwise create a new one\n            // PipelineContext should be found when this is called from controls. It is likely to\n            // be missing when called from the model.\n            final StaticExternalContext.StaticContext staticContext = StaticExternalContext.getStaticContext();\n            PipelineContext pipelineContext = (staticContext != null) ? staticContext.getPipelineContext() : null;\n            final boolean newPipelineContext = pipelineContext == null;\n            if (newPipelineContext)\n                pipelineContext = new PipelineContext();\n\n            processor.reset(pipelineContext);\n\n            try {\n                if (outputNames.size() == 0) {\n                    // Just run the processor\n                    processor.start(pipelineContext);\n                    if (newPipelineContext && !pipelineContext.isDestroyed())\n                        pipelineContext.destroy(true);\n\n                    return new ListIterator(Collections.EMPTY_LIST);\n                } else {\n                    // Create all outputs to read\n                    List outputs = new ArrayList(outputNames.size());\n                    for (Iterator i = outputNames.iterator(); i.hasNext();) {\n                        String outputName = (String) i.next();\n\n                        ProcessorOutput output = processor.createOutput(outputName);\n                        outputs.add(output);\n                    }\n\n                    // Connect all DOM serializers\n                    List domSerializers = new ArrayList(outputNames.size());\n                    for (Iterator i = outputs.iterator(); i.hasNext();) {\n                        ProcessorOutput output = (ProcessorOutput) i.next();\n\n                        DOMSerializer domSerializer = new DOMSerializer();\n                        PipelineUtils.connect(processor, output.getName(), domSerializer, \"data\");\n                        domSerializers.add(domSerializer);\n                    }\n\n                    // Read all outputs in sequence\n                    List results = new ArrayList(outputNames.size());\n                    for (Iterator i = domSerializers.iterator(); i.hasNext();) {\n                        DOMSerializer domSerializer = (DOMSerializer) i.next();\n\n                        domSerializer.start(pipelineContext);\n                        results.add(new DocumentWrapper((Document) Dom4jUtils.normalizeTextNodes(domSerializer.getDocument(pipelineContext)), null, new Configuration()));\n                    }\n                    if (newPipelineContext && !pipelineContext.isDestroyed())\n                        pipelineContext.destroy(true);\n\n                    return new ListIterator(results);\n                }\n            } catch (Exception e) {\n                try {\n                    if (newPipelineContext && !pipelineContext.isDestroyed())\n                        pipelineContext.destroy(false);\n                } catch (Exception f) {\n                    logger.error(\"Exception while destroying context after exception\", OXFException.getRootThrowable(f));\n                }\n                throw e;\n            }\n        } catch (XPathException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"08faf65d4dd345d3cd404f89b1ee60ed2aafc64e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static boolean checkFile(VirtualFile file) {\n    return !FileTypeManager.getInstance().isFileIgnored(file.getName());\n  }","id":32628,"modified_method":"public static boolean checkFile(VirtualFile file,ProjectRootManagerEx manager) {\n    if (FileTypeManager.getInstance().isFileIgnored(file.getName())) return false;\n    if (manager.getFileIndex().isIgnored(file)) return false;\n    return true;\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  protected Set<VirtualFile> getAllExcludeRoots() {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        for (IModule module : MPSModuleRepository.getInstance().getAllModules()) {\n          IFile classesGen = module.getClassesGen();\n          if (classesGen != null) {\n            VirtualFile classesGenVF = VirtualFileUtils.getVirtualFile(classesGen);\n            if (classesGenVF != null) {\n              roots.add(classesGenVF);\n            }\n          }\n        }\n      }\n    });\n    return roots;\n  }","id":32629,"modified_method":"@NotNull\n  protected Set<VirtualFile> getAllExcludeRoots() {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        for (IModule module : MPSModuleRepository.getInstance().getAllModules()) {\n          IFile classesGen = module.getClassesGen();\n          if (classesGen != null) {\n            VirtualFile classesGenVF = VirtualFileUtils.getVirtualFile(classesGen);\n            if (classesGenVF != null) {\n              roots.add(classesGenVF);\n            }\n          }\n        }\n      }\n    });\n    return roots;\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MPSFileBasedIndexProjectHandler(final Project project, final ProjectRootManagerEx rootManager, ProjectManager projectManager, FileBasedIndex index, StartupModuleMaker maker) {\n    super(project);\n    myProjectManager = projectManager;\n    myIndex = index;\n\n    final MPSUnindexedFilesUpdater updater = new MPSUnindexedFilesUpdater(myIndex);\n\n    final StartupManagerEx startupManager = (StartupManagerEx) StartupManager.getInstance(myProject);\n    if (startupManager == null) return;\n\n    startupManager.registerPreStartupActivity(new Runnable() {\n      public void run() {\n        startupManager.registerCacheUpdater(updater);\n        myIndex.registerIndexableSet(MPSFileBasedIndexProjectHandler.this, myProject);\n        DumbServiceImpl.getInstance(myProject).queueCacheUpdate(Collections.<CacheUpdater>singletonList(new MPSUnindexedFilesUpdater(myIndex)));\n      }\n    });\n  }","id":32630,"modified_method":"public MPSFileBasedIndexProjectHandler(final Project project, final ProjectRootManagerEx rootManager, ProjectManager projectManager, FileBasedIndex index, StartupModuleMaker maker) {\n    super(project);\n    myRootManager = rootManager;\n    myProjectManager = projectManager;\n    myIndex = index;\n\n    final MPSUnindexedFilesUpdater updater = new MPSUnindexedFilesUpdater(myIndex, myRootManager);\n\n    final StartupManagerEx startupManager = (StartupManagerEx) StartupManager.getInstance(myProject);\n    if (startupManager == null) return;\n\n    startupManager.registerPreStartupActivity(new Runnable() {\n      public void run() {\n        startupManager.registerCacheUpdater(updater);\n        myIndex.registerIndexableSet(MPSFileBasedIndexProjectHandler.this, myProject);\n        DumbServiceImpl.getInstance(myProject).queueCacheUpdate(Collections.<CacheUpdater>singletonList(updater));\n      }\n    });\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void iterateIndexableFilesIn_internal(VirtualFile file, ContentIterator iterator) {\n    if (!CacheUtil.checkFile(file)) return;\n\n    if (file.isDirectory()) {\n      for (VirtualFile child : file.getChildren()) {\n        iterateIndexableFilesIn_internal(child, iterator);\n      }\n    } else {\n      iterator.processFile(file);\n    }\n  }","id":32631,"modified_method":"private void iterateIndexableFilesIn_internal(VirtualFile file, ContentIterator iterator) {\n    if (!CacheUtil.checkFile(file, myRootManager)) return;\n\n    if (file.isDirectory()) {\n      for (VirtualFile child : file.getChildren()) {\n        iterateIndexableFilesIn_internal(child, iterator);\n      }\n    } else {\n      iterator.processFile(file);\n    }\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isInSet(VirtualFile file) {\n    return (CacheUtil.checkFile(file) && checkUnderModule(file));\n  }","id":32632,"modified_method":"public boolean isInSet(VirtualFile file) {\n    if (!CacheUtil.checkFile(file, myRootManager)) return false;\n\n    for (VirtualFile vf : getRootFiles()) {\n      if (VfsUtil.isAncestor(vf, file, true)) return true;\n    }\n    return false;\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MPSUnindexedFilesUpdater(FileBasedIndex index) {\n    myIndex = index;\n  }","id":32633,"modified_method":"public MPSUnindexedFilesUpdater(FileBasedIndex index, ProjectRootManagerEx manager) {\n    myIndex = index;\n    myManager = manager;\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void iterateRecursively(final VirtualFile root, final ContentIterator processor, ProgressIndicator indicator) {\n    if (root == null) return;\n    if (!CacheUtil.checkFile(root)) return;\n\n    if (indicator != null) {\n      indicator.setText(\"Scanning files to index\");\n      indicator.setText2(root.getPresentableUrl());\n    }\n\n    for (VirtualFile file : root.getChildren()) {\n      if (file.isDirectory()) {\n        iterateRecursively(file, processor, indicator);\n      } else {\n        processor.processFile(file);\n      }\n    }\n  }","id":32634,"modified_method":"private void iterateRecursively(final VirtualFile root, final ContentIterator processor, ProgressIndicator indicator) {\n    if (root == null) return;\n    if (!CacheUtil.checkFile(root,myManager)) return;\n\n    if (indicator != null) {\n      indicator.setText2(root.getPresentableUrl());\n    }\n\n    for (VirtualFile file : root.getChildren()) {\n      if (file.isDirectory()) {\n        iterateRecursively(file, processor, indicator);\n      } else {\n        processor.processFile(file);\n      }\n    }\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void iterateIndexableFiles(final ContentIterator processor) {\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n\n    Set<VirtualFile> visitedRoots = new HashSet<VirtualFile>();\n    for (VirtualFile root : CacheUtil.getIndexableRoots()) {\n      if (visitedRoots.contains(root)) continue;\n      visitedRoots.add(root);\n      iterateRecursively(root, processor, indicator);\n    }\n  }","id":32635,"modified_method":"private void iterateIndexableFiles(final ContentIterator processor) {\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.setText(\"Scanning files to index\");\n    }\n\n    Set<VirtualFile> visitedRoots = new HashSet<VirtualFile>();\n    for (VirtualFile root : CacheUtil.getIndexableRoots()) {\n      if (visitedRoots.contains(root)) continue;\n      visitedRoots.add(root);\n      iterateRecursively(root, processor, indicator);\n    }\n  }","commit_id":"58733fbdbe3f387a44928dc95cdb49fef41d8e1e","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Test various configuration options of dfs.namenode.name.dir and dfs.namenode.edits.dir\n   * This test tries to simulate failure scenarios.\n   * 1. Start cluster with shared name and edits dir\n   * 2. Restart cluster by adding separate name and edits dirs\n   * T3. Restart cluster by removing shared name and edits dir\n   * 4. Restart cluster with old shared name and edits dir, but only latest \n   *    name dir. This should fail since we dont have latest edits dir\n   * 5. Restart cluster with old shared name and edits dir, but only latest\n   *    edits dir. This should fail since we dont have latest name dir\n   */\n  public void testNameEditsConfigsFailure() throws IOException {\n    Path file1 = new Path(\"TestNameEditsConfigs1\");\n    Path file2 = new Path(\"TestNameEditsConfigs2\");\n    Path file3 = new Path(\"TestNameEditsConfigs3\");\n    MiniDFSCluster cluster = null;\n    Configuration conf = null;\n    FileSystem fileSys = null;\n    File newNameDir = new File(base_dir, \"name\");\n    File newEditsDir = new File(base_dir, \"edits\");\n    File nameAndEdits = new File(base_dir, \"name_and_edits\");\n    \n    // Start namenode with same dfs.namenode.name.dir and dfs.namenode.edits.dir\n    conf = new HdfsConfiguration();\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameAndEdits.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, nameAndEdits.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    // Manage our own dfs directories\n    cluster = new MiniDFSCluster.Builder(conf)\n                                .numDataNodes(NUM_DATA_NODES)\n                                .manageNameDfsDirs(false)\n                                .build();\n    cluster.waitActive();\n    \n    // Check that the dir has a VERSION file\n    assertTrue(new File(nameAndEdits, \"current/VERSION\").exists());\n    \n    fileSys = cluster.getFileSystem();\n\n    try {\n      assertTrue(!fileSys.exists(file1));\n      writeFile(fileSys, file1, replication);\n      checkFile(fileSys, file1, replication);\n    } finally  {\n      fileSys.close();\n      cluster.shutdown();\n    }\n\n    // Start namenode with additional dfs.namenode.name.dir and dfs.namenode.edits.dir\n    conf =  new HdfsConfiguration();\n    assertTrue(newNameDir.mkdir());\n    assertTrue(newEditsDir.mkdir());\n\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameAndEdits.getPath() +\n              \",\" + newNameDir.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, nameAndEdits.getPath() +\n              \",\" + newEditsDir.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    // Manage our own dfs directories. Do not format.\n    cluster = new MiniDFSCluster.Builder(conf)\n                                .numDataNodes(NUM_DATA_NODES)\n                                .format(false)\n                                .manageNameDfsDirs(false)\n                                .build();\n    cluster.waitActive();\n\n    // Check that the dirs have a VERSION file\n    assertTrue(new File(nameAndEdits, \"current/VERSION\").exists());\n    assertTrue(new File(newNameDir, \"current/VERSION\").exists());\n    assertTrue(new File(newEditsDir, \"current/VERSION\").exists());\n\n    fileSys = cluster.getFileSystem();\n\n    try {\n      assertTrue(fileSys.exists(file1));\n      checkFile(fileSys, file1, replication);\n      cleanupFile(fileSys, file1);\n      writeFile(fileSys, file2, replication);\n      checkFile(fileSys, file2, replication);\n    } finally {\n      fileSys.close();\n      cluster.shutdown();\n    }\n    \n    // Now remove common directory both have and start namenode with \n    // separate name and edits dirs\n    conf =  new HdfsConfiguration();\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, newNameDir.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, newEditsDir.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    cluster = new MiniDFSCluster.Builder(conf)\n                                .numDataNodes(NUM_DATA_NODES)\n                                .format(false)\n                                .manageNameDfsDirs(false)\n                                .build();\n    cluster.waitActive();\n    fileSys = cluster.getFileSystem();\n\n    try {\n      assertTrue(!fileSys.exists(file1));\n      assertTrue(fileSys.exists(file2));\n      checkFile(fileSys, file2, replication);\n      cleanupFile(fileSys, file2);\n      writeFile(fileSys, file3, replication);\n      checkFile(fileSys, file3, replication);\n    } finally {\n      fileSys.close();\n      cluster.shutdown();\n    }\n    \n    // Add old shared directory for name and edits along with latest name\n    conf = new HdfsConfiguration();\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, newNameDir.getPath() + \",\" + \n             nameAndEdits.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, nameAndEdits.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    try {\n      cluster = new MiniDFSCluster.Builder(conf)\n                                  .numDataNodes(NUM_DATA_NODES)\n                                  .format(false)\n                                  .manageNameDfsDirs(false)\n                                  .build();\n      assertTrue(false);\n    } catch (IOException e) { // expect to fail\n      System.out.println(\"cluster start failed due to missing \" +\n                         \"latest edits dir\");\n    } finally {\n      cluster = null;\n    }\n\n    // Add old shared directory for name and edits along with latest edits. \n    // This is OK, since the latest edits will have segments leading all\n    // the way from the image in name_and_edits.\n    conf = new HdfsConfiguration();\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameAndEdits.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, newEditsDir.getPath() +\n             \",\" + nameAndEdits.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    try {\n      cluster = new MiniDFSCluster.Builder(conf)\n                                  .numDataNodes(NUM_DATA_NODES)\n                                  .format(false)\n                                  .manageNameDfsDirs(false)\n                                  .build();\n      assertTrue(!fileSys.exists(file1));\n      assertTrue(fileSys.exists(file2));\n      checkFile(fileSys, file2, replication);\n      cleanupFile(fileSys, file2);\n      writeFile(fileSys, file3, replication);\n      checkFile(fileSys, file3, replication);\n    } catch (IOException e) { // expect to fail\n      System.out.println(\"cluster start failed due to missing latest name dir\");\n    } finally {\n      fileSys.close();\n      cluster.shutdown();\n    }\n  }","id":32636,"modified_method":"/**\n   * Test various configuration options of dfs.namenode.name.dir and dfs.namenode.edits.dir\n   * This test tries to simulate failure scenarios.\n   * 1. Start cluster with shared name and edits dir\n   * 2. Restart cluster by adding separate name and edits dirs\n   * 3. Restart cluster by removing shared name and edits dir\n   * 4. Restart cluster with old shared name and edits dir, but only latest \n   *    name dir. This should fail since we don't have latest edits dir\n   * 5. Restart cluster with old shared name and edits dir, but only latest\n   *    edits dir. This should succeed since the latest edits will have\n   *    segments leading all the way from the image in name_and_edits.\n   */\n  @Test\n  public void testNameEditsConfigsFailure() throws IOException {\n    Path file1 = new Path(\"TestNameEditsConfigs1\");\n    Path file2 = new Path(\"TestNameEditsConfigs2\");\n    Path file3 = new Path(\"TestNameEditsConfigs3\");\n    MiniDFSCluster cluster = null;\n    Configuration conf = null;\n    FileSystem fileSys = null;\n    File nameOnlyDir = new File(base_dir, \"name\");\n    File editsOnlyDir = new File(base_dir, \"edits\");\n    File nameAndEditsDir = new File(base_dir, \"name_and_edits\");\n    \n    // 1\n    // Start namenode with same dfs.namenode.name.dir and dfs.namenode.edits.dir\n    conf = new HdfsConfiguration();\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameAndEditsDir.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, nameAndEditsDir.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    \n    try {\n      // Manage our own dfs directories\n      cluster = new MiniDFSCluster.Builder(conf)\n                                  .numDataNodes(NUM_DATA_NODES)\n                                  .manageNameDfsDirs(false)\n                                  .build();\n      cluster.waitActive();\n      \n      // Check that the dir has a VERSION file\n      assertTrue(new File(nameAndEditsDir, \"current/VERSION\").exists());\n      \n      fileSys = cluster.getFileSystem();\n\n      assertTrue(!fileSys.exists(file1));\n      writeFile(fileSys, file1, replication);\n      checkFile(fileSys, file1, replication);\n    } finally  {\n      fileSys.close();\n      cluster.shutdown();\n    }\n\n    // 2\n    // Start namenode with additional dfs.namenode.name.dir and dfs.namenode.edits.dir\n    conf =  new HdfsConfiguration();\n    assertTrue(nameOnlyDir.mkdir());\n    assertTrue(editsOnlyDir.mkdir());\n\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameAndEditsDir.getPath() +\n              \",\" + nameOnlyDir.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, nameAndEditsDir.getPath() +\n              \",\" + editsOnlyDir.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    \n    try {\n      // Manage our own dfs directories. Do not format.\n      cluster = new MiniDFSCluster.Builder(conf)\n                                  .numDataNodes(NUM_DATA_NODES)\n                                  .format(false)\n                                  .manageNameDfsDirs(false)\n                                  .build();\n      cluster.waitActive();\n  \n      // Check that the dirs have a VERSION file\n      assertTrue(new File(nameAndEditsDir, \"current/VERSION\").exists());\n      assertTrue(new File(nameOnlyDir, \"current/VERSION\").exists());\n      assertTrue(new File(editsOnlyDir, \"current/VERSION\").exists());\n  \n      fileSys = cluster.getFileSystem();\n\n      assertTrue(fileSys.exists(file1));\n      checkFile(fileSys, file1, replication);\n      cleanupFile(fileSys, file1);\n      writeFile(fileSys, file2, replication);\n      checkFile(fileSys, file2, replication);\n    } finally {\n      fileSys.close();\n      cluster.shutdown();\n    }\n    \n    // 3\n    // Now remove common directory both have and start namenode with \n    // separate name and edits dirs\n    try {\n      conf =  new HdfsConfiguration();\n      conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameOnlyDir.getPath());\n      conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, editsOnlyDir.getPath());\n      replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n      cluster = new MiniDFSCluster.Builder(conf)\n                                  .numDataNodes(NUM_DATA_NODES)\n                                  .format(false)\n                                  .manageNameDfsDirs(false)\n                                  .build();\n      cluster.waitActive();\n      fileSys = cluster.getFileSystem();\n\n      assertFalse(fileSys.exists(file1));\n      assertTrue(fileSys.exists(file2));\n      checkFile(fileSys, file2, replication);\n      cleanupFile(fileSys, file2);\n      writeFile(fileSys, file3, replication);\n      checkFile(fileSys, file3, replication);\n    } finally {\n      fileSys.close();\n      cluster.shutdown();\n    }\n    \n    // 4\n    // Add old shared directory for name and edits along with latest name\n    conf = new HdfsConfiguration();\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameOnlyDir.getPath() + \",\" + \n             nameAndEditsDir.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, nameAndEditsDir.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    try {\n      cluster = new MiniDFSCluster.Builder(conf)\n                                  .numDataNodes(NUM_DATA_NODES)\n                                  .format(false)\n                                  .manageNameDfsDirs(false)\n                                  .build();\n      fail(\"Successfully started cluster but should not have been able to.\");\n    } catch (IOException e) { // expect to fail\n      LOG.info(\"EXPECTED: cluster start failed due to missing \" +\n                         \"latest edits dir\", e);\n    } finally {\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n      cluster = null;\n    }\n\n    // 5\n    // Add old shared directory for name and edits along with latest edits. \n    // This is OK, since the latest edits will have segments leading all\n    // the way from the image in name_and_edits.\n    conf = new HdfsConfiguration();\n    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY, nameAndEditsDir.getPath());\n    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY, editsOnlyDir.getPath() +\n             \",\" + nameAndEditsDir.getPath());\n    replication = (short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY, 3);\n    try {\n      cluster = new MiniDFSCluster.Builder(conf)\n                                  .numDataNodes(NUM_DATA_NODES)\n                                  .format(false)\n                                  .manageNameDfsDirs(false)\n                                  .build();\n      \n      fileSys = cluster.getFileSystem();\n      \n      assertFalse(fileSys.exists(file1));\n      assertFalse(fileSys.exists(file2));\n      assertTrue(fileSys.exists(file3));\n      checkFile(fileSys, file3, replication);\n      cleanupFile(fileSys, file3);\n      writeFile(fileSys, file3, replication);\n      checkFile(fileSys, file3, replication);\n    } finally {\n      fileSys.close();\n      cluster.shutdown();\n    }\n  }","commit_id":"a7195bdd1459203e73c647165cbc2e6d63dde833","url":"https://github.com/apache/hadoop"},{"original_method":"protected void setUp() throws java.lang.Exception {\n    if(base_dir.exists()) {\n      if (!FileUtil.fullyDelete(base_dir)) \n        throw new IOException(\"Cannot remove directory \" + base_dir);\n    }\n  }","id":32637,"modified_method":"@Before\n  public void setUp() throws IOException {\n    if(base_dir.exists() && !FileUtil.fullyDelete(base_dir)) {\n      throw new IOException(\"Cannot remove directory \" + base_dir);\n    }\n  }","commit_id":"a7195bdd1459203e73c647165cbc2e6d63dde833","url":"https://github.com/apache/hadoop"},{"original_method":"public static boolean checkFile(VirtualFile file) {\n    return !FileTypeManager.getInstance().isFileIgnored(file.getName());\n  }","id":32638,"modified_method":"public static boolean checkFile(VirtualFile file,ProjectRootManagerEx manager) {\n    if (FileTypeManager.getInstance().isFileIgnored(file.getName())) return false;\n    if (manager.getFileIndex().isIgnored(file)) return false;\n    return true;\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  protected Set<VirtualFile> getAllExcludeRoots() {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        for (IModule module : MPSModuleRepository.getInstance().getAllModules()) {\n          IFile classesGen = module.getClassesGen();\n          if (classesGen != null) {\n            VirtualFile classesGenVF = VirtualFileUtils.getVirtualFile(classesGen);\n            if (classesGenVF != null) {\n              roots.add(classesGenVF);\n            }\n          }\n        }\n      }\n    });\n    return roots;\n  }","id":32639,"modified_method":"@NotNull\n  protected Set<VirtualFile> getAllExcludeRoots() {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        for (IModule module : MPSModuleRepository.getInstance().getAllModules()) {\n          IFile classesGen = module.getClassesGen();\n          if (classesGen != null) {\n            VirtualFile classesGenVF = VirtualFileUtils.getVirtualFile(classesGen);\n            if (classesGenVF != null) {\n              roots.add(classesGenVF);\n            }\n          }\n        }\n      }\n    });\n    return roots;\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isInSet(VirtualFile file) {\n    return (CacheUtil.checkFile(file) && checkUnderModule(file));\n  }","id":32640,"modified_method":"public boolean isInSet(VirtualFile file) {\n    if (!CacheUtil.checkFile(file, myRootManager)) return false;\n\n    for (VirtualFile vf : getRootFiles()) {\n      if (VfsUtil.isAncestor(vf, file, true)) return true;\n    }\n    return false;\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MPSFileBasedIndexProjectHandler(final Project project, final ProjectRootManagerEx rootManager, ProjectManager projectManager, FileBasedIndex index, StartupModuleMaker maker) {\n    super(project);\n    myProjectManager = projectManager;\n    myIndex = index;\n\n    final MPSUnindexedFilesUpdater updater = new MPSUnindexedFilesUpdater(myIndex);\n\n    final StartupManagerEx startupManager = (StartupManagerEx) StartupManager.getInstance(myProject);\n    if (startupManager == null) return;\n\n    startupManager.registerPreStartupActivity(new Runnable() {\n      public void run() {\n        startupManager.registerCacheUpdater(updater);\n        myIndex.registerIndexableSet(MPSFileBasedIndexProjectHandler.this, myProject);\n        DumbServiceImpl.getInstance(myProject).queueCacheUpdate(Collections.<CacheUpdater>singletonList(new MPSUnindexedFilesUpdater(myIndex)));\n      }\n    });\n  }","id":32641,"modified_method":"public MPSFileBasedIndexProjectHandler(final Project project, final ProjectRootManagerEx rootManager, ProjectManager projectManager, FileBasedIndex index, StartupModuleMaker maker) {\n    super(project);\n    myRootManager = rootManager;\n    myProjectManager = projectManager;\n    myIndex = index;\n\n    final MPSUnindexedFilesUpdater updater = new MPSUnindexedFilesUpdater(myIndex, myRootManager);\n\n    final StartupManagerEx startupManager = (StartupManagerEx) StartupManager.getInstance(myProject);\n    if (startupManager == null) return;\n\n    startupManager.registerPreStartupActivity(new Runnable() {\n      public void run() {\n        startupManager.registerCacheUpdater(updater);\n        myIndex.registerIndexableSet(MPSFileBasedIndexProjectHandler.this, myProject);\n        DumbServiceImpl.getInstance(myProject).queueCacheUpdate(Collections.<CacheUpdater>singletonList(updater));\n      }\n    });\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void iterateIndexableFilesIn_internal(VirtualFile file, ContentIterator iterator) {\n    if (!CacheUtil.checkFile(file)) return;\n\n    if (file.isDirectory()) {\n      for (VirtualFile child : file.getChildren()) {\n        iterateIndexableFilesIn_internal(child, iterator);\n      }\n    } else {\n      iterator.processFile(file);\n    }\n  }","id":32642,"modified_method":"private void iterateIndexableFilesIn_internal(VirtualFile file, ContentIterator iterator) {\n    if (!CacheUtil.checkFile(file, myRootManager)) return;\n\n    if (file.isDirectory()) {\n      for (VirtualFile child : file.getChildren()) {\n        iterateIndexableFilesIn_internal(child, iterator);\n      }\n    } else {\n      iterator.processFile(file);\n    }\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MPSUnindexedFilesUpdater(FileBasedIndex index) {\n    myIndex = index;\n  }","id":32643,"modified_method":"public MPSUnindexedFilesUpdater(FileBasedIndex index, ProjectRootManagerEx manager) {\n    myIndex = index;\n    myManager = manager;\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void iterateRecursively(final VirtualFile root, final ContentIterator processor, ProgressIndicator indicator) {\n    if (root == null) return;\n    if (!CacheUtil.checkFile(root)) return;\n\n    if (indicator != null) {\n      indicator.setText(\"Scanning files to index\");\n      indicator.setText2(root.getPresentableUrl());\n    }\n\n    for (VirtualFile file : root.getChildren()) {\n      if (file.isDirectory()) {\n        iterateRecursively(file, processor, indicator);\n      } else {\n        processor.processFile(file);\n      }\n    }\n  }","id":32644,"modified_method":"private void iterateRecursively(final VirtualFile root, final ContentIterator processor, ProgressIndicator indicator) {\n    if (root == null) return;\n    if (!CacheUtil.checkFile(root,myManager)) return;\n\n    if (indicator != null) {\n      indicator.setText2(root.getPresentableUrl());\n    }\n\n    for (VirtualFile file : root.getChildren()) {\n      if (file.isDirectory()) {\n        iterateRecursively(file, processor, indicator);\n      } else {\n        processor.processFile(file);\n      }\n    }\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void iterateIndexableFiles(final ContentIterator processor) {\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n\n    Set<VirtualFile> visitedRoots = new HashSet<VirtualFile>();\n    for (VirtualFile root : CacheUtil.getIndexableRoots()) {\n      if (visitedRoots.contains(root)) continue;\n      visitedRoots.add(root);\n      iterateRecursively(root, processor, indicator);\n    }\n  }","id":32645,"modified_method":"private void iterateIndexableFiles(final ContentIterator processor) {\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.setText(\"Scanning files to index\");\n    }\n\n    Set<VirtualFile> visitedRoots = new HashSet<VirtualFile>();\n    for (VirtualFile root : CacheUtil.getIndexableRoots()) {\n      if (visitedRoots.contains(root)) continue;\n      visitedRoots.add(root);\n      iterateRecursively(root, processor, indicator);\n    }\n  }","commit_id":"eb253820b991acee01753e14f5770b31bfc4d819","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Ensure parallel reads are viable.\n   * <p>\n   * Execution time, justification for baseline value\n   * Detached model, no listeners: 1 thread = 200 ms; 4 threads = ~265 ms per thread\n   * Attached model, no listeners: 1 thread = 270 ms; 4 threads = ~330 ms (300 - 420)\n   * Attached model,  3 listeners: 1 thread = 340 ms; 4 threads = 510 ms (500-540)\n   * <\/p>\n   * Note, though average time in testWalkTime for slightly smaller model is 50ms, it's rather 200, 75, 25, 20, 20,\n   * i.e. each thread in parallel mode is executed as a 'fresh' run, so it looks like JIT optimizes per thread?\n   */\n  @Test\n  public void testParallelRead() throws Exception {\n    final TestModelFactory m1f = new TestModelFactory();\n    m1f.createModel(20, 100, 10, 5); // ~120k nodes\n    final int initialNodeCount = m1f.countModelNodes();\n    myTestModelAccess.enableRead();\n    m1f.attachTo(myTestRepo);\n\n    final long baselineMillis = 500 * 2; // Use twice as much time to account for slow build agents\n    final int parallelThreads = 4;\n    final CountDownLatch stopLatch = new CountDownLatch(3); // 1 for thread start sync, 1 for results ready sync, 1 for thread stop sync\n    CyclicBarrier b = new CyclicBarrier(parallelThreads, new Runnable() {\n      @Override\n      public void run() {\n        stopLatch.countDown();\n      }\n    });\n    ModelReadThread[] threads = new ModelReadThread[parallelThreads];\n    for (int i = 0; i < parallelThreads; i++) {\n      threads[i] = new ModelReadThread(b, m1f);\n      threads[i].start();\n    }\n    boolean finishOk = stopLatch.await(10, TimeUnit.SECONDS);\n    if (finishOk) {\n      final int expectedNodeCount = 3 * initialNodeCount;\n      for (int i = 0; i < parallelThreads; i++) {\n        myErrors.checkThat(threads[i].getName(), threads[i].getAllThreadListenerCount(), equalTo(expectedNodeCount * parallelThreads));\n        myErrors.checkThat(threads[i].getName(), threads[i].getThisThreadCount1(), equalTo(expectedNodeCount));\n        myErrors.checkThat(threads[i].getName(), threads[i].getThisThreadCount2(), equalTo(expectedNodeCount));\n        myErrors.checkThat(threads[i].getName(), threads[i].getElapsedMillis(), lessThan(baselineMillis));\n        myErrors.checkThat(threads[i].getName(), threads[i].getElapsedMillis(), greaterThan(baselineMillis / 4));\n      }\n      return;\n    }\n    for (int i = 0; i < parallelThreads; i++) {\n      if (threads[i].isAlive()) {\n        Throwable th = new Throwable(\"Hanging thread \" + threads[i].getName());\n        th.setStackTrace(threads[i].getStackTrace());\n        myErrors.addError(th);\n        threads[i].interrupt();\n      }\n    }\n  }","id":32646,"modified_method":"/**\n   * Ensure parallel reads are viable.\n   * <p>\n   * Execution time, justification for baseline value\n   * Detached model, no listeners: 1 thread = 200 ms; 4 threads = ~265 ms per thread\n   * Attached model, no listeners: 1 thread = 270 ms; 4 threads = ~330 ms (300 - 420)\n   * Attached model,  3 listeners: 1 thread = 340 ms; 4 threads = 510 ms (500-540)\n   * <\/p>\n   * Note, though average time in testWalkTime for slightly smaller model is 50ms, it's rather 200, 75, 25, 20, 20,\n   * i.e. each thread in parallel mode is executed as a 'fresh' run, so it looks like JIT optimizes per thread?\n   */\n  @Test\n  public void testParallelRead() throws Exception {\n    final TestModelFactory m1f = new TestModelFactory();\n    m1f.createModel(20, 100, 10, 5); // ~120k nodes\n    final int initialNodeCount = m1f.countModelNodes();\n    myTestModelAccess.enableRead();\n    m1f.attachTo(myTestRepo);\n\n    final long baselineMillis = 500 * 2; // Use twice as much time to account for slow build agents\n    final int parallelThreads = 4;\n    final CountDownLatch stopLatch = new CountDownLatch(3); // 1 for thread start sync, 1 for results ready sync, 1 for thread stop sync\n    CyclicBarrier b = new CyclicBarrier(parallelThreads, new Runnable() {\n      @Override\n      public void run() {\n        stopLatch.countDown();\n      }\n    });\n    ModelReadThread[] threads = new ModelReadThread[parallelThreads];\n    for (int i = 0; i < parallelThreads; i++) {\n      threads[i] = new ModelReadThread(b, m1f);\n      threads[i].start();\n    }\n    boolean finishOk = stopLatch.await(10, TimeUnit.SECONDS);\n    if (finishOk) {\n      final int expectedNodeCount = 3 * initialNodeCount;\n      for (int i = 0; i < parallelThreads; i++) {\n        myErrors.checkThat(threads[i].getName(), threads[i].getAllThreadListenerCount(), equalTo(expectedNodeCount * parallelThreads));\n        myErrors.checkThat(threads[i].getName(), threads[i].getThisThreadCount1(), equalTo(expectedNodeCount));\n        myErrors.checkThat(threads[i].getName(), threads[i].getThisThreadCount2(), equalTo(expectedNodeCount));\n        myErrors.checkThat(threads[i].getName(), threads[i].getElapsedMillis(), new BaseMatcher<Long>() {\n          @Override\n          public boolean matches(Object item) {\n            if (item instanceof Long) {\n              return ((Long) item) < baselineMillis;\n            }\n            return false;\n          }\n\n          @Override\n          public void describeTo(Description description) {description.appendText(String.format(\"less than %d\", baselineMillis)); }\n        });\n        myErrors.checkThat(threads[i].getName(), threads[i].getElapsedMillis(), new BaseMatcher<Long>() {\n          @Override\n          public boolean matches(Object item) {\n            if (item instanceof Long) {\n              return ((Long) item) > baselineMillis / 4;\n            }\n            return false;\n          }\n\n          @Override\n          public void describeTo(Description description) { description.appendText(String.format(\"greater than %d\", baselineMillis/4)); }\n        });\n      }\n      return;\n    }\n    for (int i = 0; i < parallelThreads; i++) {\n      if (threads[i].isAlive()) {\n        Throwable th = new Throwable(\"Hanging thread \" + threads[i].getName());\n        th.setStackTrace(threads[i].getStackTrace());\n        myErrors.addError(th);\n        threads[i].interrupt();\n      }\n    }\n  }","commit_id":"e7ffab522774c8258757af5651bec9ce5848e594","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * beanmodel1.mps is transformed Bean --> Class with a single checkpoint.\n   * This test ensures there's checkpoint model and appropriate mapping label recorded.\n   */\n  @Test\n  public void createModelWithOneCheckpoint() {\n    final SModelReference mr = PersistenceFacade.getInstance().createModelReference(\n        \"r:24638668-c917-4da1-8069-8ddef862314d(jetbrains.mps.generator.crossmodel.sandbox.beanmodel1)\");\n    // \"r:53fbbbd7-a01f-458c-a76d-a34ed2d6f25f(jetbrains.mps.generator.crossmodel.sandbox.beanmodel2)\"\n    final SModel m = resolve(mr);\n    final Checkpoint cp1 = new Checkpoint(\"aaa\");\n    ModelGenerationPlan plan = new ModelAccessHelper(mpsProject.getModelAccess()).runReadAction(new Computable<ModelGenerationPlan>() {\n      @Override\n      public ModelGenerationPlan compute() {\n        final Transform step1 = new Transform(getCrossmodelPropertyGenerators());\n        final Transform step2 = new Transform(getBaseLanguageGenerators());\n        return new RigidGenerationPlan(step1, cp1, step2);\n      }\n    });\n    final PlanIdentity planIdentity = new PlanIdentity(plan);\n    GenerationOptions opt = GenerationOptions.getDefaults().customPlan(m, plan).create();\n    final TransientModelsProvider tmProvider = mpsProject.getComponent(TransientModelsProvider.class);\n    GenerationFacade genFacade = new GenerationFacade(mpsProject.getRepository(), opt).transients(tmProvider);\n    GenerationStatus genStatus = genFacade.process(new EmptyProgressMonitor(), m);\n    myErrors.checkThat(\"Generation succeeds\", genStatus.isOk(), CoreMatchers.equalTo(true));\n    CrossModelEnvironment cme = new CrossModelEnvironment(tmProvider);\n    // XXX shall it be CME to give access to module with checkpoint models? Is there better way to find out cpModel?\n    myErrors.checkThat(\"CrossModelEnvironment.hasState\", cme.hasState(mr, planIdentity), CoreMatchers.equalTo(true));\n\n    SModule checkpointModule = tmProvider.getCheckpointsModule();\n    final SModelName cpModelName = CrossModelEnvironment.createCheckpointModelName(m.getReference(), cp1);\n    SModel cpModel = null;\n    for (SModel trm : checkpointModule.getModels()) {\n      if (cpModelName.equals(trm.getName())) {\n        cpModel = trm;\n        break;\n      }\n    }\n    myErrors.checkThat(\"Checkpoint model\", cpModel, CoreMatchers.notNullValue());\n    ModelCheckpoints modelCheckpoints = cme.getState(mr, planIdentity);\n    CheckpointState cpState = modelCheckpoints.find(cp1);\n    myErrors.checkThat(\"CheckpointState present\", cpState, CoreMatchers.notNullValue());\n    if (cpState != null) {\n      Collection<String> mappingLabels = cpState.getMappingLabels();\n      myErrors.checkThat(\"GetterMethod label present\", mappingLabels.contains(\"GetterMethod\"), CoreMatchers.equalTo(true));\n    }\n  }","id":32647,"modified_method":"/**\n   * beanmodel1.mps is transformed Bean --> Class with a single checkpoint.\n   * This test ensures there's checkpoint model and appropriate mapping label recorded.\n   */\n  @Test\n  public void createModelWithOneCheckpoint() {\n    final SModelReference mr = PersistenceFacade.getInstance().createModelReference(\n        \"r:24638668-c917-4da1-8069-8ddef862314d(jetbrains.mps.generator.crossmodel.sandbox.beanmodel1)\");\n    // \"r:53fbbbd7-a01f-458c-a76d-a34ed2d6f25f(jetbrains.mps.generator.crossmodel.sandbox.beanmodel2)\"\n    final SModel m = resolve(mr);\n    final Checkpoint cp1 = new Checkpoint(\"aaa\");\n    ModelGenerationPlan plan = new ModelAccessHelper(mpsProject.getModelAccess()).runReadAction(new Computable<ModelGenerationPlan>() {\n      @Override\n      public ModelGenerationPlan compute() {\n        final Transform step1 = new Transform(getCrossmodelPropertyGenerators());\n        final Transform step2 = new Transform(getBaseLanguageGenerators());\n        return new RigidGenerationPlan(step1, cp1, step2);\n      }\n    });\n    final PlanIdentity planIdentity = new PlanIdentity(plan);\n    GenerationOptions opt = GenerationOptions.getDefaults().customPlan(m, plan).create();\n    final TransientModelsProvider tmProvider = mpsProject.getComponent(TransientModelsProvider.class);\n    GenerationFacade genFacade = new GenerationFacade(mpsProject.getRepository(), opt).transients(tmProvider);\n    GenerationStatus genStatus = genFacade.process(new EmptyProgressMonitor(), m);\n    myErrors.checkThat(\"Generation succeeds\", genStatus.isOk(), CoreMatchers.equalTo(true));\n    CrossModelEnvironment cme = new CrossModelEnvironment(tmProvider, new ModelStreamProviderImpl());\n    // XXX shall it be CME to give access to module with checkpoint models? Is there better way to find out cpModel?\n\n    SModule checkpointModule = tmProvider.getCheckpointsModule();\n    final SModelName cpModelName = CrossModelEnvironment.createCheckpointModelName(m.getReference(), cp1);\n    SModel cpModel = null;\n    for (SModel trm : checkpointModule.getModels()) {\n      if (cpModelName.equals(trm.getName())) {\n        cpModel = trm;\n        break;\n      }\n    }\n    myErrors.checkThat(\"Checkpoint model\", cpModel, CoreMatchers.notNullValue());\n    ModelCheckpoints modelCheckpoints = cme.getState(m, planIdentity);\n    myErrors.checkThat(\"CrossModelEnvironment: state present\", modelCheckpoints, CoreMatchers.notNullValue());\n    CheckpointState cpState = modelCheckpoints.find(cp1);\n    myErrors.checkThat(\"CheckpointState present\", cpState, CoreMatchers.notNullValue());\n    if (cpState != null) {\n      Collection<String> mappingLabels = cpState.getMappingLabels();\n      myErrors.checkThat(\"GetterMethod label present\", mappingLabels.contains(\"GetterMethod\"), CoreMatchers.equalTo(true));\n    }\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * entity1.mps is transformed with two generators, Entity --> Bean --> Class. There are two checkpoints, for Beans and for Classes models.\n   * Here we ensure there are mapping labels in both checkpoints, and that output discovered with the first label matches input of a label from second CP.\n   */\n  @Test\n  public void createModelWithTwoCheckpoints() {\n    final SModelReference mr = PersistenceFacade.getInstance().createModelReference(\n        \"r:05c2f926-57b0-4b6d-930c-1aabb187694d(jetbrains.mps.generator.crossmodel.sandbox.entrymodel1)\");\n    final SModel m = resolve(mr);\n    final Checkpoint cp1 = new Checkpoint(\"aaa\");\n    final Checkpoint cp2 = new Checkpoint(\"bbb\");\n    ModelGenerationPlan plan = new ModelAccessHelper(mpsProject.getModelAccess()).runReadAction(new Computable<ModelGenerationPlan>() {\n      @Override\n      public ModelGenerationPlan compute() {\n        final Transform step1 = new Transform(getCrossmodelEntityGenerators());\n        final Transform step2 = new Transform(getCrossmodelPropertyGenerators());\n        final Transform step3 = new Transform(getBaseLanguageGenerators());\n        return new RigidGenerationPlan(step1, cp1, step2, cp2, step3);\n      }\n    });\n    final PlanIdentity planIdentity = new PlanIdentity(plan);\n    GenerationOptions opt = GenerationOptions.getDefaults().customPlan(m, plan).create();\n    final TransientModelsProvider tmProvider = mpsProject.getComponent(TransientModelsProvider.class);\n    GenerationFacade genFacade = new GenerationFacade(mpsProject.getRepository(), opt).transients(tmProvider);\n    GenerationStatus genStatus = genFacade.process(new EmptyProgressMonitor(), m);\n    myErrors.checkThat(\"Generation succeeds\", genStatus.isOk(), CoreMatchers.equalTo(true));\n    CrossModelEnvironment cme = new CrossModelEnvironment(tmProvider);\n    boolean crossModelCheckpointsPresent = cme.hasState(mr, planIdentity);\n    myErrors.checkThat(\"CrossModelEnvironment.hasState\", crossModelCheckpointsPresent, CoreMatchers.equalTo(true));\n    if (!crossModelCheckpointsPresent) {\n      return;\n    }\n    ModelCheckpoints modelCheckpoints = cme.getState(mr, planIdentity);\n    final CheckpointState cp1State = modelCheckpoints.find(cp1);\n    final CheckpointState cp2State = modelCheckpoints.find(cp2);\n    myErrors.checkThat(\"state for the first checkpoint present\", cp1State, CoreMatchers.notNullValue());\n    myErrors.checkThat(\"state for the second checkpoint present\", cp2State, CoreMatchers.notNullValue());\n    if (cp1State == null || cp2State == null) {\n      return;\n    }\n    final String ml1 = \"EntryOne2Property\";\n    final boolean ml1Present = cp1State.getMappingLabels().contains(ml1);\n    final String ml2 = \"GetterMethod\";\n    final boolean ml2Present = cp2State.getMappingLabels().contains(ml2);\n    myErrors.checkThat(\"Entry -> BeanProperty label present\", ml1Present, CoreMatchers.equalTo(true));\n    myErrors.checkThat(\"BeanProperty -> InstanceMethodDeclaration label present\", ml2Present, CoreMatchers.equalTo(true));\n    if (ml1Present && ml2Present) {\n      mpsProject.getModelAccess().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          Collection<SNodeId> entryOneInputs = cp1State.getInputs(ml1);\n          myErrors.checkThat(\"There were two Entry(kind:ONE)\", entryOneInputs.size(), CoreMatchers.equalTo(2));\n          for (SNodeId in : entryOneInputs) {\n            SNode originalInput = m.getNode(in);\n            myErrors.checkThat(\"Original model doesn't contain Entry we've got label recorded for\", originalInput, CoreMatchers.notNullValue());\n            if (originalInput == null) {\n              continue;\n            }\n            Collection<SNode> outputAtCheckpoint1 = cp1State.getOutput(ml1, originalInput);\n            myErrors.checkThat(\"Output at first checkpoint\", outputAtCheckpoint1.isEmpty(), CoreMatchers.equalTo(false));\n            for (SNode cp1Out : outputAtCheckpoint1) {\n              Collection<SNode> outputAtCheckpoint2 = cp2State.getOutput(ml2, cp1Out);\n              myErrors.checkThat(\"Output at second checkpoint\", outputAtCheckpoint2.isEmpty(), CoreMatchers.equalTo(false));\n            }\n          }\n        }\n      });\n    }\n  }","id":32648,"modified_method":"/**\n   * entity1.mps is transformed with two generators, Entity --> Bean --> Class. There are two checkpoints, for Beans and for Classes models.\n   * Here we ensure there are mapping labels in both checkpoints, and that output discovered with the first label matches input of a label from second CP.\n   */\n  @Test\n  public void createModelWithTwoCheckpoints() {\n    final SModelReference mr = PersistenceFacade.getInstance().createModelReference(\n        \"r:05c2f926-57b0-4b6d-930c-1aabb187694d(jetbrains.mps.generator.crossmodel.sandbox.entrymodel1)\");\n    final SModel m = resolve(mr);\n    final Checkpoint cp1 = new Checkpoint(\"aaa\");\n    final Checkpoint cp2 = new Checkpoint(\"bbb\");\n    ModelGenerationPlan plan = new ModelAccessHelper(mpsProject.getModelAccess()).runReadAction(new Computable<ModelGenerationPlan>() {\n      @Override\n      public ModelGenerationPlan compute() {\n        final Transform step1 = new Transform(getCrossmodelEntityGenerators());\n        final Transform step2 = new Transform(getCrossmodelPropertyGenerators());\n        final Transform step3 = new Transform(getBaseLanguageGenerators());\n        return new RigidGenerationPlan(step1, cp1, step2, cp2, step3);\n      }\n    });\n    final PlanIdentity planIdentity = new PlanIdentity(plan);\n    GenerationOptions opt = GenerationOptions.getDefaults().customPlan(m, plan).create();\n    final TransientModelsProvider tmProvider = mpsProject.getComponent(TransientModelsProvider.class);\n    GenerationFacade genFacade = new GenerationFacade(mpsProject.getRepository(), opt).transients(tmProvider);\n    GenerationStatus genStatus = genFacade.process(new EmptyProgressMonitor(), m);\n    myErrors.checkThat(\"Generation succeeds\", genStatus.isOk(), CoreMatchers.equalTo(true));\n    CrossModelEnvironment cme = new CrossModelEnvironment(tmProvider, new ModelStreamProviderImpl());\n    ModelCheckpoints modelCheckpoints = cme.getState(m, planIdentity);\n    boolean crossModelCheckpointsPresent = modelCheckpoints != null;\n    myErrors.checkThat(\"CrossModelEnvironment: state present\", crossModelCheckpointsPresent, CoreMatchers.equalTo(true));\n    if (!crossModelCheckpointsPresent) {\n      return;\n    }\n    final CheckpointState cp1State = modelCheckpoints.find(cp1);\n    final CheckpointState cp2State = modelCheckpoints.find(cp2);\n    myErrors.checkThat(\"state for the first checkpoint present\", cp1State, CoreMatchers.notNullValue());\n    myErrors.checkThat(\"state for the second checkpoint present\", cp2State, CoreMatchers.notNullValue());\n    if (cp1State == null || cp2State == null) {\n      return;\n    }\n    final String ml1 = \"EntryOne2Property\";\n    final boolean ml1Present = cp1State.getMappingLabels().contains(ml1);\n    final String ml2 = \"GetterMethod\";\n    final boolean ml2Present = cp2State.getMappingLabels().contains(ml2);\n    myErrors.checkThat(\"Entry -> BeanProperty label present\", ml1Present, CoreMatchers.equalTo(true));\n    myErrors.checkThat(\"BeanProperty -> InstanceMethodDeclaration label present\", ml2Present, CoreMatchers.equalTo(true));\n    if (ml1Present && ml2Present) {\n      mpsProject.getModelAccess().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          Collection<SNodeId> entryOneInputs = cp1State.getInputs(ml1);\n          myErrors.checkThat(\"There were two Entry(kind:ONE)\", entryOneInputs.size(), CoreMatchers.equalTo(2));\n          for (SNodeId in : entryOneInputs) {\n            SNode originalInput = m.getNode(in);\n            myErrors.checkThat(\"Original model doesn't contain Entry we've got label recorded for\", originalInput, CoreMatchers.notNullValue());\n            if (originalInput == null) {\n              continue;\n            }\n            Collection<SNode> outputAtCheckpoint1 = cp1State.getOutput(ml1, originalInput);\n            myErrors.checkThat(\"Output at first checkpoint\", outputAtCheckpoint1.isEmpty(), CoreMatchers.equalTo(false));\n            for (SNode cp1Out : outputAtCheckpoint1) {\n              Collection<SNode> outputAtCheckpoint2 = cp2State.getOutput(ml2, cp1Out);\n              myErrors.checkThat(\"Output at second checkpoint\", outputAtCheckpoint2.isEmpty(), CoreMatchers.equalTo(false));\n            }\n          }\n        }\n      });\n    }\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SModel[] getCheckpointModelsFor(SModelReference model) {\n    String nameNoStereotype = model.getName().getLongName();\n    ArrayList<SModel> rv = new ArrayList<SModel>(4);\n    for (SModel m : myModule.getModels()) {\n      if (nameNoStereotype.equals(m.getName().getLongName())) {\n        rv.add(m);\n      }\n    }\n    return rv.toArray(new SModel[rv.size()]);\n  }","id":32649,"modified_method":"/**\n   * look up checkpoint models in transient module\n   */\n  private SModel[] getCheckpointModelsFor(SModel model) {\n    String nameNoStereotype = model.getName().getLongName();\n    ArrayList<SModel> rv = new ArrayList<SModel>(4);\n    for (SModel m : myModule.getModels()) {\n      if (nameNoStereotype.equals(m.getName().getLongName())) {\n        rv.add(m);\n      }\n    }\n    return rv.toArray(new SModel[rv.size()]);\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public CrossModelEnvironment(TransientModelsProvider tmProvider) {\n    myTransientModelProvider = tmProvider;\n    myModule = tmProvider.getCheckpointsModule();\n    // FIXME in the future - populate from existing cp models\n    // but for prototype, models visible within same make would suffice\n  }","id":32650,"modified_method":"public CrossModelEnvironment(TransientModelsProvider tmProvider, ModelStreamManager.Provider streamProvider) {\n    myTransientModelProvider = tmProvider;\n    myModule = tmProvider.getCheckpointsModule();\n    // FIXME in the future - populate from existing cp models\n    // but for prototype, models visible within same make would suffice\n    myStreamProvider = streamProvider;\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void publishCheckpoint(@NotNull SModelReference originalModel, @NotNull CheckpointState cpState) {\n    myModule.addModelToKeep(cpState.getCheckpointModel().getReference(), true);\n    List<CheckpointState> checkpoints = myCheckpoints.get(originalModel);\n    if (checkpoints == null) {\n      myCheckpoints.put(originalModel, checkpoints = new ArrayList<CheckpointState>(3));\n    } else {\n      HashSet<SModelReference> forgottenCheckpoints = new HashSet<SModelReference>();\n      for (Iterator<CheckpointState> it = checkpoints.iterator(); it.hasNext(); ) {\n        CheckpointState next = it.next();\n        if (next.getCheckpoint().equals(cpState.getCheckpoint())) {\n          // XXX once checkpoint model is removed, any other checkpoint model referencing it is broken, i.e.\n          // m1@cp1 and m2@cp1, latter referencing the former, and we rebuild m1. Once we get here, we'd schedule m1@cp1 for removal\n          // and at the end of the day we've got m1'@cp1 and m2@cp1 with references pointing to no-longer-existing m1@cp1.\n          // Then, if there'd m3 to generate with the same plan, which references both m1 and m2, it's not clear how to match the two.\n          // The question is, do we need to update references in other @cp1 models, shall we keep all models to preserve any other\n          // checkpoint models (i.e. no forgetModel), or perhaps a dedicated SModelReference that resolves to whatever checkpoint is there.\n          //\n          // Present approach is to drop any model that depends on the one re-generated (resolve to latest CP model might still leave\n          // broken references if m1 is changed, and it's not easy to match nodes of old m1@cp1 versus new m1@cp1, model reference won't suffice\n          // as node id might be different, and we got no control over nodes as they are outcome of black-box ReferenceResolver code.\n          SModelReference cpReference = next.getCheckpointModel().getReference();\n          forgottenCheckpoints.add(cpReference);\n          myModule.forgetModel(cpReference, true);\n          it.remove();\n          break;\n        }\n      }\n      // drop any other checkpoints that may reference the one removed. We've scheduled for removal their respective\n      // transient models already (above with forgetModel(..., true)), now it's time to forget CheckpointState.\n      // Perhaps, shall forget models here explicitly, rather than do the same in TransientModelsModule.forgetModel(..., true)\n      for (List<CheckpointState> cpStates : myCheckpoints.values()) {\n        // intentionally  don't skip cpStates == checkpoints - we need to drop any further checkpoint models not only for\n        // external dependencies, but for subsequent cp models of the same original one, provided they reference the one we've dropped.\n        // Note that the cycle above drops only relevant cp model (compares checkpoint name).\n        for (Iterator<CheckpointState> it = cpStates.iterator(); it.hasNext(); ) {\n          CheckpointState next = it.next();\n          for (SModelReference importElement : SModelOperations.getImportedModelUIDs(next.getCheckpointModel())) {\n            if (forgottenCheckpoints.contains(importElement)) {\n              it.remove();\n              break; // skip other imports, check another state\n            }\n          }\n        }\n      }\n    }\n    checkpoints.add(cpState);\n  }","id":32651,"modified_method":"public void publishCheckpoint(@NotNull SModelReference originalModel, @NotNull CheckpointState cpState) {\n    myModule.addModelToKeep(cpState.getCheckpointModel().getReference(), true);\n    ModelCheckpoints checkpoints = myTransientCheckpoints.get(originalModel);\n    if (checkpoints == null) {\n      // XXX what if there's one in persistent? Shall we copy it into transient and update with the code below?\n      myTransientCheckpoints.put(originalModel, new ModelCheckpoints(cpState));\n    } else {\n      Collection<CheckpointState> discarded = checkpoints.updateAndDiscardOutdated(cpState);\n      HashSet<SModelReference> forgottenCheckpoints = new HashSet<SModelReference>();\n      for (CheckpointState next : discarded) {\n        // XXX once checkpoint model is removed, any other checkpoint model referencing it is broken, i.e.\n        // m1@cp1 and m2@cp1, latter referencing the former, and we rebuild m1. Once we get here, we'd schedule m1@cp1 for removal\n        // and at the end of the day we've got m1'@cp1 and m2@cp1 with references pointing to no-longer-existing m1@cp1.\n        // Then, if there'd m3 to generate with the same plan, which references both m1 and m2, it's not clear how to match the two.\n        // The question is, do we need to update references in other @cp1 models, shall we keep all models to preserve any other\n        // checkpoint models (i.e. no forgetModel), or perhaps a dedicated SModelReference that resolves to whatever checkpoint is there.\n        //\n        // Present approach is to drop any model that depends on the one re-generated (resolve to latest CP model might still leave\n        // broken references if m1 is changed, and it's not easy to match nodes of old m1@cp1 versus new m1@cp1, model reference won't suffice\n        // as node id might be different, and we got no control over nodes as they are outcome of black-box ReferenceResolver code.\n        SModelReference cpReference = next.getCheckpointModel().getReference();\n        forgottenCheckpoints.add(cpReference);\n        myModule.forgetModel(cpReference, true);\n      }\n      // drop any other checkpoints that may reference the one removed. We've scheduled for removal their respective\n      // transient models already (above with forgetModel(..., true)), now it's time to forget CheckpointState.\n      // Perhaps, shall forget models here explicitly, rather than do the same in TransientModelsModule.forgetModel(..., true)\n      for (ModelCheckpoints mcp : myTransientCheckpoints.values()) {\n        // intentionally  don't skip mcp == checkpoints - we need to drop any further checkpoint models not only for\n        // external dependencies, but for subsequent cp models of the same original one, provided they reference the one we've dropped.\n        // Note that the cycle above drops only relevant cp model (compares checkpoint name).\n        mcp.discardOutdated(forgottenCheckpoints, discarded);\n      }\n      // FIXME discarded - as queue and repeat until queue is empty\n    }\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * FIXME keep Nullable or IAE+hasState?\n   * @return recorded checkpoints for the model\n   */\n  @Nullable\n  public ModelCheckpoints getState(@NotNull SModelReference model, @NotNull PlanIdentity planIdentity) {\n    List<CheckpointState> states = myCheckpoints.get(model);\n    if (states != null) {\n      return new ModelCheckpoints(planIdentity, states.toArray(new CheckpointState[states.size()]));\n    }\n    // XXX Not sure whether read shall be local to this class or external on constructor/initialization method (see comment in #hasState() above)\n    //     It seems to be an implementation detail that we traverse model and use its nodes to persist mapping label information (that's what we need RA for).\n    return new ModelAccessHelper(myTransientModelProvider.getRepository()).runReadAction(new Computable<ModelCheckpoints>() {\n      @Override\n      public ModelCheckpoints compute() {\n        SModel[] cpModels = getCheckpointModelsFor(model);\n        return new ModelCheckpoints(myTransientModelProvider.getRepository(), planIdentity, cpModels);\n      }\n    });\n  }","id":32652,"modified_method":"/**\n   * @return recorded checkpoints for the model, if any\n   */\n  @Nullable\n  public ModelCheckpoints getState(@NotNull SModel model, @NotNull PlanIdentity planIdentity) {\n    ModelCheckpoints mcp = myTransientCheckpoints.get(model.getReference());\n    if (mcp != null) {\n      return mcp;\n    }\n    // XXX getCheckpointModelsFor iterates models of the module, hence needs a model read\n    //     OTOH, just a wrap with model read doesn't make sense here (models could get disposed right after the call),\n    //     so likely we shall populate myCheckpoints in constructor/dedicated method. Still, what about checkpoint model disposed *after*\n    //     I've collected all the relevant state for this class?\n    //     Not sure whether read shall be local to this class or external on constructor/initialization method\n    //     It seems to be an implementation detail that we traverse model and use its nodes to persist mapping label information (that's what we need RA for).\n    mcp = new ModelAccessHelper(myTransientModelProvider.getRepository()).runReadAction(new Computable<ModelCheckpoints>() {\n      @Override\n      public ModelCheckpoints compute() {\n        SModel[] cpModels = getCheckpointModelsFor(model);\n        ModelCheckpoints mcp = new ModelCheckpoints(myTransientModelProvider.getRepository(), planIdentity, cpModels);\n        myTransientCheckpoints.put(model.getReference(), mcp);\n        return mcp;\n      }\n    });\n    if (mcp != null) {\n      return mcp;\n    }\n    // FIXME once accessed, perhaps ModelCheckpoints instance shall be kept in myTransientCheckpoints?\n    return getPersistedCheckpoints(model).getCheckpointsFor(planIdentity);\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenControllerContext(@NotNull SRepository repository, @NotNull GenerationOptions options, @NotNull TransientModelsProvider transientModelsProvider, @NotNull ModelStreamManager.Provider streamProvider) {\n    myRepository = repository;\n    myOptions = options;\n    myTransientModelProvider = transientModelsProvider;\n    myStreamProvider = streamProvider;\n    myExportsVault = new ExportsVault(streamProvider);\n    myCrossModelEnvironment = new CrossModelEnvironment(transientModelsProvider);\n//    myCrossModelEnvironment = transientModelsProvider.getCrossModelEnvironment();\n  }","id":32653,"modified_method":"public GenControllerContext(@NotNull SRepository repository, @NotNull GenerationOptions options, @NotNull TransientModelsProvider transientModelsProvider, @NotNull ModelStreamManager.Provider streamProvider) {\n    myRepository = repository;\n    myOptions = options;\n    myTransientModelProvider = transientModelsProvider;\n    myStreamProvider = streamProvider;\n    myExportsVault = new ExportsVault(streamProvider);\n    myCrossModelEnvironment = new CrossModelEnvironment(transientModelsProvider, streamProvider);\n//    myCrossModelEnvironment = transientModelsProvider.getCrossModelEnvironment();\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"ModelCheckpoints(PlanIdentity plan, CheckpointState[] states) {\n    // XXX I don't quite like plan argument here, as it's implicitly assumed\n    // states.getCheckpoint().getPlan matches plan.\n    myPlan = plan;\n    myStates = Arrays.asList(states);\n  }","id":32654,"modified_method":"/**\n   * @param state not null\n   */\n  /*package*/ ModelCheckpoints(CheckpointState state) {\n    myPlan = state.getCheckpoint().getPlan();\n    myStates = Collections.singletonList(state);\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * For a cross-mode reference, we expect inputNode to point either at original model (or external non-transient model), or one of checkpoint models.\n   * There's no evidence one could get anything but that for a node referenced from another model during generation (i.e. no chances for inputNode to point\n   * to intermediate transient model).\n   */\n  @Override\n  public SNode findOutputNodeByInputNodeAndMappingName(SNode inputNode, String mappingName) {\n    SNode existing = super.findOutputNodeByInputNodeAndMappingName(inputNode, mappingName);\n    if (existing != null) {\n      // XXX apparently, there are models that use input nodes from a model other than that being transformed\n      // e.g. in build.workflow, bl.closures, bl.collections. Shall revert the change and try to rebuild\n      // to find out particular uses, as it's potential error (i.e. MLs between different models).\n      // For now, though, just check if there's mapping, and use it.\n      return existing;\n    }\n    if (inputNode == null) {\n      // there are models e.g. bl.plugin, debugger.api.ui.icons, d.java.runtime.ui that pass null as inputNode\n      return null;\n    }\n    SModel inputNodeModel = inputNode.getModel();\n    if (inputNodeModel == getInputModel()) {\n//      return super.findOutputNodeByInputNodeAndMappingName(inputNode, mappingName);\n      return null; // code down there deals with xModel references only\n    }\n    if (inputNodeModel == null) {\n      return null;\n    }\n    CrossModelEnvironment env = getGeneratorSessionContext().getCrossModelEnvironment();\n    if (!env.hasState(inputNodeModel.getReference(), myPlanStep.getPlanIdentity())) {\n      return null;\n    }\n    ModelCheckpoints modelHistory = env.getState(inputNodeModel.getReference(), myPlanStep.getPlanIdentity());\n    // last and next are not necessarily in immediately adjacent generation steps, i.e. cpLast, transfStep1, transfStep2, activeTransformStep, transfStep3, cpNext\n    Checkpoint lastPoint = myPlanStep.getLastCheckpoint();\n    Checkpoint targetPoint = myPlanStep.getNextCheckpoint();\n    CheckpointState cp = modelHistory.find(targetPoint);\n    if (cp == null) {\n      return null;\n    }\n    // FIXME we might want to ensure inputNode comes from the lastPoint checkpoint. However, unless we keep TransitionState along with the\n    //       checkpointState, I see no way to confirm inputNode comes from lastPoint (the moment we've built CheckpointState, we dispose\n    //       TransitionTrace and could not find out what are origins of the node in checkpoint model. Technically, it's not true now,\n    //       as there are user objects in the checkpoint model, however, this might get changed, so I can't rely on that, unless there's\n    //       a conscious decision to keep transition trace and to ensure validity of input nodes and their originating CP).\n    Collection<SNode> output = cp.getOutput(mappingName, inputNode);\n    if (output.size() == 1) {\n      return output.iterator().next();\n    }\n    return null;\n\n  }","id":32655,"modified_method":"/**\n   * For a cross-mode reference, we expect inputNode to point either at original model (or external non-transient model), or one of checkpoint models.\n   * There's no evidence one could get anything but that for a node referenced from another model during generation (i.e. no chances for inputNode to point\n   * to intermediate transient model).\n   */\n  @Override\n  public SNode findOutputNodeByInputNodeAndMappingName(SNode inputNode, String mappingName) {\n    SNode existing = super.findOutputNodeByInputNodeAndMappingName(inputNode, mappingName);\n    if (existing != null) {\n      // XXX apparently, there are models that use input nodes from a model other than that being transformed\n      // e.g. in build.workflow, bl.closures, bl.collections. Shall revert the change and try to rebuild\n      // to find out particular uses, as it's potential error (i.e. MLs between different models).\n      // For now, though, just check if there's mapping, and use it.\n      return existing;\n    }\n    if (inputNode == null) {\n      // there are models e.g. bl.plugin, debugger.api.ui.icons, d.java.runtime.ui that pass null as inputNode\n      return null;\n    }\n    SModel inputNodeModel = inputNode.getModel();\n    if (inputNodeModel == getInputModel()) {\n//      return super.findOutputNodeByInputNodeAndMappingName(inputNode, mappingName);\n      return null; // code down there deals with xModel references only\n    }\n    if (inputNodeModel == null) {\n      return null;\n    }\n    CrossModelEnvironment env = getGeneratorSessionContext().getCrossModelEnvironment();\n    ModelCheckpoints modelHistory = env.getState(inputNodeModel, myPlanStep.getPlanIdentity());\n    if (modelHistory == null) {\n      return null;\n    }\n    // last and next are not necessarily in immediately adjacent generation steps, i.e. cpLast, transfStep1, transfStep2, activeTransformStep, transfStep3, cpNext\n    Checkpoint lastPoint = myPlanStep.getLastCheckpoint();\n    Checkpoint targetPoint = myPlanStep.getNextCheckpoint();\n    CheckpointState cp = modelHistory.find(targetPoint);\n    if (cp == null) {\n      return null;\n    }\n    // FIXME we might want to ensure inputNode comes from the lastPoint checkpoint. However, unless we keep TransitionState along with the\n    //       checkpointState, I see no way to confirm inputNode comes from lastPoint (the moment we've built CheckpointState, we dispose\n    //       TransitionTrace and could not find out what are origins of the node in checkpoint model. Technically, it's not true now,\n    //       as there are user objects in the checkpoint model, however, this might get changed, so I can't rely on that, unless there's\n    //       a conscious decision to keep transition trace and to ensure validity of input nodes and their originating CP).\n    Collection<SNode> output = cp.getOutput(mappingName, inputNode);\n    if (output.size() == 1) {\n      return output.iterator().next();\n    }\n    return null;\n\n  }","commit_id":"a2633871e6a47a8a22479f8f41082f6662f0c76a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext, boolean update)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (message.getStatus() != StatusConstants.APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (Validator.isNull(layoutFullURL) || message.isDiscussion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getScopeGroupId());\n\n\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\tString emailAddress = user.getEmailAddress();\n\t\tString fullName = user.getFullName();\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, user);\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","id":32656,"modified_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext, boolean update)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (message.getStatus() != StatusConstants.APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (Validator.isNull(layoutFullURL) || message.isDiscussion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getScopeGroupId());\n\n\t\tUser user = null;\n\t\tString fullName = null;\n\t\tString emailAddress = null;\n\n\t\ttry {\n\t\t\tuser = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = message.getUserName();\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategory.getName(),\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHost(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","commit_id":"4d7f07b68a7b6d190601b4875babb543b70d7969","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFlagEntry(\n\t\t\tString className, long classPK, long reportedUserId,\n\t\t\tString contentTitle, String contentURL,\tString reason,\n\t\t\tString emailAddress, ServiceContext serviceContext)\n\t\tthrows Exception{\n\n\t\t// Company\n\n\t\tlong companyId = serviceContext.getCompanyId();\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getCompanyId());\n\n\t\t// Reporter User\n\n\t\tString reporterUserName = null;\n\t\tString reporterUserEmailAddress = null;\n\n\t\tUser reporterUser = userPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getUserId());\n\n\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\tif (reporterUser == null || reporterUser.isDefaultUser()) {\n\t\t\treporterUserName = LanguageUtil.get(locale, \"an-anonymous-user\");\n\n\t\t\tif (Validator.isNotNull(emailAddress)) {\n\t\t\t\treporterUserEmailAddress = emailAddress;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treporterUserEmailAddress = LanguageUtil.get(\n\t\t\t\t\tlocale, \"no-email-address-provided\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treporterUserName = reporterUser.getFullName();\n\t\t\treporterUserEmailAddress = reporterUser.getEmailAddress();\n\t\t}\n\n\t\t// Reported User\n\n\t\tUser reportedUser = userPersistence.findByPrimaryKey(reportedUserId);\n\n\t\tString reportedUserName = reportedUser.getFullName();\n\t\tString reportedUserEmailAddress = reportedUser.getEmailAddress();\n\t\tString reportedUserURL = reportedUser.getDisplayURL(\n\t\t\tserviceContext.getPortalURL(), serviceContext.getPathMain());\n\n\t\t// Group\n\n\t\tLayout layout = layoutPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getPlid());\n\n\t\tGroup group = layout.getGroup();\n\n\t\t// Email\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_FROM_NAME);\n\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_SUBJECT);\n\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_BODY);\n\n\t\tList<User> receivers = getAdministrators(\n\t\t\tcompanyId, serviceContext.getScopeGroupId());\n\n\t\tString localizedReason = LanguageUtil.get(locale, reason);\n\t\tString contentType = LanguageUtil.get(\n\t\t\tlocale, \"model.resource.\" + className);\n\n\t\tfor (User receiver : receivers) {\n\t\t\tnotify(\n\t\t\t\tfromAddress, fromName, receiver.getEmailAddress(),\n\t\t\t\treceiver.getFullName(), companyId, company.getMx(),\n\t\t\t\tcompany.getName(), company.getVirtualHost(),\n\t\t\t\tgroup.getDescriptiveName(), reporterUserEmailAddress,\n\t\t\t\treporterUserName, reportedUserEmailAddress, reportedUserName,\n\t\t\t\treportedUserURL, contentTitle, contentType, contentURL, classPK,\n\t\t\t\tlocalizedReason, subject, body);\n\t\t}\n\t}","id":32657,"modified_method":"public void addFlagEntry(\n\t\t\tString className, long classPK, long reportedUserId,\n\t\t\tString contentTitle, String contentURL,\tString reason,\n\t\t\tString emailAddress, ServiceContext serviceContext)\n\t\tthrows Exception{\n\n\t\t// Company\n\n\t\tlong companyId = serviceContext.getCompanyId();\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getCompanyId());\n\n\t\t// Group\n\n\t\tLayout layout = layoutPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getPlid());\n\n\t\tGroup group = layout.getGroup();\n\n\t\t// Reporter User\n\n\t\tString reporterUserName = null;\n\t\tString reporterUserEmailAddress = null;\n\n\t\tUser reporterUser = userPersistence.findByPrimaryKey(\n\t\t\tserviceContext.getUserId());\n\n\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\tif (reporterUser == null || reporterUser.isDefaultUser()) {\n\t\t\treporterUserName = LanguageUtil.get(locale, \"an-anonymous-user\");\n\n\t\t\tif (Validator.isNotNull(emailAddress)) {\n\t\t\t\treporterUserEmailAddress = emailAddress;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treporterUserEmailAddress = LanguageUtil.get(\n\t\t\t\t\tlocale, \"no-email-address-provided\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treporterUserName = reporterUser.getFullName();\n\t\t\treporterUserEmailAddress = reporterUser.getEmailAddress();\n\t\t}\n\n\t\t// Reported User\n\t\tString reportedUserName = StringPool.BLANK;\n\t\tString reportedUserEmailAddress = StringPool.BLANK;\n\t\tString reportedUserURL = StringPool.BLANK;\n\n\t\tUser reportedUser = userPersistence.findByPrimaryKey(reportedUserId);\n\t\tif (reportedUser.isDefaultUser()){\n\t\t\treportedUserName = group.getDescriptiveName();\n\t\t}\n\t\telse {\n\t\t\treportedUserName = reportedUser.getFullName();\n\t\t\treportedUserEmailAddress = reportedUser.getEmailAddress();\n\t\t\treportedUserURL = reportedUser.getDisplayURL(\n\t\t\tserviceContext.getPortalURL(), serviceContext.getPathMain());\n\t\t}\n\n\n\n\t\t// Email\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_FROM_NAME);\n\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_SUBJECT);\n\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.FLAGS_EMAIL_BODY);\n\n\t\tList<User> receivers = getAdministrators(\n\t\t\tcompanyId, serviceContext.getScopeGroupId());\n\n\t\tString localizedReason = LanguageUtil.get(locale, reason);\n\t\tString contentType = LanguageUtil.get(\n\t\t\tlocale, \"model.resource.\" + className);\n\n\t\tfor (User receiver : receivers) {\n\t\t\tnotify(\n\t\t\t\tfromAddress, fromName, receiver.getEmailAddress(),\n\t\t\t\treceiver.getFullName(), companyId, company.getMx(),\n\t\t\t\tcompany.getName(), company.getVirtualHost(),\n\t\t\t\tgroup.getDescriptiveName(), reporterUserEmailAddress,\n\t\t\t\treporterUserName, reportedUserEmailAddress, reportedUserName,\n\t\t\t\treportedUserURL, contentTitle, contentType, contentURL, classPK,\n\t\t\t\tlocalizedReason, subject, body);\n\t\t}\n\t}","commit_id":"8b111534f08add329895e7c38289cc0e88b3b1eb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\trequest.setAttribute(\"liferay-ui:flags:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:flags:classPK\", String.valueOf(_classPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:flags:userId\", String.valueOf(_userId));\n\t\trequest.setAttribute(\"liferay-ui:flags:title\", _title);\n\n\t\treturn EVAL_BODY_BUFFERED;\n\t}","id":32658,"modified_method":"public int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\trequest.setAttribute(\"liferay-ui:flags:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:flags:classPK\", String.valueOf(_classPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:flags:userId\", String.valueOf(_userId));\n\t\trequest.setAttribute(\"liferay-ui:flags:title\", _title);\n\t\trequest.setAttribute(\"liferay-ui:flags:message\", _message);\n\t\trequest.setAttribute(\"liferay-ui:flags:label\", String.valueOf(_label));\n\n\t\treturn EVAL_BODY_BUFFERED;\n\t}","commit_id":"8b111534f08add329895e7c38289cc0e88b3b1eb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setCalendarDataHandlers(\n\t\tMap<String, CalendarDataHandler> calendarDataHandlers) {\n\n\t\tPortalRuntimePermission.checkSetBeanProperty(getClass());\n\n\t\t_dataHandlers = new HashMap<CalendarDataFormat, CalendarDataHandler>();\n\n\t\tfor (Map.Entry<String, CalendarDataHandler> entry :\n\t\t\t\tcalendarDataHandlers.entrySet()) {\n\n\t\t\tCalendarDataFormat calendarDataFormat = CalendarDataFormat.parse(\n\t\t\t\tentry.getKey());\n\n\t\t\t_dataHandlers.put(calendarDataFormat, entry.getValue());\n\t\t}\n\t}","id":32659,"modified_method":"public void setCalendarDataHandlers(\n\t\tMap<String, CalendarDataHandler> calendarDataHandlers) {\n\n\t\tPortalRuntimePermission.checkSetBeanProperty(getClass());\n\n\t\t_calendarDataHandlers =\n\t\t\tnew HashMap<CalendarDataFormat, CalendarDataHandler>();\n\n\t\tfor (Map.Entry<String, CalendarDataHandler> entry :\n\t\t\t\tcalendarDataHandlers.entrySet()) {\n\n\t\t\tCalendarDataFormat calendarDataFormat = CalendarDataFormat.parse(\n\t\t\t\tentry.getKey());\n\n\t\t\t_calendarDataHandlers.put(calendarDataFormat, entry.getValue());\n\t\t}\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static CalendarDataHandler getCalendarDataHandler(\n\t\t\tCalendarDataFormat calendarDataFormat)\n\t\tthrows PortalException {\n\n\t\tCalendarDataHandler calendarDataHandler = _dataHandlers.get(\n\t\t\tcalendarDataFormat);\n\n\t\tif (calendarDataHandler == null) {\n\t\t\tthrow new PortalException(\n\t\t\t\t\"Invalid format type \" + calendarDataFormat);\n\t\t}\n\n\t\treturn calendarDataHandler;\n\t}","id":32660,"modified_method":"public static CalendarDataHandler getCalendarDataHandler(\n\t\t\tCalendarDataFormat calendarDataFormat)\n\t\tthrows PortalException {\n\n\t\tCalendarDataHandler calendarDataHandler = _calendarDataHandlers.get(\n\t\t\tcalendarDataFormat);\n\n\t\tif (calendarDataHandler == null) {\n\t\t\tthrow new PortalException(\n\t\t\t\t\"Invalid format type \" + calendarDataFormat);\n\t\t}\n\n\t\treturn calendarDataHandler;\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected net.fortuna.ical4j.model.Calendar toICalCalendar(\n\t\tList<CalendarBooking> calendarBookings) throws Exception {\n\n\t\tnet.fortuna.ical4j.model.Calendar iCal =\n\t\t\tnew net.fortuna.ical4j.model.Calendar();\n\n\t\tProdId prodId = new ProdId(\n\t\t\t\"-//Liferay Inc//Liferay Portal \" + ReleaseInfo.getVersion() +\n\t\t\t\"//EN\");\n\n\t\tPropertyList propertiesList = iCal.getProperties();\n\n\t\tpropertiesList.add(prodId);\n\t\tpropertiesList.add(Version.VERSION_2_0);\n\t\tpropertiesList.add(CalScale.GREGORIAN);\n\t\tpropertiesList.add(Method.PUBLISH);\n\n\t\tList<VEvent> components = iCal.getComponents();\n\n\t\tfor (CalendarBooking calendarBooking : calendarBookings) {\n\t\t\tcomponents.add(toICalEvent(calendarBooking));\n\t\t}\n\n\t\treturn iCal;\n\t}","id":32661,"modified_method":"protected net.fortuna.ical4j.model.Calendar toICalCalendar(\n\t\t\tList<CalendarBooking> calendarBookings)\n\t\tthrows Exception {\n\n\t\tnet.fortuna.ical4j.model.Calendar iCalCalendar =\n\t\t\tnew net.fortuna.ical4j.model.Calendar();\n\n\t\tPropertyList propertiesList = iCalCalendar.getProperties();\n\n\t\tProdId prodId = new ProdId(\n\t\t\t\"-//Liferay Inc//Liferay Portal \" + ReleaseInfo.getVersion() +\n\t\t\t\"//EN\");\n\n\t\tpropertiesList.add(prodId);\n\n\t\tpropertiesList.add(Version.VERSION_2_0);\n\t\tpropertiesList.add(CalScale.GREGORIAN);\n\t\tpropertiesList.add(Method.PUBLISH);\n\n\t\tList<VEvent> vEvents = iCalCalendar.getComponents();\n\n\t\tfor (CalendarBooking calendarBooking : calendarBookings) {\n\t\t\tvEvents.add(toICalEvent(calendarBooking));\n\t\t}\n\n\t\treturn iCalCalendar;\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected boolean isICalDateOnly(DateProperty dateProperty) {\n\t\tParameter valueParameter = dateProperty.getParameter(Parameter.VALUE);\n\n\t\tif ((valueParameter != null) &&\n\t\t\tvalueParameter.getValue().equals(\"DATE\")) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":32662,"modified_method":"protected boolean isICalDateOnly(DateProperty dateProperty) {\n\t\tParameter valueParameter = dateProperty.getParameter(Parameter.VALUE);\n\n\t\tif (valueParameter == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString value = valueParameter.getValue();\n\n\t\tif (value.equals(\"DATE\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void importICalEvent(long calendarId, VEvent event)\n\t\tthrows Exception {\n\n\t\tCalendar calendar = CalendarLocalServiceUtil.getCalendar(calendarId);\n\n\t\tlong companyId = calendar.getCompanyId();\n\t\tlong groupId = calendar.getGroupId();\n\n\t\tUser owner = UserLocalServiceUtil.getUser(calendar.getUserId());\n\n\t\tLocale locale = owner.getLocale();\n\n\t\t// Title\n\n\t\tMap<Locale, String> titleMap = new HashMap<Locale, String>();\n\n\t\tSummary summary = event.getSummary();\n\n\t\tif (summary != null) {\n\t\t\tString title = ModelHintsUtil.trimString(\n\t\t\t\tCalendarBooking.class.getName(), \"title\", summary.getValue());\n\n\t\t\ttitleMap.put(locale, title);\n\t\t}\n\n\t\t// Description\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tDescription description = event.getDescription();\n\n\t\tif (description != null) {\n\t\t\tdescriptionMap.put(locale, description.getValue());\n\t\t}\n\n\t\t// Location\n\n\t\tString location = StringPool.BLANK;\n\n\t\tif (event.getLocation() != null) {\n\t\t\tlocation = event.getLocation().getValue();\n\t\t}\n\n\t\t// Start date\n\n\t\tDate startDate = event.getStartDate().getDate();\n\n\t\t// End date\n\n\t\tDate endDate = event.getEndDate().getDate();\n\n\t\t// All day\n\n\t\tboolean allDay = false;\n\n\t\tif (isICalDateOnly(event.getStartDate())) {\n\t\t\tallDay = true;\n\t\t}\n\n\t\t// Recurrence\n\n\t\tRRule rrule = (RRule)event.getProperty(Property.RRULE);\n\n\t\tString recurrence = StringPool.BLANK;\n\n\t\tif (rrule != null) {\n\t\t\trecurrence = StringUtil.trim(rrule.toString());\n\t\t}\n\n\t\t// Reminders\n\n\t\tComponentList alarms = event.getAlarms();\n\n\t\tint remindersSize = alarms.size();\n\n\t\tlong[] reminders = new long[remindersSize];\n\t\tString[] reminderTypes = new String[remindersSize];\n\n\t\tint i = 0;\n\n\t\tfor (Iterator<VAlarm> it = alarms.iterator(); it.hasNext(); i++) {\n\t\t\tVAlarm vAlarm = it.next();\n\n\t\t\tAction action = vAlarm.getAction();\n\n\t\t\tString value = StringUtil.lowerCase(action.getValue());\n\n\t\t\tif (!isActionSupported(value)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treminderTypes[i] = value;\n\n\t\t\tTrigger trigger = vAlarm.getTrigger();\n\n\t\t\tDur dur = trigger.getDuration();\n\n\t\t\tlong time = (dur.getWeeks() * Time.WEEK) +\n\t\t\t\t(dur.getDays() * Time.DAY) + (dur.getHours() * Time.HOUR) +\n\t\t\t\t(dur.getMinutes() * Time.MINUTE) +\n\t\t\t\t(dur.getSeconds() * Time.SECOND);\n\n\t\t\treminders[i] = time;\n\t\t}\n\n\t\t// Attendees\n\n\t\tPropertyList attendees = event.getProperties(Property.ATTENDEE);\n\n\t\tList<Long> childCalendarIds = new ArrayList<Long>();\n\n\t\tfor (Iterator<Attendee> it = attendees.iterator(); it.hasNext();) {\n\t\t\tAttendee attendee = it.next();\n\n\t\t\tURI calAddress = attendee.getCalAddress();\n\n\t\t\tUser user = UserLocalServiceUtil.fetchUserByEmailAddress(\n\t\t\t\tcompanyId, calAddress.getSchemeSpecificPart());\n\n\t\t\tif ((user == null) || (calendar.getUserId() == user.getUserId())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setCompanyId(companyId);\n\t\t\tserviceContext.setScopeGroupId(groupId);\n\n\t\t\tCalendarResource calendarResource =\n\t\t\t\tCalendarResourceUtil.getUserCalendarResource(\n\t\t\t\t\tuser.getUserId(), serviceContext);\n\n\t\t\tif (calendarResource == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchildCalendarIds.add(calendarResource.getDefaultCalendarId());\n\t\t}\n\n\t\t// Merge calendar booking\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(groupId);\n\n\t\tString uuid = null;\n\n\t\tCalendarBooking calendarBooking = null;\n\n\t\tUid uid = event.getUid();\n\n\t\tif (uid != null) {\n\t\t\tuuid = uid.getValue();\n\n\t\t\tcalendarBooking =\n\t\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(\n\t\t\t\t\tuuid, groupId);\n\n\t\t\tif (calendarBooking == null) {\n\t\t\t\tuuid = PortalUUIDUtil.generate(uuid.getBytes());\n\n\t\t\t\tcalendarBooking =\n\t\t\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(\n\t\t\t\t\t\tuuid, calendar.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tlong[] childCalendarIdsArray = ArrayUtil.toArray(\n\t\t\tchildCalendarIds.toArray(new Long[childCalendarIds.size()]));\n\n\t\tlong firstReminder = 0;\n\t\tString firstReminderType = null;\n\n\t\tlong secondReminder = 0;\n\t\tString secondReminderType = null;\n\n\t\tif (remindersSize > 0) {\n\t\t\tfirstReminder = reminders[0];\n\t\t\tfirstReminderType = reminderTypes[0];\n\n\t\t\tif (remindersSize > 1) {\n\t\t\t\tsecondReminder = reminders[1];\n\t\t\t\tsecondReminderType = reminderTypes[1];\n\t\t\t}\n\t\t}\n\n\t\tif (calendarBooking == null) {\n\t\t\tserviceContext.setUuid(uuid);\n\n\t\t\tCalendarBookingServiceUtil.addCalendarBooking(\n\t\t\t\tcalendarId, childCalendarIdsArray,\n\t\t\t\tCalendarBookingConstants.PARENT_CALENDAR_BOOKING_ID_DEFAULT,\n\t\t\t\ttitleMap, descriptionMap, location, startDate.getTime(),\n\t\t\t\tendDate.getTime(), allDay, recurrence, firstReminder,\n\t\t\t\tfirstReminderType, secondReminder, secondReminderType,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tCalendarBookingServiceUtil.updateCalendarBooking(\n\t\t\t\tcalendarBooking.getCalendarBookingId(), calendarId,\n\t\t\t\tchildCalendarIdsArray, titleMap, descriptionMap, location,\n\t\t\t\tstartDate.getTime(), endDate.getTime(), allDay, recurrence,\n\t\t\t\tfirstReminder, firstReminderType, secondReminder,\n\t\t\t\tsecondReminderType, calendarBooking.getStatus(),\n\t\t\t\tserviceContext);\n\t\t}\n\t}","id":32663,"modified_method":"protected void importICalEvent(long calendarId, VEvent vEvent)\n\t\tthrows Exception {\n\n\t\tCalendar calendar = CalendarLocalServiceUtil.getCalendar(calendarId);\n\n\t\t// Title\n\n\t\tUser user = UserLocalServiceUtil.getUser(calendar.getUserId());\n\n\t\tMap<Locale, String> titleMap = new HashMap<Locale, String>();\n\n\t\tSummary summary = vEvent.getSummary();\n\n\t\tif (summary != null) {\n\t\t\tString title = ModelHintsUtil.trimString(\n\t\t\t\tCalendarBooking.class.getName(), \"title\", summary.getValue());\n\n\t\t\ttitleMap.put(user.getLocale(), title);\n\t\t}\n\n\t\t// Description\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tDescription description = vEvent.getDescription();\n\n\t\tif (description != null) {\n\t\t\tdescriptionMap.put(user.getLocale(), description.getValue());\n\t\t}\n\n\t\t// Location\n\n\t\tString locationString = StringPool.BLANK;\n\n\t\tLocation location = vEvent.getLocation();\n\n\t\tif (location != null) {\n\t\t\tlocationString = location.getValue();\n\t\t}\n\n\t\t// Dates\n\n\t\tDtStart dtStart = vEvent.getStartDate();\n\n\t\tDate startDate = dtStart.getDate();\n\n\t\tDtEnd dtEnd = vEvent.getEndDate();\n\n\t\tDate endDate = dtEnd.getDate();\n\n\t\t// All day\n\n\t\tboolean allDay = false;\n\n\t\tif (isICalDateOnly(dtStart)) {\n\t\t\tallDay = true;\n\t\t}\n\n\t\t// Recurrence\n\n\t\tRRule rrule = (RRule)vEvent.getProperty(Property.RRULE);\n\n\t\tString recurrence = StringPool.BLANK;\n\n\t\tif (rrule != null) {\n\t\t\trecurrence = StringUtil.trim(rrule.toString());\n\t\t}\n\n\t\t// Reminders\n\n\t\tComponentList componentList = vEvent.getAlarms();\n\n\t\tlong[] reminders = new long[componentList.size()];\n\t\tString[] reminderTypes = new String[componentList.size()];\n\n\t\tint i = 0;\n\n\t\tfor (Iterator<VAlarm> iterator = componentList.iterator();\n\t\t\t\titerator.hasNext(); i++) {\n\n\t\t\tVAlarm vAlarm = iterator.next();\n\n\t\t\tAction action = vAlarm.getAction();\n\n\t\t\tString value = StringUtil.lowerCase(action.getValue());\n\n\t\t\tif (!isActionSupported(value)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treminderTypes[i] = value;\n\n\t\t\tTrigger trigger = vAlarm.getTrigger();\n\n\t\t\tDur dur = trigger.getDuration();\n\n\t\t\tlong time = 0;\n\n\t\t\ttime += dur.getWeeks() * Time.WEEK;\n\t\t\ttime += dur.getDays() * Time.DAY;\n\t\t\ttime += dur.getHours() * Time.HOUR;\n\t\t\ttime += dur.getMinutes() * Time.MINUTE;\n\t\t\ttime += dur.getSeconds() * Time.SECOND;\n\n\t\t\treminders[i] = time;\n\t\t}\n\n\t\tlong firstReminder = 0;\n\t\tString firstReminderType = null;\n\t\tlong secondReminder = 0;\n\t\tString secondReminderType = null;\n\n\t\tif (!componentList.isEmpty()) {\n\t\t\tfirstReminder = reminders[0];\n\t\t\tfirstReminderType = reminderTypes[0];\n\n\t\t\tif (componentList.size() > 1) {\n\t\t\t\tsecondReminder = reminders[1];\n\t\t\t\tsecondReminderType = reminderTypes[1];\n\t\t\t}\n\t\t}\n\n\t\t// Attendees\n\n\t\tPropertyList propertyList = vEvent.getProperties(Property.ATTENDEE);\n\n\t\tList<Long> childCalendarIds = new ArrayList<Long>();\n\n\t\tfor (Iterator<Attendee> iterator = propertyList.iterator();\n\t\t\t\titerator.hasNext();) {\n\n\t\t\tAttendee attendee = iterator.next();\n\n\t\t\tURI uri = attendee.getCalAddress();\n\n\t\t\tUser attendeeUser = UserLocalServiceUtil.fetchUserByEmailAddress(\n\t\t\t\tcalendar.getCompanyId(), uri.getSchemeSpecificPart());\n\n\t\t\tif ((attendeeUser == null) ||\n\t\t\t\t(calendar.getUserId() == attendeeUser.getUserId())) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setCompanyId(calendar.getCompanyId());\n\t\t\tserviceContext.setScopeGroupId(calendar.getGroupId());\n\n\t\t\tCalendarResource calendarResource =\n\t\t\t\tCalendarResourceUtil.getUserCalendarResource(\n\t\t\t\t\tattendeeUser.getUserId(), serviceContext);\n\n\t\t\tif (calendarResource == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchildCalendarIds.add(calendarResource.getDefaultCalendarId());\n\t\t}\n\n\t\tlong[] childCalendarIdsArray = ArrayUtil.toArray(\n\t\t\tchildCalendarIds.toArray(new Long[childCalendarIds.size()]));\n\n\t\t// Merge calendar booking\n\n\t\tCalendarBooking calendarBooking = null;\n\n\t\tString uuid = null;\n\n\t\tUid uid = vEvent.getUid();\n\n\t\tif (uid != null) {\n\t\t\tuuid = uid.getValue();\n\n\t\t\tcalendarBooking =\n\t\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(\n\t\t\t\t\tuuid, calendar.getGroupId());\n\n\t\t\tif (calendarBooking == null) {\n\t\t\t\tuuid = PortalUUIDUtil.generate(uuid.getBytes());\n\n\t\t\t\tcalendarBooking =\n\t\t\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(\n\t\t\t\t\t\tuuid, calendar.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(calendar.getGroupId());\n\n\t\tif (calendarBooking == null) {\n\t\t\tserviceContext.setUuid(uuid);\n\n\t\t\tCalendarBookingServiceUtil.addCalendarBooking(\n\t\t\t\tcalendarId, childCalendarIdsArray,\n\t\t\t\tCalendarBookingConstants.PARENT_CALENDAR_BOOKING_ID_DEFAULT,\n\t\t\t\ttitleMap, descriptionMap, locationString, startDate.getTime(),\n\t\t\t\tendDate.getTime(), allDay, recurrence, firstReminder,\n\t\t\t\tfirstReminderType, secondReminder, secondReminderType,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tCalendarBookingServiceUtil.updateCalendarBooking(\n\t\t\t\tcalendarBooking.getCalendarBookingId(), calendarId,\n\t\t\t\tchildCalendarIdsArray, titleMap, descriptionMap, locationString,\n\t\t\t\tstartDate.getTime(), endDate.getTime(), allDay, recurrence,\n\t\t\t\tfirstReminder, firstReminderType, secondReminder,\n\t\t\t\tsecondReminderType, calendarBooking.getStatus(),\n\t\t\t\tserviceContext);\n\t\t}\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected DateTime toICalDateTime(long time) {\n\t\tDateTime dateTime = new DateTime();\n\n\t\tdateTime.setUtc(true);\n\t\tdateTime.setTime(time);\n\n\t\treturn dateTime;\n\t}","id":32664,"modified_method":"protected DateTime toICalDateTime(long time) {\n\t\tDateTime dateTime = new DateTime();\n\n\t\tdateTime.setTime(time);\n\t\tdateTime.setUtc(true);\n\n\t\treturn dateTime;\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void importCalendar(long calendarId, String data) throws Exception {\n\t\tCalendarBuilder builder = new CalendarBuilder();\n\n\t\tUnsyncStringReader unsyncStringReader = new UnsyncStringReader(data);\n\n\t\tnet.fortuna.ical4j.model.Calendar calendar = builder.build(\n\t\t\tunsyncStringReader);\n\n\t\tList<VEvent> vEvents = calendar.getComponents(Component.VEVENT);\n\n\t\tfor (VEvent vEvent : vEvents) {\n\t\t\timportICalEvent(calendarId, vEvent);\n\t\t}\n\t}","id":32665,"modified_method":"public void importCalendar(long calendarId, String data) throws Exception {\n\t\tCalendarBuilder calendarBuilder = new CalendarBuilder();\n\n\t\tUnsyncStringReader unsyncStringReader = new UnsyncStringReader(data);\n\n\t\tnet.fortuna.ical4j.model.Calendar iCalCalendar = calendarBuilder.build(\n\t\t\tunsyncStringReader);\n\n\t\tList<VEvent> vEvents = iCalCalendar.getComponents(Component.VEVENT);\n\n\t\tfor (VEvent vEvent : vEvents) {\n\t\t\timportICalEvent(calendarId, vEvent);\n\t\t}\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected VAlarm toICalAlarm(\n\t\tNotificationType notificationType, long reminder, String emailAddress) {\n\n\t\tDur dur = toICalDur(reminder);\n\n\t\tVAlarm alarm = new VAlarm(dur);\n\n\t\tPropertyList alarmProps = alarm.getProperties();\n\n\t\tAction action = Action.DISPLAY;\n\n\t\tif (notificationType == NotificationType.EMAIL) {\n\t\t\tURI uri = URI.create(\"mailto:\".concat(emailAddress));\n\n\t\t\tAttendee attendee = new Attendee(uri);\n\n\t\t\taction = Action.EMAIL;\n\n\t\t\talarmProps.add(attendee);\n\t\t\talarmProps.add(new Summary(\"Alarm notification\"));\n\t\t}\n\n\t\talarmProps.add(action);\n\t\talarmProps.add(new Description(\"This is an event reminder\"));\n\n\t\treturn alarm;\n\t}","id":32666,"modified_method":"protected VAlarm toICalAlarm(\n\t\tNotificationType notificationType, long reminder, String emailAddress) {\n\n\t\tDur dur = toICalDur(reminder);\n\n\t\tVAlarm vAlarm = new VAlarm(dur);\n\n\t\tPropertyList propertyList = vAlarm.getProperties();\n\n\t\tAction action = Action.DISPLAY;\n\n\t\tif (notificationType == NotificationType.EMAIL) {\n\t\t\tURI uri = URI.create(\"mailto:\".concat(emailAddress));\n\n\t\t\tAttendee attendee = new Attendee(uri);\n\n\t\t\taction = Action.EMAIL;\n\n\t\t\tpropertyList.add(attendee);\n\t\t\tpropertyList.add(new Summary(\"Alarm Notification\"));\n\t\t}\n\n\t\tpropertyList.add(action);\n\t\tpropertyList.add(new Description(\"This is an event reminder.\"));\n\n\t\treturn vAlarm;\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String toString(net.fortuna.ical4j.model.Calendar iCalCalendar)\n\t\tthrows Exception {\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter();\n\n\t\tCalendarOutputter calOutput = new CalendarOutputter();\n\n\t\tif (iCalCalendar.getComponents().isEmpty()) {\n\t\t\tcalOutput.setValidating(false);\n\t\t}\n\n\t\tcalOutput.output(iCalCalendar, unsyncStringWriter);\n\n\t\tunsyncStringWriter.flush();\n\n\t\treturn unsyncStringWriter.toString();\n\t}","id":32667,"modified_method":"protected String toString(net.fortuna.ical4j.model.Calendar iCalCalendar)\n\t\tthrows Exception {\n\n\t\tCalendarOutputter calendarOutputter = new CalendarOutputter();\n\n\t\tComponentList componentList = iCalCalendar.getComponents();\n\n\t\tif (componentList.isEmpty()) {\n\t\t\tcalendarOutputter.setValidating(false);\n\t\t}\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter();\n\n\t\tcalendarOutputter.output(iCalCalendar, unsyncStringWriter);\n\n\t\tunsyncStringWriter.flush();\n\n\t\treturn unsyncStringWriter.toString();\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected VEvent toICalEvent(CalendarBooking calendarBooking)\n\t\tthrows Exception {\n\n\t\tUser owner = UserLocalServiceUtil.getUser(calendarBooking.getUserId());\n\n\t\tLocale locale = owner.getLocale();\n\n\t\tVEvent vEvent = new VEvent();\n\n\t\tPropertyList eventProps = vEvent.getProperties();\n\n\t\t// UID\n\n\t\tUid uid = new Uid(calendarBooking.getUuid());\n\n\t\teventProps.add(uid);\n\n\t\t// Dates\n\n\t\tif (calendarBooking.isAllDay()) {\n\t\t\tDtStart dtStart = new DtStart(\n\t\t\t\tnew Date(calendarBooking.getStartDate()));\n\n\t\t\teventProps.add(dtStart);\n\t\t}\n\t\telse {\n\t\t\tDtStart dtStart = new DtStart(\n\t\t\t\ttoICalDateTime(calendarBooking.getStartDate()));\n\n\t\t\teventProps.add(dtStart);\n\n\t\t\tDtEnd dtEnd = new DtEnd(\n\t\t\t\ttoICalDateTime(calendarBooking.getEndDate()));\n\n\t\t\teventProps.add(dtEnd);\n\t\t}\n\n\t\t// Title\n\n\t\tSummary summary = new Summary(calendarBooking.getTitle(locale));\n\n\t\teventProps.add(summary);\n\n\t\t// Description\n\n\t\tDescription description = new Description(\n\t\t\tcalendarBooking.getDescription(locale));\n\n\t\teventProps.add(description);\n\n\t\t// Location\n\n\t\tLocation location = new Location(calendarBooking.getLocation());\n\n\t\teventProps.add(location);\n\n\t\t// Recurrence\n\n\t\tif (calendarBooking.isRecurring()) {\n\t\t\tString value = StringUtil.replace(\n\t\t\t\tcalendarBooking.getRecurrence(), _rRulePart, StringPool.BLANK);\n\n\t\t\tRRule rRule = new RRule(value);\n\n\t\t\teventProps.add(rRule);\n\t\t}\n\n\t\t// Reminders\n\n\t\tComponentList alarms = vEvent.getAlarms();\n\n\t\tlong firstReminder = calendarBooking.getFirstReminder();\n\n\t\tif (firstReminder > 0) {\n\t\t\tVAlarm alarm = toICalAlarm(\n\t\t\t\tcalendarBooking.getFirstReminderNotificationType(),\n\t\t\t\tfirstReminder, owner.getEmailAddress());\n\n\t\t\talarms.add(alarm);\n\t\t}\n\n\t\tlong secondReminder = calendarBooking.getSecondReminder();\n\n\t\tif (secondReminder > 0) {\n\t\t\tVAlarm alarm = toICalAlarm(\n\t\t\t\tcalendarBooking.getSecondReminderNotificationType(),\n\t\t\t\tsecondReminder, owner.getEmailAddress());\n\n\t\t\talarms.add(alarm);\n\t\t}\n\n\t\t// Attendees\n\n\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\tcalendarBooking.getChildCalendarBookings();\n\n\t\tlong userClassNameId = PortalUtil.getClassNameId(User.class);\n\n\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\tCalendarResource calResource =\n\t\t\t\tchildCalendarBooking.getCalendarResource();\n\n\t\t\tlong classNameId = calResource.getClassNameId();\n\t\t\tlong classPK = calResource.getClassPK();\n\n\t\t\tif ((classNameId != userClassNameId) ||\n\t\t\t\t(calendarBooking.getCalendarBookingId() ==\n\t\t\t\t\tchildCalendarBooking.getCalendarBookingId())) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUser user = UserLocalServiceUtil.getUser(classPK);\n\n\t\t\tAttendee attendee = toICalAttendee(\n\t\t\t\tuser.getFullName(), user.getEmailAddress(),\n\t\t\t\tchildCalendarBooking.getStatus());\n\n\t\t\teventProps.add(attendee);\n\t\t}\n\n\t\treturn vEvent;\n\t}","id":32668,"modified_method":"protected VEvent toICalEvent(CalendarBooking calendarBooking)\n\t\tthrows Exception {\n\n\t\tVEvent vEvent = new VEvent();\n\n\t\tPropertyList propertyList = vEvent.getProperties();\n\n\t\t// UID\n\n\t\tUid uid = new Uid(calendarBooking.getUuid());\n\n\t\tpropertyList.add(uid);\n\n\t\t// Dates\n\n\t\tif (calendarBooking.isAllDay()) {\n\t\t\tDtStart dtStart = new DtStart(\n\t\t\t\tnew Date(calendarBooking.getStartDate()));\n\n\t\t\tpropertyList.add(dtStart);\n\t\t}\n\t\telse {\n\t\t\tDtStart dtStart = new DtStart(\n\t\t\t\ttoICalDateTime(calendarBooking.getStartDate()));\n\n\t\t\tpropertyList.add(dtStart);\n\n\t\t\tDtEnd dtEnd = new DtEnd(\n\t\t\t\ttoICalDateTime(calendarBooking.getEndDate()));\n\n\t\t\tpropertyList.add(dtEnd);\n\t\t}\n\n\t\t// Title\n\n\t\tUser user = UserLocalServiceUtil.getUser(calendarBooking.getUserId());\n\n\t\tSummary summary = new Summary(\n\t\t\tcalendarBooking.getTitle(user.getLocale()));\n\n\t\tpropertyList.add(summary);\n\n\t\t// Description\n\n\t\tDescription description = new Description(\n\t\t\tcalendarBooking.getDescription(user.getLocale()));\n\n\t\tpropertyList.add(description);\n\n\t\t// Location\n\n\t\tLocation location = new Location(calendarBooking.getLocation());\n\n\t\tpropertyList.add(location);\n\n\t\t// Recurrence\n\n\t\tif (calendarBooking.isRecurring()) {\n\t\t\tString value = StringUtil.replace(\n\t\t\t\tcalendarBooking.getRecurrence(), _RRULE, StringPool.BLANK);\n\n\t\t\tRRule rRule = new RRule(value);\n\n\t\t\tpropertyList.add(rRule);\n\t\t}\n\n\t\t// Reminders\n\n\t\tComponentList componentList = vEvent.getAlarms();\n\n\t\tlong firstReminder = calendarBooking.getFirstReminder();\n\n\t\tif (firstReminder > 0) {\n\t\t\tVAlarm vAlarm = toICalAlarm(\n\t\t\t\tcalendarBooking.getFirstReminderNotificationType(),\n\t\t\t\tfirstReminder, user.getEmailAddress());\n\n\t\t\tcomponentList.add(vAlarm);\n\t\t}\n\n\t\tlong secondReminder = calendarBooking.getSecondReminder();\n\n\t\tif (secondReminder > 0) {\n\t\t\tVAlarm alarm = toICalAlarm(\n\t\t\t\tcalendarBooking.getSecondReminderNotificationType(),\n\t\t\t\tsecondReminder, user.getEmailAddress());\n\n\t\t\tcomponentList.add(alarm);\n\t\t}\n\n\t\t// Attendees\n\n\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\tcalendarBooking.getChildCalendarBookings();\n\n\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\tCalendarResource calResource =\n\t\t\t\tchildCalendarBooking.getCalendarResource();\n\n\t\t\tif (!calResource.isUser() ||\n\t\t\t\t(calendarBooking.getCalendarBookingId() ==\n\t\t\t\t\tchildCalendarBooking.getCalendarBookingId())) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUser calResourceUser = UserLocalServiceUtil.getUser(\n\t\t\t\tcalResource.getClassPK());\n\n\t\t\tAttendee attendee = toICalAttendee(\n\t\t\t\tcalResourceUser.getFullName(),\n\t\t\t\tcalResourceUser.getEmailAddress(),\n\t\t\t\tchildCalendarBooking.getStatus());\n\n\t\t\tpropertyList.add(attendee);\n\t\t}\n\n\t\treturn vEvent;\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void serveImportCalendar(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletConfig portletConfig =\n\t\t\t(PortletConfig)resourceRequest.getAttribute(\n\t\t\t\tJavaConstants.JAVAX_PORTLET_CONFIG);\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(resourceRequest);\n\n\t\tlong calendarId = ParamUtil.getLong(resourceRequest, \"calendarId\");\n\n\t\tFile file = uploadPortletRequest.getFile(\"file\");\n\n\t\tString data = FileUtil.read(file);\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tif (Validator.isNotNull(data)) {\n\t\t\tCalendarDataHandler calendarDataHandler =\n\t\t\t\tCalendarDataHandlerFactory.getCalendarDataHandler(\n\t\t\t\t\tCalendarDataFormat.ICAL);\n\n\t\t\tcalendarDataHandler.importCalendar(calendarId, data);\n\t\t}\n\t\telse {\n\t\t\tjsonObject.put(\n\t\t\t\t\"error\",\n\t\t\t\tLanguageUtil.get(\n\t\t\t\t\tportletConfig, themeDisplay.getLocale(),\n\t\t\t\t\t\"failed-to-import-events-empty-uploaded-file\"));\n\t\t}\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonObject);\n\t}","id":32669,"modified_method":"protected void serveImportCalendar(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(resourceRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong calendarId = ParamUtil.getLong(resourceRequest, \"calendarId\");\n\n\t\tFile file = uploadPortletRequest.getFile(\"file\");\n\n\t\tString data = FileUtil.read(file);\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tif (Validator.isNotNull(data)) {\n\t\t\tCalendarDataHandler calendarDataHandler =\n\t\t\t\tCalendarDataHandlerFactory.getCalendarDataHandler(\n\t\t\t\t\tCalendarDataFormat.ICAL);\n\n\t\t\tcalendarDataHandler.importCalendar(calendarId, data);\n\t\t}\n\t\telse {\n\t\t\tjsonObject.put(\n\t\t\t\t\"error\", themeDisplay.translate(\"failed-to-import-empty-file\"));\n\t\t}\n\n\t\twriteJSON(resourceRequest, resourceResponse, jsonObject);\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void serveExportCalendar(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\tresourceRequest);\n\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\tresourceResponse);\n\n\t\tlong calendarId = ParamUtil.getLong(resourceRequest, \"calendarId\");\n\n\t\tCalendar calendar = CalendarLocalServiceUtil.getCalendar(calendarId);\n\n\t\tString fileName =\n\t\t\tcalendar.getName(themeDisplay.getLocale()) + CharPool.PERIOD +\n\t\t\t\tString.valueOf(CalendarDataFormat.ICAL);\n\n\t\tCalendarDataHandler calendarDataHandler =\n\t\t\tCalendarDataHandlerFactory.getCalendarDataHandler(\n\t\t\t\tCalendarDataFormat.ICAL);\n\n\t\tString data = calendarDataHandler.exportCalendar(calendarId);\n\n\t\tString contentType = MimeTypesUtil.getContentType(fileName);\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, data.getBytes(), contentType);\n\t}","id":32670,"modified_method":"protected void serveExportCalendar(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong calendarId = ParamUtil.getLong(resourceRequest, \"calendarId\");\n\n\t\tCalendar calendar = CalendarLocalServiceUtil.getCalendar(calendarId);\n\n\t\tString fileName =\n\t\t\tcalendar.getName(themeDisplay.getLocale()) + CharPool.PERIOD +\n\t\t\t\tString.valueOf(CalendarDataFormat.ICAL);\n\n\t\tCalendarDataHandler calendarDataHandler =\n\t\t\tCalendarDataHandlerFactory.getCalendarDataHandler(\n\t\t\t\tCalendarDataFormat.ICAL);\n\n\t\tString data = calendarDataHandler.exportCalendar(calendarId);\n\n\t\tString contentType = MimeTypesUtil.getContentType(fileName);\n\n\t\tPortletResponseUtil.sendFile(\n\t\t\tresourceRequest, resourceResponse, fileName, data.getBytes(),\n\t\t\tcontentType);\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void updateUserSettings(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tPortalPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(actionRequest);\n\n\t\tString portletId = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\t\tString defaultView = ParamUtil.getString(actionRequest, \"defaultView\");\n\t\tString timeZoneId = ParamUtil.getString(actionRequest, \"timeZoneId\");\n\t\tint defaultDuration = ParamUtil.getInteger(\n\t\t\tactionRequest, \"defaultDuration\");\n\t\tint weekStartsOn = ParamUtil.getInteger(actionRequest, \"weekStartsOn\");\n\t\tboolean isoTimeFormat = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"isoTimeFormat\");\n\t\tboolean usePortalTimeZone = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"usePortalTimeZone\");\n\n\t\tpreferences.setValue(portletId, \"defaultView\", defaultView);\n\t\tpreferences.setValue(portletId, \"timeZoneId\", timeZoneId);\n\t\tpreferences.setValue(\n\t\t\tportletId, \"defaultDuration\", String.valueOf(defaultDuration));\n\t\tpreferences.setValue(\n\t\t\tportletId, \"weekStartsOn\", String.valueOf(weekStartsOn));\n\t\tpreferences.setValue(\n\t\t\tportletId, \"isoTimeFormat\", String.valueOf(isoTimeFormat));\n\t\tpreferences.setValue(\n\t\t\tportletId, \"usePortalTimeZone\", String.valueOf(usePortalTimeZone));\n\t}","id":32671,"modified_method":"protected void updateUserSettings(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tPortletPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\tactionRequest, portletResource);\n\n\t\tint defaultDuration = ParamUtil.getInteger(\n\t\t\tactionRequest, \"defaultDuration\");\n\t\tString defaultView = ParamUtil.getString(actionRequest, \"defaultView\");\n\t\tboolean isoTimeFormat = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"isoTimeFormat\");\n\t\tString timeZoneId = ParamUtil.getString(actionRequest, \"timeZoneId\");\n\t\tboolean usePortalTimeZone = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"usePortalTimeZone\");\n\t\tint weekStartsOn = ParamUtil.getInteger(actionRequest, \"weekStartsOn\");\n\n\t\tpreferences.setValue(\n\t\t\t\"defaultDuration\", String.valueOf(defaultDuration));\n\t\tpreferences.setValue(\"defaultView\", defaultView);\n\t\tpreferences.setValue(\"isoTimeFormat\", String.valueOf(isoTimeFormat));\n\t\tpreferences.setValue(\"timeZoneId\", timeZoneId);\n\t\tpreferences.setValue(\n\t\t\t\"usePortalTimeZone\", String.valueOf(usePortalTimeZone));\n\t\tpreferences.setValue(\"weekStartsOn\", String.valueOf(weekStartsOn));\n\n\t\tpreferences.store();\n\t}","commit_id":"ae2327a6f174f6d5e283438b25d13e15ece3f8d2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected User updateUser(\n\t\t\tlong companyId, LDAPUser ldapUser, User user, String password,\n\t\t\tString modifiedDate)\n\t\tthrows Exception {\n\n\t\tDate ldapUserModifiedDate = null;\n\n\t\tboolean passwordReset = ldapUser.isPasswordReset();\n\n\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\tcompanyId, PropsKeys.LDAP_EXPORT_ENABLED,\n\t\t\tPropsValues.LDAP_EXPORT_ENABLED)) {\n\n\t\t\tpasswordReset = user.isPasswordReset();\n\t\t}\n\n\t\ttry {\n\t\t\tif (Validator.isNull(modifiedDate)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"LDAP entry never modified, skipping user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress());\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tldapUserModifiedDate = LDAPUtil.parseDate(modifiedDate);\n\t\t\t}\n\n\t\t\tif (ldapUserModifiedDate.equals(user.getModifiedDate())) {\n\t\t\t\tif (!ldapUser.isAutoPassword()) {\n\t\t\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\t\t\tuser.getUserId(), password, password, passwordReset,\n\t\t\t\t\t\ttrue);\n\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\"Password updated in DB for user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress() + \" to provided \" +\n\t\t\t\t\t\t\t\"non-blank value.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"User is already synchronized, skipping user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress());\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to parse LDAP modify timestamp \" + modifiedDate,\n\t\t\t\t\tpe);\n\t\t\t}\n\t\t}\n\n\t\tif (!PropsValues.LDAP_IMPORT_USER_PASSWORD_ENABLED) {\n\t\t\tpassword = PropsValues.LDAP_IMPORT_USER_PASSWORD_DEFAULT;\n\n\t\t\tif (password.equalsIgnoreCase(_USER_PASSWORD_SCREEN_NAME)) {\n\t\t\t\tpassword = ldapUser.getScreenName();\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(ldapUser.getScreenName())) {\n\t\t\tldapUser.setAutoScreenName(true);\n\t\t}\n\n\t\tif (ldapUser.isAutoScreenName()) {\n\t\t\tScreenNameGenerator screenNameGenerator =\n\t\t\t\tScreenNameGeneratorFactory.getInstance();\n\n\t\t\tldapUser.setScreenName(\n\t\t\t\tscreenNameGenerator.generate(\n\t\t\t\t\tcompanyId, user.getUserId(), ldapUser.getEmailAddress()));\n\t\t}\n\n\t\tCalendar birthdayCal = CalendarFactoryUtil.getCalendar();\n\n\t\tbirthdayCal.setTime(user.getContact().getBirthday());\n\n\t\tint birthdayMonth = birthdayCal.get(Calendar.MONTH);\n\t\tint birthdayDay = birthdayCal.get(Calendar.DAY_OF_MONTH);\n\t\tint birthdayYear = birthdayCal.get(Calendar.YEAR);\n\n\t\tif (ldapUser.isUpdatePassword()) {\n\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\tuser.getUserId(), password, password, passwordReset, true);\n\t\t}\n\n\t\tContact contact = user.getContact();\n\n\t\tSet<String> ldapIgnoreAttributes = SetUtil.fromArray(\n\t\t\tPropsValues.LDAP_USER_IGNORE_ATTRIBUTES);\n\n\t\tfor (String attribute : ldapIgnoreAttributes) {\n\t\t\tObject value = BeanPropertiesUtil.getObjectSilent(user, attribute);\n\n\t\t\tif (value == null) {\n\t\t\t\tvalue = BeanPropertiesUtil.getObjectSilent(contact, attribute);\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tBeanPropertiesUtil.setProperty(ldapUser, attribute, value);\n\t\t\t}\n\t\t}\n\n\t\tupdateLDAPUser(ldapUser.getUser(), ldapUser.getContact(), user);\n\n\t\tuser = UserLocalServiceUtil.updateUser(\n\t\t\tuser.getUserId(), password, StringPool.BLANK, StringPool.BLANK,\n\t\t\tpasswordReset, ldapUser.getReminderQueryQuestion(),\n\t\t\tldapUser.getReminderQueryAnswer(), ldapUser.getScreenName(),\n\t\t\tldapUser.getEmailAddress(), ldapUser.getFacebookId(),\n\t\t\tldapUser.getOpenId(), ldapUser.getLanguageId(),\n\t\t\tldapUser.getTimeZoneId(), ldapUser.getGreeting(),\n\t\t\tldapUser.getComments(), ldapUser.getFirstName(),\n\t\t\tldapUser.getMiddleName(), ldapUser.getLastName(),\n\t\t\tldapUser.getPrefixId(), ldapUser.getSuffixId(), ldapUser.isMale(),\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, ldapUser.getSmsSn(),\n\t\t\tldapUser.getAimSn(), ldapUser.getFacebookSn(), ldapUser.getIcqSn(),\n\t\t\tldapUser.getJabberSn(), ldapUser.getMsnSn(),\n\t\t\tldapUser.getMySpaceSn(), ldapUser.getSkypeSn(),\n\t\t\tldapUser.getTwitterSn(), ldapUser.getYmSn(), ldapUser.getJobTitle(),\n\t\t\tldapUser.getGroupIds(), ldapUser.getOrganizationIds(),\n\t\t\tldapUser.getRoleIds(), ldapUser.getUserGroupRoles(),\n\t\t\tldapUser.getUserGroupIds(), ldapUser.getServiceContext());\n\n\t\tif (ldapUserModifiedDate != null) {\n\t\t\tuser = UserLocalServiceUtil.updateModifiedDate(\n\t\t\t\tuser.getUserId(), ldapUserModifiedDate);\n\t\t}\n\n\t\tif (ldapUser.isUpdatePortrait()) {\n\t\t\tbyte[] portraitBytes = ldapUser.getPortraitBytes();\n\n\t\t\tif ((portraitBytes != null) && (portraitBytes.length > 0)) {\n\t\t\t\tUserLocalServiceUtil.updatePortrait(\n\t\t\t\t\tuser.getUserId(), portraitBytes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUserLocalServiceUtil.deletePortrait(user.getUserId());\n\t\t\t}\n\t\t}\n\n\t\tuser = UserLocalServiceUtil.updateStatus(\n\t\t\tuser.getUserId(), ldapUser.getStatus());\n\n\t\treturn user;\n\t}","id":32672,"modified_method":"protected User updateUser(\n\t\t\tlong companyId, LDAPUser ldapUser, User user, String password,\n\t\t\tString modifiedDate)\n\t\tthrows Exception {\n\n\t\tDate ldapUserModifiedDate = null;\n\n\t\tboolean passwordReset = ldapUser.isPasswordReset();\n\n\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.LDAP_EXPORT_ENABLED,\n\t\t\t\tPropsValues.LDAP_EXPORT_ENABLED)) {\n\n\t\t\tpasswordReset = user.isPasswordReset();\n\t\t}\n\n\t\ttry {\n\t\t\tif (Validator.isNull(modifiedDate)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"LDAP entry never modified, skipping user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress());\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\n\t\t\tldapUserModifiedDate = LDAPUtil.parseDate(modifiedDate);\n\n\t\t\tif (ldapUserModifiedDate.equals(user.getModifiedDate())) {\n\t\t\t\tif (ldapUser.isAutoPassword()) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"User \" + user.getEmailAddress() +\n\t\t\t\t\t\t\t\t\" is already synchronized, skipping\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn user;\n\t\t\t\t}\n\n\t\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\t\tuser.getUserId(), password, password, passwordReset,\n\t\t\t\t\ttrue);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"User \" + user.getEmailAddress() +\n\t\t\t\t\t\t\t\" is already synchronized, but updated password \" +\n\t\t\t\t\t\t\t\t\"to avoid a blank value\");\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to parse LDAP modify timestamp \" + modifiedDate,\n\t\t\t\t\tpe);\n\t\t\t}\n\t\t}\n\n\t\tif (!PropsValues.LDAP_IMPORT_USER_PASSWORD_ENABLED) {\n\t\t\tpassword = PropsValues.LDAP_IMPORT_USER_PASSWORD_DEFAULT;\n\n\t\t\tif (password.equalsIgnoreCase(_USER_PASSWORD_SCREEN_NAME)) {\n\t\t\t\tpassword = ldapUser.getScreenName();\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(ldapUser.getScreenName())) {\n\t\t\tldapUser.setAutoScreenName(true);\n\t\t}\n\n\t\tif (ldapUser.isAutoScreenName()) {\n\t\t\tScreenNameGenerator screenNameGenerator =\n\t\t\t\tScreenNameGeneratorFactory.getInstance();\n\n\t\t\tldapUser.setScreenName(\n\t\t\t\tscreenNameGenerator.generate(\n\t\t\t\t\tcompanyId, user.getUserId(), ldapUser.getEmailAddress()));\n\t\t}\n\n\t\tCalendar birthdayCal = CalendarFactoryUtil.getCalendar();\n\n\t\tbirthdayCal.setTime(user.getContact().getBirthday());\n\n\t\tint birthdayMonth = birthdayCal.get(Calendar.MONTH);\n\t\tint birthdayDay = birthdayCal.get(Calendar.DAY_OF_MONTH);\n\t\tint birthdayYear = birthdayCal.get(Calendar.YEAR);\n\n\t\tif (ldapUser.isUpdatePassword()) {\n\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\tuser.getUserId(), password, password, passwordReset, true);\n\t\t}\n\n\t\tContact contact = user.getContact();\n\n\t\tSet<String> ldapIgnoreAttributes = SetUtil.fromArray(\n\t\t\tPropsValues.LDAP_USER_IGNORE_ATTRIBUTES);\n\n\t\tfor (String attribute : ldapIgnoreAttributes) {\n\t\t\tObject value = BeanPropertiesUtil.getObjectSilent(user, attribute);\n\n\t\t\tif (value == null) {\n\t\t\t\tvalue = BeanPropertiesUtil.getObjectSilent(contact, attribute);\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tBeanPropertiesUtil.setProperty(ldapUser, attribute, value);\n\t\t\t}\n\t\t}\n\n\t\tupdateLDAPUser(ldapUser.getUser(), ldapUser.getContact(), user);\n\n\t\tuser = UserLocalServiceUtil.updateUser(\n\t\t\tuser.getUserId(), password, StringPool.BLANK, StringPool.BLANK,\n\t\t\tpasswordReset, ldapUser.getReminderQueryQuestion(),\n\t\t\tldapUser.getReminderQueryAnswer(), ldapUser.getScreenName(),\n\t\t\tldapUser.getEmailAddress(), ldapUser.getFacebookId(),\n\t\t\tldapUser.getOpenId(), ldapUser.getLanguageId(),\n\t\t\tldapUser.getTimeZoneId(), ldapUser.getGreeting(),\n\t\t\tldapUser.getComments(), ldapUser.getFirstName(),\n\t\t\tldapUser.getMiddleName(), ldapUser.getLastName(),\n\t\t\tldapUser.getPrefixId(), ldapUser.getSuffixId(), ldapUser.isMale(),\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, ldapUser.getSmsSn(),\n\t\t\tldapUser.getAimSn(), ldapUser.getFacebookSn(), ldapUser.getIcqSn(),\n\t\t\tldapUser.getJabberSn(), ldapUser.getMsnSn(),\n\t\t\tldapUser.getMySpaceSn(), ldapUser.getSkypeSn(),\n\t\t\tldapUser.getTwitterSn(), ldapUser.getYmSn(), ldapUser.getJobTitle(),\n\t\t\tldapUser.getGroupIds(), ldapUser.getOrganizationIds(),\n\t\t\tldapUser.getRoleIds(), ldapUser.getUserGroupRoles(),\n\t\t\tldapUser.getUserGroupIds(), ldapUser.getServiceContext());\n\n\t\tif (ldapUserModifiedDate != null) {\n\t\t\tuser = UserLocalServiceUtil.updateModifiedDate(\n\t\t\t\tuser.getUserId(), ldapUserModifiedDate);\n\t\t}\n\n\t\tif (ldapUser.isUpdatePortrait()) {\n\t\t\tbyte[] portraitBytes = ldapUser.getPortraitBytes();\n\n\t\t\tif ((portraitBytes != null) && (portraitBytes.length > 0)) {\n\t\t\t\tUserLocalServiceUtil.updatePortrait(\n\t\t\t\t\tuser.getUserId(), portraitBytes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUserLocalServiceUtil.deletePortrait(user.getUserId());\n\t\t\t}\n\t\t}\n\n\t\tuser = UserLocalServiceUtil.updateStatus(\n\t\t\tuser.getUserId(), ldapUser.getStatus());\n\n\t\treturn user;\n\t}","commit_id":"963e999aa423ad13b35c930bdf012e43940bf0b4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doReceive(Message message) throws Exception {\n\t\tlong companyId = message.getLong(\"companyId\");\n\t\tlong userId = message.getLong(\"userId\");\n\t\tlong groupId = message.getLong(\"groupId\");\n\t\tlong entryId = message.getLong(\"entryId\");\n\t\tString fromName = message.getString(\"fromName\");\n\t\tString fromAddress = message.getString(\"fromAddress\");\n\t\tString subject = message.getString(\"subject\");\n\t\tString body = message.getString(\"body\");\n\t\tString replyToAddress = message.getString(\"replyToAddress\");\n\t\tString mailId = message.getString(\"mailId\");\n\t\tboolean htmlFormat = message.getBoolean(\"htmlFormat\");\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Sending notifications for {mailId=\" + mailId + \", entryId=\" +\n\t\t\t\t\tentryId + \"}\");\n\t\t}\n\n\t\t// Entries\n\n\t\tList<Subscription> subscriptions =\n\t\t\tSubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\t\tcompanyId, BlogsEntry.class.getName(), groupId);\n\n\t\tsendEmail(\n\t\t\tuserId, groupId, fromName, fromAddress, subject, body,\n\t\t\tsubscriptions, sent, replyToAddress, mailId, htmlFormat);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Finished sending notifications\");\n\t\t}\n\t}","id":32673,"modified_method":"protected void doReceive(Message message) throws Exception {\n\t\tlong companyId = message.getLong(\"companyId\");\n\t\tlong userId = message.getLong(\"userId\");\n\t\tlong groupId = message.getLong(\"groupId\");\n\t\tlong entryId = message.getLong(\"entryId\");\n\t\tString fromName = message.getString(\"fromName\");\n\t\tString fromAddress = message.getString(\"fromAddress\");\n\t\tString subject = message.getString(\"subject\");\n\t\tString body = message.getString(\"body\");\n\t\tString replyToAddress = message.getString(\"replyToAddress\");\n\t\tString mailId = message.getString(\"mailId\");\n\t\tboolean htmlFormat = message.getBoolean(\"htmlFormat\");\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Sending notifications for {mailId=\" + mailId + \", entryId=\" +\n\t\t\t\t\tentryId + \"}\");\n\t\t}\n\n\t\tSubscriptionSender subscriptionSender = new SubscriptionSender();\n\n\t\tsubscriptionSender.setCompanyId(companyId);\n\t\tsubscriptionSender.setUserId(userId);\n\t\tsubscriptionSender.setGroupId(groupId);\n\t\tsubscriptionSender.setFrom(fromName, fromAddress);\n\t\tsubscriptionSender.setSubject(subject);\n\t\tsubscriptionSender.setBody(body);\n\t\tsubscriptionSender.setReplyToAddress(replyToAddress);\n\t\tsubscriptionSender.setMailId(mailId);\n\t\tsubscriptionSender.setHtmlFormat(htmlFormat);\n\n\t\tsubscriptionSender.notifyPersistedSubscribers(\n\t\t\tBlogsEntry.class.getName(), groupId);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Finished sending notifications\");\n\t\t}\n\t}","commit_id":"aa3f5876639b4974f631312f63768c8ba9fce91d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doReceive(Message message) throws Exception {\n\t\tlong companyId = message.getLong(\"companyId\");\n\t\tlong userId = message.getLong(\"userId\");\n\t\tlong groupId = message.getLong(\"groupId\");\n\t\tString articleId = message.getString(\"articleId\");\n\t\tString fromName = message.getString(\"fromName\");\n\t\tString fromAddress = message.getString(\"fromAddress\");\n\t\tString subject = message.getString(\"subject\");\n\t\tString body = message.getString(\"body\");\n\t\tString replyToAddress = message.getString(\"replyToAddress\");\n\t\tString mailId = message.getString(\"mailId\");\n\t\tboolean htmlFormat = message.getBoolean(\"htmlFormat\");\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Sending notifications for {mailId=\" + mailId + \", articleId=\" +\n\t\t\t\t\tarticleId + \"}\");\n\t\t}\n\n\t\t// Articles\n\n\t\tList<Subscription> subscriptions =\n\t\t\tSubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\t\tcompanyId, JournalArticle.class.getName(), groupId);\n\n\t\tsendEmail(\n\t\t\tuserId, groupId, fromName, fromAddress, subject, body,\n\t\t\tsubscriptions, sent, replyToAddress, mailId, htmlFormat);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Finished sending notifications\");\n\t\t}\n\t}","id":32674,"modified_method":"protected void doReceive(Message message) throws Exception {\n\t\tlong companyId = message.getLong(\"companyId\");\n\t\tlong userId = message.getLong(\"userId\");\n\t\tlong groupId = message.getLong(\"groupId\");\n\t\tString articleId = message.getString(\"articleId\");\n\t\tString fromName = message.getString(\"fromName\");\n\t\tString fromAddress = message.getString(\"fromAddress\");\n\t\tString subject = message.getString(\"subject\");\n\t\tString body = message.getString(\"body\");\n\t\tString replyToAddress = message.getString(\"replyToAddress\");\n\t\tString mailId = message.getString(\"mailId\");\n\t\tboolean htmlFormat = message.getBoolean(\"htmlFormat\");\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Sending notifications for {mailId=\" + mailId + \", articleId=\" +\n\t\t\t\t\tarticleId + \"}\");\n\t\t}\n\n\t\tSubscriptionSender subscriptionSender = new SubscriptionSender();\n\n\t\tsubscriptionSender.setCompanyId(companyId);\n\t\tsubscriptionSender.setUserId(userId);\n\t\tsubscriptionSender.setGroupId(groupId);\n\t\tsubscriptionSender.setFrom(fromName, fromAddress);\n\t\tsubscriptionSender.setSubject(subject);\n\t\tsubscriptionSender.setBody(body);\n\t\tsubscriptionSender.setReplyToAddress(replyToAddress);\n\t\tsubscriptionSender.setMailId(mailId);\n\t\tsubscriptionSender.setHtmlFormat(htmlFormat);\n\n\t\tsubscriptionSender.notifyPersistedSubscribers(\n\t\t\tJournalArticle.class.getName(), groupId);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Finished sending notifications\");\n\t\t}\n\t}","commit_id":"aa3f5876639b4974f631312f63768c8ba9fce91d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void notifyMailingList(\n\t\t\tString subject, String body, String replyToAddress, String mailId,\n\t\t\tString inReplyTo, boolean htmlFormat, long groupId, long categoryId)\n\t\tthrows Exception {\n\n\t\tMBMailingList mailingList =\n\t\t\tMBMailingListLocalServiceUtil.getCategoryMailingList(\n\t\t\t\tgroupId, categoryId);\n\n\t\tif (!mailingList.isActive()) {\n\t\t\treturn;\n\t\t}\n\n\t\tsubject = getMailingListSubject(subject, mailId);\n\n\t\tString fromAddress = mailingList.getOutEmailAddress();\n\n\t\tInternetAddress[] bulkAddresses = new InternetAddress[] {\n\t\t\tnew InternetAddress(mailingList.getEmailAddress())\n\t\t};\n\n\t\tSMTPAccount account = null;\n\n\t\tif (mailingList.isOutCustom()) {\n\t\t\tString protocol = Account.PROTOCOL_SMTP;\n\n\t\t\tif (mailingList.isOutUseSSL()) {\n\t\t\t\tprotocol = Account.PROTOCOL_SMTPS;\n\t\t\t}\n\n\t\t\taccount = (SMTPAccount)Account.getInstance(\n\t\t\t\tprotocol, mailingList.getOutServerPort());\n\n\t\t\taccount.setHost(mailingList.getOutServerName());\n\t\t\taccount.setUser(mailingList.getOutUserName());\n\t\t\taccount.setPassword(mailingList.getOutPassword());\n\t\t}\n\n\t\tsendMail(\n\t\t\tfromAddress, null, bulkAddresses, subject, body, replyToAddress,\n\t\t\tmailId, inReplyTo, htmlFormat, account);\n\t}","id":32675,"modified_method":"protected void notifyMailingList(\n\t\t\tlong groupId, long categoryId,\n\t\t\tSubscriptionSender subscriptionSender, String subject)\n\t\tthrows Exception {\n\n\t\tMBMailingList mailingList = null;\n\n\t\ttry {\n\t\t\tmailingList = MBMailingListLocalServiceUtil.getCategoryMailingList(\n\t\t\t\tgroupId, categoryId);\n\t\t}\n\t\tcatch (NoSuchMailingListException nsmle) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!mailingList.isActive()) {\n\t\t\treturn;\n\t\t}\n\n\t\tsubscriptionSender.setFrom(mailingList.getOutEmailAddress(), null);\n\n\t\tif (mailingList.isOutCustom()) {\n\t\t\tString protocol = Account.PROTOCOL_SMTP;\n\n\t\t\tif (mailingList.isOutUseSSL()) {\n\t\t\t\tprotocol = Account.PROTOCOL_SMTPS;\n\t\t\t}\n\n\t\t\tSMTPAccount smtpAccount = (SMTPAccount)Account.getInstance(\n\t\t\t\tprotocol, mailingList.getOutServerPort());\n\n\t\t\tsmtpAccount.setHost(mailingList.getOutServerName());\n\t\t\tsmtpAccount.setUser(mailingList.getOutUserName());\n\t\t\tsmtpAccount.setPassword(mailingList.getOutPassword());\n\n\t\t\tsubscriptionSender.setSMTPAccount(smtpAccount);\n\t\t}\n\n\t\tsubscriptionSender.setSubject(subject);\n\n\t\tsubscriptionSender.notifyRuntimeSubscribers(\n\t\t\tmailingList.getEmailAddress(), mailingList.getEmailAddress());\n\t}","commit_id":"aa3f5876639b4974f631312f63768c8ba9fce91d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getMailingListSubject(String subject, String mailId) {\n\t\treturn subject + StringPool.SPACE + mailId;\n\t}","id":32676,"modified_method":"protected String getMailingListSubject(String subject, String mailId) {\n\t\treturn subject.concat(StringPool.SPACE).concat(mailId);\n\t}","commit_id":"aa3f5876639b4974f631312f63768c8ba9fce91d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doReceive(Message message) throws Exception {\n\t\tlong companyId = message.getLong(\"companyId\");\n\t\tlong userId = message.getLong(\"userId\");\n\t\tlong groupId = message.getLong(\"groupId\");\n\t\tlong nodeId = message.getLong(\"nodeId\");\n\t\tlong pageResourcePrimKey = message.getLong(\"pageResourcePrimKey\");\n\t\tString fromName = message.getString(\"fromName\");\n\t\tString fromAddress = message.getString(\"fromAddress\");\n\t\tString subject = message.getString(\"subject\");\n\t\tString body = message.getString(\"body\");\n\t\tString replyToAddress = message.getString(\"replyToAddress\");\n\t\tString mailId = message.getString(\"mailId\");\n\t\tboolean htmlFormat = message.getBoolean(\"htmlFormat\");\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Sending notifications for {mailId=\" + mailId +\n\t\t\t\t\t\", pageResourcePrimKey=\" + pageResourcePrimKey +\n\t\t\t\t\t\t\", nodeId=\" + nodeId + \"}\");\n\t\t}\n\n\t\t// Pages\n\n\t\tList<Subscription> subscriptions =\n\t\t\tSubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\t\tcompanyId, WikiPage.class.getName(), pageResourcePrimKey);\n\n\t\tsendEmail(\n\t\t\tuserId, groupId, fromName, fromAddress, subject, body,\n\t\t\tsubscriptions, sent, replyToAddress, mailId, htmlFormat);\n\n\t\t// Nodes\n\n\t\tsubscriptions = SubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\tcompanyId, WikiNode.class.getName(), nodeId);\n\n\t\tsendEmail(\n\t\t\tuserId, groupId, fromName, fromAddress, subject, body,\n\t\t\tsubscriptions, sent, replyToAddress, mailId, htmlFormat);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Finished sending notifications\");\n\t\t}\n\t}","id":32677,"modified_method":"protected void doReceive(Message message) throws Exception {\n\t\tlong companyId = message.getLong(\"companyId\");\n\t\tlong userId = message.getLong(\"userId\");\n\t\tlong groupId = message.getLong(\"groupId\");\n\t\tlong nodeId = message.getLong(\"nodeId\");\n\t\tlong pageResourcePrimKey = message.getLong(\"pageResourcePrimKey\");\n\t\tString fromName = message.getString(\"fromName\");\n\t\tString fromAddress = message.getString(\"fromAddress\");\n\t\tString subject = message.getString(\"subject\");\n\t\tString body = message.getString(\"body\");\n\t\tString replyToAddress = message.getString(\"replyToAddress\");\n\t\tString mailId = message.getString(\"mailId\");\n\t\tboolean htmlFormat = message.getBoolean(\"htmlFormat\");\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Sending notifications for {mailId=\" + mailId +\n\t\t\t\t\t\", pageResourcePrimKey=\" + pageResourcePrimKey +\n\t\t\t\t\t\t\", nodeId=\" + nodeId + \"}\");\n\t\t}\n\n\t\tSubscriptionSender subscriptionSender = new SubscriptionSender();\n\n\t\tsubscriptionSender.setCompanyId(companyId);\n\t\tsubscriptionSender.setUserId(userId);\n\t\tsubscriptionSender.setGroupId(groupId);\n\t\tsubscriptionSender.setFrom(fromName, fromAddress);\n\t\tsubscriptionSender.setSubject(subject);\n\t\tsubscriptionSender.setBody(body);\n\t\tsubscriptionSender.setReplyToAddress(replyToAddress);\n\t\tsubscriptionSender.setMailId(mailId);\n\t\tsubscriptionSender.setHtmlFormat(htmlFormat);\n\n\t\tsubscriptionSender.notifyPersistedSubscribers(\n\t\t\tWikiNode.class.getName(), nodeId);\n\t\tsubscriptionSender.notifyPersistedSubscribers(\n\t\t\tWikiPage.class.getName(), pageResourcePrimKey);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Finished sending notifications\");\n\t\t}\n\t}","commit_id":"aa3f5876639b4974f631312f63768c8ba9fce91d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void messageReceived(SessionEvent ev)\n        {\n            handleNewMessage(ev);\n        }","id":32678,"modified_method":"/**\n         * Overrides <tt>messageReceived<\/tt> from <tt>SessionAdapter<\/tt>,\n         * called when we receive a new intant message.\n         *\n         * @param ev Event with information on the received message\n         */\n        public void messageReceived(SessionEvent ev)\n        {\n            handleNewMessage(ev);\n        }","commit_id":"546b0ba82762d3c3bd637fd00eaff8a479c7c663","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void offlineMessageReceived(SessionEvent ev)\n        {\n            handleNewMessage(ev);\n        }","id":32679,"modified_method":"/**\n         * Overrides <tt>offlineMessageReceived<\/tt> from <tt>SessionAdapter<\/tt>,\n         * called when we receive a message which has been sent to us\n         * when we were offline.\n         *\n         * @param ev Event with information on the received message\n         */\n        public void offlineMessageReceived(SessionEvent ev)\n        {\n            handleNewMessage(ev);\n        }","commit_id":"546b0ba82762d3c3bd637fd00eaff8a479c7c663","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void handleNewMessage(SessionEvent ev)\n        {\n            logger.debug(\"Message received : \" + ev);\n            \n            //As no indications in the protocol is it html or not. No harm\n            //to set all messages html - doesn't affect the appearance of the gui\n            Message newMessage = createMessage(\n                new MessageDecoder().decodeToHTML(ev.getMessage()).getBytes(),\n                CONTENT_TYPE_HTML,\n                DEFAULT_MIME_ENCODING,\n                null);\n\n            Contact sourceContact = opSetPersPresence.\n                findContactByID(ev.getFrom());\n\n             if(sourceContact == null)\n            {\n                logger.debug(\"received a message from an unknown contact: \"\n                                   + ev.getFrom());\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(ev.getFrom());\n            }\n\n            MessageReceivedEvent msgReceivedEvt\n                = new MessageReceivedEvent(\n                    newMessage, sourceContact , new Date() );\n\n            fireMessageEvent(msgReceivedEvt);\n        }","id":32680,"modified_method":"/**\n         * Handle incoming message by creating an appropriate Sip Communicator\n         * <tt>Message<\/tt> and firing a <tt>MessageReceivedEvent<\/tt>\n         * to interested listeners.\n         *\n         * @param ev The original <tt>SessionEvent<\/tt> which noticed us\n         * of an incoming message.\n         */\n        private void handleNewMessage(SessionEvent ev)\n        {\n            logger.debug(\"Message received : \" + ev);\n            \n            //As no indications in the protocol is it html or not. No harm\n            //to set all messages html - doesn't affect the appearance of the gui\n            Message newMessage = createMessage(\n                new MessageDecoder().decodeToHTML(ev.getMessage()).getBytes(),\n                CONTENT_TYPE_HTML,\n                DEFAULT_MIME_ENCODING,\n                null);\n\n            Contact sourceContact = opSetPersPresence.\n                findContactByID(ev.getFrom());\n\n             if(sourceContact == null)\n            {\n                logger.debug(\"received a message from an unknown contact: \"\n                                   + ev.getFrom());\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(ev.getFrom());\n            }\n\n            MessageReceivedEvent msgReceivedEvt\n                = new MessageReceivedEvent(\n                    newMessage, sourceContact , new Date() );\n\n            fireMessageEvent(msgReceivedEvt);\n        }","commit_id":"546b0ba82762d3c3bd637fd00eaff8a479c7c663","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void newMailReceived(SessionNewMailEvent ev)\n         {\n             String myEmail = yahooProvider.getAccountID().getAccountAddress();\n             \n             // this was intended to obtain the user server i.e. mail.yahoo.com,\n             // or mail.yahoo.fr so that the login page is in the preferred user\n             // language. but it always gives yahoo.com, even if the account is registered\n             // with yahoo.fr ... perhaps because the pps always login on yahoo.com ?\n             String yahooMailLogon = \"http://mail.\"\n                     + myEmail.substring(myEmail.indexOf(\"@\") + 1);\n             yahooMailLogon = \"<a href=\\\"\"\n                     + yahooMailLogon + \"\\\">\"\n                     + yahooMailLogon + \"<\/a>\";\n\n             // TODO: care about internationalization ...\n             String newMail = \"<small>New mail, subject :<\/small> \"\n                     + ev.getSubject();\n             newMail += \"\\n<br /><small>From :<\/small> \" + ev.getEmailAddress();\n             newMail += \"\\n<br />&nbsp;&nbsp;&nbsp;&nbsp;\" + yahooMailLogon;\n\n             Message newMailMessage = new MessageYahooImpl(\n                     newMail,\n                     CONTENT_TYPE_HTML,\n                     DEFAULT_MIME_ENCODING,\n                     null);\n\n             Contact sourceContact = opSetPersPresence.\n                 findContactByID(ev.getFrom());\n\n             if (sourceContact == null)\n             {\n                 logger.debug(\"received a new mail from an unknown contact: \"\n                                    + ev.getFrom());\n                 //create the volatile contact\n                 sourceContact = opSetPersPresence\n                     .createVolatileContact(ev.getFrom());\n             }\n             MessageReceivedEvent msgReceivedEvt\n                 = new MessageReceivedEvent(\n                     newMailMessage, sourceContact, new Date(),\n                     MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n\n             fireMessageEvent(msgReceivedEvt);\n         }","id":32681,"modified_method":"/**\n         * Overrides <tt>newMailReceived<\/tt> from <tt>SessionAdapter<\/tt>,\n         * called when yahoo alert us that there is a new message in our mailbox.\n         *\n         * @param ev Event with information on the received email\n         */\n         public void newMailReceived(SessionNewMailEvent ev)\n         {\n             String myEmail = yahooProvider.getAccountID().getAccountAddress();\n             \n             // this was intended to obtain the user server i.e. mail.yahoo.com,\n             // or mail.yahoo.fr so that the login page is in the preferred user\n             // language. but it always gives yahoo.com, even if the account\n             // is registered with yahoo.fr ...\n             // perhaps because the pps always login on yahoo.com ?\n             String yahooMailLogon = \"http://mail.\"\n                     + myEmail.substring(myEmail.indexOf(\"@\") + 1);\n\n             yahooMailLogon = \"<a href=\\\"\"\n                     + yahooMailLogon + \"\\\">\"\n                     + yahooMailLogon + \"<\/a>\";\n\n             String newMail = \"<small>\" + Resources.getString(\"newMail\")\n                    + \" : <\/small> \" + ev.getSubject();\n\n             newMail += \"\\n<br /><small>\" + Resources.getString(\"from\")\n                    + \" : <\/small> \" + ev.getFrom()\n                    + \" &lt;\" + ev.getEmailAddress() + \"&gt;\";\n\n             newMail += \"\\n<br />&nbsp;&nbsp;&nbsp;&nbsp;\" + yahooMailLogon;\n\n             Message newMailMessage = new MessageYahooImpl(\n                     newMail,\n                     CONTENT_TYPE_HTML,\n                     DEFAULT_MIME_ENCODING,\n                     null);\n\n             Contact sourceContact = opSetPersPresence.\n                 findContactByID(ev.getFrom());\n\n             if (sourceContact == null)\n             {\n                 logger.debug(\"received a new mail from an unknown contact: \"\n                                    + ev.getFrom());\n                 //create the volatile contact\n                 sourceContact = opSetPersPresence\n                     .createVolatileContact(ev.getFrom());\n             }\n             MessageReceivedEvent msgReceivedEvt\n                 = new MessageReceivedEvent(\n                     newMailMessage, sourceContact, new Date(),\n                     MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n\n             fireMessageEvent(msgReceivedEvt);\n         }","commit_id":"546b0ba82762d3c3bd637fd00eaff8a479c7c663","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        if (!context.getModelNode().isDefined()) {\n            return;\n        }\n\n        context.startSubsystemElement(Namespace.CURRENT.getUri(), false);\n\n        List<ModelNode> identityManagement = context.getModelNode().asList();\n\n        for (ModelNode modelNode : identityManagement) {\n            String modelName = modelNode.asProperty().getName();\n\n            if (modelName.equals(FEDERATION.getName())) {\n                writers.get(FEDERATION.getName()).write(writer, modelNode);\n            } else {\n                PicketLinkLogger.ROOT_LOGGER.parserUnexpectedElement(modelName);\n            }\n        }\n\n        // End subsystem\n        writer.writeEndElement();\n    }","id":32682,"modified_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        // Start subsystem\n        context.startSubsystemElement(Namespace.CURRENT.getUri(), false);\n\n        ModelNode subsystemNode = context.getModelNode();\n\n        if (subsystemNode.isDefined()) {\n            List<ModelNode> identityManagement = subsystemNode.asList();\n\n            for (ModelNode modelNode : identityManagement) {\n                String modelName = modelNode.asProperty().getName();\n\n                if (modelName.equals(FEDERATION.getName())) {\n                    writers.get(FEDERATION.getName()).write(writer, modelNode);\n                } else {\n                    PicketLinkLogger.ROOT_LOGGER.parserUnexpectedElement(modelName);\n                }\n            }\n        }\n\n        // End subsystem\n        writer.writeEndElement();\n    }","commit_id":"d493be4a18759e0341b147a9294e0e2c6c653012","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        if (!context.getModelNode().isDefined()) {\n            return;\n        }\n\n        context.startSubsystemElement(Namespace.CURRENT.getUri(), false);\n\n        List<ModelNode> identityManagement = context.getModelNode().asList();\n\n        for (ModelNode modelNode : identityManagement) {\n            String modelName = modelNode.asProperty().getName();\n\n            if (modelName.equals(PARTITION_MANAGER.getName())) {\n                writers.get(PARTITION_MANAGER.getName()).write(writer, modelNode);\n            } else {\n                PicketLinkLogger.ROOT_LOGGER.parserUnexpectedElement(modelName);\n            }\n        }\n\n        // End subsystem\n        writer.writeEndElement();\n    }","id":32683,"modified_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        // Start subsystem\n        context.startSubsystemElement(Namespace.CURRENT.getUri(), false);\n\n        ModelNode subsystemNode = context.getModelNode();\n\n        if (subsystemNode.isDefined()) {\n            List<ModelNode> identityManagement = subsystemNode.asList();\n\n            for (ModelNode modelNode : identityManagement) {\n                String modelName = modelNode.asProperty().getName();\n\n                if (modelName.equals(PARTITION_MANAGER.getName())) {\n                    writers.get(PARTITION_MANAGER.getName()).write(writer, modelNode);\n                } else {\n                    PicketLinkLogger.ROOT_LOGGER.parserUnexpectedElement(modelName);\n                }\n            }\n        }\n\n        // End subsystem\n        writer.writeEndElement();\n    }","commit_id":"d493be4a18759e0341b147a9294e0e2c6c653012","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public List<AccessConstraintDefinition> getAccessConstraints() {\n        return Collections.singletonList((AccessConstraintDefinition)JdkORBSubsystemDefinitions.JDKORB_SECURITY_DEF);\n    }","id":32684,"modified_method":"@Override\n    public List<AccessConstraintDefinition> getAccessConstraints() {\n        return Collections.singletonList((AccessConstraintDefinition)AttributeConstants.JDKORB_SECURITY_DEF);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"private IORASContextDefinition() {\n        super(PathElement.pathElement(JdkORBSubsystemConstants.SETTING, JdkORBSubsystemConstants.IOR_AS_CONTEXT),\n                JdkORBExtension.getResourceDescriptionResolver(JdkORBSubsystemConstants.IOR_SETTINGS,\n                        JdkORBSubsystemConstants.IOR_AS_CONTEXT),\n                new AbstractAddStepHandler(ATTRIBUTES),\n                ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","id":32685,"modified_method":"private IORASContextDefinition() {\n        super(JdkORBExtension.PATH_IOR_AS, JdkORBExtension.getResourceDescriptionResolver(\n                JdkORBSubsystemConstants.IOR_SETTINGS, JdkORBSubsystemConstants.IOR_AS_CONTEXT), new AbstractAddStepHandler(\n                ATTRIBUTES), ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"private IORSASContextDefinition() {\n        super(PathElement.pathElement(JdkORBSubsystemConstants.SETTING, JdkORBSubsystemConstants.IOR_SAS_CONTEXT),\n                JdkORBExtension.getResourceDescriptionResolver(JdkORBSubsystemConstants.IOR_SETTINGS,\n                        JdkORBSubsystemConstants.IOR_SAS_CONTEXT),\n                new AbstractAddStepHandler(ATTRIBUTES),\n                ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","id":32686,"modified_method":"private IORSASContextDefinition() {\n        super(JdkORBExtension.PATH_IOR_SAS, JdkORBExtension.getResourceDescriptionResolver(\n                JdkORBSubsystemConstants.IOR_SETTINGS, JdkORBSubsystemConstants.IOR_SAS_CONTEXT), new AbstractAddStepHandler(\n                ATTRIBUTES), ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public List<AccessConstraintDefinition> getAccessConstraints() {\n        return Collections.singletonList((AccessConstraintDefinition) JdkORBSubsystemDefinitions.JDKORB_SECURITY_DEF);\n    }","id":32687,"modified_method":"@Override\n    public List<AccessConstraintDefinition> getAccessConstraints() {\n        return Collections.singletonList((AccessConstraintDefinition) AttributeConstants.JDKORB_SECURITY_DEF);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"private IORSettingsDefinition() {\n        super(PathElement.pathElement(JdkORBSubsystemConstants.IOR_SETTINGS, JdkORBSubsystemConstants.DEFAULT),\n                JdkORBExtension.getResourceDescriptionResolver(JdkORBSubsystemConstants.IOR_SETTINGS),\n                new AbstractAddStepHandler(), ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","id":32688,"modified_method":"private IORSettingsDefinition() {\n        super(JdkORBExtension.PATH_IOR_SETTINGS, JdkORBExtension\n                .getResourceDescriptionResolver(JdkORBSubsystemConstants.IOR_SETTINGS), new AbstractAddStepHandler(),\n                ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"private IORTransportConfigDefinition() {\n        super(PathElement.pathElement(JdkORBSubsystemConstants.SETTING, JdkORBSubsystemConstants.IOR_TRANSPORT_CONFIG),\n                JdkORBExtension.getResourceDescriptionResolver(JdkORBSubsystemConstants.IOR_SETTINGS,\n                        JdkORBSubsystemConstants.IOR_TRANSPORT_CONFIG),\n                new AbstractAddStepHandler(ATTRIBUTES),\n                ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","id":32689,"modified_method":"private IORTransportConfigDefinition() {\n        super(JdkORBExtension.PATH_IOR_TRANSPORT, JdkORBExtension.getResourceDescriptionResolver(\n                JdkORBSubsystemConstants.IOR_SETTINGS, JdkORBSubsystemConstants.IOR_TRANSPORT_CONFIG),\n                new AbstractAddStepHandler(ATTRIBUTES), ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public List<AccessConstraintDefinition> getAccessConstraints() {\n        return Collections.singletonList((AccessConstraintDefinition) JdkORBSubsystemDefinitions.JDKORB_SECURITY_DEF);\n    }","id":32690,"modified_method":"@Override\n    public List<AccessConstraintDefinition> getAccessConstraints() {\n        return Collections.singletonList((AccessConstraintDefinition) AttributeConstants.JDKORB_SECURITY_DEF);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(JdkORBSubsystemResource.INSTANCE);\n        subsystemRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        subsystem.registerXMLElementWriter(PARSER);\n    }","id":32691,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(JdkORBRootDefinition.INSTANCE);\n        subsystemRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        subsystem.registerXMLElementWriter(JdkORBSubsystemParser.INSTANCE);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JdkORBSubsystemParser.Namespace.JdkORB_1_0.getUriString(), PARSER);\n    }","id":32692,"modified_method":"@Override\n    public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME,Namespace.JdkORB_1_0.getUriString(), JdkORBSubsystemParser.INSTANCE);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ClientTransportConfigMetaData createClientTransportConfigMetaData(final OperationContext context, final ModelNode node)\n            throws OperationFailedException {\n        final ClientTransportConfigMetaData clientTransportConfigMetaData = ClientTransportConfigDefinition.INSTANCE.getTransportConfigMetaData(\n                context, node);\n        return clientTransportConfigMetaData;\n    }","id":32693,"modified_method":"private ClientTransportConfigMetaData createClientTransportConfigMetaData(final OperationContext context, final ModelNode node)\n            throws OperationFailedException {\n        final ClientTransportConfigMetaData clientTransportConfigMetaData = ClientTransportDefinition.INSTANCE.getTransportConfigMetaData(\n                context, node);\n        return clientTransportConfigMetaData;\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * <p>\n     * Obtains the subsystem configuration properties from the specified {@code ModelNode}, using default values for undefined\n     * properties. If the property has a JdkORB equivalent, it is translated into its JdkORB counterpart before being added to\n     * the returned {@code Properties} object.\n     * <\/p>\n     *\n     * @param model the {@code ModelNode} that contains the subsystem configuration properties.\n     * @return a {@code Properties} instance containing all configured subsystem properties.\n     * @throws OperationFailedException if an error occurs while resolving the properties.\n     */\n    private Properties getConfigurationProperties(OperationContext context, ModelNode model) throws OperationFailedException {\n        Properties props = new Properties();\n\n        for (AttributeDefinition attrDefinition : JdkORBSubsystemDefinitions.SUBSYSTEM_ATTRIBUTES) {\n            ModelNode resolvedModelAttribute = attrDefinition.resolveModelAttribute(context, model);\n            if (resolvedModelAttribute.isDefined()) {\n                String name = attrDefinition.getName();\n                String value = resolvedModelAttribute.asString();\n\n                String jdkorbProperty = PropertiesMap.JDKORB_PROPS_MAP.get(name);\n                if (jdkorbProperty != null){\n                    name = jdkorbProperty;\n                }\n                props.setProperty(name, value);\n            }\n        }\n\n        // check if the node contains a list of generic properties.\n        if (model.hasDefined(JdkORBSubsystemConstants.PROPERTIES)) {\n            ModelNode propertiesNode = model.get(JdkORBSubsystemConstants.PROPERTIES);\n\n            for (Property property : propertiesNode.asPropertyList()) {\n                String name = property.getName();\n                ModelNode value = property.getValue();\n                props.setProperty(name, value.asString());\n            }\n        }\n        return props;\n    }","id":32694,"modified_method":"/**\n     * <p>\n     * Obtains the subsystem configuration properties from the specified {@code ModelNode}, using default values for undefined\n     * properties. If the property has a JdkORB equivalent, it is translated into its JdkORB counterpart before being added to\n     * the returned {@code Properties} object.\n     * <\/p>\n     *\n     * @param model the {@code ModelNode} that contains the subsystem configuration properties.\n     * @return a {@code Properties} instance containing all configured subsystem properties.\n     * @throws OperationFailedException if an error occurs while resolving the properties.\n     */\n    private Properties getConfigurationProperties(OperationContext context, ModelNode model) throws OperationFailedException {\n        Properties props = new Properties();\n\n        getResourceProperties(props, ORBDefinition.INSTANCE, context,\n                model.get(ORBDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        getResourceProperties(\n                props,\n                TCPDefinition.INSTANCE,\n                context,\n                model.get(ORBDefinition.INSTANCE.getPathElement().getKeyValuePair()).get(\n                        TCPDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        getResourceProperties(\n                props,\n                InitializersDefinition.INSTANCE,\n                context,\n                model.get(ORBDefinition.INSTANCE.getPathElement().getKeyValuePair()).get(\n                        InitializersDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        getResourceProperties(props, NamingDefinition.INSTANCE, context,\n                model.get(NamingDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        getResourceProperties(props, SecurityDefinition.INSTANCE, context,\n                model.get(SecurityDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n\n        // check if the node contains a list of generic properties.\n        ModelNode configNode = model.get(JdkORBSubsystemConstants.CONFIGURATION);\n        if (configNode.hasDefined(JdkORBSubsystemConstants.PROPERTIES)) {\n            for (Property property : configNode.get(JdkORBSubsystemConstants.PROPERTIES).get(JdkORBSubsystemConstants.PROPERTY)\n                    .asPropertyList()) {\n                String name = property.getName();\n                String value = property.getValue().get(JdkORBSubsystemConstants.PROPERTY_VALUE).asString();\n                props.setProperty(name, value);\n            }\n        }\n        return props;\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void launchServices(final OperationContext context, final ModelNode model, final ServiceVerificationHandler verificationHandler,\n                                  final List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n\n        JdkORBLogger.ROOT_LOGGER.activatingSubsystem();\n\n        // set the ORBUseDynamicStub system property.\n        WildFlySecurityManager.setPropertyPrivileged(\"org.jboss.com.sun.CORBA.ORBUseDynamicStub\", \"true\");\n        // we set the same stub factory to both the static and dynamic stub factory. As there is no way to dynamically change\n        // the userDynamicStubs's property at runtime it is possible for the ORB class's <clinit> method to be\n        // called before this property is set.\n        // TODO: investigate a better way to handle this\n        com.sun.corba.se.spi.orb.ORB.getPresentationManager().setStubFactoryFactory(true,\n                new DelegatingStubFactoryFactory());\n        com.sun.corba.se.spi.orb.ORB.getPresentationManager().setStubFactoryFactory(false,\n                new DelegatingStubFactoryFactory());\n\n        // setup naming.\n        InitialContext.addUrlContextFactory(\"corbaloc\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"corbaname\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"IOR\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"iiopname\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"iiop\", JBossCNCtxFactory.INSTANCE);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            public void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(JdkORBExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES,\n                        Phase.DEPENDENCIES_JDKORB, new JdkORBDependencyProcessor());\n                processorTarget.addDeploymentProcessor(JdkORBExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_JDKORB,\n                        new JdkORBMarkerProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // get the configured ORB properties.\n        Properties props = this.getConfigurationProperties(context, model);\n\n        // setup the ORB initializers using the configured properties.\n        this.setupInitializers(props);\n\n        // setup the SSL socket factories, if necessary.\n        this.setupSSLFactories(props);\n\n        // create the service that initializes and starts the CORBA ORB.\n\n\n        CorbaORBService orbService = new CorbaORBService(props);\n        final ServiceBuilder<ORB> builder = context.getServiceTarget().addService(CorbaORBService.SERVICE_NAME, orbService);\n        org.jboss.as.server.Services.addServerExecutorDependency(builder, orbService.getExecutorInjector(), false);\n\n        // if a security domain has been specified, add a dependency to the domain service.\n        String securityDomain = props.getProperty(JdkORBSubsystemConstants.SECURITY_SECURITY_DOMAIN);\n        if (securityDomain != null && !securityDomain.isEmpty())\n            builder.addDependency(SECURITY_DOMAIN_SERVICE_NAME.append(securityDomain));\n\n        // inject the socket bindings that specify the JdkORB IIOP and IIOP/SSL ports.\n        String socketBinding = props.getProperty(JdkORBSubsystemConstants.ORB_SOCKET_BINDING);\n        builder.addDependency(SocketBinding.JBOSS_BINDING_NAME.append(socketBinding), SocketBinding.class,\n                orbService.getJdkORBSocketBindingInjector());\n        String sslSocketBinding = props.getProperty(JdkORBSubsystemConstants.ORB_SSL_SOCKET_BINDING);\n        builder.addDependency(SocketBinding.JBOSS_BINDING_NAME.append(sslSocketBinding), SocketBinding.class,\n                orbService.getJdkORBSSLSocketBindingInjector());\n        builder.addListener(verificationHandler);\n        // set the initial mode and install the service.\n        newControllers.add(builder.setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the service the initializes the Root POA.\n        CorbaPOAService rootPOAService = new CorbaPOAService(\"RootPOA\", \"poa\");\n        newControllers.add(context.getServiceTarget().addService(CorbaPOAService.ROOT_SERVICE_NAME, rootPOAService)\n                .addDependency(CorbaORBService.SERVICE_NAME, ORB.class, rootPOAService.getORBInjector())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the service the initializes the interface repository POA.\n        final CorbaPOAService irPOAService = new CorbaPOAService(\"IRPOA\", \"irpoa\", IdAssignmentPolicyValue.USER_ID, null, null,\n                LifespanPolicyValue.PERSISTENT, null, null, null);\n        newControllers.add(context.getServiceTarget()\n                .addService(CorbaPOAService.INTERFACE_REPOSITORY_SERVICE_NAME, irPOAService)\n                .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, irPOAService.getParentPOAInjector())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the service that initializes the naming service POA.\n        final CorbaPOAService namingPOAService = new CorbaPOAService(\"Naming\", null, IdAssignmentPolicyValue.USER_ID, null,\n                null, LifespanPolicyValue.PERSISTENT, null, null, null);\n        newControllers.add(context.getServiceTarget()\n                .addService(CorbaPOAService.SERVICE_NAME.append(\"namingpoa\"), namingPOAService)\n                .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, namingPOAService.getParentPOAInjector())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the CORBA naming service.\n        final String rootContext = props.getProperty(JdkORBSubsystemConstants.NAMING_ROOT_CONTEXT);\n        final CorbaNamingService namingService = new CorbaNamingService(rootContext);\n        newControllers.add(context\n                .getServiceTarget()\n                .addService(CorbaNamingService.SERVICE_NAME, namingService)\n                .addDependency(CorbaORBService.SERVICE_NAME, ORB.class, namingService.getORBInjector())\n                .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, namingService.getRootPOAInjector())\n                .addDependency(CorbaPOAService.SERVICE_NAME.append(\"namingpoa\"), POA.class,\n                        namingService.getNamingPOAInjector()).addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n     // create the IOR security config metadata service.\n        IORSecurityConfigMetaData securityConfigMetaData = null;\n        if (model.hasDefined(JdkORBSubsystemConstants.IOR_SETTINGS)) {\n            securityConfigMetaData = this.createIORSecurityConfigMetaData(context,\n                    model.get(IORSettingsDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        }\n        newControllers.add(context.getServiceTarget().addService(IORSecConfigMetaDataService.SERVICE_NAME,\n                new IORSecConfigMetaDataService(securityConfigMetaData))\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        ClientTransportConfigMetaData clientTransportConfigMetaData = null;\n        clientTransportConfigMetaData = this.createClientTransportConfigMetaData(context,\n                model.get(ClientTransportConfigDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        CSIV2IORToSocketInfo.setClientTransportConfigMetaData(clientTransportConfigMetaData);\n    }","id":32695,"modified_method":"protected void launchServices(final OperationContext context, final ModelNode model, final ServiceVerificationHandler verificationHandler,\n                                  final List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n\n        JdkORBLogger.ROOT_LOGGER.activatingSubsystem();\n\n        // set the ORBUseDynamicStub system property.\n        WildFlySecurityManager.setPropertyPrivileged(\"org.jboss.com.sun.CORBA.ORBUseDynamicStub\", \"true\");\n        // we set the same stub factory to both the static and dynamic stub factory. As there is no way to dynamically change\n        // the userDynamicStubs's property at runtime it is possible for the ORB class's <clinit> method to be\n        // called before this property is set.\n        // TODO: investigate a better way to handle this\n        com.sun.corba.se.spi.orb.ORB.getPresentationManager().setStubFactoryFactory(true,\n                new DelegatingStubFactoryFactory());\n        com.sun.corba.se.spi.orb.ORB.getPresentationManager().setStubFactoryFactory(false,\n                new DelegatingStubFactoryFactory());\n\n        // setup naming.\n        InitialContext.addUrlContextFactory(\"corbaloc\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"corbaname\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"IOR\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"iiopname\", JBossCNCtxFactory.INSTANCE);\n        InitialContext.addUrlContextFactory(\"iiop\", JBossCNCtxFactory.INSTANCE);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            public void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(JdkORBExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES,\n                        Phase.DEPENDENCIES_JDKORB, new JdkORBDependencyProcessor());\n                processorTarget.addDeploymentProcessor(JdkORBExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_JDKORB,\n                        new JdkORBMarkerProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // get the configured ORB properties.\n        Properties props = this.getConfigurationProperties(context, model);\n\n        // setup the ORB initializers using the configured properties.\n        this.setupInitializers(props);\n\n        // setup the SSL socket factories, if necessary.\n        this.setupSSLFactories(props);\n\n        // create the service that initializes and starts the CORBA ORB.\n\n\n        CorbaORBService orbService = new CorbaORBService(props);\n        final ServiceBuilder<ORB> builder = context.getServiceTarget().addService(CorbaORBService.SERVICE_NAME, orbService);\n        org.jboss.as.server.Services.addServerExecutorDependency(builder, orbService.getExecutorInjector(), false);\n\n        // if a security domain has been specified, add a dependency to the domain service.\n        String securityDomain = props.getProperty(JdkORBSubsystemConstants.SECURITY_SECURITY_DOMAIN);\n        if (securityDomain != null && !securityDomain.isEmpty())\n            builder.addDependency(SECURITY_DOMAIN_SERVICE_NAME.append(securityDomain));\n\n        // inject the socket bindings that specify the JdkORB IIOP and IIOP/SSL ports.\n        String socketBinding = props.getProperty(JdkORBSubsystemConstants.ORB_SOCKET_BINDING);\n        builder.addDependency(SocketBinding.JBOSS_BINDING_NAME.append(socketBinding), SocketBinding.class,\n                orbService.getJdkORBSocketBindingInjector());\n        String sslSocketBinding = props.getProperty(JdkORBSubsystemConstants.ORB_SSL_SOCKET_BINDING);\n        builder.addDependency(SocketBinding.JBOSS_BINDING_NAME.append(sslSocketBinding), SocketBinding.class,\n                orbService.getJdkORBSSLSocketBindingInjector());\n        builder.addListener(verificationHandler);\n        // set the initial mode and install the service.\n        newControllers.add(builder.setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the service the initializes the Root POA.\n        CorbaPOAService rootPOAService = new CorbaPOAService(\"RootPOA\", \"poa\");\n        newControllers.add(context.getServiceTarget().addService(CorbaPOAService.ROOT_SERVICE_NAME, rootPOAService)\n                .addDependency(CorbaORBService.SERVICE_NAME, ORB.class, rootPOAService.getORBInjector())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the service the initializes the interface repository POA.\n        final CorbaPOAService irPOAService = new CorbaPOAService(\"IRPOA\", \"irpoa\", IdAssignmentPolicyValue.USER_ID, null, null,\n                LifespanPolicyValue.PERSISTENT, null, null, null);\n        newControllers.add(context.getServiceTarget()\n                .addService(CorbaPOAService.INTERFACE_REPOSITORY_SERVICE_NAME, irPOAService)\n                .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, irPOAService.getParentPOAInjector())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the service that initializes the naming service POA.\n        final CorbaPOAService namingPOAService = new CorbaPOAService(\"Naming\", null, IdAssignmentPolicyValue.USER_ID, null,\n                null, LifespanPolicyValue.PERSISTENT, null, null, null);\n        newControllers.add(context.getServiceTarget()\n                .addService(CorbaPOAService.SERVICE_NAME.append(\"namingpoa\"), namingPOAService)\n                .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, namingPOAService.getParentPOAInjector())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        // create the CORBA naming service.\n        final String rootContext = props.getProperty(JdkORBSubsystemConstants.NAMING_ROOT_CONTEXT);\n        final CorbaNamingService namingService = new CorbaNamingService(rootContext);\n        newControllers.add(context\n                .getServiceTarget()\n                .addService(CorbaNamingService.SERVICE_NAME, namingService)\n                .addDependency(CorbaORBService.SERVICE_NAME, ORB.class, namingService.getORBInjector())\n                .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, namingService.getRootPOAInjector())\n                .addDependency(CorbaPOAService.SERVICE_NAME.append(\"namingpoa\"), POA.class,\n                        namingService.getNamingPOAInjector()).addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n     // create the IOR security config metadata service.\n        IORSecurityConfigMetaData securityConfigMetaData = null;\n        if (model.hasDefined(JdkORBSubsystemConstants.IOR_SETTINGS)) {\n            securityConfigMetaData = this.createIORSecurityConfigMetaData(context,\n                    model.get(IORSettingsDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        }\n        newControllers.add(context.getServiceTarget().addService(IORSecConfigMetaDataService.SERVICE_NAME,\n                new IORSecConfigMetaDataService(securityConfigMetaData))\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        ClientTransportConfigMetaData clientTransportConfigMetaData = null;\n        clientTransportConfigMetaData = this.createClientTransportConfigMetaData(context,\n                model.get(ClientTransportDefinition.INSTANCE.getPathElement().getKeyValuePair()));\n        CSIV2IORToSocketInfo.setClientTransportConfigMetaData(clientTransportConfigMetaData);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n        ModelNode node = context.getModelNode();\n\n        // write the orb configuration section if there are any orb properties to be written.\n        this.writeORBConfig(writer, node);\n\n        // write the naming configuration section if there are any naming properties to be written.\n        this.writeNamingConfig(writer, node);\n\n        // write the security configuration section if there are any security properties to be written.\n        this.writeSecurityConfig(writer, node);\n\n        if (node.hasDefined(JdkORBSubsystemConstants.IOR_SETTINGS))\n            IORSettingsParser.INSTANCE.writeContent(writer, node.get(JdkORBSubsystemConstants.IOR_SETTINGS,\n                    JdkORBSubsystemConstants.DEFAULT));\n\n        if (node.hasDefined(JdkORBSubsystemConstants.CLIENT_TRANSPORT_CONFIG))\n            ClientTransportParser.INSTANCE.writeContent(writer, node.get(JdkORBSubsystemConstants.CLIENT_TRANSPORT_CONFIG,\n                    JdkORBSubsystemConstants.DEFAULT));\n\n        // write all defined generic properties.\n        String properties = JdkORBSubsystemConstants.PROPERTIES;\n        if (node.hasDefined(properties)) {\n            this.writeGenericProperties(writer, node.get(properties));\n        }\n\n        writer.writeEndElement(); // End of subsystem element\n    }","id":32696,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        ModelNode model = new ModelNode();\n        model.get(JdkORBRootDefinition.INSTANCE.getPathElement().getKeyValuePair()).set(context.getModelNode());\n        xmlDescription.persist(writer, model, Namespace.CURRENT.getUriString());\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> nodes) throws XMLStreamException {\n        // the subsystem element has no attributes.\n        requireNoAttributes(reader);\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).add(SUBSYSTEM, JdkORBExtension.SUBSYSTEM_NAME);\n        nodes.add(subsystem);\n\n        Namespace readerNS = Namespace.forUri(reader.getNamespaceURI());\n        switch (readerNS) {\n            case JdkORB_1_0: {\n                this.readElement_1_0(readerNS, reader, nodes);\n                break;\n            }\n            default: {\n                throw unexpectedElement(reader);\n            }\n        }\n    }","id":32697,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        xmlDescription.parse(reader, PathAddress.EMPTY_ADDRESS, list);\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testParseEmptySubsystem() throws Exception {\n        // parse the subsystem xml into operations.\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" +JdkORBSubsystemParser.Namespace.CURRENT.getUriString() + \"\\\">\" +\n                \"<\/subsystem>\";\n        List<ModelNode> operations = super.parse(subsystemXml);\n\n        // check that we have the expected number of operations.\n        Assert.assertEquals(1, operations.size());\n\n        // check that each operation has the correct content.\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ADD, addSubsystem.get(OP).asString());\n        PathAddress addr = PathAddress.pathAddress(addSubsystem.get(OP_ADDR));\n        Assert.assertEquals(1, addr.size());\n        PathElement element = addr.getElement(0);\n        Assert.assertEquals(SUBSYSTEM, element.getKey());\n        Assert.assertEquals(JdkORBExtension.SUBSYSTEM_NAME, element.getValue());\n    }","id":32698,"modified_method":"@Test\n    public void testParseEmptySubsystem() throws Exception {\n        // parse the subsystem xml into operations.\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" +Namespace.CURRENT.getUriString() + \"\\\">\" +\n                \"<\/subsystem>\";\n        List<ModelNode> operations = super.parse(subsystemXml);\n\n        // check that we have the expected number of operations.\n        Assert.assertEquals(1, operations.size());\n\n        // check that each operation has the correct content.\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ADD, addSubsystem.get(OP).asString());\n        PathAddress addr = PathAddress.pathAddress(addSubsystem.get(OP_ADDR));\n        Assert.assertEquals(1, addr.size());\n        PathElement element = addr.getElement(0);\n        Assert.assertEquals(SUBSYSTEM, element.getKey());\n        Assert.assertEquals(JdkORBExtension.SUBSYSTEM_NAME, element.getValue());\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDescribeHandler() throws Exception {\n        // parse the subsystem xml and install into the first controller.\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" + JdkORBSubsystemParser.Namespace.CURRENT.getUriString() + \"\\\">\" +\n                \"<\/subsystem>\";\n\n        AdditionalInitialization additionalInit = new AdditionalInitialization(){\n            @Override\n            protected void setupController(ControllerInitializer controllerInitializer) {\n                controllerInitializer.addSocketBinding(\"jdkorb\", 3528);\n                controllerInitializer.addSocketBinding(\"jdkorb-ssl\", 3529);\n            }\n        };\n\n        KernelServices servicesA = createKernelServicesBuilder(additionalInit)\n                .setSubsystemXml(subsystemXml)\n                .build();\n        // get the model and the describe operations from the first controller.\n        ModelNode modelA = servicesA.readWholeModel();\n        ModelNode describeOp = new ModelNode();\n        describeOp.get(OP).set(DESCRIBE);\n        describeOp.get(OP_ADDR).set(\n                PathAddress.pathAddress(\n                        PathElement.pathElement(SUBSYSTEM, JdkORBExtension.SUBSYSTEM_NAME)).toModelNode());\n        List<ModelNode> operations = checkResultAndGetContents(servicesA.executeOperation(describeOp)).asList();\n        servicesA.shutdown();\n\n        Assert.assertEquals(1, operations.size());\n\n        // install the describe options from the first controller into a second controller.\n        KernelServices servicesB = createKernelServicesBuilder(additionalInit).setBootOperations(operations).build();\n        ModelNode modelB = servicesB.readWholeModel();\n        servicesB.shutdown();\n\n        // make sure the models from the two controllers are identical.\n        super.compare(modelA, modelB);\n\n    }","id":32699,"modified_method":"@Test\n    public void testDescribeHandler() throws Exception {\n        // parse the subsystem xml and install into the first controller.\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" + Namespace.CURRENT.getUriString() + \"\\\">\" +\n                \"<\/subsystem>\";\n\n        AdditionalInitialization additionalInit = new AdditionalInitialization(){\n            @Override\n            protected void setupController(ControllerInitializer controllerInitializer) {\n                controllerInitializer.addSocketBinding(\"jdkorb\", 3528);\n                controllerInitializer.addSocketBinding(\"jdkorb-ssl\", 3529);\n            }\n        };\n\n        KernelServices servicesA = createKernelServicesBuilder(additionalInit)\n                .setSubsystemXml(subsystemXml)\n                .build();\n        // get the model and the describe operations from the first controller.\n        ModelNode modelA = servicesA.readWholeModel();\n        ModelNode describeOp = new ModelNode();\n        describeOp.get(OP).set(DESCRIBE);\n        describeOp.get(OP_ADDR).set(\n                PathAddress.pathAddress(\n                        PathElement.pathElement(SUBSYSTEM, JdkORBExtension.SUBSYSTEM_NAME)).toModelNode());\n        List<ModelNode> operations = checkResultAndGetContents(servicesA.executeOperation(describeOp)).asList();\n        servicesA.shutdown();\n\n        Assert.assertEquals(1, operations.size());\n\n        // install the describe options from the first controller into a second controller.\n        KernelServices servicesB = createKernelServicesBuilder(additionalInit).setBootOperations(operations).build();\n        ModelNode modelB = servicesB.readWholeModel();\n        servicesB.shutdown();\n\n        // make sure the models from the two controllers are identical.\n        super.compare(modelA, modelB);\n\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testParseSubsystemWithBadChild() throws Exception {\n        // try parsing a XML with an invalid element.\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" + JdkORBSubsystemParser.Namespace.CURRENT.getUriString() + \"\\\">\" +\n                \"   <invalid/>\" +\n                \"<\/subsystem>\";\n        try {\n            super.parse(subsystemXml);\n            Assert.fail(\"Should not have parsed bad child\");\n        } catch (XMLStreamException expected) {\n        }\n\n        // now try parsing a valid element in an invalid position.\n        subsystemXml =\n                \"<subsystem xmlns=\\\"urn:jboss:domain:jdkorb:1.0\\\">\" +\n                \"    <orb>\" +\n                \"        <poa/>\" +\n                \"    <\/orb>\" +\n                \"<\/subsystem>\";\n        try {\n            super.parse(subsystemXml);\n            Assert.fail(\"Should not have parsed bad child\");\n        } catch (XMLStreamException expected) {\n        }\n\n    }","id":32700,"modified_method":"@Test\n    public void testParseSubsystemWithBadChild() throws Exception {\n        // try parsing a XML with an invalid element.\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" + Namespace.CURRENT.getUriString() + \"\\\">\" +\n                \"   <invalid/>\" +\n                \"<\/subsystem>\";\n        try {\n            super.parse(subsystemXml);\n            Assert.fail(\"Should not have parsed bad child\");\n        } catch (XMLStreamException expected) {\n        }\n\n        // now try parsing a valid element in an invalid position.\n        subsystemXml =\n                \"<subsystem xmlns=\\\"urn:jboss:domain:jdkorb:1.0\\\">\" +\n                \"    <orb>\" +\n                \"        <poa/>\" +\n                \"    <\/orb>\" +\n                \"<\/subsystem>\";\n        try {\n            super.parse(subsystemXml);\n            Assert.fail(\"Should not have parsed bad child\");\n        } catch (XMLStreamException expected) {\n        }\n\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testParseSubsystemWithBadAttribute() throws Exception {\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" + JdkORBSubsystemParser.Namespace.CURRENT.getUriString() + \"\\\" bad=\\\"very_bad\\\">\" +\n                \"<\/subsystem>\";\n        try {\n            super.parse(subsystemXml);\n            Assert.fail(\"Should not have parsed bad attribute\");\n        } catch (XMLStreamException expected) {\n        }\n    }","id":32701,"modified_method":"@Test\n    public void testParseSubsystemWithBadAttribute() throws Exception {\n        String subsystemXml =\n                \"<subsystem xmlns=\\\"\" + Namespace.CURRENT.getUriString() + \"\\\" bad=\\\"very_bad\\\">\" +\n                \"<\/subsystem>\";\n        try {\n            super.parse(subsystemXml);\n            Assert.fail(\"Should not have parsed bad attribute\");\n        } catch (XMLStreamException expected) {\n        }\n    }","commit_id":"643b7f3316a051f04f8908cd90393b5ed21c0a10","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n        log.debugf(\"Activating WebServices Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        subsystem.registerXMLElementWriter(WebservicesSubsystemParser.getInstance());\n        // ws subsystem\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(WSSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, WSSubsystemAdd.INSTANCE, WSSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(DESCRIBE, WSSubsystemDescribe.INSTANCE, WSSubsystemProviders.SUBSYSTEM_DESCRIBE, false, PRIVATE);\n        // ws endpoint children\n        final ModelNodeRegistration endpoints = registration.registerSubModel(PathElement.pathElement(ENDPOINT), WSSubsystemProviders.ENDPOINT_DESCRIPTION);\n        endpoints.registerOperationHandler(ADD, WSEndpointAdd.INSTANCE, WSSubsystemProviders.ENDPOINT_ADD_DESCRIPTION, false, PRIVATE);\n        endpoints.registerOperationHandler(REMOVE, WSEndpointRemove.INSTANCE, WSSubsystemProviders.ENDPOINT_REMOVE_DESCRIPTION, false, PRIVATE);\n        // ws endpoint metrics\n        for (final String attributeName : WSEndpointMetrics.ATTRIBUTES) {\n            endpoints.registerMetric(attributeName, WSEndpointMetrics.INSTANCE);\n        }\n    }","id":32702,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n        log.debugf(\"Activating WebServices Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        subsystem.registerXMLElementWriter(WebservicesSubsystemParser.getInstance());\n        // ws subsystem\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(WSSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, WSSubsystemAdd.INSTANCE, WSSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(DESCRIBE, WSSubsystemDescribe.INSTANCE, WSSubsystemProviders.SUBSYSTEM_DESCRIBE, false, PRIVATE);\n        // ws endpont configuration\n        final ModelNodeRegistration epConfigs = registration.registerSubModel(PathElement.pathElement(ENDPOINT_CONFIG), WSSubsystemProviders.ENDPOINTCONFIG_DESCRIPTION);\n        epConfigs.registerOperationHandler(ADD, EndpointConfigAdd.INSTANCE, WSSubsystemProviders.ENDPOINTCONFIG_ADD_DESCRIPTION, false);\n        epConfigs.registerOperationHandler(REMOVE, EndpointConfigRemove.INSTANCE, WSSubsystemProviders.ENDPOINTCONFIG_REMOVE_DESCRIPTION, false);\n\n        // ws endpoint children\n        final ModelNodeRegistration endpoints = registration.registerSubModel(PathElement.pathElement(ENDPOINT), WSSubsystemProviders.ENDPOINT_DESCRIPTION);\n        endpoints.registerOperationHandler(ADD, WSEndpointAdd.INSTANCE, WSSubsystemProviders.ENDPOINT_ADD_DESCRIPTION, false, PRIVATE);\n        endpoints.registerOperationHandler(REMOVE, WSEndpointRemove.INSTANCE, WSSubsystemProviders.ENDPOINT_REMOVE_DESCRIPTION, false, PRIVATE);\n        // ws endpoint metrics\n        for (final String attributeName : WSEndpointMetrics.ATTRIBUTES) {\n            endpoints.registerMetric(attributeName, WSEndpointMetrics.INSTANCE);\n        }\n    }","commit_id":"9792b0c4e413484bf5bccfae961f16b29dc488af","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void populateSubModel(final ModelNode operation, final ModelNode submodel) {\n        submodel.get(MODIFY_WSDL_ADDRESS).set(operation.require(MODIFY_WSDL_ADDRESS));\n        submodel.get(WSDL_HOST).set(operation.require(WSDL_HOST));\n        if (operation.has(WSDL_PORT)) {\n            submodel.get(WSDL_PORT).set(operation.require(WSDL_PORT));\n        }\n        if (operation.has(WSDL_SECURE_PORT)) {\n            submodel.get(WSDL_SECURE_PORT).set(operation.require(WSDL_SECURE_PORT));\n        }\n        submodel.get(ENDPOINT).setEmptyObject();\n    }","id":32703,"modified_method":"private static void populateSubModel(final ModelNode operation, final ModelNode submodel) {\n        submodel.get(MODIFY_WSDL_ADDRESS).set(operation.require(MODIFY_WSDL_ADDRESS));\n        submodel.get(WSDL_HOST).set(operation.require(WSDL_HOST));\n        if (operation.has(WSDL_PORT)) {\n            submodel.get(WSDL_PORT).set(operation.require(WSDL_PORT));\n        }\n        if (operation.has(WSDL_SECURE_PORT)) {\n            submodel.get(WSDL_SECURE_PORT).set(operation.require(WSDL_SECURE_PORT));\n        }\n        submodel.get(ENDPOINT_CONFIG).setEmptyObject();\n        submodel.get(ENDPOINT).setEmptyObject();\n    }","commit_id":"9792b0c4e413484bf5bccfae961f16b29dc488af","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        // no attributes\n        requireNoAttributes(reader);\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).add(SUBSYSTEM, WSExtension.SUBSYSTEM_NAME);\n\n        // elements\n        final EnumSet<Element> required = EnumSet.of(Element.MODIFY_WSDL_ADDRESS, Element.WSDL_HOST);\n        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEBSERVICES_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    required.remove(element);\n                    if (!encountered.add(element)) {\n                        throw unexpectedElement(reader);\n                    }\n                    switch (element) {\n                    case WSDL_HOST: {\n                        subsystem.get(WSDL_HOST).set(parseElementNoAttributes(reader));\n                        break;\n                    }\n                    case MODIFY_WSDL_ADDRESS: {\n                        boolean b = Boolean.parseBoolean(parseElementNoAttributes(reader));\n                        subsystem.get(MODIFY_WSDL_ADDRESS).set(b);\n                        break;\n                    }\n                    case WSDL_SECURE_PORT: {\n                        int port = Integer.valueOf(parseElementNoAttributes(reader));\n                        subsystem.get(WSDL_SECURE_PORT).set(port);\n                        break;\n                    }\n                    case WSDL_PORT: {\n                        int port = Integer.valueOf(parseElementNoAttributes(reader));\n                        subsystem.get(WSDL_PORT).set(port);\n                        break;\n                    }\n                    default: {\n                        throw unexpectedElement(reader);\n                    }\n                }\n                break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n        if (!required.isEmpty()) {\n            throw missingRequiredElement(reader, required);\n        }\n\n        list.add(subsystem);\n    }","id":32704,"modified_method":"@Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        // no attributes\n        requireNoAttributes(reader);\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).add(SUBSYSTEM, WSExtension.SUBSYSTEM_NAME);\n\n        final List<ModelNode> endpointConfigs = new ArrayList<ModelNode>();\n\n        // elements\n        final EnumSet<Element> required = EnumSet.of(Element.MODIFY_WSDL_ADDRESS, Element.WSDL_HOST);\n        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case WEBSERVICES_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    required.remove(element);\n                    if (element != Element.ENDPOINT_CONFIG && !encountered.add(element)) {\n                        throw unexpectedElement(reader);\n                    }\n                    switch (element) {\n                        case WSDL_HOST: {\n                            subsystem.get(WSDL_HOST).set(parseElementNoAttributes(reader));\n                            break;\n                        }\n                        case MODIFY_WSDL_ADDRESS: {\n                            boolean b = Boolean.parseBoolean(parseElementNoAttributes(reader));\n                            subsystem.get(MODIFY_WSDL_ADDRESS).set(b);\n                            break;\n                        }\n                        case WSDL_SECURE_PORT: {\n                            int port = Integer.valueOf(parseElementNoAttributes(reader));\n                            subsystem.get(WSDL_SECURE_PORT).set(port);\n                            break;\n                        }\n                        case ENDPOINT_CONFIG: {\n                            readEndpointConfig(reader, subsystem.get(OP_ADDR), endpointConfigs);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n        if (!required.isEmpty()) {\n            throw missingRequiredElement(reader, required);\n        }\n\n        list.add(subsystem);\n        list.addAll(endpointConfigs);\n    }","commit_id":"9792b0c4e413484bf5bccfae961f16b29dc488af","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n        writeElement(writer, Element.WSDL_HOST, node.require(WSDL_HOST));\n        writeElement(writer, Element.MODIFY_WSDL_ADDRESS, node.require(MODIFY_WSDL_ADDRESS));\n        if (has(node, WSDL_SECURE_PORT)) {\n            writeElement(writer, Element.WSDL_SECURE_PORT, node.require(WSDL_SECURE_PORT));\n        }\n        if (has(node, WSDL_PORT)) {\n            writeElement(writer, Element.WSDL_PORT, node.require(WSDL_PORT));\n        }\n\n        writer.writeEndElement(); // End of subsystem element\n    }","id":32705,"modified_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        SubsystemMarshallingContext newContext = new SubsystemMarshallingContext(context.getModelNode(), writer);\n        newContext.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = newContext.getModelNode();\n        writeElement(writer, Element.WSDL_HOST, node.require(WSDL_HOST));\n        writeElement(writer, Element.MODIFY_WSDL_ADDRESS, node.require(MODIFY_WSDL_ADDRESS));\n        if (has(node, WSDL_SECURE_PORT)) {\n            writeElement(writer, Element.WSDL_SECURE_PORT, node.require(WSDL_SECURE_PORT));\n        }\n        if (has(node, WSDL_PORT)) {\n            writeElement(writer, Element.WSDL_PORT, node.require(WSDL_PORT));\n        }\n        if (has(node, ENDPOINT_CONFIG)) {\n            for (String name : node.get(ENDPOINT_CONFIG).keys()) {\n                writeEndpointConfig(writer, name, node.get(ENDPOINT_CONFIG, name));\n            }\n        }\n\n        writer.writeEndElement(); // End of subsystem element\n    }","commit_id":"9792b0c4e413484bf5bccfae961f16b29dc488af","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        return ATTRIBUTES;\n    }","id":32706,"modified_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        return (Collection) ATTRIBUTES;\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        return Arrays.asList(PATH, CACHE_BUFFER_SIZE, CACHE_BUFFERS);\n    }","id":32707,"modified_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        return Arrays.asList(PATH, CACHE_BUFFER_SIZE, CACHE_BUFFERS, DIRECTORY_LISTING);\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public HttpHandler createHandler(HttpHandler next, final OperationContext context, ModelNode model) throws OperationFailedException {\n        String path = PATH.resolveModelAttribute(context, model).asString();\n        UndertowLogger.ROOT_LOGGER.infof(\"Creating file handler for path %s\", path);\n        FileResourceManager resourceManager = new FileResourceManager(Paths.get(path));\n        ResourceHandler handler = new ResourceHandler();\n        handler.setResourceManager(resourceManager);\n        handler.setDirectoryListingEnabled(true);\n        return handler;\n    }","id":32708,"modified_method":"@Override\n    public HttpHandler createHandler(final OperationContext context, ModelNode model) throws OperationFailedException {\n        String path = PATH.resolveModelAttribute(context, model).asString();\n        boolean directoryListing = DIRECTORY_LISTING.resolveModelAttribute(context, model).asBoolean();\n        UndertowLogger.ROOT_LOGGER.infof(\"Creating file handler for path %s\", path);\n        FileResourceManager resourceManager = new FileResourceManager(Paths.get(path));\n        ResourceHandler handler = new ResourceHandler();\n        handler.setResourceManager(resourceManager);\n        handler.setDirectoryListingEnabled(directoryListing);\n        return handler;\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"public FileHandler() {\n        super(\"file\");\n    }","id":32709,"modified_method":"FileHandler() {\n        super(\"file\");\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"private LocationAdd() {\n\n    }","id":32710,"modified_method":"private LocationAdd() {\n        super(LocationDefinition.HANDLER);\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathAddress hostAddress = address.subAddress(0, address.size() - 1);\n        final PathAddress serverAddress = hostAddress.subAddress(0, hostAddress.size() - 1);\n        final String name = address.getLastElement().getValue();\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        HttpHandler handlerChain = HandlerFactory.getHandlerChain(fullModel,context);\n\n        final LocationService service = new LocationService(name,handlerChain);\n        final String serverName = serverAddress.getLastElement().getValue();\n        final String hostName = hostAddress.getLastElement().getValue();\n        final ServiceName hostServiceName = UndertowService.virtualHostName(serverName, hostName);\n        final ServiceName serviceName = UndertowService.locationServiceName(serverName, hostName, name);\n        final ServiceBuilder<LocationService> builder = context.getServiceTarget().addService(serviceName, service)\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addAliases(WebHost.SERVICE_NAME.append(name));\n\n        builder.setInitialMode(ServiceController.Mode.ACTIVE);\n\n        final ServiceController<LocationService> serviceController = builder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n\n    }","id":32711,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathAddress hostAddress = address.subAddress(0, address.size() - 1);\n        final PathAddress serverAddress = hostAddress.subAddress(0, hostAddress.size() - 1);\n        final String name = address.getLastElement().getValue();\n        final String handler = LocationDefinition.HANDLER.resolveModelAttribute(context, model).asString();\n\n\n        final LocationService service = new LocationService(name);\n        final String serverName = serverAddress.getLastElement().getValue();\n        final String hostName = hostAddress.getLastElement().getValue();\n        final ServiceName hostServiceName = UndertowService.virtualHostName(serverName, hostName);\n        final ServiceName serviceName = UndertowService.locationServiceName(serverName, hostName, name);\n        final ServiceBuilder<LocationService> builder = context.getServiceTarget().addService(serviceName, service)\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addDependency(UndertowService.HANDLER.append(handler), HttpHandler.class, service.getHttpHandler())\n                .addAliases(WebHost.SERVICE_NAME.append(name));\n\n        builder.setInitialMode(ServiceController.Mode.ACTIVE);\n\n        final ServiceController<LocationService> serviceController = builder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        return Collections.emptySet();\n    }","id":32712,"modified_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        return Collections.singleton(HANDLER);\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"public LocationService(String locationPath, HttpHandler handlerChain) {\n        this.locationPath = locationPath;\n        this.handlerChain = handlerChain;\n    }","id":32713,"modified_method":"public LocationService(String locationPath) {\n        this.locationPath = locationPath;\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        UndertowLogger.ROOT_LOGGER.infof(\"registering handler %s under path '%s'\", handlerChain, locationPath);\n        host.getValue().registerHandler(locationPath, handlerChain);\n    }","id":32714,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        UndertowLogger.ROOT_LOGGER.infof(\"registering handler %s under path '%s'\", httpHandler, locationPath);\n        host.getValue().registerHandler(locationPath, httpHandler.getValue());\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void persist(XMLExtendedStreamWriter writer, ModelNode model) throws XMLStreamException {\n        boolean wildcard = getPathElement().isWildcard();\n        model = wildcard ? model.get(getPathElement().getKey()) : model.get(getPathElement().getKeyValuePair());\n        if (!model.isDefined() && !useValueAsElementName()) {\n            return;\n        }\n        boolean writeWrapper = getXmlWrapperElement() != null;\n        if (writeWrapper) {\n            writer.writeStartElement(getXmlWrapperElement());\n        }\n\n        if (wildcard) {\n            for (Property p : model.asPropertyList()) {\n                if (useValueAsElementName()) {\n                    writer.writeStartElement(p.getName());\n                } else {\n                    writer.writeStartElement(getXmlElementName());\n                    writer.writeAttribute(NAME, p.getName());\n                }\n                for (AttributeDefinition def : getAttributes()) {\n                    def.getAttributeMarshaller().marshallAsAttribute(def, p.getValue(), false, writer);\n                }\n                persistChildren(writer, p.getValue());\n                writer.writeEndElement();\n            }\n        } else {\n            if (useValueAsElementName()){\n                writer.writeStartElement(getPathElement().getValue());\n            }else{\n                writer.writeStartElement(getXmlElementName());\n            }\n            for (AttributeDefinition def : getAttributes()) {\n                def.getAttributeMarshaller().marshallAsAttribute(def, model, false, writer);\n            }\n            persistChildren(writer, model);\n            writer.writeEndElement();\n        }\n\n        if (writeWrapper) {\n            writer.writeEndElement();\n        }\n    }","id":32715,"modified_method":"@Override\n    public void persist(XMLExtendedStreamWriter writer, ModelNode model) throws XMLStreamException {\n        persist(writer, model, null);\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Map<String, PersistentResourceDefinition> getChildrenMap() {\n        Map<String, PersistentResourceDefinition> res = new HashMap<>();\n        for (PersistentResourceDefinition child : getChildren()) {\n            res.put(child.getXmlElementName(), child);\n        }\n        return res;\n    }","id":32716,"modified_method":"private Map<String, PersistentResourceDefinition> getChildrenMap() {\n        Map<String, PersistentResourceDefinition> res = new HashMap<>();\n        for (PersistentResourceDefinition child : getChildren()) {\n            if (child.getXmlWrapperElement() != null) {\n                res.put(child.getXmlWrapperElement(), child);\n            } else {\n                res.put(child.getXmlElementName(), child);\n            }\n        }\n        return res;\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void parse(final XMLExtendedStreamReader reader, PathAddress parentAddress, List<ModelNode> list) throws XMLStreamException {\n        if (getXmlWrapperElement() != null) {\n            if (reader.getLocalName().equals(getXmlWrapperElement())) {\n                if (reader.hasNext()) {\n                    if (reader.nextTag() == END_ELEMENT) {\n                        return;\n                    }\n                }\n            } else {\n                throw ParseUtils.unexpectedElement(reader);\n            }\n\n        }\n        boolean wildcard = getPathElement().isWildcard();\n        String name = null;\n        ModelNode op = Util.createAddOperation();\n        Map<String, AttributeDefinition> attributes = getAttributeMap();\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String attributeName = reader.getAttributeLocalName(i);\n            String value = reader.getAttributeValue(i);\n            if (wildcard && NAME.equals(attributeName)) {\n                name = value;\n            } else if (attributes.containsKey(attributeName)) {\n                AttributeDefinition def = attributes.get(attributeName);\n                if (def instanceof SimpleAttributeDefinition) {\n                    ((SimpleAttributeDefinition) def).parseAndSetParameter(value, op, reader);\n                } else {\n                    throw new IllegalArgumentException(\"we should know how to handle \" + def);\n                }\n            } else {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            }\n        }\n        if (wildcard && name == null) {\n            throw MESSAGES.missingRequiredAttributes(new StringBuilder(NAME), reader.getLocation());\n        }\n        PathElement path = wildcard ? PathElement.pathElement(getPathElement().getKey(), name) : getPathElement();\n        PathAddress address = parentAddress.append(path);\n        op.get(ADDRESS).set(address.toModelNode());\n        list.add(op);\n        parseChildren(reader, address, list);\n        if (getXmlWrapperElement() != null) {\n            ParseUtils.requireNoContent(reader);\n        }\n    }","id":32717,"modified_method":"@Override\n    public void parse(final XMLExtendedStreamReader reader, PathAddress parentAddress, List<ModelNode> list) throws XMLStreamException {\n        if (getXmlWrapperElement() != null) {\n            if (reader.getLocalName().equals(getXmlWrapperElement())) {\n                if (reader.hasNext()) {\n                    if (reader.nextTag() == END_ELEMENT) {\n                        return;\n                    }\n                }\n            } else {\n                throw ParseUtils.unexpectedElement(reader);\n            }\n\n        }\n        boolean wildcard = getPathElement().isWildcard();\n        String name = null;\n        ModelNode op = Util.createAddOperation();\n        Map<String, AttributeDefinition> attributes = getAttributeMap();\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String attributeName = reader.getAttributeLocalName(i);\n            String value = reader.getAttributeValue(i);\n            if (wildcard && NAME.equals(attributeName)) {\n                name = value;\n            } else if (attributes.containsKey(attributeName)) {\n                AttributeDefinition def = attributes.get(attributeName);\n                if (def instanceof SimpleAttributeDefinition) {\n                    ((SimpleAttributeDefinition) def).parseAndSetParameter(value, op, reader);\n                } else if (def instanceof StringListAttributeDefinition) {\n                    ((StringListAttributeDefinition) def).parseAndSetParameter(value, op, reader);\n                }else{\n                    throw new IllegalArgumentException(\"we should know how to handle \" + def);\n                }\n            } else {\n                throw ParseUtils.unexpectedAttribute(reader, i);\n            }\n        }\n        if (wildcard && name == null) {\n            throw MESSAGES.missingRequiredAttributes(new StringBuilder(NAME), reader.getLocation());\n        }\n        PathElement path = wildcard ? PathElement.pathElement(getPathElement().getKey(), name) : getPathElement();\n        PathAddress address = parentAddress.append(path);\n        op.get(ADDRESS).set(address.toModelNode());\n        list.add(op);\n        parseChildren(reader, address, list);\n        if (getXmlWrapperElement() != null) {\n            ParseUtils.requireNoContent(reader);\n        }\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0, 0);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(UndertowRootDefinition.INSTANCE);\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE, false);\n        registration.registerSubModel(ServerDefinition.INSTANCE);\n        registration.registerSubModel(ServletContainerDefinition.INSTANCE);\n        registration.registerSubModel(BufferCacheDefinition.INSTANCE);\n\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(DeploymentDefinition.INSTANCE);\n        deployments.registerSubModel(DeploymentServletDefinition.INSTANCE);\n\n\n        subsystem.registerXMLElementWriter(UndertowSubsystemParser.INSTANCE);\n    }","id":32718,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0, 0);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(UndertowRootDefinition.INSTANCE);\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE, false);\n     /*   registration.registerSubModel(BufferCacheDefinition.INSTANCE);\n        registration.registerSubModel(ServerDefinition.INSTANCE);\n        registration.registerSubModel(ServletContainerDefinition.INSTANCE);\n        registration.registerSubModel(ErrorHandlerDefinition.INSTANCE);*/\n\n\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(DeploymentDefinition.INSTANCE);\n        deployments.registerSubModel(DeploymentServletDefinition.INSTANCE);\n\n        subsystem.registerXMLElementWriter(UndertowSubsystemParser.INSTANCE);\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        PathAddress address = PathAddress.pathAddress(UndertowExtension.SUBSYSTEM_PATH);\n        final ModelNode subsystem = Util.createAddOperation(address);\n        list.add(subsystem);\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            switch (reader.getAttributeLocalName(i)) {\n                case Constants.DEFAULT_SERVER:\n                    UndertowRootDefinition.DEFAULT_SERVER.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case Constants.DEFAULT_SERVLET_CONTAINER:\n                    UndertowRootDefinition.DEFAULT_SERVLET_CONTAINER.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case Constants.DEFAULT_VIRTUAL_HOST:\n                    UndertowRootDefinition.DEFAULT_VIRTUAL_HOST.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                case Constants.INSTANCE_ID:\n                    UndertowRootDefinition.INSTANCE_ID.parseAndSetParameter(value, subsystem, reader);\n                    break;\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        final Namespace namespace = Namespace.forUri(reader.getNamespaceURI());\n        // elements\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (namespace) {\n                case UNDERTOW_1_0: {\n                    switch (reader.getLocalName()) {\n                        case Constants.SERVER: {\n                            ServerDefinition.INSTANCE.parse(reader, address, list);\n                            break;\n                        }\n                        case Constants.SERVLET_CONTAINER: {\n                            ServletContainerDefinition.INSTANCE.parse(reader, address, list);\n                            break;\n                        }\n                        case Constants.BUFFER_CACHES:\n                            parseBufferCaches(reader, address, list);\n                            break;\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        ParseUtils.requireNoContent(reader);\n\n    }","id":32719,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        UndertowRootDefinition.INSTANCE.parse(reader, PathAddress.EMPTY_ADDRESS, list);\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n        ModelNode model = context.getModelNode();\n        UndertowRootDefinition.DEFAULT_SERVER.marshallAsAttribute(model, writer);\n        UndertowRootDefinition.DEFAULT_VIRTUAL_HOST.marshallAsAttribute(model, writer);\n        UndertowRootDefinition.DEFAULT_SERVLET_CONTAINER.marshallAsAttribute(model, writer);\n        UndertowRootDefinition.INSTANCE_ID.marshallAsAttribute(model, writer);\n        if (model.hasDefined(Constants.BUFFER_CACHE)) {\n            writer.writeStartElement(Constants.BUFFER_CACHES);\n            BufferCacheDefinition.INSTANCE.persist(writer, model);\n            writer.writeEndElement();\n        }\n        ServerDefinition.INSTANCE.persist(writer, model);\n        ServletContainerDefinition.INSTANCE.persist(writer, model);\n        writer.writeEndElement();\n    }","id":32720,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        ModelNode model = new ModelNode();\n        model.get(UndertowRootDefinition.INSTANCE.getPathElement().getKeyValuePair()).set(context.getModelNode());//this is bit of workaround for SPRD to work properly\n        UndertowRootDefinition.INSTANCE.persist(writer, model, Namespace.CURRENT.getUriString());\n    }","commit_id":"456ce0c7db24bcff814ca6e77372c28ba7b9abbe","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n   * Helper to handle arguments based on existing input values\n   * @param arg\n   * @param inputArgs\n   */\n  @Override protected void queryArgumentValueSet(Argument arg, java.util.Properties inputArgs) {\n    super.queryArgumentValueSet(arg, inputArgs);\n    // these parameters can be changed when re-starting from a checkpointed model\n    if (!arg._name.equals(\"checkpoint\")\n            //trivial parameters that only affect the scoring or the printout\n            && !arg._name.equals(\"epochs\")\n            && !arg._name.equals(\"expert_mode\")\n            && !arg._name.equals(\"seed\")\n            && !arg._name.equals(\"score_interval\")\n            && !arg._name.equals(\"score_duty_cycle\")\n            && !arg._name.equals(\"quiet_mode\")\n            && !arg._name.equals(\"diagnostics\")\n            //non-trivial parameters that can affect training accuracy\n            && !arg._name.equals(\"mini_batch\")\n            && !arg._name.equals(\"single_node\")\n            ) {\n      if (checkpoint != null) {\n        arg.disable(\"Taken from model checkpoint.\");\n        final DeepLearningModel cp_model = UKV.get(checkpoint);\n        if (cp_model == null) {\n          throw new IllegalArgumentException(\"Checkpointed model was not found.\");\n        }\n        if (cp_model.model_info().unstable()) {\n          throw new IllegalArgumentException(\"Checkpointed model was unstable. Not restarting.\");\n        }\n        final DeepLearning cp = cp_model.model_info().get_params();\n        // the following parameters are needed in the DeepLearning class for training\n        balance_classes = cp.balance_classes;\n        score_validation_sampling = cp.score_validation_sampling;\n        max_after_balance_size = cp.max_after_balance_size;\n        score_training_samples = cp.score_training_samples;\n        score_validation_samples = cp.score_validation_samples;\n        force_load_balance = cp.force_load_balance;\n        replicate_training_data = cp.replicate_training_data;\n        shuffle_training_data = cp.shuffle_training_data;\n        classification = cp.classification;\n        state = JobState.RUNNING;\n        return;\n      }\n    }\n    if(arg._name.equals(\"initial_weight_scale\") &&\n            (initial_weight_distribution == InitialWeightDistribution.UniformAdaptive)\n            ) {\n      arg.disable(\"Using sqrt(6 / (# units + # units of previous layer)) for Uniform distribution.\", inputArgs);\n    }\n    if(arg._name.equals(\"loss\") && !classification) {\n      arg.disable(\"Using MeanSquare loss for regression.\", inputArgs);\n      loss = Loss.MeanSquare;\n    }\n    if (classification) {\n      if(arg._name.equals(\"regression_stop\")) {\n        arg.disable(\"Only for regression.\", inputArgs);\n      }\n      if(arg._name.equals(\"max_after_balance_size\") && !balance_classes) {\n        arg.disable(\"Requires balance_classes.\", inputArgs);\n      }\n    }\n    else {\n      if(arg._name.equals(\"classification_stop\")\n              || arg._name.equals(\"max_confusion_matrix_size\")\n              || arg._name.equals(\"max_hit_ratio_k\")\n              || arg._name.equals(\"max_after_balance_size\")\n              || arg._name.equals(\"balance_classes\")) {\n        arg.disable(\"Only for classification.\", inputArgs);\n      }\n      if (validation != null && arg._name.equals(\"score_validation_sampling\")) {\n        score_validation_sampling = ClassSamplingMethod.Uniform;\n        arg.disable(\"Using uniform sampling for validation scoring dataset.\", inputArgs);\n      }\n    }\n    if ((arg._name.equals(\"score_validation_samples\") || arg._name.equals(\"score_validation_sampling\")) && validation == null) {\n      arg.disable(\"Requires a validation data set.\", inputArgs);\n    }\n    if (arg._name.equals(\"loss\")\n            || arg._name.equals(\"max_w2\")\n            || arg._name.equals(\"warmup_samples\")\n            || arg._name.equals(\"score_training_samples\")\n            || arg._name.equals(\"score_validation_samples\")\n            || arg._name.equals(\"initial_weight_distribution\")\n            || arg._name.equals(\"initial_weight_scale\")\n            || arg._name.equals(\"diagnostics\")\n            || arg._name.equals(\"rate_decay\")\n            || arg._name.equals(\"score_duty_cycle\")\n            || arg._name.equals(\"fast_mode\")\n            || arg._name.equals(\"score_validation_sampling\")\n            || arg._name.equals(\"max_after_balance_size\")\n            || arg._name.equals(\"ignore_const_cols\")\n            || arg._name.equals(\"force_load_balance\")\n            || arg._name.equals(\"replicate_training_data\")\n            || arg._name.equals(\"shuffle_training_data\")\n            || arg._name.equals(\"nesterov_accelerated_gradient\")\n            || arg._name.equals(\"classification_stop\")\n            || arg._name.equals(\"regression_stop\")\n            || arg._name.equals(\"quiet_mode\")\n            || arg._name.equals(\"max_confusion_matrix_size\")\n            || arg._name.equals(\"max_hit_ratio_k\")\n            || arg._name.equals(\"hidden_dropout_ratios\")\n            || arg._name.equals(\"single_node\")\n            ) {\n      if (!expert_mode) arg.disable(\"Only in expert mode.\", inputArgs);\n    }\n    if (!adaptive_rate) {\n      if (arg._name.equals(\"rho\") || arg._name.equals(\"epsilon\")) {\n        arg.disable(\"Only for adaptive learning rate.\", inputArgs);\n        rho = 0;\n        epsilon = 0;\n      }\n    } else {\n      if (arg._name.equals(\"rate\") || arg._name.equals(\"rate_annealing\") || arg._name.equals(\"rate_decay\") || arg._name.equals(\"nesterov_accelerated_gradient\")\n              || arg._name.equals(\"momentum_start\") || arg._name.equals(\"momentum_ramp\") || arg._name.equals(\"momentum_stable\") ) {\n        arg.disable(\"Only for non-adaptive learning rate.\", inputArgs);\n        momentum_start = 0;\n        momentum_stable = 0;\n      }\n    }\n    if (arg._name.equals(\"hidden_dropout_ratios\")) {\n      if (activation != Activation.TanhWithDropout && activation != Activation.MaxoutWithDropout && activation != Activation.RectifierWithDropout) {\n        arg.disable(\"Only for activation functions with dropout.\", inputArgs);\n      }\n    }\n    if (arg._name.equals(\"single_node\") && H2O.CLOUD.size() == 1) {\n      arg.disable(\"Only for multi-node operation.\");\n    }\n  }","id":32721,"modified_method":"/**\n   * Helper to handle arguments based on existing input values\n   * @param arg\n   * @param inputArgs\n   */\n  @Override protected void queryArgumentValueSet(Argument arg, java.util.Properties inputArgs) {\n    super.queryArgumentValueSet(arg, inputArgs);\n    // these parameters can be changed when re-starting from a checkpointed model\n    if (!arg._name.equals(\"checkpoint\")\n            //trivial parameters that only affect the scoring or the printout\n            && !arg._name.equals(\"epochs\")\n            && !arg._name.equals(\"expert_mode\")\n            && !arg._name.equals(\"seed\")\n            && !arg._name.equals(\"score_interval\")\n            && !arg._name.equals(\"score_duty_cycle\")\n            && !arg._name.equals(\"quiet_mode\")\n            && !arg._name.equals(\"diagnostics\")\n            //non-trivial parameters that can affect training accuracy\n            && !arg._name.equals(\"mini_batch\")\n            && !arg._name.equals(\"single_node_mode\")\n            && !arg._name.equals(\"replicate_training_data\")\n            ) {\n      if (checkpoint != null) {\n        arg.disable(\"Taken from model checkpoint.\");\n        final DeepLearningModel cp_model = UKV.get(checkpoint);\n        if (cp_model == null) {\n          throw new IllegalArgumentException(\"Checkpointed model was not found.\");\n        }\n        if (cp_model.model_info().unstable()) {\n          throw new IllegalArgumentException(\"Checkpointed model was unstable. Not restarting.\");\n        }\n        final DeepLearning cp = cp_model.model_info().get_params();\n        // the following parameters are needed in the DeepLearning class for training\n        balance_classes = cp.balance_classes;\n        score_validation_sampling = cp.score_validation_sampling;\n        max_after_balance_size = cp.max_after_balance_size;\n        score_training_samples = cp.score_training_samples;\n        score_validation_samples = cp.score_validation_samples;\n        force_load_balance = cp.force_load_balance;\n        shuffle_training_data = cp.shuffle_training_data;\n        classification = cp.classification;\n        state = JobState.RUNNING;\n        return;\n      }\n    }\n    if(arg._name.equals(\"initial_weight_scale\") &&\n            (initial_weight_distribution == InitialWeightDistribution.UniformAdaptive)\n            ) {\n      arg.disable(\"Using sqrt(6 / (# units + # units of previous layer)) for Uniform distribution.\", inputArgs);\n    }\n    if(arg._name.equals(\"loss\") && !classification) {\n      arg.disable(\"Using MeanSquare loss for regression.\", inputArgs);\n      loss = Loss.MeanSquare;\n    }\n    if (classification) {\n      if(arg._name.equals(\"regression_stop\")) {\n        arg.disable(\"Only for regression.\", inputArgs);\n      }\n      if(arg._name.equals(\"max_after_balance_size\") && !balance_classes) {\n        arg.disable(\"Requires balance_classes.\", inputArgs);\n      }\n    }\n    else {\n      if(arg._name.equals(\"classification_stop\")\n              || arg._name.equals(\"max_confusion_matrix_size\")\n              || arg._name.equals(\"max_hit_ratio_k\")\n              || arg._name.equals(\"max_after_balance_size\")\n              || arg._name.equals(\"balance_classes\")) {\n        arg.disable(\"Only for classification.\", inputArgs);\n      }\n      if (validation != null && arg._name.equals(\"score_validation_sampling\")) {\n        score_validation_sampling = ClassSamplingMethod.Uniform;\n        arg.disable(\"Using uniform sampling for validation scoring dataset.\", inputArgs);\n      }\n    }\n    if ((arg._name.equals(\"score_validation_samples\") || arg._name.equals(\"score_validation_sampling\")) && validation == null) {\n      arg.disable(\"Requires a validation data set.\", inputArgs);\n    }\n    if (arg._name.equals(\"loss\")\n            || arg._name.equals(\"max_w2\")\n            || arg._name.equals(\"warmup_samples\")\n            || arg._name.equals(\"score_training_samples\")\n            || arg._name.equals(\"score_validation_samples\")\n            || arg._name.equals(\"initial_weight_distribution\")\n            || arg._name.equals(\"initial_weight_scale\")\n            || arg._name.equals(\"diagnostics\")\n            || arg._name.equals(\"rate_decay\")\n            || arg._name.equals(\"score_duty_cycle\")\n            || arg._name.equals(\"fast_mode\")\n            || arg._name.equals(\"score_validation_sampling\")\n            || arg._name.equals(\"max_after_balance_size\")\n            || arg._name.equals(\"ignore_const_cols\")\n            || arg._name.equals(\"force_load_balance\")\n            || arg._name.equals(\"replicate_training_data\")\n            || arg._name.equals(\"shuffle_training_data\")\n            || arg._name.equals(\"nesterov_accelerated_gradient\")\n            || arg._name.equals(\"classification_stop\")\n            || arg._name.equals(\"regression_stop\")\n            || arg._name.equals(\"quiet_mode\")\n            || arg._name.equals(\"max_confusion_matrix_size\")\n            || arg._name.equals(\"max_hit_ratio_k\")\n            || arg._name.equals(\"hidden_dropout_ratios\")\n            || arg._name.equals(\"single_node_mode\")\n            ) {\n      if (!expert_mode) arg.disable(\"Only in expert mode.\", inputArgs);\n    }\n    if (!adaptive_rate) {\n      if (arg._name.equals(\"rho\") || arg._name.equals(\"epsilon\")) {\n        arg.disable(\"Only for adaptive learning rate.\", inputArgs);\n        rho = 0;\n        epsilon = 0;\n      }\n    } else {\n      if (arg._name.equals(\"rate\") || arg._name.equals(\"rate_annealing\") || arg._name.equals(\"rate_decay\") || arg._name.equals(\"nesterov_accelerated_gradient\")\n              || arg._name.equals(\"momentum_start\") || arg._name.equals(\"momentum_ramp\") || arg._name.equals(\"momentum_stable\") ) {\n        arg.disable(\"Only for non-adaptive learning rate.\", inputArgs);\n        momentum_start = 0;\n        momentum_stable = 0;\n      }\n    }\n    if (arg._name.equals(\"hidden_dropout_ratios\")) {\n      if (activation != Activation.TanhWithDropout && activation != Activation.MaxoutWithDropout && activation != Activation.RectifierWithDropout) {\n        arg.disable(\"Only for activation functions with dropout.\", inputArgs);\n      }\n    }\n    if (arg._name.equals(\"single_node_mode\") && (H2O.CLOUD.size() == 1 || !replicate_training_data)) {\n      arg.disable(\"Only for multi-node operation with replication.\");\n      single_node_mode = false;\n    }\n  }","commit_id":"c395461e58a645d80c849f33bc30ac80e5733621","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Train a Deep Learning model, assumes that all members are populated\n   * @return JobState\n   */\n  @Override public JobState execImpl() {\n    DeepLearningModel cp;\n    if (checkpoint == null) cp = initModel();\n    else {\n      final DeepLearningModel previous = UKV.get(checkpoint);\n      if (previous == null) throw new IllegalArgumentException(\"Checkpoint not found.\");\n      cp = new DeepLearningModel(previous, destination_key, job_key);\n      try {\n        cp.write_lock(self());\n        assert(state==JobState.RUNNING);\n        if (source == null || !Arrays.equals(source._key._kb, previous.model_info().get_params().source._key._kb)) {\n          throw new IllegalArgumentException(\"source must be the same as for the checkpointed model.\");\n        }\n        if (response == null || !Arrays.equals(response._key._kb, previous.model_info().get_params().response._key._kb)) {\n          throw new IllegalArgumentException(\"response must be the same as for the checkpointed model.\");\n        }\n        if (Utils.difference(ignored_cols, previous.model_info().get_params().ignored_cols).length != 0) {\n          throw new IllegalArgumentException(\"ignored_cols must be the same as for the checkpointed model.\");\n        }\n        if ((validation!=null) != (previous.model_info().get_params().validation != null)\n                || (validation != null && !Arrays.equals(validation._key._kb, previous.model_info().get_params().validation._key._kb))) {\n          throw new IllegalArgumentException(\"validation must be the same as for the checkpointed model.\");\n        }\n        if (classification != previous.model_info().get_params().classification) {\n          throw new IllegalArgumentException(\"classification must be the same as for the checkpointed model.\");\n        }\n        // the following parameters might have been modified when restarting from a checkpoint\n        // trivial parameters that only affect scoring or printout\n        cp.model_info().get_params().expert_mode = expert_mode;\n        cp.model_info().get_params().seed = seed;\n        cp.model_info().get_params().epochs = previous.epoch_counter + epochs; //add previously processed epochs to total epochs\n        cp.model_info().get_params().score_interval = score_interval;\n        cp.model_info().get_params().score_duty_cycle = score_duty_cycle;\n        cp.model_info().get_params().quiet_mode = quiet_mode;\n        cp.model_info().get_params().diagnostics = diagnostics;\n        // non-trivial parameters\n        cp.model_info().get_params().mini_batch = mini_batch;\n        cp.model_info().get_params().single_node = single_node;\n        cp.update(self());\n      } finally {\n        cp.unlock(self());\n      }\n    }\n    trainModel(cp);\n    delete();\n    return JobState.DONE;\n  }","id":32722,"modified_method":"/**\n   * Train a Deep Learning model, assumes that all members are populated\n   * @return JobState\n   */\n  @Override public JobState execImpl() {\n    DeepLearningModel cp;\n    if (checkpoint == null) cp = initModel();\n    else {\n      final DeepLearningModel previous = UKV.get(checkpoint);\n      if (previous == null) throw new IllegalArgumentException(\"Checkpoint not found.\");\n      cp = new DeepLearningModel(previous, destination_key, job_key);\n      try {\n        cp.write_lock(self());\n        assert(state==JobState.RUNNING);\n        if (source == null || !Arrays.equals(source._key._kb, previous.model_info().get_params().source._key._kb)) {\n          throw new IllegalArgumentException(\"source must be the same as for the checkpointed model.\");\n        }\n        if (response == null || !Arrays.equals(response._key._kb, previous.model_info().get_params().response._key._kb)) {\n          throw new IllegalArgumentException(\"response must be the same as for the checkpointed model.\");\n        }\n        if (Utils.difference(ignored_cols, previous.model_info().get_params().ignored_cols).length != 0) {\n          throw new IllegalArgumentException(\"ignored_cols must be the same as for the checkpointed model.\");\n        }\n        if ((validation!=null) != (previous.model_info().get_params().validation != null)\n                || (validation != null && !Arrays.equals(validation._key._kb, previous.model_info().get_params().validation._key._kb))) {\n          throw new IllegalArgumentException(\"validation must be the same as for the checkpointed model.\");\n        }\n        if (classification != previous.model_info().get_params().classification) {\n          throw new IllegalArgumentException(\"classification must be the same as for the checkpointed model.\");\n        }\n        // the following parameters might have been modified when restarting from a checkpoint\n        // trivial parameters that only affect scoring or printout\n        cp.model_info().get_params().expert_mode = expert_mode;\n        cp.model_info().get_params().seed = seed;\n        cp.model_info().get_params().epochs = previous.epoch_counter + epochs; //add previously processed epochs to total epochs\n        cp.model_info().get_params().score_interval = score_interval;\n        cp.model_info().get_params().score_duty_cycle = score_duty_cycle;\n        cp.model_info().get_params().quiet_mode = quiet_mode;\n        cp.model_info().get_params().diagnostics = diagnostics;\n        // non-trivial parameters\n        cp.model_info().get_params().mini_batch = mini_batch;\n        cp.model_info().get_params().single_node_mode = single_node_mode;\n        cp.model_info().get_params().replicate_training_data = replicate_training_data;\n        cp.update(self());\n      } finally {\n        cp.unlock(self());\n      }\n    }\n    trainModel(cp);\n    delete();\n    return JobState.DONE;\n  }","commit_id":"c395461e58a645d80c849f33bc30ac80e5733621","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Helper to specify which arguments trigger a refresh on change\n   * @param ver\n   */\n  @Override\n  protected void registered(RequestServer.API_VERSION ver) {\n    super.registered(ver);\n    for (Argument arg : _arguments) {\n      if ( arg._name.equals(\"activation\") || arg._name.equals(\"initial_weight_distribution\")\n              || arg._name.equals(\"expert_mode\") || arg._name.equals(\"adaptive_rate\")\n              || arg._name.equals(\"balance_classes\") || arg._name.equals(\"checkpoint\")) {\n        arg.setRefreshOnChange();\n      }\n    }\n  }","id":32723,"modified_method":"/**\n   * Helper to specify which arguments trigger a refresh on change\n   * @param ver\n   */\n  @Override\n  protected void registered(RequestServer.API_VERSION ver) {\n    super.registered(ver);\n    for (Argument arg : _arguments) {\n      if ( arg._name.equals(\"activation\") || arg._name.equals(\"initial_weight_distribution\")\n              || arg._name.equals(\"expert_mode\") || arg._name.equals(\"adaptive_rate\")\n              || arg._name.equals(\"replicate_training_data\")\n              || arg._name.equals(\"balance_classes\") || arg._name.equals(\"checkpoint\")) {\n        arg.setRefreshOnChange();\n      }\n    }\n  }","commit_id":"c395461e58a645d80c849f33bc30ac80e5733621","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Train a Deep Learning neural net model\n   * @param model Input model (e.g., from initModel(), or from a previous training run)\n   * @return Trained model\n   */\n  public final DeepLearningModel trainModel(DeepLearningModel model) {\n    Frame validScoreFrame = null;\n    Frame train, trainScoreFrame;\n    try {\n      lock_data();\n      if (checkpoint == null) logStart(); //if checkpoint is given, some Job's params might be uninitialized (but the restarted model's parameters are correct)\n      if (model == null) {\n        model = UKV.get(dest());\n      }\n      model.write_lock(self());\n      prepareValidationWithModel(model);\n      final long model_size = model.model_info().size();\n      Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n//      Log.info(\"Memory usage of the model: \" + String.format(\"%.2f\", (double)model_size*Float.SIZE / (1<<23)) + \" MB.\");\n      train = model.model_info().data_info()._adaptedFrame;\n      train = updateFrame(train, reBalance(train, seed, replicate_training_data /*rebalance into only 4*cores per node*/));\n      float[] trainSamplingFactors;\n      if (classification && balance_classes) {\n        trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n        train = updateFrame(train, sampleFrameStratified(\n                train, train.lastVec(), trainSamplingFactors, (long)(max_after_balance_size*train.numRows()), seed, true, false));\n        model.setModelClassDistribution(new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist());\n      }\n      model.training_rows = train.numRows();\n      trainScoreFrame = sampleFrame(train, score_training_samples, seed); //training scoring dataset is always sampled uniformly from the training dataset\n      if (train != trainScoreFrame) ltrash(trainScoreFrame);\n\n      Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n      if (validation != null) {\n        Frame adaptedValid = getValidation();\n        if (getValidAdaptor().needsAdaptation2CM()) {\n          adaptedValid.add(getValidAdaptor().adaptedValidationResponse(_responseName), getValidAdaptor().getAdaptedValidationResponse2CM());\n        }\n        // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n        if (classification && balance_classes && score_validation_sampling == ClassSamplingMethod.Stratified) {\n          validScoreFrame = updateFrame(adaptedValid, sampleFrameStratified(adaptedValid, adaptedValid.lastVec(), null,\n                  score_validation_samples > 0 ? score_validation_samples : adaptedValid.numRows(), seed+1, false /* no oversampling */, false));\n        } else {\n          validScoreFrame = updateFrame(adaptedValid, sampleFrame(adaptedValid, score_validation_samples, seed+1));\n        }\n        validScoreFrame = updateFrame(validScoreFrame, reBalance(validScoreFrame, seed+1, false /*always split up globally since scoring should be distributed*/));\n        Log.info(\"Number of chunks of the validation data: \" + validScoreFrame.anyVec().nChunks());\n      }\n      if ((mini_batch == -1 || mini_batch == 0 || mini_batch > train.numRows()) && !replicate_training_data) {\n        Log.warn(\"Setting mini_batch (\" + mini_batch\n                + \") to one epoch: #rows (\" + (mini_batch=train.numRows()) + \").\");\n      }\n      if ((mini_batch == -1 || mini_batch > H2O.CLOUD.size()*train.numRows()) && replicate_training_data) {\n        Log.warn(\"Setting mini_batch (\" + mini_batch\n                + \") to the largest possible number: #nodes x #rows (\" + (mini_batch=H2O.CLOUD.size()*train.numRows()) + \").\");\n      }\n      // mini_batch determines the number of rows processed during one iteration, affects synchronization period\n      final float sync_fraction = mini_batch == 0l ? 1.0f : (float)mini_batch / train.numRows();\n\n      if (!quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n\n      Log.info(\"Starting to train the Deep Learning model.\");\n\n      //main loop\n      do model.set_model_info(H2O.CLOUD.size() > 1 && replicate_training_data ?\n              (single_node ? new DeepLearningTask2(train, model.model_info(), sync_fraction).invoke(Key.make()).model_info() : //each node processes all chunks\n                      new DeepLearningTask2(train, model.model_info(), sync_fraction/H2O.CLOUD.size()).invokeOnAllNodes().model_info() //each node processes all chunks\n              ) : new DeepLearningTask(model.model_info(), sync_fraction).doAll(train).model_info()); //each node processes local chunks only\n      while (model.doScoring(train, trainScoreFrame, validScoreFrame, self(), getValidAdaptor()));\n\n      Log.info(\"Finished training the Deep Learning model.\");\n      return model;\n    }\n    catch(JobCancelledException ex) {\n      Log.info(\"Deep Learning model building was cancelled.\");\n      model = UKV.get(dest());\n      return model;\n    }\n    catch(Exception ex) {\n      ex.printStackTrace();\n      throw new RuntimeException(ex);\n    }\n    finally {\n      if (model != null) model.unlock(self());\n      unlock_data();\n      emptyLTrash();\n    }\n  }","id":32724,"modified_method":"/**\n   * Train a Deep Learning neural net model\n   * @param model Input model (e.g., from initModel(), or from a previous training run)\n   * @return Trained model\n   */\n  public final DeepLearningModel trainModel(DeepLearningModel model) {\n    Frame validScoreFrame = null;\n    Frame train, trainScoreFrame;\n    try {\n      lock_data();\n      if (checkpoint == null) logStart(); //if checkpoint is given, some Job's params might be uninitialized (but the restarted model's parameters are correct)\n      if (model == null) {\n        model = UKV.get(dest());\n      }\n      model.write_lock(self());\n      prepareValidationWithModel(model);\n      final long model_size = model.model_info().size();\n      Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n//      Log.info(\"Memory usage of the model: \" + String.format(\"%.2f\", (double)model_size*Float.SIZE / (1<<23)) + \" MB.\");\n      train = model.model_info().data_info()._adaptedFrame;\n      train = updateFrame(train, reBalance(train, seed, replicate_training_data /*rebalance into only 4*cores per node*/));\n      float[] trainSamplingFactors;\n      if (classification && balance_classes) {\n        trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n        train = updateFrame(train, sampleFrameStratified(\n                train, train.lastVec(), trainSamplingFactors, (long)(max_after_balance_size*train.numRows()), seed, true, false));\n        model.setModelClassDistribution(new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist());\n      }\n      model.training_rows = train.numRows();\n      trainScoreFrame = sampleFrame(train, score_training_samples, seed); //training scoring dataset is always sampled uniformly from the training dataset\n      if (train != trainScoreFrame) ltrash(trainScoreFrame);\n\n      Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n      if (validation != null) {\n        Frame adaptedValid = getValidation();\n        if (getValidAdaptor().needsAdaptation2CM()) {\n          adaptedValid.add(getValidAdaptor().adaptedValidationResponse(_responseName), getValidAdaptor().getAdaptedValidationResponse2CM());\n        }\n        // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n        if (classification && balance_classes && score_validation_sampling == ClassSamplingMethod.Stratified) {\n          validScoreFrame = updateFrame(adaptedValid, sampleFrameStratified(adaptedValid, adaptedValid.lastVec(), null,\n                  score_validation_samples > 0 ? score_validation_samples : adaptedValid.numRows(), seed+1, false /* no oversampling */, false));\n        } else {\n          validScoreFrame = updateFrame(adaptedValid, sampleFrame(adaptedValid, score_validation_samples, seed+1));\n        }\n        validScoreFrame = updateFrame(validScoreFrame, reBalance(validScoreFrame, seed+1, false /*always split up globally since scoring should be distributed*/));\n        Log.info(\"Number of chunks of the validation data: \" + validScoreFrame.anyVec().nChunks());\n      }\n\n      // Set mini_batch size (cannot be done earlier since this depends on whether stratified sampling is done)\n      model.model_info().get_params().mini_batch = computeMiniBatchSize(mini_batch, train.numRows(), replicate_training_data);\n      final float rowUsageFraction = computeRowUsageFraction(train.numRows(), model.model_info().get_params().mini_batch, replicate_training_data, single_node_mode);\n\n      if (!quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n      Log.info(\"Starting to train the Deep Learning model.\");\n\n      //main loop\n      do model.set_model_info(H2O.CLOUD.size() > 1 && replicate_training_data ? ( single_node_mode ?\n              new DeepLearningTask2(train, model.model_info(), rowUsageFraction).invoke(Key.make()).model_info() : //replicated data + single node mode\n              new DeepLearningTask2(train, model.model_info(), rowUsageFraction).invokeOnAllNodes().model_info() ) : //replicated data + multi-node mode\n              new DeepLearningTask(model.model_info(), rowUsageFraction).doAll(train).model_info()); //distributed data (always in multi-node mode)\n      while (model.doScoring(train, trainScoreFrame, validScoreFrame, self(), getValidAdaptor()));\n\n      Log.info(\"Finished training the Deep Learning model.\");\n      return model;\n    }\n    catch(JobCancelledException ex) {\n      Log.info(\"Deep Learning model building was cancelled.\");\n      model = UKV.get(dest());\n      return model;\n    }\n    catch(Exception ex) {\n      ex.printStackTrace();\n      throw new RuntimeException(ex);\n    }\n    finally {\n      if (model != null) model.unlock(self());\n      unlock_data();\n      emptyLTrash();\n    }\n  }","commit_id":"c395461e58a645d80c849f33bc30ac80e5733621","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public boolean generateHTML(String title, StringBuilder sb) {\n    if (_key == null) {\n      DocGen.HTML.title(sb, \"No model yet\");\n      return true;\n    }\n\n    final String mse_format = \"%g\";\n//    final String cross_entropy_format = \"%2.6f\";\n\n    // stats for training and validation\n    final Errors error = last_scored();\n\n    DocGen.HTML.title(sb, title);\n\n    model_info.job().toHTML(sb);\n    Inspect2 is2 = new Inspect2();\n    final Key val_key = model_info().parameters.validation != null ? model_info().parameters.validation._key : null;\n    sb.append(\"<div class='alert'>Actions: \"\n            + (Job.isRunning(jobKey) ? \"<i class=\\\"icon-stop\\\"><\/i>\" + Cancel.link(jobKey, \"Stop training\") + \", \" : \"\")\n            + is2.link(\"Inspect training data (\" + _dataKey + \")\", _dataKey) + \", \"\n            + (val_key != null ? (is2.link(\"Inspect validation data (\" + val_key + \")\", val_key) + \", \") : \"\")\n            + water.api.Predict.link(_key, \"Score on dataset\") + \", \"\n            + DeepLearning.link(_dataKey, \"Compute new model\", null, responseName(), val_key) + \", \"\n            + (Job.isEnded(jobKey) ? \"<i class=\\\"icon-play\\\"><\/i>\" + DeepLearning.link(_dataKey, \"Continue training this model\", _key, responseName(), val_key) : \"\")\n            + \"<\/div>\");\n\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n    DocGen.HTML.paragraph(sb, \"Job Key: \" + jobKey);\n    DocGen.HTML.paragraph(sb, \"Model type: \" + (model_info().parameters.classification ? \" Classification\" : \" Regression\") + \", predicting: \" + responseName());\n    DocGen.HTML.paragraph(sb, \"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_info().size()));\n\n    if (model_info.unstable()) {\n      final String msg = \"Job was aborted due to observed numerical instability (exponential growth).\"\n              + \" Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\";\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n      DocGen.HTML.section(sb, msg);\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n    }\n\n    DocGen.HTML.title(sb, \"Progress\");\n    // update epoch counter every time the website is displayed\n    epoch_counter = training_rows > 0 ? (float)model_info().get_processed_total()/training_rows : 0;\n    final double progress = model_info.get_params().progress();\n\n    if (model_info.parameters != null && model_info.parameters.diagnostics) {\n      DocGen.HTML.section(sb, \"Status of Neuron Layers\");\n      sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(\"#\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Units\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Type\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Dropout\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L1\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L2\").append(\"<\/th>\");\n      if (model_info.get_params().adaptive_rate) {\n        sb.append(\"<th>\").append(\"Rate (Mean, RMS)\").append(\"<\/th>\");\n      } else {\n        sb.append(\"<th>\").append(\"Rate\").append(\"<\/th>\");\n        sb.append(\"<th>\").append(\"Momentum\").append(\"<\/th>\");\n      }\n      sb.append(\"<th>\").append(\"Weight (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Bias (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<\/tr>\");\n      Neurons[] neurons = DeepLearningTask.makeNeuronsForTesting(model_info()); //link the weights to the neurons, for easy access\n      for (int i=0; i<neurons.length; ++i) {\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\").append(\"<b>\").append(i+1).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(\"<b>\").append(neurons[i].units).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].getClass().getSimpleName()).append(\"<\/td>\");\n\n        if (i == 0) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.input_dropout_ratio));\n          sb.append(\"<\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          if (!model_info.get_params().adaptive_rate) sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<\/tr>\");\n          continue;\n        }\n        else if (i < neurons.length-1) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.hidden_dropout_ratios[i-1]));\n          sb.append(\"<\/td>\");\n        } else {\n          sb.append(\"<td><\/td>\");\n        }\n\n        final String format = \"%g\";\n        sb.append(\"<td>\").append(neurons[i].params.l1).append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].params.l2).append(\"<\/td>\");\n        if (model_info.get_params().adaptive_rate) {\n          sb.append(\"<td>(\").append(String.format(format, model_info.mean_rate[i])).\n                  append(\", \").append(String.format(format, model_info.rms_rate[i])).append(\")<\/td>\");\n        } else {\n          sb.append(\"<td>\").append(String.format(\"%.5g\", neurons[i].rate(error.training_samples))).append(\"<\/td>\");\n          sb.append(\"<td>\").append(String.format(\"%.5f\", neurons[i].momentum(error.training_samples))).append(\"<\/td>\");\n        }\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_weight[i])).\n                append(\", \").append(String.format(format, model_info.rms_weight[i])).append(\")<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_bias[i])).\n                append(\", \").append(String.format(format, model_info.rms_bias[i])).append(\")<\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }\n\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Classification error on training data: \" + formatPct(error.train_err));\n//      DocGen.HTML.section(sb, \"Training cross entropy: \" + String.format(cross_entropy_format, error.train_mce));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"Classification error on validation data: \" + formatPct(error.valid_err));\n//        DocGen.HTML.section(sb, \"Validation mean cross entropy: \" + String.format(cross_entropy_format, error.valid_mce));\n      }\n    } else {\n      DocGen.HTML.section(sb, \"MSE on training data: \" + String.format(mse_format, error.train_mse));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"MSE on validation data: \" + String.format(mse_format, error.valid_mse));\n      }\n    }\n    DocGen.HTML.paragraph(sb, \"Epochs: \" + String.format(\"%.3f\", epoch_counter) + \" / \" + String.format(\"%.3f\", model_info.parameters.epochs));\n    int cores = 0; for (H2ONode n : H2O.CLOUD._memary) cores += n._heartbeat._num_cpus;\n    DocGen.HTML.paragraph(sb, \"Number of compute nodes: \" + (model_info.get_params().single_node ? (\"1 (\" + H2O.NUMCPUS + \" threads)\") : (H2O.CLOUD.size() + \" (\" + cores + \" threads)\")));\n    final boolean isEnded = Job.isEnded(model_info().job().self());\n    final long time_so_far = isEnded ? run_time : run_time + System.currentTimeMillis() - _timeLastScoreEnter;\n    if (time_so_far > 0) {\n      DocGen.HTML.paragraph(sb, \"Training speed: \" + String.format(\"%,d\", model_info().get_processed_total() * 1000 / time_so_far) + \" samples/s\");\n    }\n    DocGen.HTML.paragraph(sb, \"Training time: \" + PrettyPrint.msecs(time_so_far, true));\n    if (progress > 0 && !isEnded)\n      DocGen.HTML.paragraph(sb, \"Estimated time left: \" +PrettyPrint.msecs((long)(time_so_far*(1-progress)/progress), true));\n\n    long score_train = error.score_training_samples;\n    long score_valid = error.score_validation_samples;\n    final boolean fulltrain = score_train==0 || score_train == model_info().data_info()._adaptedFrame.numRows();\n    final boolean fullvalid = score_valid==0 || score_valid == model_info().get_params().validation.numRows();\n\n    final String toolarge = \" Confusion matrix not shown here - too large: number of classes (\" + model_info.units[model_info.units.length-1]\n            + \") is greater than the specified limit of \" + model_info().get_params().max_confusion_matrix_size + \".\";\n    boolean smallenough = model_info.units[model_info.units.length-1] <= model_info().get_params().max_confusion_matrix_size;\n\n    if (isClassifier()) {\n      // print AUC\n      if (error.validAUC != null) {\n        error.validAUC.toHTML(sb);\n      }\n      else if (error.trainAUC != null) {\n        error.trainAUC.toHTML(sb);\n      }\n      else {\n        if (error.validation) {\n          RString v_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          v_rs.replace(\"key\", model_info().get_params().validation._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on validation data \" + v_rs.toString() + (fullvalid ? \"\" : \" (\" + score_valid + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.valid_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.valid_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        } else {\n          RString t_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          t_rs.replace(\"key\", model_info().get_params().source._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on training data \" + t_rs.toString() + (fulltrain ? \"\" : \" (\" + score_train + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.train_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.train_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        }\n      }\n    }\n\n    // Hit ratio\n    if (error.valid_hitratio != null) {\n      error.valid_hitratio.toHTML(sb);\n    } else if (error.train_hitratio != null) {\n      error.train_hitratio.toHTML(sb);\n    }\n\n    // Variable importance\n    if (model_info().get_params().variable_importances) {\n      final float [] varimp = model_info().computeVariableImportances();\n      new VarImp(varimp, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, varimp.length)).toHTML(sb);\n    }\n\n    DocGen.HTML.title(sb, \"Scoring history\");\n    if (errors.length > 1) {\n      DocGen.HTML.paragraph(sb, \"Time taken for last scoring: \" + PrettyPrint.msecs(errors[errors.length-1].scoring_time, true));\n      // training\n      {\n        final long pts = fulltrain ? model_info().data_info()._adaptedFrame.numRows() : score_train;\n        String training = \"Number of training data samples for scoring: \" + (fulltrain ? \"all \" : \"\") + pts;\n        if (pts < 1000 && model_info().data_info()._adaptedFrame.numRows() >= 1000) training += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (pts > 100000 && errors[errors.length-1].scoring_time > 10000) training += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, training);\n      }\n      // validation\n      if (error.validation) {\n        final long ptsv = fullvalid ? model_info().get_params().validation.numRows() : score_valid;\n        String validation = \"Number of validation data samples for scoring: \" + (fullvalid ? \"all \" : \"\") + ptsv;\n        if (ptsv < 1000 && model_info().get_params().validation.numRows() >= 1000) validation += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (ptsv > 100000 && errors[errors.length-1].scoring_time > 10000) validation += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, validation);\n      }\n\n      if (isClassifier() && nclasses() != 2 /*binary classifier has its own conflicting D3 object (AUC)*/) {\n        // Plot training error\n        float[] err = new float[errors.length];\n        float[] samples = new float[errors.length];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i].train_err;\n          samples[i] = errors[i].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"classification error\",\n                \"classification error on training data\").generate(sb);\n\n        // Plot validation error\n        if (model_info.parameters.validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i].valid_err;\n          }\n          new D3Plot(samples, err, \"training samples\", \"classification error\",\n                  \"classification error on validation set\").generate(sb);\n        }\n      }\n      // regression\n      else if (!isClassifier()) {\n        // Plot training MSE\n        float[] err = new float[errors.length-1];\n        float[] samples = new float[errors.length-1];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i+1].train_mse;\n          samples[i] = errors[i+1].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"MSE\",\n                \"regression error on training data\").generate(sb);\n\n        // Plot validation MSE\n        if (model_info.parameters.validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i+1].valid_mse;\n          }\n          new D3Plot(samples, err, \"training samples\", \"MSE\",\n                  \"regression error on validation data\").generate(sb);\n        }\n      }\n    }\n\n//    String training = \"Number of training set samples for scoring: \" + error.score_training;\n    if (error.validation) {\n//      String validation = \"Number of validation set samples for scoring: \" + error.score_validation;\n    }\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Training Time<\/th>\");\n    sb.append(\"<th>Training Epochs<\/th>\");\n    sb.append(\"<th>Training Samples<\/th>\");\n    if (isClassifier()) {\n//      sb.append(\"<th>Training MCE<\/th>\");\n      sb.append(\"<th>Training Error<\/th>\");\n      if (nclasses()==2) sb.append(\"<th>Training AUC<\/th>\");\n    } else {\n      sb.append(\"<th>Training MSE<\/th>\");\n    }\n    if (error.validation) {\n      if (isClassifier()) {\n//      sb.append(\"<th>Validation MCE<\/th>\");\n        sb.append(\"<th>Validation Error<\/th>\");\n        if (nclasses()==2) sb.append(\"<th>Validation AUC<\/th>\");\n      } else {\n        sb.append(\"<th>Validation MSE<\/th>\");\n      }\n    }\n    sb.append(\"<\/tr>\");\n    for( int i = errors.length - 1; i >= 0; i-- ) {\n      final Errors e = errors[i];\n      sb.append(\"<tr>\");\n      sb.append(\"<td>\" + PrettyPrint.msecs(e.training_time_ms, true) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%g\", e.epoch_counter) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%,d\", e.training_samples) + \"<\/td>\");\n      if (isClassifier()) {\n//        sb.append(\"<td>\" + String.format(cross_entropy_format, e.train_mce) + \"<\/td>\");\n        sb.append(\"<td>\" + formatPct(e.train_err) + \"<\/td>\");\n        if (nclasses()==2) {\n          if (e.trainAUC != null) sb.append(\"<td>\" + formatPct(e.trainAUC.AUC()) + \"<\/td>\");\n          else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n        }\n      } else {\n        sb.append(\"<td>\" + String.format(mse_format, e.train_mse) + \"<\/td>\");\n      }\n      if(e.validation) {\n        if (isClassifier()) {\n//          sb.append(\"<td>\" + String.format(cross_entropy_format, e.valid_mce) + \"<\/td>\");\n          sb.append(\"<td>\" + formatPct(e.valid_err) + \"<\/td>\");\n          if (nclasses()==2) {\n            if (e.validAUC != null) sb.append(\"<td>\" + formatPct(e.validAUC.AUC()) + \"<\/td>\");\n            else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n          }\n        } else {\n          sb.append(\"<td>\" + String.format(mse_format, e.valid_mse) + \"<\/td>\");\n        }\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table>\");\n    return true;\n  }","id":32725,"modified_method":"public boolean generateHTML(String title, StringBuilder sb) {\n    if (_key == null) {\n      DocGen.HTML.title(sb, \"No model yet\");\n      return true;\n    }\n\n    final String mse_format = \"%g\";\n//    final String cross_entropy_format = \"%2.6f\";\n\n    // stats for training and validation\n    final Errors error = last_scored();\n\n    DocGen.HTML.title(sb, title);\n\n    model_info.job().toHTML(sb);\n    Inspect2 is2 = new Inspect2();\n    final Key val_key = model_info().parameters.validation != null ? model_info().parameters.validation._key : null;\n    sb.append(\"<div class='alert'>Actions: \"\n            + (Job.isRunning(jobKey) ? \"<i class=\\\"icon-stop\\\"><\/i>\" + Cancel.link(jobKey, \"Stop training\") + \", \" : \"\")\n            + is2.link(\"Inspect training data (\" + _dataKey + \")\", _dataKey) + \", \"\n            + (val_key != null ? (is2.link(\"Inspect validation data (\" + val_key + \")\", val_key) + \", \") : \"\")\n            + water.api.Predict.link(_key, \"Score on dataset\") + \", \"\n            + DeepLearning.link(_dataKey, \"Compute new model\", null, responseName(), val_key) + \", \"\n            + (Job.isEnded(jobKey) ? \"<i class=\\\"icon-play\\\"><\/i>\" + DeepLearning.link(_dataKey, \"Continue training this model\", _key, responseName(), val_key) : \"\")\n            + \"<\/div>\");\n\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n    DocGen.HTML.paragraph(sb, \"Job Key: \" + jobKey);\n    DocGen.HTML.paragraph(sb, \"Model type: \" + (model_info().parameters.classification ? \" Classification\" : \" Regression\") + \", predicting: \" + responseName());\n    DocGen.HTML.paragraph(sb, \"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_info().size()));\n\n    if (model_info.unstable()) {\n      final String msg = \"Job was aborted due to observed numerical instability (exponential growth).\"\n              + \" Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\";\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n      DocGen.HTML.section(sb, msg);\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n    }\n\n    DocGen.HTML.title(sb, \"Progress\");\n    // update epoch counter every time the website is displayed\n    epoch_counter = training_rows > 0 ? (float)model_info().get_processed_total()/training_rows : 0;\n    final double progress = model_info.get_params().progress();\n\n    if (model_info.parameters != null && model_info.parameters.diagnostics) {\n      DocGen.HTML.section(sb, \"Status of Neuron Layers\");\n      sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(\"#\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Units\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Type\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Dropout\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L1\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L2\").append(\"<\/th>\");\n      if (model_info.get_params().adaptive_rate) {\n        sb.append(\"<th>\").append(\"Rate (Mean, RMS)\").append(\"<\/th>\");\n      } else {\n        sb.append(\"<th>\").append(\"Rate\").append(\"<\/th>\");\n        sb.append(\"<th>\").append(\"Momentum\").append(\"<\/th>\");\n      }\n      sb.append(\"<th>\").append(\"Weight (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Bias (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<\/tr>\");\n      Neurons[] neurons = DeepLearningTask.makeNeuronsForTesting(model_info()); //link the weights to the neurons, for easy access\n      for (int i=0; i<neurons.length; ++i) {\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\").append(\"<b>\").append(i+1).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(\"<b>\").append(neurons[i].units).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].getClass().getSimpleName()).append(\"<\/td>\");\n\n        if (i == 0) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.input_dropout_ratio));\n          sb.append(\"<\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          if (!model_info.get_params().adaptive_rate) sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<\/tr>\");\n          continue;\n        }\n        else if (i < neurons.length-1) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.hidden_dropout_ratios[i-1]));\n          sb.append(\"<\/td>\");\n        } else {\n          sb.append(\"<td><\/td>\");\n        }\n\n        final String format = \"%g\";\n        sb.append(\"<td>\").append(neurons[i].params.l1).append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].params.l2).append(\"<\/td>\");\n        if (model_info.get_params().adaptive_rate) {\n          sb.append(\"<td>(\").append(String.format(format, model_info.mean_rate[i])).\n                  append(\", \").append(String.format(format, model_info.rms_rate[i])).append(\")<\/td>\");\n        } else {\n          sb.append(\"<td>\").append(String.format(\"%.5g\", neurons[i].rate(error.training_samples))).append(\"<\/td>\");\n          sb.append(\"<td>\").append(String.format(\"%.5f\", neurons[i].momentum(error.training_samples))).append(\"<\/td>\");\n        }\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_weight[i])).\n                append(\", \").append(String.format(format, model_info.rms_weight[i])).append(\")<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_bias[i])).\n                append(\", \").append(String.format(format, model_info.rms_bias[i])).append(\")<\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }\n\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Classification error on training data: \" + formatPct(error.train_err));\n//      DocGen.HTML.section(sb, \"Training cross entropy: \" + String.format(cross_entropy_format, error.train_mce));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"Classification error on validation data: \" + formatPct(error.valid_err));\n//        DocGen.HTML.section(sb, \"Validation mean cross entropy: \" + String.format(cross_entropy_format, error.valid_mce));\n      }\n    } else {\n      DocGen.HTML.section(sb, \"MSE on training data: \" + String.format(mse_format, error.train_mse));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"MSE on validation data: \" + String.format(mse_format, error.valid_mse));\n      }\n    }\n    DocGen.HTML.paragraph(sb, \"Epochs: \" + String.format(\"%.3f\", epoch_counter) + \" / \" + String.format(\"%.3f\", model_info.parameters.epochs));\n    int cores = 0; for (H2ONode n : H2O.CLOUD._memary) cores += n._heartbeat._num_cpus;\n    DocGen.HTML.paragraph(sb, \"Number of compute nodes: \" + (model_info.get_params().single_node_mode ? (\"1 (\" + H2O.NUMCPUS + \" threads)\") : (H2O.CLOUD.size() + \" (\" + cores + \" threads)\")));\n    DocGen.HTML.paragraph(sb, \"Mini-batch size: \" + String.format(\"%,d\", model_info.parameters.mini_batch));\n    final boolean isEnded = Job.isEnded(model_info().job().self());\n    final long time_so_far = isEnded ? run_time : run_time + System.currentTimeMillis() - _timeLastScoreEnter;\n    if (time_so_far > 0) {\n      DocGen.HTML.paragraph(sb, \"Training speed: \" + String.format(\"%,d\", model_info().get_processed_total() * 1000 / time_so_far) + \" samples/s\");\n    }\n    DocGen.HTML.paragraph(sb, \"Training time: \" + PrettyPrint.msecs(time_so_far, true));\n    if (progress > 0 && !isEnded)\n      DocGen.HTML.paragraph(sb, \"Estimated time left: \" +PrettyPrint.msecs((long)(time_so_far*(1-progress)/progress), true));\n\n    long score_train = error.score_training_samples;\n    long score_valid = error.score_validation_samples;\n    final boolean fulltrain = score_train==0 || score_train == model_info().data_info()._adaptedFrame.numRows();\n    final boolean fullvalid = score_valid==0 || score_valid == model_info().get_params().validation.numRows();\n\n    final String toolarge = \" Confusion matrix not shown here - too large: number of classes (\" + model_info.units[model_info.units.length-1]\n            + \") is greater than the specified limit of \" + model_info().get_params().max_confusion_matrix_size + \".\";\n    boolean smallenough = model_info.units[model_info.units.length-1] <= model_info().get_params().max_confusion_matrix_size;\n\n    if (isClassifier()) {\n      // print AUC\n      if (error.validAUC != null) {\n        error.validAUC.toHTML(sb);\n      }\n      else if (error.trainAUC != null) {\n        error.trainAUC.toHTML(sb);\n      }\n      else {\n        if (error.validation) {\n          RString v_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          v_rs.replace(\"key\", model_info().get_params().validation._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on validation data \" + v_rs.toString() + (fullvalid ? \"\" : \" (\" + score_valid + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.valid_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.valid_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        } else {\n          RString t_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          t_rs.replace(\"key\", model_info().get_params().source._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on training data \" + t_rs.toString() + (fulltrain ? \"\" : \" (\" + score_train + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.train_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.train_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        }\n      }\n    }\n\n    // Hit ratio\n    if (error.valid_hitratio != null) {\n      error.valid_hitratio.toHTML(sb);\n    } else if (error.train_hitratio != null) {\n      error.train_hitratio.toHTML(sb);\n    }\n\n    // Variable importance\n    if (model_info().get_params().variable_importances) {\n      final float [] varimp = model_info().computeVariableImportances();\n      new VarImp(varimp, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, varimp.length)).toHTML(sb);\n    }\n\n    DocGen.HTML.title(sb, \"Scoring history\");\n    if (errors.length > 1) {\n      DocGen.HTML.paragraph(sb, \"Time taken for last scoring: \" + PrettyPrint.msecs(errors[errors.length-1].scoring_time, true));\n      // training\n      {\n        final long pts = fulltrain ? model_info().data_info()._adaptedFrame.numRows() : score_train;\n        String training = \"Number of training data samples for scoring: \" + (fulltrain ? \"all \" : \"\") + pts;\n        if (pts < 1000 && model_info().data_info()._adaptedFrame.numRows() >= 1000) training += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (pts > 100000 && errors[errors.length-1].scoring_time > 10000) training += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, training);\n      }\n      // validation\n      if (error.validation) {\n        final long ptsv = fullvalid ? model_info().get_params().validation.numRows() : score_valid;\n        String validation = \"Number of validation data samples for scoring: \" + (fullvalid ? \"all \" : \"\") + ptsv;\n        if (ptsv < 1000 && model_info().get_params().validation.numRows() >= 1000) validation += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (ptsv > 100000 && errors[errors.length-1].scoring_time > 10000) validation += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, validation);\n      }\n\n      if (isClassifier() && nclasses() != 2 /*binary classifier has its own conflicting D3 object (AUC)*/) {\n        // Plot training error\n        float[] err = new float[errors.length];\n        float[] samples = new float[errors.length];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i].train_err;\n          samples[i] = errors[i].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"classification error\",\n                \"classification error on training data\").generate(sb);\n\n        // Plot validation error\n        if (model_info.parameters.validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i].valid_err;\n          }\n          new D3Plot(samples, err, \"training samples\", \"classification error\",\n                  \"classification error on validation set\").generate(sb);\n        }\n      }\n      // regression\n      else if (!isClassifier()) {\n        // Plot training MSE\n        float[] err = new float[errors.length-1];\n        float[] samples = new float[errors.length-1];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i+1].train_mse;\n          samples[i] = errors[i+1].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"MSE\",\n                \"regression error on training data\").generate(sb);\n\n        // Plot validation MSE\n        if (model_info.parameters.validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i+1].valid_mse;\n          }\n          new D3Plot(samples, err, \"training samples\", \"MSE\",\n                  \"regression error on validation data\").generate(sb);\n        }\n      }\n    }\n\n//    String training = \"Number of training set samples for scoring: \" + error.score_training;\n    if (error.validation) {\n//      String validation = \"Number of validation set samples for scoring: \" + error.score_validation;\n    }\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Training Time<\/th>\");\n    sb.append(\"<th>Training Epochs<\/th>\");\n    sb.append(\"<th>Training Samples<\/th>\");\n    if (isClassifier()) {\n//      sb.append(\"<th>Training MCE<\/th>\");\n      sb.append(\"<th>Training Error<\/th>\");\n      if (nclasses()==2) sb.append(\"<th>Training AUC<\/th>\");\n    } else {\n      sb.append(\"<th>Training MSE<\/th>\");\n    }\n    if (error.validation) {\n      if (isClassifier()) {\n//      sb.append(\"<th>Validation MCE<\/th>\");\n        sb.append(\"<th>Validation Error<\/th>\");\n        if (nclasses()==2) sb.append(\"<th>Validation AUC<\/th>\");\n      } else {\n        sb.append(\"<th>Validation MSE<\/th>\");\n      }\n    }\n    sb.append(\"<\/tr>\");\n    for( int i = errors.length - 1; i >= 0; i-- ) {\n      final Errors e = errors[i];\n      sb.append(\"<tr>\");\n      sb.append(\"<td>\" + PrettyPrint.msecs(e.training_time_ms, true) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%g\", e.epoch_counter) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%,d\", e.training_samples) + \"<\/td>\");\n      if (isClassifier()) {\n//        sb.append(\"<td>\" + String.format(cross_entropy_format, e.train_mce) + \"<\/td>\");\n        sb.append(\"<td>\" + formatPct(e.train_err) + \"<\/td>\");\n        if (nclasses()==2) {\n          if (e.trainAUC != null) sb.append(\"<td>\" + formatPct(e.trainAUC.AUC()) + \"<\/td>\");\n          else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n        }\n      } else {\n        sb.append(\"<td>\" + String.format(mse_format, e.train_mse) + \"<\/td>\");\n      }\n      if(e.validation) {\n        if (isClassifier()) {\n//          sb.append(\"<td>\" + String.format(cross_entropy_format, e.valid_mce) + \"<\/td>\");\n          sb.append(\"<td>\" + formatPct(e.valid_err) + \"<\/td>\");\n          if (nclasses()==2) {\n            if (e.validAUC != null) sb.append(\"<td>\" + formatPct(e.validAUC.AUC()) + \"<\/td>\");\n            else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n          }\n        } else {\n          sb.append(\"<td>\" + String.format(mse_format, e.valid_mse) + \"<\/td>\");\n        }\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table>\");\n    return true;\n  }","commit_id":"c395461e58a645d80c849f33bc30ac80e5733621","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n     * Closes this store. This will cause all buffers and channels to be closed.\n     * Requesting an operation from after this method has been invoked is\n     * illegal and an exception will be thrown.\n     * <p>\n     * This method will start by invoking the {@link #closeStorage} method\n     * giving the implementing store way to do anything that it needs to do\n     * before the fileChannel is closed.\n     */\n    public void close()\n    {\n        if ( fileChannel == null )\n        {\n            return;\n        }\n        closeStorage();\n        if ( windowPool != null )\n        {\n            windowPool.close();\n            windowPool = null;\n        }\n        if ( isReadOnly() && !isBackupSlave() )\n        {\n            try\n            {\n                fileChannel.close();\n            }\n            catch ( IOException e )\n            {\n                throw new UnderlyingStorageException( e );\n            }\n            return;\n        }\n        long highId = idGenerator.getHighId();\n        int recordSize = -1;\n        if ( this instanceof AbstractDynamicStore )\n        {\n            recordSize = ((AbstractDynamicStore) this).getBlockSize();\n        }\n        else if ( this instanceof AbstractStore )\n        {\n            recordSize = ((AbstractStore) this).getRecordSize();\n        }\n        idGenerator.close( true );\n        boolean success = false;\n        IOException storedIoe = null;\n        // hack for WINBLOWS\n        if ( !readOnly || backupSlave )\n        {\n            for ( int i = 0; i < 10; i++ )\n            {\n                try\n                {\n                    fileChannel.position( highId * recordSize );\n                    ByteBuffer buffer = ByteBuffer.wrap(\n                        UTF8.encode( getTypeAndVersionDescriptor() ) );\n                    fileChannel.write( buffer );\n                    fileChannel.truncate( fileChannel.position() );\n                    fileChannel.force( false );\n                    releaseFileLockAndCloseFileChannel();\n                    success = true;\n                    break;\n                }\n                catch ( IOException e )\n                {\n                    storedIoe = e;\n                    System.gc();\n                }\n            }\n        }\n        else\n        {\n            releaseFileLockAndCloseFileChannel();\n            success = true;\n//=======\n//            try\n//            {\n//                fileChannel.close();\n//            }\n//            catch ( IOException e )\n//            {\n//                logger.log( Level.WARNING, \"Could not close fileChannel [\" + storageFileName + \"]\", e );\n//            }\n//>>>>>>> parent of 739f974... Change start-up sequence so that version number in neostore gets checked, not just in the child stores\n        }\n        if ( !success )\n        {\n            throw new UnderlyingStorageException( \"Unable to close store \"\n                + getStorageFileName(), storedIoe );\n        }\n    }","id":32726,"modified_method":"/**\n     * Closes this store. This will cause all buffers and channels to be closed.\n     * Requesting an operation from after this method has been invoked is\n     * illegal and an exception will be thrown.\n     * <p>\n     * This method will start by invoking the {@link #closeStorage} method\n     * giving the implementing store way to do anything that it needs to do\n     * before the fileChannel is closed.\n     */\n    public void close()\n    {\n        if ( fileChannel == null )\n        {\n            return;\n        }\n        closeStorage();\n        if ( windowPool != null )\n        {\n            windowPool.close();\n            windowPool = null;\n        }\n        if ( (isReadOnly() && !isBackupSlave()) || idGenerator == null || !storeOk )\n        {\n            try\n            {\n                fileChannel.close();\n            }\n            catch ( IOException e )\n            {\n                throw new UnderlyingStorageException( e );\n            }\n            return;\n        }\n        long highId = idGenerator.getHighId();\n        int recordSize = -1;\n        if ( this instanceof AbstractDynamicStore )\n        {\n            recordSize = ((AbstractDynamicStore) this).getBlockSize();\n        }\n        else if ( this instanceof AbstractStore )\n        {\n            recordSize = ((AbstractStore) this).getRecordSize();\n        }\n        idGenerator.close( true );\n        boolean success = false;\n        IOException storedIoe = null;\n        // hack for WINBLOWS\n        if ( !readOnly || backupSlave )\n        {\n            for ( int i = 0; i < 10; i++ )\n            {\n                try\n                {\n                    fileChannel.position( highId * recordSize );\n                    ByteBuffer buffer = ByteBuffer.wrap(\n                        UTF8.encode( getTypeAndVersionDescriptor() ) );\n                    fileChannel.write( buffer );\n                    fileChannel.truncate( fileChannel.position() );\n                    fileChannel.force( false );\n                    releaseFileLockAndCloseFileChannel();\n                    success = true;\n                    break;\n                }\n                catch ( IOException e )\n                {\n                    storedIoe = e;\n                    System.gc();\n                }\n            }\n        }\n        else\n        {\n            releaseFileLockAndCloseFileChannel();\n            success = true;\n//=======\n//            try\n//            {\n//                fileChannel.close();\n//            }\n//            catch ( IOException e )\n//            {\n//                logger.log( Level.WARNING, \"Could not close fileChannel [\" + storageFileName + \"]\", e );\n//            }\n//>>>>>>> parent of 739f974... Change start-up sequence so that version number in neostore gets checked, not just in the child stores\n        }\n        if ( !success )\n        {\n            throw new UnderlyingStorageException( \"Unable to close store \"\n                + getStorageFileName(), storedIoe );\n        }\n    }","commit_id":"d4102e1ac307a14a3948b748c00c956de54873ab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private BreakPoint[] breakpoints() throws Throwable\n    {\n        if ( breakpoints.isEmpty() )\n        {\n            synchronized ( breakpoints )\n            {\n                if ( breakpoints.isEmpty() )\n                {\n                    List<Throwable> failures = new ArrayList<Throwable>();\n                    final Object CLAIMED = new Object();\n                    Map<String, Object> bpDefs = new HashMap<String, Object>();\n                    ForeignBreakpoints foreign = getTestClass().getJavaClass().getAnnotation( ForeignBreakpoints.class );\n                    if ( foreign != null ) for ( BreakpointDef def : foreign.value() )\n                    {\n                        String name = def.name();\n                        if ( name.isEmpty() ) name = def.method();\n                        if ( null != bpDefs.put( name, def ) )\n                            failures.add( new Exception( \"Multiple definitions of the breakpoint \\\"\" + name + \"\\\"\" ) );\n                    }\n                    for ( FrameworkMethod method : getTestClass().getAnnotatedMethods( BreakpointTrigger.class ) )\n                    {\n                        String name = method.getAnnotation( BreakpointTrigger.class ).value();\n                        if ( name.isEmpty() ) name = method.getName();\n                        if ( null != bpDefs.put( name, method ) )\n                            failures.add( new Exception( \"Multiple definitions of the breakpoint \\\"\" + name + \"\\\"\" ) );\n                    }\n                    for ( FrameworkMethod handler : getTestClass().getAnnotatedMethods( BreakpointHandler.class ) )\n                    {\n                        for ( String name : handler.getAnnotation( BreakpointHandler.class ).value() )\n                        {\n                            Object bp = bpDefs.get( name );\n                            if ( bp == null )\n                            {\n                                failures.add( new Exception( \"No such breakpoint: \\\"\" + name + \"\\\", referenced from: \"\n                                                             + handler ) );\n                            }\n                            else if ( bp == CLAIMED )\n                            {\n                                failures.add( new Exception( \"Multiple handlers for breakpoint: \\\"\" + name\n                                                             + \"\\\", referenced from: \" + handler ) );\n                            }\n                            else if ( bp instanceof BreakpointDef )\n                            {\n                                try\n                                {\n                                    for ( BreakpointDispatcher dispatch : createForeignBreakpoints( (BreakpointDef) bp,\n                                            handler ) )\n                                    {\n                                        breakpoints.put( name, dispatch );\n                                    }\n                                }\n                                catch ( Exception exc )\n                                {\n                                    failures.add( exc );\n                                }\n                            }\n                            else if ( bp instanceof FrameworkMethod )\n                            {\n                                breakpoints.put( name, new BreakpointDispatcher(\n                                        ( (FrameworkMethod) bp ).getAnnotation( BreakpointTrigger.class ).on(),\n                                        getTestClass().getJavaClass(), ( (FrameworkMethod) bp ).getMethod(), handler ) );\n                            }\n                            else\n                            {\n                                failures.add( new Exception( \"Internal error, unknown breakpoint def: \" + bp ) );\n                            }\n                            bpDefs.put( name, CLAIMED );\n                        }\n                    }\n                    if ( bpDefs.size() != breakpoints.size() ) for ( Object bp : bpDefs.values() )\n                    {\n                        if ( bp != CLAIMED ) failures.add( new Exception( \"Unhandled breakpoint: \" + bp ) );\n                    }\n                    if ( !failures.isEmpty() )\n                    {\n                        if ( failures.size() == 1 ) throw failures.get( 0 );\n                        throw new MultipleFailureException( failures );\n                    }\n                }\n            }\n        }\n        return breakpoints.values().toArray( new BreakPoint[breakpoints.size()] );\n    }","id":32727,"modified_method":"private BreakPoint[] breakpoints() throws Throwable\n    {\n        if ( breakpoints.isEmpty() )\n        {\n            synchronized ( breakpoints )\n            {\n                if ( breakpoints.isEmpty() )\n                {\n                    List<Throwable> failures = new ArrayList<Throwable>();\n                    final Object CLAIMED = new Object();\n                    Map<String, Object> bpDefs = new HashMap<String, Object>();\n                    ForeignBreakpoints foreign = getTestClass().getJavaClass().getAnnotation( ForeignBreakpoints.class );\n                    if ( foreign != null ) for ( BreakpointDef def : foreign.value() )\n                    {\n                        String name = def.name();\n                        if ( name.isEmpty() ) name = def.method();\n                        if ( null != bpDefs.put( name, def ) )\n                            failures.add( new Exception( \"Multiple definitions of the breakpoint \\\"\" + name + \"\\\"\" ) );\n                    }\n                    for ( FrameworkMethod method : getTestClass().getAnnotatedMethods( BreakpointTrigger.class ) )\n                    {\n                        String name = method.getAnnotation( BreakpointTrigger.class ).value();\n                        if ( name.isEmpty() ) name = method.getName();\n                        if ( null != bpDefs.put( name, method ) )\n                            failures.add( new Exception( \"Multiple definitions of the breakpoint \\\"\" + name + \"\\\"\" ) );\n                    }\n                    for ( FrameworkMethod handler : getTestClass().getAnnotatedMethods( BreakpointHandler.class ) )\n                    {\n                        for ( String name : handler.getAnnotation( BreakpointHandler.class ).value() )\n                        {\n                            Object bp = bpDefs.get( name );\n                            if ( bp == null )\n                            {\n                                failures.add( new Exception( \"No such breakpoint: \\\"\" + name + \"\\\", referenced from: \"\n                                                             + handler ) );\n                            }\n                            else if ( bp == CLAIMED )\n                            {\n                                failures.add( new Exception( \"Multiple handlers for breakpoint: \\\"\" + name\n                                                             + \"\\\", referenced from: \" + handler ) );\n                            }\n                            else if ( bp instanceof BreakpointDef )\n                            {\n                                try\n                                {\n                                    for ( BreakpointDispatcher dispatch : createForeignBreakpoints( (BreakpointDef) bp,\n                                            handler ) )\n                                    {\n                                        breakpoints.put( name, dispatch );\n                                    }\n                                }\n                                catch ( Exception exc )\n                                {\n                                    failures.add( exc );\n                                }\n                            }\n                            else if ( bp instanceof FrameworkMethod )\n                            {\n                                breakpoints.put( name, new BreakpointDispatcher(\n                                        ( (FrameworkMethod) bp ).getAnnotation( BreakpointTrigger.class ).on(),\n                                        ( (FrameworkMethod) bp ).getMethod().getDeclaringClass(),\n                                        ( (FrameworkMethod) bp ).getMethod(), handler ) );\n                            }\n                            else\n                            {\n                                failures.add( new Exception( \"Internal error, unknown breakpoint def: \" + bp ) );\n                            }\n                            bpDefs.put( name, CLAIMED );\n                        }\n                    }\n                    if ( bpDefs.size() != breakpoints.size() ) for ( Object bp : bpDefs.values() )\n                    {\n                        if ( bp != CLAIMED ) failures.add( new Exception( \"Unhandled breakpoint: \" + bp ) );\n                    }\n                    if ( !failures.isEmpty() )\n                    {\n                        if ( failures.size() == 1 ) throw failures.get( 0 );\n                        throw new MultipleFailureException( failures );\n                    }\n                }\n            }\n        }\n        return breakpoints.values().toArray( new BreakPoint[breakpoints.size()] );\n    }","commit_id":"d4102e1ac307a14a3948b748c00c956de54873ab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void verifyBreakpointState() throws SuspendedThreadsException\n    {\n        DebuggedThread[] threads = SubProcess.DebugDispatch.get( dispatcher ).suspendedThreads();\n        if ( threads.length != 0 )\n        {\n            String[] names = new String[threads.length];\n            for ( int i = 0; i < threads.length; i++ )\n            {\n                names[i] = threads[i].name();\n                threads[i].resume();\n            }\n            throw new SuspendedThreadsException( names );\n        }\n    }","id":32728,"modified_method":"private void verifyBreakpointState() throws SuspendedThreadsException\n    {\n        DebugDispatch debugger = SubProcess.DebugDispatch.get( dispatcher );\n        // if there are no breakpoints we will have no debugger\n        DebuggedThread[] threads = (debugger == null) ? new DebuggedThread[0] : debugger.suspendedThreads();\n        if ( threads.length != 0 )\n        {\n            String[] names = new String[threads.length];\n            for ( int i = 0; i < threads.length; i++ )\n            {\n                names[i] = threads[i].name();\n                threads[i].resume();\n            }\n            throw new SuspendedThreadsException( names );\n        }\n    }","commit_id":"d4102e1ac307a14a3948b748c00c956de54873ab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void enableBreakpoints( EnabledBreakpoints breakpoints )\n    {\n        Set<String> enabled = new HashSet<String>();\n        if ( breakpoints != null ) for ( String name : breakpoints.value() )\n        {\n            enabled.add( name );\n        }\n        for ( Map.Entry<String, BreakPoint> bp : this.breakpoints.entrySet() )\n        {\n            if ( enabled.remove( bp.getKey() ) )\n            {\n                bp.getValue().enable();\n            }\n            else\n            {\n                bp.getValue().disable();\n            }\n        }\n        if ( !enabled.isEmpty() ) throw new IllegalArgumentException( \"Unknown breakpoints: \" + enabled );\n    }","id":32729,"modified_method":"private void enableBreakpoints( EnabledBreakpoints breakpoints )\n    {\n        Set<String> enabled = new HashSet<String>();\n        if ( breakpoints != null ) for ( String name : breakpoints.value() )\n        {\n            enabled.add( name );\n        }\n        for ( Map.Entry<String, BreakPoint> entry : this.breakpoints.entrySet() )\n        {\n            BreakPoint bp = entry.getValue();\n            ( enabled.remove( entry.getKey() ) ? bp.enable() : bp.disable() ).resetInvocationCount();\n        }\n        if ( !enabled.isEmpty() ) throw new IllegalArgumentException( \"Unknown breakpoints: \" + enabled );\n    }","commit_id":"d4102e1ac307a14a3948b748c00c956de54873ab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, TransitiveArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: use as a conflict resolver\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    // TODO: why do we force the version on it? what if they don't match?\n                    if ( previousRange == null )\n                    {\n                        // version was already resolved\n                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n                    }\n                    else if ( currentRange == null )\n                    {\n                        // version was already resolved\n                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n                    }\n                    else\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        previous.getArtifact().setVersionRange( previousRange.restrict( currentRange ) );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        checkScopeUpdate( node, previous, listeners );\n                    }\n                    else\n                    {\n                        checkScopeUpdate( previous, node, listeners );\n                    }\n\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        // previous was nearer\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                        node.disable();\n                    }\n                    else\n                    {\n                        previous.disable();\n                    }\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        if ( node.isActive() )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && !child.getArtifact().isOptional() )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            VersionRange versionRange = artifact.getVersionRange();\n\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !versionRange.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = versionRange.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n                        // no logger to use here either just now\n\n                        // TODO: should the remoteRepositories list be null here?!\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), null, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new TransitiveArtifactResolutionException( e.getMessage(), artifact, remoteRepositories,\n                                                                         e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }","id":32730,"modified_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, TransitiveArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: use as a conflict resolver\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    // TODO: why do we force the version on it? what if they don't match?\n                    if ( previousRange == null )\n                    {\n                        // version was already resolved\n                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n                    }\n                    else if ( currentRange == null )\n                    {\n                        // version was already resolved\n                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n                    }\n                    else\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        previous.getArtifact().setVersionRange( previousRange.restrict( currentRange ) );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        checkScopeUpdate( node, previous, listeners );\n                    }\n                    else\n                    {\n                        checkScopeUpdate( previous, node, listeners );\n                    }\n\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        // previous was nearer\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                        node.disable();\n                    }\n                    else\n                    {\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact() );\n                        previous.disable();\n                    }\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        if ( node.isActive() )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && !child.getArtifact().isOptional() )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            VersionRange versionRange = artifact.getVersionRange();\n\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !versionRange.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = versionRange.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n                        // no logger to use here either just now\n\n                        // TODO: should the remoteRepositories list be null here?!\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), null, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new TransitiveArtifactResolutionException( e.getMessage(), artifact, remoteRepositories,\n                                                                         e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }","commit_id":"5637c284986e8686dacce622cf7df84bd8b82c28","url":"https://github.com/apache/maven"},{"original_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, ManagedVersionMap managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        Object key = node.getKey();\n        \n        // TODO: Does this check need to happen here?  Had to add the same call\n        // below when we iterate on child nodes -- will that suffice?\n        if ( managedVersions.containsKey( key ))\n        {\n            manageArtifact( node, managedVersions, listeners );\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    if ( previousRange != null && currentRange != null )\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        VersionRange newRange = previousRange.restrict( currentRange );\n                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\n                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )\n                        {\n                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),\n                                       newRange );\n                        }\n                        previous.getArtifact().setVersionRange( newRange );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n\n                        //Select an appropriate available version from the (now restricted) range\n                        //Note this version was selected before to get the appropriate POM\n                        //But it was reset by the call to setVersionRange on restricting the version\n                        ResolutionNode[] resetNodes = {previous, node};\n                        for ( int j = 0; j < 2; j++ )\n                        {\n                            Artifact resetArtifact = resetNodes[j].getArtifact();\n                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&\n                                resetArtifact.getAvailableVersions() != null )\n                            {\n\n                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(\n                                    resetArtifact.getAvailableVersions() ).toString() );\n                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );\n                            }\n                        }\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    ResolutionNode nearest;\n                    ResolutionNode farthest;\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        nearest = previous;\n                        farthest = node;\n                    }\n                    else\n                    {\n                        nearest = node;\n                        farthest = previous;\n                    }\n\n                    if ( checkScopeUpdate( farthest, nearest, listeners ) )\n                    {\n                        // if we need to update scope of nearest to use farthest scope, use the nearest version, but farthest scope\n                        nearest.disable();\n                        farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );\n                    }\n                    else\n                    {\n                        farthest.disable();\n                    }\n                    fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        if ( node.isActive() )\n        {\n            fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n        }\n\n        // don't pull in the transitive deps of a system-scoped dependency.\n        if ( node.isActive() && !Artifact.SCOPE_SYSTEM.equals( node.getArtifact().getScope() ) )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !artifact.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                VersionRange versionRange = artifact.getVersionRange();\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange, artifact, remoteRepositories );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange, artifact,\n                                                                                          remoteRepositories );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = artifact.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        Object childKey = child.getKey();\n                        if ( managedVersions.containsKey( childKey ) )\n                        {\n                            // If this child node is a managed dependency, ensure\n                            // we are using the dependency management version\n                            // of this child if applicable b/c we want to use the\n                            // managed version's POM, *not* any other version's POM.\n                            // We retrieve the POM below in the retrieval step.\n                            manageArtifact( child, managedVersions, listeners );\n                            \n                            // Also, we need to ensure that any exclusions it presents are\n                            // added to the artifact before we retrive the metadata\n                            // for the artifact; otherwise we may end up with unwanted\n                            // dependencies.\n                            Artifact ma = (Artifact) managedVersions.get( childKey );\n                            ArtifactFilter managedExclusionFilter = ma.getDependencyFilter();\n                            if ( null != managedExclusionFilter )\n                            {\n                                if ( null != artifact.getDependencyFilter() )\n                                {\n                                    AndArtifactFilter aaf = new AndArtifactFilter();\n                                    aaf.add( artifact.getDependencyFilter() );\n                                    aaf.add( managedExclusionFilter );\n                                    artifact.setDependencyFilter( aaf );\n                                }\n                                else\n                                {\n                                    artifact.setDependencyFilter( managedExclusionFilter );\n                                }\n                            }\n                        }\n\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n\n                        //TODO might be better to have source.retreive() throw a specific exception for this situation\n                        //and catch here rather than have it return null\n                        if ( rGroup == null )\n                        {\n                            //relocated dependency artifact is declared excluded, no need to add and recurse further\n                            continue;\n                        }\n\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new ArtifactResolutionException(\n                            \"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories,\n                            e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }","id":32731,"modified_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, ManagedVersionMap managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        Object key = node.getKey();\n        \n        // TODO: Does this check need to happen here?  Had to add the same call\n        // below when we iterate on child nodes -- will that suffice?\n        if ( managedVersions.containsKey( key ))\n        {\n            manageArtifact( node, managedVersions, listeners );\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    if ( previousRange != null && currentRange != null )\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        VersionRange newRange = previousRange.restrict( currentRange );\n                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\n                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )\n                        {\n                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),\n                                       newRange );\n                        }\n                        previous.getArtifact().setVersionRange( newRange );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n\n                        //Select an appropriate available version from the (now restricted) range\n                        //Note this version was selected before to get the appropriate POM\n                        //But it was reset by the call to setVersionRange on restricting the version\n                        ResolutionNode[] resetNodes = {previous, node};\n                        for ( int j = 0; j < 2; j++ )\n                        {\n                            Artifact resetArtifact = resetNodes[j].getArtifact();\n                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&\n                                resetArtifact.getAvailableVersions() != null )\n                            {\n\n                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(\n                                    resetArtifact.getAvailableVersions() ).toString() );\n                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );\n                            }\n                        }\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    ResolutionNode nearest;\n                    ResolutionNode farthest;\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        nearest = previous;\n                        farthest = node;\n                    }\n                    else\n                    {\n                        nearest = node;\n                        farthest = previous;\n                    }\n\n                    if ( checkScopeUpdate( farthest, nearest, listeners ) )\n                    {\n                        // if we need to update scope of nearest to use farthest scope, use the nearest version, but farthest scope\n                        nearest.disable();\n                        farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, nearest, farthest.getArtifact() );\n                    }\n                    else\n                    {\n                        farthest.disable();\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );\n                    }\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        if ( node.isActive() )\n        {\n            fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n        }\n\n        // don't pull in the transitive deps of a system-scoped dependency.\n        if ( node.isActive() && !Artifact.SCOPE_SYSTEM.equals( node.getArtifact().getScope() ) )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !artifact.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                VersionRange versionRange = artifact.getVersionRange();\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange, artifact, remoteRepositories );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange, artifact,\n                                                                                          remoteRepositories );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = artifact.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        Object childKey = child.getKey();\n                        if ( managedVersions.containsKey( childKey ) )\n                        {\n                            // If this child node is a managed dependency, ensure\n                            // we are using the dependency management version\n                            // of this child if applicable b/c we want to use the\n                            // managed version's POM, *not* any other version's POM.\n                            // We retrieve the POM below in the retrieval step.\n                            manageArtifact( child, managedVersions, listeners );\n                            \n                            // Also, we need to ensure that any exclusions it presents are\n                            // added to the artifact before we retrive the metadata\n                            // for the artifact; otherwise we may end up with unwanted\n                            // dependencies.\n                            Artifact ma = (Artifact) managedVersions.get( childKey );\n                            ArtifactFilter managedExclusionFilter = ma.getDependencyFilter();\n                            if ( null != managedExclusionFilter )\n                            {\n                                if ( null != artifact.getDependencyFilter() )\n                                {\n                                    AndArtifactFilter aaf = new AndArtifactFilter();\n                                    aaf.add( artifact.getDependencyFilter() );\n                                    aaf.add( managedExclusionFilter );\n                                    artifact.setDependencyFilter( aaf );\n                                }\n                                else\n                                {\n                                    artifact.setDependencyFilter( managedExclusionFilter );\n                                }\n                            }\n                        }\n\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n\n                        //TODO might be better to have source.retreive() throw a specific exception for this situation\n                        //and catch here rather than have it return null\n                        if ( rGroup == null )\n                        {\n                            //relocated dependency artifact is declared excluded, no need to add and recurse further\n                            continue;\n                        }\n\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new ArtifactResolutionException(\n                            \"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories,\n                            e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }","commit_id":"87f98299ac72e1b7299d41231aa2a0d4239b6f2c","url":"https://github.com/apache/maven"},{"original_method":"protected void proxyURL(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse,\n\t\t\tURL url)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = resourceRequest.getPortletSession();\n\n\t\tString cookie = (String)portletSession.getAttribute(_COOKIE);\n\n\t\tURLConnection urlConnection = url.openConnection();\n\n\t\turlConnection.setRequestProperty(\"Cookie\", cookie);\n\n\t\turlConnection.connect();\n\n\t\tresourceResponse.setContentLength(urlConnection.getContentLength());\n\t\tresourceResponse.setContentType(urlConnection.getContentType());\n\n\t\tPortletResponseUtil.write(\n\t\t\tresourceResponse, urlConnection.getInputStream());\n\t}","id":32732,"modified_method":"protected void proxyURL(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse,\n\t\t\tURL url)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = resourceRequest.getPortletSession();\n\n\t\tString cookie = (String)portletSession.getAttribute(WebKeys.COOKIE);\n\n\t\tURLConnection urlConnection = url.openConnection();\n\n\t\turlConnection.setRequestProperty(\"Cookie\", cookie);\n\n\t\turlConnection.connect();\n\n\t\tresourceResponse.setContentLength(urlConnection.getContentLength());\n\t\tresourceResponse.setContentType(urlConnection.getContentType());\n\n\t\tPortletResponseUtil.write(\n\t\t\tresourceResponse, urlConnection.getInputStream());\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String rewriteURLs(\n\t\tString content, PortletResponse portletResponse) throws Exception {\n\n\t\tMatcher rewriteMatcher = _rewritePattern.matcher(content);\n\n\t\tStringBuffer sb = new StringBuffer();\n\n\t\twhile (rewriteMatcher.find()) {\n\t\t\tString namespace = rewriteMatcher.group(1);\n\t\t\tString url = rewriteMatcher.group(2);\n\n\t\t\tif (Validator.isNotNull(namespace)) {\n\t\t\t\trewriteMatcher.appendReplacement(\n\t\t\t\t\tsb, portletResponse.getNamespace());\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(url)) {\n\t\t\t\tMap<String, String> parameterMap =\n\t\t\t\t\tnew HashMap<String, String>();\n\n\t\t\t\tMatcher parameterMatcher = _parameterPattern.matcher(url);\n\n\t\t\t\twhile (parameterMatcher.find()) {\n\t\t\t\t\tString name = parameterMatcher.group(1);\n\t\t\t\t\tString value = parameterMatcher.group(2);\n\n\t\t\t\t\tparameterMap.put(name, HttpUtil.decodeURL(value));\n\t\t\t\t}\n\n\t\t\t\trewriteMatcher.appendReplacement(\n\t\t\t\t\tsb, rewriteURL((LiferayPortletResponse)portletResponse,\n\t\t\t\t\t\tparameterMap));\n\t\t\t}\n\t\t}\n\n\t\trewriteMatcher.appendTail(sb);\n\n\t\treturn sb.toString();\n\t}","id":32733,"modified_method":"protected String rewriteURLs(\n\t\t\tPortletResponse portletResponse, String content)\n\t\tthrows Exception {\n\n\t\tMatcher rewriteMatcher = _rewritePattern.matcher(content);\n\n\t\tStringBuffer sb = new StringBuffer();\n\n\t\twhile (rewriteMatcher.find()) {\n\t\t\tString namespace = rewriteMatcher.group(1);\n\t\t\tString url = rewriteMatcher.group(2);\n\n\t\t\tif (Validator.isNotNull(namespace)) {\n\t\t\t\trewriteMatcher.appendReplacement(\n\t\t\t\t\tsb, portletResponse.getNamespace());\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(url)) {\n\t\t\t\tMap<String, String> parameterMap =\n\t\t\t\t\tnew HashMap<String, String>();\n\n\t\t\t\tMatcher parameterMatcher = _parameterPattern.matcher(url);\n\n\t\t\t\twhile (parameterMatcher.find()) {\n\t\t\t\t\tString name = parameterMatcher.group(1);\n\t\t\t\t\tString value = parameterMatcher.group(2);\n\n\t\t\t\t\tparameterMap.put(name, HttpUtil.decodeURL(value));\n\t\t\t\t}\n\n\t\t\t\trewriteMatcher.appendReplacement(\n\t\t\t\t\tsb, rewriteURL(portletResponse, parameterMap));\n\t\t\t}\n\t\t}\n\n\t\trewriteMatcher.appendTail(sb);\n\n\t\treturn sb.toString();\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String rewriteURL(\n\t\t\tLiferayPortletResponse portletResponse,\n\t\t\tMap<String, String> parameterMap)\n\t\tthrows Exception {\n\n\t\tString lifecycle = parameterMap.get(\"wsrp-urlType\");\n\n\t\tLiferayPortletURL portletURL = null;\n\n\t\tif (lifecycle.equals(\"blockingAction\")) {\n\t\t\tportletURL = (LiferayPortletURL)portletResponse.createActionURL();\n\t\t}\n\t\telse if (lifecycle.equals(\"render\")) {\n\t\t\tportletURL = (LiferayPortletURL)portletResponse.createRenderURL();\n\t\t}\n\t\telse if (lifecycle.equals(\"resource\")) {\n\t\t\tportletURL = (LiferayPortletURL)portletResponse.createResourceURL();\n\t\t}\n\n\t\tfor (Map.Entry<String, String> parameter : parameterMap.entrySet()) {\n\t\t\tString name = parameter.getKey();\n\t\t\tString value = parameter.getValue();\n\n\t\t\tif (name.equals(\"wsrp-mode\")) {\n\t\t\t\tportletURL.setPortletMode(getPortletMode(value));\n\t\t\t}\n\t\t\telse if (name.equals(\"wsrp-resourceID\")) {\n\t\t\t\tportletURL.setResourceID(value);\n\t\t\t}\n\t\t\telse if (name.equals(\"wsrp-urlType\")) {\n\t\t\t}\n\t\t\telse if (name.equals(\"wsrp-windowState\")) {\n\t\t\t\tportletURL.setWindowState(getWindowState(value));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletURL.setParameter(name, value);\n\t\t\t}\n\t\t}\n\n\t\treturn portletURL.toString();\n\t}","id":32734,"modified_method":"protected String rewriteURL(\n\t\t\tPortletResponse portletResponse, Map<String, String> parameterMap)\n\t\tthrows Exception {\n\n\t\tLiferayPortletResponse liferayPortletResponse =\n\t\t\t(LiferayPortletResponse)portletResponse;\n\n\t\tString lifecycle = parameterMap.get(\"wsrp-urlType\");\n\n\t\tLiferayPortletURL liferayPortletURL = null;\n\n\t\tif (lifecycle.equals(\"blockingAction\")) {\n\t\t\tliferayPortletURL =\n\t\t\t\t(LiferayPortletURL)liferayPortletResponse.createActionURL();\n\t\t}\n\t\telse if (lifecycle.equals(\"render\")) {\n\t\t\tliferayPortletURL =\n\t\t\t\t(LiferayPortletURL)liferayPortletResponse.createRenderURL();\n\t\t}\n\t\telse if (lifecycle.equals(\"resource\")) {\n\t\t\tliferayPortletURL =\n\t\t\t\t(LiferayPortletURL)liferayPortletResponse.createResourceURL();\n\t\t}\n\n\t\tfor (Map.Entry<String, String> parameter : parameterMap.entrySet()) {\n\t\t\tString name = parameter.getKey();\n\t\t\tString value = parameter.getValue();\n\n\t\t\tif (name.equals(\"wsrp-mode\")) {\n\t\t\t\tliferayPortletURL.setPortletMode(getPortletMode(value));\n\t\t\t}\n\t\t\telse if (name.equals(\"wsrp-resourceID\")) {\n\t\t\t\tliferayPortletURL.setResourceID(value);\n\t\t\t}\n\t\t\telse if (name.equals(\"wsrp-urlType\")) {\n\t\t\t}\n\t\t\telse if (name.equals(\"wsrp-windowState\")) {\n\t\t\t\tliferayPortletURL.setWindowState(getWindowState(value));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tliferayPortletURL.setParameter(name, value);\n\t\t\t}\n\t\t}\n\n\t\treturn liferayPortletURL.toString();\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void processMarkupResponse(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse,\n\t\tMarkupResponse markupResponse) {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tSessionContext sessionContext = markupResponse.getSessionContext();\n\n\t\tif (sessionContext != null) {\n\t\t\tportletSession.setAttribute(_SESSION_CONTEXT, sessionContext);\n\t\t}\n\t}","id":32735,"modified_method":"protected void processMarkupResponse(\n\t\tPortletRequest portletRequest, PortletResponse portletResponse,\n\t\tMarkupResponse markupResponse) {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tSessionContext sessionContext = markupResponse.getSessionContext();\n\n\t\tif (sessionContext != null) {\n\t\t\tportletSession.setAttribute(\n\t\t\t\tWebKeys.SESSION_CONTEXT, sessionContext);\n\t\t}\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void initContexts(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse,\n\t\t\tWSRPConsumerPortlet wsrpConsumerPortlet,\n\t\t\tWSRPConsumerManager wsrpConsumerManager, MarkupParams markupParams,\n\t\t\tPortletContext portletContext, RuntimeContext runtimeContext,\n\t\t\tUserContext userContext)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\tportletRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t// Markup params\n\n\t\tList<NamedString> clientAttributes = new ArrayList<NamedString>();\n\n\t\tEnumeration<String> enu = request.getHeaderNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = enu.nextElement();\n\n\t\t\tString value = request.getHeader(name);\n\n\t\t\tNamedString clientAttribute = new NamedString();\n\n\t\t\tclientAttribute.setName(name);\n\t\t\tclientAttribute.setValue(value);\n\n\t\t\tclientAttributes.add(clientAttribute);\n\t\t}\n\n\t\tUser user = themeDisplay.getUser();\n\n\t\tclientAttributes.add(\n\t\t\tnew NamedString(\n\t\t\t\tuser.getEmailAddress(), HttpHeaders.LIFERAY_EMAIL_ADDRESS));\n\t\tclientAttributes.add(\n\t\t\tnew NamedString(\n\t\t\t\tuser.getScreenName(), HttpHeaders.LIFERAY_SCREEN_NAME));\n\t\tclientAttributes.add(\n\t\t\tnew NamedString(\n\t\t\t\tString.valueOf(user.getUserId()),\n\t\t\t\tHttpHeaders.LIFERAY_USER_ID));\n\n\t\tClientData clientData = new ClientData();\n\n\t\tclientData.setClientAttributes(\n\t\t\tclientAttributes.toArray(new NamedString[clientAttributes.size()]));\n\n\t\tclientData.setRequestVerb(HttpMethods.GET);\n\t\tclientData.setUserAgent(request.getHeader(HttpHeaders.USER_AGENT));\n\n\t\tmarkupParams.setClientData(clientData);\n\n\t\tList<Locale> locales = Collections.list(portletRequest.getLocales());\n\n\t\tString[] localesArray = new String[locales.size()];\n\n\t\tfor (int i = 0; i < locales.size(); i++) {\n\t\t\tLocale locale = locales.get(i);\n\n\t\t\tlocalesArray[i] = locale.toString();\n\t\t}\n\n\t\tmarkupParams.setLocales(localesArray);\n\n\t\tmarkupParams.setMarkupCharacterSets(_CHAR_SETS);\n\t\tmarkupParams.setMimeTypes(_MIME_TYPES);\n\t\tmarkupParams.setMode(\"wsrp:\" + portletRequest.getPortletMode());\n\t\tmarkupParams.setWindowState(\"wsrp:\" + portletRequest.getWindowState());\n\n\t\tPortletDescription portletDescription =\n\t\t\twsrpConsumerManager.getPortletDescription(\n\t\t\t\twsrpConsumerPortlet.getPortletHandle());\n\n\t\tMarkupType[] markupTypes = portletDescription.getMarkupTypes();\n\n\t\tfor (MarkupType markupType : markupTypes) {\n\t\t\tif (markupType.getMimeType().equalsIgnoreCase(\n\t\t\t\t\tContentTypes.TEXT_HTML)) {\n\n\t\t\t\tmarkupParams.setValidNewModes(markupType.getModes());\n\t\t\t\tmarkupParams.setValidNewWindowStates(\n\t\t\t\t\tmarkupType.getWindowStates());\n\t\t\t}\n\t\t}\n\n\t\t// Navigational context\n\n\t\tNavigationalContext navigationalContext = new NavigationalContext();\n\n\t\tString navigationalState = portletRequest.getParameter(\n\t\t\t\"wsrp-navigationalState\");\n\n\t\tnavigationalContext.setOpaqueValue(navigationalState);\n\n\t\tString navigationalValues = portletRequest.getParameter(\n\t\t\t\"wsrp-navigationalValues\");\n\n\t\tif (Validator.isNotNull(navigationalValues)) {\n\t\t\tList<NamedString> publicValues = new ArrayList<NamedString>();\n\n\t\t\tMatcher matcher = _navigationalValuesPattern.matcher(\n\t\t\t\tnavigationalValues);\n\n\t\t\twhile (matcher.find()) {\n\t\t\t\tNamedString publicValue = new NamedString();\n\n\t\t\t\tpublicValue.setName(matcher.group(1));\n\t\t\t\tpublicValue.setValue(matcher.group(2));\n\n\t\t\t\tpublicValues.add(publicValue);\n\t\t\t}\n\n\t\t\tnavigationalContext.setPublicValues(\n\t\t\t\tpublicValues.toArray(new NamedString[publicValues.size()]));\n\t\t}\n\n\t\tmarkupParams.setNavigationalContext(navigationalContext);\n\n\t\t// Portlet context\n\n\t\tportletContext.setPortletHandle(wsrpConsumerPortlet.getPortletHandle());\n\n\t\t// Runtime context\n\n\t\truntimeContext.setNamespacePrefix(portletResponse.getNamespace());\n\t\truntimeContext.setPortletInstanceKey(portletResponse.getNamespace());\n\n\t\tSessionContext sessionContext =\n\t\t\t(SessionContext)portletSession.getAttribute(_SESSION_CONTEXT);\n\n\t\tif (sessionContext != null) {\n\t\t\tSessionParams sessionParams = new SessionParams();\n\n\t\t\tsessionParams.setSessionID(sessionContext.getSessionID());\n\n\t\t\truntimeContext.setSessionParams(sessionParams);\n\t\t}\n\n\t\truntimeContext.setUserAuthentication(\"wsrp:password\");\n\n\t\t// User context\n\n\t\tuserContext.setUserCategories(new String[] {RoleConstants.USER});\n\t\tuserContext.setUserContextKey(String.valueOf(themeDisplay.getUserId()));\n\t}","id":32736,"modified_method":"protected void initContexts(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse,\n\t\t\tWSRPConsumerPortlet wsrpConsumerPortlet,\n\t\t\tWSRPConsumerManager wsrpConsumerManager, MarkupParams markupParams,\n\t\t\tPortletContext portletContext, RuntimeContext runtimeContext,\n\t\t\tUserContext userContext)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\tportletRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t// Markup params\n\n\t\tList<NamedString> clientAttributes = new ArrayList<NamedString>();\n\n\t\tEnumeration<String> enu = request.getHeaderNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = enu.nextElement();\n\n\t\t\tString value = request.getHeader(name);\n\n\t\t\tNamedString clientAttribute = new NamedString();\n\n\t\t\tclientAttribute.setName(name);\n\t\t\tclientAttribute.setValue(value);\n\n\t\t\tclientAttributes.add(clientAttribute);\n\t\t}\n\n\t\tUser user = themeDisplay.getUser();\n\n\t\tclientAttributes.add(\n\t\t\tnew NamedString(\n\t\t\t\tuser.getEmailAddress(), HttpHeaders.LIFERAY_EMAIL_ADDRESS));\n\t\tclientAttributes.add(\n\t\t\tnew NamedString(\n\t\t\t\tuser.getScreenName(), HttpHeaders.LIFERAY_SCREEN_NAME));\n\t\tclientAttributes.add(\n\t\t\tnew NamedString(\n\t\t\t\tString.valueOf(user.getUserId()),\n\t\t\t\tHttpHeaders.LIFERAY_USER_ID));\n\n\t\tClientData clientData = new ClientData();\n\n\t\tclientData.setClientAttributes(\n\t\t\tclientAttributes.toArray(new NamedString[clientAttributes.size()]));\n\n\t\tclientData.setRequestVerb(HttpMethods.GET);\n\t\tclientData.setUserAgent(request.getHeader(HttpHeaders.USER_AGENT));\n\n\t\tmarkupParams.setClientData(clientData);\n\n\t\tList<Locale> locales = Collections.list(portletRequest.getLocales());\n\n\t\tString[] localesArray = new String[locales.size()];\n\n\t\tfor (int i = 0; i < locales.size(); i++) {\n\t\t\tLocale locale = locales.get(i);\n\n\t\t\tlocalesArray[i] = locale.toString();\n\t\t}\n\n\t\tmarkupParams.setLocales(localesArray);\n\n\t\tmarkupParams.setMarkupCharacterSets(_CHAR_SETS);\n\t\tmarkupParams.setMimeTypes(_MIME_TYPES);\n\t\tmarkupParams.setMode(\"wsrp:\" + portletRequest.getPortletMode());\n\t\tmarkupParams.setWindowState(\"wsrp:\" + portletRequest.getWindowState());\n\n\t\tPortletDescription portletDescription =\n\t\t\twsrpConsumerManager.getPortletDescription(\n\t\t\t\twsrpConsumerPortlet.getPortletHandle());\n\n\t\tMarkupType[] markupTypes = portletDescription.getMarkupTypes();\n\n\t\tfor (MarkupType markupType : markupTypes) {\n\t\t\tif (markupType.getMimeType().equalsIgnoreCase(\n\t\t\t\t\tContentTypes.TEXT_HTML)) {\n\n\t\t\t\tmarkupParams.setValidNewModes(markupType.getModes());\n\t\t\t\tmarkupParams.setValidNewWindowStates(\n\t\t\t\t\tmarkupType.getWindowStates());\n\t\t\t}\n\t\t}\n\n\t\t// Navigational context\n\n\t\tNavigationalContext navigationalContext = new NavigationalContext();\n\n\t\tString navigationalState = portletRequest.getParameter(\n\t\t\t\"wsrp-navigationalState\");\n\n\t\tnavigationalContext.setOpaqueValue(navigationalState);\n\n\t\tString navigationalValues = portletRequest.getParameter(\n\t\t\t\"wsrp-navigationalValues\");\n\n\t\tif (Validator.isNotNull(navigationalValues)) {\n\t\t\tList<NamedString> publicValues = new ArrayList<NamedString>();\n\n\t\t\tMatcher matcher = _navigationalValuesPattern.matcher(\n\t\t\t\tnavigationalValues);\n\n\t\t\twhile (matcher.find()) {\n\t\t\t\tNamedString publicValue = new NamedString();\n\n\t\t\t\tpublicValue.setName(matcher.group(1));\n\t\t\t\tpublicValue.setValue(matcher.group(2));\n\n\t\t\t\tpublicValues.add(publicValue);\n\t\t\t}\n\n\t\t\tnavigationalContext.setPublicValues(\n\t\t\t\tpublicValues.toArray(new NamedString[publicValues.size()]));\n\t\t}\n\n\t\tmarkupParams.setNavigationalContext(navigationalContext);\n\n\t\t// Portlet context\n\n\t\tportletContext.setPortletHandle(wsrpConsumerPortlet.getPortletHandle());\n\n\t\t// Runtime context\n\n\t\truntimeContext.setNamespacePrefix(portletResponse.getNamespace());\n\t\truntimeContext.setPortletInstanceKey(portletResponse.getNamespace());\n\n\t\tSessionContext sessionContext =\n\t\t\t(SessionContext)portletSession.getAttribute(\n\t\t\t\tWebKeys.SESSION_CONTEXT);\n\n\t\tif (sessionContext != null) {\n\t\t\tSessionParams sessionParams = new SessionParams();\n\n\t\t\tsessionParams.setSessionID(sessionContext.getSessionID());\n\n\t\t\truntimeContext.setSessionParams(sessionParams);\n\t\t}\n\n\t\truntimeContext.setUserAuthentication(\"wsrp:password\");\n\n\t\t// User context\n\n\t\tuserContext.setUserCategories(new String[] {RoleConstants.USER});\n\t\tuserContext.setUserContextKey(String.valueOf(themeDisplay.getUserId()));\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void sendRedirect(\n\t\t\tString redirectURL, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tredirectURL = rewriteURLs(redirectURL, actionResponse);\n\n\t\tactionResponse.sendRedirect(redirectURL);\n\t}","id":32737,"modified_method":"protected void sendRedirect(\n\t\t\tActionResponse actionResponse, String redirectURL)\n\t\tthrows Exception {\n\n\t\tredirectURL = rewriteURLs(actionResponse, redirectURL);\n\n\t\tactionResponse.sendRedirect(redirectURL);\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected WSRP_v2_Markup_PortType getMarkupService(\n\t\t\tPortletRequest portletRequest,\n\t\t\tWSRPConsumerManager wsrpConsumerManager)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tWSRP_v2_Markup_PortType markupService =\n\t\t\t(WSRP_v2_Markup_PortType)portletSession.getAttribute(\n\t\t\t\t_MARKUP_SERVICE);\n\n\t\tif (markupService == null) {\n\t\t\tmarkupService = wsrpConsumerManager.getMarkupService();\n\n\t\t\tServiceDescription serviceDescription =\n\t\t\t\twsrpConsumerManager.getServiceDescription();\n\n\t\t\tString cookie = (String)portletSession.getAttribute(_COOKIE);\n\n\t\t\tif (cookie == null) {\n\t\t\t\tCookieProtocol cookieProtocol =\n\t\t\t\t\tserviceDescription.getRequiresInitCookie();\n\n\t\t\t\tString cookieProtocolValue = cookieProtocol.getValue();\n\n\t\t\t\tif (cookieProtocolValue.equals(CookieProtocol._perGroup) ||\n\t\t\t\t\tcookieProtocolValue.equals(CookieProtocol._perUser)) {\n\n\t\t\t\t\tInitCookie initCookie = new InitCookie();\n\n\t\t\t\t\tmarkupService.initCookie(initCookie);\n\n\t\t\t\t\tcookie = SimpleHTTPSender.getCurrentCookie();\n\n\t\t\t\t\tportletSession.setAttribute(_COOKIE, cookie);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletSession.setAttribute(_MARKUP_SERVICE, markupService);\n\t\t}\n\n\t\treturn markupService;\n\t}","id":32738,"modified_method":"protected WSRP_v2_Markup_PortType getMarkupService(\n\t\t\tPortletRequest portletRequest,\n\t\t\tWSRPConsumerManager wsrpConsumerManager)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tWSRP_v2_Markup_PortType markupService =\n\t\t\t(WSRP_v2_Markup_PortType)portletSession.getAttribute(\n\t\t\t\tWebKeys.MARKUP_SERVICE);\n\n\t\tif (markupService == null) {\n\t\t\tmarkupService = wsrpConsumerManager.getMarkupService();\n\n\t\t\tServiceDescription serviceDescription =\n\t\t\t\twsrpConsumerManager.getServiceDescription();\n\n\t\t\tString cookie = (String)portletSession.getAttribute(\n\t\t\t\tWebKeys.COOKIE);\n\n\t\t\tif (cookie == null) {\n\t\t\t\tCookieProtocol cookieProtocol =\n\t\t\t\t\tserviceDescription.getRequiresInitCookie();\n\n\t\t\t\tString cookieProtocolValue = cookieProtocol.getValue();\n\n\t\t\t\tif (cookieProtocolValue.equals(CookieProtocol._perGroup) ||\n\t\t\t\t\tcookieProtocolValue.equals(CookieProtocol._perUser)) {\n\n\t\t\t\t\tInitCookie initCookie = new InitCookie();\n\n\t\t\t\t\tmarkupService.initCookie(initCookie);\n\n\t\t\t\t\tcookie = SimpleHTTPSender.getCurrentCookie();\n\n\t\t\t\t\tportletSession.setAttribute(WebKeys.COOKIE, cookie);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletSession.setAttribute(WebKeys.MARKUP_SERVICE, markupService);\n\t\t}\n\n\t\treturn markupService;\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doRender(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = renderRequest.getPortletSession();\n\n\t\tMarkupContext markupContext =\n\t\t\t(MarkupContext)portletSession.getAttribute(_MARKUP_CONTEXT);\n\n\t\tif (markupContext != null) {\n\t\t\tportletSession.removeAttribute(_MARKUP_CONTEXT);\n\t\t}\n\t\telse {\n\t\t\tMarkupResponse markupResponse = getMarkupResponse(\n\t\t\t\trenderRequest, renderResponse);\n\n\t\t\tmarkupContext = markupResponse.getMarkupContext();\n\t\t}\n\n\t\trenderResponse.setContentType(ContentTypes.TEXT_HTML_UTF8);\n\n\t\tString content = rewriteURLs(\n\t\t\tmarkupContext.getItemString(), renderResponse);\n\n\t\tPortletResponseUtil.write(renderResponse, content);\n\t}","id":32739,"modified_method":"protected void doRender(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = renderRequest.getPortletSession();\n\n\t\tMarkupContext markupContext =\n\t\t\t(MarkupContext)portletSession.getAttribute(WebKeys.MARKUP_CONTEXT);\n\n\t\tif (markupContext != null) {\n\t\t\tportletSession.removeAttribute(WebKeys.MARKUP_CONTEXT);\n\t\t}\n\t\telse {\n\t\t\tMarkupResponse markupResponse = getMarkupResponse(\n\t\t\t\trenderRequest, renderResponse);\n\n\t\t\tmarkupContext = markupResponse.getMarkupContext();\n\t\t}\n\n\t\trenderResponse.setContentType(ContentTypes.TEXT_HTML_UTF8);\n\n\t\tString content = rewriteURLs(\n\t\t\trenderResponse, markupContext.getItemString());\n\n\t\tPortletResponseUtil.write(renderResponse, content);\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void processBlockingInteractionResponse(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tBlockingInteractionResponse blockingInteractionResponse)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = actionRequest.getPortletSession();\n\n\t\tString redirectURL = blockingInteractionResponse.getRedirectURL();\n\n\t\tif (Validator.isNotNull(redirectURL)) {\n\t\t\tsendRedirect(redirectURL, actionResponse);\n\n\t\t\treturn;\n\t\t}\n\n\t\tUpdateResponse updateResponse =\n\t\t\tblockingInteractionResponse.getUpdateResponse();\n\n\t\tif (updateResponse == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tportletSession.setAttribute(\n\t\t\t_MARKUP_CONTEXT, updateResponse.getMarkupContext());\n\n\t\tNavigationalContext navigationalContext =\n\t\t\tupdateResponse.getNavigationalContext();\n\n\t\tif (navigationalContext != null) {\n\t\t\tString opaqueValue = navigationalContext.getOpaqueValue();\n\n\t\t\tif (opaqueValue != null) {\n\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\"wsrp-navigationalState\", opaqueValue);\n\t\t\t}\n\n\t\t\tNamedString[] publicValues = navigationalContext.getPublicValues();\n\n\t\t\tif ((publicValues != null) && (publicValues.length > 0)) {\n\t\t\t\tint lastIndex = publicValues.length - 2;\n\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\tfor (int i = 0; i < publicValues.length; i++) {\n\t\t\t\t\tNamedString publicValue = publicValues[i];\n\n\t\t\t\t\tsb.append(publicValue.getName());\n\n\t\t\t\t\tString value = publicValue.getValue();\n\n\t\t\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\t\t\tsb.append(StringPool.EQUAL);\n\t\t\t\t\t\tsb.append(publicValue.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i < lastIndex) {\n\t\t\t\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\"wsrp-navigationalValues\", sb.toString());\n\t\t\t}\n\t\t}\n\n\t\tPortletContext portletContext = updateResponse.getPortletContext();\n\n\t\tif (portletContext != null) {\n\t\t\tportletSession.setAttribute(_PORTLET_CONTEXT, portletContext);\n\t\t}\n\n\t\tSessionContext sessionContext = updateResponse.getSessionContext();\n\n\t\tif (sessionContext != null) {\n\t\t\tportletSession.setAttribute(_SESSION_CONTEXT, sessionContext);\n\t\t}\n\n\t\tString portletMode = updateResponse.getNewMode();\n\n\t\tif (Validator.isNotNull(portletMode)) {\n\t\t\tactionResponse.setPortletMode(getPortletMode(portletMode));\n\t\t}\n\n\t\tString windowState = updateResponse.getNewWindowState();\n\n\t\tif (Validator.isNotNull(windowState)) {\n\t\t\tactionResponse.setWindowState(getWindowState(windowState));\n\t\t}\n\t}","id":32740,"modified_method":"protected void processBlockingInteractionResponse(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tBlockingInteractionResponse blockingInteractionResponse)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = actionRequest.getPortletSession();\n\n\t\tString redirectURL = blockingInteractionResponse.getRedirectURL();\n\n\t\tif (Validator.isNotNull(redirectURL)) {\n\t\t\tsendRedirect(actionResponse, redirectURL);\n\n\t\t\treturn;\n\t\t}\n\n\t\tUpdateResponse updateResponse =\n\t\t\tblockingInteractionResponse.getUpdateResponse();\n\n\t\tif (updateResponse == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tportletSession.setAttribute(\n\t\t\tWebKeys.MARKUP_CONTEXT, updateResponse.getMarkupContext());\n\n\t\tNavigationalContext navigationalContext =\n\t\t\tupdateResponse.getNavigationalContext();\n\n\t\tif (navigationalContext != null) {\n\t\t\tString opaqueValue = navigationalContext.getOpaqueValue();\n\n\t\t\tif (opaqueValue != null) {\n\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\"wsrp-navigationalState\", opaqueValue);\n\t\t\t}\n\n\t\t\tNamedString[] publicValues = navigationalContext.getPublicValues();\n\n\t\t\tif ((publicValues != null) && (publicValues.length > 0)) {\n\t\t\t\tint lastIndex = publicValues.length - 2;\n\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\tfor (int i = 0; i < publicValues.length; i++) {\n\t\t\t\t\tNamedString publicValue = publicValues[i];\n\n\t\t\t\t\tsb.append(publicValue.getName());\n\n\t\t\t\t\tString value = publicValue.getValue();\n\n\t\t\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\t\t\tsb.append(StringPool.EQUAL);\n\t\t\t\t\t\tsb.append(publicValue.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i < lastIndex) {\n\t\t\t\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tactionResponse.setRenderParameter(\n\t\t\t\t\t\"wsrp-navigationalValues\", sb.toString());\n\t\t\t}\n\t\t}\n\n\t\tPortletContext portletContext = updateResponse.getPortletContext();\n\n\t\tif (portletContext != null) {\n\t\t\tportletSession.setAttribute(\n\t\t\t\tWebKeys.PORTLET_CONTEXT, portletContext);\n\t\t}\n\n\t\tSessionContext sessionContext = updateResponse.getSessionContext();\n\n\t\tif (sessionContext != null) {\n\t\t\tportletSession.setAttribute(\n\t\t\t\tWebKeys.SESSION_CONTEXT, sessionContext);\n\t\t}\n\n\t\tString portletMode = updateResponse.getNewMode();\n\n\t\tif (Validator.isNotNull(portletMode)) {\n\t\t\tactionResponse.setPortletMode(getPortletMode(portletMode));\n\t\t}\n\n\t\tString windowState = updateResponse.getNewWindowState();\n\n\t\tif (Validator.isNotNull(windowState)) {\n\t\t\tactionResponse.setWindowState(getWindowState(windowState));\n\t\t}\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected MarkupResponse getMarkupResponse(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tWSRPConsumerPortlet wsrpConsumerPortlet = getWSRPConsumerPortlet();\n\n\t\tWSRPConsumerManager wsrpConsumerManager = getWSRPConsumerManager(\n\t\t\twsrpConsumerPortlet);\n\n\t\tMarkupParams markupParams = new MarkupParams();\n\t\tPortletContext portletContext = new PortletContext();\n\t\tRuntimeContext runtimeContext = new RuntimeContext();\n\t\tUserContext userContext = new UserContext();\n\n\t\tinitContexts(\n\t\t\tportletRequest, portletResponse, wsrpConsumerPortlet,\n\t\t\twsrpConsumerManager, markupParams, portletContext, runtimeContext,\n\t\t\tuserContext);\n\n\t\tGetMarkup getMarkup = new GetMarkup();\n\n\t\tgetMarkup.setMarkupParams(markupParams);\n\n\t\tPortletContext existingPortletContext =\n\t\t\t(PortletContext)portletSession.getAttribute(_PORTLET_CONTEXT);\n\n\t\tif (existingPortletContext != null) {\n\t\t\tgetMarkup.setPortletContext(existingPortletContext);\n\t\t}\n\t\telse {\n\t\t\tgetMarkup.setPortletContext(portletContext);\n\t\t}\n\n\t\tgetMarkup.setRuntimeContext(runtimeContext);\n\t\tgetMarkup.setUserContext(userContext);\n\n\t\tWSRP_v2_Markup_PortType markupService = getMarkupService(\n\t\t\tportletRequest, wsrpConsumerManager);\n\n\t\tMarkupResponse markupResponse = markupService.getMarkup(getMarkup);\n\n\t\tprocessMarkupResponse(portletRequest, portletResponse, markupResponse);\n\n\t\treturn markupResponse;\n\t}","id":32741,"modified_method":"protected MarkupResponse getMarkupResponse(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\tWSRPConsumerPortlet wsrpConsumerPortlet = getWSRPConsumerPortlet();\n\n\t\tWSRPConsumerManager wsrpConsumerManager = getWSRPConsumerManager(\n\t\t\twsrpConsumerPortlet);\n\n\t\tMarkupParams markupParams = new MarkupParams();\n\t\tPortletContext portletContext = new PortletContext();\n\t\tRuntimeContext runtimeContext = new RuntimeContext();\n\t\tUserContext userContext = new UserContext();\n\n\t\tinitContexts(\n\t\t\tportletRequest, portletResponse, wsrpConsumerPortlet,\n\t\t\twsrpConsumerManager, markupParams, portletContext, runtimeContext,\n\t\t\tuserContext);\n\n\t\tGetMarkup getMarkup = new GetMarkup();\n\n\t\tgetMarkup.setMarkupParams(markupParams);\n\n\t\tPortletContext existingPortletContext =\n\t\t\t(PortletContext)portletSession.getAttribute(\n\t\t\t\tWebKeys.PORTLET_CONTEXT);\n\n\t\tif (existingPortletContext != null) {\n\t\t\tgetMarkup.setPortletContext(existingPortletContext);\n\t\t}\n\t\telse {\n\t\t\tgetMarkup.setPortletContext(portletContext);\n\t\t}\n\n\t\tgetMarkup.setRuntimeContext(runtimeContext);\n\t\tgetMarkup.setUserContext(userContext);\n\n\t\tWSRP_v2_Markup_PortType markupService = getMarkupService(\n\t\t\tportletRequest, wsrpConsumerManager);\n\n\t\tMarkupResponse markupResponse = markupService.getMarkup(getMarkup);\n\n\t\tprocessMarkupResponse(portletRequest, portletResponse, markupResponse);\n\n\t\treturn markupResponse;\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected MarkupResponse doGetMarkup(GetMarkup getMarkup) throws Exception {\n\t\tHttpSession session = ServletUtil.getRequest().getSession();\n\n\t\tWSRPProducer wsrpProducer = getWSRPProducer();\n\n\t\tString url = getURL(getMarkup, wsrpProducer);\n\n\t\tHttp.Options httpOptions = new Http.Options();\n\n\t\thttpOptions.setLocation(url);\n\n\t\tCookie[] cookies = (Cookie[])session.getAttribute(\"cookies\");\n\n\t\tif (cookies != null) {\n\t\t\thttpOptions.setCookies(cookies);\n\t\t}\n\n\t\tMarkupParams markupParams = getMarkup.getMarkupParams();\n\n\t\taddHeaders(markupParams, httpOptions);\n\n\t\tString content = HttpUtil.URLtoString(httpOptions);\n\n\t\t// Cookies from HttpUtil\n\n\t\t// cookies = (Cookie[])objects[1];\n\n\t\tif (cookies != null) {\n\t\t\tsession.setAttribute(\"cookies\", cookies);\n\t\t}\n\n\t\tMarkupContext markupContext = new MarkupContext();\n\n\t\tmarkupContext.setItemString(content);\n\t\tmarkupContext.setRequiresRewriting(true);\n\n\t\tMarkupResponse markupResponse = new MarkupResponse();\n\n\t\tmarkupResponse.setMarkupContext(markupContext);\n\n\t\treturn markupResponse;\n\t}","id":32742,"modified_method":"protected MarkupResponse doGetMarkup(GetMarkup getMarkup) throws Exception {\n\t\tWSRPProducer wsrpProducer = getWSRPProducer();\n\n\t\tHttp.Options httpOptions = new Http.Options();\n\n\t\taddHeaders(getMarkup.getMarkupParams(), httpOptions);\n\n\t\thttpOptions.setLocation(getURL(getMarkup, wsrpProducer));\n\n\t\tString content = getContent(httpOptions);\n\n\t\tMarkupContext markupContext = new MarkupContext();\n\n\t\tmarkupContext.setItemString(content);\n\t\tmarkupContext.setRequiresRewriting(true);\n\n\t\tMarkupResponse markupResponse = new MarkupResponse();\n\n\t\tmarkupResponse.setMarkupContext(markupContext);\n\n\t\treturn markupResponse;\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected BlockingInteractionResponse doPerformBlockingInteraction(\n\t\t\tPerformBlockingInteraction performBlockingInteraction)\n\t\tthrows Exception {\n\n\t\tHttpSession session = ServletUtil.getRequest().getSession();\n\n\t\tWSRPProducer wsrpProducer = getWSRPProducer();\n\n\t\tString url = getURL(performBlockingInteraction, wsrpProducer);\n\n\t\tHttp.Options httpOptions = new Http.Options();\n\n\t\thttpOptions.setLocation(url);\n\t\thttpOptions.setPost(true);\n\n\t\tCookie[] cookies = (Cookie[])session.getAttribute(\"cookies\");\n\n\t\tif (cookies != null) {\n\t\t\thttpOptions.setCookies(cookies);\n\t\t}\n\n\t\tMarkupParams markupParams =\n\t\t\tperformBlockingInteraction.getMarkupParams();\n\n\t\taddHeaders(markupParams, httpOptions);\n\n\t\tPortletContext portletContext =\n\t\t\tperformBlockingInteraction.getPortletContext();\n\n\t\tInteractionParams interactionParams =\n\t\t\tperformBlockingInteraction.getInteractionParams();\n\n\t\tNamedString[] formParameters  = interactionParams.getFormParameters();\n\n\t\tfor (NamedString formParameter : formParameters) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(getPortletId(portletContext));\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(formParameter.getName());\n\n\t\t\thttpOptions.addPart(sb.toString(), formParameter.getValue());\n\t\t}\n\n\t\tString content = HttpUtil.URLtoString(httpOptions);\n\n\t\t// Cookies from HttpUtil\n\n\t\t// cookies = (Cookie[])objects[1];\n\n\t\tif (cookies != null) {\n\t\t\tsession.setAttribute(\"cookies\", cookies);\n\t\t}\n\n\t\tMarkupContext markupContext = new MarkupContext();\n\n\t\tmarkupContext.setItemString(content);\n\t\tmarkupContext.setRequiresRewriting(true);\n\n\t\tBlockingInteractionResponse blockingInteractionResponse =\n\t\t\tnew BlockingInteractionResponse();\n\n\t\t// Restore this once /widget is parsing content properly\n\n\t\t/*UpdateResponse updateResponse = new UpdateResponse();\n\n\t\tupdateResponse.setMarkupContext(markupContext);\n\n\t\tblockingInteractionResponse.setUpdateResponse(updateResponse);*/\n\n\t\treturn blockingInteractionResponse;\n\t}","id":32743,"modified_method":"protected BlockingInteractionResponse doPerformBlockingInteraction(\n\t\t\tPerformBlockingInteraction performBlockingInteraction)\n\t\tthrows Exception {\n\n\t\tWSRPProducer wsrpProducer = getWSRPProducer();\n\n\t\tHttp.Options httpOptions = new Http.Options();\n\n\t\taddHeaders(performBlockingInteraction.getMarkupParams(), httpOptions);\n\n\t\thttpOptions.setLocation(\n\t\t\tgetURL(performBlockingInteraction, wsrpProducer));\n\n\t\tPortletContext portletContext =\n\t\t\tperformBlockingInteraction.getPortletContext();\n\n\t\tInteractionParams interactionParams =\n\t\t\tperformBlockingInteraction.getInteractionParams();\n\n\t\tNamedString[] formParameters  = interactionParams.getFormParameters();\n\n\t\tfor (NamedString formParameter : formParameters) {\n\t\t\tString name =\n\t\t\t\tPortalUtil.getPortletNamespace(getPortletId(portletContext)) +\n\t\t\t\t\tformParameter.getName();\n\n\t\t\thttpOptions.addPart(name, formParameter.getValue());\n\t\t}\n\n\t\thttpOptions.setPost(true);\n\n\t\tString content = getContent(httpOptions);\n\n\t\tMarkupContext markupContext = new MarkupContext();\n\n\t\tmarkupContext.setItemString(content);\n\t\tmarkupContext.setRequiresRewriting(true);\n\n\t\tBlockingInteractionResponse blockingInteractionResponse =\n\t\t\tnew BlockingInteractionResponse();\n\n\t\tUpdateResponse updateResponse = new UpdateResponse();\n\n\t\tupdateResponse.setMarkupContext(markupContext);\n\n\t\tblockingInteractionResponse.setUpdateResponse(updateResponse);\n\n\t\treturn blockingInteractionResponse;\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getURL(\n\t\t\tString lifecycle, MarkupParams markupParams,\n\t\t\tPortletContext portletContext, WSRPProducer wsrpProducer)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request = ServletUtil.getRequest();\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(portalURL);\n\n\t\tif (lifecycle.equals(\"1\")) {\n\t\t\tsb.append(PortalUtil.getPathContext());\n\t\t\tsb.append(_PATH_WIDGET);\n\t\t}\n\t\telse {\n\t\t\tsb.append(PortalUtil.getPathMain());\n\t\t\tsb.append(_PATH_RENDER_PORTLET);\n\t\t}\n\n\t\tsb.append(StringPool.QUESTION);\n\n\t\tLayout layout = getLayout(portletContext, wsrpProducer);\n\n\t\tsb.append(\"p_l_id=\");\n\t\tsb.append(layout.getPlid());\n\n\t\tString portletId = getPortletId(portletContext);\n\n\t\tsb.append(\"&p_p_id=\");\n\t\tsb.append(HttpUtil.encodeURL(portletId));\n\n\t\tsb.append(\"&p_p_lifecycle=\");\n\t\tsb.append(lifecycle);\n\n\t\tsb.append(\"&p_p_state=exclusive\");\n\n\t\tString portletMode = getPortletMode(markupParams);\n\n\t\tsb.append(\"&p_p_mode=\");\n\t\tsb.append(HttpUtil.encodeURL(portletMode));\n\n\t\tNavigationalContext navigationalContext =\n\t\t\tmarkupParams.getNavigationalContext();\n\n\t\tif (navigationalContext != null) {\n\t\t\tString opaqueValue = navigationalContext.getOpaqueValue();\n\n\t\t\tif (Validator.isNotNull(opaqueValue)) {\n\t\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\t\tsb.append(HttpUtil.decodeURL(opaqueValue));\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"&wsrp=1\");\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"URL \" + sb.toString());\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":32744,"modified_method":"protected String getURL(\n\t\t\tString lifecycle, MarkupParams markupParams,\n\t\t\tPortletContext portletContext, WSRPProducer wsrpProducer)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request = ServletUtil.getRequest();\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(portalURL);\n\t\tsb.append(PortalUtil.getPathContext());\n\t\tsb.append(_PATH_WIDGET);\n\n\t\tLayout layout = getLayout(portletContext, wsrpProducer);\n\n\t\tsb.append(\"p_l_id=\");\n\t\tsb.append(layout.getPlid());\n\n\t\tString portletId = getPortletId(portletContext);\n\n\t\tsb.append(\"&p_p_id=\");\n\t\tsb.append(HttpUtil.encodeURL(portletId));\n\n\t\tsb.append(\"&p_p_lifecycle=\");\n\t\tsb.append(lifecycle);\n\n\t\tString windowState = getWindowState(markupParams);\n\n\t\tsb.append(\"&p_p_state=\");\n\t\tsb.append(HttpUtil.encodeURL(windowState));\n\n\t\tString portletMode = getPortletMode(markupParams);\n\n\t\tsb.append(\"&p_p_mode=\");\n\t\tsb.append(HttpUtil.encodeURL(portletMode));\n\n\t\tNavigationalContext navigationalContext =\n\t\t\tmarkupParams.getNavigationalContext();\n\n\t\tif (navigationalContext != null) {\n\t\t\tString opaqueValue = navigationalContext.getOpaqueValue();\n\n\t\t\tif (Validator.isNotNull(opaqueValue)) {\n\t\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\t\tsb.append(HttpUtil.decodeURL(opaqueValue));\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"&wsrp=1\");\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"URL \" + sb.toString());\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Extension[] doInitCookie(InitCookie initCookie) throws Exception {\n\t\tServletUtil.getRequest().getSession();\n\n\t\treturn null;\n\t}","id":32745,"modified_method":"protected Extension[] doInitCookie(InitCookie initCookie) throws Exception {\n\t\tServletUtil.getSession();\n\n\t\treturn null;\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void run() {\n\t\ttry {\n\n\t\t\t// Wait 5 seconds before initializing consumer portlets in case the\n\t\t\t// consumer and producer are the same machine\n\n\t\t\tThread.sleep(5000);\n\n\t\t\tWSRPConsumerPortletLocalServiceUtil.initWSRPConsumerPortlets();\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":32746,"modified_method":"public void run() {\n\t\ttry {\n\n\t\t\t// Wait 3 seconds before initializing consumer portlets in case the\n\t\t\t// consumer and producer are the same machine\n\n\t\t\tThread.sleep(3000);\n\n\t\t\tWSRPConsumerPortletLocalServiceUtil.initWSRPConsumerPortlets();\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"4d41d9d17273c472142b30f3efe57fbd4c73f244","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        try {\n            String path = req.getPathInfo();\n            //Make sure path is valid\n            if (path == null) {\n                resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                return;\n            }\n            if (path.startsWith(\"/\")) {\n                path = path.substring(1);\n            }\n\n            // handle move\n            String location = req.getHeader(LOCATION_HEADER);\n            if (location != null) {\n                UploadContext result = move(location, path);\n                addHeaders(resp, result.headers());\n                resp.setStatus(HttpServletResponse.SC_ACCEPTED);\n                return;\n            }\n\n            UploadContext result = doUpload(req.getInputStream(), path);\n            if (result.status()) {\n                addHeaders(resp, result.headers());\n\n                String profile = req.getParameter(\"profile\");\n                String version = req.getParameter(\"version\");\n                if (profile != null && version != null) {\n                    ProjectRequirements requirements = toProjectRequirements(result);\n                    requirements.setProfileId(profile);\n                    requirements.setVersion(version);\n\n                    DeployResults deployResults = addToProfile(requirements);\n                    LOGGER.info(String.format(\"Deployed artifact %s to profile: %s\", result.toArtifact(), deployResults));\n                }\n\n                resp.setStatus(HttpServletResponse.SC_ACCEPTED);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);\n            }\n        } catch (InvalidMavenArtifactRequest ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        } catch (Exception ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        }\n\n    }","id":32747,"modified_method":"@Override\n    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        try {\n            String path = req.getPathInfo();\n            //Make sure path is valid\n            if (path == null) {\n                resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                return;\n            }\n            if (path.startsWith(\"/\")) {\n                path = path.substring(1);\n            }\n\n            UploadContext result;\n            // handle move\n            String location = req.getHeader(LOCATION_HEADER);\n            if (location != null) {\n                result = move(location, path);\n            } else {\n                result = doUpload(req.getInputStream(), path);\n            }\n\n            if (result.status()) {\n                handleDeploy(req, result);\n\n                addHeaders(resp, result.headers());\n\n                resp.setStatus(HttpServletResponse.SC_ACCEPTED);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);\n            }\n        } catch (InvalidMavenArtifactRequest ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        } catch (Exception ex) {\n            // must response with status and flush as Jetty may report org.eclipse.jetty.server.Response Committed before 401 null\n            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            resp.setContentLength(0);\n            resp.flushBuffer();\n        }\n\n    }","commit_id":"df9d9cd73834f9bcf795725f9a3fa80f64d86a6e","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"monitor\", new MonitorChannelHandler( byteCounterMonitor ) );\n        addLengthFieldPipes( pipeline, frameLength );\n        BlockingReadHandler<ChannelBuffer> reader =\n                new BlockingReadHandler<>( new ArrayBlockingQueue<ChannelEvent>( 100, false ) );\n        pipeline.addLast( \"blockingHandler\", reader );\n        return pipeline;\n    }","id":32748,"modified_method":"@Override\n    public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( MONITORING_CHANNEL_HANDLER_NAME, new MonitorChannelHandler( byteCounterMonitor ) );\n        addLengthFieldPipes( pipeline, frameLength );\n        BlockingReadHandler<ChannelBuffer> reader =\n                new BlockingReadHandler<>( new ArrayBlockingQueue<ChannelEvent>( 100, false ) );\n        pipeline.addLast( BLOCKING_CHANNEL_HANDLER_NAME, reader );\n        return pipeline;\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected <R> Response<R> sendRequest( RequestType<T> type, RequestContext context,\n            Serializer serializer, Deserializer<R> deserializer,\n            StoreId specificStoreId, TxHandler txHandler )\n    {\n        boolean success = true;\n        Triplet<Channel,ChannelBuffer,ByteBuffer> channelContext;\n        Throwable failure = null;\n\n        // Send 'em over the wire\n        Channel channel;\n        ChannelBuffer output;\n        ByteBuffer input;\n        try\n        {\n            channelContext = getChannel( type );\n            channel = channelContext.first();\n            output = channelContext.second();\n            input = channelContext.third();\n        }\n        catch ( Throwable e )\n        {\n            throw Exceptions.launderedException( ComException.class, e );\n        }\n\n        try\n        {\n            notifyRequestMonitor( type, context, channel );\n\n            // Request\n            protocol.serializeRequest( channel, output, type, context, serializer );\n\n            // Response\n            @SuppressWarnings( \"unchecked\" )\n            Response<R> response = protocol.deserializeResponse(\n                    (BlockingReadHandler<ChannelBuffer>) channel.getPipeline().get( \"blockingHandler\" ), input,\n                    getReadTimeout( type, readTimeout ), deserializer, resourcePoolReleaser );\n\n            if ( type.responseShouldBeUnpacked() )\n            {\n                responseUnpacker.unpackResponse( response, txHandler );\n            }\n\n            if ( shouldCheckStoreId( type ) )\n            {\n                // specificStoreId is there as a workaround for then the graphDb isn't initialized yet\n                if ( specificStoreId != null )\n                {\n                    assertCorrectStoreId( response.getStoreId(), specificStoreId );\n                }\n                else\n                {\n                    assertCorrectStoreId( response.getStoreId(), storeId );\n                }\n            }\n\n            return response;\n        }\n        catch ( ComException e )\n        {\n            failure = e;\n            success = false;\n            comExceptionHandler.handle( e );\n            throw e;\n        }\n        catch ( Throwable e )\n        {\n            failure = e;\n            success = false;\n            if ( channelContext != null )\n            {\n                closeChannel( channelContext );\n            }\n            throw Exceptions.launderedException( ComException.class, e );\n        }\n        finally\n        {\n            /*\n             * Otherwise the user must call response.close() to prevent resource leaks.\n             */\n            if ( !success )\n            {\n                releaseChannel();\n            }\n            requestMonitor.endRequest( failure );\n        }\n    }","id":32749,"modified_method":"protected <R> Response<R> sendRequest( RequestType<T> type, RequestContext context,\n            Serializer serializer, Deserializer<R> deserializer,\n            StoreId specificStoreId, TxHandler txHandler )\n    {\n        ChannelContext channelContext = acquireChannelContext( type );\n\n        Throwable failure = null;\n        try\n        {\n            requestMonitor.beginRequest( channelContext.channel().getRemoteAddress(), type, context );\n\n            // Request\n            protocol.serializeRequest( channelContext.channel(), channelContext.output(), type, context, serializer );\n\n            // Response\n            Response<R> response = protocol.deserializeResponse( extractBlockingReadHandler( channelContext ),\n                    channelContext.input(), getReadTimeout( type, readTimeout ), deserializer, resourcePoolReleaser );\n\n            if ( type.responseShouldBeUnpacked() )\n            {\n                responseUnpacker.unpackResponse( response, txHandler );\n            }\n\n            if ( shouldCheckStoreId( type ) )\n            {\n                // specificStoreId is there as a workaround for then the graphDb isn't initialized yet\n                if ( specificStoreId != null )\n                {\n                    assertCorrectStoreId( response.getStoreId(), specificStoreId );\n                }\n                else\n                {\n                    assertCorrectStoreId( response.getStoreId(), storeId );\n                }\n            }\n\n            return response;\n        }\n        catch ( ComException e )\n        {\n            failure = e;\n            comExceptionHandler.handle( e );\n            throw e;\n        }\n        catch ( Throwable e )\n        {\n            failure = e;\n            throw Exceptions.launderedException( ComException.class, e );\n        }\n        finally\n        {\n            /*\n             * Otherwise the user must call response.close() to prevent resource leaks.\n             */\n            if ( failure != null )\n            {\n                dispose( channelContext );\n            }\n            requestMonitor.endRequest( failure );\n        }\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Triplet<Channel,ChannelBuffer,ByteBuffer> getChannel( RequestType<T> type ) throws Exception\n    {\n        // Calling acquire is dangerous since it may be a blocking call... and if this\n        // thread holds a lock which others may want to be able to communicate with\n        // the server things go stiff.\n        Triplet<Channel,ChannelBuffer,ByteBuffer> result = channelPool.acquire();\n        if ( result == null )\n        {\n            msgLog.error( \"Unable to acquire new channel for \" + type );\n            throw new ComException( \"Unable to acquire new channel for \" + type );\n        }\n        return result;\n    }","id":32750,"modified_method":"private ChannelContext acquireChannelContext( RequestType<T> type )\n    {\n        try\n        {\n            // Calling acquire is dangerous since it may be a blocking call... and if this\n            // thread holds a lock which others may want to be able to communicate with\n            // the server things go stiff.\n            ChannelContext result = channelPool.acquire();\n            if ( result == null )\n            {\n                msgLog.error( \"Unable to acquire new channel for \" + type );\n                throw new ComException( \"Unable to acquire new channel for \" + type );\n            }\n            return result;\n        }\n        catch ( Throwable e )\n        {\n            throw Exceptions.launderedException( ComException.class, e );\n        }\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void start()\n    {\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                newCachedThreadPool( daemon( getClass().getSimpleName() + \"-boss@\" + address ) ),\n                newCachedThreadPool( daemon( getClass().getSimpleName() + \"-worker@\" + address ) ) ) );\n        bootstrap.setPipelineFactory( this );\n\n        channelPool = new ResourcePool<Triplet<Channel,ChannelBuffer,ByteBuffer>>( maxUnusedChannels,\n                new ResourcePool.CheckStrategy.TimeoutCheckStrategy( DEFAULT_CHECK_INTERVAL, SYSTEM_CLOCK ),\n                new LoggingResourcePoolMonitor( msgLog ) )\n        {\n            @Override\n            protected Triplet<Channel,ChannelBuffer,ByteBuffer> create()\n            {\n                ChannelFuture channelFuture = bootstrap.connect( address );\n                channelFuture.awaitUninterruptibly( 5, TimeUnit.SECONDS );\n                Triplet<Channel,ChannelBuffer,ByteBuffer> channel;\n                if ( channelFuture.isSuccess() )\n                {\n                    channel = Triplet.of( channelFuture.getChannel(),\n                            ChannelBuffers.dynamicBuffer(),\n                            ByteBuffer.allocate( 1024 * 1024 ) );\n                    msgLog.logMessage( \"Opened a new channel to \" + address, true );\n                    return channel;\n                }\n\n                String msg = Client.this.getClass().getSimpleName() + \" could not connect to \" + address;\n                msgLog.logMessage( msg, true );\n                throw new ComException( msg, channelFuture.getCause() );\n            }\n\n            @Override\n            protected boolean isAlive( Triplet<Channel,ChannelBuffer,ByteBuffer> resource )\n            {\n                return resource.first().isConnected();\n            }\n\n            @Override\n            protected void dispose( Triplet<Channel,ChannelBuffer,ByteBuffer> resource )\n            {\n                Channel channel = resource.first();\n                if ( channel.isConnected() )\n                {\n                    msgLog.debug( \"Closing channel: \" + channel + \". Channel pool size is now \" + currentSize() );\n                    channel.close();\n                }\n            }\n        };\n        /*\n         * This is here to couple the channel releasing to Response.close() itself and not\n         * to TransactionStream.close() as it is implemented here. The reason is that a Response\n         * that is returned without a TransactionStream will still hold the channel and should\n         * release it eventually. Also, logically, closing the channel is not dependent on the\n         * TransactionStream.\n         */\n        resourcePoolReleaser = new ResourceReleaser()\n        {\n            @Override\n            public void release()\n            {\n                channelPool.release();\n            }\n        };\n    }","id":32751,"modified_method":"@Override\n    public void start()\n    {\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                newCachedThreadPool( daemon( getClass().getSimpleName() + \"-boss@\" + address ) ),\n                newCachedThreadPool( daemon( getClass().getSimpleName() + \"-worker@\" + address ) ) ) );\n        bootstrap.setPipelineFactory( this );\n\n        channelPool = new ResourcePool<ChannelContext>( maxUnusedChannels,\n                new ResourcePool.CheckStrategy.TimeoutCheckStrategy( DEFAULT_CHECK_INTERVAL, SYSTEM_CLOCK ),\n                new LoggingResourcePoolMonitor( msgLog ) )\n        {\n            @Override\n            protected ChannelContext create()\n            {\n                ChannelFuture channelFuture = bootstrap.connect( address );\n                channelFuture.awaitUninterruptibly( 5, TimeUnit.SECONDS );\n                if ( channelFuture.isSuccess() )\n                {\n                    msgLog.logMessage( threadInfo() + \"Opened a new channel to \" + address, true );\n\n                    return new ChannelContext( channelFuture.getChannel(), ChannelBuffers.dynamicBuffer(),\n                            ByteBuffer.allocate( 1024 * 1024 ) );\n                }\n\n                String msg = Client.this.getClass().getSimpleName() + \" could not connect to \" + address;\n                msgLog.logMessage( msg, true );\n                throw new ComException( msg, channelFuture.getCause() );\n            }\n\n            @Override\n            protected boolean isAlive( ChannelContext context )\n            {\n                return context.channel().isConnected();\n            }\n\n            @Override\n            protected void dispose( ChannelContext context )\n            {\n                Channel channel = context.channel();\n                if ( channel.isConnected() )\n                {\n                    msgLog.logMessage( threadInfo() + \"Closing: \" + context + \". \" +\n                                       \"Channel pool size is now \" + currentSize(), true );\n                    channel.close();\n                }\n            }\n\n            private String threadInfo()\n            {\n                return \"Thread[\" + Thread.currentThread().getId() + \", \" + Thread.currentThread().getName() + \"] \";\n            }\n        };\n        /*\n         * This is here to couple the channel releasing to Response.close() itself and not\n         * to TransactionStream.close() as it is implemented here. The reason is that a Response\n         * that is returned without a TransactionStream will still hold the channel and should\n         * release it eventually. Also, logically, closing the channel is not dependent on the\n         * TransactionStream.\n         */\n        resourcePoolReleaser = new ResourceReleaser()\n        {\n            @Override\n            public void release()\n            {\n                channelPool.release();\n            }\n        };\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowForcedElectionsAfterModeSwitch() throws Throwable\n    {\n        // Given\n        SwitchToSlave switchToSlave = mock( SwitchToSlave.class );\n        when( switchToSlave.switchToSlave( any( LifeSupport.class ), any( URI.class ), any( URI.class ),\n                any( CancellationRequest.class ) ) ).thenReturn( URI.create( \"http://localhost\" ) );\n        ClusterMemberAvailability memberAvailability = mock( ClusterMemberAvailability.class );\n        Election election = mock( Election.class );\n\n        final CountDownLatch modeSwitchHappened = new CountDownLatch( 1 );\n\n        HighAvailabilityModeSwitcher modeSwitcher = new HighAvailabilityModeSwitcher( switchToSlave,\n                mock( SwitchToMaster.class ), election, memberAvailability, dependencyResolverMock(),\n                mock( InstanceId.class ), new DevNullLoggingService() )\n        {\n            @Override\n            ScheduledExecutorService createExecutor()\n            {\n                ScheduledExecutorService executor = mock( ScheduledExecutorService.class );\n\n                doAnswer( new Answer()\n                {\n                    @Override\n                    public Object answer( InvocationOnMock invocation ) throws Throwable\n                    {\n                        ((Runnable) invocation.getArguments()[0]).run();\n                        modeSwitchHappened.countDown();\n                        return mock( Future.class );\n                    }\n                } ).when( executor ).submit( any( Runnable.class ) );\n\n                return executor;\n            }\n        };\n\n        modeSwitcher.init();\n        modeSwitcher.start();\n\n        modeSwitcher.forceElections();\n        reset( memberAvailability, election );\n\n        // When\n        modeSwitcher.masterIsAvailable( new HighAvailabilityMemberChangeEvent( PENDING, TO_SLAVE, mock( InstanceId\n                .class ),\n                URI.create( \"http://localhost:9090?serverId=42\" ) ) );\n        modeSwitchHappened.await();\n        modeSwitcher.forceElections();\n\n        // Then\n        InOrder inOrder = inOrder( memberAvailability, election );\n        inOrder.verify( memberAvailability ).memberIsUnavailable( HighAvailabilityModeSwitcher.SLAVE );\n        inOrder.verify( election ).performRoleElections();\n        inOrder.verifyNoMoreInteractions();\n    }","id":32752,"modified_method":"@Test\n    public void shouldAllowForcedElectionsAfterModeSwitch() throws Throwable\n    {\n        // Given\n        SwitchToSlave switchToSlave = mock( SwitchToSlave.class );\n        when( switchToSlave.switchToSlave( any( LifeSupport.class ), any( URI.class ), any( URI.class ),\n                any( CancellationRequest.class ) ) ).thenReturn( URI.create( \"http://localhost\" ) );\n        ClusterMemberAvailability memberAvailability = mock( ClusterMemberAvailability.class );\n        Election election = mock( Election.class );\n\n        final CountDownLatch modeSwitchHappened = new CountDownLatch( 1 );\n\n        HighAvailabilityModeSwitcher modeSwitcher = new HighAvailabilityModeSwitcher( switchToSlave,\n                mock( SwitchToMaster.class ), election, memberAvailability, dependencyResolverMock(),\n                mock( InstanceId.class ), new DevNullLoggingService() )\n        {\n            @Override\n            ScheduledExecutorService createExecutor()\n            {\n                ScheduledExecutorService executor = mock( ScheduledExecutorService.class );\n\n                doAnswer( new Answer<Future<?>>()\n                {\n                    @Override\n                    public Future<?> answer( InvocationOnMock invocation ) throws Throwable\n                    {\n                        ((Runnable) invocation.getArguments()[0]).run();\n                        modeSwitchHappened.countDown();\n                        return mock( Future.class );\n                    }\n                } ).when( executor ).submit( any( Runnable.class ) );\n\n                return executor;\n            }\n        };\n\n        modeSwitcher.init();\n        modeSwitcher.start();\n\n        modeSwitcher.forceElections();\n        reset( memberAvailability, election );\n\n        // When\n        modeSwitcher.masterIsAvailable( new HighAvailabilityMemberChangeEvent( PENDING, TO_SLAVE, mock( InstanceId\n                .class ),\n                URI.create( \"http://localhost:9090?serverId=42\" ) ) );\n        modeSwitchHappened.await();\n        modeSwitcher.forceElections();\n\n        // Then\n        InOrder inOrder = inOrder( memberAvailability, election );\n        inOrder.verify( memberAvailability ).memberIsUnavailable( HighAvailabilityModeSwitcher.SLAVE );\n        inOrder.verify( election ).performRoleElections();\n        inOrder.verifyNoMoreInteractions();\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected ResourcePool( int minSize )\n    {\n        this( minSize, new CheckStrategy.TimeoutCheckStrategy( DEFAULT_CHECK_INTERVAL, SYSTEM_CLOCK ), new Monitor.Adapter() );\n    }","id":32753,"modified_method":"protected ResourcePool( int minSize )\n    {\n        this( minSize, new CheckStrategy.TimeoutCheckStrategy( DEFAULT_CHECK_INTERVAL, SYSTEM_CLOCK ),\n                new Monitor.Adapter<R>() );\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public final R acquire()\n    {\n        Thread thread = Thread.currentThread();\n        R resource = current.get( thread );\n        if ( resource == null )\n        {\n            List<R> garbage = null;\n            synchronized ( unused )\n            {\n                for (; ; )\n                {\n                    resource = unused.poll();\n                    if ( resource == null )\n                    {\n                        break;\n                    }\n                    if ( isAlive( resource ) )\n                    {\n                        break;\n                    }\n                    if ( garbage == null )\n                    {\n                        garbage = new LinkedList<R>();\n                    }\n                    garbage.add( resource );\n                }\n            }\n            if ( resource == null )\n            {\n                resource = create();\n                monitor.created( resource );\n            }\n            current.put( thread, resource );\n            monitor.acquired( resource );\n            if ( garbage != null )\n            {\n                for ( R dead : garbage )\n                {\n                    dispose( dead );\n                    monitor.disposed( dead );\n                }\n            }\n        }\n        currentPeakSize = Math.max( currentPeakSize, current.size() );\n        if ( checkStrategy.shouldCheck() )\n        {\n            targetSize = Math.max( minSize, currentPeakSize );\n            monitor.updatedCurrentPeakSize( currentPeakSize );\n            currentPeakSize = 0;\n            monitor.updatedTargetSize( targetSize );\n        }\n\n        return resource;\n    }","id":32754,"modified_method":"public final R acquire()\n    {\n        Thread thread = Thread.currentThread();\n        R resource = current.get( thread );\n        if ( resource == null )\n        {\n            List<R> garbage = null;\n            synchronized ( unused )\n            {\n                for (; ; )\n                {\n                    resource = unused.poll();\n                    if ( resource == null )\n                    {\n                        break;\n                    }\n                    if ( isAlive( resource ) )\n                    {\n                        break;\n                    }\n                    if ( garbage == null )\n                    {\n                        garbage = new LinkedList<>();\n                    }\n                    garbage.add( resource );\n                }\n            }\n            if ( resource == null )\n            {\n                resource = create();\n                monitor.created( resource );\n            }\n            current.put( thread, resource );\n            monitor.acquired( resource );\n            if ( garbage != null )\n            {\n                for ( R dead : garbage )\n                {\n                    dispose( dead );\n                    monitor.disposed( dead );\n                }\n            }\n        }\n        currentPeakSize = Math.max( currentPeakSize, current.size() );\n        if ( checkStrategy.shouldCheck() )\n        {\n            targetSize = Math.max( minSize, currentPeakSize );\n            monitor.updatedCurrentPeakSize( currentPeakSize );\n            currentPeakSize = 0;\n            monitor.updatedTargetSize( targetSize );\n        }\n\n        return resource;\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public final void close( boolean force )\n    {\n        List<R> dead = new LinkedList<R>();\n        synchronized ( unused )\n        {\n            dead.addAll( unused );\n            unused.clear();\n        }\n        if ( force )\n        {\n            dead.addAll( current.values() );\n        }\n        for ( R resource : dead )\n        {\n            dispose( resource );\n        }\n    }","id":32755,"modified_method":"public final void close( boolean force )\n    {\n        List<R> dead = new LinkedList<>();\n        synchronized ( unused )\n        {\n            dead.addAll( unused );\n            unused.clear();\n        }\n        if ( force )\n        {\n            dead.addAll( current.values() );\n        }\n        for ( R resource : dead )\n        {\n            dispose( resource );\n        }\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected ResourcePool( int minSize, CheckStrategy strategy, Monitor monitor )\n    {\n        this.minSize = minSize;\n        this.currentPeakSize = 0;\n        this.targetSize = minSize;\n        this.checkStrategy = strategy;\n        this.monitor = monitor;\n    }","id":32756,"modified_method":"protected ResourcePool( int minSize, CheckStrategy strategy, Monitor<R> monitor )\n    {\n        this.minSize = minSize;\n        this.currentPeakSize = 0;\n        this.targetSize = minSize;\n        this.checkStrategy = strategy;\n        this.monitor = monitor;\n    }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        @SuppressWarnings( \"unchecked\" )\n        public void run()\n        {\n            Map<String,String> requestContext = new HashMap<>();\n            requestContext.put( \"type\", type.toString() );\n            requestContext.put( \"remoteClient\", channel.getRemoteAddress().toString() );\n            requestContext.put( \"slaveContext\", context.toString() );\n            requestMonitor.beginRequest( requestContext );\n            Response<R> response = null;\n            Throwable failure = null;\n            try\n            {\n                unmapSlave( channel );\n                response = type.getTargetCaller().call( requestTarget, context, bufferToReadFrom, targetBuffer );\n                type.getObjectSerializer().write( response.response(), targetBuffer );\n                writeStoreId( response.getStoreId(), targetBuffer );\n                response.accept( this );\n                targetBuffer.done();\n                responseWritten( type, channel, context );\n            }\n            catch ( Throwable e )\n            {\n                failure = e;\n                targetBuffer.clear( true );\n                writeFailureResponse( e, targetBuffer );\n                tryToFinishOffChannel( channel, context );\n                throw Exceptions.launderedException( e );\n            }\n            finally\n            {\n                if ( response != null )\n                {\n                    response.close();\n                }\n                requestMonitor.endRequest( failure );\n            }\n        }","id":32757,"modified_method":"@Override\n        @SuppressWarnings( \"unchecked\" )\n        public void run()\n        {\n            requestMonitor.beginRequest( channel.getRemoteAddress(), type, context );\n            Response<R> response = null;\n            Throwable failure = null;\n            try\n            {\n                unmapSlave( channel );\n                response = type.getTargetCaller().call( requestTarget, context, bufferToReadFrom, targetBuffer );\n                type.getObjectSerializer().write( response.response(), targetBuffer );\n                writeStoreId( response.getStoreId(), targetBuffer );\n                response.accept( this );\n                targetBuffer.done();\n                responseWritten( type, channel, context );\n            }\n            catch ( Throwable e )\n            {\n                failure = e;\n                targetBuffer.clear( true );\n                writeFailureResponse( e, targetBuffer );\n                tryToFinishOffChannel( channel, context );\n                throw Exceptions.launderedException( e );\n            }\n            finally\n            {\n                if ( response != null )\n                {\n                    response.close();\n                }\n                requestMonitor.endRequest( failure );\n            }\n        }","commit_id":"d6dd440c5057e80c73d75c2367b178b8972de75d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public GetObjectResponseType getObject(GetObjectType request) throws EucalyptusCloudException {\n\t\tGetObjectResponseType reply = (GetObjectResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tString userId = request.getUserId();\n\t\tBoolean deleteAfterGet = request.getDeleteAfterGet();\n\t\tif(deleteAfterGet == null)\n\t\t\tdeleteAfterGet = false;\n\n\t\tBoolean getTorrent = request.getGetTorrent();\n\t\tif(getTorrent == null)\n\t\t\tgetTorrent = false;\n\n\t\tBoolean getMetaData = request.getGetMetaData();\n\t\tif(getMetaData == null)\n\t\t\tgetMetaData = false;\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif(objectInfo.canRead(userId)) {\n\t\t\t\t\tString objectName = objectInfo.getObjectName();\n\t\t\t\t\tDefaultHttpResponse httpResponse = new DefaultHttpResponse( HttpVersion.HTTP_1_1, HttpResponseStatus.OK ); \n\t\t\t\t\tif(getMetaData) {\n\t\t\t\t\t\tList<MetaDataInfo> metaDataInfos = objectInfo.getMetaData();\n\t\t\t\t\t\tfor(MetaDataInfo metaDataInfo : metaDataInfos) {\n\t\t\t\t\t\t\thttpResponse.addHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataInfo.getName(), metaDataInfo.getValue());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(getTorrent) {\n\t\t\t\t\t\tif(objectInfo.isGlobalRead()) {\n\t\t\t\t\t\t\tif(!WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Torrents disabled\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo;\n\t\t\t\t\t\t\tString absoluteObjectPath = storageManager.getObjectPath(bucketName, objectName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfoundTorrentInfo = dbTorrent.getUnique(torrentInfo);\n\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tString torrentFile = objectName + \".torrent\";\n\t\t\t\t\t\t\t\tString torrentFilePath = storageManager.getObjectPath(bucketName, torrentFile);\n\t\t\t\t\t\t\t\tTorrentCreator torrentCreator = new TorrentCreator(absoluteObjectPath, objectKey, objectName, torrentFilePath, WalrusProperties.TRACKER_URL);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttorrentCreator.create();\n\t\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\t\tLOG.error(e);\n\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"could not create torrent file \" + torrentFile);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttorrentInfo.setTorrentFile(torrentFile);\n\t\t\t\t\t\t\t\tdbTorrent.add(torrentInfo);\n\t\t\t\t\t\t\t\tfoundTorrentInfo = torrentInfo;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.commit();\n\t\t\t\t\t\t\tString torrentFile = foundTorrentInfo.getTorrentFile();\n\t\t\t\t\t\t\tString torrentFilePath = storageManager.getObjectPath(bucketName, torrentFile);\n\t\t\t\t\t\t\tTorrentClient torrentClient = new TorrentClient(torrentFilePath, absoluteObjectPath);\n\t\t\t\t\t\t\tTorrents.addClient(bucketName + objectKey, torrentClient);\n\t\t\t\t\t\t\ttorrentClient.start();\n\t\t\t\t\t\t\t//send torrent\n\t\t\t\t\t\t\tString key = bucketName + \".\" + objectKey;\n\t\t\t\t\t\t\tString randomKey = key + \".\" + Hashes.getRandom(10);\n\t\t\t\t\t\t\trequest.setRandomKey(randomKey);\n\n\t\t\t\t\t\t\tFile torrent = new File(torrentFilePath);\n\t\t\t\t\t\t\tif(torrent.exists()) {\n\t\t\t\t\t\t\t\tDate lastModified = objectInfo.getLastModified();\n\t\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\t\tlong torrentLength = torrent.length();\n\t\t\t\t\t\t\t\tstorageManager.sendObject(request.getChannel(), httpResponse, bucketName, torrentFile, torrentLength, null, \n\t\t\t\t\t\t\t\t\t\tDateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\", \n\t\t\t\t\t\t\t\t\t\t\"application/x-bittorrent\", \"attachment; filename=\" + objectKey + \".torrent;\", request.getIsCompressed());\n\t\t\t\t\t\t\t\t//TODO: this should reflect params for the torrent?\n\t\t\t\t\t\t\t\treply.setEtag(\"\");\n\t\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN));\n\t\t\t\t\t\t\t\treply.setSize(torrentLength);\n\t\t\t\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\t\t\t\tstatus.setCode(200);\n\t\t\t\t\t\t\t\tstatus.setDescription(\"OK\");\n\t\t\t\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\t\t\t\treply.setContentType(\"binary/octet-stream\");\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesOut(torrentLength);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\t\t\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t\tlogData.setObjectSize(torrentLength);\n\t\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tString errorString = \"Could not get torrent file \" + torrentFilePath;\n\t\t\t\t\t\t\t\tLOG.error(errorString);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(errorString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDate lastModified = objectInfo.getLastModified();\n\t\t\t\t\tLong size = objectInfo.getSize();\n\t\t\t\t\tString etag = objectInfo.getEtag();\n\t\t\t\t\tString contentType = objectInfo.getContentType();\n\t\t\t\t\tString contentDisposition = objectInfo.getContentDisposition();\n\t\t\t\t\tdb.commit();\n\t\t\t\t\tif(request.getGetData()) {\n\t\t\t\t\t\tif(request.getInlineData()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbyte[] bytes = new byte[102400/*TODO: NEIL WalrusQueryDispatcher.DATA_MESSAGE_SIZE*/];\n\t\t\t\t\t\t\t\tint bytesRead = 0;\n\t\t\t\t\t\t\t\tString base64Data = \"\";\n\t\t\t\t\t\t\t\twhile((bytesRead = storageManager.readObject(bucketName, objectName, bytes, bytesRead)) > 0) {\n\t\t\t\t\t\t\t\t\tbase64Data += new String(bytes, 0, bytesRead);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treply.setBase64Data(base64Data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t//set error code\n\t\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//support for large objects\n\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\twalrusStatistics.updateBytesOut(objectInfo.getSize());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstorageManager.sendObject(request.getChannel(), httpResponse, bucketName, objectName, size, etag, \n\t\t\t\t\t\t\t\t\tDateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\", \n\t\t\t\t\t\t\t\t\tcontentType, contentDisposition, request.getIsCompressed());                            \n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstorageManager.sendHeaders(request.getChannel(), httpResponse, size, etag, \n\t\t\t\t\t\t\t\tDateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\", \n\t\t\t\t\t\t\t\tcontentType, contentDisposition);                            \n\n\t\t\t\t\t}\n\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified, DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\t\treply.setSize(size);\n\t\t\t\t\treply.setContentType(contentType);\n\t\t\t\t\treply.setContentDisposition(contentDisposition);\n\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\tstatus.setCode(200);\n\t\t\t\t\tstatus.setDescription(\"OK\");\n\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\treturn reply;\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t}","id":32758,"modified_method":"public GetObjectResponseType getObject(GetObjectType request) throws EucalyptusCloudException {\n\t\tGetObjectResponseType reply = (GetObjectResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tString userId = request.getUserId();\n\t\tBoolean deleteAfterGet = request.getDeleteAfterGet();\n\t\tif(deleteAfterGet == null)\n\t\t\tdeleteAfterGet = false;\n\n\t\tBoolean getTorrent = request.getGetTorrent();\n\t\tif(getTorrent == null)\n\t\t\tgetTorrent = false;\n\n\t\tBoolean getMetaData = request.getGetMetaData();\n\t\tif(getMetaData == null)\n\t\t\tgetMetaData = false;\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif(objectInfo.canRead(userId)) {\n\t\t\t\t\tString objectName = objectInfo.getObjectName();\n\t\t\t\t\tDefaultHttpResponse httpResponse = new DefaultHttpResponse( HttpVersion.HTTP_1_1, HttpResponseStatus.OK ); \n\t\t\t\t\tif(getMetaData) {\n\t\t\t\t\t\tList<MetaDataInfo> metaDataInfos = objectInfo.getMetaData();\n\t\t\t\t\t\tfor(MetaDataInfo metaDataInfo : metaDataInfos) {\n\t\t\t\t\t\t\thttpResponse.addHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataInfo.getName(), metaDataInfo.getValue());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(getTorrent) {\n\t\t\t\t\t\tif(objectInfo.isGlobalRead()) {\n\t\t\t\t\t\t\tif(!WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Torrents disabled\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo;\n\t\t\t\t\t\t\tString absoluteObjectPath = storageManager.getObjectPath(bucketName, objectName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfoundTorrentInfo = dbTorrent.getUnique(torrentInfo);\n\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tString torrentFile = objectName + \".torrent\";\n\t\t\t\t\t\t\t\tString torrentFilePath = storageManager.getObjectPath(bucketName, torrentFile);\n\t\t\t\t\t\t\t\tTorrentCreator torrentCreator = new TorrentCreator(absoluteObjectPath, objectKey, objectName, torrentFilePath, WalrusProperties.TRACKER_URL);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttorrentCreator.create();\n\t\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\t\tLOG.error(e);\n\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"could not create torrent file \" + torrentFile);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttorrentInfo.setTorrentFile(torrentFile);\n\t\t\t\t\t\t\t\tdbTorrent.add(torrentInfo);\n\t\t\t\t\t\t\t\tfoundTorrentInfo = torrentInfo;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.commit();\n\t\t\t\t\t\t\tString torrentFile = foundTorrentInfo.getTorrentFile();\n\t\t\t\t\t\t\tString torrentFilePath = storageManager.getObjectPath(bucketName, torrentFile);\n\t\t\t\t\t\t\tTorrentClient torrentClient = new TorrentClient(torrentFilePath, absoluteObjectPath);\n\t\t\t\t\t\t\tTorrents.addClient(bucketName + objectKey, torrentClient);\n\t\t\t\t\t\t\ttorrentClient.start();\n\t\t\t\t\t\t\t//send torrent\n\t\t\t\t\t\t\tString key = bucketName + \".\" + objectKey;\n\t\t\t\t\t\t\tString randomKey = key + \".\" + Hashes.getRandom(10);\n\t\t\t\t\t\t\trequest.setRandomKey(randomKey);\n\n\t\t\t\t\t\t\tFile torrent = new File(torrentFilePath);\n\t\t\t\t\t\t\tif(torrent.exists()) {\n\t\t\t\t\t\t\t\tDate lastModified = objectInfo.getLastModified();\n\t\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\t\tlong torrentLength = torrent.length();\n\t\t\t\t\t\t\t\tstorageManager.sendObject(request.getChannel(), httpResponse, bucketName, torrentFile, torrentLength, null, \n\t\t\t\t\t\t\t\t\t\tDateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\", \n\t\t\t\t\t\t\t\t\t\t\"application/x-bittorrent\", \"attachment; filename=\" + objectKey + \".torrent;\", request.getIsCompressed());\n\t\t\t\t\t\t\t\t//TODO: this should reflect params for the torrent?\n\t\t\t\t\t\t\t\treply.setEtag(\"\");\n\t\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN));\n\t\t\t\t\t\t\t\treply.setSize(torrentLength);\n\t\t\t\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\t\t\t\tstatus.setCode(200);\n\t\t\t\t\t\t\t\tstatus.setDescription(\"OK\");\n\t\t\t\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\t\t\t\treply.setContentType(\"binary/octet-stream\");\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesOut(torrentLength);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t\tlogData.setObjectSize(torrentLength);\n\t\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tString errorString = \"Could not get torrent file \" + torrentFilePath;\n\t\t\t\t\t\t\t\tLOG.error(errorString);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(errorString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDate lastModified = objectInfo.getLastModified();\n\t\t\t\t\tLong size = objectInfo.getSize();\n\t\t\t\t\tString etag = objectInfo.getEtag();\n\t\t\t\t\tString contentType = objectInfo.getContentType();\n\t\t\t\t\tString contentDisposition = objectInfo.getContentDisposition();\n\t\t\t\t\tdb.commit();\n\t\t\t\t\tif(request.getGetData()) {\n\t\t\t\t\t\tif(request.getInlineData()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbyte[] bytes = new byte[102400/*TODO: NEIL WalrusQueryDispatcher.DATA_MESSAGE_SIZE*/];\n\t\t\t\t\t\t\t\tint bytesRead = 0;\n\t\t\t\t\t\t\t\tString base64Data = \"\";\n\t\t\t\t\t\t\t\twhile((bytesRead = storageManager.readObject(bucketName, objectName, bytes, bytesRead)) > 0) {\n\t\t\t\t\t\t\t\t\tbase64Data += new String(bytes, 0, bytesRead);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treply.setBase64Data(base64Data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t//set error code\n\t\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//support for large objects\n\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\twalrusStatistics.updateBytesOut(objectInfo.getSize());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstorageManager.sendObject(request.getChannel(), httpResponse, bucketName, objectName, size, etag, \n\t\t\t\t\t\t\t\t\tDateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\", \n\t\t\t\t\t\t\t\t\tcontentType, contentDisposition, request.getIsCompressed());                            \n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstorageManager.sendHeaders(request.getChannel(), httpResponse, size, etag, \n\t\t\t\t\t\t\t\tDateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\", \n\t\t\t\t\t\t\t\tcontentType, contentDisposition);                            \n\n\t\t\t\t\t}\n\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified, DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\t\treply.setSize(size);\n\t\t\t\t\treply.setContentType(contentType);\n\t\t\t\t\treply.setContentDisposition(contentDisposition);\n\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\tstatus.setCode(200);\n\t\t\t\t\tstatus.setDescription(\"OK\");\n\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\treturn reply;\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SetBucketAccessControlPolicyResponseType setBucketAccessControlPolicy(SetBucketAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetBucketAccessControlPolicyResponseType reply = (SetBucketAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tif(accessControlList == null) {\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t}\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif (bucket.canWriteACP(userId)) {\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tbucket.resetGlobalGrants();\n\t\t\t\tbucket.addGrants(bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tbucket.setGrants(grantInfos);\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32759,"modified_method":"public SetBucketAccessControlPolicyResponseType setBucketAccessControlPolicy(SetBucketAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetBucketAccessControlPolicyResponseType reply = (SetBucketAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tif(accessControlList == null) {\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t}\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (bucket.canWriteACP(userId)) {\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tbucket.resetGlobalGrants();\n\t\t\t\tbucket.addGrants(bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tbucket.setGrants(grantInfos);\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListBucketResponseType listBucket(ListBucketType request) throws EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tString prefix = request.getPrefix();\n\t\tif(prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString marker = request.getMarker();\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif(maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif(bucket.canRead(userId)) {\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(request.isAdministrator()) {\n\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = db.recast(WalrusSnapshotInfo.class);\n\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketName);\n\t\t\t\t\tList<WalrusSnapshotInfo> walrusSnaps = dbSnap.query(walrusSnapInfo);\n\t\t\t\t\tif(walrusSnaps.size() > 0) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif(maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setMarker(marker);\n\t\t\t\tif(delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tif(marker != null || objectInfos.size() < maxKeys)\n\t\t\t\t\t\tCollections.sort(objectInfos);\n\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>();\n\t\t\t\t\tfor(ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tif(objectKey.compareTo(marker) <= 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\t\tif(!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif(parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor(PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif(prefixEntry.getPrefix().equals(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(prefixString));\n\t\t\t\t\t\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tString displayName = objectInfo.getOwnerId();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tUser userInfo = CredentialProvider.getUser( displayName );\n\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(userInfo.getQueryId(), displayName));\n\t\t\t\t\t\t} catch ( NoSuchUserException e ) {\n\t\t\t\t\t\t\tdb.rollback( );\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>();\n\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t}\n\t\t\t\t\treply.setContents(contents);\n\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32760,"modified_method":"public ListBucketResponseType listBucket(ListBucketType request) throws EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tString prefix = request.getPrefix();\n\t\tif(prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString marker = request.getMarker();\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif(maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif(bucket.canRead(userId)) {\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(request.isAdministrator()) {\n\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = db.recast(WalrusSnapshotInfo.class);\n\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketName);\n\t\t\t\t\tList<WalrusSnapshotInfo> walrusSnaps = dbSnap.query(walrusSnapInfo);\n\t\t\t\t\tif(walrusSnaps.size() > 0) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif(maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setMarker(marker);\n\t\t\t\tif(delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tif(marker != null || objectInfos.size() < maxKeys)\n\t\t\t\t\t\tCollections.sort(objectInfos);\n\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>();\n\t\t\t\t\tfor(ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tif(objectKey.compareTo(marker) <= 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\t\tif(!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif(parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor(PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif(prefixEntry.getPrefix().equals(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(prefixString));\n\t\t\t\t\t\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys >= 0) {\n\t\t\t\t\t\t\tif(howManyProcessed++ > maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tString displayName = objectInfo.getOwnerId();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tUser userInfo = CredentialProvider.getUser( displayName );\n\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(userInfo.getQueryId(), displayName));\n\t\t\t\t\t\t} catch ( NoSuchUserException e ) {\n\t\t\t\t\t\t\tdb.rollback( );\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>();\n\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t}\n\t\t\t\t\treply.setContents(contents);\n\t\t\t\t\tif(prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(GetObjectAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tString userId = request.getUserId();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t//construct access control policy from grant infos\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif(objectInfo.canReadACP(userId)) {\n\t\t\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\tfor (GrantInfo grantInfo: grantInfos) {\n\t\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tUser userInfo = CredentialProvider.getUser( uId );\n\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\n\t\t\t\t\t\t\taddPermission(grants, userInfo, grantInfo);\n\t\t\t\t\t\t} catch ( NoSuchUserException e ) {\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);              \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tUser ownerUserInfo = CredentialProvider.getUser( ownerId );\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerUserInfo.getQueryId(), ownerUserInfo.getUserName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch ( NoSuchUserException e ) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32761,"modified_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(GetObjectAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tString userId = request.getUserId();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\t\tBucketLogData logData;\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t//construct access control policy from grant infos\n\t\t\tlogData = bucketList.get(0).getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif(objectInfo.canReadACP(userId)) {\n\t\t\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\n\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\tfor (GrantInfo grantInfo: grantInfos) {\n\t\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tUser userInfo = CredentialProvider.getUser( uId );\n\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\n\t\t\t\t\t\t\taddPermission(grants, userInfo, grantInfo);\n\t\t\t\t\t\t} catch ( NoSuchUserException e ) {\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);              \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tUser ownerUserInfo = CredentialProvider.getUser( ownerId );\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerUserInfo.getQueryId(), ownerUserInfo.getUserName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch ( NoSuchUserException e ) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SetRESTObjectAccessControlPolicyResponseType setRESTObjectAccessControlPolicy(SetRESTObjectAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetRESTObjectAccessControlPolicyResponseType reply = (SetRESTObjectAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlPolicyType accessControlPolicy = request.getAccessControlPolicy();\n\t\tif(accessControlPolicy == null) {\n\t\t\tthrow new AccessDeniedException(\"Key\", request.getKey());\n\t\t}\n\t\tAccessControlListType accessControlList = accessControlPolicy.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0)  {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif (!objectInfo.canWriteACP(userId)) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t}\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\tif(!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t}\n\t\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32762,"modified_method":"public SetRESTObjectAccessControlPolicyResponseType setRESTObjectAccessControlPolicy(SetRESTObjectAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetRESTObjectAccessControlPolicyResponseType reply = (SetRESTObjectAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlPolicyType accessControlPolicy = request.getAccessControlPolicy();\n\t\tif(accessControlPolicy == null) {\n\t\t\tthrow new AccessDeniedException(\"Key\", request.getKey());\n\t\t}\n\t\tAccessControlListType accessControlList = accessControlPolicy.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0)  {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif (!objectInfo.canWriteACP(userId)) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t}\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\tif(!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t}\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteBucketResponseType deleteBucket(DeleteBucketType request) throws EucalyptusCloudException {\n\t\tDeleteBucketResponseType reply = (DeleteBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo searchBucket = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(searchBucket);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucketFound = bucketList.get(0);\n\t\t\tif (bucketFound.canWrite(userId)) {\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObject);\n\t\t\t\tif(objectInfos.size() == 0) {\n\t\t\t\t\t//asychronously flush any images in this bucket\n\t\t\t\t\tEntityWrapper<ImageCacheInfo> dbIC = db.recast(ImageCacheInfo.class);\n\t\t\t\t\tImageCacheInfo searchImageCacheInfo = new ImageCacheInfo();\n\t\t\t\t\tsearchImageCacheInfo.setBucketName(bucketName);\n\t\t\t\t\tList<ImageCacheInfo> foundImageCacheInfos = dbIC.query(searchImageCacheInfo);\n\n\t\t\t\t\tif(foundImageCacheInfos.size() > 0) {\n\t\t\t\t\t\tImageCacheInfo foundImageCacheInfo = foundImageCacheInfos.get(0);\n\t\t\t\t\t\twalrusImageManager.startImageCacheFlusher(bucketName, foundImageCacheInfo.getManifestName());\n\t\t\t\t\t}\n\n\t\t\t\t\tdb.delete(bucketFound);\n\t\t\t\t\t//Actually remove the bucket from the backing store\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstorageManager.deleteBucket(bucketName);\n\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) \n\t\t\t\t\t\t\twalrusStatistics.decrementBucketCount();\n\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t//set exception code in reply\n\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(WalrusProperties.enableVirtualHosting) {\n\t\t\t\t\t\tRemoveARecordType removeARecordType = new RemoveARecordType();\n\t\t\t\t\t\tremoveARecordType.setUserId(userId);\n\t\t\t\t\t\tString zone = WalrusProperties.WALRUS_SUBDOMAIN + \".\";\n\t\t\t\t\t\tremoveARecordType.setName(bucketName + \".\" + zone);\n\t\t\t\t\t\tremoveARecordType.setZone(zone);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tServiceDispatcher.lookupSingle(Component.dns).send(removeARecordType);\n\t\t\t\t\t\t\tLOG.info(\"Removing mapping for \" + removeARecordType.getName());\n\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\tLOG.error(\"Could not update DNS record\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\tstatus.setCode(204);\n\t\t\t\t\tstatus.setDescription(\"No Content\");\n\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\tBucketLogData logData = bucketFound.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketFound, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new BucketNotEmptyException(bucketName);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32763,"modified_method":"public DeleteBucketResponseType deleteBucket(DeleteBucketType request) throws EucalyptusCloudException {\n\t\tDeleteBucketResponseType reply = (DeleteBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo searchBucket = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(searchBucket);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucketFound = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketFound.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (bucketFound.canWrite(userId)) {\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObject);\n\t\t\t\tif(objectInfos.size() == 0) {\n\t\t\t\t\t//asychronously flush any images in this bucket\n\t\t\t\t\tEntityWrapper<ImageCacheInfo> dbIC = db.recast(ImageCacheInfo.class);\n\t\t\t\t\tImageCacheInfo searchImageCacheInfo = new ImageCacheInfo();\n\t\t\t\t\tsearchImageCacheInfo.setBucketName(bucketName);\n\t\t\t\t\tList<ImageCacheInfo> foundImageCacheInfos = dbIC.query(searchImageCacheInfo);\n\n\t\t\t\t\tif(foundImageCacheInfos.size() > 0) {\n\t\t\t\t\t\tImageCacheInfo foundImageCacheInfo = foundImageCacheInfos.get(0);\n\t\t\t\t\t\twalrusImageManager.startImageCacheFlusher(bucketName, foundImageCacheInfo.getManifestName());\n\t\t\t\t\t}\n\n\t\t\t\t\tdb.delete(bucketFound);\n\t\t\t\t\t//Actually remove the bucket from the backing store\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstorageManager.deleteBucket(bucketName);\n\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) \n\t\t\t\t\t\t\twalrusStatistics.decrementBucketCount();\n\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t//set exception code in reply\n\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(WalrusProperties.enableVirtualHosting) {\n\t\t\t\t\t\tRemoveARecordType removeARecordType = new RemoveARecordType();\n\t\t\t\t\t\tremoveARecordType.setUserId(userId);\n\t\t\t\t\t\tString zone = WalrusProperties.WALRUS_SUBDOMAIN + \".\";\n\t\t\t\t\t\tremoveARecordType.setName(bucketName + \".\" + zone);\n\t\t\t\t\t\tremoveARecordType.setZone(zone);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tServiceDispatcher.lookupSingle(Component.dns).send(removeARecordType);\n\t\t\t\t\t\t\tLOG.info(\"Removing mapping for \" + removeARecordType.getName());\n\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\tLOG.error(\"Could not update DNS record\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\tstatus.setCode(204);\n\t\t\t\t\tstatus.setDescription(\"No Content\");\n\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketFound, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new BucketNotEmptyException(bucketName, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SetRESTBucketAccessControlPolicyResponseType setRESTBucketAccessControlPolicy(SetRESTBucketAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetRESTBucketAccessControlPolicyResponseType reply = (SetRESTBucketAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlPolicyType accessControlPolicy = request.getAccessControlPolicy();\n\t\tString bucketName = request.getBucket();\n\t\tif(accessControlPolicy == null) {\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t}\n\t\tAccessControlListType accessControlList = accessControlPolicy.getAccessControlList();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif (bucket.canWriteACP(userId)) {\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tbucket.resetGlobalGrants();\n\t\t\t\tbucket.addGrants(bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tbucket.setGrants(grantInfos);\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32764,"modified_method":"public SetRESTBucketAccessControlPolicyResponseType setRESTBucketAccessControlPolicy(SetRESTBucketAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetRESTBucketAccessControlPolicyResponseType reply = (SetRESTBucketAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlPolicyType accessControlPolicy = request.getAccessControlPolicy();\n\t\tString bucketName = request.getBucket();\n\t\tif(accessControlPolicy == null) {\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t}\n\t\tAccessControlListType accessControlList = accessControlPolicy.getAccessControlList();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (bucket.canWriteACP(userId)) {\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tbucket.resetGlobalGrants();\n\t\t\t\tbucket.addGrants(bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tbucket.setGrants(grantInfos);\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SetObjectAccessControlPolicyResponseType setObjectAccessControlPolicy(SetObjectAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetObjectAccessControlPolicyResponseType reply = (SetObjectAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0)  {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif (!objectInfo.canWriteACP(userId)) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t}\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\tif(!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t}\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32765,"modified_method":"public SetObjectAccessControlPolicyResponseType setObjectAccessControlPolicy(SetObjectAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tSetObjectAccessControlPolicyResponseType reply = (SetObjectAccessControlPolicyResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0)  {\n\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\tif (!objectInfo.canWriteACP(userId)) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t}\n\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\tobjectInfo.resetGlobalGrants();\n\t\t\t\tobjectInfo.addGrants(objectInfo.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\tobjectInfo.setGrants(grantInfos);\n\n\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\tif(!objectInfo.isGlobalRead()) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t}\n\t\t\t\treply.setCode(\"204\");\n\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null)\n\t\t\t\t\treply.setLogData(logData);\n\n\t\t\t\tObjectInfo foundObject = null;\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObject);\n\t\t\t\tfor (ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\tif (objectInfo.getObjectKey().equals(objectKey)) {\n\t\t\t\t\t\t//key (object) exists. check perms\n\t\t\t\t\t\tif (!objectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\toldBucketSize = -foundObject.getSize();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//write object to bucket\n\t\t\t\tString objectName;\n\t\t\t\tif (foundObject == null) {\n\t\t\t\t\t//not found. create an object info\n\t\t\t\t\tfoundObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tfoundObject.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4);\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t} else {\n\t\t\t\t\t//object already exists. see if we can modify acl\n\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t}\n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoundObject.setObjectKey(objectKey);\n\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\tdb.commit();\n\t\t\t\t//writes are unconditional\n\t\t\t\tLinkedBlockingQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take())!=null) {\n\t\t\t\t\t\tif(WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = objectName + \".\" + Hashes.getRandom(12);\n\t\t\t\t\t\t\tdigest = Hashes.Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t//commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tdbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\tobjectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize + size;\n\t\t\t\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\tthrow new NoSuchEntityException(\"Could not find object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if(WalrusDataMessage.isInterrupted(dataMessage)) {\n\n\t\t\t\t\t\t\t//there was a write after this one started\n\t\t\t\t\t\t\t//abort writing but wait until the other (last) writer has completed\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert(WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t//start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","id":32766,"modified_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\tif(logData != null)\n\t\t\t\t\treply.setLogData(logData);\n\n\t\t\t\tObjectInfo foundObject = null;\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObject);\n\t\t\t\tfor (ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\tif (objectInfo.getObjectKey().equals(objectKey)) {\n\t\t\t\t\t\t//key (object) exists. check perms\n\t\t\t\t\t\tif (!objectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\toldBucketSize = -foundObject.getSize();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//write object to bucket\n\t\t\t\tString objectName;\n\t\t\t\tif (foundObject == null) {\n\t\t\t\t\t//not found. create an object info\n\t\t\t\t\tfoundObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tfoundObject.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4);\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t} else {\n\t\t\t\t\t//object already exists. see if we can modify acl\n\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t}\n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\tif(WalrusProperties.enableTorrents) {\n\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);\n\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.query(torrentInfo);\n\t\t\t\t\t\tif(torrentInfos.size() > 0) {\n\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\tif(torrentClient != null) {\n\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoundObject.setObjectKey(objectKey);\n\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\tdb.commit();\n\t\t\t\t//writes are unconditional\n\t\t\t\tLinkedBlockingQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take())!=null) {\n\t\t\t\t\t\tif(WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = objectName + \".\" + Hashes.getRandom(12);\n\t\t\t\t\t\t\tdigest = Hashes.Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t//commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tdbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\tobjectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize + size;\n\t\t\t\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\tthrow new NoSuchEntityException(\"Could not find object: \" + bucketName + \"/\" + objectKey, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if(WalrusDataMessage.isInterrupted(dataMessage)) {\n\n\t\t\t\t\t\t\t//there was a write after this one started\n\t\t\t\t\t\t\t//abort writing but wait until the other (last) writer has completed\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert(WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t//start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tif(digest != null)\n\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \" + key + \".\" + randomKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public GetBucketAccessControlPolicyResponseType getBucketAccessControlPolicy(GetBucketAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tGetBucketAccessControlPolicyResponseType reply = (GetBucketAccessControlPolicyResponseType) request.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\t//construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tList<GrantInfo> grantInfos = bucket.getGrants();\n\t\t\tif (bucket.canReadACP(userId)) {\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\townerId = bucket.getOwnerId();\n\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\tbucket.readPermissions(grants);\n\t\t\t\tfor (GrantInfo grantInfo: grantInfos) {\n\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif(uId != null) {\n\t\t\t\t\t\t\tUser grantUserInfo = CredentialProvider.getUser( uId );\n\t\t\t\t\t\t\taddPermission(grants, grantUserInfo, grantInfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddPermission(grants, grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch ( NoSuchUserException e ) {\n\t\t\t\t\t\tdb.rollback( );\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tUser ownerUserInfo = CredentialProvider.getUser( ownerId );\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerUserInfo.getQueryId(), ownerUserInfo.getUserName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch ( NoSuchUserException e ) {\n\t\t\tdb.rollback( );\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32767,"modified_method":"public GetBucketAccessControlPolicyResponseType getBucketAccessControlPolicy(GetBucketAccessControlPolicyType request) throws EucalyptusCloudException\n\t{\n\t\tGetBucketAccessControlPolicyResponseType reply = (GetBucketAccessControlPolicyResponseType) request.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tBucketLogData logData;\n\n\t\tif (bucketList.size() > 0) {\n\t\t\t//construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tList<GrantInfo> grantInfos = bucket.getGrants();\n\t\t\tif (bucket.canReadACP(userId)) {\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t\townerId = bucket.getOwnerId();\n\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\tbucket.readPermissions(grants);\n\t\t\t\tfor (GrantInfo grantInfo: grantInfos) {\n\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif(uId != null) {\n\t\t\t\t\t\t\tUser grantUserInfo = CredentialProvider.getUser( uId );\n\t\t\t\t\t\t\taddPermission(grants, grantUserInfo, grantInfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddPermission(grants, grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch ( NoSuchUserException e ) {\n\t\t\t\t\t\tdb.rollback( );\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tUser ownerUserInfo = CredentialProvider.getUser( ownerId );\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerUserInfo.getQueryId(), ownerUserInfo.getUserName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch ( NoSuchUserException e ) {\n\t\t\tdb.rollback( );\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public GetBucketLocationResponseType getBucketLocation(GetBucketLocationType request) throws EucalyptusCloudException {\n\t\tGetBucketLocationResponseType reply = (GetBucketLocationResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif(bucket.canRead(userId)) {\n\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t\tString location = bucket.getLocation();\n\t\t\t\tif(location == null) {\n\t\t\t\t\tlocation = \"NotSupported\";\n\t\t\t\t}\n\t\t\t\treply.setLocationConstraint(location);\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32768,"modified_method":"public GetBucketLocationResponseType getBucketLocation(GetBucketLocationType request) throws EucalyptusCloudException {\n\t\tGetBucketLocationResponseType reply = (GetBucketLocationResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString userId = request.getUserId();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif(bucket.canRead(userId)) {\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\t\t\t\t\n\t\t\t\tString location = bucket.getLocation();\n\t\t\t\tif(location == null) {\n\t\t\t\t\tlocation = \"NotSupported\";\n\t\t\t\t}\n\t\t\t\treply.setLocationConstraint(location);\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public PutObjectInlineResponseType putObjectInline(PutObjectInlineType request) throws EucalyptusCloudException {\n\t\tPutObjectInlineResponseType reply = (PutObjectInlineResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tString md5 = \"\";\n\t\tLong oldBucketSize = 0L;\n\t\tDate lastModified;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\n\t\t\t\tObjectInfo foundObject = null;\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tfor (ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\tif (objectInfo.getObjectKey().equals(objectKey)) {\n\t\t\t\t\t\t//key (object) exists. check perms\n\t\t\t\t\t\tif (!objectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\toldBucketSize = -foundObject.getSize();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//write object to bucket\n\t\t\t\tString objectName;\n\t\t\t\tif (foundObject == null) {\n\t\t\t\t\t//not found. create an object info\n\t\t\t\t\tfoundObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tfoundObject.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4);\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t} else {\n\t\t\t\t\t//object already exists. see if we can modify acl\n\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\tList<GrantInfo> grantInfos = foundObject.getGrants();\n\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t}\n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t}\n\t\t\t\tfoundObject.setObjectKey(objectKey);\n\t\t\t\ttry {\n\t\t\t\t\t//writes are unconditional\n\t\t\t\t\tbyte[] base64Data = request.getBase64Data().getBytes();\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFileIO fileIO = storageManager.prepareForWrite(bucketName, objectName);\n\t\t\t\t\t\tif(fileIO != null) {\n\t\t\t\t\t\t\tfileIO.write(base64Data);\n\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tmd5 = Hashes.getHexString(Hashes.Digest.MD5.get().digest(base64Data));\n\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\tLong size = (long)base64Data.length;\n\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize + size;\n\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t}\n\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t}\n\t\t\t\t\t//Add meta data if specified\n\t\t\t\t\tif(request.getMetaData() != null)\n\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\n\t\t\t\t\t//TODO: add support for other storage classes\n\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} catch (/*TODO: NEIL, check if it is IOException*/Exception ex) {\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new EucalyptusCloudException(bucketName);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName);\n\t\t\t}\n\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tdb.commit();\n\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","id":32769,"modified_method":"public PutObjectInlineResponseType putObjectInline(PutObjectInlineType request) throws EucalyptusCloudException {\n\t\tPutObjectInlineResponseType reply = (PutObjectInlineResponseType) request.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tString md5 = \"\";\n\t\tLong oldBucketSize = 0L;\n\t\tDate lastModified;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif(bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\n\t\t\t\tObjectInfo foundObject = null;\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tfor (ObjectInfo objectInfo: objectInfos) {\n\t\t\t\t\tif (objectInfo.getObjectKey().equals(objectKey)) {\n\t\t\t\t\t\t//key (object) exists. check perms\n\t\t\t\t\t\tif (!objectInfo.canWrite(userId)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\toldBucketSize = -foundObject.getSize();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//write object to bucket\n\t\t\t\tString objectName;\n\t\t\t\tif (foundObject == null) {\n\t\t\t\t\t//not found. create an object info\n\t\t\t\t\tfoundObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tfoundObject.setOwnerId(userId);\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\") + Hashes.getRandom(4);\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t} else {\n\t\t\t\t\t//object already exists. see if we can modify acl\n\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\tList<GrantInfo> grantInfos = foundObject.getGrants();\n\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t}\n\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t}\n\t\t\t\tfoundObject.setObjectKey(objectKey);\n\t\t\t\ttry {\n\t\t\t\t\t//writes are unconditional\n\t\t\t\t\tbyte[] base64Data = request.getBase64Data().getBytes();\n\t\t\t\t\tfoundObject.setObjectName(objectName);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFileIO fileIO = storageManager.prepareForWrite(bucketName, objectName);\n\t\t\t\t\t\tif(fileIO != null) {\n\t\t\t\t\t\t\tfileIO.write(base64Data);\n\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tmd5 = Hashes.getHexString(Hashes.Digest.MD5.get().digest(base64Data));\n\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\tLong size = (long)base64Data.length;\n\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\tif(WalrusProperties.shouldEnforceUsageLimits && !request.isAdministrator()) {\n\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize + size;\n\t\t\t\t\t\tif(newSize > WalrusProperties.MAX_BUCKET_SIZE) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t}\n\t\t\t\t\tif(WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t}\n\t\t\t\t\t//Add meta data if specified\n\t\t\t\t\tif(request.getMetaData() != null)\n\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\n\t\t\t\t\t//TODO: add support for other storage classes\n\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new EucalyptusCloudException(bucketName);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t}   else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tdb.commit();\n\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteObjectResponseType deleteObject(DeleteObjectType request) throws EucalyptusCloudException {\n\t\tDeleteObjectResponseType reply = (DeleteObjectResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tString userId = request.getUserId();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfos = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfos);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketInfo = bucketList.get(0);\n\t\t\tObjectInfo foundObject = null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t}\n\n\t\t\tif (foundObject != null) {\n\t\t\t\tif (foundObject.canWrite(userId)) {\n\t\t\t\t\tdbObject.delete(foundObject);\n\t\t\t\t\tString objectName = foundObject.getObjectName();\n\t\t\t\t\tfor (GrantInfo grantInfo: foundObject.getGrants()) {\n\t\t\t\t\t\tdb.getEntityManager().remove(grantInfo);\n\t\t\t\t\t}\n\t\t\t\t\tLong size = foundObject.getSize();\n\t\t\t\t\tbucketInfo.setBucketSize(bucketInfo.getBucketSize() - size);\n\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, objectName, size);\n\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\tBucketLogData logData = bucketInfo.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketInfo, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":32770,"modified_method":"public DeleteObjectResponseType deleteObject(DeleteObjectType request) throws EucalyptusCloudException {\n\t\tDeleteObjectResponseType reply = (DeleteObjectResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tString userId = request.getUserId();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfos = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfos);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketInfo = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketInfo.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tObjectInfo foundObject = null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\tif(objectInfos.size() > 0) {\n\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t}\n\n\t\t\tif (foundObject != null) {\n\t\t\t\tif (foundObject.canWrite(userId)) {\n\t\t\t\t\tdbObject.delete(foundObject);\n\t\t\t\t\tString objectName = foundObject.getObjectName();\n\t\t\t\t\tfor (GrantInfo grantInfo: foundObject.getGrants()) {\n\t\t\t\t\t\tdb.getEntityManager().remove(grantInfo);\n\t\t\t\t\t}\n\t\t\t\t\tLong size = foundObject.getSize();\n\t\t\t\t\tbucketInfo.setBucketSize(bucketInfo.getBucketSize() - size);\n\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, objectName, size);\n\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\tif(logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketInfo, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpResponse ) {\n\t\t\tMappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );\n\t\t\tif(httpResponse.getMessage() instanceof WalrusResponseType) {\n\t\t\t\tWalrusResponseType response = (WalrusResponseType) httpResponse.getMessage();\n\t\t\t\tBucketLogData logData = response.getLogData();\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tlogData.setBytesSent(httpResponse.getContent().readableBytes());\n\t\t\t\t\tlong startTime = logData.getTotalTime();\n\t\t\t\t\tlogData.setTotalTime(System.currentTimeMillis() - startTime);\n\t\t\t\t\tWalrusBucketLogger.getInstance().addLogEntry(logData);\t\t\t\t\t\n\t\t\t\t\tresponse.setLogData(null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":32771,"modified_method":"@Override\n\tpublic void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpResponse ) {\n\t\t\tMappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );\n\t\t\tif(httpResponse.getMessage() instanceof WalrusResponseType) {\n\t\t\t\tWalrusResponseType response = (WalrusResponseType) httpResponse.getMessage();\n\t\t\t\tBucketLogData logData = response.getLogData();\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tlogData.setBytesSent(httpResponse.getContent().readableBytes());\n\t\t\t\t\tlong startTime = logData.getTotalTime();\n\t\t\t\t\tlogData.setTotalTime(System.currentTimeMillis() - startTime);\n\t\t\t\t\tHttpResponseStatus status = httpResponse.getStatus();\n\t\t\t\t\tif(status != null)\n\t\t\t\t\t\tlogData.setStatus(Integer.toString(status.getCode()));\n\t\t\t\t\tWalrusBucketLogger.getInstance().addLogEntry(logData);\t\t\t\t\t\n\t\t\t\t\tresponse.setLogData(null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void incomingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpRequest ) {\n\t\t\tMappingHttpRequest httpRequest = ( MappingHttpRequest ) event.getMessage();\n\t\t\tif(httpRequest.getMessage() instanceof WalrusRequestType) {\n\t\t\t\tWalrusRequestType request = (WalrusRequestType) httpRequest.getMessage();\n\t\t\t\tBucketLogData logData = request.getLogData();\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tlogData.setTotalTime(System.currentTimeMillis());\n\t\t\t\t\tlogData.setUri(httpRequest.getUri());\n\t\t\t\t\tString referrer = httpRequest.getHeader(HttpHeaders.Names.REFERER);\n\t\t\t\t\tif(referrer != null)\n\t\t\t\t\t\tlogData.setReferrer(referrer);\n\t\t\t\t\tString userAgent = httpRequest.getHeader(HttpHeaders.Names.USER_AGENT);\n\t\t\t\t\tif(userAgent != null)\n\t\t\t\t\t\tlogData.setUserAgent(userAgent);\n\t\t\t\t\tlogData.setTimestamp(String.format(\"[%1$td/%1$tb/%1$tY:%1$tH:%1$tM:%1$tS %1$tz]\", Calendar.getInstance()));\n\t\t\t\t\tUser user = httpRequest.getUser();\n\t\t\t\t\tif(user != null)\n\t\t\t\t\t\tlogData.setAccessorId(user.getUserName());\n\t\t\t\t\tif(request.getBucket() != null)\n\t\t\t\t\t\tlogData.setBucketName(request.getBucket());\n\t\t\t\t\tif(request.getKey() != null) \n\t\t\t\t\t\tlogData.setKey(request.getKey());\n\t\t\t\t\tlogData.setSourceAddress(ctx.getChannel().getRemoteAddress().toString());\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}","id":32772,"modified_method":"@Override\n\tpublic void incomingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpRequest ) {\n\t\t\tMappingHttpRequest httpRequest = ( MappingHttpRequest ) event.getMessage();\n\t\t\tif(httpRequest.getMessage() instanceof WalrusRequestType) {\n\t\t\t\tWalrusRequestType request = (WalrusRequestType) httpRequest.getMessage();\n\t\t\t\tBucketLogData logData = request.getLogData();\n\t\t\t\tif(logData != null) {\n\t\t\t\t\tlogData.setTotalTime(System.currentTimeMillis());\n\t\t\t\t\tlogData.setUri(httpRequest.getUri());\n\t\t\t\t\tString referrer = httpRequest.getHeader(HttpHeaders.Names.REFERER);\n\t\t\t\t\tif(referrer != null)\n\t\t\t\t\t\tlogData.setReferrer(referrer);\n\t\t\t\t\tString userAgent = httpRequest.getHeader(HttpHeaders.Names.USER_AGENT);\n\t\t\t\t\tif(userAgent != null)\n\t\t\t\t\t\tlogData.setUserAgent(userAgent);\n\t\t\t\t\tlogData.setTimestamp(String.format(\"[%1$td/%1$tb/%1$tY:%1$tH:%1$tM:%1$tS %1$tz]\", Calendar.getInstance()));\n\t\t\t\t\tUser user = httpRequest.getUser();\n\t\t\t\t\tif(user != null)\n\t\t\t\t\t\tlogData.setAccessorId(user.getUserName());\n\t\t\t\t\tif(request.getBucket() != null)\n\t\t\t\t\t\tlogData.setBucketName(request.getBucket());\n\t\t\t\t\tif(request.getKey() != null) \n\t\t\t\t\t\tlogData.setKey(request.getKey());\n\t\t\t\t\tif(ctx.getChannel().getRemoteAddress() instanceof InetSocketAddress) {\n\t\t\t\t\t\tInetSocketAddress sockAddress = (InetSocketAddress) ctx.getChannel().getRemoteAddress();\n\t\t\t\t\t\tlogData.setSourceAddress(sockAddress.getAddress().getHostAddress());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}","commit_id":"3cf644744aec74247847c0c72ece1b61b99b6340","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void split( ChannelHandlerContext ctx ) {\n    Long rb = readBytes.getAndSet( 0l );\n    Long wb = writeBytes.getAndSet( 0l );\n    Long roundTime = ( System.currentTimeMillis( ) - this.openTime.getAndSet( 0 ) );\n    LOG.trace( EventRecord.here( ctx.getPipeline( ).getLast( ).getClass( ), \n                                 EventType.SOCKET_CLOSE, roundTime.toString( ), ctx.getChannel( ).getLocalAddress( ).toString( ), ctx.getChannel( ).getRemoteAddress( ).toString( ), \n                                 EventType.SOCKET_BYTES_READ.toString( ), rb.toString( ), Float.toString( ( wb * 1024.0f ) / ( roundTime * 1024.0f ) ), \n                                 EventType.SOCKET_BYTES_WRITE.toString( ), wb.toString( ), Float.toString( ( wb * 1024.0f ) / ( roundTime * 1024.0f ) ) ) );\n  }","id":32773,"modified_method":"public void split( ChannelHandlerContext ctx ) {\n    Long rb = readBytes.getAndSet( 0l );\n    Long wb = writeBytes.getAndSet( 0l );\n    Long roundTime = ( System.currentTimeMillis( ) - this.openTime.getAndSet( 0 ) );\n    LOG.trace( EventRecord.here( ctx.getPipeline( ).getLast( ).getClass( ), EventType.SOCKET_CLOSE, \"\"+roundTime.toString( ), \"\"+ctx.getChannel( ).getLocalAddress( ), \"\"+ctx.getChannel( ).getRemoteAddress( ) ) ); \n    if( rb != null ) {\n      LOG.trace( EventRecord.here( ctx.getPipeline( ).getLast( ).getClass( ), EventType.SOCKET_BYTES_READ, \"\"+rb, Float.toString( ( wb * 1024.0f ) / ( roundTime * 1024.0f ) ) ) );\n    }\n    if( wb != null ) {\n      LOG.trace( EventRecord.here( ctx.getPipeline( ).getLast( ).getClass( ), EventType.SOCKET_BYTES_WRITE, \"\"+wb, Float.toString( ( wb * 1024.0f ) / ( roundTime * 1024.0f ) ) ) );\n    }\n  }","commit_id":"e75b382ce0ff9f3a6f711716d911f8d3bc300465","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private String getPrivateSubnet(String vlan) throws ExecutionException {\n        String _interfaceName = genPrivateInterfaceName(Long.valueOf(vlan).longValue());\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"type\", \"config\");\n        params.put(\"action\", \"get\");\n        params.put(\"xpath\", \"/config/devices/entry/network/interface/\" + _privateInterfaceType + \"/entry[@name='\" + _privateInterface + \"']/layer3/units/entry[@name='\" +\n            _interfaceName + \"']/ip/entry\");\n        String response = request(PaloAltoMethod.GET, params);\n        if (validResponse(response) && responseNotEmpty(response)) {\n            NodeList response_body;\n            Document doc = getDocument(response);\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            try {\n                XPathExpression expr = xpath.compile(\"/response[@status='success']/result/entry\");\n                response_body = (NodeList)expr.evaluate(doc, XPathConstants.NODESET);\n            } catch (XPathExpressionException e) {\n                throw new ExecutionException(e.getCause().getMessage());\n            }\n            if (response_body.getLength() > 0) {\n                return response_body.item(0).getAttributes().getNamedItem(\"name\").getTextContent();\n            }\n        }\n        return null;\n    }","id":32774,"modified_method":"private String getPrivateSubnet(String vlan) throws ExecutionException {\n        String _interfaceName = genPrivateInterfaceName(Long.parseLong(vlan));\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"type\", \"config\");\n        params.put(\"action\", \"get\");\n        params.put(\"xpath\", \"/config/devices/entry/network/interface/\" + _privateInterfaceType + \"/entry[@name='\" + _privateInterface + \"']/layer3/units/entry[@name='\" +\n            _interfaceName + \"']/ip/entry\");\n        String response = request(PaloAltoMethod.GET, params);\n        if (validResponse(response) && responseNotEmpty(response)) {\n            NodeList response_body;\n            Document doc = getDocument(response);\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            try {\n                XPathExpression expr = xpath.compile(\"/response[@status='success']/result/entry\");\n                response_body = (NodeList)expr.evaluate(doc, XPathConstants.NODESET);\n            } catch (XPathExpressionException e) {\n                throw new ExecutionException(e.getCause().getMessage());\n            }\n            if (response_body.getLength() > 0) {\n                return response_body.item(0).getAttributes().getNamedItem(\"name\").getTextContent();\n            }\n        }\n        return null;\n    }","commit_id":"6f330f7ab63c9c7dfefc3383a7073ee7ea851b27","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    userSession.checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n\n    String login = request.mandatoryParam(PARAM_LOGIN);\n    NewUser newUser = NewUser.create()\n      .setLogin(login)\n      .setName(request.mandatoryParam(PARAM_NAME))\n      .setEmail(request.param(PARAM_EMAIL))\n      .setScmAccounts(request.paramAsStrings(PARAM_SCM_ACCOUNTS))\n      .setPassword(request.mandatoryParam(PARAM_PASSWORD))\n      .setPasswordConfirmation(request.mandatoryParam(PARAM_PASSWORD_CONFIRMATION));\n\n    boolean isUserReactivated = userUpdater.create(newUser);\n    writeResponse(response, login, isUserReactivated);\n  }","id":32775,"modified_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    userSession.checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n\n    String login = request.mandatoryParam(PARAM_LOGIN);\n    String password = request.mandatoryParam(PARAM_PASSWORD);\n    NewUser newUser = NewUser.create()\n      .setLogin(login)\n      .setName(request.mandatoryParam(PARAM_NAME))\n      .setEmail(request.param(PARAM_EMAIL))\n      .setScmAccounts(request.paramAsStrings(PARAM_SCM_ACCOUNTS))\n      .setPassword(password)\n      .setPasswordConfirmation(password);\n\n    boolean isUserReactivated = userUpdater.create(newUser);\n    writeResponse(response, login, isUserReactivated);\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"create\")\n      .setDescription(\"Create a user. Requires Administer System permission\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(this);\n\n    action.createParam(PARAM_LOGIN)\n      .setDescription(\"User login\")\n      .setRequired(true)\n      .setExampleValue(\"myuser\");\n\n    action.createParam(PARAM_PASSWORD)\n      .setDescription(\"User password\")\n      .setRequired(true)\n      .setExampleValue(\"mypassword\");\n\n    action.createParam(PARAM_PASSWORD_CONFIRMATION)\n      .setDescription(\"Must be the same value as \\\"password\\\"\")\n      .setRequired(true)\n      .setExampleValue(\"mypassword\");\n\n    action.createParam(PARAM_NAME)\n      .setDescription(\"User name\")\n      .setRequired(true)\n      .setExampleValue(\"My Name\");\n\n    action.createParam(PARAM_EMAIL)\n      .setDescription(\"User email\")\n      .setExampleValue(\"myname@email.com\");\n\n    action.createParam(PARAM_SCM_ACCOUNTS)\n      .setDescription(\"SCM accounts. This parameter has been added in 5.1\")\n      .setExampleValue(\"myscmaccount1, myscmaccount2\");\n  }","id":32776,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"create\")\n      .setDescription(\"Create a user. Requires Administer System permission\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(this);\n\n    action.createParam(PARAM_LOGIN)\n      .setDescription(\"User login\")\n      .setRequired(true)\n      .setExampleValue(\"myuser\");\n\n    action.createParam(PARAM_PASSWORD)\n      .setDescription(\"User password\")\n      .setRequired(true)\n      .setExampleValue(\"mypassword\");\n\n    action.createParam(PARAM_NAME)\n      .setDescription(\"User name\")\n      .setRequired(true)\n      .setExampleValue(\"My Name\");\n\n    action.createParam(PARAM_EMAIL)\n      .setDescription(\"User email\")\n      .setExampleValue(\"myname@email.com\");\n\n    action.createParam(PARAM_SCM_ACCOUNTS)\n      .setDescription(\"SCM accounts. This parameter has been added in 5.1\")\n      .setDeprecatedKey(PARAM_SCM_ACCOUNTS_DEPRECATED)\n      .setExampleValue(\"myscmaccount1,myscmaccount2\");\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = ForbiddenException.class)\n  public void fail_on_missing_permission() throws Exception {\n    userSessionRule.login(\"not_admin\");\n\n    tester.newPostRequest(\"api/users\", \"create\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"John\")\n      .setParam(\"email\", \"john@email.com\")\n      .setParam(\"scm_accounts\", \"jn\")\n      .setParam(\"password\", \"1234\")\n      .setParam(\"password_confirmation\", \"1234\").execute();\n  }","id":32777,"modified_method":"@Test(expected = ForbiddenException.class)\n  public void fail_on_missing_permission() throws Exception {\n    userSessionRule.login(\"not_admin\");\n\n    tester.newPostRequest(\"api/users\", \"create\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"John\")\n      .setParam(\"email\", \"john@email.com\")\n      .setParam(\"scm_accounts\", \"jn\")\n      .setParam(\"password\", \"1234\").execute();\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_user() throws Exception {\n    userSessionRule.login(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    tester.newPostRequest(\"api/users\", \"create\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"John\")\n      .setParam(\"email\", \"john@email.com\")\n      .setParam(\"scm_accounts\", \"jn\")\n      .setParam(\"password\", \"1234\")\n      .setParam(\"password_confirmation\", \"1234\").execute()\n      .assertJson(getClass(), \"create_user.json\");\n\n    UserDoc user = index.getByLogin(\"john\");\n    assertThat(user.login()).isEqualTo(\"john\");\n    assertThat(user.name()).isEqualTo(\"John\");\n    assertThat(user.email()).isEqualTo(\"john@email.com\");\n    assertThat(user.scmAccounts()).containsOnly(\"jn\");\n  }","id":32778,"modified_method":"@Test\n  public void create_user() throws Exception {\n    userSessionRule.login(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    tester.newPostRequest(\"api/users\", \"create\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"John\")\n      .setParam(\"email\", \"john@email.com\")\n      .setParam(\"scmAccounts\", \"jn\")\n      .setParam(\"password\", \"1234\").execute()\n      .assertJson(getClass(), \"create_user.json\");\n\n    UserDoc user = index.getByLogin(\"john\");\n    assertThat(user.login()).isEqualTo(\"john\");\n    assertThat(user.name()).isEqualTo(\"John\");\n    assertThat(user.email()).isEqualTo(\"john@email.com\");\n    assertThat(user.scmAccounts()).containsOnly(\"jn\");\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void reactivate_user() throws Exception {\n    userSessionRule.login(\"admin\").setLocale(Locale.FRENCH).setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    dbClient.userDao().insert(session, new UserDto()\n      .setEmail(\"john@email.com\")\n      .setLogin(\"john\")\n      .setName(\"John\")\n      .setActive(true));\n    session.commit();\n    dbClient.userDao().deactivateUserByLogin(\"john\");\n    userIndexer.index();\n\n    when(i18n.message(Locale.FRENCH, \"user.reactivated\", \"user.reactivated\", \"john\")).thenReturn(\"The user 'john' has been reactivated.\");\n\n    tester.newPostRequest(\"api/users\", \"create\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"John\")\n      .setParam(\"email\", \"john@email.com\")\n      .setParam(\"scm_accounts\", \"jn\")\n      .setParam(\"password\", \"1234\")\n      .setParam(\"password_confirmation\", \"1234\").execute()\n      .assertJson(getClass(), \"reactivate_user.json\");\n\n    assertThat(index.getByLogin(\"john\").active()).isTrue();\n  }","id":32779,"modified_method":"@Test\n  public void reactivate_user() throws Exception {\n    userSessionRule.login(\"admin\").setLocale(Locale.FRENCH).setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    dbClient.userDao().insert(session, new UserDto()\n      .setEmail(\"john@email.com\")\n      .setLogin(\"john\")\n      .setName(\"John\")\n      .setActive(true));\n    session.commit();\n    dbClient.userDao().deactivateUserByLogin(\"john\");\n    userIndexer.index();\n\n    when(i18n.message(Locale.FRENCH, \"user.reactivated\", \"user.reactivated\", \"john\")).thenReturn(\"The user 'john' has been reactivated.\");\n\n    tester.newPostRequest(\"api/users\", \"create\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"John\")\n      .setParam(\"email\", \"john@email.com\")\n      .setParam(\"scm_accounts\", \"jn\")\n      .setParam(\"password\", \"1234\").execute()\n      .assertJson(getClass(), \"reactivate_user.json\");\n\n    assertThat(index.getByLogin(\"john\").active()).isTrue();\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"update\")\n      .setDescription(\"Update a user. Requires Administer System permission. Since 5.2, a user's password can only be changed using the 'change_password' action.\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(this)\n      .setResponseExample(getClass().getResource(\"example-update.json\"));\n\n    action.createParam(PARAM_LOGIN)\n      .setDescription(\"User login\")\n      .setRequired(true)\n      .setExampleValue(\"myuser\");\n\n    action.createParam(PARAM_NAME)\n      .setDescription(\"User name\")\n      .setExampleValue(\"My Name\");\n\n    action.createParam(PARAM_EMAIL)\n      .setDescription(\"User email\")\n      .setExampleValue(\"myname@email.com\");\n\n    action.createParam(PARAM_SCM_ACCOUNTS)\n      .setDescription(\"SCM accounts. This parameter has been added in 5.1\")\n      .setExampleValue(\"myscmaccount1, myscmaccount2\");\n  }","id":32780,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"update\")\n      .setDescription(\"Update a user. Requires Administer System permission. Since 5.2, a user's password can only be changed using the 'change_password' action.\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(this)\n      .setResponseExample(getClass().getResource(\"example-update.json\"));\n\n    action.createParam(PARAM_LOGIN)\n      .setDescription(\"User login\")\n      .setRequired(true)\n      .setExampleValue(\"myuser\");\n\n    action.createParam(PARAM_NAME)\n      .setDescription(\"User name\")\n      .setExampleValue(\"My Name\");\n\n    action.createParam(PARAM_EMAIL)\n      .setDescription(\"User email\")\n      .setExampleValue(\"myname@email.com\");\n\n    action.createParam(PARAM_SCM_ACCOUNTS)\n      .setDescription(\"SCM accounts. This parameter has been added in 5.1\")\n      .setDeprecatedKey(PARAM_SCM_ACCOUNTS_DEPRECATED)\n      .setExampleValue(\"myscmaccount1,myscmaccount2\");\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    userSession.checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n\n    String login = request.mandatoryParam(PARAM_LOGIN);\n    UpdateUser updateUser = UpdateUser.create(login);\n    if (request.hasParam(PARAM_NAME)) {\n      updateUser.setName(request.mandatoryParam(PARAM_NAME));\n    }\n    if (request.hasParam(PARAM_EMAIL)) {\n      updateUser.setEmail(request.param(PARAM_EMAIL));\n    }\n    if (request.hasParam(PARAM_SCM_ACCOUNTS)) {\n      updateUser.setScmAccounts(request.paramAsStrings(PARAM_SCM_ACCOUNTS));\n    }\n\n    userUpdater.update(updateUser);\n    writeResponse(response, login);\n  }","id":32781,"modified_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    userSession.checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n\n    String login = request.mandatoryParam(PARAM_LOGIN);\n    UpdateUser updateUser = UpdateUser.create(login);\n    if (request.hasParam(PARAM_NAME)) {\n      updateUser.setName(request.mandatoryParam(PARAM_NAME));\n    }\n    if (request.hasParam(PARAM_EMAIL)) {\n      updateUser.setEmail(request.param(PARAM_EMAIL));\n    }\n    if (request.hasParam(PARAM_SCM_ACCOUNTS) || request.hasParam(PARAM_SCM_ACCOUNTS_DEPRECATED)) {\n      updateUser.setScmAccounts(request.paramAsStrings(PARAM_SCM_ACCOUNTS));\n    }\n\n    userUpdater.update(updateUser);\n    writeResponse(response, login);\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_user() throws Exception {\n    createUser();\n\n    tester.newPostRequest(\"api/users\", \"update\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"Jon Snow\")\n      .setParam(\"email\", \"jon.snow@thegreatw.all\")\n      .setParam(\"scm_accounts\", \"jon.snow\")\n      .execute()\n      .assertJson(getClass(), \"update_user.json\");\n  }","id":32782,"modified_method":"@Test\n  public void update_user() throws Exception {\n    createUser();\n\n    tester.newPostRequest(\"api/users\", \"update\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"name\", \"Jon Snow\")\n      .setParam(\"email\", \"jon.snow@thegreatw.all\")\n      .setParam(\"scmAccounts\", \"jon.snow\")\n      .execute()\n      .assertJson(getClass(), \"update_user.json\");\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_only_scm_accounts() throws Exception {\n    createUser();\n\n    tester.newPostRequest(\"api/users\", \"update\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"scm_accounts\", \"jon.snow\")\n      .execute()\n      .assertJson(getClass(), \"update_scm_accounts.json\");\n  }","id":32783,"modified_method":"@Test\n  public void update_only_scm_accounts() throws Exception {\n    createUser();\n\n    tester.newPostRequest(\"api/users\", \"update\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"scmAccounts\", \"jon.snow\")\n      .execute()\n      .assertJson(getClass(), \"update_scm_accounts.json\");\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_create_action() {\n    WebService.Action action = controller.action(\"create\");\n    assertThat(action).isNotNull();\n    assertThat(action.isPost()).isTrue();\n    assertThat(action.params()).hasSize(6);\n  }","id":32784,"modified_method":"@Test\n  public void define_create_action() {\n    WebService.Action action = controller.action(\"create\");\n    assertThat(action).isNotNull();\n    assertThat(action.isPost()).isTrue();\n    assertThat(action.params()).hasSize(5);\n  }","commit_id":"21bdb331b57985f24eb372897d00af1f08142a45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public CreateAction(DbClient dbClient, UserSession userSession, System2 system, TypeValidations typeValidations, CustomMeasureJsonWriter customMeasureJsonWriter) {\n    this.dbClient = dbClient;\n    this.userSession = userSession;\n    this.system = system;\n    this.typeValidations = typeValidations;\n    this.customMeasureJsonWriter = customMeasureJsonWriter;\n  }","id":32785,"modified_method":"public CreateAction(DbClient dbClient, UserSession userSession, System2 system, CustomMeasureValidator validator, CustomMeasureJsonWriter customMeasureJsonWriter,\n    UserIndex userIndex) {\n    this.dbClient = dbClient;\n    this.userSession = userSession;\n    this.system = system;\n    this.validator = validator;\n    this.customMeasureJsonWriter = customMeasureJsonWriter;\n    this.userIndex = userIndex;\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    DbSession dbSession = dbClient.openSession(false);\n    String description = request.param(PARAM_DESCRIPTION);\n    long now = system.now();\n\n    try {\n      ComponentDto component = searchProject(dbSession, request);\n      MetricDto metric = searchMetric(dbSession, request);\n      checkPermissions(component);\n      checkMeasureDoesNotExistAlready(dbSession, component, metric);\n      CustomMeasureDto measure = new CustomMeasureDto()\n        .setComponentUuid(component.uuid())\n        .setComponentId(component.getId())\n        .setMetricId(metric.getId())\n        .setDescription(description)\n        .setCreatedAt(now);\n      setMeasureValue(measure, request, metric);\n      dbClient.customMeasureDao().insert(dbSession, measure);\n      dbSession.commit();\n\n      JsonWriter json = response.newJsonWriter();\n      writeMeasure(json, measure, component, metric, request.mandatoryParam(PARAM_VALUE));\n      json.close();\n    } finally {\n      MyBatis.closeQuietly(dbSession);\n    }\n  }","id":32786,"modified_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    DbSession dbSession = dbClient.openSession(false);\n    String valueAsString = request.mandatoryParam(PARAM_VALUE);\n    String description = request.param(PARAM_DESCRIPTION);\n    long now = system.now();\n\n    try {\n      ComponentDto component = searchProject(dbSession, request);\n      MetricDto metric = searchMetric(dbSession, request);\n      checkPermissions(component);\n      checkMeasureDoesNotExistAlready(dbSession, component, metric);\n      UserDoc user = userIndex.getByLogin(userSession.getLogin());\n      CustomMeasureDto measure = new CustomMeasureDto()\n        .setComponentUuid(component.uuid())\n        .setComponentId(component.getId())\n        .setMetricId(metric.getId())\n        .setDescription(description)\n        .setUserLogin(user.login())\n        .setCreatedAt(now);\n      validator.setMeasureValue(measure, valueAsString, metric);\n      dbClient.customMeasureDao().insert(dbSession, measure);\n      dbSession.commit();\n\n      JsonWriter json = response.newJsonWriter();\n      customMeasureJsonWriter.write(json, measure, metric, component, user);\n      json.close();\n    } finally {\n      MyBatis.closeQuietly(dbSession);\n    }\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    dbClient = new DbClient(db.database(), db.myBatis(), new CustomMeasureDao(), new MetricDao(), new ComponentDao());\n    dbSession = dbClient.openSession(false);\n    TypeValidations typeValidations = new TypeValidations(Arrays.asList(new BooleanTypeValidation(), new IntegerTypeValidation(), new FloatTypeValidation(),\n      new MetricLevelTypeValidation(), new LongTypeValidation()));\n    ws = new WsTester(new CustomMeasuresWs(new CreateAction(dbClient, userSession, System2.INSTANCE, typeValidations, new CustomMeasureJsonWriter())));\n    db.truncateTables();\n    userSession.setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n  }","id":32787,"modified_method":"@Before\n  public void setUp() {\n    dbClient = new DbClient(db.database(), db.myBatis(), new CustomMeasureDao(), new MetricDao(), new ComponentDao());\n    dbSession = dbClient.openSession(false);\n    ws = new WsTester(new CustomMeasuresWs(new CreateAction(dbClient, userSession, System2.INSTANCE, new CustomMeasureValidator(newFullTypeValidations()),\n      new CustomMeasureJsonWriter(new UserJsonWriter(userSession)), new UserIndex(es.client()))));\n    db.truncateTables();\n    userSession.login(\"login\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_float_custom_measure_indb() throws Exception {\n    MetricDto metric = insertMetricAndProject(ValueType.FLOAT, DEFAULT_PROJECT_UUID);\n\n    newRequest()\n      .setParam(CreateAction.PARAM_PROJECT_ID, DEFAULT_PROJECT_UUID)\n      .setParam(CreateAction.PARAM_METRIC_ID, metric.getId().toString())\n      .setParam(CreateAction.PARAM_VALUE, \"4.2\")\n      .execute();\n\n    CustomMeasureDto customMeasure = dbClient.customMeasureDao().selectByMetricId(dbSession, metric.getId()).get(0);\n    assertThat(customMeasure.getValue()).isCloseTo(4.2d, Offset.offset(0.01d));\n    assertThat(customMeasure.getTextValue()).isNullOrEmpty();\n  }","id":32788,"modified_method":"@Test\n  public void create_float_custom_measure_in_db() throws Exception {\n    MetricDto metric = insertMetricAndProject(ValueType.FLOAT, DEFAULT_PROJECT_UUID);\n\n    newRequest()\n      .setParam(CreateAction.PARAM_PROJECT_ID, DEFAULT_PROJECT_UUID)\n      .setParam(CreateAction.PARAM_METRIC_ID, metric.getId().toString())\n      .setParam(CreateAction.PARAM_VALUE, \"4.2\")\n      .execute();\n\n    CustomMeasureDto customMeasure = dbClient.customMeasureDao().selectByMetricId(dbSession, metric.getId()).get(0);\n    assertThat(customMeasure.getValue()).isCloseTo(4.2d, Offset.offset(0.01d));\n    assertThat(customMeasure.getTextValue()).isNullOrEmpty();\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public CustomMeasureDto selectById(DbSession session, long id) {\n    CustomMeasureDto customMeasure = selectNullableById(session, id);\n    if (customMeasure == null) {\n      throw new NotFoundException(String.format(\"CustomMeasure '%d' not found\", id));\n    }\n    return customMeasure;\n  }","id":32789,"modified_method":"public CustomMeasureDto selectById(DbSession session, long id) {\n    CustomMeasureDto customMeasure = selectNullableById(session, id);\n    if (customMeasure == null) {\n      throw new NotFoundException(String.format(\"Custom measure '%d' not found.\", id));\n    }\n    return customMeasure;\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void write(JsonWriter json, CustomMeasureDto measure, MetricDto metric, ComponentDto component) {\n    json.beginObject();\n    json.prop(FIELD_ID, String.valueOf(measure.getId()));\n    json.name(FIELD_METRIC);\n    writeMetric(json, metric);\n    json.prop(FIELD_PROJECT_ID, component.uuid());\n    json.prop(FIELD_PROJECT_KEY, component.key());\n    json.prop(FIELD_DESCRIPTION, measure.getDescription());\n    json.prop(FIELD_VALUE, measureValue(measure, metric));\n    json.endObject();\n  }","id":32790,"modified_method":"public void write(JsonWriter json, CustomMeasureDto measure, MetricDto metric, ComponentDto component, User user) {\n    json.beginObject();\n    json.prop(FIELD_ID, String.valueOf(measure.getId()));\n    json.name(FIELD_METRIC);\n    writeMetric(json, metric);\n    json.prop(FIELD_PROJECT_ID, component.uuid());\n    json.prop(FIELD_PROJECT_KEY, component.key());\n    json.prop(FIELD_DESCRIPTION, measure.getDescription());\n    json.prop(FIELD_VALUE, measureValue(measure, metric));\n    json.propDateTime(FIELD_CREATED_AT, new Date(measure.getCreatedAt()));\n    json.propDateTime(FIELD_UPDATED_AT, new Date(measure.getUpdatedAt()));\n    json.name(FIELD_USER);\n    userJsonWriter.write(json, user);\n    json.endObject();\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected void configureModule() {\n    add(\n      CustomMeasuresWs.class,\n      DeleteAction.class,\n      CustomMeasureJsonWriter.class,\n      CreateAction.class);\n  }","id":32791,"modified_method":"@Override\n  protected void configureModule() {\n    add(\n      CustomMeasuresWs.class,\n      CreateAction.class,\n      UpdateAction.class,\n      DeleteAction.class,\n      CustomMeasureJsonWriter.class,\n      CustomMeasureValidator.class);\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void verify_count_of_added_components() {\n    ComponentContainer container = new ComponentContainer();\n    new CustomMeasuresWsModule().configure(container);\n    assertThat(container.size()).isEqualTo(5);\n  }","id":32792,"modified_method":"@Test\n  public void verify_count_of_added_components() {\n    ComponentContainer container = new ComponentContainer();\n    new CustomMeasuresWsModule().configure(container);\n    assertThat(container.size()).isEqualTo(8);\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void create_action_properties() {\n    WebService.Action action = ws.controller(\"api/custom_measures\").action(\"create\");\n    assertThat(action.isPost()).isTrue();\n  }","id":32793,"modified_method":"@Test\n  public void create_action_properties() {\n    WebService.Action action = ws.controller(ENDPOINT).action(\"create\");\n    assertThat(action.isPost()).isTrue();\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    DbClient dbClient = mock(DbClient.class);\n    UserSession userSession = mock(UserSession.class);\n    ws = new WsTester(new CustomMeasuresWs(\n      new DeleteAction(dbClient, userSession),\n      new CreateAction(dbClient, userSession, System2.INSTANCE, mock(TypeValidations.class), mock(CustomMeasureJsonWriter.class))\n      ));\n  }","id":32794,"modified_method":"@Before\n  public void setUp() {\n    DbClient dbClient = mock(DbClient.class);\n    UserSession userSession = mock(UserSession.class);\n    ws = new WsTester(new CustomMeasuresWs(\n      new DeleteAction(dbClient, userSession),\n      new CreateAction(dbClient, userSession, System2.INSTANCE, mock(CustomMeasureValidator.class), mock(CustomMeasureJsonWriter.class), mock(UserIndex.class)),\n      new UpdateAction(dbClient, userSession, System2.INSTANCE, mock(CustomMeasureValidator.class), mock(CustomMeasureJsonWriter.class), mock(UserIndex.class))\n      ));\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void delete_action_properties() {\n    WebService.Action deleteAction = ws.controller(\"api/custom_measures\").action(\"delete\");\n    assertThat(deleteAction.isPost()).isTrue();\n  }","id":32795,"modified_method":"@Test\n  public void delete_action_properties() {\n    WebService.Action deleteAction = ws.controller(ENDPOINT).action(\"delete\");\n    assertThat(deleteAction.isPost()).isTrue();\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_ws() {\n    WebService.Controller controller = ws.controller(\"api/custom_measures\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(2);\n  }","id":32796,"modified_method":"@Test\n  public void define_ws() {\n    WebService.Controller controller = ws.controller(\"api/custom_measures\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(3);\n  }","commit_id":"04c9396965fa0c915c4e2c780b9576c99dfa7866","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"change_password\")\n      .setDescription(\"Update a user's password. Requires Administer System permission.\")\n      .setSince(\"5.2\")\n      .setPost(true)\n      .setHandler(this);\n\n    action.createParam(PARAM_LOGIN)\n      .setDescription(\"User login\")\n      .setRequired(true)\n      .setExampleValue(\"myuser\");\n\n    action.createParam(PARAM_PASSWORD)\n      .setDescription(\"New password\")\n      .setRequired(true)\n      .setExampleValue(\"mypassword\");\n\n    action.createParam(PARAM_PASSWORD_CONFIRMATION)\n      .setDescription(\"Must be the same value as \\\"password\\\"\")\n      .setRequired(true)\n      .setExampleValue(\"mypassword\");\n  }","id":32797,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"change_password\")\n      .setDescription(\"Update a user's password. Requires Administer System permission.\")\n      .setSince(\"5.2\")\n      .setPost(true)\n      .setHandler(this);\n\n    action.createParam(PARAM_LOGIN)\n      .setDescription(\"User login\")\n      .setRequired(true)\n      .setExampleValue(\"myuser\");\n\n    action.createParam(PARAM_PASSWORD)\n      .setDescription(\"New password\")\n      .setRequired(true)\n      .setExampleValue(\"mypassword\");\n  }","commit_id":"223cca42ca4f24a6d5790077eb0e638d421276f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    UserSession.get().checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n\n    String login = request.mandatoryParam(PARAM_LOGIN);\n    UpdateUser updateUser = UpdateUser.create(login)\n      .setPassword(request.mandatoryParam(PARAM_PASSWORD))\n      .setPasswordConfirmation(request.mandatoryParam(PARAM_PASSWORD_CONFIRMATION));\n\n    userUpdater.update(updateUser);\n    response.noContent();\n  }","id":32798,"modified_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    UserSession.get().checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n\n    String login = request.mandatoryParam(PARAM_LOGIN);\n    String password = request.mandatoryParam(PARAM_PASSWORD);\n    UpdateUser updateUser = UpdateUser.create(login)\n      .setPassword(password)\n      .setPasswordConfirmation(password);\n\n    userUpdater.update(updateUser);\n    response.noContent();\n  }","commit_id":"223cca42ca4f24a6d5790077eb0e638d421276f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_password() throws Exception {\n    createUser();\n    session.clearCache();\n    String originalPassword = dbClient.userDao().selectByLogin(session, \"john\").getCryptedPassword();\n\n    tester.newPostRequest(\"api/users\", \"change_password\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"password\", \"Valar Morghulis\")\n      .setParam(\"password_confirmation\", \"Valar Morghulis\")\n      .execute()\n      .assertNoContent();\n\n    session.clearCache();\n    String newPassword = dbClient.userDao().selectByLogin(session, \"john\").getCryptedPassword();\n    assertThat(newPassword).isNotEqualTo(originalPassword);\n  }","id":32799,"modified_method":"@Test\n  public void update_password() throws Exception {\n    createUser();\n    session.clearCache();\n    String originalPassword = dbClient.userDao().selectByLogin(session, \"john\").getCryptedPassword();\n\n    tester.newPostRequest(\"api/users\", \"change_password\")\n      .setParam(\"login\", \"john\")\n      .setParam(\"password\", \"Valar Morghulis\")\n      .execute()\n      .assertNoContent();\n\n    session.clearCache();\n    String newPassword = dbClient.userDao().selectByLogin(session, \"john\").getCryptedPassword();\n    assertThat(newPassword).isNotEqualTo(originalPassword);\n  }","commit_id":"223cca42ca4f24a6d5790077eb0e638d421276f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = NotFoundException.class)\n  public void fail_on_unknown_user() throws Exception {\n    tester.newPostRequest(\"api/users\", \"change_password\")\n      .setParam(\"login\", \"polop\")\n      .setParam(\"password\", \"polop\")\n      .setParam(\"password_confirmation\", \"polop\")\n      .execute();\n  }","id":32800,"modified_method":"@Test(expected = NotFoundException.class)\n  public void fail_on_unknown_user() throws Exception {\n    tester.newPostRequest(\"api/users\", \"change_password\")\n      .setParam(\"login\", \"polop\")\n      .setParam(\"password\", \"polop\")\n      .execute();\n  }","commit_id":"223cca42ca4f24a6d5790077eb0e638d421276f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    WsTester tester = new WsTester(new UsersWs(\n      new CreateAction(mock(UserIndex.class), mock(UserUpdater.class), mock(I18n.class)),\n      new UpdateAction(mock(UserIndex.class), mock(UserUpdater.class)),\n      new CurrentUserAction(),\n      new DeactivateAction(mock(UserIndex.class), mock(UserUpdater.class)),\n      new ChangePasswordAction(mock(UserUpdater.class)),\n      new CurrentUserAction()));\n    controller = tester.controller(\"api/users\");\n  }","id":32801,"modified_method":"@Before\n  public void setUp() throws Exception {\n    WsTester tester = new WsTester(new UsersWs(\n      new CreateAction(mock(UserIndex.class), mock(UserUpdater.class), mock(I18n.class)),\n      new UpdateAction(mock(UserIndex.class), mock(UserUpdater.class)),\n      new CurrentUserAction(),\n      new DeactivateAction(mock(UserIndex.class), mock(UserUpdater.class)),\n      new ChangePasswordAction(mock(UserUpdater.class))));\n    controller = tester.controller(\"api/users\");\n  }","commit_id":"223cca42ca4f24a6d5790077eb0e638d421276f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_controller() throws Exception {\n    assertThat(controller).isNotNull();\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.since()).isEqualTo(\"3.6\");\n    assertThat(controller.actions()).hasSize(7);\n  }","id":32802,"modified_method":"@Test\n  public void define_controller() throws Exception {\n    assertThat(controller).isNotNull();\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.since()).isEqualTo(\"3.6\");\n    assertThat(controller.actions()).hasSize(6);\n  }","commit_id":"223cca42ca4f24a6d5790077eb0e638d421276f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_change_password_action() throws Exception {\n    WebService.Action action = controller.action(\"change_password\");\n    assertThat(action).isNotNull();\n    assertThat(action.isPost()).isTrue();\n    assertThat(action.params()).hasSize(3);\n  }","id":32803,"modified_method":"@Test\n  public void define_change_password_action() throws Exception {\n    WebService.Action action = controller.action(\"change_password\");\n    assertThat(action).isNotNull();\n    assertThat(action.isPost()).isTrue();\n    assertThat(action.params()).hasSize(2);\n  }","commit_id":"223cca42ca4f24a6d5790077eb0e638d421276f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void computeFollowElements(FollowElementCalculator calculator, FollowElement element) {\n\t\tif (element.getLookAhead() <= 1) {\n\t\t\tAssignment ass = EcoreUtil2.getContainerOfType(element.getGrammarElement(), Assignment.class);\n\t\t\tif (ass != null)\n\t\t\t\tcalculator.doSwitch(ass);\n\t\t\telse {\n\t\t\t\tcalculator.doSwitch(element.getGrammarElement());\n\t\t\t\tParserRule rule = EcoreUtil2.getContainerOfType(element.getGrammarElement(), ParserRule.class);\n\t\t\t\tif (rule != null && GrammarUtil.isDatatypeRule(rule)) {\n\t\t\t\t\tfor (int i = element.getLocalTrace().size() - 1; i >= 0; i--) {\n\t\t\t\t\t\tAbstractElement grammarElement = element.getLocalTrace().get(i);\n\t\t\t\t\t\tif (grammarElement instanceof Assignment) {\n\t\t\t\t\t\t\tcalculator.doSwitch(grammarElement);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tCollection<FollowElement> followElements = parser.getFollowElements(element);\n\t\tfor(FollowElement newElement: followElements) {\n\t\t\tcomputeFollowElements(calculator, newElement);\n\t\t}\n\t}","id":32804,"modified_method":"protected void computeFollowElements(FollowElementCalculator calculator, FollowElement element) {\n\t\tif (element.getLookAhead() <= 1) {\n\t\t\tAssignment ass = EcoreUtil2.getContainerOfType(element.getGrammarElement(), Assignment.class);\n\t\t\tif (ass != null)\n\t\t\t\tcalculator.doSwitch(ass);\n\t\t\telse {\n\t\t\t\tcalculator.doSwitch(element.getGrammarElement());\n\t\t\t\tParserRule rule = EcoreUtil2.getContainerOfType(element.getGrammarElement(), ParserRule.class);\n\t\t\t\tif (rule != null && GrammarUtil.isDatatypeRule(rule)) {\n\t\t\t\t\tfor (int i = element.getLocalTrace().size() - 1; i >= 0; i--) {\n\t\t\t\t\t\tAbstractElement grammarElement = element.getLocalTrace().get(i);\n\t\t\t\t\t\tif (grammarElement instanceof Assignment) {\n\t\t\t\t\t\t\tcalculator.doSwitch(grammarElement);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tCollection<FollowElement> followElements = parser.getFollowElements(element);\n\t\tfor(FollowElement newElement: followElements) {\n\t\t\tif (newElement.getLookAhead() != element.getLookAhead() || newElement.getGrammarElement() != element.getGrammarElement())\n\t\t\t\tcomputeFollowElements(calculator, newElement);\n\t\t}\n\t}","commit_id":"64e602fc3c7d9a5f2de1692c271c8587ce3148dd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean canBeCalledAfter(AbstractRule rule, final EObject previousGrammarElement, final EObject nextGrammarElement) {\n\t\treturn new XtextSwitch<Boolean>() {\n\t\t\tprivate Set<AbstractRule> visiting = new HashSet<AbstractRule>();\n\t\t\tprivate Map<AbstractRule, Boolean> visited = Maps.newHashMapWithExpectedSize(4);\n\t\t\tprivate EObject grammarElement = previousGrammarElement;\n\t\t\tprivate Boolean result = Boolean.FALSE;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractRule(AbstractRule object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (!visiting.add(object))\n\t\t\t\t\treturn Boolean.FALSE;\n\t\t\t\tif (visited.containsKey(object))\n\t\t\t\t\treturn visited.get(object);\n\t\t\t\tEObject wasGrammarElement = grammarElement;\n\t\t\t\tBoolean result = doSwitch(object.getAlternatives());\n\t\t\t\tvisiting.remove(object);\n\t\t\t\tif (wasGrammarElement == grammarElement) // we store the result per grammarElement for performance reasons\n\t\t\t\t\tvisited.put(object, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tprivate boolean checkFurther(EObject object) {\n\t\t\t\tif (object == grammarElement) {\n\t\t\t\t\tif (grammarElement == previousGrammarElement) {\n\t\t\t\t\t\tgrammarElement = nextGrammarElement;\n\t\t\t\t\t\tvisited.clear();\n\t\t\t\t\t\tvisiting.clear();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tresult = Boolean.TRUE;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseTerminalRule(TerminalRule object) {\n\t\t\t\tcheckFurther(object);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseGroup(Group object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAlternatives(Alternatives object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tEObject wasGrammarElement = this.grammarElement;\n\t\t\t\tSet<AbstractRule> visiting = Sets.newHashSet(this.visiting);\n\t\t\t\tboolean foundSomething = false;\n\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (foundSomething) {\n\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t}\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\twasGrammarElement = this.grammarElement;\n\t\t\t\t\tvisiting = Sets.newHashSet(this.visiting);\n\t\t\t\t\tfoundSomething = false;\n\t\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (foundSomething) {\n\t\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractElement(AbstractElement object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAssignment(Assignment object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseCrossReference(CrossReference object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseRuleCall(RuleCall object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseEnumLiteralDeclaration(EnumLiteralDeclaration object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tBoolean result = doSwitch(object.getLiteral());\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t}.doSwitch(rule);\n\t}","id":32805,"modified_method":"protected boolean canBeCalledAfter(AbstractRule rule, final EObject previousGrammarElement, final EObject nextGrammarElement) {\n\t\treturn new XtextSwitch<Boolean>() {\n\t\t\tprivate Set<AbstractRule> visiting = new HashSet<AbstractRule>();\n\t\t\tprivate Map<AbstractRule, Boolean> visited = Maps.newHashMapWithExpectedSize(4);\n\t\t\tprivate EObject grammarElement = previousGrammarElement;\n\t\t\tprivate EObject queuedGrammarElement = nextGrammarElement;\n\t\t\tprivate Boolean result = Boolean.FALSE;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractRule(AbstractRule object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (!visiting.add(object))\n\t\t\t\t\treturn Boolean.FALSE;\n\t\t\t\tif (visited.containsKey(object)) {\n\t\t\t\t\tvisiting.remove(object);\n\t\t\t\t\treturn visited.get(object);\n\t\t\t\t}\n\t\t\t\tEObject wasGrammarElement = grammarElement;\n\t\t\t\tBoolean result = doSwitch(object.getAlternatives());\n\t\t\t\tvisiting.remove(object);\n\t\t\t\tif (wasGrammarElement == grammarElement) // we store the result per grammarElement for performance reasons\n\t\t\t\t\tvisited.put(object, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tprivate boolean checkFurther(EObject object) {\n\t\t\t\tif (object == grammarElement) {\n\t\t\t\t\tif (queuedGrammarElement != null) {\n\t\t\t\t\t\tgrammarElement = queuedGrammarElement;\n\t\t\t\t\t\tqueuedGrammarElement = null;\n\t\t\t\t\t\tvisited.clear();\n\t\t\t\t\t\tvisiting.clear();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tresult = Boolean.TRUE;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseTerminalRule(TerminalRule object) {\n\t\t\t\tcheckFurther(object);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseGroup(Group object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAlternatives(Alternatives object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tEObject wasGrammarElement = this.grammarElement;\n\t\t\t\tSet<AbstractRule> visiting = Sets.newHashSet(this.visiting);\n\t\t\t\tboolean foundSomething = false;\n\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (foundSomething) {\n\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t}\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\twasGrammarElement = this.grammarElement;\n\t\t\t\t\tvisiting = Sets.newHashSet(this.visiting);\n\t\t\t\t\tfoundSomething = false;\n\t\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (foundSomething) {\n\t\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractElement(AbstractElement object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAssignment(Assignment object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseCrossReference(CrossReference object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseRuleCall(RuleCall object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseEnumLiteralDeclaration(EnumLiteralDeclaration object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tBoolean result = doSwitch(object.getLiteral());\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t}.doSwitch(rule);\n\t}","commit_id":"64e602fc3c7d9a5f2de1692c271c8587ce3148dd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createContexts(\n\t\t\tITextViewer viewer, IParseResult parseResult, int completionOffset,\n\t\t\tCompositeNode rootNode, AbstractNode lastCompleteNode, AbstractNode currentNode,\n\t\t\tList<ContentAssistContext> result, String prefix,\n\t\t\tEObject previousModel, Collection<FollowElement> followElements) {\n\t\tMultimap<EObject, FollowElement> contextMap = computeCurrentModel(previousModel, lastCompleteNode, followElements);\n\t\tfor (Entry<EObject, Collection<FollowElement>> entry : contextMap.asMap().entrySet()) {\n\t\t\tContentAssistContext context = createContext(viewer, completionOffset, parseResult, rootNode,\n\t\t\t\t\tlastCompleteNode, entry.getKey(), currentNode, prefix);\n\t\t\tcomputeFollowElements(entry.getValue(), context);\n\t\t\tresult.add(context);\n\t\t}\n\t}","id":32806,"modified_method":"protected void createContexts(\n\t\t\tITextViewer viewer, IParseResult parseResult, int completionOffset,\n\t\t\tCompositeNode rootNode, AbstractNode lastCompleteNode, AbstractNode currentNode,\n\t\t\tList<ContentAssistContext> result, String prefix,\n\t\t\tEObject previousModel, Collection<FollowElement> followElements) {\n\t\tSet<AbstractElement> followElementAsAbstractElements = Sets.newLinkedHashSet();\n\t\tcomputeFollowElements(followElements, followElementAsAbstractElements);\n\t\tMultimap<EObject, AbstractElement> contextMap = computeCurrentModel(previousModel, lastCompleteNode, followElementAsAbstractElements);\n\t\tfor (Entry<EObject, Collection<AbstractElement>> entry : contextMap.asMap().entrySet()) {\n\t\t\tContentAssistContext context = createContext(viewer, completionOffset, parseResult, rootNode,\n\t\t\t\t\tlastCompleteNode, entry.getKey(), currentNode, prefix);\n\t\t\tfor(AbstractElement element: entry.getValue()) {\n\t\t\t\tcontext.accept(element);\n\t\t\t}\n\t\t\tresult.add(context);\n\t\t}\n\t}","commit_id":"64e602fc3c7d9a5f2de1692c271c8587ce3148dd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Multimap<EObject, FollowElement> computeCurrentModel(EObject currentModel, AbstractNode lastCompleteNode,\n\t\t\tCollection<FollowElement> followElements) {\n\t\tMultimap<EObject, FollowElement> result = Multimaps.newArrayListMultimap();\n\t\tNodeAdapter adapter = NodeUtil.getNodeAdapter(currentModel);\n\t\tif (adapter == null || adapter.getParserNode() == null) {\n\t\t\tresult.putAll(currentModel, followElements);\n\t\t\treturn result;\n\t\t}\n\t\tCompositeNode currentParserNode = adapter.getParserNode();\n\t\tEObject currentGrammarElement = currentParserNode.getGrammarElement();\n\t\tAbstractRule currentRule = getRule(currentGrammarElement);\n\t\tfor (FollowElement element : followElements) {\n\t\t\tAbstractElement grammarElement = element.getGrammarElement();\n\t\t\tEObject loopGrammarElement = currentGrammarElement;\n\t\t\tAbstractRule rule = currentRule;\n\t\t\tCompositeNode loopParserNode = currentParserNode;\n\t\t\tEObject loopLastGrammarElement = lastCompleteNode.getGrammarElement();\n\t\t\twhile (!canBeCalledAfter(rule, loopLastGrammarElement, grammarElement) && loopParserNode.getParent() != null) {\n\t\t\t\tloopLastGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\twhile (loopParserNode.getGrammarElement() == null && loopParserNode.getParent() != null)\n\t\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\tloopGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\trule = getRule(loopGrammarElement);\n\t\t\t}\n\t\t\tEObject context = NodeUtil.getNearestSemanticObject(loopParserNode);\n\t\t\tresult.put(context, element);\n\t\t}\n\t\treturn result;\n\t}","id":32807,"modified_method":"protected Multimap<EObject, AbstractElement> computeCurrentModel(EObject currentModel, AbstractNode lastCompleteNode,\n\t\t\tCollection<AbstractElement> followElements) {\n\t\tMultimap<EObject, AbstractElement> result = Multimaps.newArrayListMultimap();\n\t\tNodeAdapter adapter = NodeUtil.getNodeAdapter(currentModel);\n\t\tif (adapter == null || adapter.getParserNode() == null) {\n\t\t\tresult.putAll(currentModel, followElements);\n\t\t\treturn result;\n\t\t}\n\t\tCompositeNode currentParserNode = adapter.getParserNode();\n\t\tEObject currentGrammarElement = currentParserNode.getGrammarElement();\n\t\tAbstractRule currentRule = getRule(currentGrammarElement);\n\t\tfor (AbstractElement grammarElement : followElements) {\n\t\t\tEObject loopGrammarElement = currentGrammarElement;\n\t\t\tAbstractRule rule = currentRule;\n\t\t\tCompositeNode loopParserNode = currentParserNode;\n\t\t\tEObject loopLastGrammarElement = lastCompleteNode.getGrammarElement();\n\t\t\twhile (!canBeCalledAfter(rule, loopLastGrammarElement, grammarElement) && loopParserNode.getParent() != null) {\n\t\t\t\tloopLastGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\twhile (loopParserNode.getGrammarElement() == null && loopParserNode.getParent() != null)\n\t\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\tloopGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\trule = getRule(loopGrammarElement);\n\t\t\t}\n\t\t\tEObject context = NodeUtil.getNearestSemanticObject(loopParserNode);\n\t\t\tresult.put(context, grammarElement);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"64e602fc3c7d9a5f2de1692c271c8587ce3148dd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void computeFollowElements(Collection<FollowElement> followElements, final ContentAssistContext result) {\n\t\tFollowElementCalculator calculator = new FollowElementCalculator();\n\t\tcalculator.acceptor =\n\t\t\tnew IFollowElementAcceptor(){\n\t\t\t\tpublic void accept(AbstractElement element) {\n\t\t\t\t\tParserRule rule = GrammarUtil.containingParserRule(element);\n\t\t\t\t\tif (rule == null || !GrammarUtil.isDatatypeRule(rule))\n\t\t\t\t\t\tresult.accept(element);\n\t\t\t\t}\n\t\t\t};\n\t\tfor(FollowElement element: followElements) {\n\t\t\tcomputeFollowElements(calculator, element);\n\t\t}\n\t}","id":32808,"modified_method":"protected void computeFollowElements(Collection<FollowElement> followElements, final Collection<AbstractElement> result) {\n\t\tFollowElementCalculator calculator = new FollowElementCalculator();\n\t\tcalculator.acceptor = new IFollowElementAcceptor(){\n\t\t\tpublic void accept(AbstractElement element) {\n\t\t\t\tParserRule rule = GrammarUtil.containingParserRule(element);\n\t\t\t\tif (rule == null || !GrammarUtil.isDatatypeRule(rule))\n\t\t\t\t\tresult.add(element);\n\t\t\t}\n\t\t};\n\t\tfor(FollowElement element: followElements) {\n\t\t\tcomputeFollowElements(calculator, element);\n\t\t}\n\t}","commit_id":"64e602fc3c7d9a5f2de1692c271c8587ce3148dd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean canBeCalledAfter(AbstractRule rule, final EObject previousGrammarElement, final EObject nextGrammarElement) {\n\t\treturn new XtextSwitch<Boolean>() {\n\t\t\tprivate Set<AbstractRule> visiting = new HashSet<AbstractRule>();\n\t\t\tprivate Map<AbstractRule, Boolean> visited = Maps.newHashMapWithExpectedSize(4);\n\t\t\tprivate EObject grammarElement = previousGrammarElement;\n\t\t\tprivate Boolean result = Boolean.FALSE;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractRule(AbstractRule object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (!visiting.add(object))\n\t\t\t\t\treturn Boolean.FALSE;\n\t\t\t\tif (visited.containsKey(object))\n\t\t\t\t\treturn visited.get(object);\n\t\t\t\tEObject wasGrammarElement = grammarElement;\n\t\t\t\tBoolean result = doSwitch(object.getAlternatives());\n\t\t\t\tvisiting.remove(object);\n\t\t\t\tif (wasGrammarElement == grammarElement) // we store the result per grammarElement for performance reasons\n\t\t\t\t\tvisited.put(object, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tprivate boolean checkFurther(EObject object) {\n\t\t\t\tif (object == grammarElement) {\n\t\t\t\t\tif (grammarElement == previousGrammarElement) {\n\t\t\t\t\t\tgrammarElement = nextGrammarElement;\n\t\t\t\t\t\tvisited.clear();\n\t\t\t\t\t\tvisiting.clear();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tresult = Boolean.TRUE;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseTerminalRule(TerminalRule object) {\n\t\t\t\tcheckFurther(object);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseGroup(Group object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAlternatives(Alternatives object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tEObject wasGrammarElement = this.grammarElement;\n\t\t\t\tSet<AbstractRule> visiting = Sets.newHashSet(this.visiting);\n\t\t\t\tboolean foundSomething = false;\n\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (foundSomething) {\n\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t}\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\twasGrammarElement = this.grammarElement;\n\t\t\t\t\tvisiting = Sets.newHashSet(this.visiting);\n\t\t\t\t\tfoundSomething = false;\n\t\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (foundSomething) {\n\t\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractElement(AbstractElement object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAssignment(Assignment object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseCrossReference(CrossReference object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseRuleCall(RuleCall object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseEnumLiteralDeclaration(EnumLiteralDeclaration object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tBoolean result = doSwitch(object.getLiteral());\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t}.doSwitch(rule);\n\t}","id":32809,"modified_method":"protected boolean canBeCalledAfter(AbstractRule rule, final EObject previousGrammarElement, final EObject nextGrammarElement) {\n\t\treturn new XtextSwitch<Boolean>() {\n\t\t\tprivate Set<AbstractRule> visiting = new HashSet<AbstractRule>();\n\t\t\tprivate Map<AbstractRule, Boolean> visited = Maps.newHashMapWithExpectedSize(4);\n\t\t\tprivate EObject grammarElement = previousGrammarElement;\n\t\t\tprivate EObject queuedGrammarElement = nextGrammarElement;\n\t\t\tprivate Boolean result = Boolean.FALSE;\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractRule(AbstractRule object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (!visiting.add(object))\n\t\t\t\t\treturn Boolean.FALSE;\n\t\t\t\tif (visited.containsKey(object)) {\n\t\t\t\t\tvisiting.remove(object);\n\t\t\t\t\treturn visited.get(object);\n\t\t\t\t}\n\t\t\t\tEObject wasGrammarElement = grammarElement;\n\t\t\t\tBoolean result = doSwitch(object.getAlternatives());\n\t\t\t\tvisiting.remove(object);\n\t\t\t\tif (wasGrammarElement == grammarElement) // we store the result per grammarElement for performance reasons\n\t\t\t\t\tvisited.put(object, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tprivate boolean checkFurther(EObject object) {\n\t\t\t\tif (object == grammarElement) {\n\t\t\t\t\tif (queuedGrammarElement != null) {\n\t\t\t\t\t\tgrammarElement = queuedGrammarElement;\n\t\t\t\t\t\tqueuedGrammarElement = null;\n\t\t\t\t\t\tvisited.clear();\n\t\t\t\t\t\tvisiting.clear();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tresult = Boolean.TRUE;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseTerminalRule(TerminalRule object) {\n\t\t\t\tcheckFurther(object);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseGroup(Group object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tfor (AbstractElement token : object.getTokens())\n\t\t\t\t\t\tif (doSwitch(token))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAlternatives(Alternatives object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tEObject wasGrammarElement = this.grammarElement;\n\t\t\t\tSet<AbstractRule> visiting = Sets.newHashSet(this.visiting);\n\t\t\t\tboolean foundSomething = false;\n\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (foundSomething) {\n\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t}\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\twasGrammarElement = this.grammarElement;\n\t\t\t\t\tvisiting = Sets.newHashSet(this.visiting);\n\t\t\t\t\tfoundSomething = false;\n\t\t\t\t\tfor (AbstractElement group : object.getGroups()) {\n\t\t\t\t\t\tthis.grammarElement = wasGrammarElement;\n\t\t\t\t\t\tthis.visiting = Sets.newHashSet(visiting);\n\t\t\t\t\t\tif (doSwitch(group))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tif (wasGrammarElement != this.grammarElement) {\n\t\t\t\t\t\t\tfoundSomething = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (foundSomething) {\n\t\t\t\t\t\tthis.grammarElement = nextGrammarElement;\n\t\t\t\t\t\tthis.visiting.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAbstractElement(AbstractElement object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseAssignment(Assignment object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseCrossReference(CrossReference object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getTerminal()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseRuleCall(RuleCall object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\treturn true;\n\t\t\t\tif (GrammarUtil.isMultipleCardinality(object)) {\n\t\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\t\treturn result;\n\t\t\t\t\tif (doSwitch(object.getRule()))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Boolean caseEnumLiteralDeclaration(EnumLiteralDeclaration object) {\n\t\t\t\tif (!checkFurther(object))\n\t\t\t\t\treturn result;\n\t\t\t\tBoolean result = doSwitch(object.getLiteral());\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t}.doSwitch(rule);\n\t}","commit_id":"d7204dd5012d0cac9d850e6f78a5d87857108ba2","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void computeFollowElements(FollowElementCalculator calculator, FollowElement element) {\n\t\tif (element.getLookAhead() <= 1) {\n\t\t\tAssignment ass = EcoreUtil2.getContainerOfType(element.getGrammarElement(), Assignment.class);\n\t\t\tif (ass != null)\n\t\t\t\tcalculator.doSwitch(ass);\n\t\t\telse {\n\t\t\t\tcalculator.doSwitch(element.getGrammarElement());\n\t\t\t\tParserRule rule = EcoreUtil2.getContainerOfType(element.getGrammarElement(), ParserRule.class);\n\t\t\t\tif (rule != null && GrammarUtil.isDatatypeRule(rule)) {\n\t\t\t\t\tfor (int i = element.getLocalTrace().size() - 1; i >= 0; i--) {\n\t\t\t\t\t\tAbstractElement grammarElement = element.getLocalTrace().get(i);\n\t\t\t\t\t\tif (grammarElement instanceof Assignment) {\n\t\t\t\t\t\t\tcalculator.doSwitch(grammarElement);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tCollection<FollowElement> followElements = parser.getFollowElements(element);\n\t\tfor(FollowElement newElement: followElements) {\n\t\t\tcomputeFollowElements(calculator, newElement);\n\t\t}\n\t}","id":32810,"modified_method":"protected void computeFollowElements(FollowElementCalculator calculator, FollowElement element) {\n\t\tif (element.getLookAhead() <= 1) {\n\t\t\tAssignment ass = EcoreUtil2.getContainerOfType(element.getGrammarElement(), Assignment.class);\n\t\t\tif (ass != null)\n\t\t\t\tcalculator.doSwitch(ass);\n\t\t\telse {\n\t\t\t\tcalculator.doSwitch(element.getGrammarElement());\n\t\t\t\tParserRule rule = EcoreUtil2.getContainerOfType(element.getGrammarElement(), ParserRule.class);\n\t\t\t\tif (rule != null && GrammarUtil.isDatatypeRule(rule)) {\n\t\t\t\t\tfor (int i = element.getLocalTrace().size() - 1; i >= 0; i--) {\n\t\t\t\t\t\tAbstractElement grammarElement = element.getLocalTrace().get(i);\n\t\t\t\t\t\tif (grammarElement instanceof Assignment) {\n\t\t\t\t\t\t\tcalculator.doSwitch(grammarElement);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tCollection<FollowElement> followElements = parser.getFollowElements(element);\n\t\tfor(FollowElement newElement: followElements) {\n\t\t\tif (newElement.getLookAhead() != element.getLookAhead() || newElement.getGrammarElement() != element.getGrammarElement())\n\t\t\t\tcomputeFollowElements(calculator, newElement);\n\t\t}\n\t}","commit_id":"d7204dd5012d0cac9d850e6f78a5d87857108ba2","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void computeFollowElements(Collection<FollowElement> followElements, final ContentAssistContext result) {\n\t\tFollowElementCalculator calculator = new FollowElementCalculator();\n\t\tcalculator.acceptor =\n\t\t\tnew IFollowElementAcceptor(){\n\t\t\t\tpublic void accept(AbstractElement element) {\n\t\t\t\t\tParserRule rule = GrammarUtil.containingParserRule(element);\n\t\t\t\t\tif (rule == null || !GrammarUtil.isDatatypeRule(rule))\n\t\t\t\t\t\tresult.accept(element);\n\t\t\t\t}\n\t\t\t};\n\t\tfor(FollowElement element: followElements) {\n\t\t\tcomputeFollowElements(calculator, element);\n\t\t}\n\t}","id":32811,"modified_method":"protected void computeFollowElements(Collection<FollowElement> followElements, final Collection<AbstractElement> result) {\n\t\tFollowElementCalculator calculator = new FollowElementCalculator();\n\t\tcalculator.acceptor = new IFollowElementAcceptor(){\n\t\t\tpublic void accept(AbstractElement element) {\n\t\t\t\tParserRule rule = GrammarUtil.containingParserRule(element);\n\t\t\t\tif (rule == null || !GrammarUtil.isDatatypeRule(rule))\n\t\t\t\t\tresult.add(element);\n\t\t\t}\n\t\t};\n\t\tfor(FollowElement element: followElements) {\n\t\t\tcomputeFollowElements(calculator, element);\n\t\t}\n\t}","commit_id":"d7204dd5012d0cac9d850e6f78a5d87857108ba2","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void createContexts(\n\t\t\tITextViewer viewer, IParseResult parseResult, int completionOffset,\n\t\t\tCompositeNode rootNode, AbstractNode lastCompleteNode, AbstractNode currentNode,\n\t\t\tList<ContentAssistContext> result, String prefix,\n\t\t\tEObject previousModel, Collection<FollowElement> followElements) {\n\t\tMultimap<EObject, FollowElement> contextMap = computeCurrentModel(previousModel, lastCompleteNode, followElements);\n\t\tfor (Entry<EObject, Collection<FollowElement>> entry : contextMap.asMap().entrySet()) {\n\t\t\tContentAssistContext context = createContext(viewer, completionOffset, parseResult, rootNode,\n\t\t\t\t\tlastCompleteNode, entry.getKey(), currentNode, prefix);\n\t\t\tcomputeFollowElements(entry.getValue(), context);\n\t\t\tresult.add(context);\n\t\t}\n\t}","id":32812,"modified_method":"protected void createContexts(\n\t\t\tITextViewer viewer, IParseResult parseResult, int completionOffset,\n\t\t\tCompositeNode rootNode, AbstractNode lastCompleteNode, AbstractNode currentNode,\n\t\t\tList<ContentAssistContext> result, String prefix,\n\t\t\tEObject previousModel, Collection<FollowElement> followElements) {\n\t\tSet<AbstractElement> followElementAsAbstractElements = Sets.newLinkedHashSet();\n\t\tcomputeFollowElements(followElements, followElementAsAbstractElements);\n\t\tMultimap<EObject, AbstractElement> contextMap = computeCurrentModel(previousModel, lastCompleteNode, followElementAsAbstractElements);\n\t\tfor (Entry<EObject, Collection<AbstractElement>> entry : contextMap.asMap().entrySet()) {\n\t\t\tContentAssistContext context = createContext(viewer, completionOffset, parseResult, rootNode,\n\t\t\t\t\tlastCompleteNode, entry.getKey(), currentNode, prefix);\n\t\t\tfor(AbstractElement element: entry.getValue()) {\n\t\t\t\tcontext.accept(element);\n\t\t\t}\n\t\t\tresult.add(context);\n\t\t}\n\t}","commit_id":"d7204dd5012d0cac9d850e6f78a5d87857108ba2","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Multimap<EObject, FollowElement> computeCurrentModel(EObject currentModel, AbstractNode lastCompleteNode,\n\t\t\tCollection<FollowElement> followElements) {\n\t\tMultimap<EObject, FollowElement> result = Multimaps.newArrayListMultimap();\n\t\tNodeAdapter adapter = NodeUtil.getNodeAdapter(currentModel);\n\t\tif (adapter == null || adapter.getParserNode() == null) {\n\t\t\tresult.putAll(currentModel, followElements);\n\t\t\treturn result;\n\t\t}\n\t\tCompositeNode currentParserNode = adapter.getParserNode();\n\t\tEObject currentGrammarElement = currentParserNode.getGrammarElement();\n\t\tAbstractRule currentRule = getRule(currentGrammarElement);\n\t\tfor (FollowElement element : followElements) {\n\t\t\tAbstractElement grammarElement = element.getGrammarElement();\n\t\t\tEObject loopGrammarElement = currentGrammarElement;\n\t\t\tAbstractRule rule = currentRule;\n\t\t\tCompositeNode loopParserNode = currentParserNode;\n\t\t\tEObject loopLastGrammarElement = lastCompleteNode.getGrammarElement();\n\t\t\twhile (!canBeCalledAfter(rule, loopLastGrammarElement, grammarElement) && loopParserNode.getParent() != null) {\n\t\t\t\tloopLastGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\twhile (loopParserNode.getGrammarElement() == null && loopParserNode.getParent() != null)\n\t\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\tloopGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\trule = getRule(loopGrammarElement);\n\t\t\t}\n\t\t\tEObject context = NodeUtil.getNearestSemanticObject(loopParserNode);\n\t\t\tresult.put(context, element);\n\t\t}\n\t\treturn result;\n\t}","id":32813,"modified_method":"protected Multimap<EObject, AbstractElement> computeCurrentModel(EObject currentModel, AbstractNode lastCompleteNode,\n\t\t\tCollection<AbstractElement> followElements) {\n\t\tMultimap<EObject, AbstractElement> result = Multimaps.newArrayListMultimap();\n\t\tNodeAdapter adapter = NodeUtil.getNodeAdapter(currentModel);\n\t\tif (adapter == null || adapter.getParserNode() == null) {\n\t\t\tresult.putAll(currentModel, followElements);\n\t\t\treturn result;\n\t\t}\n\t\tCompositeNode currentParserNode = adapter.getParserNode();\n\t\tEObject currentGrammarElement = currentParserNode.getGrammarElement();\n\t\tAbstractRule currentRule = getRule(currentGrammarElement);\n\t\tfor (AbstractElement grammarElement : followElements) {\n\t\t\tEObject loopGrammarElement = currentGrammarElement;\n\t\t\tAbstractRule rule = currentRule;\n\t\t\tCompositeNode loopParserNode = currentParserNode;\n\t\t\tEObject loopLastGrammarElement = lastCompleteNode.getGrammarElement();\n\t\t\twhile (!canBeCalledAfter(rule, loopLastGrammarElement, grammarElement) && loopParserNode.getParent() != null) {\n\t\t\t\tloopLastGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\twhile (loopParserNode.getGrammarElement() == null && loopParserNode.getParent() != null)\n\t\t\t\t\tloopParserNode = loopParserNode.getParent();\n\t\t\t\tloopGrammarElement = loopParserNode.getGrammarElement();\n\t\t\t\trule = getRule(loopGrammarElement);\n\t\t\t}\n\t\t\tEObject context = NodeUtil.getNearestSemanticObject(loopParserNode);\n\t\t\tresult.put(context, grammarElement);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"d7204dd5012d0cac9d850e6f78a5d87857108ba2","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void computeFollowElements(FollowElementCalculator calculator, FollowElement element, Multimap<Integer, List<AbstractElement>> visited) {\n\t\t\tList<AbstractElement> currentState = Lists.newArrayList(element.getLocalTrace());\n\t\t\tcurrentState.add(element.getGrammarElement());\n\t\t\tif (!visited.put(element.getLookAhead(), currentState))\n\t\t\t\treturn;\n\t\t\tif (element.getLookAhead() <= 1) {\n\t\t\t\tfor(AbstractElement abstractElement: currentState) {\n\t\t\t\t\tAssignment ass = EcoreUtil2.getContainerOfType(abstractElement, Assignment.class);\n\t\t\t\t\tif (ass != null)\n\t\t\t\t\t\tcalculator.doSwitch(ass);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (abstractElement instanceof UnorderedGroup && abstractElement == element.getGrammarElement()) {\n\t\t\t\t\t\t\tcalculator.doSwitch((UnorderedGroup) abstractElement, element.getHandledUnorderedGroupElements());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcalculator.doSwitch(abstractElement);\n\t\t\t\t\t\t\tif (GrammarUtil.isOptionalCardinality(abstractElement)) {\n\t\t\t\t\t\t\t\tEObject container = abstractElement.eContainer();\n\t\t\t\t\t\t\t\tif (container instanceof Group) {\n\t\t\t\t\t\t\t\t\tGroup group = (Group) container;\n\t\t\t\t\t\t\t\t\tint idx = group.getElements().indexOf(abstractElement);\n\t\t\t\t\t\t\t\t\tif (idx == group.getElements().size() - 1) {\n\t\t\t\t\t\t\t\t\t\tif (!currentState.contains(group) && GrammarUtil.isMultipleCardinality(group)) {\n\t\t\t\t\t\t\t\t\t\t\tcalculator.doSwitch(group);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (idx < group.getElements().size() - 1 && \"?\".equals(abstractElement.getCardinality())) { // loops are fine\n\t\t\t\t\t\t\t\t\t\tAbstractElement nextElement = group.getElements().get(idx + 1);\n\t\t\t\t\t\t\t\t\t\tif (!currentState.contains(nextElement)) {\n\t\t\t\t\t\t\t\t\t\t\tcalculator.doSwitch(nextElement);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (isAlternativeWithEmptyPath(abstractElement)) {\n\t\t\t\t\t\t\t\tEObject container = abstractElement.eContainer();\n\t\t\t\t\t\t\t\tif (container instanceof Group) {\n\t\t\t\t\t\t\t\t\tGroup group = (Group) container;\n\t\t\t\t\t\t\t\t\tint idx = group.getElements().indexOf(abstractElement);\n\t\t\t\t\t\t\t\t\tif (!currentState.contains(group) && idx != group.getElements().size() - 1) {\n\t\t\t\t\t\t\t\t\t\tAbstractElement next = group.getElements().get(idx + 1);\n\t\t\t\t\t\t\t\t\t\tif (!currentState.contains(next)) {\n\t\t\t\t\t\t\t\t\t\t\tcalculator.doSwitch(next);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// special case: entry rule, first abstract element\n\t\t\t\t// we need a synthetic rule call\n\t\t\t\tif (element.getTrace().equals(element.getLocalTrace())) {\n\t\t\t\t\tParserRule parserRule = GrammarUtil.containingParserRule(element.getGrammarElement());\n\t\t\t\t\tif (parserRule != null) {\n\t\t\t\t\t\tRuleCall ruleCall = XtextFactory.eINSTANCE.createRuleCall();\n\t\t\t\t\t\truleCall.setRule(parserRule);\n\t\t\t\t\t\tcalculator.doSwitch(ruleCall);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCollection<FollowElement> followElements = parser.getFollowElements(element);\n\t\t\tfor(FollowElement newElement: followElements) {\n\t\t\t\tif (newElement.getLookAhead() != element.getLookAhead() || newElement.getGrammarElement() != element.getGrammarElement())\n\t\t\t\t\tcomputeFollowElements(calculator, newElement, visited);\n\t\t\t}\n\t\t}","id":32814,"modified_method":"protected void computeFollowElements(FollowElementCalculator calculator, FollowElement element, Multimap<Integer, List<AbstractElement>> visited) {\n\t\t\tList<AbstractElement> currentState = Lists.newArrayList(element.getLocalTrace());\n\t\t\tcurrentState.add(element.getGrammarElement());\n\t\t\tif (!visited.put(element.getLookAhead(), currentState))\n\t\t\t\treturn;\n\t\t\tif (element.getLookAhead() <= 1) {\n\t\t\t\tfor(AbstractElement abstractElement: currentState) {\n\t\t\t\t\tAssignment ass = EcoreUtil2.getContainerOfType(abstractElement, Assignment.class);\n\t\t\t\t\tif (ass != null)\n\t\t\t\t\t\tcalculator.doSwitch(ass);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (abstractElement instanceof UnorderedGroup && abstractElement == element.getGrammarElement()) {\n\t\t\t\t\t\t\tcalculator.doSwitch((UnorderedGroup) abstractElement, element.getHandledUnorderedGroupElements());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcalculator.doSwitch(abstractElement);\n\t\t\t\t\t\t\tif (GrammarUtil.isOptionalCardinality(abstractElement)) {\n\t\t\t\t\t\t\t\tEObject container = abstractElement.eContainer();\n\t\t\t\t\t\t\t\tif (container instanceof Group) {\n\t\t\t\t\t\t\t\t\tGroup group = (Group) container;\n\t\t\t\t\t\t\t\t\tint idx = group.getElements().indexOf(abstractElement);\n\t\t\t\t\t\t\t\t\tif (idx == group.getElements().size() - 1) {\n\t\t\t\t\t\t\t\t\t\tif (!currentState.contains(group) && GrammarUtil.isMultipleCardinality(group)) {\n\t\t\t\t\t\t\t\t\t\t\tcalculator.doSwitch(group);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (idx < group.getElements().size() - 1 && \"?\".equals(abstractElement.getCardinality())) { // loops are fine\n\t\t\t\t\t\t\t\t\t\tAbstractElement nextElement = group.getElements().get(idx + 1);\n\t\t\t\t\t\t\t\t\t\tif (!currentState.contains(nextElement)) {\n\t\t\t\t\t\t\t\t\t\t\tcalculator.doSwitch(nextElement);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (isAlternativeWithEmptyPath(abstractElement)) {\n\t\t\t\t\t\t\t\tEObject container = abstractElement.eContainer();\n\t\t\t\t\t\t\t\tif (container instanceof Group) {\n\t\t\t\t\t\t\t\t\tGroup group = (Group) container;\n\t\t\t\t\t\t\t\t\tint idx = group.getElements().indexOf(abstractElement);\n\t\t\t\t\t\t\t\t\tif (!currentState.contains(group) && idx != group.getElements().size() - 1) {\n\t\t\t\t\t\t\t\t\t\tAbstractElement next = group.getElements().get(idx + 1);\n\t\t\t\t\t\t\t\t\t\tif (!currentState.contains(next)) {\n\t\t\t\t\t\t\t\t\t\t\tcalculator.doSwitch(next);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// special case: entry rule, first abstract element\n\t\t\t\t// we need a synthetic rule call\n\t\t\t\tif (element.getTrace().equals(element.getLocalTrace())) {\n\t\t\t\t\tParserRule parserRule = GrammarUtil.containingParserRule(element.getGrammarElement());\n\t\t\t\t\tif (parserRule != null) {\n\t\t\t\t\t\tRuleCall ruleCall = XtextFactory.eINSTANCE.createRuleCall();\n\t\t\t\t\t\truleCall.setRule(parserRule);\n\t\t\t\t\t\tcalculator.doSwitch(ruleCall);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCollection<FollowElement> followElements = parser.getFollowElements(element);\n\t\t\tfor(FollowElement newElement: followElements) {\n\t\t\t\tif (newElement.getLookAhead() != element.getLookAhead() || newElement.getGrammarElement() != element.getGrammarElement()) {\n\t\t\t\t\tif (newElement.getLookAhead() == element.getLookAhead()) {\n\t\t\t\t\t\tint originalTraceSize = element.getLocalTrace().size();\n\t\t\t\t\t\tList<AbstractElement> newTrace = newElement.getLocalTrace();\n\t\t\t\t\t\tif (newTrace.size() > originalTraceSize) {\n\t\t\t\t\t\t\tif (Collections.indexOfSubList(element.getLocalTrace(), newTrace.subList(originalTraceSize, newTrace.size())) == -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcomputeFollowElements(calculator, newElement, visited);\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"3d90fd9831b0b8905259ed11865a0136cefc6be3","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * Performs the publish report, will be called by the JSP page.<p>\n     * \n     * @throws JspException if problems including sub-elements occur\n     */\n    public void actionReport() throws JspException {        \n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        switch (getAction()) {\n            case ACTION_REPORT_END:\n                actionCloseDialog();\n                break;\n            case ACTION_REPORT_UPDATE:\n                setParamAction(REPORT_UPDATE);   \n                getJsp().include(C_FILE_REPORT_OUTPUT);  \n                break;\n            case ACTION_REPORT_BEGIN:\n            case ACTION_CONFIRMED:\n            default:\n                try {\n                    CmsResource publishResource = null;\n                    \n                    if (\"true\".equalsIgnoreCase(getParamDirectpublish())) {\n                        // get the offline resource in direct publish mode\n                        publishResource = getCms().readFileHeader(getParamResource());\n                        // check if the resource is locked in direct publish mode                     \n                        org.opencms.lock.CmsLock lock = getCms().getLock(publishResource);\n                        if (!lock.isNullLock()) {\n                            // resource is locked, so unlock it\n                            getCms().unlockResource(getParamResource(), false);\n                        }  \n                    }\n                    \n                    if (showUnlockConfirmation()) {   \n                        // some resources are locked, unlock them before publishing                                 \n                        if (\"true\".equals(getParamDirectpublish())) {\n                            // unlock subresources of a folder\n                            String folderName = getParamResource();\n                            if (!folderName.endsWith(\"/\")) {\n                                folderName += \"/\";\n                            }\n                            getCms().lockResource(folderName);\n                            getCms().unlockResource(folderName, false);\n                        } else {\n                            // unlock all project resources\n                            getCms().unlockProject(Integer.parseInt(getParamProjectid()));                               \n                        }                         \n                    }\n                    \n                    // start the link validation thread before publishing\n                    CmsHtmlLinkValidatorThread thread = new CmsHtmlLinkValidatorThread(getCms(), publishResource, \"true\".equals(getParamPublishsiblings()), getSettings());\n                    setParamAction(REPORT_BEGIN);\n                    setParamThread(thread.getId().toString());\n                    \n                    // set the flag that another thread is following\n                    setParamThreadHasNext(\"true\");\n                    // set the key name for the continue checkbox\n                    setParamReportContinueKey(\"label.button.continue.brokenlinks\");\n                    getJsp().include(C_FILE_REPORT_OUTPUT); \n                    \n                } catch (CmsException e) {\n                    // error while unlocking resources, show error screen\n                    setParamErrorstack(e.getStackTraceAsString());\n                    setParamMessage(key(\"error.message.projectlockchange\"));\n                    setParamReasonSuggestion(key(\"error.reason.projectlockchange\") + \"<br>\\n\" + key(\"error.suggestion.projectlockchange\"));\n                    getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n                }                         \n        }\n    }","id":32815,"modified_method":"/**\n     * Performs the publish report, will be called by the JSP page.<p>\n     * \n     * @throws JspException if problems including sub-elements occur\n     */\n    public void actionReport() throws JspException {        \n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        switch (getAction()) {\n            case ACTION_REPORT_END:\n                actionCloseDialog();\n                break;\n            case ACTION_REPORT_UPDATE:\n                setParamAction(REPORT_UPDATE);   \n                getJsp().include(C_FILE_REPORT_OUTPUT);  \n                break;\n            case ACTION_REPORT_BEGIN:\n            case ACTION_CONFIRMED:\n            default:\n                try {\n                    CmsResource publishResource = null;\n                    \n                    if (\"true\".equalsIgnoreCase(getParamDirectpublish())) {\n                        // get the offline resource in direct publish mode\n                        publishResource = getCms().readFileHeader(getParamResource(), true);\n                        // check if the resource is locked in direct publish mode                     \n                        org.opencms.lock.CmsLock lock = getCms().getLock(publishResource);\n                        if (!lock.isNullLock()) {\n                            // resource is locked, so unlock it\n                            getCms().unlockResource(getParamResource(), false);\n                        }  \n                    }\n                    \n                    if (showUnlockConfirmation()) {   \n                        // some resources are locked, unlock them before publishing                                 \n                        if (\"true\".equals(getParamDirectpublish())) {\n                            // unlock subresources of a folder\n                            String folderName = getParamResource();\n                            if (!folderName.endsWith(\"/\")) {\n                                folderName += \"/\";\n                            }\n                            getCms().lockResource(folderName);\n                            getCms().unlockResource(folderName, false);\n                        } else {\n                            // unlock all project resources\n                            getCms().unlockProject(Integer.parseInt(getParamProjectid()));                               \n                        }                         \n                    }\n                    \n                    // start the link validation thread before publishing\n                    CmsHtmlLinkValidatorThread thread = new CmsHtmlLinkValidatorThread(getCms(), publishResource, \"true\".equals(getParamPublishsiblings()), getSettings());\n                    setParamAction(REPORT_BEGIN);\n                    setParamThread(thread.getId().toString());\n                    \n                    // set the flag that another thread is following\n                    setParamThreadHasNext(\"true\");\n                    // set the key name for the continue checkbox\n                    setParamReportContinueKey(\"label.button.continue.brokenlinks\");\n                    getJsp().include(C_FILE_REPORT_OUTPUT); \n                    \n                } catch (CmsException e) {\n                    // error while unlocking resources, show error screen\n                    setParamErrorstack(e.getStackTraceAsString());\n                    setParamMessage(key(\"error.message.projectlockchange\"));\n                    setParamReasonSuggestion(key(\"error.reason.projectlockchange\") + \"<br>\\n\" + key(\"error.suggestion.projectlockchange\"));\n                    getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n                }                         \n        }\n    }","commit_id":"d8dca9177fd2d66a1ace0891c3e4ae7b4935dcc7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Builds the HTML for the \"publish siblings\" checkbox when direct publishing a file.<p>\n     * \n     * @return the HTMl for the \"publish siblings\" checkbox  \n     */\n    public String buildCheckSiblings() {\n        CmsResource res = null;\n        try {\n            res = getCms().readFileHeader(getParamResource());\n        } catch (CmsException e) {\n            // res will be null\n        }\n        if ((res != null && res.isFile() && res.getLinkCount() > 1) || (res.isFolder())) {\n            // resource is file and has siblings, so create checkbox\n            StringBuffer retValue = new StringBuffer(128);\n            retValue.append(\"<tr>\\n\\t<td>\");\n            retValue.append(\"<input type=\\\"checkbox\\\" name=\\\"publishsiblings\\\" value=\\\"true\\\"\");\n            // set the checkbox state to the default value defined in the opencms.properties\n            if (getSettings().getUserSettings().getDialogPublishSiblings()) {\n                retValue.append(\" checked=\\\"checked\\\"\");\n            }\n            retValue.append(\">&nbsp;\");\n            retValue.append(key(\"messagebox.message5.publishresource\"));\n            retValue.append(\"<\/td>\\n<\/tr>\\n\");\n            return retValue.toString();\n        }\n        return \"\";\n    }","id":32816,"modified_method":"/**\n     * Builds the HTML for the \"publish siblings\" checkbox when direct publishing a file.<p>\n     * \n     * @return the HTMl for the \"publish siblings\" checkbox  \n     */\n    public String buildCheckSiblings() {\n        CmsResource res = null;\n        try {\n            res = getCms().readFileHeader(getParamResource(), true);\n        } catch (CmsException e) {\n            // res will be null\n        }\n        if ((res != null && res.isFile() && res.getLinkCount() > 1) || (res != null && res.isFolder())) {\n            // resource is file and has siblings, so create checkbox\n            StringBuffer retValue = new StringBuffer(128);\n            retValue.append(\"<tr>\\n\\t<td>\");\n            retValue.append(\"<input type=\\\"checkbox\\\" name=\\\"publishsiblings\\\" value=\\\"true\\\"\");\n            // set the checkbox state to the default value defined in the opencms.properties\n            if (getSettings().getUserSettings().getDialogPublishSiblings()) {\n                retValue.append(\" checked=\\\"checked\\\"\");\n            }\n            retValue.append(\">&nbsp;\");\n            retValue.append(key(\"messagebox.message5.publishresource\"));\n            retValue.append(\"<\/td>\\n<\/tr>\\n\");\n            return retValue.toString();\n        }\n        return \"\";\n    }","commit_id":"d8dca9177fd2d66a1ace0891c3e4ae7b4935dcc7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a resource info widget for a resource that looks like the sitemap entry for that resource.<p>\n     *\n     * @param resource the resource\n     * @param baseSite the base site\n     *\n     * @return the resource info widget\n     */\n    public static CmsResourceInfo createSitemapResourceInfo(CmsResource resource, CmsSite baseSite) {\n\n        String title = resource.getName();\n        String path = resource.getRootPath();\n\n        CmsResourceInfo info = new CmsResourceInfo();\n        CmsResourceUtil resUtil = new CmsResourceUtil(A_CmsUI.getCmsObject(), resource);\n\n        CmsObject cms = A_CmsUI.getCmsObject();\n        try {\n            Map<String, CmsProperty> props = CmsProperty.toObjectMap(cms.readPropertyObjects(resource, false));\n            CmsProperty navtextProp = props.get(CmsPropertyDefinition.PROPERTY_NAVTEXT);\n            CmsProperty titleProp = props.get(CmsPropertyDefinition.PROPERTY_TITLE);\n\n            if ((navtextProp != null) && (navtextProp.getValue() != null)) {\n                title = navtextProp.getValue();\n            } else if ((titleProp != null) && (titleProp.getValue() != null)) {\n                title = titleProp.getValue();\n            }\n        } catch (Exception e) {\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n        info.getTopLine().setValue(title);\n        if (baseSite != null) {\n            String siteRoot = baseSite.getSiteRoot();\n            if (path.startsWith(siteRoot)) {\n                path = path.substring(siteRoot.length());\n                path = CmsStringUtil.joinPaths(\"/\", path);\n            }\n        }\n        info.getBottomLine().setValue(path);\n        String icon = CmsSitemapTreeContainer.getSitemapResourceIcon(A_CmsUI.getCmsObject(), resUtil.getResource());\n        info.getResourceIcon().initContent(resUtil, icon, null);\n        return info;\n    }","id":32817,"modified_method":"/**\n     * Creates a resource info widget for a resource that looks like the sitemap entry for that resource.<p>\n     *\n     * @param resource the resource\n     * @param baseSite the base site\n     *\n     * @return the resource info widget\n     */\n    public static CmsResourceInfo createSitemapResourceInfo(CmsResource resource, CmsSite baseSite) {\n\n        String title = resource.getName();\n        String path = resource.getRootPath();\n\n        CmsResourceInfo info = new CmsResourceInfo();\n        CmsResourceUtil resUtil = new CmsResourceUtil(A_CmsUI.getCmsObject(), resource);\n\n        CmsObject cms = A_CmsUI.getCmsObject();\n        try {\n            Map<String, CmsProperty> props = CmsProperty.toObjectMap(cms.readPropertyObjects(resource, false));\n            CmsProperty navtextProp = props.get(CmsPropertyDefinition.PROPERTY_NAVTEXT);\n            CmsProperty titleProp = props.get(CmsPropertyDefinition.PROPERTY_TITLE);\n\n            if ((navtextProp != null) && (navtextProp.getValue() != null)) {\n                title = navtextProp.getValue();\n            } else if ((titleProp != null) && (titleProp.getValue() != null)) {\n                title = titleProp.getValue();\n            }\n        } catch (Exception e) {\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n        info.getTopLine().setValue(title);\n        if (baseSite != null) {\n            String siteRoot = baseSite.getSiteRoot();\n            if (path.startsWith(siteRoot)) {\n                path = path.substring(siteRoot.length());\n                path = CmsStringUtil.joinPaths(\"/\", path);\n            }\n        }\n        info.getBottomLine().setValue(path);\n        String icon = CmsSitemapTreeContainer.getSitemapResourceIcon(\n            A_CmsUI.getCmsObject(),\n            resUtil.getResource(),\n            IconMode.localeCompare);\n        info.getResourceIcon().initContent(resUtil, icon, null);\n        return info;\n    }","commit_id":"327fd5326b9bff8d364768898ebb63bbf36c8109","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.components.fileselect.CmsResourceTreeContainer#getIcon(org.opencms.file.CmsObject, org.opencms.file.CmsResource)\n     */\n    @Override\n    public String getIcon(CmsObject cms, CmsResource resource) {\n\n        return getSitemapResourceIcon(cms, resource);\n    }","id":32818,"modified_method":"/**\n     * @see org.opencms.ui.components.fileselect.CmsResourceTreeContainer#getIcon(org.opencms.file.CmsObject, org.opencms.file.CmsResource)\n     */\n    @Override\n    public String getIcon(CmsObject cms, CmsResource resource) {\n\n        return getSitemapResourceIcon(cms, resource, IconMode.sitemapSelect);\n    }","commit_id":"327fd5326b9bff8d364768898ebb63bbf36c8109","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the resource icon for a resource for use in a CmsResourceInfo widget when used in a sitemap context.<p>\n     *\n     * @param cms the CMS context\n     * @param resource a resource\n     * @return the path for the resource icon\n     */\n    public static String getSitemapResourceIcon(CmsObject cms, CmsResource resource) {\n\n        CmsResource defaultFile = null;\n        List<CmsResource> resourcesForType = Lists.newArrayList();\n        resourcesForType.add(resource);\n        if (resource.isFolder()) {\n            try {\n                defaultFile = cms.readDefaultFile(resource, CmsResourceFilter.IGNORE_EXPIRATION);\n                if (defaultFile != null) {\n                    resourcesForType.add(0, defaultFile);\n                }\n            } catch (Exception e) {\n                // Shouldn't normally happen - readDefaultFile returns null instead of throwing an exception when it doesn't find a default file\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        if (CmsJspNavBuilder.isNavLevelFolder(cms, resource)) {\n            return CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES + CmsIconUtil.ICON_NAV_LEVEL_BIG);\n        }\n        CmsResource maybePage = resourcesForType.get(0);\n        if (CmsResourceTypeXmlContainerPage.isContainerPage(maybePage)) {\n            CmsADEConfigData config = OpenCms.getADEManager().lookupConfiguration(cms, maybePage.getRootPath());\n            for (DetailInfo info : config.getDetailInfos(cms)) {\n                CmsDetailPageInfo realInfo = info.getDetailPageInfo();\n                if (realInfo.getUri().equals(maybePage.getRootPath())\n                    || realInfo.getUri().equals(CmsResource.getParentFolder(maybePage.getRootPath()))) {\n                    CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(\n                        realInfo.getIconType());\n                    if (settings != null) {\n                        return CmsWorkplace.getResourceUri(\n                            CmsWorkplace.RES_PATH_FILETYPES + settings.getBigIconIfAvailable());\n                    }\n                }\n            }\n        }\n\n        String result = null;\n        for (CmsResource res : resourcesForType) {\n            I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(res);\n            CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(type.getTypeName());\n            if (settings != null) {\n                result = CmsWorkplace.RES_PATH_FILETYPES + settings.getBigIconIfAvailable();\n                break;\n            }\n        }\n        return CmsWorkplace.getResourceUri(result);\n    }","id":32819,"modified_method":"/**\n     * Gets the resource icon for a resource for use in a CmsResourceInfo widget when used in a sitemap context.<p>\n     *\n     * @param cms the CMS context\n     * @param resource a resource\n     * @param iconMode the icon mode\n     * @return the path for the resource icon\n     */\n    public static String getSitemapResourceIcon(CmsObject cms, CmsResource resource, IconMode iconMode) {\n\n        CmsResource defaultFile = null;\n        List<CmsResource> resourcesForType = Lists.newArrayList();\n        resourcesForType.add(resource);\n        boolean skipDefaultFile = (iconMode == IconMode.sitemapSelect)\n            && OpenCms.getResourceManager().matchResourceType(\n                CmsResourceTypeFolderSubSitemap.TYPE_SUBSITEMAP,\n                resource.getTypeId());\n        if (resource.isFolder() && !skipDefaultFile) {\n\n            try {\n                defaultFile = cms.readDefaultFile(resource, CmsResourceFilter.IGNORE_EXPIRATION);\n                if (defaultFile != null) {\n                    resourcesForType.add(0, defaultFile);\n                }\n            } catch (Exception e) {\n                // Shouldn't normally happen - readDefaultFile returns null instead of throwing an exception when it doesn't find a default file\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        if (CmsJspNavBuilder.isNavLevelFolder(cms, resource)) {\n            return CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES + CmsIconUtil.ICON_NAV_LEVEL_BIG);\n        }\n        CmsResource maybePage = resourcesForType.get(0);\n        if (CmsResourceTypeXmlContainerPage.isContainerPage(maybePage)) {\n            CmsADEConfigData config = OpenCms.getADEManager().lookupConfiguration(cms, maybePage.getRootPath());\n            for (CmsDetailPageInfo realInfo : config.getAllDetailPages(true)) {\n                if (realInfo.getUri().equals(maybePage.getRootPath())\n                    || realInfo.getUri().equals(CmsResource.getParentFolder(maybePage.getRootPath()))) {\n                    CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(\n                        realInfo.getIconType());\n                    if (settings != null) {\n                        return CmsWorkplace.getResourceUri(\n                            CmsWorkplace.RES_PATH_FILETYPES + settings.getBigIconIfAvailable());\n                    }\n                }\n            }\n        }\n\n        String result = null;\n        for (CmsResource res : resourcesForType) {\n            I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(res);\n            CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(type.getTypeName());\n            if (settings != null) {\n                result = CmsWorkplace.RES_PATH_FILETYPES + settings.getBigIconIfAvailable();\n                break;\n            }\n        }\n        return CmsWorkplace.getResourceUri(result);\n    }","commit_id":"327fd5326b9bff8d364768898ebb63bbf36c8109","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a sitemap tree node widget from a tree node bean.<p>\n     *\n     * @param entry the tree node bean\n     * @return the tree node widget\n     */\n    public CmsSitemapTreeNode createNode(final CmsSitemapTreeNodeData entry) {\n\n        final CmsSitemapTreeNode node = new CmsSitemapTreeNode();\n        node.addLayoutClickListener(new LayoutClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void layoutClick(LayoutClickEvent event) {\n\n                Component currentComponent = event.getClickedComponent();\n                if (currentComponent != null) {\n                    boolean linked = false;\n                    do {\n                        currentComponent = currentComponent.getParent();\n                        if ((currentComponent != null)\n                            && \"linked\".equals(((AbstractComponent)currentComponent).getData())) {\n                            linked = true;\n                        }\n                        if (event.getClickedComponent() instanceof CmsResourceIcon) {\n                            if (currentComponent == node) {\n                                openTargetPage((CmsSitemapTreeNodeData)(node.getData()), linked);\n                            } else if (currentComponent instanceof CmsSitemapTreeNode) {\n                                break;\n                            }\n                        }\n                    } while (currentComponent != null);\n                }\n\n            }\n\n        });\n        String icon = CmsSitemapTreeContainer.getSitemapResourceIcon(A_CmsUI.getCmsObject(), entry.getResource());\n        CmsResourceInfo info = new CmsResourceInfo(\n            entry.getClientEntry().getTitle(),\n            entry.getClientEntry().getSitePath(),\n            icon);\n        info = CmsResourceInfo.createSitemapResourceInfo(\n            entry.getResource(),\n            OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath()));\n        info.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n        info.getResourceIcon().setDescription(CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_OPEN_PAGE_0));\n\n        if (entry.getClientEntry().isHiddenNavigationEntry()) {\n            info.addStyleName(OpenCmsTheme.RESOURCE_INFO_WEAK);\n        }\n        final MenuBar menu = new MenuBar();\n        boolean noTranslation = false;\n        noTranslation = entry.isMarkedNoTranslation(m_localeContext.getComparisonLocale());\n\n        final MenuItem main = menu.addItem(\"\", null);\n        main.setIcon(FontOpenCms.CONTEXT_MENU);\n        CssLayout rightSide = new CssLayout();\n        info.setButtonWidget(rightSide);\n        rightSide.addComponent(menu);\n        main.setCommand(new Command() {\n\n            /** Serial version id. */\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void menuSelected(MenuItem selectedItem) {\n\n                m_menu.removeAllItems();\n                if (!entry.isLinked()) {\n                    addLinkItem(entry, node);\n                }\n                if (m_localeContext.getRootLocale().equals(A_CmsUI.getCmsObject().getLocaleGroupService().getMainLocale(\n                    m_localeContext.getRoot().getRootPath()))) {\n                    try {\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        final CmsResource primaryFinal = primary;\n                        addMarkItems(entry, node, primaryFinal);\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n\n                }\n\n                if (entry.isCopyable()) {\n                    ContextMenuItem copyItem = m_menu.addItem(\n                        CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_COPY_PAGE_0));\n                    copyItem.addItemClickListener(new ContextMenuItemClickListener() {\n\n                        public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                            openPageCopyDialog(entry);\n                        }\n                    });\n                }\n\n                if (entry.isLinked()) {\n                    try {\n\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        CmsLocaleGroupService groupService = A_CmsUI.getCmsObject().getLocaleGroupService();\n                        Locale mainLocale = groupService.getMainLocale(m_localeContext.getRoot().getRootPath());\n                        int mainLocaleCount = 0;\n                        for (Locale testLocale : Arrays.asList(\n                            m_localeContext.getRootLocale(),\n                            m_localeContext.getComparisonLocale())) {\n                            mainLocaleCount += mainLocale.equals(testLocale) ? 1 : 0;\n                        }\n                        if (mainLocaleCount == 1) {\n                            addUnlinkItem(entry, node);\n                        }\n                        CmsLocaleGroup localeGroup = groupService.readLocaleGroup(primary);\n                        if (localeGroup.isRealGroup()) {\n                            ContextMenuItem show = m_menu.addItem(\n                                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_SHOW_LOCALE_0));\n                            Map<Locale, CmsResource> resourcesByLocale = localeGroup.getResourcesByLocale();\n                            String mySiteRoot = A_CmsUI.getCmsObject().getRequestContext().getSiteRoot();\n                            int realSubitemCount = 0;\n                            for (Map.Entry<Locale, CmsResource> localeGroupEntry : resourcesByLocale.entrySet()) {\n                                final Locale locale = localeGroupEntry.getKey();\n                                final CmsResource resource = localeGroupEntry.getValue();\n                                final boolean sameSite = mySiteRoot.equals(\n                                    OpenCms.getSiteManager().getSiteRoot(resource.getRootPath()));\n\n                                String localeName = locale.getDisplayLanguage(A_CmsUI.get().getLocale());\n                                ContextMenuItem showLanguage = show.addItem(localeName);\n                                if (!sameSite) {\n                                    showLanguage.addStyleName(\"o-show-locale-disabled\");\n                                }\n                                showLanguage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                                    public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                                        if (sameSite) {\n                                            CmsObject cms = A_CmsUI.getCmsObject();\n                                            String link = OpenCms.getLinkManager().substituteLink(cms, resource);\n                                            A_CmsUI.get().getPage().setLocation(link);\n                                        } else {\n                                            String message = CmsVaadinUtils.getMessageText(\n                                                Messages.GUI_LOCALECOMPARE_SHOW_WRONGSITE_1,\n                                                resource.getRootPath());\n\n                                            Notification.show(message, Type.ERROR_MESSAGE);\n                                        }\n                                    }\n                                });\n                                realSubitemCount += 1;\n\n                            }\n                            if (realSubitemCount == 0) {\n                                m_menu.removeItem(show);\n                            }\n                        }\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n                }\n\n                m_menu.open(menu);\n            }\n\n        });\n\n        menu.addStyleName(\"borderless o-toolbar-button o-resourceinfo-toolbar\");\n        if (entry.isLinked()) {\n            CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath());\n            CmsResourceInfo linkedInfo = CmsResourceInfo.createSitemapResourceInfo(\n                readSitemapEntryFolderIfPossible(entry.getLinkedResource()),\n                site);\n            if (entry.isDirectLink()) {\n                linkedInfo.addStyleName(OpenCmsTheme.RESOURCE_INFO_DIRECTLINK);\n            }\n            rightSide.addComponent(linkedInfo, 0);\n            linkedInfo.setWidth(RHS_WIDTH + \"px\");\n            node.setContent(info);\n            linkedInfo.setData(\"linked\"); // Data used by click handler to distinguish clicked resource icons\n            linkedInfo.getResourceIcon().setDescription(\n                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_OPEN_PAGE_0));\n            linkedInfo.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n        } else {\n            if (noTranslation) {\n                Label noTranslationLabel = createNoTranslationLabel();\n                rightSide.addComponent(noTranslationLabel, 0);\n            }\n            node.setContent(info);\n        }\n\n        if (entry.hasNoChildren()) {\n            node.setOpen(true);\n            node.setOpenerVisible(false);\n        }\n        node.setData(entry);\n        return node;\n\n    }","id":32820,"modified_method":"/**\n     * Creates a sitemap tree node widget from a tree node bean.<p>\n     *\n     * @param entry the tree node bean\n     * @return the tree node widget\n     */\n    public CmsSitemapTreeNode createNode(final CmsSitemapTreeNodeData entry) {\n\n        final CmsSitemapTreeNode node = new CmsSitemapTreeNode();\n        node.addLayoutClickListener(new LayoutClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void layoutClick(LayoutClickEvent event) {\n\n                Component currentComponent = event.getClickedComponent();\n                if (currentComponent != null) {\n                    boolean linked = false;\n                    do {\n                        currentComponent = currentComponent.getParent();\n                        if ((currentComponent != null)\n                            && \"linked\".equals(((AbstractComponent)currentComponent).getData())) {\n                            linked = true;\n                        }\n                        if (event.getClickedComponent() instanceof CmsResourceIcon) {\n                            if (currentComponent == node) {\n                                openTargetPage((CmsSitemapTreeNodeData)(node.getData()), linked);\n                            } else if (currentComponent instanceof CmsSitemapTreeNode) {\n                                break;\n                            }\n                        }\n                    } while (currentComponent != null);\n                }\n\n            }\n\n        });\n        String icon = CmsSitemapTreeContainer.getSitemapResourceIcon(\n            A_CmsUI.getCmsObject(),\n            entry.getResource(),\n            IconMode.localeCompare);\n        CmsResourceInfo info = new CmsResourceInfo(\n            entry.getClientEntry().getTitle(),\n            entry.getClientEntry().getSitePath(),\n            icon);\n        info = CmsResourceInfo.createSitemapResourceInfo(\n            entry.getResource(),\n            OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath()));\n        info.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n        info.getResourceIcon().setDescription(CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_OPEN_PAGE_0));\n\n        if (entry.getClientEntry().isHiddenNavigationEntry()) {\n            info.addStyleName(OpenCmsTheme.RESOURCE_INFO_WEAK);\n        }\n        final MenuBar menu = new MenuBar();\n        boolean noTranslation = false;\n        noTranslation = entry.isMarkedNoTranslation(m_localeContext.getComparisonLocale());\n\n        final MenuItem main = menu.addItem(\"\", null);\n        main.setIcon(FontOpenCms.CONTEXT_MENU);\n        CssLayout rightSide = new CssLayout();\n        info.setButtonWidget(rightSide);\n        rightSide.addComponent(menu);\n        main.setCommand(new Command() {\n\n            /** Serial version id. */\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void menuSelected(MenuItem selectedItem) {\n\n                m_menu.removeAllItems();\n                if (!entry.isLinked()) {\n                    addLinkItem(entry, node);\n                }\n                if (m_localeContext.getRootLocale().equals(A_CmsUI.getCmsObject().getLocaleGroupService().getMainLocale(\n                    m_localeContext.getRoot().getRootPath()))) {\n                    try {\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        final CmsResource primaryFinal = primary;\n                        addMarkItems(entry, node, primaryFinal);\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n\n                }\n\n                if (entry.isCopyable()) {\n                    ContextMenuItem copyItem = m_menu.addItem(\n                        CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_COPY_PAGE_0));\n                    copyItem.addItemClickListener(new ContextMenuItemClickListener() {\n\n                        public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                            openPageCopyDialog(entry);\n                        }\n                    });\n                }\n\n                if (entry.isLinked()) {\n                    try {\n\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        CmsLocaleGroupService groupService = A_CmsUI.getCmsObject().getLocaleGroupService();\n                        Locale mainLocale = groupService.getMainLocale(m_localeContext.getRoot().getRootPath());\n                        int mainLocaleCount = 0;\n                        for (Locale testLocale : Arrays.asList(\n                            m_localeContext.getRootLocale(),\n                            m_localeContext.getComparisonLocale())) {\n                            mainLocaleCount += mainLocale.equals(testLocale) ? 1 : 0;\n                        }\n                        if (mainLocaleCount == 1) {\n                            addUnlinkItem(entry, node);\n                        }\n                        CmsLocaleGroup localeGroup = groupService.readLocaleGroup(primary);\n                        if (localeGroup.isRealGroup()) {\n                            ContextMenuItem show = m_menu.addItem(\n                                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_SHOW_LOCALE_0));\n                            Map<Locale, CmsResource> resourcesByLocale = localeGroup.getResourcesByLocale();\n                            String mySiteRoot = A_CmsUI.getCmsObject().getRequestContext().getSiteRoot();\n                            int realSubitemCount = 0;\n                            for (Map.Entry<Locale, CmsResource> localeGroupEntry : resourcesByLocale.entrySet()) {\n                                final Locale locale = localeGroupEntry.getKey();\n                                final CmsResource resource = localeGroupEntry.getValue();\n                                final boolean sameSite = mySiteRoot.equals(\n                                    OpenCms.getSiteManager().getSiteRoot(resource.getRootPath()));\n\n                                String localeName = locale.getDisplayLanguage(A_CmsUI.get().getLocale());\n                                ContextMenuItem showLanguage = show.addItem(localeName);\n                                if (!sameSite) {\n                                    showLanguage.addStyleName(\"o-show-locale-disabled\");\n                                }\n                                showLanguage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                                    public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                                        if (sameSite) {\n                                            CmsObject cms = A_CmsUI.getCmsObject();\n                                            String link = OpenCms.getLinkManager().substituteLink(cms, resource);\n                                            A_CmsUI.get().getPage().setLocation(link);\n                                        } else {\n                                            String message = CmsVaadinUtils.getMessageText(\n                                                Messages.GUI_LOCALECOMPARE_SHOW_WRONGSITE_1,\n                                                resource.getRootPath());\n\n                                            Notification.show(message, Type.ERROR_MESSAGE);\n                                        }\n                                    }\n                                });\n                                realSubitemCount += 1;\n\n                            }\n                            if (realSubitemCount == 0) {\n                                m_menu.removeItem(show);\n                            }\n                        }\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n                }\n\n                m_menu.open(menu);\n            }\n\n        });\n\n        menu.addStyleName(\"borderless o-toolbar-button o-resourceinfo-toolbar\");\n        if (entry.isLinked()) {\n            CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath());\n            CmsResourceInfo linkedInfo = CmsResourceInfo.createSitemapResourceInfo(\n                readSitemapEntryFolderIfPossible(entry.getLinkedResource()),\n                site);\n            if (entry.isDirectLink()) {\n                linkedInfo.addStyleName(OpenCmsTheme.RESOURCE_INFO_DIRECTLINK);\n            }\n            rightSide.addComponent(linkedInfo, 0);\n            linkedInfo.setWidth(RHS_WIDTH + \"px\");\n            node.setContent(info);\n            linkedInfo.setData(\"linked\"); // Data used by click handler to distinguish clicked resource icons\n            linkedInfo.getResourceIcon().setDescription(\n                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_OPEN_PAGE_0));\n            linkedInfo.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n        } else {\n            if (noTranslation) {\n                Label noTranslationLabel = createNoTranslationLabel();\n                rightSide.addComponent(noTranslationLabel, 0);\n            }\n            node.setContent(info);\n        }\n\n        if (entry.hasNoChildren()) {\n            node.setOpen(true);\n            node.setOpenerVisible(false);\n        }\n        node.setData(entry);\n        return node;\n\n    }","commit_id":"327fd5326b9bff8d364768898ebb63bbf36c8109","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the editing of the resources properties.<p>\n     * \n     * @param request the HttpServletRequest\n     * @return true, if the properties were successfully changed, otherwise false\n     * @throws CmsException if editing is not successful\n     */\n    protected boolean performEditOperation(HttpServletRequest request) throws CmsException {\n        boolean useTempfileProject = Boolean.valueOf(getParamUsetempfileproject()).booleanValue();\n        try {\n            if (useTempfileProject) {\n                switchToTempProject();\n            }\n            // loop over the default properties\n            for (int i=0; i<C_DEFAULT_PROPERTIES.length; i++) {\n                String curProperty = C_DEFAULT_PROPERTIES[i];\n                String paramValue = CmsEncoder.decode(request.getParameter(PREFIX_VALUE + curProperty));\n                String oldValue = request.getParameter(PREFIX_HIDDEN + curProperty);\n                writeProperty(curProperty, paramValue, oldValue);\n            }\n            \n            // loop over the ebk properties\n            for (int i=0; i<C_EBK_PROPERTIES.length; i++) {\n                String curProperty = C_EBK_PROPERTIES[i];\n                String paramValue = CmsEncoder.decode(request.getParameter(PREFIX_VALUE + curProperty));\n                String oldValue = request.getParameter(PREFIX_HIDDEN + curProperty);                \n                writeProperty(curProperty, paramValue, oldValue);\n            }\n            \n            // write the navigation properties if enabled\n            if (showNavigation()) {\n                // get the navigation enabled parameter\n                String paramValue = request.getParameter(\"enablenav\");\n                String oldValue = null;\n                if (Boolean.valueOf(paramValue).booleanValue()) {\n                    // navigation enabled, update params\n                    paramValue = request.getParameter(\"navpos\");\n                    if (!\"-1\".equals(paramValue)) {\n                        // update the property only when it is different from \"-1\" (meaning no change)\n                        oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVPOS);\n                        writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, paramValue, oldValue);\n                    }\n                    paramValue = request.getParameter(PREFIX_VALUE + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                    oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                    writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, paramValue, oldValue);\n                } else {\n                    // navigation disabled, delete property values\n                    writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, null, null);\n                    writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, null, null);\n                }                  \n            }\n        } finally {\n            if (useTempfileProject) {\n                switchToCurrentProject();\n            }\n        }\n        return true;\n    }","id":32821,"modified_method":"/**\n     * Performs the editing of the resources properties.<p>\n     * \n     * @param request the HttpServletRequest\n     * @return true, if the properties were successfully changed, otherwise false\n     * @throws CmsException if editing is not successful\n     */\n    protected boolean performEditOperation(HttpServletRequest request) throws CmsException {\n        \n        boolean useTempfileProject = Boolean.valueOf(getParamUsetempfileproject()).booleanValue();\n        try {\n            if (useTempfileProject) {\n                switchToTempProject();\n            }\n            // loop over the default properties\n            for (int i=0; i<C_DEFAULT_PROPERTIES.length; i++) {\n                String curProperty = C_DEFAULT_PROPERTIES[i];\n                String paramValue = CmsEncoder.decode(request.getParameter(PREFIX_VALUE + curProperty));\n                String oldValue = request.getParameter(PREFIX_HIDDEN + curProperty);\n                writeProperty(curProperty, paramValue, oldValue);\n            }\n            \n            // loop over all properties\n            for (int i=0; i<C_ALL_PROPERTIES.length; i++) {\n                String curProperty = C_ALL_PROPERTIES[i];\n                String paramValue = CmsEncoder.decode(request.getParameter(PREFIX_VALUE + curProperty));\n                String oldValue = request.getParameter(PREFIX_HIDDEN + curProperty);                \n                writeProperty(curProperty, paramValue, oldValue);\n            }\n            \n            // write the navigation properties if enabled\n            if (showNavigation()) {\n                // get the navigation enabled parameter\n                String paramValue = request.getParameter(\"enablenav\");\n                String oldValue = null;\n                if (Boolean.valueOf(paramValue).booleanValue()) {\n                    // navigation enabled, update params\n                    paramValue = request.getParameter(\"navpos\");\n                    if (!\"-1\".equals(paramValue)) {\n                        // update the property only when it is different from \"-1\" (meaning no change)\n                        oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVPOS);\n                        writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, paramValue, oldValue);\n                    }\n                    paramValue = request.getParameter(PREFIX_VALUE + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                    oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                    writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, paramValue, oldValue);\n                } else {\n                    // navigation disabled, delete property values\n                    writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, null, null);\n                    writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, null, null);\n                }                  \n            }\n        } finally {\n            if (useTempfileProject) {\n                switchToCurrentProject();\n            }\n        }\n        return true;\n    }","commit_id":"fe7a7853a2990ea8bcd0a22e1f82dccdacc86150","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private boolean isFolder() {\n        \n        try {\n            CmsResource res = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n            if (res.isFolder()) {\n                return true;\n            }\n        } catch (CmsException e) {\n            // ignore\n        }\n        \n        return false;\n    }","id":32822,"modified_method":"/**\n     * Checks if the currently edited resource is a folder.<p>\n     * \n     * @return true if the resource is a folder, otherwise false\n     */\n    private boolean isFolder() {\n        \n        try {\n            CmsResource res = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n            if (res.isFolder()) {\n                return true;\n            }\n        } catch (CmsException e) {\n            // ignore this exception\n        }       \n        return false;\n    }","commit_id":"fe7a7853a2990ea8bcd0a22e1f82dccdacc86150","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.I_CmsDialogHandler#getDialogUri(java.lang.String, CmsJspActionElement)\n     */\n    public String getDialogUri(String resource, CmsJspActionElement jsp) {\n        try {\n            CmsResource res = jsp.getCmsObject().readResource(resource, CmsResourceFilter.ALL);\n            if (res.getTypeId() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID) {\n                if (C_TEMPLATE_ONE.equals(jsp.property(\"template\", resource))) {\n                    // display special property dialog for xmlpage types with \"template one\" as template\n                    return C_MODULE_PATH + \"dialogs/property.jsp\";\n                }\n                \n                return C_PATH_WORKPLACE + \"editors/dialogs/property.jsp\";\n            }\n            if (res.isFolder()) {\n                if (!res.getRootPath().startsWith(I_CmsConstants.VFS_FOLDER_SYSTEM)) {\n                    // display special property dialog for folders. excluse system folders\n                    return C_MODULE_PATH + \"dialogs/property.jsp\";\n                }\n                \n                return C_PATH_WORKPLACE + \"editors/dialogs/property.jsp\";\n            }\n            String resTypeName = OpenCms.getResourceManager().getResourceType(res.getTypeId()).getTypeName();\n            CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(resTypeName);\n            if (settings.isPropertiesEnabled()) {\n                // special properties for this type enabled, display customized dialog\n                return URI_PROPERTY_CUSTOM_DIALOG;\n            }\n        } catch (CmsException e) {\n            // should usually never happen\n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(e);\n            }\n        }\n        return URI_PROPERTY_DIALOG;\n    }","id":32823,"modified_method":"/**\n     * @see org.opencms.workplace.I_CmsDialogHandler#getDialogUri(java.lang.String, CmsJspActionElement)\n     */\n    public String getDialogUri(String resource, CmsJspActionElement jsp) {\n        \n        try {\n            CmsResource res = jsp.getCmsObject().readResource(resource, CmsResourceFilter.ALL);\n            if (! res.isFolder() && res.getTypeId() != CmsResourceTypeBinary.C_RESOURCE_TYPE_ID \n                    && res.getTypeId() != CmsResourceTypePlain.C_RESOURCE_TYPE_ID && res.getTypeId() != CmsResourceTypeImage.C_RESOURCE_TYPE_ID) {\n                // file is no plain text, binary or image type, check \"template\" property\n                if (C_TEMPLATE_ONE.equals(jsp.getCmsObject().readPropertyObject(jsp.getCmsObject().getSitePath(res), I_CmsConstants.C_PROPERTY_TEMPLATE, true).getValue(\"\"))) {\n                    // display special property dialog for files with \"template one\" as template\n                    return C_MODULE_PATH + \"dialogs/property.jsp\";\n                } else if (res.getTypeId() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID) {\n                    // show xmlpage property dialog for xmlpages not using \"template one\" as template\n                    return C_PATH_WORKPLACE + \"editors/dialogs/property.jsp\";\n                }\n            }\n            if (res.isFolder() && ! res.getRootPath().startsWith(I_CmsConstants.VFS_FOLDER_SYSTEM)) {\n                // display special property dialog also for folders but exclude the system folders\n                return C_MODULE_PATH + \"dialogs/property.jsp\";\n            }\n            String resTypeName = OpenCms.getResourceManager().getResourceType(res.getTypeId()).getTypeName();\n            CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(resTypeName);\n            if (settings.isPropertiesEnabled()) {\n                // special properties for this type enabled, display customized dialog\n                return URI_PROPERTY_CUSTOM_DIALOG;\n            }\n        } catch (CmsException e) {\n            // should usually never happen\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(e);\n            }\n        }\n        return URI_PROPERTY_DIALOG;\n    }","commit_id":"fe7a7853a2990ea8bcd0a22e1f82dccdacc86150","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void testImportXMLFromFileWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32824,"modified_method":"public void testImportXMLFromFileWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test import operation for a posted json string without the optional name\n     */\n    public void testImportJSONFromRequestParamWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String jsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32825,"modified_method":"/**\n     * Test import operation for a posted json string without the optional name\n     */\n    public void testImportJSONFromRequestParamWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String jsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"protected String importNodeWithExactName(String testNodeName) throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        props.put(SlingPostConstants.RP_NODE_NAME, testNodeName);\n        String jsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String location = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(location + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n\n    \tassertHttpStatus(location + DEFAULT_EXT, HttpServletResponse.SC_OK,\n                \"POST must redirect to created resource (\" + location + \")\");\n        assertTrue(\"Node (\" + location + \") must have exact name\",\n                !location.endsWith(\"/*\"));\n        assertTrue(\"Node (\" + location + \") must created be under POST URL (\" + testNode + \")\",\n                location.contains(testNode + \"/\"));\n        assertTrue(\"Node (\" + location + \") must have exact name '\" + testNodeName + \"'\",\n        \t\tlocation.endsWith(\"/\" + testNodeName));\n\n\t\treturn location;\n    }","id":32826,"modified_method":"protected String importNodeWithExactName(String testNodeName) throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        props.put(SlingPostConstants.RP_NODE_NAME, testNodeName);\n        String jsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String location = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(location + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n\n    \tassertHttpStatus(location + DEFAULT_EXT, HttpServletResponse.SC_OK,\n                \"POST must redirect to created resource (\" + location + \")\");\n        assertTrue(\"Node (\" + location + \") must have exact name\",\n                !location.endsWith(\"/*\"));\n        assertTrue(\"Node (\" + location + \") must created be under POST URL (\" + testNode + \")\",\n                location.contains(testNode + \"/\"));\n        assertTrue(\"Node (\" + location + \") must have exact name '\" + testNodeName + \"'\",\n        \t\tlocation.endsWith(\"/\" + testNodeName));\n\n\t\treturn location;\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * SLING-1091: test error reporting when attempting to create a node with an \n     * invalid exact node name. \n     */\n    public void testImportNodeWithInvalidExactName() throws IOException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n\t\tList<NameValuePair> postParams = new ArrayList<NameValuePair>();\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_OPERATION, SlingPostConstants.OPERATION_IMPORT));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_NODE_NAME, \"exactNodeName*\"));\n        String jsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_CONTENT, jsonContent));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_CONTENT_TYPE, \"json\"));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\"));\n\n        //expect a 500 status since the name is invalid\n        String location = HTTP_BASE_URL + testPath;\n\t\tassertPostStatus(location, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, postParams, null);\n    }","id":32827,"modified_method":"/**\n     * SLING-1091: test error reporting when attempting to create a node with an\n     * invalid exact node name.\n     */\n    public void testImportNodeWithInvalidExactName() throws IOException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n\t\tList<NameValuePair> postParams = new ArrayList<NameValuePair>();\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_OPERATION, SlingPostConstants.OPERATION_IMPORT));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_NODE_NAME, \"exactNodeName*\"));\n        String jsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_CONTENT, jsonContent));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_CONTENT_TYPE, \"json\"));\n\t\tpostParams.add(new NameValuePair(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\"));\n\n        //expect a 500 status since the name is invalid\n        String location = HTTP_BASE_URL + testPath;\n\t\tassertPostStatus(location, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, postParams, null);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test import operation which replaces existing content\n     */\n    public void testImportReplace() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        //add node that will get replaced\n        props.put(\"propTest\", \"propTestValue\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath + \"/nodeName\", props);\n        \n        //import with the replace option to replace the existing node.\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.json\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        props.put(SlingPostConstants.RP_REPLACE, \"true\");\n        String importedNodeUrl2 = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        //the new node should have the same path as the replaced node\n        assertEquals(importedNodeUrl, importedNodeUrl2);\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl2 + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\t\tassertNull(jsonObj.optString(\"propTest\", null)); //test property should be gone.\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32828,"modified_method":"/**\n     * Test import operation which replaces existing content\n     */\n    public void testImportReplace() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        //add node that will get replaced\n        props.put(\"propTest\", \"propTestValue\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath + \"/nodeName\", props);\n\n        //import with the replace option to replace the existing node.\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.json\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        props.put(SlingPostConstants.RP_REPLACE, \"true\");\n        String importedNodeUrl2 = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        //the new node should have the same path as the replaced node\n        assertEquals(importedNodeUrl, importedNodeUrl2);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl2 + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\t\tassertNull(jsonObj.optString(\"propTest\", null)); //test property should be gone.\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"public void testImportXMLFromRequestParam() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String xmlContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT, xmlContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32829,"modified_method":"public void testImportXMLFromRequestParam() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String xmlContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT, xmlContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"public void testImportJCRXMLFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testnode_1287021810\";\n        props.put(SlingPostConstants.RP_NODE_NAME, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.jcr.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"jcr.xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32830,"modified_method":"public void testImportJCRXMLFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testnode_1287021810\";\n        props.put(SlingPostConstants.RP_NODE_NAME, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.jcr.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"jcr.xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test import operation for a posted json file\n     */\n    public void testImportJSONFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32831,"modified_method":"/**\n     * Test import operation for a posted json file\n     */\n    public void testImportJSONFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"static String getStreamAsString(InputStream is, String charset) throws IOException {\n\t\tInputStreamReader reader = new InputStreamReader(is, charset);\n        final StringBuilder content = new StringBuilder();\n        final char [] buffer = new char[16384];\n        int n = 0;\n        while( (n = reader.read(buffer, 0, buffer.length)) > 0) {\n            content.append(new String(buffer, 0, n));\n        }\n        return content.toString();\n    }","id":32832,"modified_method":"static String getStreamAsString(InputStream is, String charset) throws IOException {\n\t\tInputStreamReader reader = new InputStreamReader(is, charset);\n        final StringBuilder content = new StringBuilder();\n        final char [] buffer = new char[16384];\n        int n = 0;\n        while( (n = reader.read(buffer)) > 0) {\n            content.append(buffer, 0, n);\n        }\n        return content.toString();\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test import operation for a posted json file without the optional name\n     */\n    public void testImportJSONFromFileWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.json\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32833,"modified_method":"/**\n     * Test import operation for a posted json file without the optional name\n     */\n    public void testImportJSONFromFileWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.json\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"public void testImportXMLFromRequestParamWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String xmlContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT, xmlContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        \n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32834,"modified_method":"public void testImportXMLFromRequestParamWithoutOptionalName() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String xmlContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport2.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT, xmlContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        //make sure the name is what was inside the file.\n        assertTrue(importedNodeUrl.endsWith(\"/nodeName\"));\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"public void testImportZipFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.zip\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"zip\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimportzip.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32835,"modified_method":"public void testImportZipFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.zip\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"zip\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimportzip.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Test import operation for a posted json string\n     */\n    public void testImportJSONFromRequestParam() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String jsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32836,"modified_method":"/**\n     * Test import operation for a posted json string\n     */\n    public void testImportJSONFromRequestParam() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String jsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * SLING-1627: test import of content over existing content with the ':replaceProperties\"\n     * parameter set and the \":replace\" property not set.\n     */\n    public void testImportReplaceProperties() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        //1. First import some initial content\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String jsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n\n    \t\n\t\t//2. Second, import on top of the node from #1 to replace some properties.\n\t\t\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String jsonContent2 = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_replaceProps.json\"));\n\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent2);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, importedNodeUrl);\n        props.put(SlingPostConstants.RP_REPLACE, \"false\");\n        props.put(SlingPostConstants.RP_REPLACE_PROPERTIES, \"true\");\n        String importedNodeUrl2 = testClient.createNode(importedNodeUrl, props);\n        assertEquals(importedNodeUrl, importedNodeUrl2);\n        \n        // assert content at new location\n        String content2 = getContent(importedNodeUrl2 + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj2 = new JSONObject(content2);\n\t\tassertNotNull(jsonObj2);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent2 = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_replaceProps.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent2), jsonObj2);\n    }","id":32837,"modified_method":"/**\n     * SLING-1627: test import of content over existing content with the ':replaceProperties\"\n     * parameter set and the \":replace\" property not set.\n     */\n    public void testImportReplaceProperties() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        //1. First import some initial content\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String jsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.json\"));\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n\n\n\t\t//2. Second, import on top of the node from #1 to replace some properties.\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String jsonContent2 = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_replaceProps.json\"));\n\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent2);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, importedNodeUrl);\n        props.put(SlingPostConstants.RP_REPLACE, \"false\");\n        props.put(SlingPostConstants.RP_REPLACE_PROPERTIES, \"true\");\n        String importedNodeUrl2 = testClient.createNode(importedNodeUrl, props);\n        assertEquals(importedNodeUrl, importedNodeUrl2);\n\n        // assert content at new location\n        String content2 = getContent(importedNodeUrl2 + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj2 = new JSONObject(content2);\n\t\tassertNotNull(jsonObj2);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent2 = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_replaceProps.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent2), jsonObj2);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * SLING-2143: test import where json is in a UTF-8 charset\n     */\n    public void testImportJSONWithUTF8Content() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String jsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_utf8.json\"), \"UTF-8\");\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_utf8.json\"), \"UTF-8\");\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32838,"modified_method":"/**\n     * SLING-2143: test import where json is in a UTF-8 charset\n     */\n    public void testImportJSONWithUTF8Content() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        String jsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_utf8.json\"), \"UTF-8\");\n        props.put(SlingPostConstants.RP_CONTENT, jsonContent);\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"json\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, props);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport_utf8.json\"), \"UTF-8\");\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"public void testImportJarFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.jar\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"jar\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimportzip.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32839,"modified_method":"public void testImportJarFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.jar\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"jar\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimportzip.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"public void testImportXMLFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n        \n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n        \n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = (String)getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","id":32840,"modified_method":"public void testImportXMLFromFile() throws IOException, JSONException {\n        final String testPath = TEST_BASE_PATH;\n        Map<String, String> props = new HashMap<String, String>();\n        String testNode = testClient.createNode(HTTP_BASE_URL + testPath, props);\n        urlsToDelete.add(testNode);\n\n        props.clear();\n        props.put(SlingPostConstants.RP_OPERATION,\n        \t\tSlingPostConstants.OPERATION_IMPORT);\n\n        String testNodeName = \"testNode_\" + String.valueOf(random.nextInt());\n        props.put(SlingPostConstants.RP_NODE_NAME_HINT, testNodeName);\n        testFile = getTestFile(getClass().getResourceAsStream(\"/integration-test/servlets/post/testimport.xml\"));\n        props.put(SlingPostConstants.RP_CONTENT_TYPE, \"xml\");\n        props.put(SlingPostConstants.RP_REDIRECT_TO, SERVLET_CONTEXT + testPath + \"/*\");\n        String importedNodeUrl = testClient.createNode(HTTP_BASE_URL + testPath, new NameValuePairList(props), null, true,\n        \t\ttestFile, SlingPostConstants.RP_CONTENT_FILE, null);\n\n        // assert content at new location\n        String content = getContent(importedNodeUrl + \".3.json\", CONTENT_TYPE_JSON);\n\n\t\tJSONObject jsonObj = new JSONObject(content);\n\t\tassertNotNull(jsonObj);\n\n\t\t//assert the imported content is there.\n        String expectedJsonContent = getStreamAsString(getClass().getResourceAsStream(\"/integration-test/servlets/post/importresults.json\"));\n\t\tassertExpectedJSON(new JSONObject(expectedJsonContent), jsonObj);\n    }","commit_id":"63760db66c46734f9f824818b5df17852e9743f8","url":"https://github.com/apache/sling"},{"original_method":"public void applyRule(final SNode invoke, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    final List<SNode> ptypes = ListSequence.fromList(new ArrayList<SNode>());\n    for (SNode p : SLinkOperations.getTargets(invoke, \"parameter\", true)) {\n      final SNode T_typevar_7246115176735293270 = typeCheckingContext.createNewRuntimeTypesVariable();\n      ListSequence.fromList(ptypes).addElement(typeCheckingContext.getRepresentative(T_typevar_7246115176735293270));\n      {\n        SNode _nodeToCheck_1029348928467 = p;\n        BaseQuickFixProvider intentionProvider = null;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"2608385503904033315\", 0, intentionProvider);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"2608385503904033317\", true), (SNode) typeCheckingContext.getRepresentative(T_typevar_7246115176735293270), _info_12389875345);\n      }\n    }\n    final SNode ret_typevar_7246115176735293292 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = invoke;\n      BaseQuickFixProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7246115176735293294\", 0, intentionProvider);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7246115176735293298\", true), (SNode) typeCheckingContext.getRepresentative(ret_typevar_7246115176735293292), _info_12389875345);\n    }\n    final SNode ftype_typevar_642108346586029186 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(invoke, \"function\", true);\n      BaseQuickFixProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"642108346586029191\", 0, intentionProvider);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(ftype_typevar_642108346586029186), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"642108346586029206\", true), _info_12389875345);\n    }\n    {\n      final SNode _representatorVar_ojnxkp_g0a = typeCheckingContext.getRepresentative(ftype_typevar_642108346586029186);\n      typeCheckingContext.whenConcrete(_representatorVar_ojnxkp_g0a, new Runnable() {\n        public void run() {\n          try {\n            {\n              SNode _nodeToCheck_1029348928467 = invoke;\n              BaseQuickFixProvider intentionProvider = null;\n              EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"2608385503904033289\", 0, intentionProvider);\n              _info_12389875345.setInequationGroup(\"default\");\n              typeCheckingContext.createGreaterThanInequation((SNode) typeCheckingContext.getRepresentative(ret_typevar_7246115176735293292), (SNode) FunctionTypeUtil.getResultType(typeCheckingContext.getRepresentative(ftype_typevar_642108346586029186)), false, _info_12389875345);\n            }\n            {\n              SNode pt;\n              SNode fpt;\n              Iterator<SNode> pt_iterator = ListSequence.fromList(ptypes).iterator();\n              Iterator<SNode> fpt_iterator = ListSequence.fromList(FunctionTypeUtil.getParameterTypes(typeCheckingContext.getRepresentative(ftype_typevar_642108346586029186))).iterator();\n              while (true) {\n                if (!(pt_iterator.hasNext())) {\n                  break;\n                }\n                if (!(fpt_iterator.hasNext())) {\n                  break;\n                }\n                pt = pt_iterator.next();\n                fpt = fpt_iterator.next();\n                {\n                  SNode _nodeToCheck_1029348928467 = pt;\n                  BaseQuickFixProvider intentionProvider = null;\n                  EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"2608385503904033296\", 0, intentionProvider);\n                  _info_12389875345.setInequationGroup(\"default\");\n                  typeCheckingContext.createLessThanInequation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"2608385503904033298\", true), (SNode) fpt, false, _info_12389875345);\n                }\n              }\n            }\n          } catch (RuntimeException ex) {\n            if (!(false)) {\n              BaseQuickFixProvider intentionProvider = null;\n              MessageTarget errorTarget = new NodeMessageTarget();\n              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(invoke, ex.getMessage(), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"8679288141369466374\", intentionProvider, errorTarget);\n            }\n          }\n        }\n      }, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"642108346586001510\", false, false);\n    }\n  }","id":32841,"modified_method":"public void applyRule(final SNode invoke, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    final List<SNode> ptypes = ListSequence.fromList(new ArrayList<SNode>());\n    for (SNode p : SLinkOperations.getTargets(invoke, \"parameter\", true)) {\n      final SNode T_typevar_668767903263948977 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = p;\n        BaseQuickFixProvider intentionProvider = null;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"668767903263948978\", 0, intentionProvider);\n        _info_12389875345.setInequationGroup(\"default\");\n        typeCheckingContext.createLessThanInequation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"668767903263948980\", true), (SNode) typeCheckingContext.getRepresentative(T_typevar_668767903263948977), true, _info_12389875345);\n      }\n      ListSequence.fromList(ptypes).addElement(typeCheckingContext.getRepresentative(T_typevar_668767903263948977));\n    }\n    final SNode ret_typevar_668767903263948995 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(invoke, \"function\", true);\n      BaseQuickFixProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"668767903263948996\", 0, intentionProvider);\n      _info_12389875345.setInequationGroup(\"default\");\n      typeCheckingContext.createGreaterThanInequation((SNode) new typeof_CompactInvokeFunctionExpression_InferenceRule.QuotationClass_ojnxkp_a0a3a0().createNode(ptypes, typeCheckingContext.getRepresentative(ret_typevar_668767903263948995), typeCheckingContext), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"668767903263948998\", true), false, _info_12389875345);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = invoke;\n      BaseQuickFixProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"668767903263949012\", 0, intentionProvider);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"668767903263949016\", true), (SNode) typeCheckingContext.getRepresentative(ret_typevar_668767903263948995), _info_12389875345);\n    }\n  }","commit_id":"037bd5e2dc9ef8129a28ef3f07f0a08387507985","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSubOrSuperType(SNode longClassifier, TypeCheckingContext typeCheckingContext) {\n    return new _Quotations.QuotationClass_115().createNode(typeCheckingContext);\n  }","id":32842,"modified_method":"public SNode getSubOrSuperType(SNode longClassifier, TypeCheckingContext typeCheckingContext) {\n    return new _Quotations.QuotationClass_116().createNode(typeCheckingContext);\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSubOrSuperType(SNode durationType, TypeCheckingContext typeCheckingContext) {\n    return new _Quotations.QuotationClass_116().createNode(typeCheckingContext);\n  }","id":32843,"modified_method":"public SNode getSubOrSuperType(SNode durationType, TypeCheckingContext typeCheckingContext) {\n    return new _Quotations.QuotationClass_117().createNode(typeCheckingContext);\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NowExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_UnaryDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_FormatExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeCompareOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeWithPropertyOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PeriodConstant_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeMinusPeriodOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimePlusPeriodOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeMinusOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NeverExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_MathDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_TimeZoneConstant_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeZoneCreator_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConstantTimeZone_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_InlineFormatExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_TimeZoneFromString_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PeriodInPropertyOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_WithPropertyCompareExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ParseExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_RoundDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_InTimezone_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ParseDateTimeExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_FormatDateTimeExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_InlineFormatDateTimeExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToJavaCalendarOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToJavaDateOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToJodaDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimePropetyReferenceOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NotNullOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NullOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToDurationOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PeriodInPropertyExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ScheduleLiteral_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DateTimeType_unboxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DateTimeType_boxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DurationType_boxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DurationType_unboxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_21().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_22().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_23().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_25().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_26().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_24().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_27().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_28().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_29().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_31().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_30().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_32().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_33().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_34().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_35().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_46().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_47().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_48().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_49().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_50().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_51().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_64().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_65().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_66().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_67().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_68().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_69().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_70().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_71().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_72().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_73().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_74().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_75().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_76().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_77().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_78().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_80().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_79().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_81().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_83().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_84().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_82().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_95().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_96().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_97().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_98().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_99().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_100().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_104().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_105().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_106().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_108().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_107().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_109().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_112().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_113().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_114().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n  }","id":32844,"modified_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NowExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_UnaryDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_FormatExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeCompareOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeWithPropertyOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PeriodConstant_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeMinusPeriodOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimePlusPeriodOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeMinusOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NeverExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_MathDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_TimeZoneConstant_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimeZoneCreator_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConstantTimeZone_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_InlineFormatExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_TimeZoneFromString_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PeriodInPropertyOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_WithPropertyCompareExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ParseExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_RoundDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_InTimezone_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ParseDateTimeExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_FormatDateTimeExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_InlineFormatDateTimeExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToJavaCalendarOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToJavaDateOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToJodaDateTimeOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_DateTimePropetyReferenceOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NotNullOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_NullOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ConvertToDurationOperation_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_PeriodInPropertyExpression_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_ScheduleLiteral_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DateTimeType_unboxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DateTimeType_boxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DurationType_boxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      SubtypingRule_Runtime subtypingRule = new DurationType_unboxing_SubtypingRule();\n      this.mySubtypingRules.add(subtypingRule);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_21().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_22().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_23().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_25().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_26().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_24().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_27().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_28().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_29().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_31().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_30().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_32().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_33().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_34().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_35().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_46().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_47().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_48().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_49().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_50().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_51().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_64().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_65().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_66().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_67().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_68().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_69().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_70().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_71().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_72().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_73().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_74().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_75().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_76().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_77().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_78().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_80().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_79().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_81().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_83().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_84().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.MinusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_82().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_94().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_95().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.BinaryCompareOperation\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_96().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_97().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_98().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_99().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_105().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_106().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_107().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_109().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_108().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_110().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n    {\n      OverloadedOperationsTypesProvider provider = new OverloadedOperationsTypesProvider() {\n        {\n          this.myLeftOperandType = new _Quotations.QuotationClass_113().createNode();\n          this.myRightOperandType = new _Quotations.QuotationClass_114().createNode();\n          this.myOperationConceptFQName = \"jetbrains.mps.baseLanguage.structure.PlusExpression\";\n          this.myLeftTypeIsExact = true;\n          this.myRightTypeIsExact = true;\n          this.myRightIsStrong = false;\n          this.myLeftIsStrong = false;\n        }\n\n        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {\n          return new _Quotations.QuotationClass_115().createNode();\n        }\n      };\n      this.myOverloadedOperationsTypesProviders.add(provider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183362\", true), (SNode)new _Quotations.QuotationClass_117().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183365\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = IOperation_Behavior.call_getOperand_1213877410070(operation);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183375\", true), (SNode)new _Quotations.QuotationClass_118().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183383\", intentionProvider);\n    }\n  }","id":32845,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183362\", true), (SNode)new _Quotations.QuotationClass_118().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183365\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = IOperation_Behavior.call_getOperand_1213877410070(operation);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183375\", true), (SNode)new _Quotations.QuotationClass_119().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5372916090361183383\", intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode op, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(op, \"expression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1204416290893\", true), (SNode)new _Quotations.QuotationClass_10().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1204416302428\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = op;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551102\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(op, \"datetime\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551123\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551110\", intentionProvider);\n    }\n  }","id":32846,"modified_method":"public void applyRule(final SNode op, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(op, \"expression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1204416290893\", true), (SNode)new _Quotations.QuotationClass_10().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1204416302428\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = op;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551102\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(op, \"datetime\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551123\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551110\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(op, \"datetime\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3986031709810154698\", true), (SNode)new _Quotations.QuotationClass_100().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3986031709810158442\", true, 0, intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302136\", true), (SNode)new _Quotations.QuotationClass_110().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302139\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"datetime\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302149\", true), (SNode)new _Quotations.QuotationClass_111().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302157\", intentionProvider);\n    }\n  }","id":32847,"modified_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302136\", true), (SNode)new _Quotations.QuotationClass_111().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302139\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"datetime\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302149\", true), (SNode)new _Quotations.QuotationClass_112().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5034322243092302157\", intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode timezone, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = timezone;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402700237\", true), (SNode)new _Quotations.QuotationClass_89().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402700252\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(timezone, \"datetime\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402700264\", true), (SNode)new _Quotations.QuotationClass_90().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402701477\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(timezone, \"timezone\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402701493\", true), (SNode)new _Quotations.QuotationClass_91().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402701501\", intentionProvider);\n    }\n  }","id":32848,"modified_method":"public void applyRule(final SNode timezone, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = timezone;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402700237\", true), (SNode)new _Quotations.QuotationClass_89().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402700252\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(timezone, \"datetime\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3986031709811403927\", true), (SNode)new _Quotations.QuotationClass_101().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3986031709811403925\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(timezone, \"timezone\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402701493\", true), (SNode)new _Quotations.QuotationClass_90().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402701501\", intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode mathOperation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(mathOperation, \"leftExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224368532\", true), (SNode)new _Quotations.QuotationClass_92().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224368530\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(mathOperation, \"rightExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224421754\", true), (SNode)new _Quotations.QuotationClass_93().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224421752\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(mathOperation, \"leftExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224424984\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(mathOperation, \"rightExpression\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224424997\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224424992\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = mathOperation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1238249542975\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(mathOperation, \"leftExpression\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224306337\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1238249548697\", intentionProvider);\n    }\n  }","id":32849,"modified_method":"public void applyRule(final SNode mathOperation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(mathOperation, \"leftExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224368532\", true), (SNode)new _Quotations.QuotationClass_91().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224368530\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(mathOperation, \"rightExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224421754\", true), (SNode)new _Quotations.QuotationClass_92().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224421752\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(mathOperation, \"leftExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224424984\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(mathOperation, \"rightExpression\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224424997\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224424992\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = mathOperation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1238249542975\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(mathOperation, \"leftExpression\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2644539331224306337\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1238249548697\", intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638813\", true), (SNode)new _Quotations.QuotationClass_101().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638816\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"default\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638850\", true), (SNode)new _Quotations.QuotationClass_102().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638858\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"source\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638873\", true), (SNode)new _Quotations.QuotationClass_103().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638868\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"zone\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7499037524191428197\", true), (SNode)new _Quotations.QuotationClass_122().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7499037524191428205\", intentionProvider);\n    }\n  }","id":32850,"modified_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638813\", true), (SNode)new _Quotations.QuotationClass_102().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638816\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"default\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638850\", true), (SNode)new _Quotations.QuotationClass_103().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638858\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"source\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638873\", true), (SNode)new _Quotations.QuotationClass_104().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"4389880778953638868\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(expression, \"zone\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7499037524191428197\", true), (SNode)new _Quotations.QuotationClass_123().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7499037524191428205\", intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode pe, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(pe, \"source\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204767239\", true), (SNode)new _Quotations.QuotationClass_86().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204768359\", true, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(pe, \"default\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7678715681280021116\", true), (SNode)new _Quotations.QuotationClass_123().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7678715681280022236\", true, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = pe;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204768371\", true), (SNode)new _Quotations.QuotationClass_87().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204768374\", intentionProvider);\n    }\n  }","id":32851,"modified_method":"public void applyRule(final SNode pe, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(pe, \"source\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204767239\", true), (SNode)new _Quotations.QuotationClass_86().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204768359\", true, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(pe, \"default\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7678715681280021116\", true), (SNode)new _Quotations.QuotationClass_124().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"7678715681280022236\", true, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = pe;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204768371\", true), (SNode)new _Quotations.QuotationClass_87().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1892577441204768374\", intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551153\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"datetime\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551161\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551156\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(operation, \"datetime\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5488841840788545324\", true), (SNode)new _Quotations.QuotationClass_119().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5488841840788546541\", true, 0, intentionProvider);\n    }\n  }","id":32852,"modified_method":"public void applyRule(final SNode operation, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = operation;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551153\", true), (SNode)typeCheckingContext.typeOf(SLinkOperations.getTarget(operation, \"datetime\", true), \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551161\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"2639623922402551156\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(operation, \"datetime\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5488841840788545324\", true), (SNode)new _Quotations.QuotationClass_120().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5488841840788546541\", true, 0, intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode literal, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = literal;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3394771273339689753\", true), (SNode)new _Quotations.QuotationClass_94().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3394771273339689756\", intentionProvider);\n    }\n  }","id":32853,"modified_method":"public void applyRule(final SNode literal, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = literal;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3394771273339689753\", true), (SNode)new _Quotations.QuotationClass_93().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"3394771273339689756\", intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1239808503999\", true), (SNode)new _Quotations.QuotationClass_53().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1239808508190\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SLinkOperations.getTarget(expression, \"operation\", true), \"leftExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457529\", true), (SNode)new _Quotations.QuotationClass_120().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457527\", true, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SLinkOperations.getTarget(expression, \"operation\", true), \"rightExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457540\", true), (SNode)new _Quotations.QuotationClass_121().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457538\", true, 0, intentionProvider);\n    }\n  }","id":32854,"modified_method":"public void applyRule(final SNode expression, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = expression;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1239808503999\", true), (SNode)new _Quotations.QuotationClass_53().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"1239808508190\", intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SLinkOperations.getTarget(expression, \"operation\", true), \"leftExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457529\", true), (SNode)new _Quotations.QuotationClass_121().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457527\", true, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SLinkOperations.getTarget(expression, \"operation\", true), \"rightExpression\", true);\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457540\", true), (SNode)new _Quotations.QuotationClass_122().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903d1(jetbrains.mps.baseLanguage.dates.typesystem)\", \"5600029375248457538\", true, 0, intentionProvider);\n    }\n  }","commit_id":"2c903650371b59ca7c245040d025324b1a4e69fc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049600040\", true), new QuotationClass_2().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049606449\", intentionProvider);\n    }\n  }","id":32855,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049600040\", true), new QuotationClass_2().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049606449\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1200512000904\", true), new QuotationClass_4().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1200512038892\", intentionProvider);\n    }\n  }","id":32856,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1200512000904\", true), new QuotationClass_4().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1200512038892\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    for(SNode element : SLinkOperations.getTargets(nodeToCheck, \"constants\", true)) {\n      {\n        SNode _nodeToCheck_1029348928467 = nodeToCheck;\n        BaseIntentionProvider intentionProvider = null;\n        TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(element, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197401239298\", true), ListSequence.fromList(SLinkOperations.getConceptLinkTargets(nodeToCheck, \"type\")).first(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197401256457\", false, 0, intentionProvider);\n      }\n    }\n  }","id":32857,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    for(SNode element : SLinkOperations.getTargets(nodeToCheck, \"constants\", true)) {\n      {\n        SNode _nodeToCheck_1029348928467 = nodeToCheck;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(element, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197401239298\", true), ListSequence.fromList(SLinkOperations.getConceptLinkTargets(nodeToCheck, \"type\")).first(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197401256457\", false, 0, intentionProvider);\n      }\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1199032106410\", true), new QuotationClass_3().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1199032106408\", intentionProvider);\n    }\n  }","id":32858,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1199032106410\", true), new QuotationClass_3().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1199032106408\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196872829511\", true), new QuotationClass_0().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196872839076\", intentionProvider);\n    }\n  }","id":32859,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196872829511\", true), new QuotationClass_0().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196872839076\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"propertyValue\", true), \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871226606\", true), SLinkOperations.getTarget(nodeToCheck, \"type\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871226604\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871295252\", true), SLinkOperations.getTarget(nodeToCheck, \"type\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871299285\", intentionProvider);\n    }\n  }","id":32860,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(SLinkOperations.getTarget(nodeToCheck, \"propertyValue\", true), \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871226606\", true), SLinkOperations.getTarget(nodeToCheck, \"type\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871226604\", false, 0, intentionProvider);\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871295252\", true), SLinkOperations.getTarget(nodeToCheck, \"type\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871299285\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871332366\", true), TypeChecker.getInstance().getRuntimeSupport().typeOf(SLinkOperations.getTarget(nodeToCheck, \"propertyDeclaration\", false), \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871369284\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871348598\", intentionProvider);\n    }\n  }","id":32861,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871332366\", true), typeCheckingContext.typeOf(SLinkOperations.getTarget(nodeToCheck, \"propertyDeclaration\", false), \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871369284\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1196871348598\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049545310\", true), new QuotationClass_1().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049555016\", intentionProvider);\n    }\n  }","id":32862,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049545310\", true), new QuotationClass_1().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1197049555016\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1203432895581\", true), new QuotationClass_6().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1203432895579\", intentionProvider);\n    }\n  }","id":32863,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(nodeToCheck, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1203432895581\", true), new QuotationClass_6().createNode(), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895904c4(jetbrains.mps.buildlanguage.helgins)\", \"1203432895579\", intentionProvider);\n    }\n  }","commit_id":"192681e080b465cccd6bf19cdbc5f5111c76b0c6","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void copyBodyToResponse() throws IOException {\n\t\tif (this.content.size() > 0) {\n\t\t\tgetResponse().setContentLength(this.content.size());\n\t\t\tStreamUtils.copy(this.content.toByteArray(), getResponse().getOutputStream());\n\t\t\tthis.content.reset();\n\t\t}\n\t}","id":32864,"modified_method":"public void copyBodyToResponse() throws IOException {\n\t\tif (this.content.size() > 0) {\n\t\t\tHttpServletResponse rawResponse = (HttpServletResponse) getResponse();\n\t\t\tif(! rawResponse.isCommitted()){\n\t\t\t\trawResponse.setContentLength(this.content.size());\n\t\t\t}\n\t\t\tthis.content.writeTo(rawResponse.getOutputStream());\n\t\t\tthis.content.reset();\n\t\t}\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void setContentLength(int len) {\n\t\tif (len > this.content.capacity()) {\n\t\t\tthis.content.resize(len);\n\t\t}\n\t}","id":32865,"modified_method":"@Override\n\tpublic void setContentLength(int len) {\n\t\tthis.content.resize(len);\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void setContentLengthLong(long len) {\n\t\tif (len > Integer.MAX_VALUE) {\n\t\t\tthrow new IllegalArgumentException(\"Content-Length exceeds ShallowEtagHeaderFilter's maximum (\" +\n\t\t\t\t\tInteger.MAX_VALUE + \"): \" + len);\n\t\t}\n\t\tif (len > this.content.capacity()) {\n\t\t\tthis.content.resize((int) len);\n\t\t}\n\t}","id":32866,"modified_method":"public void setContentLengthLong(long len) {\n\t\tif (len > Integer.MAX_VALUE) {\n\t\t\tthrow new IllegalArgumentException(\"Content-Length exceeds ShallowEtagHeaderFilter's maximum (\" +\n\t\t\t\t\tInteger.MAX_VALUE + \"): \" + len);\n\t\t}\n\t\tthis.content.resize((int) len);\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void setBufferSize(int size) {\n\t\tif (size > this.content.capacity()) {\n\t\t\tthis.content.resize(size);\n\t\t}\n\t}","id":32867,"modified_method":"@Override\n\tpublic void setBufferSize(int size) {\n\t\tthis.content.resize(size);\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Indicates whether the given request and response are eligible for ETag generation.\n\t * <p>The default implementation returns {@code true} if all conditions match:\n\t * <ul>\n\t * <li>response status codes in the {@code 2xx} series<\/li>\n\t * <li>request method is a GET<\/li>\n\t * <li>response Cache-Control header is not set or does not contain a \"no-store\" directive<\/li>\n\t * <\/ul>\n\t * @param request the HTTP request\n\t * @param response the HTTP response\n\t * @param responseStatusCode the HTTP response status code\n\t * @param responseBody the response body\n\t * @return {@code true} if eligible for ETag generation; {@code false} otherwise\n\t */\n\tprotected boolean isEligibleForEtag(HttpServletRequest request, HttpServletResponse response,\n\t\t\tint responseStatusCode, byte[] responseBody) {\n\n\t\tif (responseStatusCode >= 200 && responseStatusCode < 300 &&\n\t\t\t\tHttpMethod.GET.name().equals(request.getMethod())) {\n\t\t\tString cacheControl = (responseGetHeaderAvailable ? response.getHeader(HEADER_CACHE_CONTROL) : null);\n\t\t\tif (cacheControl == null || !cacheControl.contains(DIRECTIVE_NO_STORE)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":32868,"modified_method":"/**\n\t * Indicates whether the given request and response are eligible for ETag generation.\n\t * <p>The default implementation returns {@code true} if all conditions match:\n\t * <ul>\n\t * <li>response status codes in the {@code 2xx} series<\/li>\n\t * <li>request method is a GET<\/li>\n\t * <li>response Cache-Control header is not set or does not contain a \"no-store\" directive<\/li>\n\t * <\/ul>\n\t * @param request the HTTP request\n\t * @param response the HTTP response\n\t * @param responseStatusCode the HTTP response status code\n\t * @param inputStream the response body\n\t * @return {@code true} if eligible for ETag generation; {@code false} otherwise\n\t */\n\tprotected boolean isEligibleForEtag(HttpServletRequest request, HttpServletResponse response,\n\t\t\tint responseStatusCode, InputStream inputStream) {\n\n\t\tif (responseStatusCode >= 200 && responseStatusCode < 300 &&\n\t\t\t\tHttpMethod.GET.name().equals(request.getMethod())) {\n\t\t\tString cacheControl = (responseGetHeaderAvailable ? response.getHeader(HEADER_CACHE_CONTROL) : null);\n\t\t\tif (cacheControl == null || !cacheControl.contains(DIRECTIVE_NO_STORE)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Generate the ETag header value from the given response body byte array.\n\t * <p>The default implementation generates an MD5 hash.\n\t * @param bytes the response body as byte array\n\t * @return the ETag header value\n\t * @see org.springframework.util.DigestUtils\n\t */\n\tprotected String generateETagHeaderValue(byte[] bytes) {\n\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\tDigestUtils.appendMd5DigestAsHex(bytes, builder);\n\t\tbuilder.append('\"');\n\t\treturn builder.toString();\n\t}","id":32869,"modified_method":"/**\n\t * Generate the ETag header value from the given response body byte array.\n\t * <p>The default implementation generates an MD5 hash.\n\t * @param inputStream the response body as an InputStream\n\t * @return the ETag header value\n\t * @see org.springframework.util.DigestUtils\n\t */\n\tprotected String generateETagHeaderValue(InputStream inputStream) {\n\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\ttry {\n\t\t\tDigestUtils.appendMd5DigestAsHex(inputStream, builder);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tbuilder.append('\"');\n\t\treturn builder.toString();\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void updateResponse(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\tContentCachingResponseWrapper responseWrapper =\n\t\t\t\tWebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);\n\t\tAssert.notNull(responseWrapper, \"ShallowEtagResponseWrapper not found\");\n\n\t\tHttpServletResponse rawResponse = (HttpServletResponse) responseWrapper.getResponse();\n\t\tint statusCode = responseWrapper.getStatusCode();\n\t\tbyte[] body = responseWrapper.getContentAsByteArray();\n\n\t\tif (rawResponse.isCommitted()) {\n\t\t\tif (body.length > 0) {\n\t\t\t\tStreamUtils.copy(body, rawResponse.getOutputStream());\n\t\t\t}\n\t\t}\n\t\telse if (isEligibleForEtag(request, responseWrapper, statusCode, body)) {\n\t\t\tString responseETag = generateETagHeaderValue(body);\n\t\t\trawResponse.setHeader(HEADER_ETAG, responseETag);\n\t\t\tString requestETag = request.getHeader(HEADER_IF_NONE_MATCH);\n\t\t\tif (responseETag.equals(requestETag)) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"ETag [\" + responseETag + \"] equal to If-None-Match, sending 304\");\n\t\t\t\t}\n\t\t\t\trawResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"ETag [\" + responseETag + \"] not equal to If-None-Match [\" + requestETag +\n\t\t\t\t\t\t\t\"], sending normal response\");\n\t\t\t\t}\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\trawResponse.setContentLength(body.length);\n\t\t\t\t\tStreamUtils.copy(body, rawResponse.getOutputStream());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Response with status code [\" + statusCode + \"] not eligible for ETag\");\n\t\t\t}\n\t\t\tif (body.length > 0) {\n\t\t\t\trawResponse.setContentLength(body.length);\n\t\t\t\tStreamUtils.copy(body, rawResponse.getOutputStream());\n\t\t\t}\n\t\t}\n\t}","id":32870,"modified_method":"private void updateResponse(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\tContentCachingResponseWrapper responseWrapper =\n\t\t\t\tWebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);\n\t\tAssert.notNull(responseWrapper, \"ShallowEtagResponseWrapper not found\");\n\n\t\tHttpServletResponse rawResponse = (HttpServletResponse) responseWrapper.getResponse();\n\t\tint statusCode = responseWrapper.getStatusCode();\n\n\t\tif (rawResponse.isCommitted()) {\n\t\t\tresponseWrapper.copyBodyToResponse();\n\t\t}\n\t\telse if (isEligibleForEtag(request, responseWrapper, statusCode, responseWrapper.getContentInputStream())) {\n\t\t\tString responseETag = generateETagHeaderValue(responseWrapper.getContentInputStream());\n\t\t\trawResponse.setHeader(HEADER_ETAG, responseETag);\n\t\t\tString requestETag = request.getHeader(HEADER_IF_NONE_MATCH);\n\t\t\tif (responseETag.equals(requestETag)) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"ETag [\" + responseETag + \"] equal to If-None-Match, sending 304\");\n\t\t\t\t}\n\t\t\t\trawResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"ETag [\" + responseETag + \"] not equal to If-None-Match [\" + requestETag +\n\t\t\t\t\t\t\t\"], sending normal response\");\n\t\t\t\t}\n\t\t\t\tresponseWrapper.copyBodyToResponse();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Response with status code [\" + statusCode + \"] not eligible for ETag\");\n\t\t\t}\n\t\t\tresponseWrapper.copyBodyToResponse();\n\t\t}\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void isEligibleForEtag() {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest(\"GET\", \"/hotels\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\n\t\tassertTrue(filter.isEligibleForEtag(request, response, 200, new byte[0]));\n\t\tassertFalse(filter.isEligibleForEtag(request, response, 300, new byte[0]));\n\n\t\trequest = new MockHttpServletRequest(\"POST\", \"/hotels\");\n\t\tassertFalse(filter.isEligibleForEtag(request, response, 200, new byte[0]));\n\n\t\trequest = new MockHttpServletRequest(\"POST\", \"/hotels\");\n\t\trequest.addHeader(\"Cache-Control\",\"must-revalidate, no-store\");\n\t\tassertFalse(filter.isEligibleForEtag(request, response, 200, new byte[0]));\n\t}","id":32871,"modified_method":"@Test\n\tpublic void isEligibleForEtag() {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest(\"GET\", \"/hotels\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\n\t\tassertTrue(filter.isEligibleForEtag(request, response, 200, new ByteArrayInputStream(new byte[0])));\n\t\tassertFalse(filter.isEligibleForEtag(request, response, 300, new ByteArrayInputStream(new byte[0])));\n\n\t\trequest = new MockHttpServletRequest(\"POST\", \"/hotels\");\n\t\tassertFalse(filter.isEligibleForEtag(request, response, 200, new ByteArrayInputStream(new byte[0])));\n\n\t\trequest = new MockHttpServletRequest(\"POST\", \"/hotels\");\n\t\trequest.addHeader(\"Cache-Control\",\"must-revalidate, no-store\");\n\t\tassertFalse(filter.isEligibleForEtag(request, response, 200, new ByteArrayInputStream(new byte[0])));\n\t}","commit_id":"213a3fd779747e5e8dfc24905b9bb98da063a5a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * @see org.apache.wicket.request.resource.AbstractResource#newResourceResponse(org.apache.wicket.request.resource.IResource.Attributes)\n\t */\n\t@Override\n\tprotected ResourceResponse newResourceResponse(final Attributes attributes)\n\t{\n\t\tfinal ResourceResponse response = new ResourceResponse();\n\n\t\tString contentType = this.contentType;\n\n\t\tif (contentType == null)\n\t\t{\n\t\t\tif (filename != null)\n\t\t\t{\n\t\t\t\tcontentType = URLConnection.getFileNameMap().getContentTypeFor(filename);\n\t\t\t}\n\n\t\t\tif (contentType == null)\n\t\t\t{\n\t\t\t\tcontentType = \"application/octet-stream\";\n\t\t\t}\n\t\t}\n\n\n\t\tresponse.setContentType(contentType);\n\t\tresponse.setLastModified(lastModified);\n\n\t\tfinal byte[] data = getData(attributes);\n\t\tif (data == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"ByteArrayResource's data cannot be 'null'.\");\n\t\t}\n\t\tresponse.setContentLength(data.length);\n\n\t\tif (response.dataNeedsToBeWritten(attributes))\n\t\t{\n\t\t\tif (filename != null)\n\t\t\t{\n\t\t\t\tresponse.setFileName(filename);\n\t\t\t\tresponse.setContentDisposition(ContentDisposition.ATTACHMENT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresponse.setContentDisposition(ContentDisposition.INLINE);\n\t\t\t}\n\n\t\t\tresponse.setWriteCallback(new WriteCallback()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void writeData(final Attributes attributes)\n\t\t\t\t{\n\t\t\t\t\tattributes.getResponse().write(data);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconfigureResponse(response, attributes);\n\t\t}\n\n\t\treturn response;\n\t}","id":32872,"modified_method":"/**\n\t * @see org.apache.wicket.request.resource.AbstractResource#newResourceResponse(org.apache.wicket.request.resource.IResource.Attributes)\n\t */\n\t@Override\n\tprotected ResourceResponse newResourceResponse(final Attributes attributes)\n\t{\n\t\tfinal ResourceResponse response = new ResourceResponse();\n\n\t\tString contentType = this.contentType;\n\n\t\tif (contentType == null)\n\t\t{\n\t\t\tif (filename != null)\n\t\t\t{\n\t\t\t\tcontentType = URLConnection.getFileNameMap().getContentTypeFor(filename);\n\t\t\t}\n\n\t\t\tif (contentType == null)\n\t\t\t{\n\t\t\t\tcontentType = \"application/octet-stream\";\n\t\t\t}\n\t\t}\n\n\n\t\tresponse.setContentType(contentType);\n\t\tresponse.setLastModified(lastModified);\n\n\t\tfinal byte[] data = getData(attributes);\n\t\tif (data == null)\n\t\t{\n\t\t\tresponse.setError(HttpServletResponse.SC_NOT_FOUND);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.setContentLength(data.length);\n\n\t\t\tif (response.dataNeedsToBeWritten(attributes))\n\t\t\t{\n\t\t\t\tif (filename != null)\n\t\t\t\t{\n\t\t\t\t\tresponse.setFileName(filename);\n\t\t\t\t\tresponse.setContentDisposition(ContentDisposition.ATTACHMENT);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresponse.setContentDisposition(ContentDisposition.INLINE);\n\t\t\t\t}\n\n\t\t\t\tresponse.setWriteCallback(new WriteCallback()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void writeData(final Attributes attributes)\n\t\t\t\t\t{\n\t\t\t\t\t\tattributes.getResponse().write(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconfigureResponse(response, attributes);\n\t\t\t}\n\t\t}\n\n\t\treturn response;\n\t}","commit_id":"50b52742204a7b4aeab08bbd0716934744e1a880","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected ResourceResponse newResourceResponse(final Attributes attributes)\n\t{\n\t\tfinal ResourceResponse response = new ResourceResponse();\n\n\t\tif (lastModifiedTime != null)\n\t\t{\n\t\t\tresponse.setLastModified(lastModifiedTime);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.setLastModified(Time.now());\n\t\t}\n\n\t\tif (response.dataNeedsToBeWritten(attributes))\n\t\t{\n\t\t\tresponse.setContentType(\"image/\" + getFormat());\n\n\t\t\tresponse.setContentDisposition(ContentDisposition.INLINE);\n\n\t\t\tfinal byte[] imageData = getImageData(attributes);\n\t\t\tif (imageData == null)\n\t\t\t{\n\t\t\t\tresponse.setError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresponse.setWriteCallback(new WriteCallback()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void writeData(final Attributes attributes)\n\t\t\t\t\t{\n\t\t\t\t\t\tattributes.getResponse().write(imageData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfigureResponse(response, attributes);\n\t\t}\n\n\t\treturn response;\n\t}","id":32873,"modified_method":"@Override\n\tprotected ResourceResponse newResourceResponse(final Attributes attributes)\n\t{\n\t\tfinal ResourceResponse response = new ResourceResponse();\n\n\t\tif (lastModifiedTime != null)\n\t\t{\n\t\t\tresponse.setLastModified(lastModifiedTime);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.setLastModified(Time.now());\n\t\t}\n\n\t\tif (response.dataNeedsToBeWritten(attributes))\n\t\t{\n\t\t\tresponse.setContentType(\"image/\" + getFormat());\n\n\t\t\tresponse.setContentDisposition(ContentDisposition.INLINE);\n\n\t\t\tfinal byte[] imageData = getImageData(attributes);\n\t\t\tif (imageData == null)\n\t\t\t{\n\t\t\t\tresponse.setError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresponse.setWriteCallback(new WriteCallback()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void writeData(final Attributes attributes)\n\t\t\t\t\t{\n\t\t\t\t\t\tattributes.getResponse().write(imageData);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconfigureResponse(response, attributes);\n\t\t\t}\n\t\t}\n\n\t\treturn response;\n\t}","commit_id":"50b52742204a7b4aeab08bbd0716934744e1a880","url":"https://github.com/apache/wicket"},{"original_method":"private static final void outResponsePostfix(PrintWriter out)\n\tthrows IOException {\n\t\tout.write(\"\\n<\/rs>\");\n\t}","id":32874,"modified_method":"private static final Writer outResponsePrefix()\n\tthrows IOException {\n\t\tfinal StringWriter out = new StringWriter();\n\t\tout.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<rs>\\n\");\n\t\treturn out;\n\t}","commit_id":"fa44ee26e7c78496db0c78884f6afa3ac0fb4169","url":"https://github.com/zkoss/zk"},{"original_method":"/** Retrieves the response from {@link Viewable#getView}.\n\t */\n\tprivate void view(Session sess, HttpServletRequest request,\n\tHttpServletResponse response, String pi)\n\tthrows ServletException, IOException {\n\t\tif (D.ON && log.debugable()) log.debug(\"View \"+pi);\n\n\t\tif (pi.length() == 0 || pi.charAt(0) != '/')\n\t\t\tthrow new ServletException(\"Wrong path info: \"+pi);\n\t\tint j = pi.indexOf('/', 1);\n\t\tif (j < 0)\n\t\t\tthrow new ServletException(\"Wrong path info: \"+pi);\n\n\t\tfinal String dtid = pi.substring(1, j);\n\t\tfinal int k = pi.indexOf('/', ++j);\n\t\tfinal String uuid = k >= 0 ? pi.substring(j, k): pi.substring(j);\n\n\t\tfinal Media media;\n\t\ttry {\n\t\t\tfinal WebAppCtrl wappc = (WebAppCtrl)sess.getWebApp();\n\t\t\tfinal UiEngine uieng = wappc.getUiEngine();\n\t\t\tfinal Desktop desktop = wappc.getDesktopCache(sess).getDesktop(dtid);\n\n\t\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t\t_ctx, request, response, desktop, null);\n\t\t\tuieng.activate(exec);\n\t\t\ttry {\n\t\t\t\tfinal Component comp = desktop.getComponentByUuid(uuid);\n\t\t\t\tif (!(comp instanceof Viewable))\n\t\t\t\t\tthrow new ServletException(Viewable.class+\" must be implemented: \"+comp.getClass());\n\t\t\t\tmedia = ((Viewable)comp).getView(k >= 0 ? pi.substring(k): \"\");\n\t\t\t\tif (media == null) {\n\t\t\t\t\tresponse.sendError(response.SC_GONE, \"Media not found in \"+comp);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tuieng.deactivate(exec);\n\t\t\t}\n\t\t} catch (ComponentNotFoundException ex) {\n\t\t\t//possible because view might be as late as origin comp is gone\n\t\t\tresponse.sendError(response.SC_GONE, Messages.get(MZk.UPDATE_OBSOLETE_PAGE, uuid));\n\t\t\treturn;\n\t\t}\n\n\t\t//reading an image and send it back to client\n\t\tfinal String ctype = media.getContentType();\n\t\tif (ctype != null)\n\t\t\tresponse.setContentType(ctype);\n\n\t\tif (media.isBinary()) {\n\t\t\tfinal ServletOutputStream out = response.getOutputStream();\n\t\t\tif (media.inMemory()) {\n\t\t\t\tfinal byte[] data = media.getByteData();\n\t\t\t\tresponse.setContentLength(data.length);\n\t\t\t\tout.write(data);\n\t\t\t} else {\n\t\t\t\tFiles.copy(out, media.getStreamData());\n\t\t\t}\n\t\t\tout.flush();\n\t\t} else {\n\t\t\tfinal PrintWriter out = response.getWriter();\n\t\t\tif (media.inMemory()) {\n\t\t\t\tout.write(media.getStringData());\n\t\t\t} else {\n\t\t\t\tFiles.copy(out, media.getReaderData());\n\t\t\t}\n\t\t\tout.flush();\n\t\t}\n\t\t//FUTURE: support last-modified\n\t}","id":32875,"modified_method":"/** Retrieves the response from {@link Viewable#getView}.\n\t */\n\tprivate void view(Session sess, HttpServletRequest request,\n\tHttpServletResponse response, String pi)\n\tthrows ServletException, IOException {\n\t\tif (D.ON && log.debugable()) log.debug(\"View \"+pi);\n\n\t\tif (pi.length() == 0 || pi.charAt(0) != '/')\n\t\t\tthrow new ServletException(\"Wrong path info: \"+pi);\n\t\tint j = pi.indexOf('/', 1);\n\t\tif (j < 0)\n\t\t\tthrow new ServletException(\"Wrong path info: \"+pi);\n\n\t\tfinal String dtid = pi.substring(1, j);\n\t\tfinal int k = pi.indexOf('/', ++j);\n\t\tfinal String uuid = k >= 0 ? pi.substring(j, k): pi.substring(j);\n\n\t\tfinal Media media;\n\t\ttry {\n\t\t\tfinal WebAppCtrl wappc = (WebAppCtrl)sess.getWebApp();\n\t\t\tfinal UiEngine uieng = wappc.getUiEngine();\n\t\t\tfinal Desktop desktop = wappc.getDesktopCache(sess).getDesktop(dtid);\n\n\t\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t\t_ctx, request, response, desktop, null);\n\t\t\tuieng.activate(exec);\n\t\t\ttry {\n\t\t\t\tfinal Component comp = desktop.getComponentByUuid(uuid);\n\t\t\t\tif (!(comp instanceof Viewable))\n\t\t\t\t\tthrow new ServletException(Viewable.class+\" must be implemented: \"+comp.getClass());\n\t\t\t\tmedia = ((Viewable)comp).getView(k >= 0 ? pi.substring(k): \"\");\n\t\t\t\tif (media == null) {\n\t\t\t\t\tresponse.sendError(response.SC_GONE, \"Media not found in \"+comp);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tuieng.deactivate(exec);\n\t\t\t}\n\t\t} catch (ComponentNotFoundException ex) {\n\t\t\t//possible because view might be as late as origin comp is gone\n\t\t\tresponse.sendError(response.SC_GONE, Messages.get(MZk.UPDATE_OBSOLETE_PAGE, uuid));\n\t\t\treturn;\n\t\t}\n\n\t\t//reading an image and send it back to client\n\t\tfinal String ctype = media.getContentType();\n\t\tif (ctype != null)\n\t\t\tresponse.setContentType(ctype);\n\n\t\tif (!media.inMemory()) {\n\t\t\tif (media.isBinary()) {\n\t\t\t\tfinal ServletOutputStream out = response.getOutputStream();\n\t\t\t\tFiles.copy(out, media.getStreamData());\n\t\t\t\tout.flush();\n\t\t\t} else {\n\t\t\t\tfinal Writer out = response.getWriter();\n\t\t\t\tFiles.copy(out, media.getReaderData());\n\t\t\t\tout.flush();\n\t\t\t}\n\t\t\treturn; //done;\n\t\t}\n\n\t\tfinal ServletOutputStream out = response.getOutputStream();\n\t\tfinal byte[] data = media.isBinary() ? media.getByteData():\n\t\t\tmedia.getStringData().getBytes(\"UTF-8\");\n\t\tresponse.setContentLength(data.length);\n\t\tout.write(data);\n\t\tout.flush();\n\t\t//FUTURE: support last-modified\n\t}","commit_id":"fa44ee26e7c78496db0c78884f6afa3ac0fb4169","url":"https://github.com/zkoss/zk"},{"original_method":"private static final\n\tPrintWriter outResponsePrefix(HttpServletResponse response)\n\tthrows IOException {\n\t\tresponse.setContentType(\"text/xml;charset=UTF-8\");\n\t\tfinal PrintWriter out = response.getWriter();\n\t\tout.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<rs>\\n\");\n\t\treturn out;\n\t}","id":32876,"modified_method":"private static final\n\tvoid outResponsePostfix(HttpServletResponse response, Writer out)\n\tthrows IOException {\n\t\tout.write(\"\\n<\/rs>\");\n\n\t\tfinal byte[] bs = ((StringWriter)out).toString().getBytes(\"UTF-8\");\n\t\tresponse.setContentType(\"text/xml;charset=UTF-8\");\n\t\tresponse.setContentLength(bs.length); //Strange but required for Jetty 6: Bug 1528592\n\t\tresponse.getOutputStream().write(bs);\n\t\tresponse.flushBuffer();\n\t}","commit_id":"fa44ee26e7c78496db0c78884f6afa3ac0fb4169","url":"https://github.com/zkoss/zk"},{"original_method":"/** Process update requests from the client. */\n\tprivate void process(Session sess,\n\tHttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal WebApp wapp = sess.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\t\tfinal UiEngine uieng = wappc.getUiEngine();\n\t\tfinal List aureqs = new LinkedList();\n\n\t\t//parse desktop ID\n\t\tfinal String dtid = request.getParameter(\"dtid\");\n\t\tif (dtid == null) {\n\t\t\tresponseError(uieng, response, \"Illegal request: dtid is required\");\n\t\t\treturn;\n\t\t}\n\t\tfinal Desktop desktop;\n\t\ttry {\n\t\t\tdesktop = wappc.getDesktopCache(sess).getDesktop(dtid);\n\t\t\tWebManager.setDesktop(request, desktop);\n\t\t\t\t//reason: a new page might be created (such as include)\n\t\t} catch (ComponentNotFoundException ex) {\n\t\t\tfinal PrintWriter out = outResponsePrefix(response);\n\n\t\t\tfinal String scmd = request.getParameter(\"cmd.0\");\n\t\t\tif (!\"rmDesktop\".equals(scmd) && !\"onRender\".equals(scmd)\n\t\t\t&& !\"onTimer\".equals(scmd)) {//possible in FF due to cache\n\t\t\t\tString uri = wapp.getConfiguration().getTimeoutURI();\n\t\t\t\tfinal AuResponse resp;\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tif (uri.length() != 0)\n\t\t\t\t\t\turi = Encodes.encodeURL(_ctx, request, response, uri);\n\t\t\t\t\tresp = new AuSendRedirect(uri, null);\n\t\t\t\t} else {\n\t\t\t\t\tresp = new AuObsolete(\n\t\t\t\t\t\tdtid, Messages.get(MZk.UPDATE_OBSOLETE_PAGE, dtid));\n\t\t\t\t}\n\t\t\t\tuieng.response(resp, out);\n\t\t\t}\n\n\t\t\toutResponsePostfix(out);\n\t\t\treturn;\n\t\t}\n\n\t\t//parse commands\n\t\ttry {\n\t\t\tfor (int j = 0;; ++j) {\n\t\t\t\tfinal String scmd = request.getParameter(\"cmd.\"+j);\n\t\t\t\tif (scmd == null)\n\t\t\t\t\tbreak;\n\n\t\t\t\tfinal AuRequest.Command cmd = AuRequest.getCommand(scmd);\n\t\t\t\tfinal String uuid = request.getParameter(\"uuid.\"+j);\n\t\t\t\tfinal String[] data = request.getParameterValues(\"data.\"+j);\n\t\t\t\tif (data != null) {\n\t\t\t\t\tfor (int k = data.length; --k >= 0;)\n\t\t\t\t\t\tif (\"zk_null~q\".equals(data[k]))\n\t\t\t\t\t\t\tdata[k] = null;\n\t\t\t\t}\n\t\t\t\tif (uuid == null || uuid.length() == 0) {\n\t\t\t\t\taureqs.add(new AuRequest(desktop, cmd, data));\n\t\t\t\t} else {\n\t\t\t\t\taureqs.add(new AuRequest(desktop, uuid, cmd, data));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (aureqs.isEmpty()) {\n\t\t\t\tresponseError(uieng, response, \"Illegal request: cmd is required\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (CommandNotFoundException ex) {\n\t\t\tresponseError(uieng, response, Exceptions.getMessage(ex));\n\t\t\treturn;\n\t\t}\n\n\t\tif (D.ON && log.debugable()) log.debug(\"AU request: \"+aureqs);\n\t\tfinal PrintWriter out = outResponsePrefix(response);\n\n\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t_ctx, request, response, desktop, null);\n\t\tuieng.execUpdate(exec, aureqs, out);\n\n\t\toutResponsePostfix(out);\n\t}","id":32877,"modified_method":"/** Process update requests from the client. */\n\tprivate void process(Session sess,\n\tHttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal WebApp wapp = sess.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\t\tfinal UiEngine uieng = wappc.getUiEngine();\n\t\tfinal List aureqs = new LinkedList();\n\n\t\t//parse desktop ID\n\t\tfinal String dtid = request.getParameter(\"dtid\");\n\t\tif (dtid == null) {\n\t\t\tresponseError(uieng, response, \"Illegal request: dtid is required\");\n\t\t\treturn;\n\t\t}\n\t\tfinal Desktop desktop;\n\t\ttry {\n\t\t\tdesktop = wappc.getDesktopCache(sess).getDesktop(dtid);\n\t\t\tWebManager.setDesktop(request, desktop);\n\t\t\t\t//reason: a new page might be created (such as include)\n\t\t} catch (ComponentNotFoundException ex) {\n\t\t\tfinal Writer out = outResponsePrefix();\n\n\t\t\tfinal String scmd = request.getParameter(\"cmd.0\");\n\t\t\tif (!\"rmDesktop\".equals(scmd) && !\"onRender\".equals(scmd)\n\t\t\t&& !\"onTimer\".equals(scmd)) {//possible in FF due to cache\n\t\t\t\tString uri = wapp.getConfiguration().getTimeoutURI();\n\t\t\t\tfinal AuResponse resp;\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tif (uri.length() != 0)\n\t\t\t\t\t\turi = Encodes.encodeURL(_ctx, request, response, uri);\n\t\t\t\t\tresp = new AuSendRedirect(uri, null);\n\t\t\t\t} else {\n\t\t\t\t\tresp = new AuObsolete(\n\t\t\t\t\t\tdtid, Messages.get(MZk.UPDATE_OBSOLETE_PAGE, dtid));\n\t\t\t\t}\n\t\t\t\tuieng.response(resp, out);\n\t\t\t}\n\n\t\t\toutResponsePostfix(response, out);\n\t\t\treturn;\n\t\t}\n\n\t\t//parse commands\n\t\ttry {\n\t\t\tfor (int j = 0;; ++j) {\n\t\t\t\tfinal String scmd = request.getParameter(\"cmd.\"+j);\n\t\t\t\tif (scmd == null)\n\t\t\t\t\tbreak;\n\n\t\t\t\tfinal AuRequest.Command cmd = AuRequest.getCommand(scmd);\n\t\t\t\tfinal String uuid = request.getParameter(\"uuid.\"+j);\n\t\t\t\tfinal String[] data = request.getParameterValues(\"data.\"+j);\n\t\t\t\tif (data != null) {\n\t\t\t\t\tfor (int k = data.length; --k >= 0;)\n\t\t\t\t\t\tif (\"zk_null~q\".equals(data[k]))\n\t\t\t\t\t\t\tdata[k] = null;\n\t\t\t\t}\n\t\t\t\tif (uuid == null || uuid.length() == 0) {\n\t\t\t\t\taureqs.add(new AuRequest(desktop, cmd, data));\n\t\t\t\t} else {\n\t\t\t\t\taureqs.add(new AuRequest(desktop, uuid, cmd, data));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (aureqs.isEmpty()) {\n\t\t\t\tresponseError(uieng, response, \"Illegal request: cmd is required\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (CommandNotFoundException ex) {\n\t\t\tresponseError(uieng, response, Exceptions.getMessage(ex));\n\t\t\treturn;\n\t\t}\n\n\t\tif (D.ON && log.debugable()) log.debug(\"AU request: \"+aureqs);\n\t\tfinal Writer out = outResponsePrefix();\n\n\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t_ctx, request, response, desktop, null);\n\t\tuieng.execUpdate(exec, aureqs, out);\n\n\t\toutResponsePostfix(response, out);\n\t}","commit_id":"fa44ee26e7c78496db0c78884f6afa3ac0fb4169","url":"https://github.com/zkoss/zk"},{"original_method":"public void start(PipelineContext pipelineContext) {\n        try {\n            // Read configuration input\n            final Config config = readConfig(pipelineContext);\n\n            // Get data input information\n            ProcessorInput dataInput = getInputByName(INPUT_DATA);\n\n            ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n            final ExternalContext.Response response = externalContext.getResponse();\n\n            // Compute headers\n            if (externalContext != null) {\n\n                // Send an error if needed and return immediately\n                int errorCode = config.errorCode;\n                if (errorCode != DEFAULT_ERROR_CODE) {\n                    response.sendError(errorCode);\n                    return;\n                }\n\n                // Get last modification date and compute last modified if possible\n                Object validity = getInputValidity(pipelineContext, dataInput);\n                long lastModified = (validity != null) ? findLastModified(validity) : 0;\n\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Last modified: \" + lastModified);\n\n                // Set caching headers and force revalidation\n                response.setCaching(lastModified, true, true);\n\n                // Check If-Modified-Since (conditional GET) and don't return content if condition is met\n                if (!response.checkIfModifiedSince(lastModified, true)) {\n                    response.setStatus(ExternalContext.SC_NOT_MODIFIED);\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Sending SC_NOT_MODIFIED\");\n                    return;\n                }\n\n                // Set status code\n                response.setStatus(config.statusCode);\n\n                // Set custom headers\n                if (config.headers != null) {\n                    for(Iterator i = config.headers.iterator(); i.hasNext();){\n                        String name = (String) i.next();\n                        String value = (String) i.next();\n                        response.setHeader(name, value);\n                    }\n                }\n            }\n\n            // If we have an empty body, return w/o reading the data input\n            if (config.empty)\n                return;\n\n            final OutputStream httpOutputStream = response.getOutputStream();\n\n            if (config.cacheUseLocalCache) {\n                // If local caching of the data is enabled, use the caching API\n                // We return a ResultStore\n                final boolean[] read = new boolean[1];\n                ResultStore resultStore = (ResultStore) readCacheInputAsObject(pipelineContext, dataInput, new CacheableInputReader() {\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        read[0] = true;\n                        if (logger.isDebugEnabled())\n                            logger.debug(\"Output not cached\");\n                        try {\n                            ResultStoreOutputStream resultStoreOutputStream = new ResultStoreOutputStream(httpOutputStream);\n                            readInput(context, response, input, config, resultStoreOutputStream);\n                            resultStoreOutputStream.close();\n                            return resultStoreOutputStream;\n                        } catch (IOException e) {\n                            throw new OXFException(e);\n                        }\n                    }\n                });\n\n                // If the output was obtained from the cache, just write it\n                if (!read[0]) {\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Serializer output cached\");\n                    if (externalContext != null)\n                        response.setContentLength(resultStore.length(pipelineContext));\n                    resultStore.replay(pipelineContext);\n                }\n            } else {\n                // Local caching is not enabled\n\n                readInput(pipelineContext, response, dataInput, config, httpOutputStream);\n                httpOutputStream.close();\n            }\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":32878,"modified_method":"public void start(PipelineContext pipelineContext) {\n        try {\n            // Read configuration input\n            final Config config = readConfig(pipelineContext);\n\n            // Get data input information\n            ProcessorInput dataInput = getInputByName(INPUT_DATA);\n\n            ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n            final ExternalContext.Response response = externalContext.getResponse();\n\n            // Compute headers\n            if (externalContext != null) {\n\n                // Send an error if needed and return immediately\n                int errorCode = config.errorCode;\n                if (errorCode != DEFAULT_ERROR_CODE) {\n                    response.sendError(errorCode);\n                    return;\n                }\n\n                // Get last modification date and compute last modified if possible\n                Object validity = getInputValidity(pipelineContext, dataInput);\n                long lastModified = (validity != null) ? findLastModified(validity) : 0;\n\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Last modified: \" + lastModified);\n\n                // Set caching headers and force revalidation\n                response.setCaching(lastModified, true, true);\n\n                // Check If-Modified-Since (conditional GET) and don't return content if condition is met\n                if (!response.checkIfModifiedSince(lastModified, true)) {\n                    response.setStatus(ExternalContext.SC_NOT_MODIFIED);\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Sending SC_NOT_MODIFIED\");\n                    return;\n                }\n\n                // Set status code\n                response.setStatus(config.statusCode);\n\n                // Set custom headers\n                if (config.headers != null) {\n                    for(Iterator i = config.headers.iterator(); i.hasNext();){\n                        String name = (String) i.next();\n                        String value = (String) i.next();\n                        response.setHeader(name, value);\n                    }\n                }\n            }\n\n            // If we have an empty body, return w/o reading the data input\n            if (config.empty)\n                return;\n\n            final OutputStream httpOutputStream = response.getOutputStream();\n\n            if (config.cacheUseLocalCache) {\n                // If local caching of the data is enabled, use the caching API\n                // We return a ResultStore\n                final boolean[] read = new boolean[1];\n                ResultStore resultStore = (ResultStore) readCacheInputAsObject(pipelineContext, dataInput, new CacheableInputReader() {\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        read[0] = true;\n                        if (logger.isDebugEnabled())\n                            logger.debug(\"Output not cached\");\n                        try {\n                            ResultStoreOutputStream resultStoreOutputStream = new ResultStoreOutputStream(httpOutputStream);\n                            readInput(context, response, input, config, resultStoreOutputStream);\n                            resultStoreOutputStream.close();\n                            return resultStoreOutputStream;\n                        } catch (IOException e) {\n                            throw new OXFException(e);\n                        }\n                    }\n                });\n\n                // If the output was obtained from the cache, just write it\n                if (!read[0]) {\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Serializer output cached\");\n                    if (externalContext != null)  {\n                        String encoding = getEncoding(config, null, DEFAULT_ENCODING);\n                        String contentType = getContentType(config, null, getDefaultContentType());\n                        if (contentType != null)\n                            response.setContentType(contentType + \"; charset=\" + encoding);\n                        response.setContentLength(resultStore.length(pipelineContext));\n                    }\n                    resultStore.replay(pipelineContext);\n                }\n            } else {\n                // Local caching is not enabled\n\n                readInput(pipelineContext, response, dataInput, config, httpOutputStream);\n                httpOutputStream.close();\n            }\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"61f58ee108a447050254f0b8377e970b1f822322","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n\t * Write parts of the resource as indicated by the request {@code Range} header.\n\t * @param resource the identified resource (never {@code null})\n\t * @param outputMessage current servlet response\n\t * @throws IOException in case of errors while writing the content\n\t */\n\tprotected void writePartialContent(HttpRangeResource resource, HttpOutputMessage outputMessage) throws IOException {\n\n\t\tAssert.notNull(resource, \"Resource should not be null\");\n\n\t\tList<HttpRange> ranges = resource.getHttpRanges();\n\t\tHttpHeaders responseHeaders = outputMessage.getHeaders();\n\t\tMediaType contentType = responseHeaders.getContentType();\n\t\tLong length = getContentLength(resource, contentType);\n\n\t\tif (ranges.size() == 1) {\n\t\t\tHttpRange range = ranges.get(0);\n\n\t\t\tlong start = range.getRangeStart(length);\n\t\t\tlong end = range.getRangeEnd(length);\n\t\t\tlong rangeLength = end - start + 1;\n\n\t\t\tresponseHeaders.add(\"Content-Range\", \"bytes \" + start + \"-\" + end + \"/\" + length);\n\t\t\tresponseHeaders.setContentLength((int) rangeLength);\n\n\t\t\tInputStream in = resource.getInputStream();\n\t\t\ttry {\n\t\t\t\tcopyRange(in, outputMessage.getBody(), start, end);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString boundaryString = MimeTypeUtils.generateMultipartBoundaryString();\n\t\t\tresponseHeaders.set(HttpHeaders.CONTENT_TYPE, \"multipart/byteranges; boundary=\" + boundaryString);\n\n\t\t\tOutputStream out = outputMessage.getBody();\n\n\t\t\tfor (HttpRange range : ranges) {\n\t\t\t\tlong start = range.getRangeStart(length);\n\t\t\t\tlong end = range.getRangeEnd(length);\n\n\t\t\t\tInputStream in = resource.getInputStream();\n\n\t\t\t\t// Writing MIME header.\n\t\t\t\tprintln(out);\n\t\t\t\tprint(out, \"--\" + boundaryString);\n\t\t\t\tprintln(out);\n\t\t\t\tif (contentType != null) {\n\t\t\t\t\tprint(out, \"Content-Type: \" + contentType.toString());\n\t\t\t\t\tprintln(out);\n\t\t\t\t}\n\t\t\t\tprint(out, \"Content-Range: bytes \" + start + \"-\" + end + \"/\" + length);\n\t\t\t\tprintln(out);\n\t\t\t\tprintln(out);\n\n\t\t\t\t// Printing content\n\t\t\t\tcopyRange(in, out, start, end);\n\t\t\t}\n\t\t\tprintln(out);\n\t\t\tprint(out, \"--\" + boundaryString + \"--\");\n\t\t}\n\t}","id":32879,"modified_method":"/**\n\t * Write parts of the resource as indicated by the request {@code Range} header.\n\t * @param resource the identified resource (never {@code null})\n\t * @param outputMessage current servlet response\n\t * @throws IOException in case of errors while writing the content\n\t */\n\tprotected void writePartialContent(HttpRangeResource resource, HttpOutputMessage outputMessage) throws IOException {\n\t\tAssert.notNull(resource, \"Resource should not be null\");\n\t\tList<HttpRange> ranges = resource.getHttpRanges();\n\t\tHttpHeaders responseHeaders = outputMessage.getHeaders();\n\t\tMediaType contentType = responseHeaders.getContentType();\n\t\tLong length = getContentLength(resource, contentType);\n\n\t\tif (ranges.size() == 1) {\n\t\t\tHttpRange range = ranges.get(0);\n\t\t\tlong start = range.getRangeStart(length);\n\t\t\tlong end = range.getRangeEnd(length);\n\t\t\tlong rangeLength = end - start + 1;\n\t\t\tresponseHeaders.add(\"Content-Range\", \"bytes \" + start + \"-\" + end + \"/\" + length);\n\t\t\tresponseHeaders.setContentLength(rangeLength);\n\t\t\tInputStream in = resource.getInputStream();\n\t\t\ttry {\n\t\t\t\tcopyRange(in, outputMessage.getBody(), start, end);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString boundaryString = MimeTypeUtils.generateMultipartBoundaryString();\n\t\t\tresponseHeaders.set(HttpHeaders.CONTENT_TYPE, \"multipart/byteranges; boundary=\" + boundaryString);\n\t\t\tOutputStream out = outputMessage.getBody();\n\t\t\tfor (HttpRange range : ranges) {\n\t\t\t\tlong start = range.getRangeStart(length);\n\t\t\t\tlong end = range.getRangeEnd(length);\n\t\t\t\tInputStream in = resource.getInputStream();\n\t\t\t\t// Writing MIME header.\n\t\t\t\tprintln(out);\n\t\t\t\tprint(out, \"--\" + boundaryString);\n\t\t\t\tprintln(out);\n\t\t\t\tif (contentType != null) {\n\t\t\t\t\tprint(out, \"Content-Type: \" + contentType.toString());\n\t\t\t\t\tprintln(out);\n\t\t\t\t}\n\t\t\t\tprint(out, \"Content-Range: bytes \" + start + \"-\" + end + \"/\" + length);\n\t\t\t\tprintln(out);\n\t\t\t\tprintln(out);\n\t\t\t\t// Printing content\n\t\t\t\tcopyRange(in, out, start, end);\n\t\t\t}\n\t\t\tprintln(out);\n\t\t\tprint(out, \"--\" + boundaryString + \"--\");\n\t\t}\n\t}","commit_id":"37bd51cf6d1d1a41d287a66504539b28fc8e4584","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected Long getContentLength(Resource resource, MediaType contentType) throws IOException {\n\t\t// Don't try to determine contentLength on InputStreamResource - cannot be read afterwards...\n\t\t// Note: custom InputStreamResource subclasses could provide a pre-calculated content length!\n\t\tif (InputStreamResource.class == resource.getClass()) {\n\t\t\treturn null;\n\t\t}\n\t\tlong contentLength = resource.contentLength();\n\t\tif (contentLength > Integer.MAX_VALUE) {\n\t\t\tthrow new IOException(\"Resource content too long (beyond Integer.MAX_VALUE): \" + resource);\n\t\t}\n\t\treturn (contentLength < 0 ? null : contentLength);\n\t}","id":32880,"modified_method":"@Override\n\tprotected Long getContentLength(Resource resource, MediaType contentType) throws IOException {\n\t\t// Don't try to determine contentLength on InputStreamResource - cannot be read afterwards...\n\t\t// Note: custom InputStreamResource subclasses could provide a pre-calculated content length!\n\t\tif (InputStreamResource.class == resource.getClass()) {\n\t\t\treturn null;\n\t\t}\n\t\tlong contentLength = resource.contentLength();\n\t\treturn (contentLength < 0 ? null : contentLength);\n\t}","commit_id":"37bd51cf6d1d1a41d287a66504539b28fc8e4584","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set headers on the given servlet response.\n\t * Called for GET requests as well as HEAD requests.\n\t * @param response current servlet response\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t * @throws IOException in case of errors while setting the headers\n\t */\n\tprotected void setHeaders(HttpServletResponse response, Resource resource, MediaType mediaType) throws IOException {\n\t\tlong length = resource.contentLength();\n\t\tif (length > Integer.MAX_VALUE) {\n\t\t\tthrow new IOException(\"Resource content too long (beyond Integer.MAX_VALUE): \" + resource);\n\t\t}\n\t\tresponse.setContentLength((int) length);\n\t\tif (mediaType != null) {\n\t\t\tresponse.setContentType(mediaType.toString());\n\t\t}\n\t\tif (resource instanceof EncodedResource) {\n\t\t\tresponse.setHeader(HttpHeaders.CONTENT_ENCODING, ((EncodedResource) resource).getContentEncoding());\n\t\t}\n\t\tif (resource instanceof VersionedResource) {\n\t\t\tresponse.setHeader(HttpHeaders.ETAG, \"\\\"\" + ((VersionedResource) resource).getVersion() + \"\\\"\");\n\t\t}\n\t\tresponse.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t}","id":32881,"modified_method":"/**\n\t * Set headers on the given servlet response.\n\t * Called for GET requests as well as HEAD requests.\n\t * @param response current servlet response\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t * @throws IOException in case of errors while setting the headers\n\t */\n\tprotected void setHeaders(HttpServletResponse response, Resource resource, MediaType mediaType) throws IOException {\n\t\tlong length = resource.contentLength();\n\t\tif (length > Integer.MAX_VALUE) {\n\t\t\tif (contentLengthLongAvailable) {\n\t\t\t\tresponse.setContentLengthLong(length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.setHeader(HttpHeaders.CONTENT_LENGTH, Long.toString(length));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresponse.setContentLength((int) length);\n\t\t}\n\n\t\tif (mediaType != null) {\n\t\t\tresponse.setContentType(mediaType.toString());\n\t\t}\n\t\tif (resource instanceof EncodedResource) {\n\t\t\tresponse.setHeader(HttpHeaders.CONTENT_ENCODING, ((EncodedResource) resource).getContentEncoding());\n\t\t}\n\t\tif (resource instanceof VersionedResource) {\n\t\t\tresponse.setHeader(HttpHeaders.ETAG, \"\\\"\" + ((VersionedResource) resource).getVersion() + \"\\\"\");\n\t\t}\n\t\tresponse.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t}","commit_id":"37bd51cf6d1d1a41d287a66504539b28fc8e4584","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected static Pair<PsiType, ConstraintType> inferConstraint(PsiTypeParameter typeParameter,\n                                                                 PsiExpression innerMethodCall,\n                                                                 int parameterIdx,\n                                                                 PsiType innerReturnType,\n                                                                 JavaResolveResult result,\n                                                                 final PsiSubstitutor substitutor) {\n    final PsiElement element = result.getElement();\n    if (element instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)element;\n      final PsiParameter[] parameters = method.getParameterList().getParameters();\n      PsiParameter parameter = null;\n      if (parameters.length > parameterIdx) {\n        parameter = parameters[parameterIdx];\n      }\n      else if (method.isVarArgs()) {\n        parameter = parameters[parameters.length - 1];\n      }\n      if (parameter != null) {\n        final PsiParameter finalParameter = parameter;\n        PsiType type = PsiResolveHelper.ourGuard.doPreventingRecursion(innerMethodCall, true, new Computable<PsiType>() {\n          @Override\n          public PsiType compute() {\n            return substitutor.substitute(finalParameter.getType());\n          }\n        });\n        PsiResolveHelperImpl resolveHelper = (PsiResolveHelperImpl)JavaPsiFacade.getInstance(method.getProject()).getResolveHelper();\n        final Pair<PsiType, ConstraintType> constraint =\n          resolveHelper.getSubstitutionForTypeParameterConstraint(typeParameter, innerReturnType, type, false,\n                                                                         PsiUtil.getLanguageLevel(finalParameter));\n        if (constraint != null) return constraint;\n      }\n    }\n    return null;\n  }","id":32882,"modified_method":"protected static Pair<PsiType, ConstraintType> inferConstraint(PsiTypeParameter typeParameter,\n                                                                 PsiExpression innerMethodCall,\n                                                                 int parameterIdx,\n                                                                 PsiType innerReturnType,\n                                                                 JavaResolveResult result,\n                                                                 final PsiSubstitutor substitutor) {\n    final PsiElement element = result.getElement();\n    if (element instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)element;\n      final PsiParameter[] parameters = method.getParameterList().getParameters();\n      PsiParameter parameter = null;\n      if (parameters.length > parameterIdx) {\n        parameter = parameters[parameterIdx];\n      }\n      else if (method.isVarArgs()) {\n        parameter = parameters[parameters.length - 1];\n      }\n      if (parameter != null) {\n        final PsiParameter finalParameter = parameter;\n        PsiType type = PsiResolveHelper.ourGuard.doPreventingRecursion(innerMethodCall, true, new Computable<PsiType>() {\n          @Override\n          public PsiType compute() {\n            return substitutor.substitute(finalParameter.getType());\n          }\n        });\n        PsiResolveHelperImpl resolveHelper = (PsiResolveHelperImpl)JavaPsiFacade.getInstance(method.getProject()).getResolveHelper();\n        final LanguageLevel languageLevel = PsiUtil.getLanguageLevel(finalParameter);\n        final Pair<PsiType, ConstraintType> constraint =\n          ((PsiOldInferenceHelper)resolveHelper.getInferenceHelper(languageLevel)).getSubstitutionForTypeParameterConstraint(typeParameter, innerReturnType, type, false, languageLevel);\n        if (constraint != null) return constraint;\n      }\n    }\n    return null;\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiType getSubstitutionForTypeParameter(PsiTypeParameter typeParam,\n                                                 PsiType param,\n                                                 PsiType arg,\n                                                 boolean isContraVariantPosition,\n                                                 final LanguageLevel languageLevel) {\n    final Pair<PsiType, ConstraintType> constraint = getSubstitutionForTypeParameterConstraint(typeParam, param, arg, isContraVariantPosition,\n                                                                                               languageLevel);\n    return constraint == null ? PsiType.NULL : constraint.getFirst();\n  }","id":32883,"modified_method":"@Override\n  public PsiType getSubstitutionForTypeParameter(PsiTypeParameter typeParam,\n                                                 PsiType param,\n                                                 PsiType arg,\n                                                 boolean isContraVariantPosition, \n                                                 LanguageLevel languageLevel) {\n    return getInferenceHelper(languageLevel)\n      .getSubstitutionForTypeParameter(typeParam, param, arg, isContraVariantPosition, languageLevel);\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiType inferTypeForMethodTypeParameter(@NotNull final PsiTypeParameter typeParameter,\n                                                 @NotNull final PsiParameter[] parameters,\n                                                 @NotNull PsiExpression[] arguments,\n                                                 @NotNull PsiSubstitutor partialSubstitutor,\n                                                 PsiElement parent,\n                                                 @NotNull final ParameterTypeInferencePolicy policy) {\n\n    final Pair<PsiType, ConstraintType> constraint =\n      inferTypeForMethodTypeParameterInner(typeParameter, parameters, arguments, partialSubstitutor, parent, policy);\n    if (constraint == null) return PsiType.NULL;\n    return constraint.getFirst();\n  }","id":32884,"modified_method":"@Override\n  public PsiType inferTypeForMethodTypeParameter(@NotNull PsiTypeParameter typeParameter,\n                                                 @NotNull PsiParameter[] parameters,\n                                                 @NotNull PsiExpression[] arguments,\n                                                 @NotNull PsiSubstitutor partialSubstitutor,\n                                                 @Nullable PsiElement parent,\n                                                 @NotNull ParameterTypeInferencePolicy policy) {\n    return getInferenceHelper(PsiUtil.getLanguageLevel(parent != null ? parent : typeParameter))\n      .inferTypeForMethodTypeParameter(typeParameter, parameters, arguments, partialSubstitutor, parent, policy);\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public PsiSubstitutor inferTypeArguments(@NotNull PsiTypeParameter[] typeParameters,\n                                           @NotNull PsiParameter[] parameters,\n                                           @NotNull PsiExpression[] arguments,\n                                           @NotNull PsiSubstitutor partialSubstitutor,\n                                           @NotNull PsiElement parent,\n                                           @NotNull ParameterTypeInferencePolicy policy) {\n    return inferTypeArguments(typeParameters, parameters, arguments, partialSubstitutor, parent, policy, PsiUtil.getLanguageLevel(parent));\n  }","id":32885,"modified_method":"@Override\n  @NotNull\n  public PsiSubstitutor inferTypeArguments(@NotNull PsiTypeParameter[] typeParameters,\n                                           @NotNull PsiParameter[] parameters,\n                                           @NotNull PsiExpression[] arguments,\n                                           @NotNull PsiSubstitutor partialSubstitutor,\n                                           @NotNull PsiElement parent,\n                                           @NotNull ParameterTypeInferencePolicy policy) {\n    return getInferenceHelper(PsiUtil.getLanguageLevel(parent))\n      .inferTypeArguments(typeParameters, parameters, arguments, partialSubstitutor, parent, policy, PsiUtil.getLanguageLevel(parent));\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiSubstitutor inferTypeArguments(@NotNull PsiTypeParameter[] typeParameters,\n                                           @NotNull PsiParameter[] parameters,\n                                           @NotNull PsiExpression[] arguments,\n                                           @NotNull PsiSubstitutor partialSubstitutor,\n                                           @NotNull PsiElement parent,\n                                           @NotNull ParameterTypeInferencePolicy policy,\n                                           @NotNull LanguageLevel languageLevel) {\n    PsiType[] substitutions = new PsiType[typeParameters.length];\n    @SuppressWarnings(\"unchecked\")\n    Pair<PsiType, ConstraintType>[] constraints = new Pair[typeParameters.length];\n    for (int i = 0; i < typeParameters.length; i++) {\n      if (substitutions[i] != null) continue;\n      final Pair<PsiType, ConstraintType> constraint =\n        inferTypeForMethodTypeParameterInner(typeParameters[i], parameters, arguments, partialSubstitutor, null, policy);\n      constraints[i] = constraint;\n      if (constraint != null && constraint.getSecond() != ConstraintType.SUBTYPE) {\n        substitutions[i] = constraint.getFirst();\n\n        if (substitutions[i] != null && languageLevel.isAtLeast(LanguageLevel.JDK_1_8)) { //try once more\n          partialSubstitutor = partialSubstitutor.put(typeParameters[i], substitutions[i]);\n          i = -1;\n        }\n      }\n    }\n\n    for (int i = 0; i < typeParameters.length; i++) {\n      PsiTypeParameter typeParameter = typeParameters[i];\n      if (substitutions[i] == null) {\n        PsiType substitutionFromBounds = PsiType.NULL;\n        OtherParameters:\n        for (int j = 0; j < typeParameters.length; j++) {\n          if (i != j) {\n            PsiTypeParameter other = typeParameters[j];\n            final PsiType otherSubstitution = substitutions[j];\n            if (otherSubstitution == null) continue;\n            final PsiClassType[] bounds = other.getExtendsListTypes();\n            for (PsiClassType bound : bounds) {\n              final PsiType substitutedBound = partialSubstitutor.substitute(bound);\n              final Pair<PsiType, ConstraintType> currentConstraint =\n                getSubstitutionForTypeParameterConstraint(typeParameter, substitutedBound, otherSubstitution, true, languageLevel);\n              if (currentConstraint == null) continue;\n              final PsiType currentSubstitution = currentConstraint.getFirst();\n              final ConstraintType currentConstraintType = currentConstraint.getSecond();\n              if (currentConstraintType == ConstraintType.EQUALS) {\n                substitutionFromBounds = currentSubstitution;\n                if (currentSubstitution == null) {\n                  constraints[i] = FAILED_INFERENCE;\n                }\n                break OtherParameters;\n              }\n              else if (currentConstraintType == ConstraintType.SUPERTYPE) {\n                if (PsiType.NULL.equals(substitutionFromBounds)) {\n                  substitutionFromBounds = currentSubstitution;\n                }\n                else {\n                  substitutionFromBounds = GenericsUtil.getLeastUpperBound(substitutionFromBounds, currentSubstitution, myManager);\n                }\n              }\n            }\n\n          }\n        }\n\n        if (substitutionFromBounds != PsiType.NULL) substitutions[i] = substitutionFromBounds;\n      }\n    }\n\n    for (int i = 0; i < typeParameters.length; i++) {\n      PsiTypeParameter typeParameter = typeParameters[i];\n      PsiType substitution = substitutions[i];\n      if (substitution != PsiType.NULL) {\n        partialSubstitutor = partialSubstitutor.put(typeParameter, substitution);\n      }\n    }\n\n    try {\n      for (int i = 0; i < typeParameters.length; i++) {\n        PsiTypeParameter typeParameter = typeParameters[i];\n        PsiType substitution = substitutions[i];\n        if (substitution != null) continue;\n\n        Pair<PsiType, ConstraintType> constraint = constraints[i];\n        if (constraint == null) {\n          constraint = inferMethodTypeParameterFromParent(typeParameter, partialSubstitutor, parent, policy);\n        }\n        else if (constraint.getSecond() == ConstraintType.SUBTYPE) {\n          Pair<PsiType, ConstraintType> otherConstraint = inferMethodTypeParameterFromParent(typeParameter, partialSubstitutor, parent, policy);\n          if (otherConstraint != null) {\n            if (otherConstraint.getSecond() == ConstraintType.EQUALS || otherConstraint.getSecond() == ConstraintType.SUPERTYPE) {\n              constraint = otherConstraint;\n            }\n          }\n        }\n\n        if (constraint != null) {\n          substitution = constraint.getFirst();\n        }\n\n        if (substitution == null) {\n          PsiElementFactory factory = JavaPsiFacade.getInstance(myManager.getProject()).getElementFactory();\n          return factory.createRawSubstitutor(partialSubstitutor, typeParameters);\n        }\n        if (substitution != PsiType.NULL) {\n          partialSubstitutor = partialSubstitutor.put(typeParameter, substitution);\n        }\n      }\n    }\n    finally {\n      GraphInferencePolicy.forget(parent);\n    }\n    return partialSubstitutor;\n  }","id":32886,"modified_method":"@Override\n  @NotNull\n  public PsiSubstitutor inferTypeArguments(@NotNull PsiTypeParameter[] typeParameters,\n                                           @NotNull PsiParameter[] parameters,\n                                           @NotNull PsiExpression[] arguments,\n                                           @NotNull PsiSubstitutor partialSubstitutor,\n                                           @NotNull PsiElement parent,\n                                           @NotNull ParameterTypeInferencePolicy policy,\n                                           @NotNull LanguageLevel languageLevel) {\n    return getInferenceHelper(languageLevel)\n      .inferTypeArguments(typeParameters, parameters, arguments, partialSubstitutor, parent, policy, languageLevel);\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public PsiSubstitutor inferTypeArguments(@NotNull PsiTypeParameter[] typeParameters,\n                                           @NotNull PsiType[] leftTypes,\n                                           @NotNull PsiType[] rightTypes,\n                                           @NotNull LanguageLevel languageLevel) {\n    if (leftTypes.length != rightTypes.length) throw new IllegalArgumentException(\"Types must be of the same length\");\n    PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n    for (PsiTypeParameter typeParameter : typeParameters) {\n      PsiType substitution = PsiType.NULL;\n      PsiType lowerBound = PsiType.NULL;\n      for (int i1 = 0; i1 < leftTypes.length; i1++) {\n        PsiType leftType = leftTypes[i1];\n        PsiType rightType = rightTypes[i1];\n        final Pair<PsiType, ConstraintType> constraint =\n            getSubstitutionForTypeParameterConstraint(typeParameter, leftType, rightType, true, languageLevel);\n        if (constraint != null) {\n          final ConstraintType constraintType = constraint.getSecond();\n          final PsiType current = constraint.getFirst();\n          if (constraintType == ConstraintType.EQUALS) {\n            substitution = current;\n            break;\n          }\n          else if (constraintType == ConstraintType.SUBTYPE) {\n            if (PsiType.NULL.equals(substitution)) {\n              substitution = current;\n            }\n            else {\n              substitution = GenericsUtil.getLeastUpperBound(substitution, current, myManager);\n            }\n          }\n          else {\n            if (PsiType.NULL.equals(lowerBound)) {\n              lowerBound = current;\n            }\n            else {\n              lowerBound = GenericsUtil.getLeastUpperBound(lowerBound, current, myManager);\n            }\n          }\n        }\n      }\n\n      if (PsiType.NULL.equals(substitution)) {\n        substitution = lowerBound;\n      }\n\n      if (substitution != PsiType.NULL) {\n        substitutor = substitutor.put(typeParameter, substitution);\n      }\n    }\n    for (int i = 0; i < typeParameters.length; i++) {\n      PsiTypeParameter typeParameter = typeParameters[i];\n      if (!substitutor.getSubstitutionMap().containsKey(typeParameter)) {\n        PsiType substitutionFromBounds = PsiType.NULL;\n        OtherParameters:\n        for (int j = 0; j < typeParameters.length; j++) {\n          if (i != j) {\n            PsiTypeParameter other = typeParameters[j];\n            final PsiType otherSubstitution = substitutor.substitute(other);\n            if (otherSubstitution == null) continue;\n            final PsiClassType[] bounds = other.getExtendsListTypes();\n            for (PsiClassType bound : bounds) {\n              final PsiType substitutedBound = substitutor.substitute(bound);\n              final Pair<PsiType, ConstraintType> currentConstraint =\n                getSubstitutionForTypeParameterConstraint(typeParameter, substitutedBound, otherSubstitution, true, languageLevel);\n              if (currentConstraint == null) continue;\n              final PsiType currentSubstitution = currentConstraint.getFirst();\n              final ConstraintType currentConstraintType = currentConstraint.getSecond();\n              if (currentConstraintType == ConstraintType.EQUALS) {\n                substitutionFromBounds = currentSubstitution;\n                break OtherParameters;\n              }\n              else if (currentConstraintType == ConstraintType.SUPERTYPE) {\n                if (PsiType.NULL.equals(substitutionFromBounds)) {\n                  substitutionFromBounds = currentSubstitution;\n                }\n                else {\n                  substitutionFromBounds = GenericsUtil.getLeastUpperBound(substitutionFromBounds, currentSubstitution, myManager);\n                }\n              }\n            }\n          }\n        }\n        if (substitutionFromBounds != PsiType.NULL) {\n          substitutor = substitutor.put(typeParameter, substitutionFromBounds);\n        }\n      }\n    }\n    return substitutor;\n  }","id":32887,"modified_method":"@Override\n  @NotNull\n  public PsiSubstitutor inferTypeArguments(@NotNull PsiTypeParameter[] typeParameters,\n                                           @NotNull PsiType[] leftTypes,\n                                           @NotNull PsiType[] rightTypes,\n                                           @NotNull LanguageLevel languageLevel) {\n    return getInferenceHelper(languageLevel)\n      .inferTypeArguments(typeParameters, leftTypes, rightTypes, languageLevel);\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static InferenceGraphNode<Integer>[] initNodes() {\n    InferenceGraphNode<Integer>[] nodes = new InferenceGraphNode[9];\n    for (int i = 0; i < nodes.length; i++) {\n      nodes[i] = new InferenceGraphNode<Integer>(i + 1);\n    }\n\n    nodes[0].getDependencies().add(nodes[1]);\n\n    nodes[1].getDependencies().add(nodes[0]);\n    nodes[1].getDependencies().add(nodes[4]);\n\n    nodes[2].getDependencies().add(nodes[3]);\n\n    nodes[3].getDependencies().add(nodes[2]);\n    nodes[3].getDependencies().add(nodes[4]);\n\n    nodes[4].getDependencies().add(nodes[5]);\n\n    nodes[5].getDependencies().add(nodes[6]);\n\n    nodes[6].getDependencies().add(nodes[7]);\n\n    nodes[7].getDependencies().add(nodes[5]);\n    nodes[7].getDependencies().add(nodes[8]);\n    return nodes;\n  }","id":32888,"modified_method":"private static InferenceVariablesOrder.InferenceGraphNode<Integer>[] initNodes() {\n    InferenceVariablesOrder.InferenceGraphNode<Integer>[] nodes = new InferenceVariablesOrder.InferenceGraphNode[9];\n    for (int i = 0; i < nodes.length; i++) {\n      nodes[i] = new InferenceVariablesOrder.InferenceGraphNode<Integer>(i + 1);\n    }\n\n    nodes[0].getDependencies().add(nodes[1]);\n\n    nodes[1].getDependencies().add(nodes[0]);\n    nodes[1].getDependencies().add(nodes[4]);\n\n    nodes[2].getDependencies().add(nodes[3]);\n\n    nodes[3].getDependencies().add(nodes[2]);\n    nodes[3].getDependencies().add(nodes[4]);\n\n    nodes[4].getDependencies().add(nodes[5]);\n\n    nodes[5].getDependencies().add(nodes[6]);\n\n    nodes[6].getDependencies().add(nodes[7]);\n\n    nodes[7].getDependencies().add(nodes[5]);\n    nodes[7].getDependencies().add(nodes[8]);\n    return nodes;\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testResultGraph() throws Exception {\n    \n\n    final List<List<InferenceGraphNode<Integer>>> tarjan = InferenceGraphNode.tarjan(Arrays.asList(initNodes()));\n    final String messages = StringUtil.join(tarjan, new Function<List<InferenceGraphNode<Integer>>, String>() {\n      @Override\n      public String fun(List<InferenceGraphNode<Integer>> nodes) {\n        return StringUtil.join(nodes, new Function<InferenceGraphNode<Integer>, String>() {\n          @Override\n          public String fun(InferenceGraphNode<Integer> node) {\n            return String.valueOf(node.getValue());\n          }\n        }, \",\");\n      }\n    }, \"\\n\");\n\n    Assert.assertEquals(\"[9]\\n\" +\n                        \"[8],[7],[6]\\n\" +\n                        \"[5]\\n\" +\n                        \"[2],[1]\\n\" +\n                        \"[4],[3]\", messages);\n\n    final ArrayList<InferenceGraphNode<Integer>> acyclicNodes = InferenceGraphNode.initNodes(Arrays.asList(initNodes()));\n    final String aMessages = StringUtil.join(acyclicNodes, new Function<InferenceGraphNode<Integer>, String>() {\n      @Override\n      public String fun(InferenceGraphNode<Integer> node) {\n        return String.valueOf(node.getValue());\n      }\n    }, \",\");\n\n\n    Assert.assertEquals(\"[9],[8, 7, 6],[5],[2, 1],[4, 3]\", aMessages);\n  }","id":32889,"modified_method":"public void testResultGraph() throws Exception {\n    \n\n    final List<List<InferenceVariablesOrder.InferenceGraphNode<Integer>>> tarjan = InferenceVariablesOrder.tarjan(Arrays.asList(initNodes()));\n    final String messages = StringUtil.join(tarjan, new Function<List<InferenceVariablesOrder.InferenceGraphNode<Integer>>, String>() {\n      @Override\n      public String fun(List<InferenceVariablesOrder.InferenceGraphNode<Integer>> nodes) {\n        return StringUtil.join(nodes, new Function<InferenceVariablesOrder.InferenceGraphNode<Integer>, String>() {\n          @Override\n          public String fun(InferenceVariablesOrder.InferenceGraphNode<Integer> node) {\n            return String.valueOf(node.getValue());\n          }\n        }, \",\");\n      }\n    }, \"\\n\");\n\n    Assert.assertEquals(\"[9]\\n\" +\n                        \"[8],[7],[6]\\n\" +\n                        \"[5]\\n\" +\n                        \"[2],[1]\\n\" +\n                        \"[4],[3]\", messages);\n\n    final ArrayList<InferenceVariablesOrder.InferenceGraphNode<Integer>> acyclicNodes = InferenceVariablesOrder.initNodes(Arrays.asList(initNodes()));\n    final String aMessages = StringUtil.join(acyclicNodes, new Function<InferenceVariablesOrder.InferenceGraphNode<Integer>, String>() {\n      @Override\n      public String fun(InferenceVariablesOrder.InferenceGraphNode<Integer> node) {\n        return String.valueOf(node.getValue());\n      }\n    }, \",\");\n\n\n    Assert.assertEquals(\"[9],[8, 7, 6],[5],[2, 1],[4, 3]\", aMessages);\n  }","commit_id":"b816d2770e8737bfd541e82b74760cbfb250c126","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Pair<PsiType, ConstraintType> inferMethodTypeParameterFromParent(PsiElement parent,\n                                                     PsiMethodCallExpression methodCall,\n                                                     final PsiTypeParameter typeParameter,\n                                                     PsiSubstitutor substitutor,\n                                                     final boolean forCompletion) {\n    PsiType expectedType = null;\n\n    if (parent instanceof PsiVariable && methodCall.equals(((PsiVariable)parent).getInitializer())) {\n      expectedType = ((PsiVariable)parent).getType();\n    }\n    else if (parent instanceof PsiAssignmentExpression && methodCall.equals(((PsiAssignmentExpression)parent).getRExpression())) {\n      expectedType = ((PsiAssignmentExpression)parent).getLExpression().getType();\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiMethod method = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (method != null) {\n        expectedType = method.getReturnType();\n      }\n    }\n    else if (parent instanceof PsiExpressionList && forCompletion) {\n      final PsiElement pParent = parent.getParent();\n      if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {\n        final Pair<PsiType, ConstraintType> constraint =\n          inferTypeForCompletionFromCallContext(methodCall, (PsiExpressionList)parent, (PsiCallExpression)pParent, typeParameter);\n        if (constraint != null) return constraint;\n      }\n    }\n\n    final PsiManager manager = typeParameter.getManager();\n    final GlobalSearchScope scope = parent.getResolveScope();\n    if (expectedType == null) {\n      expectedType = forCompletion ?\n             PsiType.NULL :\n             PsiType.getJavaLangObject(manager, scope);\n    }\n\n    PsiType returnType = ((PsiMethod)typeParameter.getOwner()).getReturnType();\n    final Pair<PsiType, ConstraintType> constraint =\n      getSubstitutionForTypeParameterConstraint(typeParameter, returnType, expectedType, false, PsiUtil.getLanguageLevel(parent));\n\n    final Pair<PsiType, ConstraintType> result;\n    if (constraint == null) {\n      final PsiSubstitutor finalSubstitutor = substitutor.put(typeParameter, null);\n      PsiType superType = finalSubstitutor.substitute(typeParameter.getSuperTypes()[0]);\n      if (superType == null) superType = PsiType.getJavaLangObject(manager, scope);\n      if (forCompletion && superType != null && !(superType instanceof PsiWildcardType)) {\n        result = new Pair<PsiType, ConstraintType>(PsiWildcardType.createExtends(manager, superType), ConstraintType.EQUALS);\n      }\n      else {\n        result = new Pair<PsiType, ConstraintType>(superType, ConstraintType.SUBTYPE);\n      }\n    }\n    else {\n      PsiType guess = constraint.getFirst();\n      if (guess == null) guess = TypeConversionUtil.typeParameterErasure(typeParameter);\n      if (forCompletion && guess != null && !(guess instanceof PsiWildcardType)) guess = PsiWildcardType.createExtends(manager, guess);\n\n      //The following code is the result of deep thought, do not shit it out before discussing with [ven]\n      if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {\n        PsiClassType[] extendsTypes = typeParameter.getExtendsListTypes();\n        PsiSubstitutor newSubstitutor = substitutor.put(typeParameter, guess);\n        for (PsiClassType extendsType1 : extendsTypes) {\n          PsiType extendsType = newSubstitutor.substitute(extendsType1);\n          if (!extendsType.isAssignableFrom(guess)) {\n            if (guess.isAssignableFrom(extendsType)) {\n              guess = extendsType;\n              newSubstitutor = substitutor.put(typeParameter, guess);\n            }\n            else {\n              break;\n            }\n          }\n        }\n      }\n\n      result = new Pair<PsiType, ConstraintType>(guess, constraint.getSecond());\n    }\n    return result;\n  }","id":32890,"modified_method":"private Pair<PsiType, ConstraintType> inferMethodTypeParameterFromParent(PsiElement parent,\n                                                     PsiMethodCallExpression methodCall,\n                                                     final PsiTypeParameter typeParameter,\n                                                     PsiSubstitutor substitutor,\n                                                     final boolean forCompletion) {\n    Pair<PsiType, ConstraintType> constraint = null;\n    PsiType expectedType = null;\n\n    if (parent instanceof PsiVariable && methodCall.equals(((PsiVariable)parent).getInitializer())) {\n      expectedType = ((PsiVariable)parent).getType();\n    }\n    else if (parent instanceof PsiAssignmentExpression && methodCall.equals(((PsiAssignmentExpression)parent).getRExpression())) {\n      expectedType = ((PsiAssignmentExpression)parent).getLExpression().getType();\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiMethod method = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (method != null) {\n        expectedType = method.getReturnType();\n      }\n    }\n    else if (parent instanceof PsiExpressionList && forCompletion) {\n      final PsiElement pParent = parent.getParent();\n      if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {\n        constraint = inferTypeForCompletionFromCallContext(methodCall, (PsiExpressionList)parent, (PsiCallExpression)pParent, typeParameter);\n      }\n    }\n\n    final Pair<PsiType, ConstraintType> result;\n    final PsiManager manager = typeParameter.getManager();\n    final GlobalSearchScope scope = parent.getResolveScope();\n    PsiType returnType = null;\n    if (constraint == null) {\n      if (expectedType == null) {\n        expectedType = forCompletion ?\n               PsiType.NULL :\n               PsiType.getJavaLangObject(manager, scope);\n      }\n\n      returnType = ((PsiMethod)typeParameter.getOwner()).getReturnType();\n\n      constraint = getSubstitutionForTypeParameterConstraint(typeParameter, returnType, expectedType, false, PsiUtil.getLanguageLevel(parent));\n    }\n\n    if (constraint == null) {\n      final PsiSubstitutor finalSubstitutor = substitutor.put(typeParameter, null);\n      PsiType superType = finalSubstitutor.substitute(typeParameter.getSuperTypes()[0]);\n      if (superType == null) superType = PsiType.getJavaLangObject(manager, scope);\n      if (forCompletion && !(superType instanceof PsiWildcardType)) {\n        result = new Pair<PsiType, ConstraintType>(PsiWildcardType.createExtends(manager, superType), ConstraintType.EQUALS);\n      }\n      else {\n        result = new Pair<PsiType, ConstraintType>(superType, ConstraintType.SUBTYPE);\n      }\n    }\n    else {\n      PsiType guess = constraint.getFirst();\n      if (forCompletion && !(guess instanceof PsiWildcardType)) {\n        if (constraint.getSecond() == ConstraintType.SUPERTYPE) guess = PsiWildcardType.createExtends(manager, guess);\n        else if (constraint.getSecond() == ConstraintType.SUBTYPE) guess = PsiWildcardType.createSuper(manager, guess);\n      }\n\n      //The following code is the result of deep thought, do not shit it out before discussing with [ven]\n      if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {\n        PsiClassType[] extendsTypes = typeParameter.getExtendsListTypes();\n        PsiSubstitutor newSubstitutor = substitutor.put(typeParameter, guess);\n        for (PsiClassType extendsType1 : extendsTypes) {\n          PsiType extendsType = newSubstitutor.substitute(extendsType1);\n          if (!extendsType.isAssignableFrom(guess)) {\n            if (guess.isAssignableFrom(extendsType)) {\n              guess = extendsType;\n              newSubstitutor = substitutor.put(typeParameter, guess);\n            }\n            else {\n              break;\n            }\n          }\n        }\n      }\n\n      result = new Pair<PsiType, ConstraintType>(guess, constraint.getSecond());\n    }\n    return result;\n  }","commit_id":"a4c345d0211b57fa431ac2b94639f307e701e742","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processMousePressed(final MouseEvent e){\n    RadComponent component = null;\n    final RadComponent draggerHost = FormEditingUtil.getDraggerHost(myEditor);\n    // Try to understand whether we pressed inside dragger area\n    if(draggerHost != null){\n      final JComponent delegee = draggerHost.getDelegee();\n      final Point p = SwingUtilities.convertPoint(delegee, 0, 0, e.getComponent());\n      if(\n        p.x - MainProcessor.DRAGGER_SIZE <= e.getX() && e.getX() <= p.x &&\n        p.y - MainProcessor.DRAGGER_SIZE <= e.getY() && e.getY() <= p.y\n      ){\n        component = draggerHost;\n      }\n    }\n\n    // If user clicked not inside dragger then we have find RadComponent at the click point\n    if(component == null){\n      component = FormEditingUtil.getRadComponentAt(myEditor, e.getX(), e.getY());\n    }\n\n    if (component == null) {\n      return;\n    }\n\n    /*\n    if (!myEditor.ensureEditable()) {\n      return;\n    }\n    */\n\n    final ComponentItem selectedItem = myEditor.getPalettePanel().getActiveItem();\n    if (selectedItem != null) {\n      myCurrentProcessor = new InsertComponentProcessor(myEditor, myEditor.getPalettePanel(), e.isControlDown());\n      return;\n    }\n\n    if (e.isControlDown()) {\n      component.setSelected(!(component.isSelected()));\n    }\n    else if (e.isShiftDown()) {\n      // Do not select component is shift is pressed\n    }\n    else {\n      if (!component.isSelected()) {\n        FormEditingUtil.clearSelection(myEditor.getRootContainer());\n        component.setSelected(true);\n      }\n    }\n\n    if(myCurrentProcessor != null){\n      // Sun sometimes skips mouse released events...\n      myCurrentProcessor.cancelOperation();\n      myCurrentProcessor = null;\n    }\n\n    final Point point = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), component.getDelegee());\n    final int resizeMask = Painter.getResizeMask(component, point.x, point.y);\n\n    if (resizeMask != 0) {\n      if (component.getParent().isXY()) {\n        myCurrentProcessor = new ResizeProcessor(myEditor, component, resizeMask);\n      }\n    }\n    else if (component instanceof RadRootContainer || ((component instanceof RadContainer) && e.isShiftDown())) {\n      myCurrentProcessor = new GroupSelectionProcessor(myEditor, (RadContainer)component);\n    }\n    else if (!e.isShiftDown()) {\n      myCurrentProcessor = new DragSelectionProcessor(myEditor);\n    }\n\n    updateDragger(e);\n  }","id":32891,"modified_method":"private void processMousePressed(final MouseEvent e){\n    RadComponent component = null;\n    final RadComponent draggerHost = FormEditingUtil.getDraggerHost(myEditor);\n    // Try to understand whether we pressed inside dragger area\n    if(draggerHost != null){\n      final JComponent delegee = draggerHost.getDelegee();\n      final Point p = SwingUtilities.convertPoint(delegee, 0, 0, e.getComponent());\n      if(\n        p.x - MainProcessor.DRAGGER_SIZE <= e.getX() && e.getX() <= p.x &&\n        p.y - MainProcessor.DRAGGER_SIZE <= e.getY() && e.getY() <= p.y\n      ){\n        component = draggerHost;\n      }\n    }\n\n    // If user clicked not inside dragger then we have find RadComponent at the click point\n    if(component == null){\n      component = FormEditingUtil.getRadComponentAt(myEditor, e.getX(), e.getY());\n    }\n\n    if (component == null) {\n      return;\n    }\n\n    /*\n    if (!myEditor.ensureEditable()) {\n      return;\n    }\n    */\n\n    final ComponentItem selectedItem = myEditor.getPalettePanel().getActiveItem();\n    if (selectedItem != null) {\n      myCurrentProcessor = new InsertComponentProcessor(myEditor, myEditor.getPalettePanel(),\n                                                        e.isControlDown() || e.isShiftDown());\n      return;\n    }\n\n    if (e.isControlDown()) {\n      component.setSelected(!(component.isSelected()));\n    }\n    else if (e.isShiftDown()) {\n      // Do not select component is shift is pressed\n    }\n    else {\n      if (!component.isSelected()) {\n        FormEditingUtil.clearSelection(myEditor.getRootContainer());\n        component.setSelected(true);\n      }\n    }\n\n    if(myCurrentProcessor != null){\n      // Sun sometimes skips mouse released events...\n      myCurrentProcessor.cancelOperation();\n      myCurrentProcessor = null;\n    }\n\n    final Point point = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), component.getDelegee());\n    final int resizeMask = Painter.getResizeMask(component, point.x, point.y);\n\n    if (resizeMask != 0) {\n      if (component.getParent().isXY()) {\n        myCurrentProcessor = new ResizeProcessor(myEditor, component, resizeMask);\n      }\n    }\n    else if (component instanceof RadRootContainer || ((component instanceof RadContainer) && e.isShiftDown())) {\n      myCurrentProcessor = new GroupSelectionProcessor(myEditor, (RadContainer)component);\n    }\n    else if (!e.isShiftDown()) {\n      myCurrentProcessor = new DragSelectionProcessor(myEditor);\n    }\n\n    updateDragger(e);\n  }","commit_id":"340e7b9b79da5cd660635ba5080b2f86cb5cfb42","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * from IKeyboardHandler\n   */\n  public boolean processKeyPressed(EditorContext editorContext, KeyEvent keyEvent) {\n    if (myNodeSubstituteChooser.isVisible()) {\n      if (myNodeSubstituteChooser.processKeyPressed(keyEvent)) {\n        keyEvent.consume();\n        return true;\n      }\n    }\n\n    String actionType = getActionType(keyEvent, editorContext);\n\n    // pre-process action\n    if (mySelectedCell != null &&\n            actionType == EditorCellAction.RIGHT_TRANSFORM) {\n      if (!isValidCell(mySelectedCell) &&\n              !validateCell(mySelectedCell)) {  // !side effect: can change selection!\n        keyEvent.consume();\n        return true;\n      }\n\n      // todo: hardcoded condition\n      if (mySelectedCell != null && getCellAction(mySelectedCell, EditorCellAction.RIGHT_TRANSFORM) == null) {\n        if (mySelectedCell instanceof EditorCell_Constant) {\n          actionType = EditorCellAction.RIGHT_SPECIAL;\n          keyEvent.consume();\n        }\n        if (mySelectedCell instanceof EditorCell_Property) {\n          String text = ((EditorCell_Property) mySelectedCell).getText();\n          if (!((EditorCell_Property) mySelectedCell).getModelAccessor().isValidText(text + \" \")) {\n            actionType = EditorCellAction.RIGHT_SPECIAL;\n            keyEvent.consume();\n          }\n        }\n      }\n    }\n\n    // process action\n    if (mySelectedCell != null) {\n\n      if (actionType != null) {\n        if (executeCellAction(mySelectedCell, actionType)) {\n          keyEvent.consume();\n          return true;\n        }\n      }\n\n      if (!keyEvent.isConsumed()) {\n\n        EditorCell oldSelection = mySelectedCell;\n        if (mySelectedCell.processKeyPressed(keyEvent) == true) {\n          if (oldSelection != mySelectedCell) {\n            mySelectedStack.removeAllElements();\n          }\n          keyEvent.consume();\n          return true;\n        }\n\n        // auto-completion (AKA node substitution)\n        if ((keyEvent.getKeyCode() == KeyEvent.VK_SPACE && keyEvent.isControlDown()) ||\n                (keyEvent.getKeyCode() == KeyEvent.VK_ENTER && !keyEvent.isControlDown())) {\n          if (activateNodeSubstituteChooser(mySelectedCell, keyEvent.getKeyCode() == KeyEvent.VK_ENTER)) {\n            keyEvent.consume();\n            System.out.println(\"SUBSTITUTE\");\n            return true;\n          }\n          System.out.println(\"NO SUBSTITUTE\");\n        }\n\n      } // if (!keyEvent.isConsumed())\n    } // if (mySelectedCell != null)\n\n    if (actionType != null) {\n      if (executeGlobalAction(actionType)) {\n        keyEvent.consume();\n        return true;\n      }\n    }\n\n    // special case - don't allow kbd focus to leave editor area\n    if (keyEvent.getKeyCode() == KeyEvent.VK_UP && keyEvent.isControlDown()) {\n      keyEvent.consume();\n    }\n\n    return false;\n  }","id":32892,"modified_method":"/**\n   * from IKeyboardHandler\n   */\n  public boolean processKeyPressed(EditorContext editorContext, KeyEvent keyEvent) {\n    if (myNodeSubstituteChooser.isVisible()) {\n      if (myNodeSubstituteChooser.processKeyPressed(keyEvent)) {\n        keyEvent.consume();\n        return true;\n      }\n    }\n\n    String actionType = getActionType(keyEvent, editorContext);\n\n    // pre-process action\n\n    if (mySelectedCell != null) {\n      boolean endEditKeystroke = (keyEvent.getKeyCode() == KeyEvent.VK_ENTER && !(keyEvent.isControlDown() || keyEvent.isAltDown() || keyEvent.isShiftDown()));\n      boolean deleteKeystroke = (keyEvent.getKeyCode() == KeyEvent.VK_DELETE && !(keyEvent.isControlDown() || keyEvent.isAltDown() || keyEvent.isShiftDown()));\n\n      if (actionType == EditorCellAction.RIGHT_TRANSFORM || endEditKeystroke) {\n        if (!isValidCell(mySelectedCell) &&\n                !validateCell(mySelectedCell)) {  // !side effect: can change selection!\n          keyEvent.consume();\n          return true;\n        }\n      }\n\n      // may be change actionType to be processed\n      if (mySelectedCell != null) {\n        // todo: too mach hardcoded conditions\n        if (endEditKeystroke) {\n          actionType = EditorCellAction.NEXT;\n          keyEvent.consume();\n\n        } else if (deleteKeystroke) {\n          if (!(mySelectedCell instanceof EditorCell_Label &&\n                  ((EditorCell_Label) mySelectedCell).isEditable())) {\n            actionType = EditorCellAction.DELETE;\n            keyEvent.consume();\n          }\n\n        } else if (actionType == EditorCellAction.RIGHT_TRANSFORM &&\n                getCellAction(mySelectedCell, actionType) == null) {\n          if (mySelectedCell instanceof EditorCell_Constant) {\n            actionType = EditorCellAction.RIGHT_SPECIAL;\n            keyEvent.consume();\n          }\n          if (mySelectedCell instanceof EditorCell_Property) {\n            String text = ((EditorCell_Property) mySelectedCell).getText();\n            if (!((EditorCell_Property) mySelectedCell).getModelAccessor().isValidText(text + \" \")) {\n              actionType = EditorCellAction.RIGHT_SPECIAL;\n              keyEvent.consume();\n            }\n          }\n        }\n      }\n    }\n\n    // process action\n\n    if (mySelectedCell != null) {\n\n      if (actionType != null) {\n        if (executeCellAction(mySelectedCell, actionType)) {\n          keyEvent.consume();\n          return true;\n        }\n      }\n\n      if (!keyEvent.isConsumed()) {\n\n        EditorCell oldSelection = mySelectedCell;\n        if (mySelectedCell.processKeyPressed(keyEvent) == true) {\n          if (oldSelection != mySelectedCell) {\n            mySelectedStack.removeAllElements();\n          }\n          keyEvent.consume();\n          return true;\n        }\n\n        // auto-completion (AKA node substitution)\n        if ((keyEvent.getKeyCode() == KeyEvent.VK_SPACE && keyEvent.isControlDown() && !(keyEvent.isAltDown() || keyEvent.isShiftDown())) ||\n                (keyEvent.getKeyCode() == KeyEvent.VK_ENTER && keyEvent.isAltDown() && !(keyEvent.isControlDown() || keyEvent.isShiftDown()))) {\n          if (activateNodeSubstituteChooser(mySelectedCell, keyEvent.getKeyCode() == KeyEvent.VK_ENTER)) {\n            keyEvent.consume();\n            System.out.println(\"SUBSTITUTE\");\n            return true;\n          }\n          System.out.println(\"NO SUBSTITUTE\");\n        }\n\n      } // if (!keyEvent.isConsumed())\n    } // if (mySelectedCell != null)\n\n    if (actionType != null) {\n      if (executeGlobalAction(actionType)) {\n        keyEvent.consume();\n        return true;\n      }\n    }\n\n    // special case - don't allow kbd focus to leave editor area\n    if (keyEvent.getKeyCode() == KeyEvent.VK_UP && keyEvent.isControlDown()) {\n      keyEvent.consume();\n    }\n\n    return false;\n  }","commit_id":"11cb8ef5a0bec94ce35f40df1bdbbf318bd73be4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getActionType(KeyEvent keyEvent, EditorContext editorContext) {\n    if (keyEvent.getKeyCode() == KeyEvent.VK_LEFT && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.LEFT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_RIGHT && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.RIGHT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_UP && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.UP;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_DOWN && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.DOWN;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_INSERT && keyEvent.isControlDown() && keyEvent.isShiftDown()) {\n      return EditorCellAction.INSERT_BEFORE;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_INSERT && keyEvent.isControlDown()) {\n      return EditorCellAction.INSERT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_LEFT && keyEvent.isControlDown()) {\n      return EditorCellAction.LEFT_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_RIGHT && keyEvent.isControlDown()) {\n      return EditorCellAction.RIGHT_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_UP && keyEvent.isControlDown()) {\n      return EditorCellAction.UP_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_DOWN && keyEvent.isControlDown()) {\n      return EditorCellAction.DOWN_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_TAB && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.NEXT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_TAB && keyEvent.isShiftDown()) {\n      return EditorCellAction.PREV;\n    }\n\n    // ---\n    if (keyEvent.getKeyCode() == KeyEvent.VK_SPACE && keyEvent.getModifiers() == 0) {\n      EditorCell selectedCell = editorContext.getNodeEditorComponent().getSelectedCell();\n      if (!(selectedCell instanceof EditorCell_Label)) {\n        return EditorCellAction.RIGHT_TRANSFORM;\n      }\n      EditorCell_Label labelCell = (EditorCell_Label) selectedCell;\n      if (!labelCell.isEditable()) {\n        return EditorCellAction.RIGHT_TRANSFORM;\n      }\n\n      // caret at the end of text ?\n      String text = labelCell.getText();\n      int caretPosition = labelCell.getTextLine().getCaretPosition();\n      System.out.println(\"text:\" + text + \" len:\" + text.length() + \"caret at:\" + caretPosition);\n      if (caretPosition == text.length()) {\n        return EditorCellAction.RIGHT_TRANSFORM;\n      }\n    }\n\n\n    if (keyEvent.getKeyCode() == KeyEvent.VK_DELETE && keyEvent.isControlDown()) {\n      return EditorCellAction.DELETE;\n    }\n\n    // ---\n    if (keyEvent.getKeyCode() == KeyEvent.VK_C && keyEvent.isControlDown()) {\n      return EditorCellAction.COPY;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_V && keyEvent.isControlDown()) {\n      if (keyEvent.isShiftDown() && !keyEvent.isAltDown()) {\n        return EditorCellAction.PASTE_BEFORE;\n      } else if (!keyEvent.isShiftDown() && keyEvent.isAltDown()) {\n        return EditorCellAction.PASTE_AFTER;\n      }\n      return EditorCellAction.PASTE;\n    }\n\n    return null;\n  }","id":32893,"modified_method":"public String getActionType(KeyEvent keyEvent, EditorContext editorContext) {\n    if (keyEvent.getKeyCode() == KeyEvent.VK_LEFT && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.LEFT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_RIGHT && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.RIGHT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_UP && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.UP;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_DOWN && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.DOWN;\n    }\n//    if (keyEvent.getKeyCode() == KeyEvent.VK_INSERT && keyEvent.isControlDown() && keyEvent.isShiftDown()) {\n    if (keyEvent.getKeyCode() == KeyEvent.VK_INSERT && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.INSERT_BEFORE;\n    }\n//    if (keyEvent.getKeyCode() == KeyEvent.VK_INSERT && keyEvent.isControlDown()) {\n    if (keyEvent.getKeyCode() == KeyEvent.VK_ENTER && keyEvent.isControlDown() && !(keyEvent.isShiftDown() || keyEvent.isAltDown())) {\n      return EditorCellAction.INSERT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_LEFT && keyEvent.isControlDown()) {\n      return EditorCellAction.LEFT_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_RIGHT && keyEvent.isControlDown()) {\n      return EditorCellAction.RIGHT_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_UP && keyEvent.isControlDown()) {\n      return EditorCellAction.UP_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_DOWN && keyEvent.isControlDown()) {\n      return EditorCellAction.DOWN_SPECIAL;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_TAB && keyEvent.getModifiers() == 0) {\n      return EditorCellAction.NEXT;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_TAB && keyEvent.isShiftDown()) {\n      return EditorCellAction.PREV;\n    }\n\n    // ---\n    if (keyEvent.getKeyCode() == KeyEvent.VK_SPACE && keyEvent.getModifiers() == 0) {\n      EditorCell selectedCell = editorContext.getNodeEditorComponent().getSelectedCell();\n      if (!(selectedCell instanceof EditorCell_Label)) {\n        return EditorCellAction.RIGHT_TRANSFORM;\n      }\n      EditorCell_Label labelCell = (EditorCell_Label) selectedCell;\n      if (!labelCell.isEditable()) {\n        return EditorCellAction.RIGHT_TRANSFORM;\n      }\n\n      // caret at the end of text ?\n      String text = labelCell.getText();\n      int caretPosition = labelCell.getTextLine().getCaretPosition();\n      System.out.println(\"text:\" + text + \" len:\" + text.length() + \"caret at:\" + caretPosition);\n      if (caretPosition == text.length()) {\n        return EditorCellAction.RIGHT_TRANSFORM;\n      }\n    }\n\n\n    if (keyEvent.getKeyCode() == KeyEvent.VK_DELETE && keyEvent.isControlDown()) {\n      return EditorCellAction.DELETE;\n    }\n\n    // ---\n    if (keyEvent.getKeyCode() == KeyEvent.VK_C && keyEvent.isControlDown()) {\n      return EditorCellAction.COPY;\n    }\n    if (keyEvent.getKeyCode() == KeyEvent.VK_V && keyEvent.isControlDown()) {\n      if (keyEvent.isShiftDown() && !keyEvent.isAltDown()) {\n        return EditorCellAction.PASTE_BEFORE;\n      } else if (!keyEvent.isShiftDown() && keyEvent.isAltDown()) {\n        return EditorCellAction.PASTE_AFTER;\n      }\n      return EditorCellAction.PASTE;\n    }\n\n    return null;\n  }","commit_id":"11cb8ef5a0bec94ce35f40df1bdbbf318bd73be4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n\t\tif (item.getItemId() == R.id.map_show_settings) {\r\n    \t\tfinal Intent settings = new Intent(MapActivity.this, SettingsActivity.class);\r\n\t\t\tstartActivity(settings);\r\n    \t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_where_am_i) {\r\n\t\t\tbackToLocationImpl();\r\n        \treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_show_gps_status) {\r\n\t\t\tIntent intent = new Intent();\r\n\t\t\tintent.setComponent(new ComponentName(GPS_STATUS_COMPONENT, GPS_STATUS_ACTIVITY));\r\n\t\t\tResolveInfo resolved = getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n\t\t\tif(resolved != null){\r\n\t\t\t\tstartActivity(intent);\r\n\t\t\t} else {\r\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n\t\t\t\tbuilder.setMessage(getString(R.string.gps_status_app_not_found))\r\n\t\t\t\t\t\t.setPositiveButton(\r\n\t\t\t\t\t\t\t\tgetString(R.string.default_buttons_yes),\r\n\t\t\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\r\n\t\t\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog,\r\n\t\t\t\t\t\t\t\t\t\t\tint which) {\r\n\t\t\t\t\t\t\t\t\t\tIntent intent = new Intent(\r\n\t\t\t\t\t\t\t\t\t\t\t\tIntent.ACTION_VIEW,\r\n\t\t\t\t\t\t\t\t\t\t\t\tUri.parse(\"market://search?q=pname:\" + GPS_STATUS_COMPONENT));\r\n\t\t\t\t\t\t\t\t\t\tstartActivity(intent);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.setNegativeButton(getString(R.string.default_buttons_no), null)\r\n\t\t\t\t\t\t.show();\r\n\t\t\t}\r\n\t\t\treturn true;\r\n//\t\t} else if (item.getItemId() == R.id.map_mark_point) {\r\n//\t\t\tcontextMenuPoint(mapView.getLatitude(), mapView.getLongitude());\r\n//\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_get_directions) {\r\n\t\t\tgetDirections(mapView.getLatitude(), mapView.getLongitude(), true);\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_layers) {\r\n\t\t\topenLayerSelectionDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_specify_point) {\r\n\t\t\topenChangeLocationDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_mute) {\r\n\t\t\troutingHelper.getVoiceRouter().setMute(!routingHelper.getVoiceRouter().isMute());\r\n\t\t\treturn true;\r\n    \t}  else if (item.getItemId() == R.id.map_navigate_to_point) {\r\n    \t\tif(navigationLayer.getPointToNavigate() != null){\r\n    \t\t\tif(routingHelper.isRouteCalculated()){\r\n    \t\t\t\troutingHelper.setFinalAndCurrentLocation(null, null);\r\n    \t\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, false);\r\n    \t\t\t\troutingHelper.setFollowingMode(false);\r\n    \t\t\t} else {\r\n    \t\t\t\tnavigateToPoint(null);\r\n    \t\t\t}\r\n    \t\t} else {\r\n    \t\t\tnavigateToPoint(new LatLon(mapView.getLatitude(), mapView.getLongitude()));\r\n    \t\t}\r\n\t\t\tmapView.refreshMap();\r\n    \t} else if (item.getItemId() == R.id.map_gpx_routing) {\r\n\t\t\tuseGPXFileLayer(true, navigationLayer.getPointToNavigate());\r\n\t\t\treturn true;\r\n    \t} else if (item.getItemId() == R.id.map_show_point_options) {\r\n\t\t\tcontextMenuPoint(mapView.getLatitude(), mapView.getLongitude());\r\n    \t\treturn true;\r\n    \t}\r\n    \treturn super.onOptionsItemSelected(item);\r\n    }","id":32894,"modified_method":"@Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n\t\tif (item.getItemId() == R.id.map_show_settings) {\r\n    \t\tfinal Intent settings = new Intent(MapActivity.this, SettingsActivity.class);\r\n\t\t\tstartActivity(settings);\r\n    \t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_where_am_i) {\r\n\t\t\tbackToLocationImpl();\r\n        \treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_show_gps_status) {\r\n\t\t\tIntent intent = new Intent();\r\n\t\t\tintent.setComponent(new ComponentName(GPS_STATUS_COMPONENT, GPS_STATUS_ACTIVITY));\r\n\t\t\tResolveInfo resolved = getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n\t\t\tif(resolved != null){\r\n\t\t\t\tstartActivity(intent);\r\n\t\t\t} else {\r\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n\t\t\t\tbuilder.setMessage(getString(R.string.gps_status_app_not_found));\r\n\t\t\t\tbuilder.setPositiveButton(getString(R.string.default_buttons_yes),\r\n\t\t\t\t\t\tnew DialogInterface.OnClickListener() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\t\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"market://search?q=pname:\" + GPS_STATUS_COMPONENT));\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tstartActivity(intent);\r\n\t\t\t\t\t\t\t\t} catch (ActivityNotFoundException e) {\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\tbuilder.setNegativeButton(getString(R.string.default_buttons_no), null);\r\n\t\t\t\tbuilder.show();\r\n\t\t\t}\r\n\t\t\treturn true;\r\n//\t\t} else if (item.getItemId() == R.id.map_mark_point) {\r\n//\t\t\tcontextMenuPoint(mapView.getLatitude(), mapView.getLongitude());\r\n//\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_get_directions) {\r\n\t\t\tgetDirections(mapView.getLatitude(), mapView.getLongitude(), true);\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_layers) {\r\n\t\t\topenLayerSelectionDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_specify_point) {\r\n\t\t\topenChangeLocationDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_mute) {\r\n\t\t\troutingHelper.getVoiceRouter().setMute(!routingHelper.getVoiceRouter().isMute());\r\n\t\t\treturn true;\r\n    \t}  else if (item.getItemId() == R.id.map_navigate_to_point) {\r\n    \t\tif(navigationLayer.getPointToNavigate() != null){\r\n    \t\t\tif(routingHelper.isRouteCalculated()){\r\n    \t\t\t\troutingHelper.setFinalAndCurrentLocation(null, null);\r\n    \t\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, false);\r\n    \t\t\t\troutingHelper.setFollowingMode(false);\r\n    \t\t\t} else {\r\n    \t\t\t\tnavigateToPoint(null);\r\n    \t\t\t}\r\n    \t\t} else {\r\n    \t\t\tnavigateToPoint(new LatLon(mapView.getLatitude(), mapView.getLongitude()));\r\n    \t\t}\r\n\t\t\tmapView.refreshMap();\r\n    \t} else if (item.getItemId() == R.id.map_gpx_routing) {\r\n\t\t\tuseGPXFileLayer(true, navigationLayer.getPointToNavigate());\r\n\t\t\treturn true;\r\n    \t} else if (item.getItemId() == R.id.map_show_point_options) {\r\n\t\t\tcontextMenuPoint(mapView.getLatitude(), mapView.getLongitude());\r\n    \t\treturn true;\r\n    \t}\r\n    \treturn super.onOptionsItemSelected(item);\r\n    }","commit_id":"d6def716ad2534dd1152d17cba18f9f097a4ef51","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void enterRoutePlanningMode(final LatLon from, final String fromName, boolean useCurrentGPX) {\n\t\tList<SelectedGpxFile> selectedGPXFiles = mapActivity.getMyApplication().getSelectedGpxHelper()\n\t\t\t\t.getSelectedGPXFiles();\n\t\tGPXFile gpxFile = null;\n\t\tfor (SelectedGpxFile gs : selectedGPXFiles) {\n\t\t\tif (!gs.isShowCurrentTrack() && !gs.notShowNavigationDialog) {\n\t\t\t\tif (gs.getGpxFile().hasRtePt() || gs.getGpxFile().hasTrkpt()) {\n\t\t\t\t\tgpxFile = gs.getGpxFile();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinal GPXFile f = gpxFile;\n\t\tif (gpxFile != null && !useCurrentGPX) {\n\n\t\t\tBuilder bld = new AlertDialog.Builder(mapActivity);\n\t\t\tbld.setMessage(R.string.use_displayed_track_for_navigation);\n\t\t\tbld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tenterRoutePlanningModeImpl(f, from, fromName);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tenterRoutePlanningModeImpl(null, from, fromName);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbld.show();\n\t\t} else {\n\t\t\tenterRoutePlanningModeImpl(useCurrentGPX ? f : null, from, fromName);\n\t\t}\n\t}","id":32895,"modified_method":"public void enterRoutePlanningMode(final LatLon from, final String fromName, boolean useCurrentGPX) {\n\t\tList<SelectedGpxFile> selectedGPXFiles = mapActivity.getMyApplication().getSelectedGpxHelper()\n\t\t\t\t.getSelectedGPXFiles();\n\t\tfinal List<GPXFile> gpxFiles = new ArrayList<GPXFile>();\n\t\tfor (SelectedGpxFile gs : selectedGPXFiles) {\n\t\t\tif (!gs.isShowCurrentTrack() && !gs.notShowNavigationDialog) {\n\t\t\t\tif (gs.getGpxFile().hasRtePt() || gs.getGpxFile().hasTrkpt()) {\n\t\t\t\t\tgpxFiles.add(gs.getGpxFile());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (gpxFiles.size() > 0 && !useCurrentGPX) {\n\t\t\tBuilder bld = new AlertDialog.Builder(mapActivity);\n\t\t\tif (gpxFiles.size() == 1){\n\t\t\t\tbld.setMessage(R.string.use_displayed_track_for_navigation);\n\t\t\t\tbld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tenterRoutePlanningModeImpl(gpxFiles.get(0), from, fromName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tbld.setTitle(R.string.use_displayed_track_for_navigation);\n\t\t\t\tArrayAdapter<GPXFile> adapter =new ArrayAdapter<GPXFile>(mapActivity, R.layout.drawer_list_item, gpxFiles){\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\t\t\t\t\tif (convertView == null){\n\t\t\t\t\t\t\tconvertView = mapActivity.getLayoutInflater().inflate(R.layout.drawer_list_item, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString path = getItem(position).path;\n\t\t\t\t\t\tString name = path.substring(path.lastIndexOf(\"/\") + 1,path.length());\n\t\t\t\t\t\t((TextView)convertView.findViewById(R.id.title)).setText(name);\n\t\t\t\t\t\tconvertView.findViewById(R.id.icon).setVisibility(View.GONE);\n\t\t\t\t\t\tconvertView.findViewById(R.id.check_item).setVisibility(View.GONE);\n\t\t\t\t\t\treturn convertView;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tbld.setAdapter(adapter, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialogInterface, int i) {\n\t\t\t\t\t\tenterRoutePlanningModeImpl(gpxFiles.get(i), from, fromName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tbld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tenterRoutePlanningModeImpl(null, from, fromName);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbld.show();\n\t\t} else {\n\t\t\tenterRoutePlanningModeImpl(useCurrentGPX ? gpxFiles.get(0) : null, from, fromName);\n\t\t}\n\t}","commit_id":"a5bac45957b7a7428805ea31eca0a6190b8490fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\r\n\t\tsuper.onListItemClick(l, v, position, id);\r\n\t\tfinal Entry<String, String> e = ((DownloadIndexAdapter)getListAdapter()).getItem(position);\r\n\t\tBuilder builder = new AlertDialog.Builder(this);\r\n\t\tint ls = e.getKey().lastIndexOf('_');\r\n\t\tfinal String regionName = e.getKey().substring(0, ls);\r\n\t\tbuilder.setMessage(MessageFormat.format(getString(R.string.download_question), regionName, e.getValue()));\r\n\t\tbuilder.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tdownloadFile(e.getKey(), regionName);\r\n\t\t\t}\r\n\t\t});\r\n\t\tbuilder.setNegativeButton(R.string.default_buttons_no, null);\r\n\t\tbuilder.show();\r\n\t}","id":32896,"modified_method":"@Override\r\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\r\n\t\tsuper.onListItemClick(l, v, position, id);\r\n\t\tfinal Entry<String, String> e = ((DownloadIndexAdapter)getListAdapter()).getItem(position);\r\n\t\t\r\n\t\tint ls = e.getKey().lastIndexOf('_');\r\n\t\tfinal String regionName = e.getKey().substring(0, ls);\r\n\t\tfinal File fileToSave = resolveFileName(e.getKey(), regionName);\r\n\t\tif (fileToSave != null) {\r\n\t\t\tBuilder builder = new AlertDialog.Builder(this);\r\n\t\t\tif(!fileToSave.exists()){\r\n\t\t\t\tbuilder.setMessage(MessageFormat.format(getString(R.string.download_question), regionName, e.getValue()));\r\n\t\t\t} else {\r\n\t\t\t\tMessageFormat format = new MessageFormat(\"{0,date,dd.MM.yyyy} : {1, number,##.#} MB\", Locale.US); //$NON-NLS-1$\r\n\t\t\t\tString description = format.format(new Object[]{new Date(fileToSave.lastModified()), ((float)fileToSave.length() / MB)});\r\n\t\t\t\tbuilder.setMessage(MessageFormat.format(getString(R.string.download_question_exist), regionName, description, e.getValue()));\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tbuilder.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\t\tdownloadFile(e.getKey(), fileToSave);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tbuilder.setNegativeButton(R.string.default_buttons_no, null);\r\n\t\t\tbuilder.show();\r\n\t\t}\r\n\t}","commit_id":"dd825737b4284e19ebdd1fcbd9d4805e6d6594a8","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void downloadFile(final String key, String regionName) {\r\n\t\tFile parent = null;\r\n\t\tif(key.endsWith(IndexConstants.ADDRESS_INDEX_EXT)){\r\n\t\t\tparent = new File(Environment.getExternalStorageDirectory(), ResourceManager.ADDRESS_PATH);\r\n\t\t\tregionName += IndexConstants.ADDRESS_INDEX_EXT;\r\n\t\t} else if(key.endsWith(IndexConstants.POI_INDEX_EXT)){\r\n\t\t\tparent = new File(Environment.getExternalStorageDirectory(), ResourceManager.POI_PATH);\r\n\t\t\tregionName += IndexConstants.POI_INDEX_EXT;\r\n\t\t} else if(key.endsWith(IndexConstants.TRANSPORT_INDEX_EXT)){\r\n\t\t\tparent = new File(Environment.getExternalStorageDirectory(), ResourceManager.TRANSPORT_PATH);\r\n\t\t\tregionName += IndexConstants.TRANSPORT_INDEX_EXT;\r\n\t\t}\r\n\t\tif(parent != null){\r\n\t\t\tparent.mkdirs();\r\n\t\t}\r\n\t\tif(parent == null || !parent.exists()){\r\n\t\t\tToast.makeText(DownloadIndexActivity.this, getString(R.string.download_sd_dir_not_accessible), Toast.LENGTH_LONG);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfinal File file = new File(parent, regionName);\r\n\t\tfinal ProgressDialog dlg = ProgressDialog.show(this, getString(R.string.downloading), getString(R.string.downloading_file), true, true);\r\n\t\tdlg.show();\r\n\t\tfinal ProgressDialogImplementation impl = new ProgressDialogImplementation(dlg, true);\r\n\t\timpl.setRunnable(\"DownloadIndex\", new Runnable(){ //$NON-NLS-1$\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream out = new FileOutputStream(file);\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tURL url = DownloaderIndexFromGoogleCode.getInputStreamToLoadIndex(key);\r\n\t\t\t\t\t\tURLConnection conn = url.openConnection();\r\n\t\t\t\t\t\tInputStream is = conn.getInputStream();\r\n\t\t\t\t\t\timpl.startTask(getString(R.string.downloading_file), conn.getContentLength());\r\n\t\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\r\n\t\t\t\t\t\tint read = 0;\r\n\t\t\t\t\t\twhile((read = is.read(buffer)) != -1){\r\n\t\t\t\t\t\t\tout.write(buffer, 0, read);\r\n\t\t\t\t\t\t\timpl.progress(read);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tArrayList<String> warnings = new ArrayList<String>();\r\n\t\t\t\t\t\tif(file.getName().endsWith(IndexConstants.ADDRESS_INDEX_EXT)){\r\n\t\t\t\t\t\t\tResourceManager.getResourceManager().indexingAddress(impl, warnings, file);\r\n\t\t\t\t\t\t} else if(file.getName().endsWith(IndexConstants.POI_INDEX_EXT)){\r\n\t\t\t\t\t\t\tResourceManager.getResourceManager().indexingPoi(impl, warnings, file);\r\n\t\t\t\t\t\t} else if(file.getName().endsWith(IndexConstants.TRANSPORT_INDEX_EXT)){\r\n\t\t\t\t\t\t\tResourceManager.getResourceManager().indexingTransport(impl, warnings, file);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(warnings.isEmpty()){\r\n\t\t\t\t\t\t\tshowWarning(getString(R.string.download_index_success));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tshowWarning(warnings.get(0));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\tout.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\r\n\t\t\t\t\tshowWarning(getString(R.string.error_io_error));\r\n\t\t\t\t\t// Possibly file is corrupted\r\n\t\t\t\t\tfile.delete();\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tdlg.dismiss();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\timpl.run();\r\n\t}","id":32897,"modified_method":"protected void downloadFile(final String key, final File file) {\r\n\t\t\r\n\t\tfinal ProgressDialog dlg = ProgressDialog.show(this, getString(R.string.downloading), getString(R.string.downloading_file), true, true);\r\n\t\tdlg.show();\r\n\t\tfinal ProgressDialogImplementation impl = new ProgressDialogImplementation(dlg, true);\r\n\t\timpl.setRunnable(\"DownloadIndex\", new Runnable(){ //$NON-NLS-1$\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream out = new FileOutputStream(file);\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tURL url = DownloaderIndexFromGoogleCode.getInputStreamToLoadIndex(key);\r\n\t\t\t\t\t\tURLConnection conn = url.openConnection();\r\n\t\t\t\t\t\tInputStream is = conn.getInputStream();\r\n\t\t\t\t\t\timpl.startTask(getString(R.string.downloading_file), conn.getContentLength());\r\n\t\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\r\n\t\t\t\t\t\tint read = 0;\r\n\t\t\t\t\t\twhile((read = is.read(buffer)) != -1){\r\n\t\t\t\t\t\t\tout.write(buffer, 0, read);\r\n\t\t\t\t\t\t\timpl.progress(read);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tArrayList<String> warnings = new ArrayList<String>();\r\n\t\t\t\t\t\tif(file.getName().endsWith(IndexConstants.ADDRESS_INDEX_EXT)){\r\n\t\t\t\t\t\t\tResourceManager.getResourceManager().indexingAddress(impl, warnings, file);\r\n\t\t\t\t\t\t} else if(file.getName().endsWith(IndexConstants.POI_INDEX_EXT)){\r\n\t\t\t\t\t\t\tResourceManager.getResourceManager().indexingPoi(impl, warnings, file);\r\n\t\t\t\t\t\t} else if(file.getName().endsWith(IndexConstants.TRANSPORT_INDEX_EXT)){\r\n\t\t\t\t\t\t\tResourceManager.getResourceManager().indexingTransport(impl, warnings, file);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(warnings.isEmpty()){\r\n\t\t\t\t\t\t\tshowWarning(getString(R.string.download_index_success));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tshowWarning(warnings.get(0));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\tout.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\r\n\t\t\t\t\tshowWarning(getString(R.string.error_io_error));\r\n\t\t\t\t\t// Possibly file is corrupted\r\n\t\t\t\t\tfile.delete();\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tdlg.dismiss();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\timpl.run();\r\n\t}","commit_id":"dd825737b4284e19ebdd1fcbd9d4805e6d6594a8","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public boolean onCreateOptionsMenu(Menu menu) {\r\n\t\tMenuInflater inflater = getMenuInflater();\r\n\t\tinflater.inflate(R.menu.map_menu, menu);\r\n\t\tnavigateToPointMenu = menu.findItem(R.id.map_navigate_to_point);\r\n\t\tmuteMenu = menu.findItem(R.id.map_mute);\r\n\t\tupdateNavigateToPointMenu();\r\n\t\treturn true;\r\n\t}","id":32898,"modified_method":"public boolean onCreateOptionsMenu(Menu menu) {\r\n\t\tMenuInflater inflater = getMenuInflater();\r\n\t\tinflater.inflate(R.menu.map_menu, menu);\r\n\t\treturn true;\r\n\t}","commit_id":"3b5a535af9f1e93026a919b7ec3b8bf3c9679e42","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n\t\tif (item.getItemId() == R.id.map_show_settings) {\r\n    \t\tfinal Intent settings = new Intent(MapActivity.this, SettingsActivity.class);\r\n\t\t\tstartActivity(settings);\r\n    \t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_where_am_i) {\r\n\t\t\tbackToLocationImpl();\r\n        \treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_show_gps_status) {\r\n\t\t\tIntent intent = new Intent();\r\n\t\t\tintent.setComponent(new ComponentName(GPS_STATUS_COMPONENT, GPS_STATUS_ACTIVITY));\r\n\t\t\tResolveInfo resolved = getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n\t\t\tif(resolved != null){\r\n\t\t\t\tstartActivity(intent);\r\n\t\t\t} else {\r\n\t\t\t\tToast.makeText(this, getString(R.string.gps_status_app_not_found), Toast.LENGTH_LONG).show();\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_transport) {\r\n\t\t\tstartActivity(new Intent(this, SearchTransportActivity.class));\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_mark_point) {\r\n\t\t\tcontextMenuPoint(mapView.getLatitude(), mapView.getLongitude(), true);\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_get_directions) {\r\n\t\t\tgetDirections(mapView.getLatitude(), mapView.getLongitude());\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_layers) {\r\n\t\t\topenLayerSelectionDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_specify_point) {\r\n\t\t\topenChangeLocationDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_mute) {\r\n\t\t\troutingHelper.getVoiceRouter().setMute(!routingHelper.getVoiceRouter().isMute());\r\n\t\t\tupdateNavigateToPointMenu();\r\n\t\t\treturn true;\r\n    \t}  else if (item.getItemId() == R.id.map_navigate_to_point) {\r\n    \t\tif(navigationLayer.getPointToNavigate() != null){\r\n    \t\t\tif(routingHelper.isRouteCalculated()){\r\n    \t\t\t\troutingHelper.setFinalAndCurrentLocation(null, null);\r\n    \t\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, false);\r\n    \t\t\t\troutingHelper.setFollowingMode(false);\r\n    \t\t\t\tupdateNavigateToPointMenu();\r\n    \t\t\t} else {\r\n    \t\t\t\tnavigateToPoint(null);\r\n    \t\t\t}\r\n    \t\t} else {\r\n    \t\t\tnavigateToPoint(new LatLon(mapView.getLatitude(), mapView.getLongitude()));\r\n    \t\t}\r\n\t\t\tmapView.refreshMap();\r\n    \t}\r\n    \treturn super.onOptionsItemSelected(item);\r\n    }","id":32899,"modified_method":"@Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n\t\tif (item.getItemId() == R.id.map_show_settings) {\r\n    \t\tfinal Intent settings = new Intent(MapActivity.this, SettingsActivity.class);\r\n\t\t\tstartActivity(settings);\r\n    \t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_where_am_i) {\r\n\t\t\tbackToLocationImpl();\r\n        \treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_show_gps_status) {\r\n\t\t\tIntent intent = new Intent();\r\n\t\t\tintent.setComponent(new ComponentName(GPS_STATUS_COMPONENT, GPS_STATUS_ACTIVITY));\r\n\t\t\tResolveInfo resolved = getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n\t\t\tif(resolved != null){\r\n\t\t\t\tstartActivity(intent);\r\n\t\t\t} else {\r\n\t\t\t\tToast.makeText(this, getString(R.string.gps_status_app_not_found), Toast.LENGTH_LONG).show();\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_transport) {\r\n\t\t\tstartActivity(new Intent(this, SearchTransportActivity.class));\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_mark_point) {\r\n\t\t\tcontextMenuPoint(mapView.getLatitude(), mapView.getLongitude(), true);\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_get_directions) {\r\n\t\t\tgetDirections(mapView.getLatitude(), mapView.getLongitude(), true);\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_layers) {\r\n\t\t\topenLayerSelectionDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_specify_point) {\r\n\t\t\topenChangeLocationDialog();\r\n\t\t\treturn true;\r\n\t\t} else if (item.getItemId() == R.id.map_mute) {\r\n\t\t\troutingHelper.getVoiceRouter().setMute(!routingHelper.getVoiceRouter().isMute());\r\n\t\t\treturn true;\r\n    \t}  else if (item.getItemId() == R.id.map_navigate_to_point) {\r\n    \t\tif(navigationLayer.getPointToNavigate() != null){\r\n    \t\t\tif(routingHelper.isRouteCalculated()){\r\n    \t\t\t\troutingHelper.setFinalAndCurrentLocation(null, null);\r\n    \t\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, false);\r\n    \t\t\t\troutingHelper.setFollowingMode(false);\r\n    \t\t\t} else {\r\n    \t\t\t\tnavigateToPoint(null);\r\n    \t\t\t}\r\n    \t\t} else {\r\n    \t\t\tnavigateToPoint(new LatLon(mapView.getLatitude(), mapView.getLongitude()));\r\n    \t\t}\r\n\t\t\tmapView.refreshMap();\r\n    \t}\r\n    \treturn super.onOptionsItemSelected(item);\r\n    }","commit_id":"3b5a535af9f1e93026a919b7ec3b8bf3c9679e42","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void contextMenuPoint(final double latitude, final double longitude, boolean menu){\r\n    \tBuilder builder = new AlertDialog.Builder(this);\r\n    \tResources resources = this.getResources();\r\n    \tString[] res = new String[]{\r\n        \t\t\tresources.getString(R.string.context_menu_item_navigate_point),\r\n        \t\t\tresources.getString(R.string.context_menu_item_search_poi),\r\n        \t\t\tresources.getString(R.string.context_menu_item_show_route),\r\n        \t\t\tresources.getString(R.string.context_menu_item_add_favorite),\r\n        \t\t\tresources.getString(R.string.context_menu_item_create_poi),\r\n        \t\t\tresources.getString(R.string.context_menu_item_open_bug),\r\n        \t\t\tresources.getString(R.string.context_menu_item_update_map)\r\n        \t};\r\n    \tbuilder.setItems(res, new DialogInterface.OnClickListener(){\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tif(which == 0){\r\n\t\t\t\t\tnavigateToPoint(new LatLon(latitude, longitude));\r\n\t\t\t\t} else if(which == 1){\r\n\t\t\t\t\tIntent intent = new Intent(MapActivity.this, SearchPoiFilterActivity.class);\r\n\t\t\t\t\tintent.putExtra(SearchPoiFilterActivity.SEARCH_LAT, latitude);\r\n\t\t\t\t\tintent.putExtra(SearchPoiFilterActivity.SEARCH_LON, longitude);\r\n\t\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n\t\t\t\t\tstartActivity(intent);\r\n\t\t\t\t} else if(which == 2){\r\n\t\t\t\t\tshowRoute(latitude, longitude);\r\n\t\t\t\t} else if(which == 3){\r\n\t\t\t\t\taddFavouritePoint(latitude, longitude);\r\n\t\t\t\t} else if(which == 4){\r\n\t\t\t\t\tEditingPOIActivity activity = new EditingPOIActivity(MapActivity.this, mapView);\r\n\t\t\t\t\tactivity.showCreateDialog(latitude, longitude);\r\n\t\t\t\t} else if(which == 5){\r\n\t\t\t\t\tosmBugsLayer.openBug(MapActivity.this, getLayoutInflater(), mapView, latitude, longitude);\r\n\t\t\t\t} else if(which == 6){\r\n\t\t\t\t\treloadTile(mapView.getZoom(), latitude, longitude);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t});\r\n\t\tbuilder.create().show();\r\n    }","id":32900,"modified_method":"public void contextMenuPoint(final double latitude, final double longitude, boolean menu){\r\n    \tBuilder builder = new AlertDialog.Builder(this);\r\n    \tResources resources = this.getResources();\r\n    \tString[] res = new String[]{\r\n        \t\t\tresources.getString(R.string.context_menu_item_navigate_point),\r\n        \t\t\tresources.getString(R.string.context_menu_item_search_poi),\r\n        \t\t\tresources.getString(R.string.context_menu_item_show_route),\r\n        \t\t\tresources.getString(R.string.context_menu_item_add_favorite),\r\n        \t\t\tresources.getString(R.string.context_menu_item_create_poi),\r\n        \t\t\tresources.getString(R.string.context_menu_item_open_bug),\r\n        \t\t\tresources.getString(R.string.context_menu_item_update_map)\r\n        \t};\r\n    \tbuilder.setItems(res, new DialogInterface.OnClickListener(){\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tif(which == 0){\r\n\t\t\t\t\tnavigateToPoint(new LatLon(latitude, longitude));\r\n\t\t\t\t} else if(which == 1){\r\n\t\t\t\t\tIntent intent = new Intent(MapActivity.this, SearchPoiFilterActivity.class);\r\n\t\t\t\t\tintent.putExtra(SearchPoiFilterActivity.SEARCH_LAT, latitude);\r\n\t\t\t\t\tintent.putExtra(SearchPoiFilterActivity.SEARCH_LON, longitude);\r\n\t\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n\t\t\t\t\tstartActivity(intent);\r\n\t\t\t\t} else if(which == 2){\r\n\t\t\t\t\tgetDirections(latitude, longitude, false);\r\n\t\t\t\t} else if(which == 3){\r\n\t\t\t\t\taddFavouritePoint(latitude, longitude);\r\n\t\t\t\t} else if(which == 4){\r\n\t\t\t\t\tEditingPOIActivity activity = new EditingPOIActivity(MapActivity.this, mapView);\r\n\t\t\t\t\tactivity.showCreateDialog(latitude, longitude);\r\n\t\t\t\t} else if(which == 5){\r\n\t\t\t\t\tosmBugsLayer.openBug(MapActivity.this, getLayoutInflater(), mapView, latitude, longitude);\r\n\t\t\t\t} else if(which == 6){\r\n\t\t\t\t\treloadTile(mapView.getZoom(), latitude, longitude);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t});\r\n\t\tbuilder.create().show();\r\n    }","commit_id":"3b5a535af9f1e93026a919b7ec3b8bf3c9679e42","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void getDirections(final double lat, final double lon){\r\n    \tif(navigationLayer.getPointToNavigate() == null){\r\n\t\t\tToast.makeText(this, R.string.mark_final_location_first, Toast.LENGTH_LONG).show();\r\n\t\t\treturn;\r\n\t\t}\r\n    \tBuilder builder = new AlertDialog.Builder(this);\r\n    \tbuilder.setTitle(R.string.follow_route);\r\n    \tView view = getLayoutInflater().inflate(R.layout.calculate_route, null);\r\n    \tfinal ToggleButton[] buttons = new ToggleButton[ApplicationMode.values().length];\r\n    \tbuttons[ApplicationMode.CAR.ordinal()] = (ToggleButton) view.findViewById(R.id.CarButton);\r\n    \tbuttons[ApplicationMode.BICYCLE.ordinal()] = (ToggleButton) view.findViewById(R.id.BicycleButton);\r\n    \tbuttons[ApplicationMode.PEDESTRIAN.ordinal()] = (ToggleButton) view.findViewById(R.id.PedestrianButton);\r\n    \tApplicationMode appMode = OsmandSettings.getApplicationMode(this);\r\n    \tfor(int i=0; i< buttons.length; i++){\r\n    \t\tif(buttons[i] != null){\r\n    \t\t\tfinal int ind = i;\r\n    \t\t\tToggleButton b = buttons[i];\r\n    \t\t\tb.setChecked(appMode == ApplicationMode.values()[i]);\r\n    \t\t\tb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\r\n\t\t\t\t\t\tif(isChecked){\r\n\t\t\t\t\t\t\tif (OsmandSettings.getApplicationMode(MapActivity.this) != ApplicationMode.values()[ind]) {\r\n\t\t\t\t\t\t\t\tEditor edit = getSharedPreferences(OsmandSettings.SHARED_PREFERENCES_NAME, MODE_WORLD_WRITEABLE).edit();\r\n\t\t\t\t\t\t\t\tedit.putString(OsmandSettings.APPLICATION_MODE, ApplicationMode.values()[ind].name());\r\n\t\t\t\t\t\t\t\tSettingsActivity.setAppMode(ApplicationMode.values()[ind], edit);\r\n\t\t\t\t\t\t\t\tedit.commit();\r\n\t\t\t\t\t\t\t\tfor (int j = 0; j < buttons.length; j++) {\r\n\t\t\t\t\t\t\t\t\tif (buttons[j] != null) {\r\n\t\t\t\t\t\t\t\t\t\tbuttons[j].setChecked(ind == j);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tupdateApplicationModeSettings();\t\r\n\t\t\t\t\t\t\t\tmapView.refreshMap();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// revert state\t\r\n\t\t\t\t\t\t\tif (OsmandSettings.getApplicationMode(MapActivity.this) == ApplicationMode.values()[ind]){ \r\n\t\t\t\t\t\t\t\tbuttons[ind].setChecked(true);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n    \t\t\t\t\r\n    \t\t\t});\r\n    \t\t}\r\n    \t}\r\n    \tbuilder.setView(view);\r\n    \tbuilder.setPositiveButton(R.string.follow, new DialogInterface.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tLocation location = locationLayer.getLastKnownLocation();\r\n\t\t\t\tif(location == null){\r\n\t\t\t\t\tlocation = new Location(\"map\"); //$NON-NLS-1$\r\n\t\t\t\t\tlocation.setLatitude(lat);\r\n\t\t\t\t\tlocation.setLongitude(lon);\r\n\t\t\t\t} \r\n\t\t\t\troutingHelper.setFollowingMode(true);\r\n\t\t\t\troutingHelper.setFinalAndCurrentLocation(navigationLayer.getPointToNavigate(), location);\r\n\t\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, true);\r\n\t\t\t\tupdateNavigateToPointMenu();\r\n\t\t\t}\r\n    \t});\r\n    \tif(routingHelper.isRouterEnabled() && routingHelper.isRouteCalculated()){\r\n    \t\tbuilder.setNeutralButton(R.string.route_about, new DialogInterface.OnClickListener(){\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\t\tIntent intent = new Intent(MapActivity.this, ShowRouteInfoActivity.class);\r\n\t\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n\t\t\t\t\tstartActivity(intent);\r\n\t\t\t\t}\r\n    \t\t});\r\n    \t}\r\n    \tbuilder.setNegativeButton(R.string.only_show, new DialogInterface.OnClickListener(){\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tshowRoute(lat, lon);\r\n\t\t\t}\r\n    \t});\r\n    \tbuilder.show();\r\n    }","id":32901,"modified_method":"protected void getDirections(final double lat, final double lon, boolean followEnabled){\r\n    \tif(navigationLayer.getPointToNavigate() == null){\r\n\t\t\tToast.makeText(this, R.string.mark_final_location_first, Toast.LENGTH_LONG).show();\r\n\t\t\treturn;\r\n\t\t}\r\n    \tBuilder builder = new AlertDialog.Builder(this);\r\n    \t\r\n    \tView view = getLayoutInflater().inflate(R.layout.calculate_route, null);\r\n    \tfinal ToggleButton[] buttons = new ToggleButton[ApplicationMode.values().length];\r\n    \tbuttons[ApplicationMode.CAR.ordinal()] = (ToggleButton) view.findViewById(R.id.CarButton);\r\n    \tbuttons[ApplicationMode.BICYCLE.ordinal()] = (ToggleButton) view.findViewById(R.id.BicycleButton);\r\n    \tbuttons[ApplicationMode.PEDESTRIAN.ordinal()] = (ToggleButton) view.findViewById(R.id.PedestrianButton);\r\n    \tApplicationMode appMode = OsmandSettings.getApplicationMode(this);\r\n    \tfor(int i=0; i< buttons.length; i++){\r\n    \t\tif(buttons[i] != null){\r\n    \t\t\tfinal int ind = i;\r\n    \t\t\tToggleButton b = buttons[i];\r\n    \t\t\tb.setChecked(appMode == ApplicationMode.values()[i]);\r\n    \t\t\tb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\r\n\t\t\t\t\t\tif(isChecked){\r\n\t\t\t\t\t\t\tfor (int j = 0; j < buttons.length; j++) {\r\n\t\t\t\t\t\t\t\tif (buttons[j] != null) {\r\n\t\t\t\t\t\t\t\t\tif(buttons[j].isChecked() != (ind == j)){\r\n\t\t\t\t\t\t\t\t\t\tbuttons[j].setChecked(ind == j);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// revert state\r\n\t\t\t\t\t\t\tboolean revert = true;\r\n\t\t\t\t\t\t\tfor (int j = 0; j < buttons.length; j++) {\r\n\t\t\t\t\t\t\t\tif (buttons[j] != null) {\r\n\t\t\t\t\t\t\t\t\tif(buttons[j].isChecked()){\r\n\t\t\t\t\t\t\t\t\t\trevert = false;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (revert){ \r\n\t\t\t\t\t\t\t\tbuttons[ind].setChecked(true);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n    \t\t\t});\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \tDialogInterface.OnClickListener onlyShowCall = new DialogInterface.OnClickListener(){\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tApplicationMode mode = getAppMode(buttons);\r\n\t\t\t\tLocation map = new Location(\"map\"); //$NON-NLS-1$\r\n\t\t\t\tmap.setLatitude(lat);\r\n\t\t\t\tmap.setLongitude(lon);\r\n\t\t\t\troutingHelper.setAppMode(mode);\r\n\t\t\t\troutingHelper.setFollowingMode(false);\r\n\t\t\t\troutingHelper.setFinalAndCurrentLocation(navigationLayer.getPointToNavigate(), map);\r\n\t\t\t}\r\n    \t};\r\n    \t\r\n    \tDialogInterface.OnClickListener followCall = new DialogInterface.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tApplicationMode mode = getAppMode(buttons);\r\n\t\t\t\t// change global settings\r\n\t\t\t\tif (OsmandSettings.getApplicationMode(MapActivity.this) != mode) {\r\n\t\t\t\t\tEditor edit = getSharedPreferences(OsmandSettings.SHARED_PREFERENCES_NAME, MODE_WORLD_WRITEABLE).edit();\r\n\t\t\t\t\tedit.putString(OsmandSettings.APPLICATION_MODE, mode.name());\r\n\t\t\t\t\tSettingsActivity.setAppMode(mode, edit);\r\n\t\t\t\t\tedit.commit();\r\n\t\t\t\t\tupdateApplicationModeSettings();\t\r\n\t\t\t\t\tmapView.refreshMap();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tLocation location = locationLayer.getLastKnownLocation();\r\n\t\t\t\tif(location == null){\r\n\t\t\t\t\tlocation = new Location(\"map\"); //$NON-NLS-1$\r\n\t\t\t\t\tlocation.setLatitude(lat);\r\n\t\t\t\t\tlocation.setLongitude(lon);\r\n\t\t\t\t} \r\n\t\t\t\troutingHelper.setAppMode(mode);\r\n\t\t\t\troutingHelper.setFollowingMode(true);\r\n\t\t\t\troutingHelper.setFinalAndCurrentLocation(navigationLayer.getPointToNavigate(), location);\r\n\t\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, true);\r\n\t\t\t}\r\n    \t};\r\n    \tDialogInterface.OnClickListener showRoute = new DialogInterface.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\r\n\t\t\t\tIntent intent = new Intent(MapActivity.this, ShowRouteInfoActivity.class);\r\n\t\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n\t\t\t\tstartActivity(intent);\r\n\t\t\t}\r\n\t\t};\r\n    \t\r\n    \tbuilder.setView(view);\r\n    \tif (followEnabled) {\r\n    \t\tbuilder.setTitle(R.string.follow_route);\r\n\t\t\tbuilder.setPositiveButton(R.string.follow, followCall);\r\n\t\t\tif (routingHelper.isRouterEnabled() && routingHelper.isRouteCalculated()) {\r\n\t\t\t\tbuilder.setNeutralButton(R.string.route_about, showRoute);\r\n\t\t\t}\r\n\t\t\tbuilder.setNegativeButton(R.string.only_show, onlyShowCall);\r\n\t\t} else {\r\n\t\t\tbuilder.setTitle(R.string.show_route);\r\n\t\t\tview.findViewById(R.id.TextView).setVisibility(View.GONE);\r\n    \t\tbuilder.setPositiveButton(R.string.show_route, onlyShowCall);\r\n    \t\tbuilder.setNegativeButton(R.string.default_buttons_cancel, null);\r\n    \t}\r\n    \tbuilder.show();\r\n    }","commit_id":"3b5a535af9f1e93026a919b7ec3b8bf3c9679e42","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void navigateToPoint(LatLon point){\r\n\t\tif(point != null){\r\n\t\t\tOsmandSettings.setPointToNavigate(this, point.getLatitude(), point.getLongitude());\r\n\t\t} else {\r\n\t\t\tOsmandSettings.clearPointToNavigate(this);\r\n\t\t}\r\n\t\troutingHelper.setFinalAndCurrentLocation(point, null);\r\n\t\tif(point == null){\r\n\t\t\troutingHelper.setFollowingMode(false);\r\n\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, false);\r\n\t\t}\r\n\t\tnavigationLayer.setPointToNavigate(point);\r\n\t\tupdateNavigateToPointMenu();\r\n\t}","id":32902,"modified_method":"public void navigateToPoint(LatLon point){\r\n\t\tif(point != null){\r\n\t\t\tOsmandSettings.setPointToNavigate(this, point.getLatitude(), point.getLongitude());\r\n\t\t} else {\r\n\t\t\tOsmandSettings.clearPointToNavigate(this);\r\n\t\t}\r\n\t\troutingHelper.setFinalAndCurrentLocation(point, null);\r\n\t\tif(point == null){\r\n\t\t\troutingHelper.setFollowingMode(false);\r\n\t\t\tOsmandSettings.setFollowingByRoute(MapActivity.this, false);\r\n\t\t}\r\n\t\tnavigationLayer.setPointToNavigate(point);\r\n\t}","commit_id":"3b5a535af9f1e93026a919b7ec3b8bf3c9679e42","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic void onDraw(Canvas canvas) {\r\n\t\tif (isLocationVisible(lastKnownLocation)) {\r\n\t\t\tint locationX = view.getMapXForPoint(lastKnownLocation.getLongitude());\r\n\t\t\tint locationY = view.getMapYForPoint(lastKnownLocation.getLatitude());\r\n\t\t\tint radius = MapUtils.getLengthXFromMeters(view.getFloatZoom(), view.getLatitude(), view.getLongitude(), lastKnownLocation\r\n\t\t\t\t\t.getAccuracy(), view.getTileSize(), view.getWidth());\r\n\r\n\t\t\tif(appMode == ApplicationMode.CAR){\r\n\t\t\t\tif(!lastKnownLocation.hasBearing()){\r\n\t\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS * 2.5f, location);\r\n\t\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS * 2.5f, bearingOver);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS, location);\r\n\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS, bearingOver);\r\n\t\t\t}\r\n\t\t\tif (radius > RADIUS) {\r\n\t\t\t\tcanvas.drawCircle(locationX, locationY, radius, area);\r\n\t\t\t}\r\n\t\t\tif(heading != null){\r\n\t\t\t\tcanvas.drawArc(getHeadingRect(locationX, locationY), \r\n\t\t\t\t\t\theading - HEADING_ANGLE/ 2 - 90, HEADING_ANGLE, true, headingPaint);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(lastKnownLocation.hasBearing()){\r\n\t\t\t\tfloat bearing = lastKnownLocation.getBearing();\r\n\t\t\t\tint radiusBearing = 30;\r\n\t\t\t\tif(lastKnownLocation.hasSpeed()){\r\n\t\t\t\t\tradiusBearing = \r\n\t\t\t\t\t\tMath.max(MapUtils.getLengthXFromMeters(view.getFloatZoom(), view.getLatitude(), view.getLongitude(), \r\n\t\t\t\t\t\t\tlastKnownLocation.getSpeed(), view.getTileSize(), view.getWidth()) * 2, radiusBearing);\r\n\t\t\t\t}\r\n\t\t\t\tradiusBearing += RADIUS /2;\r\n\t\t\t\t\r\n\t\t\t\tpathForDirection.reset();\r\n\t\t\t\tpathForDirection.moveTo(0, 0);\r\n\t\t\t\tpathForDirection.lineTo((float) RADIUS, 1f);\r\n\t\t\t\tpathForDirection.lineTo((float) -RADIUS, 1f);\r\n\t\t\t\tpathForDirection.lineTo(0, 0);\r\n\t\t\t\tMatrix m = new Matrix();\r\n\t\t\t\tm.reset();\r\n\t\t\t\tif(appMode == ApplicationMode.CAR){\r\n\t\t\t\t\tm.postScale(2.5f, radiusBearing * 1.5f);\r\n\t\t\t\t\tm.postTranslate(0, -radiusBearing/2);\r\n\t\t\t\t} else if(appMode == ApplicationMode.BICYCLE){\r\n\t\t\t\t\tm.postScale(2f, radiusBearing);\r\n\t\t\t\t\tm.postTranslate(0, -radiusBearing/2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tm.postScale(1, radiusBearing * 0.5f);\r\n\t\t\t\t\tm.postTranslate(0, -radiusBearing);\r\n\t\t\t\t}\r\n\t\t\t\tm.postTranslate(locationX, locationY);\r\n\t\t\t\tm.postRotate(bearing, locationX, locationY);\r\n\t\t\t\t\r\n\t\t\t\tpathForDirection.transform(m);\r\n\t\t\t\tcanvas.drawPath(pathForDirection, this.bearing);\r\n\t\t\t\tcanvas.drawPath(pathForDirection, this.bearingOver);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t}","id":32903,"modified_method":"@Override\r\n\tpublic void onDraw(Canvas canvas) {\r\n\t\tif (isLocationVisible(lastKnownLocation)) {\r\n\t\t\tint locationX = view.getMapXForPoint(lastKnownLocation.getLongitude());\r\n\t\t\tint locationY = view.getMapYForPoint(lastKnownLocation.getLatitude());\r\n\t\t\tint radius = MapUtils.getLengthXFromMeters(view.getFloatZoom(), view.getLatitude(), view.getLongitude(), lastKnownLocation\r\n\t\t\t\t\t.getAccuracy(), view.getTileSize(), view.getWidth());\r\n\r\n\t\t\tif(appMode == ApplicationMode.CAR){\r\n\t\t\t\tif(!lastKnownLocation.hasBearing()){\r\n\t\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS * 2.5f, location);\r\n\t\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS * 2.5f, bearingOver);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS, location);\r\n\t\t\t\tcanvas.drawCircle(locationX, locationY, RADIUS, bearingOver);\r\n\t\t\t}\r\n\t\t\tif (radius > RADIUS) {\r\n\t\t\t\tcanvas.drawCircle(locationX, locationY, radius, area);\r\n\t\t\t}\r\n\t\t\tif(heading != null){\r\n\t\t\t\tcanvas.drawArc(getHeadingRect(locationX, locationY), \r\n\t\t\t\t\t\theading - HEADING_ANGLE/ 2 - 90, HEADING_ANGLE, true, headingPaint);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(lastKnownLocation.hasBearing()){\r\n\t\t\t\tfloat bearing = lastKnownLocation.getBearing();\r\n\t\t\t\tint radiusBearing = 30;\r\n\t\t\t\tif(lastKnownLocation.hasSpeed() && appMode != ApplicationMode.CAR){\r\n\t\t\t\t\tradiusBearing = \r\n\t\t\t\t\t\tMath.max(MapUtils.getLengthXFromMeters(view.getFloatZoom(), view.getLatitude(), view.getLongitude(), \r\n\t\t\t\t\t\t\tlastKnownLocation.getSpeed(), view.getTileSize(), view.getWidth()) * 2, radiusBearing);\r\n\t\t\t\t\tradiusBearing = Math.min(radiusBearing, view.getHeight() / 4);\r\n\t\t\t\t}\r\n\t\t\t\tradiusBearing += RADIUS /2;\r\n\t\t\t\t\r\n\t\t\t\tpathForDirection.reset();\r\n\t\t\t\tpathForDirection.moveTo(0, 0);\r\n\t\t\t\tpathForDirection.lineTo((float) RADIUS, 1f);\r\n\t\t\t\tpathForDirection.lineTo((float) -RADIUS, 1f);\r\n\t\t\t\tpathForDirection.lineTo(0, 0);\r\n\t\t\t\tMatrix m = new Matrix();\r\n\t\t\t\tm.reset();\r\n\t\t\t\tif(appMode == ApplicationMode.CAR){\r\n\t\t\t\t\tm.postScale(2.5f, radiusBearing * 1.5f);\r\n\t\t\t\t\tm.postTranslate(0, -radiusBearing/2);\r\n\t\t\t\t} else if(appMode == ApplicationMode.BICYCLE){\r\n\t\t\t\t\tm.postScale(2f, radiusBearing);\r\n\t\t\t\t\tm.postTranslate(0, -radiusBearing/2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tm.postScale(1, radiusBearing * 0.5f);\r\n\t\t\t\t\tm.postTranslate(0, -radiusBearing);\r\n\t\t\t\t}\r\n\t\t\t\tm.postTranslate(locationX, locationY);\r\n\t\t\t\tm.postRotate(bearing, locationX, locationY);\r\n\t\t\t\t\r\n\t\t\t\tpathForDirection.transform(m);\r\n\t\t\t\tcanvas.drawPath(pathForDirection, this.bearing);\r\n\t\t\t\tcanvas.drawPath(pathForDirection, this.bearingOver);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t}","commit_id":"3b5a535af9f1e93026a919b7ec3b8bf3c9679e42","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic boolean onPreferenceClick(Preference preference) {\r\n\t\tif(preference == downloadIndexes){\r\n\t\t\tstartActivity(new Intent(this, DownloadIndexActivity.class));\r\n\t\t\treturn true;\r\n\t\t} else if(preference == reloadIndexes){\r\n\t\t\treloadIndexes();\r\n\t\t\treturn true;\r\n\t\t} else if(preference == saveCurrentTrack){\r\n\t\t\tSavingTrackHelper helper = new SavingTrackHelper(this);\r\n\t\t\thelper.saveDataToGpx();\r\n\t\t\thelper.close();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":32904,"modified_method":"@Override\r\n\tpublic boolean onPreferenceClick(Preference preference) {\r\n\t\tif(preference == downloadIndexes){\r\n\t\t\tstartActivity(new Intent(this, DownloadIndexActivity.class));\r\n\t\t\treturn true;\r\n\t\t} else if(preference == reloadIndexes){\r\n\t\t\treloadIndexes();\r\n\t\t\treturn true;\r\n\t\t} else if(preference == saveCurrentTrack){\r\n\t\t\tSavingTrackHelper helper = new SavingTrackHelper(this);\r\n\t\t\tif (helper.hasDataToSave()) {\r\n\t\t\t\tprogressDlg = ProgressDialog.show(this, getString(R.string.saving_gpx_tracks), getString(R.string.saving_gpx_tracks), true);\r\n\t\t\t\tfinal ProgressDialogImplementation impl = new ProgressDialogImplementation(progressDlg);\r\n\t\t\t\timpl.setRunnable(\"SavingGPX\", new Runnable() { //$NON-NLS-1$\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void run() {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tSavingTrackHelper helper = new SavingTrackHelper(SettingsActivity.this);\r\n\t\t\t\t\t\t\t\thelper.saveDataToGpx();\r\n\t\t\t\t\t\t\t\thelper.close();\r\n\t\t\t\t\t\t\t} finally {\r\n\t\t\t\t\t\t\t\tif (progressDlg != null) {\r\n\t\t\t\t\t\t\t\t\tprogressDlg.dismiss();\r\n\t\t\t\t\t\t\t\t\tprogressDlg = null;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\timpl.run();\r\n\t\t\t} else {\r\n\t\t\t\thelper.close();\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"3b5a535af9f1e93026a919b7ec3b8bf3c9679e42","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void main(String[] args) throws FSParseException, PeerParseException, CHKEncodeException, InvalidThresholdException, NodeInitException, ReferenceSignatureVerificationException, InterruptedException {\n        String name = \"realNodeRequestInsertTest\";\n        File wd = new File(name);\n        if(!FileUtil.removeAll(wd)) {\n        \tSystem.err.println(\"Mass delete failed, test may not be accurate.\");\n        \tSystem.exit(EXIT_CANNOT_DELETE_OLD_DATA);\n        }\n        wd.mkdir();\n        //NOTE: globalTestInit returns in ignored random source\n        //NodeStarter.globalTestInit(name, false, Logger.ERROR, \"freenet.node.Location:normal,freenet.node.simulator.RealNode:minor,freenet.node.Insert:MINOR,freenet.node.Request:MINOR,freenet.node.Node:MINOR\");\n        //NodeStarter.globalTestInit(name, false, Logger.ERROR, \"freenet.node.Location:MINOR,freenet.io.comm:MINOR,freenet.node.NodeDispatcher:MINOR,freenet.node.simulator:MINOR,freenet.node.PeerManager:MINOR,freenet.node.RequestSender:MINOR\");\n        //NodeStarter.globalTestInit(name, false, Logger.ERROR, \"freenet.node.FNP:MINOR,freenet.node.Packet:MINOR,freenet.io.comm:MINOR,freenet.node.PeerNode:MINOR,freenet.node.DarknetPeerNode:MINOR\");\n        NodeStarter.globalTestInit(name, false, Logger.ERROR, \"\");\n        System.out.println(\"Insert/retrieve test\");\n        System.out.println();\n        DummyRandomSource random = new DummyRandomSource();\n        //DiffieHellman.init(random);\n        Node[] nodes = new Node[NUMBER_OF_NODES];\n        Logger.normal(RealNodeRoutingTest.class, \"Creating nodes...\");\n        Executor executor = new PooledExecutor();\n        for(int i=0;i<NUMBER_OF_NODES;i++) {\n            nodes[i] = \n            \tNodeStarter.createTestNode(5001+i, name, false, true, false, MAX_HTL, 20 /* 5% */, random, executor, 500*NUMBER_OF_NODES, 256*1024, true, ENABLE_SWAPPING, false, ENABLE_ULPRS, ENABLE_PER_NODE_FAILURE_TABLES, ENABLE_SWAP_QUEUEING, ENABLE_PACKET_COALESCING, 12000);\n            Logger.normal(RealNodeRoutingTest.class, \"Created node \"+i);\n        }\n        \n        // Now link them up\n        makeKleinbergNetwork(nodes, START_WITH_IDEAL_LOCATIONS, DEGREE, FORCE_NEIGHBOUR_CONNECTIONS);\n\n        Logger.normal(RealNodeRoutingTest.class, \"Added random links\");\n        \n        for(int i=0;i<NUMBER_OF_NODES;i++) {\n            nodes[i].start(false);\n            System.err.println(\"Started node \"+i+\"/\"+nodes.length);\n        }\n        \n        waitForAllConnected(nodes);\n        \n        waitForPingAverage(0.95, nodes, random, MAX_PINGS, 1000);\n        \n        System.out.println();\n        System.out.println(\"Ping average > 95%, lets do some inserts/requests\");\n        System.out.println();\n        int requestNumber = 0;\n        RunningAverage requestsAvg = new SimpleRunningAverage(100, 0.0);\n        String baseString = System.currentTimeMillis() + \" \";\n\t\tint insertAttempts = 0;\n\t\tint insertSuccesses = 0;\n\t\tint fetchSuccesses = 0;\n        while(true) {\n            try {\n                requestNumber++;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e1) {\n                }\n                String dataString = baseString + requestNumber;\n                // Pick random node to insert to\n                int node1 = random.nextInt(NUMBER_OF_NODES);\n                Node randomNode = nodes[node1];\n                Logger.error(RealNodeRequestInsertTest.class,\"Inserting: \\\"\"+dataString+\"\\\" to \"+node1);\n                byte[] data = dataString.getBytes(\"UTF-8\");\n                ClientCHKBlock block;\n                block = ClientCHKBlock.encode(data, false, false, (short)-1, 0);\n                ClientCHK chk = (ClientCHK) block.getClientKey();\n                byte[] encData = block.getData();\n                byte[] encHeaders = block.getHeaders();\n                ClientCHKBlock newBlock = new ClientCHKBlock(encData, encHeaders, chk, true);\n                Logger.minor(RealNodeRequestInsertTest.class, \"Decoded: \"+new String(newBlock.memoryDecode()));\n                Logger.normal(RealNodeRequestInsertTest.class,\"CHK: \"+chk.getURI());\n                Logger.minor(RealNodeRequestInsertTest.class,\"Headers: \"+HexUtil.bytesToHex(block.getHeaders()));\n\t\t\t\ttry {\n\t\t\t\t\tinsertAttempts++;\n\t\t\t\t\trandomNode.clientCore.realPut(block, true);\n\t\t\t\t\tLogger.error(RealNodeRequestInsertTest.class, \"Inserted to \"+node1);\n\t\t\t\t\tLogger.minor(RealNodeRequestInsertTest.class, \"Data: \"+Fields.hashCode(encData)+\", Headers: \"+Fields.hashCode(encHeaders));\n\t\t\t\t\tinsertSuccesses++;\n\t\t\t\t} catch (freenet.node.LowLevelPutException putEx) {\n\t\t\t\t\tLogger.error(RealNodeRequestInsertTest.class, \"Insert failed: \"+ putEx);\n\t\t\t\t\tSystem.err.println(\"Insert failed: \"+ putEx);\n\t\t\t\t\tSystem.exit(EXIT_INSERT_FAILED);\n\t\t\t\t}\n                // Pick random node to request from\n                int node2;\n                do {\n                    node2 = random.nextInt(NUMBER_OF_NODES);\n                } while(node2 == node1);\n                Node fetchNode = nodes[node2];\n                block = (ClientCHKBlock) fetchNode.clientCore.realGetKey((ClientKey) chk, false, true, false);\n                if(block == null) {\n\t\t\t\t\tint percentSuccess=100*fetchSuccesses/insertAttempts;\n                    Logger.error(RealNodeRequestInsertTest.class, \"Fetch #\"+requestNumber+\" FAILED (\"+percentSuccess+\"%); from \"+node2);\n                    requestsAvg.report(0.0);\n                    System.exit(EXIT_REQUEST_FAILED);\n                } else {\n                    byte[] results = block.memoryDecode();\n                    requestsAvg.report(1.0);\n                    if(Arrays.equals(results, data)) {\n\t\t\t\t\t\tfetchSuccesses++;\n\t\t\t\t\t\tint percentSuccess=100*fetchSuccesses/insertAttempts;\n                        Logger.error(RealNodeRequestInsertTest.class, \"Fetch #\"+requestNumber+\" succeeded (\"+percentSuccess+\"%): \"+new String(results));\n                        System.err.println(\"Fetch #\"+requestNumber+\" succeeded (\"+percentSuccess+\"%): \\\"\"+new String(results)+'\\\"');\n                        if(fetchSuccesses == TARGET_SUCCESSES) {\n                        \tSystem.err.println(\"Succeeded, \"+TARGET_SUCCESSES+\" successful fetches\");\n                        \tSystem.exit(0);\n                        }\n                    } else {\n                        Logger.error(RealNodeRequestInsertTest.class, \"Returned invalid data!: \"+new String(results));\n                        System.err.println(\"Returned invalid data!: \"+new String(results));\n                        System.exit(EXIT_BAD_DATA);\n                    }\n                }\n                StringBuffer load = new StringBuffer(\"Running UIDs for nodes: \");\n                int totalRunningUIDs = 0;\n                int totalRunningUIDsAlt = 0;\n                Vector runningUIDsList = new Vector(); // <Long>\n                for(int i=0;i<nodes.length;i++) {\n                \tload.append(i);\n                \tload.append(':');\n                \tnodes[i].addRunningUIDs(runningUIDsList);\n                \tint runningUIDs = nodes[i].getTotalRunningUIDs();\n                \tint runningUIDsAlt = nodes[i].getTotalRunningUIDsAlt();\n                \ttotalRunningUIDs += runningUIDs;\n                \ttotalRunningUIDsAlt += runningUIDsAlt;\n                \tload.append(totalRunningUIDs);\n                \tload.append(':');\n                \tload.append(totalRunningUIDsAlt);\n                \tif(i != nodes.length-1)\n                \t\tload.append(' ');\n                }\n                System.err.println(load.toString());\n                if(totalRunningUIDs != 0)\n                \tSystem.err.println(\"Still running UIDs: \"+totalRunningUIDs);\n                if(totalRunningUIDsAlt != 0)\n                \tSystem.err.println(\"Still running UIDs (alt): \"+totalRunningUIDsAlt);\n                if(!runningUIDsList.isEmpty()) {\n                \tSystem.err.println(\"List of running UIDs: \"+StringArray.toString(runningUIDsList.toArray()));\n                }\n            } catch (Throwable t) {\n                Logger.error(RealNodeRequestInsertTest.class, \"Caught \"+t, t);\n            }\n        }\n    }","id":32905,"modified_method":"public static void main(String[] args) throws FSParseException, PeerParseException, CHKEncodeException, InvalidThresholdException, NodeInitException, ReferenceSignatureVerificationException, InterruptedException {\n        String name = \"realNodeRequestInsertTest\";\n        File wd = new File(name);\n        if(!FileUtil.removeAll(wd)) {\n        \tSystem.err.println(\"Mass delete failed, test may not be accurate.\");\n        \tSystem.exit(EXIT_CANNOT_DELETE_OLD_DATA);\n        }\n        wd.mkdir();\n        //NOTE: globalTestInit returns in ignored random source\n        //NodeStarter.globalTestInit(name, false, Logger.ERROR, \"freenet.node.Location:normal,freenet.node.simulator.RealNode:minor,freenet.node.Insert:MINOR,freenet.node.Request:MINOR,freenet.node.Node:MINOR\");\n        //NodeStarter.globalTestInit(name, false, Logger.ERROR, \"freenet.node.Location:MINOR,freenet.io.comm:MINOR,freenet.node.NodeDispatcher:MINOR,freenet.node.simulator:MINOR,freenet.node.PeerManager:MINOR,freenet.node.RequestSender:MINOR\");\n        //NodeStarter.globalTestInit(name, false, Logger.ERROR, \"freenet.node.FNP:MINOR,freenet.node.Packet:MINOR,freenet.io.comm:MINOR,freenet.node.PeerNode:MINOR,freenet.node.DarknetPeerNode:MINOR\");\n        NodeStarter.globalTestInit(name, false, Logger.ERROR, \"\");\n        System.out.println(\"Insert/retrieve test\");\n        System.out.println();\n        DummyRandomSource random = new DummyRandomSource();\n        //DiffieHellman.init(random);\n        Node[] nodes = new Node[NUMBER_OF_NODES];\n        Logger.normal(RealNodeRoutingTest.class, \"Creating nodes...\");\n        Executor executor = new PooledExecutor();\n        for(int i=0;i<NUMBER_OF_NODES;i++) {\n            nodes[i] = \n            \tNodeStarter.createTestNode(5001+i, name, false, true, false, MAX_HTL, 20 /* 5% */, random, executor, 500*NUMBER_OF_NODES, 256*1024, true, ENABLE_SWAPPING, false, ENABLE_ULPRS, ENABLE_PER_NODE_FAILURE_TABLES, ENABLE_SWAP_QUEUEING, ENABLE_PACKET_COALESCING, 12000);\n            Logger.normal(RealNodeRoutingTest.class, \"Created node \"+i);\n        }\n        \n        // Now link them up\n        makeKleinbergNetwork(nodes, START_WITH_IDEAL_LOCATIONS, DEGREE, FORCE_NEIGHBOUR_CONNECTIONS);\n\n        Logger.normal(RealNodeRoutingTest.class, \"Added random links\");\n        \n        for(int i=0;i<NUMBER_OF_NODES;i++) {\n            nodes[i].start(false);\n            System.err.println(\"Started node \"+i+\"/\"+nodes.length);\n        }\n        \n        waitForAllConnected(nodes);\n        \n        waitForPingAverage(0.95, nodes, random, MAX_PINGS, 1000);\n        \n        System.out.println();\n        System.out.println(\"Ping average > 95%, lets do some inserts/requests\");\n        System.out.println();\n        int requestNumber = 0;\n        RunningAverage requestsAvg = new SimpleRunningAverage(100, 0.0);\n        String baseString = System.currentTimeMillis() + \" \";\n\t\tint insertAttempts = 0;\n\t\tint insertSuccesses = 0;\n\t\tint fetchSuccesses = 0;\n        while(true) {\n            try {\n                requestNumber++;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e1) {\n                }\n                String dataString = baseString + requestNumber;\n                // Pick random node to insert to\n                int node1 = random.nextInt(NUMBER_OF_NODES);\n                Node randomNode = nodes[node1];\n                //Logger.error(RealNodeRequestInsertTest.class,\"Inserting: \\\"\"+dataString+\"\\\" to \"+node1);\n                \n                boolean isSSK = requestNumber % 2 == 1;\n                \n                FreenetURI testKey;\n                ClientKey insertKey;\n                ClientKey fetchKey;\n                ClientKeyBlock block;\n                \n            \tbyte[] buf = dataString.getBytes(\"UTF-8\");\n                if(isSSK) {\n                \ttestKey = new FreenetURI(\"KSK\", dataString);\n                \t\n                \tinsertKey = InsertableClientSSK.create(testKey);\n                \tfetchKey = ClientKSK.create(testKey);\n                \t\n                \tblock = ((InsertableClientSSK)insertKey).encode(new ArrayBucket(buf), false, false, (short)-1, buf.length, random);\n                } else {\n                \tblock = ClientCHKBlock.encode(buf, false, false, (short)-1, buf.length);\n                \tinsertKey = fetchKey = block.getClientKey();\n                \ttestKey = insertKey.getURI();\n                }\n                \n                System.err.println();\n                System.err.println(\"Created random test key \"+testKey+\" = \"+fetchKey.getNodeKey());\n                System.err.println();\n                \n                byte[] data = dataString.getBytes(\"UTF-8\");\n                Logger.minor(RealNodeRequestInsertTest.class, \"Decoded: \"+new String(block.memoryDecode()));\n                Logger.normal(RealNodeRequestInsertTest.class,\"Insert Key: \"+insertKey.getURI());\n                Logger.normal(RealNodeRequestInsertTest.class,\"Fetch Key: \"+fetchKey.getURI());\n\t\t\t\ttry {\n\t\t\t\t\tinsertAttempts++;\n\t\t\t\t\trandomNode.clientCore.realPut(block, true);\n\t\t\t\t\tLogger.error(RealNodeRequestInsertTest.class, \"Inserted to \"+node1);\n\t\t\t\t\tinsertSuccesses++;\n\t\t\t\t} catch (freenet.node.LowLevelPutException putEx) {\n\t\t\t\t\tLogger.error(RealNodeRequestInsertTest.class, \"Insert failed: \"+ putEx);\n\t\t\t\t\tSystem.err.println(\"Insert failed: \"+ putEx);\n\t\t\t\t\tSystem.exit(EXIT_INSERT_FAILED);\n\t\t\t\t}\n                // Pick random node to request from\n                int node2;\n                do {\n                    node2 = random.nextInt(NUMBER_OF_NODES);\n                } while(node2 == node1);\n                Node fetchNode = nodes[node2];\n                block = (ClientCHKBlock) fetchNode.clientCore.realGetKey(fetchKey, false, true, false);\n                if(block == null) {\n\t\t\t\t\tint percentSuccess=100*fetchSuccesses/insertAttempts;\n                    Logger.error(RealNodeRequestInsertTest.class, \"Fetch #\"+requestNumber+\" FAILED (\"+percentSuccess+\"%); from \"+node2);\n                    requestsAvg.report(0.0);\n                    System.exit(EXIT_REQUEST_FAILED);\n                } else {\n                    byte[] results = block.memoryDecode();\n                    requestsAvg.report(1.0);\n                    if(Arrays.equals(results, data)) {\n\t\t\t\t\t\tfetchSuccesses++;\n\t\t\t\t\t\tint percentSuccess=100*fetchSuccesses/insertAttempts;\n                        Logger.error(RealNodeRequestInsertTest.class, \"Fetch #\"+requestNumber+\" succeeded (\"+percentSuccess+\"%): \"+new String(results));\n                        System.err.println(\"Fetch #\"+requestNumber+\" succeeded (\"+percentSuccess+\"%): \\\"\"+new String(results)+'\\\"');\n                        if(fetchSuccesses == TARGET_SUCCESSES) {\n                        \tSystem.err.println(\"Succeeded, \"+TARGET_SUCCESSES+\" successful fetches\");\n                        \tSystem.exit(0);\n                        }\n                    } else {\n                        Logger.error(RealNodeRequestInsertTest.class, \"Returned invalid data!: \"+new String(results));\n                        System.err.println(\"Returned invalid data!: \"+new String(results));\n                        System.exit(EXIT_BAD_DATA);\n                    }\n                }\n                StringBuffer load = new StringBuffer(\"Running UIDs for nodes: \");\n                int totalRunningUIDs = 0;\n                int totalRunningUIDsAlt = 0;\n                Vector runningUIDsList = new Vector(); // <Long>\n                for(int i=0;i<nodes.length;i++) {\n                \tload.append(i);\n                \tload.append(':');\n                \tnodes[i].addRunningUIDs(runningUIDsList);\n                \tint runningUIDs = nodes[i].getTotalRunningUIDs();\n                \tint runningUIDsAlt = nodes[i].getTotalRunningUIDsAlt();\n                \ttotalRunningUIDs += runningUIDs;\n                \ttotalRunningUIDsAlt += runningUIDsAlt;\n                \tload.append(totalRunningUIDs);\n                \tload.append(':');\n                \tload.append(totalRunningUIDsAlt);\n                \tif(i != nodes.length-1)\n                \t\tload.append(' ');\n                }\n                System.err.println(load.toString());\n                if(totalRunningUIDs != 0)\n                \tSystem.err.println(\"Still running UIDs: \"+totalRunningUIDs);\n                if(totalRunningUIDsAlt != 0)\n                \tSystem.err.println(\"Still running UIDs (alt): \"+totalRunningUIDsAlt);\n                if(!runningUIDsList.isEmpty()) {\n                \tSystem.err.println(\"List of running UIDs: \"+StringArray.toString(runningUIDsList.toArray()));\n                }\n            } catch (Throwable t) {\n                Logger.error(RealNodeRequestInsertTest.class, \"Caught \"+t, t);\n            }\n        }\n    }","commit_id":"b8ea261e32fd0d1ed58a86fc55ea7f717dec1cf1","url":"https://github.com/freenet/fred"},{"original_method":"/** Attempt to encode the block, if necessary */\n\t@Override\n\tpublic void tryEncode(ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(resultingURI != null) return;\n\t\t\tif(finished) return;\n\t\t}\n\t\ttry {\n\t\t\tencode(context, false);\n\t\t} catch (InsertException e) {\n\t\t\tfail(e, context);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t// Don't requeue on BackgroundBlockEncoder.\n\t\t\t// Not necessary to do so (we'll ask again when we need it), and it'll probably just break again.\n\t\t}\n\t}","id":32906,"modified_method":"/** Attempt to encode the block, if necessary */\n\t@Override\n\tpublic void tryEncode(ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(resultingKey != null) return;\n\t\t\tif(finished) return;\n\t\t}\n\t\ttry {\n\t\t\tencode(context, false);\n\t\t} catch (InsertException e) {\n\t\t\tfail(e, context);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t// Don't requeue on BackgroundBlockEncoder.\n\t\t\t// Not necessary to do so (we'll ask again when we need it), and it'll probably just break again.\n\t\t}\n\t}","commit_id":"16ec173dd1a39b9941e3ea308c4c2dae5c5c93f4","url":"https://github.com/freenet/fred"},{"original_method":"public FreenetURI getURI(ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(resultingURI != null) {\n\t\t\t\treturn persistent ? resultingURI.clone() : resultingURI;\n\t\t\t}\n\t\t}\n\t\tgetBlock(context, true);\n\t\tsynchronized(this) {\n\t\t\t// FIXME not really necessary? resultingURI is never dropped, only set.\n\t\t\treturn persistent ? resultingURI.clone() : resultingURI;\n\t\t}\n\t}","id":32907,"modified_method":"public FreenetURI getURI(ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(resultingKey != null) {\n\t\t\t\treturn resultingKey.getURI();\n\t\t\t}\n\t\t}\n\t\tgetBlock(context, true);\n\t\tsynchronized(this) {\n\t\t\t// FIXME not really necessary? resultingKey is never dropped, only set.\n\t\t    return resultingKey.getURI();\n\t\t}\n\t}","commit_id":"16ec173dd1a39b9941e3ea308c4c2dae5c5c93f4","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized FreenetURI getURINoEncode() {\n\t\treturn resultingURI;\n\t}","id":32908,"modified_method":"public synchronized FreenetURI getURINoEncode() {\n\t\treturn resultingKey == null ? null : resultingKey.getURI();\n\t}","commit_id":"16ec173dd1a39b9941e3ea308c4c2dae5c5c93f4","url":"https://github.com/freenet/fred"},{"original_method":"protected void onEncode(final ClientKey key, final ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tif(resultingURI != null) return;\n\t\t\tresultingURI = key.getURI();\n\t\t}\n\t\tif(!persistent) {\n\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcb.onEncode(key, SingleBlockInserter.this, context);\n\t\t\t\t}\n\t\t\t}, \"Got URI\");\n\t\t} else {\n\t\t    context.jobRunner.queueNormalOrDrop(new PersistentJob() {\n\n                @Override\n                public boolean run(ClientContext context) {\n                    cb.onEncode(key, SingleBlockInserter.this, context);\n                    return false;\n                }\n\t\t        \n\t\t    });\n\t\t\tcb.onEncode(key, this, context);\n\t\t}\n\t}","id":32909,"modified_method":"protected void onEncode(final ClientKey key, final ClientContext context) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tif(resultingKey != null) return;\n\t\t\tresultingKey = key;\n\t\t}\n\t\tif(!persistent) {\n\t\t\tcontext.mainExecutor.execute(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcb.onEncode(key, SingleBlockInserter.this, context);\n\t\t\t\t}\n\t\t\t}, \"Got URI\");\n\t\t} else {\n\t\t    context.jobRunner.queueNormalOrDrop(new PersistentJob() {\n\n                @Override\n                public boolean run(ClientContext context) {\n                    cb.onEncode(key, SingleBlockInserter.this, context);\n                    return false;\n                }\n\t\t        \n\t\t    });\n\t\t\tcb.onEncode(key, this, context);\n\t\t}\n\t}","commit_id":"16ec173dd1a39b9941e3ea308c4c2dae5c5c93f4","url":"https://github.com/freenet/fred"},{"original_method":"protected ClientKeyBlock encode(ClientContext context, boolean calledByCB) throws InsertException {\n\t\tClientKeyBlock block;\n\t\tboolean shouldSend;\n\t\tsynchronized(this) {\n\t\t\tif(finished) return null;\n\t\t\tif(sourceData == null) {\n\t\t\t\tLogger.error(this, \"Source data is null on \"+this+\" but not finished!\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tblock = innerEncode(context.random);\n\t\t\tshouldSend = (resultingURI == null);\n\t\t\tresultingURI = block.getClientKey().getURI();\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+resultingURI+\" for \"+this+\" shouldSend=\"+shouldSend+\" dontSendEncoded=\"+dontSendEncoded);\n\t\tif(shouldSend && !dontSendEncoded)\n\t\t\tcb.onEncode(block.getClientKey(), this, context);\n\t\treturn block;\n\t}","id":32910,"modified_method":"protected ClientKeyBlock encode(ClientContext context, boolean calledByCB) throws InsertException {\n\t\tClientKeyBlock block;\n\t\tboolean shouldSend;\n\t\tsynchronized(this) {\n\t\t\tif(finished) return null;\n\t\t\tif(sourceData == null) {\n\t\t\t\tLogger.error(this, \"Source data is null on \"+this+\" but not finished!\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tblock = innerEncode(context.random);\n\t\t\tshouldSend = (resultingKey == null);\n\t\t\tresultingKey = block.getClientKey();\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+resultingKey.getURI()+\" for \"+this+\" shouldSend=\"+shouldSend+\" dontSendEncoded=\"+dontSendEncoded);\n\t\tif(shouldSend && !dontSendEncoded)\n\t\t\tcb.onEncode(block.getClientKey(), this, context);\n\t\treturn block;\n\t}","commit_id":"16ec173dd1a39b9941e3ea308c4c2dae5c5c93f4","url":"https://github.com/freenet/fred"},{"original_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(context, 1);\n\t\t\tcontainer.activate(blockFetchContext, 1);\n\t\t}\n\t\tif(codec == null)\n\t\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tif(persistent) {\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t// The FECCodec won't set them.\n\t\t\t\t// But they should be active.\n\t\t\t\tif(dataBlockStatus[i] != dataBuckets[i]) {\n\t\t\t\t\tlong theirID = container.ext().getID(dataBlockStatus[i]);\n\t\t\t\t\tlong ourID = container.ext().getID(dataBuckets[i]);\n\t\t\t\t\tif(theirID == ourID) {\n\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED IN DECODED SEGMENT!: our block: \"+dataBuckets[i]+\" block from decode \"+dataBlockStatus[i]+\" both have ID \"+ourID+\" = \"+theirID);\n\t\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Data block \"+i+\" is \"+dataBuckets[i]);\n\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is not stored!\");\n\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is inactive! : \"+dataBuckets[i]);\n\t\t\t\tif(dataBuckets[i] == null)\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is null!\");\n\t\t\t\telse if(dataBuckets[i].data == null)\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" has null data!\");\n\t\t\t\telse\n\t\t\t\t\tdataBuckets[i].data.storeTo(container);\n\t\t\t\tcontainer.store(dataBuckets[i]);\n\t\t\t}\n\t\t}\n\t\tif(crossCheckBlocks != 0) {\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tif(persistent) container.activate(dataBuckets[i], 1); // onFetched might deactivate blocks.\n\t\t\t\tif(dataBuckets[i].flag) {\n\t\t\t\t\t// New block. Might allow a cross-segment decode.\n\t\t\t\t\tif(persistent) container.activate(crossSegmentsByBlock[i], 1);\n\t\t\t\t\tcrossSegmentsByBlock[i].onFetched(this, i, container, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\tif(data == null) \n\t\t\t\tthrow new NullPointerException(\"Data bucket \"+i+\" of \"+dataBuckets.length+\" is null in onDecodedSegment\");\n\t\t\ttry {\n\t\t\t\tmaybeAddToBinaryBlob(data, null, i, container, context, \"FEC DECODE\");\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfail(e, container, context, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\tfinished = true;\n\t\tif(persistent) container.store(this);\n\t\tif(persistent) {\n\t\t\tboolean fin;\n\t\t\tsynchronized(this) {\n\t\t\t\tfin = fetcherFinished;\n\t\t\t}\n\t\t\tif(fin) {\n\t\t\t\tencoderFinished(container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT || !isCollectingBinaryBlob()) {\n\t\t\tif(persistent) container.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent) container.deactivate(parentFetcher, 1);\n\t\t}\n\t\t// Leave active before queueing\n\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(parent, 1);\n\t\t\t\tcontainer.deactivate(context, 1);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// FIXME don't heal if ignoreLastBlock.\n\t\tBucket lastBlock = dataBuckets[dataBuckets.length-1].data;\n\t\tif(lastBlock != null) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(lastBlock, 1);\n\t\t\tif(lastBlock.size() != CHKBlock.DATA_LENGTH) {\n\t\t\t\ttry {\n\t\t\t\t\tdataBuckets[dataBuckets.length-1].data =\n\t\t\t\t\t\tBucketTools.pad(lastBlock, CHKBlock.DATA_LENGTH, context.getBucketFactory(persistent), (int) lastBlock.size());\n\t\t\t\t\tlastBlock.free();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tlastBlock.removeFrom(container);\n\t\t\t\t\t\tdataBuckets[dataBuckets.length-1].storeTo(container);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tfail(new FetchException(FetchException.BUCKET_ERROR, e), container, context, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Encode any check blocks we don't have\n\t\ttry {\n\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(persistent), this, false, parent.getPriorityClass(), persistent),\n\t\t\t\tcontext.fecQueue, container);\n\t\tif(persistent) {\n\t\t\tcontainer.deactivate(parent, 1);\n\t\t\tcontainer.deactivate(context, 1);\n\t\t}\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t}\n\t}","id":32911,"modified_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(context, 1);\n\t\t\tcontainer.activate(blockFetchContext, 1);\n\t\t}\n\t\tif(codec == null)\n\t\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tif(persistent) {\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t// The FECCodec won't set them.\n\t\t\t\t// But they should be active.\n\t\t\t\tif(dataBlockStatus[i] != dataBuckets[i]) {\n\t\t\t\t\tlong theirID = container.ext().getID(dataBlockStatus[i]);\n\t\t\t\t\tlong ourID = container.ext().getID(dataBuckets[i]);\n\t\t\t\t\tif(theirID == ourID) {\n\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED IN DECODED SEGMENT!: our block: \"+dataBuckets[i]+\" block from decode \"+dataBlockStatus[i]+\" both have ID \"+ourID+\" = \"+theirID);\n\t\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Data block \"+i+\" is \"+dataBuckets[i]);\n\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is not stored!\");\n\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is inactive! : \"+dataBuckets[i]);\n\t\t\t\tif(dataBuckets[i] == null)\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is null!\");\n\t\t\t\telse if(dataBuckets[i].data == null)\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" has null data!\");\n\t\t\t\telse\n\t\t\t\t\tdataBuckets[i].data.storeTo(container);\n\t\t\t\tcontainer.store(dataBuckets[i]);\n\t\t\t}\n\t\t}\n\t\tif(crossCheckBlocks != 0) {\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tif(persistent) container.activate(dataBuckets[i], 1); // onFetched might deactivate blocks.\n\t\t\t\tif(dataBuckets[i].flag) {\n\t\t\t\t\t// New block. Might allow a cross-segment decode.\n\t\t\t\t\tif(persistent) container.activate(crossSegmentsByBlock[i], 1);\n\t\t\t\t\tcrossSegmentsByBlock[i].onFetched(this, i, container, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\tif(data == null) \n\t\t\t\tthrow new NullPointerException(\"Data bucket \"+i+\" of \"+dataBuckets.length+\" is null in onDecodedSegment\");\n\t\t\ttry {\n\t\t\t\tif(!maybeAddToBinaryBlob(data, null, i, container, context, \"FEC DECODE\")) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" FAILED TO DECODE CORRECTLY\");\n\t\t\t\t\t// Disable healing.\n\t\t\t\t\tdataRetries[i] = 0;\n\t\t\t\t}\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfail(e, container, context, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\tfinished = true;\n\t\tif(persistent) container.store(this);\n\t\tif(persistent) {\n\t\t\tboolean fin;\n\t\t\tsynchronized(this) {\n\t\t\t\tfin = fetcherFinished;\n\t\t\t}\n\t\t\tif(fin) {\n\t\t\t\tencoderFinished(container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT || !isCollectingBinaryBlob()) {\n\t\t\tif(persistent) container.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent) container.deactivate(parentFetcher, 1);\n\t\t}\n\t\t// Leave active before queueing\n\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(parent, 1);\n\t\t\t\tcontainer.deactivate(context, 1);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// FIXME don't heal if ignoreLastBlock.\n\t\tBucket lastBlock = dataBuckets[dataBuckets.length-1].data;\n\t\tif(lastBlock != null) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(lastBlock, 1);\n\t\t\tif(lastBlock.size() != CHKBlock.DATA_LENGTH) {\n\t\t\t\ttry {\n\t\t\t\t\tdataBuckets[dataBuckets.length-1].data =\n\t\t\t\t\t\tBucketTools.pad(lastBlock, CHKBlock.DATA_LENGTH, context.getBucketFactory(persistent), (int) lastBlock.size());\n\t\t\t\t\tlastBlock.free();\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tlastBlock.removeFrom(container);\n\t\t\t\t\t\tdataBuckets[dataBuckets.length-1].storeTo(container);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tfail(new FetchException(FetchException.BUCKET_ERROR, e), container, context, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Encode any check blocks we don't have\n\t\ttry {\n\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(persistent), this, false, parent.getPriorityClass(), persistent),\n\t\t\t\tcontext.fecQueue, container);\n\t\tif(persistent) {\n\t\t\tcontainer.deactivate(parent, 1);\n\t\t\tcontainer.deactivate(context, 1);\n\t\t}\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t}\n\t}","commit_id":"cdd4a175bab7f4e8f1c13de8fd632522dc50ba95","url":"https://github.com/freenet/fred"},{"original_method":"public boolean onSuccess(Bucket data, int blockNo, ClientCHKBlock block, ObjectContainer container, ClientContext context, SplitFileFetcherSubSegment sub) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tif(data == null) throw new NullPointerException();\n\t\t// FIXME RECONSTRUCT BLOCK FOR BINARY BLOB.\n\t\t// Also can serve as an integrity check - if the key generated is wrong something is busted.\n\t\t// Probably only worth the effort if we are actually adding to a binary blob???\n//\t\tif(block == null) {\n//\t\t\tif(logMINOR) Logger.minor(this, \"Reconstructing block from cross-segment decode\");\n//\t\t\tblock = encode(data, blockNo);\n//\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Fetched block \"+blockNo+\" in \"+this+\" data=\"+dataBuckets.length+\" check=\"+checkBuckets.length);\n\t\ttry {\n\t\t\tmaybeAddToBinaryBlob(data, block, blockNo, container, context, block == null ? \"CROSS-SEGMENT FEC\" : \"UNKNOWN\");\n\t\t} catch (FetchException e) {\n\t\t\tfail(e, container, context, false);\n\t\t}\n\t\t// No need to unregister key, because it will be cleared in tripPendingKey().\n\t\tshort result = onSuccessInner(data, blockNo, container, context);\n\t\tif(result == (short)-1) return false;\n\t\tfinishOnSuccess(result, container, context);\n\t\treturn true;\n\t}","id":32912,"modified_method":"public boolean onSuccess(Bucket data, int blockNo, ClientCHKBlock block, ObjectContainer container, ClientContext context, SplitFileFetcherSubSegment sub) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tif(data == null) throw new NullPointerException();\n\t\t// FIXME RECONSTRUCT BLOCK FOR BINARY BLOB.\n\t\t// Also can serve as an integrity check - if the key generated is wrong something is busted.\n\t\t// Probably only worth the effort if we are actually adding to a binary blob???\n//\t\tif(block == null) {\n//\t\t\tif(logMINOR) Logger.minor(this, \"Reconstructing block from cross-segment decode\");\n//\t\t\tblock = encode(data, blockNo);\n//\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Fetched block \"+blockNo+\" in \"+this+\" data=\"+dataBuckets.length+\" check=\"+checkBuckets.length);\n\t\ttry {\n\t\t\tif(!maybeAddToBinaryBlob(data, block, blockNo, container, context, block == null ? \"CROSS-SEGMENT FEC\" : \"UNKNOWN\")) {\n\t\t\t\tif(block == null) {\n\t\t\t\t\t// Cross-segment, just return false.\n\t\t\t\t\tLogger.error(this, \"CROSS-SEGMENT DECODED/ENCODED BLOCK INVALID: \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tLogger.error(this, \"DATA BLOCK INVALID: \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\tthis.onFatalFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Invalid block\"), blockNo, null, container, context);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (FetchException e) {\n\t\t\tfail(e, container, context, false);\n\t\t}\n\t\t// No need to unregister key, because it will be cleared in tripPendingKey().\n\t\tshort result = onSuccessInner(data, blockNo, container, context);\n\t\tif(result == (short)-1) return false;\n\t\tfinishOnSuccess(result, container, context);\n\t\treturn true;\n\t}","commit_id":"cdd4a175bab7f4e8f1c13de8fd632522dc50ba95","url":"https://github.com/freenet/fred"},{"original_method":"private void maybeAddToBinaryBlob(Bucket data, ClientCHKBlock block, int blockNo, ObjectContainer container, ClientContext context, String dataSource) throws FetchException {\n\t\tif(parent instanceof ClientGetter || FORCE_CHECK_FEC_KEYS) {\n\t\t\tif(((ClientGetter)parent).collectingBinaryBlob() || FORCE_CHECK_FEC_KEYS) {\n\t\t\t\ttry {\n\t\t\t\t\t// Note: dontCompress is true. if false we need to know the codec it was compresssed to get a proper blob\n\t\t\t\t\tbyte[] buf = BucketTools.toByteArray(data);\n\t\t\t\t\tif(!(buf.length == CHKBlock.DATA_LENGTH)) {\n\t\t\t\t\t\t// All new splitfile inserts insert only complete blocks even at the end.\n\t\t\t\t\t\tif((!ignoreLastDataBlock) || (blockNo != dataKeys.length-1))\n\t\t\t\t\t\t\tLogger.error(this, \"Block is too small: \"+buf.length);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(block == null) {\n\t\t\t\t\t\tblock = \n\t\t\t\t\t\t\tClientCHKBlock.encodeSplitfileBlock(buf, forceCryptoKey, cryptoAlgorithm);\n\t\t\t\t\t}\n\t\t\t\t\tClientCHK key = getBlockKey(blockNo, container);\n\t\t\t\t\tif(key != null) {\n\t\t\t\t\t\tif(!(key.equals(block.getClientKey()))) {\n\t\t\t\t\t\t\tif(ignoreLastDataBlock && blockNo == dataKeys.length-1 && dataSource.equals(\"FEC DECODE\")) {\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Last block wrong key, ignored because expected due to padding issues\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLogger.error(this, \"INVALID KEY FROM \"+dataSource+\": Block \"+blockNo+\" (data \"+dataKeys.length+\" check \"+checkKeys.length+\" ignore last block=\"+ignoreLastDataBlock+\") : key \"+block.getClientKey()+\" should be \"+key, new Exception(\"error\"));\n\t\t\t\t\t\t\t\tthis.onFatalFailure(new FetchException(FetchException.INTERNAL_ERROR, \"Invalid block from \"+dataSource), blockNo, null, container, context);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Verified key for block \"+blockNo+\" from \"+dataSource);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(dataSource.equals(\"FEC ENCODE\") || dataSource.equals(\"FEC DECODE\")) {\n\t\t\t\t\t\t\t// Ignore. FIXME Probably we should not delete the keys until after the encode??? Back compatibility issues maybe though...\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Key is null for block \"+blockNo+\" when checking key / adding to binary blob, key source is \"+dataSource, new Exception(\"error\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLogger.error(this, \"Key is null for block \"+blockNo+\" when checking key / adding to binary blob, key source is \"+dataSource, new Exception(\"error\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(parent instanceof ClientGetter) {\n\t\t\t\t\t\t((ClientGetter)parent).addKeyToBinaryBlob(block, container, context);\n\t\t\t\t\t}\n\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to encode (collecting binary blob) block \"+blockNo+\": \"+e, e);\n\t\t\t\t\tthrow new FetchException(FetchException.INTERNAL_ERROR, \"Failed to encode for binary blob: \"+e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Failed to encode for binary blob: \"+e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":32913,"modified_method":"private boolean maybeAddToBinaryBlob(Bucket data, ClientCHKBlock block, int blockNo, ObjectContainer container, ClientContext context, String dataSource) throws FetchException {\n\t\tif(parent instanceof ClientGetter || FORCE_CHECK_FEC_KEYS) {\n\t\t\tif(((ClientGetter)parent).collectingBinaryBlob() || FORCE_CHECK_FEC_KEYS) {\n\t\t\t\ttry {\n\t\t\t\t\t// Note: dontCompress is true. if false we need to know the codec it was compresssed to get a proper blob\n\t\t\t\t\tbyte[] buf = BucketTools.toByteArray(data);\n\t\t\t\t\tif(!(buf.length == CHKBlock.DATA_LENGTH)) {\n\t\t\t\t\t\t// All new splitfile inserts insert only complete blocks even at the end.\n\t\t\t\t\t\tif((!ignoreLastDataBlock) || (blockNo != dataKeys.length-1))\n\t\t\t\t\t\t\tLogger.error(this, \"Block is too small: \"+buf.length);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(block == null) {\n\t\t\t\t\t\tblock = \n\t\t\t\t\t\t\tClientCHKBlock.encodeSplitfileBlock(buf, forceCryptoKey, cryptoAlgorithm);\n\t\t\t\t\t}\n\t\t\t\t\tClientCHK key = getBlockKey(blockNo, container);\n\t\t\t\t\tif(key != null) {\n\t\t\t\t\t\tif(!(key.equals(block.getClientKey()))) {\n\t\t\t\t\t\t\tif(ignoreLastDataBlock && blockNo == dataKeys.length-1 && dataSource.equals(\"FEC DECODE\")) {\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Last block wrong key, ignored because expected due to padding issues\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLogger.error(this, \"INVALID KEY FROM \"+dataSource+\": Block \"+blockNo+\" (data \"+dataKeys.length+\" check \"+checkKeys.length+\" ignore last block=\"+ignoreLastDataBlock+\") : key \"+block.getClientKey().getURI()+\" should be \"+key.getURI(), new Exception(\"error\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Verified key for block \"+blockNo+\" from \"+dataSource);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(dataSource.equals(\"FEC ENCODE\") || dataSource.equals(\"FEC DECODE\")) {\n\t\t\t\t\t\t\t// Ignore. FIXME Probably we should not delete the keys until after the encode??? Back compatibility issues maybe though...\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Key is null for block \"+blockNo+\" when checking key / adding to binary blob, key source is \"+dataSource, new Exception(\"error\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLogger.error(this, \"Key is null for block \"+blockNo+\" when checking key / adding to binary blob, key source is \"+dataSource, new Exception(\"error\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(parent instanceof ClientGetter) {\n\t\t\t\t\t\t((ClientGetter)parent).addKeyToBinaryBlob(block, container, context);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (CHKEncodeException e) {\n\t\t\t\t\tLogger.error(this, \"Failed to encode (collecting binary blob) block \"+blockNo+\": \"+e, e);\n\t\t\t\t\tthrow new FetchException(FetchException.INTERNAL_ERROR, \"Failed to encode for binary blob: \"+e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Failed to encode for binary blob: \"+e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true; // Assume it is encoded correctly.\n\t}","commit_id":"cdd4a175bab7f4e8f1c13de8fd632522dc50ba95","url":"https://github.com/freenet/fred"},{"original_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\ttry {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tBucket wrapper = queueHeal(data, container, context);\n\t\t\t\t\tif(wrapper != data) {\n\t\t\t\t\t\tassert(!persistent);\n\t\t\t\t\t\tdataBuckets[i].setData(wrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmaybeAddToBinaryBlob(data, null, i+dataKeys.length, container, context, \"FEC ENCODE\");\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tBucket wrapper = queueHeal(data, container, context);\n\t\t\t\t\tif(wrapper != data) {\n\t\t\t\t\t\tassert(!persistent);\n\t\t\t\t\t\twrapper.free();\n\t\t\t\t\t}\n\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tcheckBuckets[i].data = null;\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcheckBuckets[i].removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tif(persistent && checkKeys[i] != null)\n\t\t\t\t\tcheckKeys[i].removeFrom(container);\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t\tif(persistent && !fetcherFinished) {\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Checked blocks.\");\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob()) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t\t} finally {\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t}\n\t}","id":32914,"modified_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\ttry {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tBucket wrapper = queueHeal(data, container, context);\n\t\t\t\t\tif(wrapper != data) {\n\t\t\t\t\t\tassert(!persistent);\n\t\t\t\t\t\tdataBuckets[i].setData(wrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\ttry {\n\t\t\t\t\tif(!maybeAddToBinaryBlob(data, null, i+dataKeys.length, container, context, \"FEC ENCODE\")) {\n\t\t\t\t\t\theal = false;\n\t\t\t\t\t\tLogger.error(this, \"FAILED TO ENCODE CORRECTLY so not healing check block \"+i);\n\t\t\t\t\t}\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(heal) {\n\t\t\t\t\tBucket wrapper = queueHeal(data, container, context);\n\t\t\t\t\tif(wrapper != data) {\n\t\t\t\t\t\tassert(!persistent);\n\t\t\t\t\t\twrapper.free();\n\t\t\t\t\t}\n\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tcheckBuckets[i].data = null;\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcheckBuckets[i].removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tif(persistent && checkKeys[i] != null)\n\t\t\t\t\tcheckKeys[i].removeFrom(container);\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t\tif(persistent && !fetcherFinished) {\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Checked blocks.\");\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob()) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t\t} finally {\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t}\n\t}","commit_id":"cdd4a175bab7f4e8f1c13de8fd632522dc50ba95","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void endExtension(String id, String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        // TODO: add support for complete extension\n\n        ExtensionId extensionId = new ExtensionId(id, version);\n\n        try {\n            LocalExtension localExtension = this.localRepository.getLocalExtension(extensionId);\n            if (localExtension == null) {\n                Extension extension;\n                try {\n                    // Try to find and download the extension from a repository\n                    extension = this.extensionRepository.resolve(extensionId);\n                } catch (ResolveException e) {\n                    this.logger.debug(\"Can't find extension [{}]\", extensionId, e);\n\n                    // FIXME: Create a dummy extension. Need support for partial/lazy extension.\n                    return;\n                }\n\n                localExtension = this.localRepository.storeExtension(extension);\n            }\n\n            // Register the extension as installed\n            String namespace = getCurrentNamespace();\n            InstalledExtension installedExtension =\n                this.installedRepository.getInstalledExtension(localExtension.getId());\n            if (installedExtension == null || !installedExtension.isInstalled(namespace)) {\n                this.installedRepository.installExtension(localExtension, namespace, false);\n            }\n        } catch (Exception e) {\n            this.logger.error(\"Failed to register extenion [{}] from the XAR\", extensionId, e);\n        }\n    }","id":32915,"modified_method":"@Override\n    public void endExtension(String id, String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        // TODO: add support for complete extension\n\n        ExtensionId extensionId = new ExtensionId(id, version);\n\n        try {\n            LocalExtension localExtension = this.localRepository.getLocalExtension(extensionId);\n            if (localExtension == null) {\n                Extension extension;\n                try {\n                    // Try to find and download the extension from a repository\n                    extension = this.extensionRepository.resolve(extensionId);\n                } catch (ResolveException e) {\n                    this.logger.debug(\"Can't find extension [{}]\", extensionId, e);\n\n                    // FIXME: Create a dummy extension. Need support for partial/lazy extension.\n                    return;\n                }\n\n                localExtension = this.localRepository.storeExtension(extension);\n            }\n\n\n            String namespace = getCurrentNamespace();\n\n            // Make sure it's not already there\n            // TODO: should probably make it configurable\n            if (installedRepository.getInstalledExtension(localExtension.getId().getId(), namespace) == null) {\n                for (String feature : localExtension.getFeatures()) {\n                    if (installedRepository.getInstalledExtension(feature, namespace) != null) {\n                        // Already exist so don't register it or it could create a mess\n                        return;\n                    }\n                }\n            } else {\n                return;\n            }\n\n            // Register the extension as installed\n            installedRepository.installExtension(localExtension, namespace, false);\n        } catch (Exception e) {\n            this.logger.error(\"Failed to register extenion [{}] from the XAR\", extensionId, e);\n        }\n    }","commit_id":"528e648e649bdf17c6498e5373d955b5d80a479e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void registerExtension(XWikiContext context)\n    {\n        // Register the package as extension if it's one\n        if (isInstallExension() && StringUtils.isNotEmpty(getExtensionId()) && StringUtils.isNotEmpty(getVersion())) {\n            ExtensionId extensionId = new ExtensionId(getExtensionId(), getVersion());\n\n            try {\n                LocalExtensionRepository localRepository = Utils.getComponent(LocalExtensionRepository.class);\n\n                LocalExtension localExtension = localRepository.getLocalExtension(extensionId);\n                if (localExtension == null) {\n                    Extension extension;\n                    try {\n                        // Try to find and download the extension from a repository\n                        extension = Utils.getComponent(ExtensionRepositoryManager.class).resolve(extensionId);\n                    } catch (ResolveException e) {\n                        LOGGER.debug(\"Can't find extension [{}]\", extensionId, e);\n\n                        // FIXME: Create a dummy extension. Need support for partial/lazy extension.\n                        return;\n                    }\n\n                    localExtension = localRepository.storeExtension(extension);\n                }\n\n                // Register the extension as installed\n                InstalledExtensionRepository installedRepository =\n                    Utils.getComponent(InstalledExtensionRepository.class);\n                String namespace = \"wiki:\" + context.getWikiId();\n                InstalledExtension installedExtension =\n                    installedRepository.getInstalledExtension(localExtension.getId());\n                if (installedExtension == null || !installedExtension.isInstalled(namespace)) {\n                    installedRepository.installExtension(localExtension, namespace, false);\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to register extenion [{}] from the XAR\", extensionId, e);\n            }\n        }\n    }","id":32916,"modified_method":"private void registerExtension(XWikiContext context)\n    {\n        // Register the package as extension if it's one\n        if (isInstallExension() && StringUtils.isNotEmpty(getExtensionId()) && StringUtils.isNotEmpty(getVersion())) {\n            ExtensionId extensionId = new ExtensionId(getExtensionId(), getVersion());\n\n            try {\n                LocalExtensionRepository localRepository = Utils.getComponent(LocalExtensionRepository.class);\n\n                LocalExtension localExtension = localRepository.getLocalExtension(extensionId);\n                if (localExtension == null) {\n                    Extension extension;\n                    try {\n                        // Try to find and download the extension from a repository\n                        extension = Utils.getComponent(ExtensionRepositoryManager.class).resolve(extensionId);\n                    } catch (ResolveException e) {\n                        LOGGER.debug(\"Can't find extension [{}]\", extensionId, e);\n\n                        // FIXME: Create a dummy extension. Need support for partial/lazy extension.\n                        return;\n                    }\n\n                    localExtension = localRepository.storeExtension(extension);\n                }\n\n                InstalledExtensionRepository installedRepository =\n                    Utils.getComponent(InstalledExtensionRepository.class);\n\n                String namespace = \"wiki:\" + context.getWikiId();\n\n                // Make sure it's not already there\n                if (installedRepository.getInstalledExtension(localExtension.getId().getId(), namespace) == null) {\n                    for (String feature : localExtension.getFeatures()) {\n                        if (installedRepository.getInstalledExtension(feature, namespace) != null) {\n                            // Already exist so don't register it or it could create a mess\n                            return;\n                        }\n                    }\n                } else {\n                    return;\n                }\n\n                // Register the extension as installed\n                installedRepository.installExtension(localExtension, namespace, false);\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to register extenion [{}] from the XAR\", extensionId, e);\n            }\n        }\n    }","commit_id":"528e648e649bdf17c6498e5373d955b5d80a479e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected AbstractJobStatus<DistributionRequest> createNewStatus(DistributionRequest request)\n    {\n        // TODO: make steps components automatically discovered so that any module can add custom steps\n\n        List<DistributionStepStatus> steps = new ArrayList<DistributionStepStatus>(3);\n\n        ExtensionId extensionUI = this.distributionManager.getUIExtensionId();\n\n        // Step 1: Install/upgrade main wiki UI\n\n        DistributionStepStatus step1 = new DistributionStepStatus(\"extension.mainui\");\n        steps.add(step1);\n        // Only if the UI is not already installed\n        if (extensionUI == null || this.installedRepository.getInstalledExtension(extensionUI) != null) {\n            step1.setUpdateState(UpdateState.COMPLETED);\n        }\n\n        // Step 2: Upgrade outdated extensions\n\n        DistributionStepStatus step2 = new DistributionStepStatus(\"extension.outdatedextensions\");\n        steps.add(step2);\n        step2.setUpdateState(UpdateState.COMPLETED);\n        // Upgrade outdated extensions only when there is outdated extensions\n        for (InstalledExtension extension : this.installedRepository.getInstalledExtensions()) {\n            Collection<String> namespaces = extension.getNamespaces();\n            if (namespaces == null) {\n                if (!extension.isValid(null)) {\n                    step2.setUpdateState(null);\n                    break;\n                }\n            } else {\n                for (String namespace : namespaces) {\n                    if (!extension.isValid(namespace)) {\n                        step2.setUpdateState(null);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Step 0: A welcome message. Only if there is actually something to do\n        for (DistributionStepStatus step : steps) {\n            if (step.getUpdateState() == null) {\n                steps.add(0, new DistributionStepStatus(\"welcome\"));\n                break;\n            }\n        }\n\n        // Create status\n\n        DistributionJobStatus status =\n            new DistributionJobStatus(request, this.observationManager, this.loggerManager, steps);\n\n        if (this.distributionManager.getDistributionExtension() != null) {\n            DistributionJobStatus previousStatus = this.distributionManager.getPreviousJobStatus();\n\n            if (previousStatus != null\n                && previousStatus.getDistributionExtension() != null\n                && !ObjectUtils.equals(previousStatus.getDistributionExtension(),\n                    this.distributionManager.getDistributionExtension())) {\n                status.setDistributionExtension(previousStatus.getDistributionExtension());\n                status.setDistributionExtensionUi(previousStatus.getDistributionExtensionUi());\n            }\n\n            status.setDistributionExtension(this.distributionManager.getDistributionExtension().getId());\n            status.setDistributionExtensionUi(extensionUI);\n        }\n\n        return status;\n    }","id":32917,"modified_method":"@Override\n    protected AbstractJobStatus<DistributionRequest> createNewStatus(DistributionRequest request)\n    {\n        // TODO: make steps components automatically discovered so that any module can add custom steps\n\n        List<DistributionStepStatus> steps = new ArrayList<DistributionStepStatus>(3);\n\n        ExtensionId extensionUI = this.distributionManager.getUIExtensionId();\n\n        // Step 1: Install/upgrade main wiki UI\n\n        DistributionStepStatus step1 = new DistributionStepStatus(\"extension.mainui\");\n        steps.add(step1);\n        // Only if the UI is not already installed\n        step1.setUpdateState(UpdateState.COMPLETED);\n        if (extensionUI != null) {\n            // FIXME: using \"xwiki\" directly is cheating but there is no way to get the official main wiki at this\n            // level yet. Using \"xwiki\" since in pratice there is no way to change the main wiki\n            InstalledExtension installedExtension =\n                this.installedRepository.getInstalledExtension(extensionUI.getId(), \"wiki:xwiki\");\n            if (installedExtension != null && !installedExtension.getId().getVersion().equals(extensionUI.getVersion())) {\n                step1.setUpdateState(null);\n            }\n        }\n\n        // Step 2: Upgrade outdated extensions\n\n        DistributionStepStatus step2 = new DistributionStepStatus(\"extension.outdatedextensions\");\n        steps.add(step2);\n        step2.setUpdateState(UpdateState.COMPLETED);\n        // Upgrade outdated extensions only when there is outdated extensions\n        for (InstalledExtension extension : this.installedRepository.getInstalledExtensions()) {\n            Collection<String> namespaces = extension.getNamespaces();\n            if (namespaces == null) {\n                if (!extension.isValid(null)) {\n                    step2.setUpdateState(null);\n                    break;\n                }\n            } else {\n                for (String namespace : namespaces) {\n                    if (!extension.isValid(namespace)) {\n                        step2.setUpdateState(null);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Step 0: A welcome message. Only if there is actually something to do\n        for (DistributionStepStatus step : steps) {\n            if (step.getUpdateState() == null) {\n                steps.add(0, new DistributionStepStatus(\"welcome\"));\n                break;\n            }\n        }\n\n        // Create status\n\n        DistributionJobStatus status =\n            new DistributionJobStatus(request, this.observationManager, this.loggerManager, steps);\n\n        if (this.distributionManager.getDistributionExtension() != null) {\n            DistributionJobStatus previousStatus = this.distributionManager.getPreviousJobStatus();\n\n            if (previousStatus != null\n                && previousStatus.getDistributionExtension() != null\n                && !ObjectUtils.equals(previousStatus.getDistributionExtension(),\n                    this.distributionManager.getDistributionExtension())) {\n                status.setDistributionExtension(previousStatus.getDistributionExtension());\n                status.setDistributionExtensionUi(previousStatus.getDistributionExtensionUi());\n            }\n\n            status.setDistributionExtension(this.distributionManager.getDistributionExtension().getId());\n            status.setDistributionExtensionUi(extensionUI);\n        }\n\n        return status;\n    }","commit_id":"ee911fcddc153323239ad655bf7937f3e0d12fbb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"static void checkMethodBody(final PsiMethod method,\n                              final InspectionManager manager,\n                              final Collection<ProblemDescriptor> problemDescriptors) {\n    PsiType returnType = method.getReturnType();\n    if (method.isConstructor() || returnType == null) return;\n    PsiCodeBlock body = method.getBody();\n    if (body == null) return;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null || aClass.isInterface()) return;\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    final PsiMethod superMethod = superSignatures.isEmpty() ? null : superSignatures.get(0).getMethod();\n    final PsiMethod templateMethod = getTemplateMethod(returnType, superSignatures, aClass);\n    if (PsiEquivalenceUtil.areElementsEquivalent(body, templateMethod.getBody(), new Comparator<PsiElement>(){\n      public int compare(final PsiElement element1, final PsiElement element2) {\n        // templates may be different on super method name                              \n        if (element1 == superMethod && (element2 == templateMethod || element2 == null)) return 0;\n        return 1;\n      }\n    }, true)) {\n      Pair<? extends PsiElement, ? extends PsiElement> range = DefaultFileTemplateUsageInspection.getInteriorRange(body);\n      final String description = InspectionsBundle.message(\"default.file.template.description\");\n      ProblemDescriptor problem = manager.createProblemDescriptor(range.first, range.second, description,\n                                                                  ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                  createMethodBodyQuickFix(method));\n      problemDescriptors.add(problem);\n    }\n  }","id":32918,"modified_method":"static void checkMethodBody(final PsiMethod method,\n                              final InspectionManager manager,\n                              final Collection<ProblemDescriptor> problemDescriptors) {\n    PsiType returnType = method.getReturnType();\n    if (method.isConstructor() || returnType == null) return;\n    PsiCodeBlock body = method.getBody();\n    if (body == null) return;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null || aClass.isInterface()) return;\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    final PsiMethod superMethod = superSignatures.isEmpty() ? null : superSignatures.get(0).getMethod();\n\n    final PsiMethod templateMethod = getTemplateMethod(returnType, superSignatures, aClass);\n    if (templateMethod == null) return;\n\n    final PsiCodeBlock templateBody = templateMethod.getBody();\n    if (templateBody == null) return;\n\n    if (PsiEquivalenceUtil.areElementsEquivalent(body, templateBody, new Comparator<PsiElement>(){\n      public int compare(final PsiElement element1, final PsiElement element2) {\n        // templates may be different on super method name                              \n        if (element1 == superMethod && (element2 == templateMethod || element2 == null)) return 0;\n        return 1;\n      }\n    }, true)) {\n      Pair<? extends PsiElement, ? extends PsiElement> range = DefaultFileTemplateUsageInspection.getInteriorRange(body);\n      final String description = InspectionsBundle.message(\"default.file.template.description\");\n      ProblemDescriptor problem = manager.createProblemDescriptor(range.first, range.second, description,\n                                                                  ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                  createMethodBodyQuickFix(method));\n      problemDescriptors.add(problem);\n    }\n  }","commit_id":"2499ee33ab9269ed9b96c60fa4f19ec1c4d3a507","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static FileTemplate setupMethodBody(final List<HierarchicalMethodSignature> superSignatures,\n                                              final PsiMethod templateMethod,\n                                              final PsiClass aClass,\n                                              final boolean useDefaultTemplate) throws IncorrectOperationException {\n    FileTemplate template = getMethodFileTemplate(superSignatures, useDefaultTemplate);\n    if (NEW_METHOD_BODY_TEMPLATE_NAME.equals(template.getName())) {\n      CreateFromUsageUtils.setupMethodBody(templateMethod, aClass, template);\n    }\n    else {\n      PsiMethod superMethod = superSignatures.get(0).getMethod();\n      OverrideImplementUtil.setupMethodBody(templateMethod, superMethod, aClass,template);\n    }\n    return template;\n  }","id":32919,"modified_method":"@Nullable\n  private static FileTemplate setupMethodBody(final List<HierarchicalMethodSignature> superSignatures,\n                                              final PsiMethod templateMethod,\n                                              final PsiClass aClass,\n                                              final boolean useDefaultTemplate) throws IncorrectOperationException {\n    FileTemplate template = getMethodFileTemplate(superSignatures, useDefaultTemplate);\n    if (template == null) return null;\n    if (NEW_METHOD_BODY_TEMPLATE_NAME.equals(template.getName())) {\n      CreateFromUsageUtils.setupMethodBody(templateMethod, aClass, template);\n    }\n    else {\n      PsiMethod superMethod = superSignatures.get(0).getMethod();\n      OverrideImplementUtil.setupMethodBody(templateMethod, superMethod, aClass,template);\n    }\n    return template;\n  }","commit_id":"2499ee33ab9269ed9b96c60fa4f19ec1c4d3a507","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static LocalQuickFix[] createMethodBodyQuickFix(final PsiMethod method) {\n    PsiType returnType = method.getReturnType();\n    PsiClass aClass = method.getContainingClass();\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    FileTemplate template;\n    try {\n      PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n      template = setupMethodBody(superSignatures, templateMethod, aClass, false);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return null;\n    }\n    final ReplaceWithFileTemplateFix replaceWithFileTemplateFix = new ReplaceWithFileTemplateFix() {\n      public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n        PsiType returnType = method.getReturnType();\n        if (method.isConstructor() || returnType == null) return;\n        PsiCodeBlock body = method.getBody();\n        if (body == null) return;\n        PsiClass aClass = method.getContainingClass();\n        if (aClass == null) return;\n        List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n        try {\n          PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n          setupMethodBody(superSignatures, templateMethod, aClass, false);\n          PsiElement newBody = method.getBody().replace(templateMethod.getBody());\n          CodeStyleManager.getInstance(project).reformat(newBody);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    };\n    LocalQuickFix editFileTemplateFix = DefaultFileTemplateUsageInspection.createEditFileTemplateFix(template, replaceWithFileTemplateFix);\n    if (template.isDefault()) {\n      return new LocalQuickFix[]{editFileTemplateFix};\n    }\n    return new LocalQuickFix[]{replaceWithFileTemplateFix, editFileTemplateFix};\n  }","id":32920,"modified_method":"@Nullable\n  private static LocalQuickFix[] createMethodBodyQuickFix(final PsiMethod method) {\n    PsiType returnType = method.getReturnType();\n    PsiClass aClass = method.getContainingClass();\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    FileTemplate template;\n    try {\n      PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n      template = setupMethodBody(superSignatures, templateMethod, aClass, false);\n    }\n    catch (IncorrectOperationException e) {\n      return null;\n    }\n\n    final ReplaceWithFileTemplateFix replaceWithFileTemplateFix = new ReplaceWithFileTemplateFix() {\n      public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n        PsiType returnType = method.getReturnType();\n        if (method.isConstructor() || returnType == null) return;\n        PsiCodeBlock body = method.getBody();\n        if (body == null) return;\n        PsiClass aClass = method.getContainingClass();\n        if (aClass == null) return;\n        List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n        try {\n          PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n          setupMethodBody(superSignatures, templateMethod, aClass, false);\n          final PsiCodeBlock templateBody = templateMethod.getBody();\n          if (templateBody == null) return;\n\n          PsiElement newBody = body.replace(templateBody);\n          CodeStyleManager.getInstance(project).reformat(newBody);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    };\n    LocalQuickFix editFileTemplateFix = DefaultFileTemplateUsageInspection.createEditFileTemplateFix(template, replaceWithFileTemplateFix);\n    if (template != null && template.isDefault()) {\n      return new LocalQuickFix[]{editFileTemplateFix};\n    }\n    return new LocalQuickFix[]{replaceWithFileTemplateFix, editFileTemplateFix};\n  }","commit_id":"2499ee33ab9269ed9b96c60fa4f19ec1c4d3a507","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiMethod getTemplateMethod(PsiType returnType, List<HierarchicalMethodSignature> superSignatures, final PsiClass aClass) {\n    Project project = aClass.getProject();\n\n    if (!(returnType instanceof PsiPrimitiveType)) {\n      returnType = PsiType.getJavaLangObject(PsiManager.getInstance(project), GlobalSearchScope.allScope(project));\n    }\n    try {\n      final String fileTemplateName = getMethodFileTemplate(superSignatures, true).getName();\n      String methodName = superSignatures.isEmpty() ? \"\" : superSignatures.get(0).getName();\n      String key = returnType.getCanonicalText() + \"+\" + methodName + \"+\"+fileTemplateName;\n      final Map<String, PsiMethod> cache = getTemplatesCache(project);\n      PsiMethod method = cache.get(key);\n      if (method == null) {\n        method = PsiManager.getInstance(project).getElementFactory().createMethod(\"x\", returnType);\n        setupMethodBody(superSignatures, method, aClass, true);\n        cache.put(key, method);\n      }\n      return method;\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return null;\n    }\n  }","id":32921,"modified_method":"@Nullable\n  private static PsiMethod getTemplateMethod(PsiType returnType, List<HierarchicalMethodSignature> superSignatures, final PsiClass aClass) {\n    Project project = aClass.getProject();\n\n    if (!(returnType instanceof PsiPrimitiveType)) {\n      returnType = PsiType.getJavaLangObject(PsiManager.getInstance(project), GlobalSearchScope.allScope(project));\n    }\n    try {\n      final FileTemplate template = getMethodFileTemplate(superSignatures, true);\n      if (template == null) return null;\n      final String fileTemplateName = template.getName();\n      String methodName = superSignatures.isEmpty() ? \"\" : superSignatures.get(0).getName();\n      String key = returnType.getCanonicalText() + \"+\" + methodName + \"+\"+fileTemplateName;\n      final Map<String, PsiMethod> cache = getTemplatesCache(project);\n      PsiMethod method = cache.get(key);\n      if (method == null) {\n        method = PsiManager.getInstance(project).getElementFactory().createMethod(\"x\", returnType);\n        setupMethodBody(superSignatures, method, aClass, true);\n        cache.put(key, method);\n      }\n      return method;\n    }\n    catch (IncorrectOperationException e) {\n      return null;\n    }\n  }","commit_id":"2499ee33ab9269ed9b96c60fa4f19ec1c4d3a507","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static LocalQuickFix createQuickFix(final PsiCatchSection section) {\n    FileTemplate catchBodyTemplate = FileTemplateManager.getInstance().getCodeTemplate(FileTemplateManager.TEMPLATE_CATCH_BODY);\n    if (catchBodyTemplate.isDefault()) return null;\n    return new ReplaceWithFileTemplateFix() {\n      public void applyFix(Project project, ProblemDescriptor descriptor) {\n        final PsiParameter parameter = section.getParameter();\n        if (parameter == null) return;\n        PsiCodeBlock catchBlock = section.getCatchBlock();\n        if (catchBlock == null) return;\n        PsiType type = parameter.getType();\n        if (!(type instanceof PsiClassType)) return;\n        final PsiElementFactory elementFactory = section.getManager().getElementFactory();\n        try {\n          PsiCatchSection sectionTemplate = elementFactory.createCatchSection((PsiClassType)type, parameter.getName(), parameter);\n          section.replace(sectionTemplate);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n    };\n  }","id":32922,"modified_method":"private static LocalQuickFix[] createQuickFix(final PsiCatchSection section) {\n    FileTemplate template = FileTemplateManager.getInstance().getCodeTemplate(FileTemplateManager.TEMPLATE_CATCH_BODY);\n    ReplaceWithFileTemplateFix replaceWithFileTemplateFix = new ReplaceWithFileTemplateFix() {\n      public void applyFix(Project project, ProblemDescriptor descriptor) {\n        final PsiParameter parameter = section.getParameter();\n        if (parameter == null) return;\n        PsiCodeBlock catchBlock = section.getCatchBlock();\n        if (catchBlock == null) return;\n        PsiType type = parameter.getType();\n        if (!(type instanceof PsiClassType)) return;\n        final PsiElementFactory elementFactory = section.getManager().getElementFactory();\n        try {\n          PsiCatchSection sectionTemplate = elementFactory.createCatchSection((PsiClassType)type, parameter.getName(), parameter);\n          section.replace(sectionTemplate);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n    };\n    LocalQuickFix editFileTemplateFix = DefaultFileTemplateUsageInspection.createEditFileTemplateFix(template, replaceWithFileTemplateFix);\n    if (template.isDefault()) {\n      return new LocalQuickFix[]{editFileTemplateFix};\n    }\n    return new LocalQuickFix[]{replaceWithFileTemplateFix, editFileTemplateFix};\n  }","commit_id":"4390c31e8c296b85b17e0f93fd8bdf5f6e285fcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static ProblemDescriptor checkFileHeader(final PsiFile file,\n                                           final InspectionManager manager) {\n    FileTemplate template = FileTemplateManager.getInstance().getDefaultTemplate(FileTemplateManager.FILE_HEADER_TEMPLATE_NAME);\n    String text = template.getText();\n    TIntObjectHashMap<String> offsetToProperty = new TIntObjectHashMap<String>();\n    String regex = templateToRegex(text, offsetToProperty);\n    regex = \".*(\"+regex+\").*\";\n    String fileText = file.getText();\n    Pattern pattern = Pattern.compile(regex, Pattern.DOTALL);\n    Matcher matcher = pattern.matcher(fileText);\n    if (matcher.matches()) {\n      final int startOffset = matcher.start(1);\n      final int endOffset = matcher.end(1);\n      final Ref<PsiDocComment> docComment = new Ref<PsiDocComment>();\n      file.accept(new PsiRecursiveElementVisitor(){\n        public void visitElement(PsiElement element) {\n          if (docComment.get() != null) return;\n          TextRange range = element.getTextRange();\n          if (!range.contains(startOffset) && !range.contains(endOffset)) return;\n          super.visitElement(element);\n        }\n        public void visitDocComment(PsiDocComment comment) {\n          docComment.set(comment);\n        }\n      });\n      PsiDocComment element = docComment.get();\n      if (element == null) return null;\n      LocalQuickFix quickFix = createQuickFix(element, matcher, offsetToProperty);\n      final String description = InspectionsBundle.message(\"default.file.template.description\");\n      ProblemDescriptor descriptor = manager.createProblemDescriptor(element, description, quickFix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      return descriptor;\n    }\n    return null;\n  }","id":32923,"modified_method":"static ProblemDescriptor checkFileHeader(final PsiFile file,\n                                           final InspectionManager manager) {\n    FileTemplate template = FileTemplateManager.getInstance().getDefaultTemplate(FileTemplateManager.FILE_HEADER_TEMPLATE_NAME);\n    String text = template.getText();\n    TIntObjectHashMap<String> offsetToProperty = new TIntObjectHashMap<String>();\n    String regex = templateToRegex(text, offsetToProperty);\n    regex = \".*(\"+regex+\").*\";\n    String fileText = file.getText();\n    Pattern pattern = Pattern.compile(regex, Pattern.DOTALL);\n    Matcher matcher = pattern.matcher(fileText);\n    if (matcher.matches()) {\n      final int startOffset = matcher.start(1);\n      final int endOffset = matcher.end(1);\n      final Ref<PsiDocComment> docComment = new Ref<PsiDocComment>();\n      file.accept(new PsiRecursiveElementVisitor(){\n        public void visitElement(PsiElement element) {\n          if (docComment.get() != null) return;\n          TextRange range = element.getTextRange();\n          if (!range.contains(startOffset) && !range.contains(endOffset)) return;\n          super.visitElement(element);\n        }\n        public void visitDocComment(PsiDocComment comment) {\n          docComment.set(comment);\n        }\n      });\n      PsiDocComment element = docComment.get();\n      if (element == null) return null;\n      LocalQuickFix[] quickFix = createQuickFix(element, matcher, offsetToProperty);\n      final String description = InspectionsBundle.message(\"default.file.template.description\");\n      ProblemDescriptor descriptor = manager.createProblemDescriptor(element, description, quickFix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      return descriptor;\n    }\n    return null;\n  }","commit_id":"4390c31e8c296b85b17e0f93fd8bdf5f6e285fcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static LocalQuickFix createQuickFix(final PsiDocComment element,\n                                              final Matcher matcher,\n                                              final TIntObjectHashMap<String> offsetToProperty) {\n    FileTemplate template = FileTemplateManager.getInstance().getPattern(FileTemplateManager.FILE_HEADER_TEMPLATE_NAME);\n    if (template.isDefault()) return null;\n    return new ReplaceWithFileTemplateFix() {\n      public void applyFix(Project project, ProblemDescriptor descriptor) {\n        FileTemplate template = FileTemplateManager.getInstance().getPattern(FileTemplateManager.FILE_HEADER_TEMPLATE_NAME);\n        try {\n          String newText = template.getText(computeProperties(matcher, offsetToProperty));\n          PsiDocComment newDoc = element.getManager().getElementFactory().createDocCommentFromText(newText, element);\n          element.replace(newDoc);\n        }\n        catch (IOException e) {\n          LOG.error(e);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      private Properties computeProperties(final Matcher matcher, final TIntObjectHashMap<String> offsetToProperty) {\n        Properties properties = new Properties(FileTemplateManager.getInstance().getDefaultProperties());\n        int[] offsets = offsetToProperty.keys();\n        Arrays.sort(offsets);\n\n        for (int i = 0; i < offsets.length; i++) {\n          final int offset = offsets[i];\n          String propName = offsetToProperty.get(offset);\n          int groupNum = i + 2; // first group is whole doc comment\n          String propValue = matcher.group(groupNum);\n          properties.put(propName, propValue);\n        }\n\n        return properties;\n      }\n    };\n  }","id":32924,"modified_method":"private static LocalQuickFix[] createQuickFix(final PsiDocComment element,\n                                              final Matcher matcher,\n                                              final TIntObjectHashMap<String> offsetToProperty) {\n    FileTemplate template = FileTemplateManager.getInstance().getPattern(FileTemplateManager.FILE_HEADER_TEMPLATE_NAME);\n    final ReplaceWithFileTemplateFix replaceTemplateFix = new ReplaceWithFileTemplateFix() {\n      public void applyFix(Project project, ProblemDescriptor descriptor) {\n        FileTemplate template = FileTemplateManager.getInstance().getPattern(FileTemplateManager.FILE_HEADER_TEMPLATE_NAME);\n        try {\n          String newText = template.getText(computeProperties(matcher, offsetToProperty));\n          PsiDocComment newDoc = element.getManager().getElementFactory().createDocCommentFromText(newText, element);\n          element.replace(newDoc);\n        }\n        catch (IOException e) {\n          LOG.error(e);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      private Properties computeProperties(final Matcher matcher, final TIntObjectHashMap<String> offsetToProperty) {\n        Properties properties = new Properties(FileTemplateManager.getInstance().getDefaultProperties());\n        int[] offsets = offsetToProperty.keys();\n        Arrays.sort(offsets);\n\n        for (int i = 0; i < offsets.length; i++) {\n          final int offset = offsets[i];\n          String propName = offsetToProperty.get(offset);\n          int groupNum = i + 2; // first group is whole doc comment\n          String propValue = matcher.group(groupNum);\n          properties.put(propName, propValue);\n        }\n\n        return properties;\n      }\n    };\n    final LocalQuickFix editFileTemplateFix = DefaultFileTemplateUsageInspection.createEditFileTemplateFix(template, replaceTemplateFix);\n    if (template.isDefault()) {\n      return new LocalQuickFix[]{editFileTemplateFix};\n    }\n    return new LocalQuickFix[]{replaceTemplateFix,editFileTemplateFix};\n  }","commit_id":"4390c31e8c296b85b17e0f93fd8bdf5f6e285fcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static LocalQuickFix createMethodBodyQuickFix(final PsiMethod method) {\n    PsiType returnType = method.getReturnType();\n    PsiClass aClass = method.getContainingClass();\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    try {\n      PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n      FileTemplate template = setupMethodBody(superSignatures, templateMethod, aClass, false);\n      if (template.isDefault()) return null;\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return new ReplaceWithFileTemplateFix() {\n      public void applyFix(Project project, ProblemDescriptor descriptor) {\n        PsiType returnType = method.getReturnType();\n        if (method.isConstructor() || returnType == null) return;\n        PsiCodeBlock body = method.getBody();\n        if (body == null) return;\n        PsiClass aClass = method.getContainingClass();\n        if (aClass == null) return;\n        List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n        try {\n          PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n          setupMethodBody(superSignatures, templateMethod, aClass, false);\n          PsiElement newBody = method.getBody().replace(templateMethod.getBody());\n          CodeStyleManager.getInstance(project).reformat(newBody);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    };\n  }","id":32925,"modified_method":"private static LocalQuickFix[] createMethodBodyQuickFix(final PsiMethod method) {\n    PsiType returnType = method.getReturnType();\n    PsiClass aClass = method.getContainingClass();\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    FileTemplate template;\n    try {\n      PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n      template = setupMethodBody(superSignatures, templateMethod, aClass, false);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return null;\n    }\n    final ReplaceWithFileTemplateFix replaceWithFileTemplateFix = new ReplaceWithFileTemplateFix() {\n      public void applyFix(Project project, ProblemDescriptor descriptor) {\n        PsiType returnType = method.getReturnType();\n        if (method.isConstructor() || returnType == null) return;\n        PsiCodeBlock body = method.getBody();\n        if (body == null) return;\n        PsiClass aClass = method.getContainingClass();\n        if (aClass == null) return;\n        List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n        try {\n          PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n          setupMethodBody(superSignatures, templateMethod, aClass, false);\n          PsiElement newBody = method.getBody().replace(templateMethod.getBody());\n          CodeStyleManager.getInstance(project).reformat(newBody);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    };\n    LocalQuickFix editFileTemplateFix = DefaultFileTemplateUsageInspection.createEditFileTemplateFix(template, replaceWithFileTemplateFix);\n    if (template.isDefault()) {\n      return new LocalQuickFix[]{editFileTemplateFix};\n    }\n    return new LocalQuickFix[]{replaceWithFileTemplateFix, editFileTemplateFix};\n  }","commit_id":"4390c31e8c296b85b17e0f93fd8bdf5f6e285fcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getName() {\n    return \"Reaplce with actual file template\";\n  }","id":32926,"modified_method":"public String getName() {\n    return InspectionsBundle.message(\"default.file.template.replace.with.actual.file.template\");\n  }","commit_id":"4390c31e8c296b85b17e0f93fd8bdf5f6e285fcd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiClass findMainClass(final Project project, final String mainClassName, final GlobalSearchScope scope) {\n    if (project.isDefault()) return null;\n    final PsiManager psiManager = PsiManager.getInstance(project);\n    final String shortName = StringUtil.getShortName(mainClassName);\n    final String packageName = StringUtil.getPackageName(mainClassName);\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(psiManager.getProject());\n    final PsiClass psiClass = psiFacade.findClass(StringUtil.getQualifiedName(packageName, shortName.replace('$', '.')), scope);\n    return psiClass == null ? psiFacade.findClass(mainClassName, scope) : psiClass;\n  }","id":32927,"modified_method":"@Nullable\n  public static PsiClass findMainClass(final Project project, final String mainClassName, final GlobalSearchScope scope) {\n    if (project.isDefault() || DumbService.isDumb(project)) return null;\n    final PsiManager psiManager = PsiManager.getInstance(project);\n    final String shortName = StringUtil.getShortName(mainClassName);\n    final String packageName = StringUtil.getPackageName(mainClassName);\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(psiManager.getProject());\n    final PsiClass psiClass = psiFacade.findClass(StringUtil.getQualifiedName(packageName, shortName.replace('$', '.')), scope);\n    return psiClass == null ? psiFacade.findClass(mainClassName, scope) : psiClass;\n  }","commit_id":"cf323744bfa85d115a0da289e7c7b33792a544cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean value(final Project project) {\n    final LocalTask activeTask = TaskManager.getManager(project).getActiveTask();\n    final boolean isNotUsed = activeTask.isDefault() && Comparing.equal(activeTask.getCreated(), activeTask.getUpdated());\n    return !isNotUsed;\n  }","id":32928,"modified_method":"@Override\n  public boolean value(final Project project) {\n    final TaskManager manager = TaskManager.getManager(project);\n    final LocalTask activeTask = manager.getActiveTask();\n    final boolean isNotUsed =\n      activeTask.isDefault() && manager.getLocalTasks().size() == 1 && Comparing.equal(activeTask.getCreated(), activeTask.getUpdated());\n    return !isNotUsed;\n  }","commit_id":"14f25ea211f4361784582c429c1ce4aee6344c90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    super.dispose();\n    if (myListener != null) {\n      ProjectManager.getInstance().removeProjectManagerListener(myListener);\n      myListener = null;\n    }\n    myDisposed = true;\n    myInfo = null;\n    myStatusBar = null;\n    myOption = null;\n  }","id":32929,"modified_method":"public void dispose() {\n    super.dispose();\n    myDisposed = true;\n    myInfo = null;\n    myStatusBar = null;\n    myOption = null;\n  }","commit_id":"12d275e155704d6a3d816bbb1f425663261234e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BackgroundableProcessIndicator(@Nullable final Project project, TaskInfo info, @NotNull PerformInBackgroundOption option) {\n    super(info.isCancellable(), true, project, info.getCancelText());\n    if (project != null) {\n      myListener = new ProjectManagerAdapter() {\n        public void projectClosing(Project closingProject) {\n          if (project == closingProject && isRunning()) {\n            cancel();\n          }\n        }\n      };\n      ProjectManager.getInstance().addProjectManagerListener(myListener);\n    }\n    setOwnerTask(info);\n    setProcessId(info.getProcessId());\n    myOption = option;\n    myInfo = info;\n    setTitle(info.getTitle());\n    final Project nonDefaultProject = (project == null || project.isDisposed()) ? null : ((project.isDefault()) ? null : project);\n    final IdeFrame frame = ((WindowManagerEx)WindowManager.getInstance()).findFrameFor(nonDefaultProject);\n    myStatusBar = (StatusBarEx)frame.getStatusBar();\n    if (option.shouldStartInBackground()) {\n      doBackground();\n    }\n  }","id":32930,"modified_method":"public BackgroundableProcessIndicator(@Nullable final Project project, TaskInfo info, @NotNull PerformInBackgroundOption option) {\n    super(info.isCancellable(), true, project, info.getCancelText());\n    if (project != null) {\n      final ProjectManagerAdapter myListener = new ProjectManagerAdapter() {\n        public void projectClosing(Project closingProject) {\n          if (isRunning()) {\n            cancel();\n          }\n        }\n      };\n      ProjectManager.getInstance().addProjectManagerListener(project, myListener);\n      Disposer.register(this, new Disposable() {\n        @Override\n        public void dispose() {\n          ProjectManager.getInstance().removeProjectManagerListener(myListener);\n        }\n      });\n    }\n    setOwnerTask(info);\n    setProcessId(info.getProcessId());\n    myOption = option;\n    myInfo = info;\n    setTitle(info.getTitle());\n    final Project nonDefaultProject = project == null || project.isDisposed() ? null : project.isDefault() ? null : project;\n    final IdeFrame frame = ((WindowManagerEx)WindowManager.getInstance()).findFrameFor(nonDefaultProject);\n    myStatusBar = (StatusBarEx)frame.getStatusBar();\n    if (option.shouldStartInBackground()) {\n      doBackground();\n    }\n  }","commit_id":"12d275e155704d6a3d816bbb1f425663261234e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void startBlocking() {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    LOG.assertTrue(!isRunning());\n    LOG.assertTrue(!myStoppedAlready);\n\n    enterModality();\n\n    IdeEventQueue.getInstance().pumpEventsForHierarchy(myDialog.myPanel, new Condition<AWTEvent>() {\n      public boolean value(final AWTEvent object) {\n        if (myShouldShowCancel &&\n            object instanceof KeyEvent &&\n            object.getID() == KeyEvent.KEY_PRESSED &&\n            ((KeyEvent)object).getKeyCode() == KeyEvent.VK_ESCAPE &&\n            ((KeyEvent)object).getModifiers() == 0) {\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              cancel();\n            }\n          });\n        }\n        return isStarted() && !isRunning();\n      }\n    });\n\n    exitModality();\n  }","id":32931,"modified_method":"public void startBlocking() {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    synchronized (this) {\n      LOG.assertTrue(!isRunning());\n      LOG.assertTrue(!myStoppedAlready);\n    }\n\n    enterModality();\n\n    IdeEventQueue.getInstance().pumpEventsForHierarchy(myDialog.myPanel, new Condition<AWTEvent>() {\n      public boolean value(final AWTEvent object) {\n        if (myShouldShowCancel &&\n            object instanceof KeyEvent &&\n            object.getID() == KeyEvent.KEY_PRESSED &&\n            ((KeyEvent)object).getKeyCode() == KeyEvent.VK_ESCAPE &&\n            ((KeyEvent)object).getModifiers() == 0) {\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              cancel();\n            }\n          });\n        }\n        return isStarted() && !isRunning();\n      }\n    });\n\n    exitModality();\n  }","commit_id":"12d275e155704d6a3d816bbb1f425663261234e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ServletMapping addServletMapping (String servletName, XmlParser.Node node, WebAppContext context, Descriptor descriptor)\n    {\n        ServletMapping mapping = new ServletMapping();\n        mapping.setServletName(servletName);\n        mapping.setDefault(descriptor instanceof DefaultsDescriptor);\n        \n        List<String> paths = new ArrayList<String>();\n        Iterator<XmlParser.Node> iter = node.iterator(\"url-pattern\");\n        while (iter.hasNext())\n        {\n            String p = iter.next().toString(false, true);\n            p = normalizePattern(p);\n            \n            //check if there is already a mapping for this path, and if there is && it is from a defaultdescriptor\n            //remove it in favour of the new one      \n            ListIterator<ServletMapping> listItor = _servletMappings.listIterator();\n            boolean found = false;\n            while (listItor.hasNext() && !found)\n            {\n                ServletMapping sm = listItor.next();\n                if (sm.getPathSpecs() != null)\n                {\n                    for (String ps:sm.getPathSpecs())\n                    {\n                        if (p.equals(ps) && sm.isDefault())\n                        {\n                            if (LOG.isDebugEnabled()) LOG.debug(\"{} in mapping {} from defaults descriptor is overridden by \",ps,sm,servletName);\n                            //remove ps from the path specs on the existing mapping\n                            //if the mapping now has no pathspecs, remove it\n                            String[] updatedPaths = ArrayUtil.removeFromArray(sm.getPathSpecs(), ps);\n                            if (updatedPaths == null || updatedPaths.length == 0)\n                            { \n                                if (LOG.isDebugEnabled()) LOG.debug(\"Removed mapping {} from defaults descriptor\",sm);\n                                listItor.remove();\n                            }\n                            else \n                            {\n                                sm.setPathSpecs(updatedPaths);\n                                if (LOG.isDebugEnabled()) LOG.debug(\"Removed path {} from mapping {} from defaults descriptor \", p,sm);\n                            }\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            paths.add(p);\n            context.getMetaData().setOrigin(servletName+\".servlet.mapping.\"+p, descriptor);\n        }\n        mapping.setPathSpecs((String[]) paths.toArray(new String[paths.size()]));\n        if (LOG.isDebugEnabled()) LOG.debug(\"Added mapping {} \",mapping);\n        \n      \n      \n        _servletMappings.add(mapping);\n        return mapping;\n    }","id":32932,"modified_method":"public ServletMapping addServletMapping (String servletName, XmlParser.Node node, WebAppContext context, Descriptor descriptor)\n    {\n        ServletMapping mapping = new ServletMapping();\n        mapping.setServletName(servletName);\n        mapping.setDefault(descriptor instanceof DefaultsDescriptor);\n        \n        List<String> paths = new ArrayList<String>();\n        Iterator<XmlParser.Node> iter = node.iterator(\"url-pattern\");\n        while (iter.hasNext())\n        {\n            String p = iter.next().toString(false, true);\n            p = normalizePattern(p);\n            \n            //check if there is already a mapping for this path\n            ListIterator<ServletMapping> listItor = _servletMappings.listIterator();\n            boolean found = false;\n            while (listItor.hasNext() && !found)\n            {\n                ServletMapping sm = listItor.next();\n                if (sm.getPathSpecs() != null)\n                {\n                    for (String ps:sm.getPathSpecs())\n                    {\n                        //The same path has been mapped multiple times, either to a different servlet or the same servlet.\n                        //If its a different servlet, this is only valid to do if the old mapping was from a default descriptor.\n                        if (p.equals(ps) && (sm.isDefault() || servletName.equals(sm.getServletName())))\n                        {\n                            if (sm.isDefault())\n                            {\n                                if (LOG.isDebugEnabled()) LOG.debug(\"{} in mapping {} from defaults descriptor is overridden by \",ps,sm,servletName);\n                            }\n                            else\n                                LOG.warn(\"Duplicate mapping from {} to {}\", p, servletName);\n\n                            //remove ps from the path specs on the existing mapping\n                            //if the mapping now has no pathspecs, remove it\n                            String[] updatedPaths = ArrayUtil.removeFromArray(sm.getPathSpecs(), ps);\n                            if (updatedPaths == null || updatedPaths.length == 0)\n                            { \n                                if (LOG.isDebugEnabled()) LOG.debug(\"Removed empty mapping {}\",sm);\n                                listItor.remove();\n                            }\n                            else \n                            {\n                                sm.setPathSpecs(updatedPaths);\n                                if (LOG.isDebugEnabled()) LOG.debug(\"Removed path {} from mapping {}\", p,sm);\n                            }\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            paths.add(p);\n            context.getMetaData().setOrigin(servletName+\".servlet.mapping.\"+p, descriptor);\n        }\n        mapping.setPathSpecs((String[]) paths.toArray(new String[paths.size()]));\n        if (LOG.isDebugEnabled()) LOG.debug(\"Added mapping {} \",mapping);\n    \n        _servletMappings.add(mapping);\n        return mapping;\n    }","commit_id":"bded25a2841adf3929705c4b9c225f893ffad62c","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private boolean needsCompanionDelegate(final Class model, Declaration member) {\n        return member.equals(model.getMember(member.getName(), null))\n                && member.isDefault();\n    }","id":32933,"modified_method":"private boolean needsCompanionDelegate(final Class model, Declaration member) {\n        return member.equals(model.getMember(member.getName(), null))\n                && (member.isDefault() || !member.isFormal());\n    }","commit_id":"aa42747fedea1ff969284e1999ecfa7468a1a8f6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void transformInstantiateCompanions(\n            ClassDefinitionBuilder classBuilder, \n            Interface iface, ProducedType satisfiedType, boolean goRaw) {\n        at(null);\n        final List<JCExpression> state = List.<JCExpression>of(makeUnquotedIdent(\"this\"));\n        Map<TypeParameter, ProducedType> typeArguments = satisfiedType.getTypeArguments();\n        final String fieldName = getCompanionFieldName(iface);\n        classBuilder.init(make().Exec(make().Assign(\n                makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                make().NewClass(null, \n                        null, // TODO Type args \n                        makeCompanionType(iface, typeArguments, goRaw),\n                        state,\n                        null))));\n        \n        classBuilder.field(PRIVATE | FINAL, fieldName, \n                makeCompanionType(iface, typeArguments, false), null, false);\n    }","id":32934,"modified_method":"private void transformInstantiateCompanions(\n            ClassDefinitionBuilder classBuilder, \n            Interface iface, ProducedType satisfiedType, boolean goRaw) {\n        at(null);\n        final List<JCExpression> state = List.<JCExpression>of(makeUnquotedIdent(\"this\"));\n        Map<TypeParameter, ProducedType> typeArguments = satisfiedType.getTypeArguments();\n        final String fieldName = getCompanionFieldName(iface);\n        classBuilder.init(make().Exec(make().Assign(\n                makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                make().NewClass(null, \n                        null, // TODO Type args \n                        makeCompanionType(iface, typeArguments, goRaw),\n                        state,\n                        null))));\n        \n        classBuilder.field(PRIVATE | FINAL, fieldName, \n                makeCompanionType(iface, typeArguments, goRaw), null, false);\n    }","commit_id":"aa42747fedea1ff969284e1999ecfa7468a1a8f6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n        // Detect whether we're satisfiying the same interface more than once\n        // and use raw types if so.\n        boolean goRaw = false;\n        Map<TypeDeclaration, java.util.List<ProducedType>> m = new HashMap<TypeDeclaration, java.util.List<ProducedType>>();\n        for (ProducedType t : model.getType().getSupertypes()) {\n            TypeDeclaration declaration = t.getDeclaration();\n            java.util.List<ProducedType> typeArguments = t.getTypeArgumentList();\n            java.util.List<ProducedType> existingTypeArgs = m.put(declaration, typeArguments);\n            if (existingTypeArgs != null) {\n                goRaw = true;\n                break;\n            }\n        }   \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    iface, satisfiedType, goRaw);\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(method, Collections.<ProducedType>emptyList());\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()\n                                || param.isSequenced()) {\n                            final ProducedTypedReference typedParameter = typedMember.getTypedParameter(param);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface,\n                                    typedParameter,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            \n                            final JCMethodDecl overload = makeDelegateToCompanion(iface,\n                                    typedMember,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    method.getName(), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(overload);\n                            \n                            // If that method has a defaulted parameter, \n                            // we need to generate a overload method\n                            // which also delegates to the $impl\n                            MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(\n                                    gen(), Decl.isAncestorLocal(model), true, method.getName());\n                            final MethodDefinitionBuilder overload = makeOverloadsForDefaultedParameter(true, true,  \n                                    overloadBuilder, method, parameters, param);\n                            classBuilder.defs(overload.build());\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    \n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            typedMember,\n                            PUBLIC, \n                            method.getTypeParameters(), \n                            method.getType(), \n                            method.getName(), \n                            method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter) {// Concrete getter\n                Getter getter = (Getter)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(getter, null);\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                            typedMember,\n                            PUBLIC | (getter.isDefault() ? 0 : FINAL), \n                            Collections.<TypeParameter>emptyList(), \n                            getter.getType(), \n                            CodegenUtil.getGetterName(member), \n                            Collections.<Parameter>emptyList(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(getterDelegate);\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getName());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","id":32935,"modified_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n        // Detect whether we're satisfiying the same interface more than once\n        // and use raw types if so.\n        boolean goRaw = false;\n        Map<TypeDeclaration, java.util.List<ProducedType>> m = new HashMap<TypeDeclaration, java.util.List<ProducedType>>();\n        for (ProducedType t : model.getType().getSupertypes()) {\n            TypeDeclaration declaration = t.getDeclaration();\n            java.util.List<ProducedType> typeArguments = t.getTypeArgumentList();\n            java.util.List<ProducedType> existingTypeArgs = m.put(declaration, typeArguments);\n            if (existingTypeArgs != null) {\n                goRaw = true;\n                break;\n            }\n        }   \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    iface, satisfiedType, goRaw);\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(method, Collections.<ProducedType>emptyList());\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()\n                                || param.isSequenced()) {\n                            final ProducedTypedReference typedParameter = typedMember.getTypedParameter(param);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface,\n                                    typedParameter,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            \n                            final JCMethodDecl overload = makeDelegateToCompanion(iface,\n                                    typedMember,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    method.getName(), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(overload);\n                            \n                            // If that method has a defaulted parameter, \n                            // we need to generate a overload method\n                            // which also delegates to the $impl\n                            MethodDefinitionBuilder overloadBuilder = MethodDefinitionBuilder.method(\n                                    gen(), Decl.isAncestorLocal(model), true, method.getName());\n                            final MethodDefinitionBuilder overload = makeOverloadsForDefaultedParameter(true, true,  \n                                    overloadBuilder, method, parameters, param);\n                            classBuilder.defs(overload.build());\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    \n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            typedMember,\n                            PUBLIC, \n                            method.getTypeParameters(), \n                            method.getType(), \n                            method.getName(), \n                            method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter) {// Concrete getter\n                Getter getter = (Getter)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(getter, null);\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                            typedMember,\n                            PUBLIC | (getter.isDefault() ? 0 : FINAL), \n                            Collections.<TypeParameter>emptyList(), \n                            getter.getType(), \n                            CodegenUtil.getGetterName(member), \n                            Collections.<Parameter>emptyList(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(getterDelegate);\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getName() + \" \" + member.getClass());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","commit_id":"aa42747fedea1ff969284e1999ecfa7468a1a8f6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected MavenResolver createRealResolver() {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        MavenResolver resolver = createResolver(rootUri);\n\n        for (URI repoUrl : getArtifactUrls()) {\n            resolver.addArtifactLocation(repoUrl, null);\n        }\n        return resolver;\n    }","id":32936,"modified_method":"protected MavenResolver createRealResolver() {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        MavenResolver resolver = createResolver(rootUri);\n\n        for (URI repoUrl : getArtifactUrls()) {\n            resolver.addArtifactLocation(repoUrl);\n        }\n        return resolver;\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"protected MavenResolver createRealResolver() {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        MavenResolver resolver = new MavenLocalResolver(getName(), rootUri, getTransport(rootUri.getScheme()), getLocallyAvailableResourceFinder(), getResolverStrategy());\n        for (URI repoUrl : getArtifactUrls()) {\n            resolver.addArtifactLocation(repoUrl, null);\n        }\n        return resolver;\n    }","id":32937,"modified_method":"protected MavenResolver createRealResolver() {\n        URI rootUri = getUrl();\n        if (rootUri == null) {\n            throw new InvalidUserDataException(\"You must specify a URL for a Maven repository.\");\n        }\n\n        MavenResolver resolver = new MavenLocalResolver(getName(), rootUri, getTransport(rootUri.getScheme()), getLocallyAvailableResourceFinder(), getResolverStrategy());\n        for (URI repoUrl : getArtifactUrls()) {\n            resolver.addArtifactLocation(repoUrl);\n        }\n        return resolver;\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"private static File getFile(String absolutePath) {\n        File f = new File(absolutePath);\n        if (!f.isAbsolute()) {\n            throw new IllegalArgumentException(\"Filename must be absolute: \" + absolutePath);\n        }\n        return f;\n    }","id":32938,"modified_method":"private static File getFile(String absolutePath) {\n        URI uri;\n        try {\n            uri = new URI(absolutePath);\n        } catch (URISyntaxException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n        File f = new File(uri);\n        if (!f.isAbsolute()) {\n            throw new IllegalArgumentException(\"Filename must be absolute: \" + absolutePath);\n        }\n        return f;\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"public void addArtifactLocation(URI baseUri, String pattern) {\n        String artifactPattern = transport.convertToPath(baseUri) + pattern;\n        addArtifactPattern(toResourcePattern(artifactPattern));\n    }","id":32939,"modified_method":"public void addArtifactLocation(URI baseUri, String pattern) {\n        addArtifactPattern(toResourcePattern(baseUri, pattern));\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"public IvyResolver(String name, RepositoryTransport transport,\n                       LocallyAvailableResourceFinder<ModuleVersionArtifactMetaData> locallyAvailableResourceFinder,\n                       boolean dynamicResolve, ResolverStrategy resolverStrategy) {\n        super(name, transport.getRepository(), new ResourceVersionLister(transport.getRepository()), locallyAvailableResourceFinder, resolverStrategy);\n        this.metaDataParser = new DownloadedIvyModuleDescriptorParser(resolverStrategy);\n        this.transport = transport;\n        this.transport.configureCacheManager(this);\n        this.dynamicResolve = dynamicResolve;\n    }","id":32940,"modified_method":"public IvyResolver(String name, RepositoryTransport transport,\n                       LocallyAvailableResourceFinder<ModuleVersionArtifactMetaData> locallyAvailableResourceFinder,\n                       boolean dynamicResolve, ResolverStrategy resolverStrategy) {\n        super(name, transport.getRepository(), new ResourceVersionLister(transport.getRepository()), locallyAvailableResourceFinder, resolverStrategy);\n        this.metaDataParser = new DownloadedIvyModuleDescriptorParser(resolverStrategy);\n        transport.configureCacheManager(this);\n        this.dynamicResolve = dynamicResolve;\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"protected ResourcePattern toResourcePattern(String pattern) {\n        return isM2compatible() ? new M2ResourcePattern(pattern) : new IvyResourcePattern(pattern);\n    }","id":32941,"modified_method":"protected ResourcePattern toResourcePattern(URI baseUri, String pattern) {\n        return isM2compatible() ? new M2ResourcePattern(baseUri, pattern) : new IvyResourcePattern(baseUri, pattern);\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"public void addDescriptorLocation(URI baseUri, String pattern) {\n        String descriptorPattern = transport.convertToPath(baseUri) + pattern;\n        addIvyPattern(toResourcePattern(descriptorPattern));\n    }","id":32942,"modified_method":"public void addDescriptorLocation(URI baseUri, String pattern) {\n        addIvyPattern(toResourcePattern(baseUri, pattern));\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"private void updatePatterns() {\n        if (isUsepoms()) {\n            setIvyPatterns(Collections.singletonList(new M2ResourcePattern(getWholePattern())));\n        } else {\n            setIvyPatterns(Collections.<ResourcePattern>emptyList());\n        }\n\n        List<ResourcePattern> artifactPatterns = new ArrayList<ResourcePattern>();\n        artifactPatterns.add(new M2ResourcePattern(getWholePattern()));\n        for (String artifactRoot : artifactRoots) {\n            artifactPatterns.add(new M2ResourcePattern(artifactRoot + pattern));\n        }\n        setArtifactPatterns(artifactPatterns);\n    }","id":32943,"modified_method":"private void updatePatterns() {\n        if (isUsepoms()) {\n            setIvyPatterns(Collections.singletonList(getWholePattern()));\n        } else {\n            setIvyPatterns(Collections.<ResourcePattern>emptyList());\n        }\n\n        List<ResourcePattern> artifactPatterns = new ArrayList<ResourcePattern>();\n        artifactPatterns.add(getWholePattern());\n        for (URI artifactRoot : artifactRoots) {\n            artifactPatterns.add(new M2ResourcePattern(artifactRoot, pattern));\n        }\n        setArtifactPatterns(artifactPatterns);\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"public MavenResolver(String name, URI rootUri, RepositoryTransport transport,\n                         LocallyAvailableResourceFinder<ModuleVersionArtifactMetaData> locallyAvailableResourceFinder,\n                         ResolverStrategy resolverStrategy) {\n        super(name, transport.getRepository(),\n                new ChainedVersionLister(new MavenVersionLister(transport.getRepository()), new ResourceVersionLister(transport.getRepository())),\n                locallyAvailableResourceFinder, resolverStrategy);\n        transport.configureCacheManager(this);\n\n        this.metaDataParser = new GradlePomModuleDescriptorParser();\n        this.mavenMetaDataLoader = new MavenMetadataLoader(transport.getRepository());\n        this.transport = transport;\n        this.root = transport.convertToPath(rootUri);\n\n        // SNAPSHOT revisions are changing revisions\n        setChangingMatcher(PatternMatcher.REGEXP);\n        setChangingPattern(\".*-SNAPSHOT\");\n\n        updatePatterns();\n    }","id":32944,"modified_method":"public MavenResolver(String name, URI rootUri, RepositoryTransport transport,\n                         LocallyAvailableResourceFinder<ModuleVersionArtifactMetaData> locallyAvailableResourceFinder,\n                         ResolverStrategy resolverStrategy) {\n        super(name, transport.getRepository(),\n                new ChainedVersionLister(new MavenVersionLister(transport.getRepository()), new ResourceVersionLister(transport.getRepository())),\n                locallyAvailableResourceFinder, resolverStrategy);\n        transport.configureCacheManager(this);\n\n        this.metaDataParser = new GradlePomModuleDescriptorParser();\n        this.mavenMetaDataLoader = new MavenMetadataLoader(transport.getRepository());\n        this.root = rootUri;\n\n        // SNAPSHOT revisions are changing revisions\n        setChangingMatcher(PatternMatcher.REGEXP);\n        setChangingPattern(\".*-SNAPSHOT\");\n\n        updatePatterns();\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"public void addArtifactLocation(URI baseUri, String pattern) {\n        if (pattern != null && pattern.length() > 0) {\n            throw new IllegalArgumentException(\"Maven Resolver only supports a single pattern. It cannot be provided on a per-location basis.\");\n        }\n        artifactRoots.add(transport.convertToPath(baseUri));\n\n        updatePatterns();\n    }","id":32945,"modified_method":"public void addArtifactLocation(URI baseUri) {\n        artifactRoots.add(baseUri);\n        updatePatterns();\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"private String getWholePattern() {\n        return root + pattern;\n    }","id":32946,"modified_method":"private M2ResourcePattern getWholePattern() {\n        return new M2ResourcePattern(root, pattern);\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"private MavenUniqueSnapshotModuleSource findUniqueSnapshotVersion(ModuleComponentIdentifier module) {\n        String metadataLocation = new M2ResourcePattern(getWholePattern()).toModuleVersionPath(module) + \"/maven-metadata.xml\";\n        MavenMetadata mavenMetadata = parseMavenMetadata(metadataLocation);\n\n        if (mavenMetadata.timestamp != null) {\n            // we have found a timestamp, so this is a snapshot unique version\n            String timestamp = String.format(\"%s-%s\", mavenMetadata.timestamp, mavenMetadata.buildNumber);\n            return new MavenUniqueSnapshotModuleSource(timestamp);\n        }\n        return null;\n    }","id":32947,"modified_method":"private MavenUniqueSnapshotModuleSource findUniqueSnapshotVersion(ModuleComponentIdentifier module) {\n        String metadataLocation = getWholePattern().toModuleVersionPath(module) + \"/maven-metadata.xml\";\n        MavenMetadata mavenMetadata = parseMavenMetadata(metadataLocation);\n\n        if (mavenMetadata.timestamp != null) {\n            // we have found a timestamp, so this is a snapshot unique version\n            String timestamp = String.format(\"%s-%s\", mavenMetadata.timestamp, mavenMetadata.buildNumber);\n            return new MavenUniqueSnapshotModuleSource(timestamp);\n        }\n        return null;\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"public String getRoot() {\n        return root;\n    }","id":32948,"modified_method":"public String getRoot() {\n        return root.toString();\n    }","commit_id":"6ab3f018a98a943549b8bec6617fb8c7f7460282","url":"https://github.com/gradle/gradle"},{"original_method":"public static Tuple<Settings, Environment> prepareSettings(Settings pSettings, boolean loadConfigSettings) {\n        // ignore this prefixes when getting properties from es. and elasticsearch.\n        String[] ignorePrefixes = new String[]{\"es.default.\", \"elasticsearch.default.\"};\n        // just create enough settings to build the environment\n        ImmutableSettings.Builder settingsBuilder = settingsBuilder()\n                .put(pSettings)\n                .putProperties(\"elasticsearch.default.\", System.getProperties())\n                .putProperties(\"es.default.\", System.getProperties())\n                .putProperties(\"elasticsearch.\", System.getProperties(), ignorePrefixes)\n                .putProperties(\"es.\", System.getProperties(), ignorePrefixes)\n                .replacePropertyPlaceholders();\n\n        Environment environment = new Environment(settingsBuilder.build());\n\n        if (loadConfigSettings) {\n            boolean loadFromEnv = true;\n            // if its default, then load it, but also load form env\n            if (System.getProperty(\"es.default.config\") != null) {\n                loadFromEnv = true;\n                settingsBuilder.loadFromUrl(environment.resolveConfig(System.getProperty(\"es.default.config\")));\n            }\n            // if explicit, just load it and don't load from env\n            if (System.getProperty(\"es.config\") != null) {\n                loadFromEnv = false;\n                settingsBuilder.loadFromUrl(environment.resolveConfig(System.getProperty(\"es.config\")));\n            }\n            if (System.getProperty(\"elasticsearch.config\") != null) {\n                loadFromEnv = false;\n                settingsBuilder.loadFromUrl(environment.resolveConfig(System.getProperty(\"elasticsearch.config\")));\n            }\n            if (loadFromEnv) {\n                try {\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(\"elasticsearch.yml\"));\n                } catch (FailedToResolveConfigException e) {\n                    // ignore\n                } catch (NoClassDefFoundError e) {\n                    // ignore, no yaml\n                }\n                try {\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(\"elasticsearch.json\"));\n                } catch (FailedToResolveConfigException e) {\n                    // ignore\n                }\n                try {\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(\"elasticsearch.properties\"));\n                } catch (FailedToResolveConfigException e) {\n                    // ignore\n                }\n            }\n        }\n\n        settingsBuilder.put(pSettings)\n                .putProperties(\"elasticsearch.\", System.getProperties(), ignorePrefixes)\n                .putProperties(\"es.\", System.getProperties(), ignorePrefixes)\n                .replacePropertyPlaceholders();\n\n        // generate the name\n        if (settingsBuilder.get(\"name\") == null) {\n            String name = System.getProperty(\"name\");\n            if (name == null || name.isEmpty()) {\n                name = settingsBuilder.get(\"node.name\");\n                if (name == null || name.isEmpty()) {\n                    name = Names.randomNodeName(environment.resolveConfig(\"names.txt\"));\n                }\n            }\n\n            if (name != null) {\n                settingsBuilder.put(\"name\", name);\n            }\n        }\n\n        // put the cluster name\n        if (settingsBuilder.get(ClusterName.SETTING) == null) {\n            settingsBuilder.put(ClusterName.SETTING, ClusterName.DEFAULT.value());\n        }\n\n        Settings v1 = settingsBuilder.build();\n        environment = new Environment(v1);\n\n        // put back the env settings\n        settingsBuilder = settingsBuilder().put(v1);\n        // we put back the path.logs so we can use it in the logging configuration file\n        settingsBuilder.put(\"path.logs\", cleanPath(environment.logsFile().getAbsolutePath()));\n\n        v1 = settingsBuilder.build();\n\n        return new Tuple<Settings, Environment>(v1, environment);\n    }","id":32949,"modified_method":"public static Tuple<Settings, Environment> prepareSettings(Settings pSettings, boolean loadConfigSettings) {\n        // ignore this prefixes when getting properties from es. and elasticsearch.\n        String[] ignorePrefixes = new String[]{\"es.default.\", \"elasticsearch.default.\"};\n        boolean useSystemProperties = !pSettings.getAsBoolean(\"config.ignore_system_properties\", false);\n        // just create enough settings to build the environment\n        ImmutableSettings.Builder settingsBuilder = settingsBuilder().put(pSettings);\n        if (useSystemProperties) {\n            settingsBuilder.putProperties(\"elasticsearch.default.\", System.getProperties())\n                    .putProperties(\"es.default.\", System.getProperties())\n                    .putProperties(\"elasticsearch.\", System.getProperties(), ignorePrefixes)\n                    .putProperties(\"es.\", System.getProperties(), ignorePrefixes);\n        }\n        settingsBuilder.replacePropertyPlaceholders();\n\n        Environment environment = new Environment(settingsBuilder.build());\n\n        if (loadConfigSettings) {\n            boolean loadFromEnv = true;\n            if (useSystemProperties) {\n                // if its default, then load it, but also load form env\n                if (System.getProperty(\"es.default.config\") != null) {\n                    loadFromEnv = true;\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(System.getProperty(\"es.default.config\")));\n                }\n                // if explicit, just load it and don't load from env\n                if (System.getProperty(\"es.config\") != null) {\n                    loadFromEnv = false;\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(System.getProperty(\"es.config\")));\n                }\n                if (System.getProperty(\"elasticsearch.config\") != null) {\n                    loadFromEnv = false;\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(System.getProperty(\"elasticsearch.config\")));\n                }\n            }\n            if (loadFromEnv) {\n                try {\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(\"elasticsearch.yml\"));\n                } catch (FailedToResolveConfigException e) {\n                    // ignore\n                } catch (NoClassDefFoundError e) {\n                    // ignore, no yaml\n                }\n                try {\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(\"elasticsearch.json\"));\n                } catch (FailedToResolveConfigException e) {\n                    // ignore\n                }\n                try {\n                    settingsBuilder.loadFromUrl(environment.resolveConfig(\"elasticsearch.properties\"));\n                } catch (FailedToResolveConfigException e) {\n                    // ignore\n                }\n            }\n        }\n\n        settingsBuilder.put(pSettings);\n        if (useSystemProperties) {\n            settingsBuilder.putProperties(\"elasticsearch.\", System.getProperties(), ignorePrefixes)\n                    .putProperties(\"es.\", System.getProperties(), ignorePrefixes);\n        }\n        settingsBuilder.replacePropertyPlaceholders();\n\n        // generate the name\n        if (settingsBuilder.get(\"name\") == null) {\n            String name = System.getProperty(\"name\");\n            if (name == null || name.isEmpty()) {\n                name = settingsBuilder.get(\"node.name\");\n                if (name == null || name.isEmpty()) {\n                    name = Names.randomNodeName(environment.resolveConfig(\"names.txt\"));\n                }\n            }\n\n            if (name != null) {\n                settingsBuilder.put(\"name\", name);\n            }\n        }\n\n        // put the cluster name\n        if (settingsBuilder.get(ClusterName.SETTING) == null) {\n            settingsBuilder.put(ClusterName.SETTING, ClusterName.DEFAULT.value());\n        }\n\n        Settings v1 = settingsBuilder.build();\n        environment = new Environment(v1);\n\n        // put back the env settings\n        settingsBuilder = settingsBuilder().put(v1);\n        // we put back the path.logs so we can use it in the logging configuration file\n        settingsBuilder.put(\"path.logs\", cleanPath(environment.logsFile().getAbsolutePath()));\n\n        v1 = settingsBuilder.build();\n\n        return new Tuple<Settings, Environment>(v1, environment);\n    }","commit_id":"d947dfde2be9772b50052ff4dd4e72ef2ce83379","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void configure(Settings settings) {\n        if (loaded) {\n            return;\n        }\n        loaded = true;\n        // TODO: this is partly a copy of InternalSettingsPreparer...we should pass in Environment and not do all this...\n        Environment environment = new Environment(settings);\n        Settings.Builder settingsBuilder = settingsBuilder().put(settings);\n        resolveConfig(environment, settingsBuilder);\n        settingsBuilder\n                .putProperties(\"elasticsearch.\", System.getProperties())\n                .putProperties(\"es.\", System.getProperties())\n                .replacePropertyPlaceholders();\n        Properties props = new Properties();\n        for (Map.Entry<String, String> entry : settingsBuilder.build().getAsMap().entrySet()) {\n            String key = \"log4j.\" + entry.getKey();\n            String value = entry.getValue();\n            if (replacements.containsKey(value)) {\n                value = replacements.get(value);\n            }\n            if (key.endsWith(\".value\")) {\n                props.setProperty(key.substring(0, key.length() - \".value\".length()), value);\n            } else if (key.endsWith(\".type\")) {\n                props.setProperty(key.substring(0, key.length() - \".type\".length()), value);\n            } else {\n                props.setProperty(key, value);\n            }\n        }\n        // ensure explicit path to logs dir exists\n        props.setProperty(\"log4j.path.logs\", cleanPath(environment.logsFile().toAbsolutePath().toString()));\n        PropertyConfigurator.configure(props);\n    }","id":32950,"modified_method":"public static void configure(Settings settings) {\n        if (loaded) {\n            return;\n        }\n        loaded = true;\n        // TODO: this is partly a copy of InternalSettingsPreparer...we should pass in Environment and not do all this...\n        Environment environment = new Environment(settings);\n        Settings.Builder settingsBuilder = settingsBuilder();\n        resolveConfig(environment, settingsBuilder);\n        settingsBuilder\n                .putProperties(\"elasticsearch.\", System.getProperties())\n                .putProperties(\"es.\", System.getProperties());\n        // add custom settings after config was added so that they are not overwritten by config\n        settingsBuilder.put(settings);\n        settingsBuilder.replacePropertyPlaceholders();\n        Properties props = new Properties();\n        for (Map.Entry<String, String> entry : settingsBuilder.build().getAsMap().entrySet()) {\n            String key = \"log4j.\" + entry.getKey();\n            String value = entry.getValue();\n            if (replacements.containsKey(value)) {\n                value = replacements.get(value);\n            }\n            if (key.endsWith(\".value\")) {\n                props.setProperty(key.substring(0, key.length() - \".value\".length()), value);\n            } else if (key.endsWith(\".type\")) {\n                props.setProperty(key.substring(0, key.length() - \".type\".length()), value);\n            } else {\n                props.setProperty(key, value);\n            }\n        }\n        // ensure explicit path to logs dir exists\n        props.setProperty(\"log4j.path.logs\", cleanPath(environment.logsFile().toAbsolutePath().toString()));\n        PropertyConfigurator.configure(props);\n    }","commit_id":"ceefb06752073a3cc16fd981296870d6f4384bc6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testResolveConfigInvalidFilename() throws Exception {\n        Path tmpDir = createTempDir();\n        Path invalidSuffix = tmpDir.resolve(loggingConfiguration(randomFrom(LogConfigurator.ALLOWED_SUFFIXES)) + randomInvalidSuffix());\n        Files.write(invalidSuffix, \"yml: bar\".getBytes(StandardCharsets.UTF_8));\n        Environment environment = new Environment(\n                Settings.builder()\n                    .put(\"path.conf\", invalidSuffix.toAbsolutePath())\n                    .put(\"path.home\", createTempDir().toString())\n                    .build());\n\n        Settings.Builder builder = Settings.builder();\n        LogConfigurator.resolveConfig(environment, builder);\n\n        Settings logSettings = builder.build();\n        assertThat(logSettings.get(\"yml\"), Matchers.nullValue());\n    }","id":32951,"modified_method":"@Test\n    public void testResolveConfigInvalidFilename() throws Exception {\n        Path tmpDir = createTempDir();\n        Path invalidSuffix = tmpDir.resolve(loggingConfiguration(randomFrom(LogConfigurator.ALLOWED_SUFFIXES)) + randomInvalidSuffix());\n        Files.write(invalidSuffix, \"yml: bar\".getBytes(StandardCharsets.UTF_8));\n        Environment environment = new Environment(\n                Settings.builder()\n                    .put(\"path.conf\", invalidSuffix.toAbsolutePath())\n                    .put(\"path.home\", createTempDir().toString())\n                    .build());\n\n        Settings.Builder builder = Settings.builder();\n        LogConfigurator.resolveConfig(environment, builder);\n\n        Settings logSettings = builder.build();\n        assertThat(logSettings.get(\"yml\"), nullValue());\n    }","commit_id":"ceefb06752073a3cc16fd981296870d6f4384bc6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {\n\t\tString voiceProvider = osmandSettings.VOICE_PROVIDER.get();\n\t\tif (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {\n\t\t\tif (warningNoneProvider && voiceProvider == null) {\n\t\t\t\tAlertDialog.Builder builder = new AccessibleAlertBuilder(uiContext);\n\t\t\t\tLinearLayout ll = new LinearLayout(uiContext);\n\t\t\t\tll.setOrientation(LinearLayout.VERTICAL);\n\t\t\t\tfinal TextView tv = new TextView(uiContext);\n\t\t\t\ttv.setPadding(7, 3, 7, 0);\n\t\t\t\ttv.setText(R.string.voice_is_not_available_msg);\n\t\t\t\ttv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);\n\t\t\t\tll.addView(tv);\n\t\t\t\t\n\t\t\t\tfinal CheckBox cb = new CheckBox(uiContext);\n\t\t\t\tcb.setText(R.string.shared_string_remember_my_choice);\n\t\t\t\tLinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);\n\t\t\t\tlp.setMargins(7, 10, 7, 0);\n\t\t\t\tcb.setLayoutParams(lp);\n\t\t\t\tll.addView(cb);\n\t\t\t\t\n\t\t\t\tbuilder.setCancelable(true);\n\t\t\t\tbuilder.setNegativeButton(R.string.shared_string_cancel, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tif(cb.isChecked()) {\n\t\t\t\t\t\t\tosmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbuilder.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tIntent intent = new Intent(uiContext, SettingsActivity.class);\n\t\t\t\t\t\tintent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);\n\t\t\t\t\t\tuiContext.startActivity(intent);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tbuilder.setTitle(R.string.voice_is_not_available_title);\n\t\t\t\tbuilder.setView(ll);\n\t\t\t\t//builder.setMessage(R.string.voice_is_not_available_msg);\n\t\t\t\tbuilder.show();\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {\n\t\t\t\tappInitializer.\tinitVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);\n\t\t\t}\n\t\t}\n\n\t}","id":32952,"modified_method":"public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {\n\t\tString voiceProvider = osmandSettings.VOICE_PROVIDER.get();\n\t\tif (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {\n\t\t\tif (warningNoneProvider && voiceProvider == null) {\n\t\t\t\tfinal AlertDialog.Builder builder = new AlertDialog.Builder(uiContext);\n\n\t\t\t\tView view = uiContext.getLayoutInflater().inflate(R.layout.select_voice_first, null);\n\n\t\t\t\t((ImageView) view.findViewById(R.id.icon))\n\t\t\t\t\t\t.setImageDrawable(getIconsCache().getContentIcon(R.drawable.ic_action_volume_up, getSettings().isLightContent()));\n\n\t\t\t\tview.findViewById(R.id.spinner).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(final View v) {\n\t\t\t\t\t\tRoutePreferencesMenu.selectVoiceGuidance((MapActivity) uiContext, new CallbackWithObject<String>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean processResult(String result) {\n\t\t\t\t\t\t\t\tboolean acceptableValue = !RoutePreferencesMenu.MORE_VALUE.equals(firstSelectedVoiceProvider);\n\t\t\t\t\t\t\t\tif (acceptableValue) {\n\t\t\t\t\t\t\t\t\t((TextView) v.findViewById(R.id.selectText))\n\t\t\t\t\t\t\t\t\t\t\t.setText(RoutePreferencesMenu.getVoiceProviderName(uiContext, result));\n\t\t\t\t\t\t\t\t\tfirstSelectedVoiceProvider = result;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn acceptableValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t((ImageView) view.findViewById(R.id.dropDownIcon))\n\t\t\t\t\t\t.setImageDrawable(getIconsCache().getContentIcon(R.drawable.ic_action_arrow_drop_down, getSettings().isLightContent()));\n\n\t\t\t\tbuilder.setCancelable(true);\n\t\t\t\tbuilder.setNegativeButton(R.string.shared_string_cancel, null);\n\t\t\t\tbuilder.setPositiveButton(R.string.shared_string_apply, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tif (!Algorithms.isEmpty(firstSelectedVoiceProvider)) {\n\t\t\t\t\t\t\tRoutePreferencesMenu.applyVoiceProvider((MapActivity) uiContext, firstSelectedVoiceProvider);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tbuilder.setView(view);\n\t\t\t\tbuilder.show();\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {\n\t\t\t\tappInitializer.\tinitVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"7839f0b933062061cbb205d42d47bb41dafdd655","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public ArrayAdapter<LocalRoutingParameter> getRoutePreferencesDrawerAdapter(final boolean nightMode) {\n\n\t\tlistAdapter = new ArrayAdapter<LocalRoutingParameter>(mapActivity, R.layout.layers_list_activity_item, R.id.title,\n\t\t\t\tgetRoutingParameters(settings.APPLICATION_MODE.get())) {\n\t\t\t@Override\n\t\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\t\tLocalRoutingParameter parameter = getItem(position);\n\t\t\t\tif (parameter instanceof MuteSoundRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.switch_select_list_item, null);\n\t\t\t\t\tv.findViewById(R.id.description_text).setVisibility(View.GONE);\n\t\t\t\t\tv.findViewById(R.id.select_button).setVisibility(View.GONE);\n\t\t\t\t\t((ImageView) v.findViewById(R.id.icon))\n\t\t\t\t\t\t\t.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.ic_action_volume_up, !nightMode));\n\t\t\t\t\tfinal CompoundButton btn = (CompoundButton) v.findViewById(R.id.check_item);\n\t\t\t\t\tbtn.setVisibility(View.VISIBLE);\n\t\t\t\t\tbtn.setChecked(!routingHelper.getVoiceRouter().isMute());\n\t\t\t\t\tbtn.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\t\t\t\tswitchSound();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tTextView tv = (TextView) v.findViewById(R.id.header_text);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\t\ttv.setText(getString(R.string.shared_string_sound));\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof AvoidRoadsRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.switch_select_list_item, null);\n\t\t\t\t\t((ImageView) v.findViewById(R.id.icon))\n\t\t\t\t\t\t\t.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.ic_action_road_works_dark, !nightMode));\n\t\t\t\t\tv.findViewById(R.id.check_item).setVisibility(View.GONE);\n\t\t\t\t\tfinal TextView btn = (TextView) v.findViewById(R.id.select_button);\n\t\t\t\t\tbtn.setTextColor(btn.getLinkTextColors());\n\t\t\t\t\tbtn.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tselectRestrictedRoads();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tTextView tv = (TextView) v.findViewById(R.id.header_text);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\t\ttv.setText(getString(R.string.impassable_road));\n\n\t\t\t\t\tTextView tvDesc = (TextView) v.findViewById(R.id.description_text);\n\t\t\t\t\tAndroidUtils.setTextSecondaryColor(mapActivity, tvDesc, nightMode);\n\t\t\t\t\ttvDesc.setText(getString(R.string.impassable_road_desc));\n\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof VoiceGuidanceRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.switch_select_list_item, null);\n\t\t\t\t\tv.findViewById(R.id.icon).setVisibility(View.GONE);\n\t\t\t\t\tv.findViewById(R.id.description_text).setVisibility(View.GONE);\n\t\t\t\t\tv.findViewById(R.id.check_item).setVisibility(View.GONE);\n\t\t\t\t\tfinal TextView btn = (TextView) v.findViewById(R.id.select_button);\n\t\t\t\t\tbtn.setTextColor(btn.getLinkTextColors());\n\t\t\t\t\tString voiceProvider = settings.VOICE_PROVIDER.get();\n\t\t\t\t\tString voiceProviderStr;\n\t\t\t\t\tif (OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {\n\t\t\t\t\t\tvoiceProviderStr = getString(R.string.shared_string_do_not_use);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvoiceProviderStr = FileNameTranslationHelper.getVoiceName(mapActivity, voiceProvider);\n\t\t\t\t\t}\n\t\t\t\t\tvoiceProviderStr += voiceProvider.contains(\"tts\") ? \" TTS\" : \"\";\n\t\t\t\t\tbtn.setText(voiceProviderStr);\n\t\t\t\t\tbtn.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tselectVoiceGuidance();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tTextView tv = (TextView) v.findViewById(R.id.header_text);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\t\ttv.setText(getString(R.string.voice_provider));\n\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof GpxLocalRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.plan_route_gpx, null);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, (TextView) v.findViewById(R.id.GPXRouteTitle), nightMode);\n\t\t\t\t\tfinal TextView gpxSpinner = (TextView) v.findViewById(R.id.GPXRouteSpinner);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, gpxSpinner, nightMode);\n\t\t\t\t\t((ImageView) v.findViewById(R.id.dropDownIcon))\n\t\t\t\t\t\t\t.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.ic_action_arrow_drop_down, !nightMode));\n\t\t\t\t\tupdateSpinnerItems(gpxSpinner);\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof OtherSettingsRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.layers_list_activity_item, null);\n\t\t\t\t\tfinal ImageView icon = (ImageView) v.findViewById(R.id.icon);\n\t\t\t\t\ticon.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_settings, !nightMode));\n\t\t\t\t\ticon.setVisibility(View.VISIBLE);\n\t\t\t\t\tTextView titleView = (TextView) v.findViewById(R.id.title);\n\t\t\t\t\ttitleView.setText(R.string.routing_settings_2);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, titleView, nightMode);\n\t\t\t\t\tv.findViewById(R.id.check_item).setVisibility(View.GONE);\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\treturn inflateRoutingParameter(position);\n\t\t\t}\n\n\t\t\tprivate View inflateRoutingParameter(final int position) {\n\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.layers_list_activity_item, null);\n\t\t\t\tfinal TextView tv = (TextView) v.findViewById(R.id.title);\n\t\t\t\tfinal CheckBox ch = ((CheckBox) v.findViewById(R.id.check_item));\n\t\t\t\tfinal LocalRoutingParameter rp = getItem(position);\n\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\ttv.setText(rp.getText(mapActivity));\n\t\t\t\tch.setOnCheckedChangeListener(null);\n\t\t\t\tif (rp.routingParameter != null && rp.routingParameter.getId().equals(\"short_way\")) {\n\t\t\t\t\t// if short route settings - it should be inverse of fast_route_mode\n\t\t\t\t\tch.setChecked(!settings.FAST_ROUTE_MODE.get());\n\t\t\t\t} else {\n\t\t\t\t\tch.setChecked(rp.isSelected(settings));\n\t\t\t\t}\n\t\t\t\tch.setVisibility(View.VISIBLE);\n\t\t\t\tch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\t\t\t// if short way that it should set valut to fast mode opposite of current\n\t\t\t\t\t\tif (rp.routingParameter != null && rp.routingParameter.getId().equals(\"short_way\")) {\n\t\t\t\t\t\t\tsettings.FAST_ROUTE_MODE.set(!isChecked);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trp.setSelected(settings, isChecked);\n\n\t\t\t\t\t\tif (rp instanceof OtherLocalRoutingParameter) {\n\t\t\t\t\t\t\tupdateGpxRoutingParameter((OtherLocalRoutingParameter) rp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapActivity.getRoutingHelper().recalculateRouteDueToSettingsChange();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn v;\n\t\t\t}\n\t\t};\n\n\t\treturn listAdapter;\n\t}","id":32953,"modified_method":"public ArrayAdapter<LocalRoutingParameter> getRoutePreferencesDrawerAdapter(final boolean nightMode) {\n\n\t\tlistAdapter = new ArrayAdapter<LocalRoutingParameter>(mapActivity, R.layout.layers_list_activity_item, R.id.title,\n\t\t\t\tgetRoutingParameters(settings.APPLICATION_MODE.get())) {\n\t\t\t@Override\n\t\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\t\tLocalRoutingParameter parameter = getItem(position);\n\t\t\t\tif (parameter instanceof MuteSoundRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.switch_select_list_item, null);\n\t\t\t\t\tv.findViewById(R.id.description_text).setVisibility(View.GONE);\n\t\t\t\t\tv.findViewById(R.id.select_button).setVisibility(View.GONE);\n\t\t\t\t\t((ImageView) v.findViewById(R.id.icon))\n\t\t\t\t\t\t\t.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.ic_action_volume_up, !nightMode));\n\t\t\t\t\tfinal CompoundButton btn = (CompoundButton) v.findViewById(R.id.check_item);\n\t\t\t\t\tbtn.setVisibility(View.VISIBLE);\n\t\t\t\t\tbtn.setChecked(!routingHelper.getVoiceRouter().isMute());\n\t\t\t\t\tbtn.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\t\t\t\tswitchSound();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tTextView tv = (TextView) v.findViewById(R.id.header_text);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\t\ttv.setText(getString(R.string.shared_string_sound));\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof AvoidRoadsRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.switch_select_list_item, null);\n\t\t\t\t\t((ImageView) v.findViewById(R.id.icon))\n\t\t\t\t\t\t\t.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.ic_action_road_works_dark, !nightMode));\n\t\t\t\t\tv.findViewById(R.id.check_item).setVisibility(View.GONE);\n\t\t\t\t\tfinal TextView btn = (TextView) v.findViewById(R.id.select_button);\n\t\t\t\t\tbtn.setTextColor(btn.getLinkTextColors());\n\t\t\t\t\tbtn.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tselectRestrictedRoads();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tTextView tv = (TextView) v.findViewById(R.id.header_text);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\t\ttv.setText(getString(R.string.impassable_road));\n\n\t\t\t\t\tTextView tvDesc = (TextView) v.findViewById(R.id.description_text);\n\t\t\t\t\tAndroidUtils.setTextSecondaryColor(mapActivity, tvDesc, nightMode);\n\t\t\t\t\ttvDesc.setText(getString(R.string.impassable_road_desc));\n\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof VoiceGuidanceRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.switch_select_list_item, null);\n\t\t\t\t\tv.findViewById(R.id.icon).setVisibility(View.GONE);\n\t\t\t\t\tv.findViewById(R.id.description_text).setVisibility(View.GONE);\n\t\t\t\t\tv.findViewById(R.id.check_item).setVisibility(View.GONE);\n\t\t\t\t\tfinal TextView btn = (TextView) v.findViewById(R.id.select_button);\n\t\t\t\t\tbtn.setTextColor(btn.getLinkTextColors());\n\t\t\t\t\tString voiceProvider = settings.VOICE_PROVIDER.get();\n\t\t\t\t\tString voiceProviderStr;\n\t\t\t\t\tif (OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {\n\t\t\t\t\t\tvoiceProviderStr = getString(R.string.shared_string_do_not_use);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvoiceProviderStr = FileNameTranslationHelper.getVoiceName(mapActivity, voiceProvider);\n\t\t\t\t\t}\n\t\t\t\t\tvoiceProviderStr += voiceProvider.contains(\"tts\") ? \" TTS\" : \"\";\n\t\t\t\t\tbtn.setText(voiceProviderStr);\n\t\t\t\t\tbtn.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tselectVoiceGuidance(mapActivity, new CallbackWithObject<String>() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic boolean processResult(String result) {\n\t\t\t\t\t\t\t\t\tapplyVoiceProvider(mapActivity, result);\n\t\t\t\t\t\t\t\t\tupdateParameters();\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tTextView tv = (TextView) v.findViewById(R.id.header_text);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\t\ttv.setText(getString(R.string.voice_provider));\n\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof InterruptMusicRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.switch_select_list_item, null);\n\t\t\t\t\tv.findViewById(R.id.select_button).setVisibility(View.GONE);\n\t\t\t\t\tv.findViewById(R.id.icon).setVisibility(View.GONE);\n\t\t\t\t\tfinal CompoundButton btn = (CompoundButton) v.findViewById(R.id.check_item);\n\t\t\t\t\tbtn.setVisibility(View.VISIBLE);\n\t\t\t\t\tbtn.setChecked(settings.INTERRUPT_MUSIC.get());\n\t\t\t\t\tbtn.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\t\t\t\tswitchMusic();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tTextView tv = (TextView) v.findViewById(R.id.header_text);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\t\ttv.setText(getString(R.string.interrupt_music));\n\t\t\t\t\tTextView tvDesc = (TextView) v.findViewById(R.id.description_text);\n\t\t\t\t\tAndroidUtils.setTextSecondaryColor(mapActivity, tvDesc, nightMode);\n\t\t\t\t\ttvDesc.setText(getString(R.string.interrupt_music_descr));\n\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof GpxLocalRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.plan_route_gpx, null);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, (TextView) v.findViewById(R.id.GPXRouteTitle), nightMode);\n\t\t\t\t\tfinal TextView gpxSpinner = (TextView) v.findViewById(R.id.GPXRouteSpinner);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, gpxSpinner, nightMode);\n\t\t\t\t\t((ImageView) v.findViewById(R.id.dropDownIcon))\n\t\t\t\t\t\t\t.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.ic_action_arrow_drop_down, !nightMode));\n\t\t\t\t\tupdateSpinnerItems(gpxSpinner);\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tif (parameter instanceof OtherSettingsRoutingParameter) {\n\t\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.layers_list_activity_item, null);\n\t\t\t\t\tfinal ImageView icon = (ImageView) v.findViewById(R.id.icon);\n\t\t\t\t\ticon.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_settings, !nightMode));\n\t\t\t\t\ticon.setVisibility(View.VISIBLE);\n\t\t\t\t\tTextView titleView = (TextView) v.findViewById(R.id.title);\n\t\t\t\t\ttitleView.setText(R.string.routing_settings_2);\n\t\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, titleView, nightMode);\n\t\t\t\t\tv.findViewById(R.id.check_item).setVisibility(View.GONE);\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\treturn inflateRoutingParameter(position);\n\t\t\t}\n\n\t\t\tprivate View inflateRoutingParameter(final int position) {\n\t\t\t\tView v = mapActivity.getLayoutInflater().inflate(R.layout.layers_list_activity_item, null);\n\t\t\t\tfinal TextView tv = (TextView) v.findViewById(R.id.title);\n\t\t\t\tfinal CheckBox ch = ((CheckBox) v.findViewById(R.id.check_item));\n\t\t\t\tfinal LocalRoutingParameter rp = getItem(position);\n\t\t\t\tAndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);\n\t\t\t\ttv.setText(rp.getText(mapActivity));\n\t\t\t\tch.setOnCheckedChangeListener(null);\n\t\t\t\tif (rp.routingParameter != null && rp.routingParameter.getId().equals(\"short_way\")) {\n\t\t\t\t\t// if short route settings - it should be inverse of fast_route_mode\n\t\t\t\t\tch.setChecked(!settings.FAST_ROUTE_MODE.get());\n\t\t\t\t} else {\n\t\t\t\t\tch.setChecked(rp.isSelected(settings));\n\t\t\t\t}\n\t\t\t\tch.setVisibility(View.VISIBLE);\n\t\t\t\tch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\t\t\t// if short way that it should set valut to fast mode opposite of current\n\t\t\t\t\t\tif (rp.routingParameter != null && rp.routingParameter.getId().equals(\"short_way\")) {\n\t\t\t\t\t\t\tsettings.FAST_ROUTE_MODE.set(!isChecked);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trp.setSelected(settings, isChecked);\n\n\t\t\t\t\t\tif (rp instanceof OtherLocalRoutingParameter) {\n\t\t\t\t\t\t\tupdateGpxRoutingParameter((OtherLocalRoutingParameter) rp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapActivity.getRoutingHelper().recalculateRouteDueToSettingsChange();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn v;\n\t\t\t}\n\t\t};\n\n\t\treturn listAdapter;\n\t}","commit_id":"7839f0b933062061cbb205d42d47bb41dafdd655","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private Set<String> getVoiceFiles() {\n\t\t// read available voice data\n\t\tFile extStorage = app.getAppPath(IndexConstants.VOICE_INDEX_DIR);\n\t\tSet<String> setFiles = new LinkedHashSet<>();\n\t\tif (extStorage.exists()) {\n\t\t\tfor (File f : extStorage.listFiles()) {\n\t\t\t\tif (f.isDirectory()) {\n\t\t\t\t\tsetFiles.add(f.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn setFiles;\n\t}","id":32954,"modified_method":"private static Set<String> getVoiceFiles(MapActivity mapActivity) {\n\t\t// read available voice data\n\t\tFile extStorage = mapActivity.getMyApplication().getAppPath(IndexConstants.VOICE_INDEX_DIR);\n\t\tSet<String> setFiles = new LinkedHashSet<>();\n\t\tif (extStorage.exists()) {\n\t\t\tfor (File f : extStorage.listFiles()) {\n\t\t\t\tif (f.isDirectory()) {\n\t\t\t\t\tsetFiles.add(f.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn setFiles;\n\t}","commit_id":"7839f0b933062061cbb205d42d47bb41dafdd655","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public OnItemClickListener getItemClickListener(final ArrayAdapter<?> listAdapter) {\n\t\treturn new OnItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemClick(AdapterView<?> adapterView, View view, int item, long l) {\n\t\t\t\tObject obj = listAdapter.getItem(item);\n\t\t\t\tif (obj instanceof OtherSettingsRoutingParameter) {\n\t\t\t\t\tfinal Intent settings = new Intent(mapActivity, SettingsNavigationActivity.class);\n\t\t\t\t\tsettings.putExtra(SettingsNavigationActivity.INTENT_SKIP_DIALOG, true);\n\t\t\t\t\tmapActivity.startActivity(settings);\n\t\t\t\t} else if (obj instanceof MuteSoundRoutingParameter) {\n\t\t\t\t\tfinal CompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);\n\t\t\t\t\tbtn.performClick();\n\t\t\t\t} else if (obj instanceof VoiceGuidanceRoutingParameter) {\n\t\t\t\t\tfinal TextView btn = (TextView) view.findViewById(R.id.select_button);\n\t\t\t\t\tbtn.performClick();\n\t\t\t\t} else if (obj instanceof AvoidRoadsRoutingParameter) {\n\t\t\t\t\tselectRestrictedRoads();\n\t\t\t\t} else if (view.findViewById(R.id.GPXRouteSpinner) != null) {\n\t\t\t\t\tshowOptionsMenu((TextView) view.findViewById(R.id.GPXRouteSpinner));\n\t\t\t\t} else {\n\t\t\t\t\tCheckBox ch = (CheckBox) view.findViewById(R.id.check_item);\n\t\t\t\t\tif (ch != null) {\n\t\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","id":32955,"modified_method":"public OnItemClickListener getItemClickListener(final ArrayAdapter<?> listAdapter) {\n\t\treturn new OnItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemClick(AdapterView<?> adapterView, View view, int item, long l) {\n\t\t\t\tObject obj = listAdapter.getItem(item);\n\t\t\t\tif (obj instanceof OtherSettingsRoutingParameter) {\n\t\t\t\t\tfinal Intent settings = new Intent(mapActivity, SettingsNavigationActivity.class);\n\t\t\t\t\tsettings.putExtra(SettingsNavigationActivity.INTENT_SKIP_DIALOG, true);\n\t\t\t\t\tmapActivity.startActivity(settings);\n\t\t\t\t} else if (obj instanceof MuteSoundRoutingParameter) {\n\t\t\t\t\tfinal CompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);\n\t\t\t\t\tbtn.performClick();\n\t\t\t\t} else if (obj instanceof VoiceGuidanceRoutingParameter) {\n\t\t\t\t\tfinal TextView btn = (TextView) view.findViewById(R.id.select_button);\n\t\t\t\t\tbtn.performClick();\n\t\t\t\t} else if (obj instanceof InterruptMusicRoutingParameter) {\n\t\t\t\t\tfinal CompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);\n\t\t\t\t\tbtn.performClick();\n\t\t\t\t} else if (obj instanceof AvoidRoadsRoutingParameter) {\n\t\t\t\t\tselectRestrictedRoads();\n\t\t\t\t} else if (view.findViewById(R.id.GPXRouteSpinner) != null) {\n\t\t\t\t\tshowOptionsMenu((TextView) view.findViewById(R.id.GPXRouteSpinner));\n\t\t\t\t} else {\n\t\t\t\t\tCheckBox ch = (CheckBox) view.findViewById(R.id.check_item);\n\t\t\t\t\tif (ch != null) {\n\t\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","commit_id":"7839f0b933062061cbb205d42d47bb41dafdd655","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private List<LocalRoutingParameter> getRoutingParameters(ApplicationMode am) {\n\t\tList<LocalRoutingParameter> list = getRoutingParametersInner(am);\n\t\tlist.add(0, new MuteSoundRoutingParameter());\n\t\tlist.add(1, new VoiceGuidanceRoutingParameter());\n\t\tlist.add(2, new AvoidRoadsRoutingParameter());\n\t\tlist.add(new GpxLocalRoutingParameter());\n\t\tlist.add(new OtherSettingsRoutingParameter());\n\t\treturn list;\n\t}","id":32956,"modified_method":"private List<LocalRoutingParameter> getRoutingParameters(ApplicationMode am) {\n\t\tList<LocalRoutingParameter> list = getRoutingParametersInner(am);\n\t\tlist.add(0, new MuteSoundRoutingParameter());\n\t\tlist.add(1, new VoiceGuidanceRoutingParameter());\n\t\tlist.add(2, new InterruptMusicRoutingParameter());\n\t\tlist.add(3, new AvoidRoadsRoutingParameter());\n\t\tlist.add(new GpxLocalRoutingParameter());\n\t\tlist.add(new OtherSettingsRoutingParameter());\n\t\treturn list;\n\t}","commit_id":"7839f0b933062061cbb205d42d47bb41dafdd655","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void processHistoryEvent(ValueChangeEvent<String> event)\n   {\n      try\n      {\n\n      // TODO keep track of previous history token like in DocumentListPresenter\n\n      Log.info(\"Responding to history token: \" + event.getValue());\n\n      HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n\n      DocumentId docId = documentListPresenter.getDocumentId(token.getDocumentPath());\n\n      if (docId != null && (selectedDocument == null || !selectedDocument.getId().equals(docId)))\n      {\n         Log.info(\"Firing document selection event\");\n         try\n         {\n            eventBus.fireEvent(new DocumentSelectionEvent(docId));\n         }\n         catch (Throwable t)\n         {\n            Log.info(\"got exception from document selection event\", t);\n         }\n         Log.info(\"Fired document selection event for \" + docId.getId());\n      }\n\n      if (token.hasView() && token.getView() != display.getCurrentView())\n      {\n         if (display.getCurrentView().equals(MainView.Editor))\n         {\n            translationPresenter.saveEditorPendingChange();\n         }\n         else\n         { // document list view\n            if (selectedDocument != null)\n            {\n               display.setSelectedDocument(selectedDocument);\n            }\n         }\n         display.showInMainView(token.getView());\n      }\n      // TODO set defaults in history rather than having this block.\n      else if (!token.hasView())\n      {\n         // default view.\n         display.showInMainView(MainView.Documents);\n      }\n\n      // TODO use a cloned token below when the current token is stored. Ok to\n      // modify current token for now. (add clone method when doing this)\n\n      // update toggle link with alternate view latest history state\n      if (token.hasView() && token.getView().equals(MainView.Editor))\n      {\n         token.setView(MainView.Documents);\n      }\n      else\n      { // doclist is default\n         token.setView(MainView.Editor);\n      }\n      ((Anchor) display.getDocumentsLink()).setHref(\"#\" + token.toTokenString());\n\n      }\n      catch (Throwable t)\n      {\n         Log.error(\"exception while responding to history token\", t);\n      }\n\n   }","id":32957,"modified_method":"private void processHistoryEvent(ValueChangeEvent<String> event)\n   {\n      try\n      {\n         Log.info(\"Responding to history token: \" + event.getValue());\n\n         HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n\n         DocumentId docId = documentListPresenter.getDocumentId(token.getDocumentPath());\n\n         if (docId != null && (selectedDocument == null || !selectedDocument.getId().equals(docId)))\n         {\n            Log.info(\"Firing document selection event\");\n            try\n            {\n               eventBus.fireEvent(new DocumentSelectionEvent(docId));\n            }\n            catch (Throwable t)\n            {\n               Log.info(\"got exception from document selection event\", t);\n            }\n            Log.info(\"Fired document selection event for \" + docId.getId());\n         }\n\n         if (token.getView() != display.getCurrentView())\n         {\n            if (display.getCurrentView().equals(MainView.Editor))\n            {\n               translationPresenter.saveEditorPendingChange();\n            }\n            else\n            { // document list view\n               if (selectedDocument != null)\n               {\n                  display.setSelectedDocument(selectedDocument);\n               }\n            }\n            display.showInMainView(token.getView());\n         }\n\n         // update toggle link with alternate view latest history state\n         if (token.getView().equals(MainView.Editor))\n            token.setView(MainView.Documents);\n         else\n            token.setView(MainView.Editor);\n         ((Anchor) display.getDocumentsLink()).setHref(\"#\" + token.toTokenString());\n      }\n      catch (Throwable t)\n      {\n         Log.error(\"exception while responding to history token\", t);\n      }\n\n   }","commit_id":"4e73570da679178c62b514e1c6477c2418aed181","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n\n      registerHandler(display.getDocumentList().addSelectionHandler(new SelectionHandler<DocumentInfo>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<DocumentInfo> event)\n         {\n            // generate history token\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n\n            // prevent feedback loops between history and selection\n            boolean isNewSelection;\n            DocumentId docId = getDocumentId(token.getDocumentPath());\n            if (docId == null)\n            {\n               isNewSelection = true;\n            }\n            else\n            {\n               isNewSelection = docId.equals(event.getSelectedItem().getId());\n            }\n\n            if (isNewSelection)\n            {\n               currentDocument = event.getSelectedItem();\n               token.setDocumentPath(event.getSelectedItem().getPath() + event.getSelectedItem().getName());\n               token.setView(MainView.Editor);\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler()\n      {\n         @Override\n         public void onDocumentSelected(DocumentSelectionEvent event)\n         {\n            // match bookmarked selection, but prevent selection feedback loop\n            // from history\n            if (event.getDocumentId() != (currentDocument == null ? null : currentDocument.getId()))\n            {\n               setSelection(event.getDocumentId());\n            }\n         }\n      }));\n\n      registerHandler(display.getFilterTextBox().addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (event.getValue() != token.getDocFilterText())\n            {\n               token.setDocFilterText(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(display.getExactSearchCheckbox().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (event.getValue() != token.getDocFilterExact())\n            {\n               token.setDocFilterExact(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      History.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            try\n            {\n               boolean filterChanged = false;\n               HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n               if (token.hasDocFilterText())\n               {\n                  // update textbox to match new history state\n                  if (!token.getDocFilterText().equals(display.getFilterTextBox().getValue()))\n                  {\n                     display.getFilterTextBox().setValue(token.getDocFilterText(), true);\n                  }\n\n                  boolean patternChanged;\n                  if (currentHistoryState == null)\n                     patternChanged = true;\n                  else\n                     patternChanged = !token.getDocFilterText().equals(currentHistoryState.getDocFilterText());\n                  if (patternChanged)\n                  {\n                     filter.setPattern(token.getDocFilterText());\n                     filterChanged = true;\n                  }\n               }\n               else\n               {\n                  if (currentHistoryState != null && currentHistoryState.hasDocFilterText())\n                  {\n                     // not using default\n                     filter.setPattern(\"\");\n                     filterChanged = true;\n                  }\n                  // else was already using blank filter\n               }\n\n               if (token.hasDocFilterExact())\n               {\n                  // update checkbox to match new history state\n                  if (token.getDocFilterExact() != display.getExactSearchCheckbox().getValue())\n                  {\n                     display.getExactSearchCheckbox().setValue(token.getDocFilterExact());\n                  }\n\n                  boolean flagChanged;\n                  if (currentHistoryState == null)\n                     flagChanged = true;\n                  else\n                     flagChanged = !token.getDocFilterExact().equals(currentHistoryState.getDocFilterExact());\n\n                  if (flagChanged)\n                  {\n                     filter.setFullText(token.getDocFilterExact());\n                     filterChanged = true;\n                  }\n               }\n               else\n               {\n                  if (currentHistoryState != null && currentHistoryState.hasDocFilterExact() && currentHistoryState.getDocFilterExact() == true)\n                  {\n                     // not using default\n                     filter.setFullText(false);\n                     filterChanged = true;\n                  }\n                  // else was already using substring match\n               }\n\n               currentHistoryState = token;\n\n               if (filterChanged)\n                  runFilter();\n            }\n            catch (Throwable t)\n            {\n               Log.error(\"exception with doclistpresenter responding to histroy token\", t);\n            }\n         }\n      });\n\n      registerHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler()\n      {\n         @Override\n         public void onTransUnitUpdated(TransUnitUpdatedEvent event)\n         {\n            DocumentId docId = event.getDocumentId();\n            TransUnitUpdatedEventHandler handler = nodes.get(docId);\n            if (handler != null)\n               handler.onTransUnitUpdated(event);\n         }\n      }));\n\n      loadDocumentList();\n   }","id":32958,"modified_method":"@Override\n   protected void onBind()\n   {\n\n      registerHandler(display.getDocumentList().addSelectionHandler(new SelectionHandler<DocumentInfo>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<DocumentInfo> event)\n         {\n            // generate history token\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n\n            // prevent feedback loops between history and selection\n            boolean isNewSelection;\n            DocumentId docId = getDocumentId(token.getDocumentPath());\n            if (docId == null)\n            {\n               isNewSelection = true;\n            }\n            else\n            {\n               isNewSelection = !docId.equals(event.getSelectedItem().getId());\n            }\n\n            if (isNewSelection)\n            {\n               currentDocument = event.getSelectedItem();\n               token.setDocumentPath(event.getSelectedItem().getPath() + event.getSelectedItem().getName());\n               token.setView(MainView.Editor);\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler()\n      {\n         @Override\n         public void onDocumentSelected(DocumentSelectionEvent event)\n         {\n            // match bookmarked selection, but prevent selection feedback loop\n            // from history\n            if (event.getDocumentId() != (currentDocument == null ? null : currentDocument.getId()))\n            {\n               setSelection(event.getDocumentId());\n            }\n         }\n      }));\n\n      registerHandler(display.getFilterTextBox().addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (event.getValue() != token.getDocFilterText())\n            {\n               token.setDocFilterText(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(display.getExactSearchCheckbox().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (event.getValue() != token.getDocFilterExact())\n            {\n               token.setDocFilterExact(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      History.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            try\n            {\n               boolean filterChanged = false;\n               HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n               if (token.hasDocFilterText())\n               {\n                  // update textbox to match new history state\n                  if (!token.getDocFilterText().equals(display.getFilterTextBox().getValue()))\n                  {\n                     display.getFilterTextBox().setValue(token.getDocFilterText(), true);\n                  }\n\n                  boolean patternChanged;\n                  if (currentHistoryState == null)\n                     patternChanged = true;\n                  else\n                     patternChanged = !token.getDocFilterText().equals(currentHistoryState.getDocFilterText());\n                  if (patternChanged)\n                  {\n                     filter.setPattern(token.getDocFilterText());\n                     filterChanged = true;\n                  }\n               }\n               else\n               {\n                  if (currentHistoryState != null && currentHistoryState.hasDocFilterText())\n                  {\n                     // not using default\n                     filter.setPattern(\"\");\n                     filterChanged = true;\n                  }\n                  // else was already using blank filter\n               }\n\n               if (token.hasDocFilterExact())\n               {\n                  // update checkbox to match new history state\n                  if (token.getDocFilterExact() != display.getExactSearchCheckbox().getValue())\n                  {\n                     display.getExactSearchCheckbox().setValue(token.getDocFilterExact());\n                  }\n\n                  boolean flagChanged;\n                  if (currentHistoryState == null)\n                     flagChanged = true;\n                  else\n                     flagChanged = !token.getDocFilterExact().equals(currentHistoryState.getDocFilterExact());\n\n                  if (flagChanged)\n                  {\n                     filter.setFullText(token.getDocFilterExact());\n                     filterChanged = true;\n                  }\n               }\n               else\n               {\n                  if (currentHistoryState != null && currentHistoryState.hasDocFilterExact() && currentHistoryState.getDocFilterExact() == true)\n                  {\n                     // not using default\n                     filter.setFullText(false);\n                     filterChanged = true;\n                  }\n                  // else was already using substring match\n               }\n\n               currentHistoryState = token;\n\n               if (filterChanged)\n                  runFilter();\n            }\n            catch (Throwable t)\n            {\n               Log.error(\"exception with doclistpresenter responding to histroy token\", t);\n            }\n         }\n      });\n\n      registerHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler()\n      {\n         @Override\n         public void onTransUnitUpdated(TransUnitUpdatedEvent event)\n         {\n            DocumentId docId = event.getDocumentId();\n            TransUnitUpdatedEventHandler handler = nodes.get(docId);\n            if (handler != null)\n               handler.onTransUnitUpdated(event);\n         }\n      }));\n\n      loadDocumentList();\n   }","commit_id":"4e73570da679178c62b514e1c6477c2418aed181","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Generate a history token from the given token string\n    * \n    * @param token A GWT history token in the form key1:value1,key2:value2,...\n    */\n   public static HistoryToken fromTokenString(String token)\n   {\n      HistoryToken historyToken = new HistoryToken();\n\n\n      if (token == null || token.length() == 0)\n      {\n         return historyToken;\n      }\n\n      String[] pair;\n      for (String pairString : token.split(PAIR_SEPARATOR))\n      {\n         pair = pairString.split(DELIMITER_K_V);\n         String key;\n         String value;\n         try\n         {\n            key = pair[0];\n            value = pair[1];\n         }\n         catch (ArrayIndexOutOfBoundsException e)\n         {\n            continue;\n         }\n\n         if (key == HistoryToken.KEY_DOCUMENT)\n         {\n            historyToken.setDocumentPath(value);\n         }\n         else if (key == HistoryToken.KEY_VIEW)\n         {\n            if (value.equals(VALUE_EDITOR_VIEW))\n            {\n               historyToken.setView(AppPresenter.Display.MainView.Editor);\n            }\n            else if (value.equals(VALUE_DOCLIST_VIEW))\n            {\n               historyToken.setView(AppPresenter.Display.MainView.Documents);\n            }\n            else\n            { // invalid view\n               historyToken.setView(null);\n            }\n         }\n         else if (key == HistoryToken.KEY_DOC_FILTER_OPTION)\n         {\n            if (value == VALUE_DOC_FILTER_EXACT)\n               historyToken.setDocFilterExact(true);\n            else if (value == VALUE_DOC_FILTER_INEXACT)\n               historyToken.setDocFilterExact(false);\n         }\n         else if (key == HistoryToken.KEY_DOC_FILTER_TEXT)\n         {\n            historyToken.setDocFilterText(value);\n         }\n\n         else\n            Log.info(\"unrecognised history key: \" + key);\n\n      }\n\n      return historyToken;\n   }","id":32959,"modified_method":"/**\n    * Generate a history token from the given token string\n    * \n    * @param token A GWT history token in the form key1:value1,key2:value2,...\n    */\n   public static HistoryToken fromTokenString(String token)\n   {\n      HistoryToken historyToken = new HistoryToken();\n\n      if (token == null || token.length() == 0)\n      {\n         return historyToken;\n      }\n\n      for (String pairString : token.split(PAIR_SEPARATOR))\n      {\n         String[] pair = pairString.split(DELIMITER_K_V);\n         String key;\n         String value;\n         try\n         {\n            key = pair[0];\n            value = pair[1];\n         }\n         catch (ArrayIndexOutOfBoundsException e)\n         {\n            continue;\n         }\n\n         if (key == HistoryToken.KEY_DOCUMENT)\n         {\n            historyToken.setDocumentPath(value);\n         }\n         else if (key == HistoryToken.KEY_VIEW)\n         {\n            if (value.equals(VALUE_EDITOR_VIEW))\n            {\n               historyToken.setView(AppPresenter.Display.MainView.Editor);\n            }\n            // else default will be used\n         }\n         else if (key == HistoryToken.KEY_DOC_FILTER_OPTION)\n         {\n            if (value == VALUE_DOC_FILTER_EXACT)\n               historyToken.setDocFilterExact(true);\n            else if (value == VALUE_DOC_FILTER_INEXACT)\n               historyToken.setDocFilterExact(false);\n         }\n         else if (key == HistoryToken.KEY_DOC_FILTER_TEXT)\n         {\n            historyToken.setDocFilterText(value);\n         }\n\n         else\n            Log.info(\"unrecognised history key: \" + key);\n\n      }\n\n      return historyToken;\n   }","commit_id":"4e73570da679178c62b514e1c6477c2418aed181","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setView(AppPresenter.Display.MainView view)\n   {\n      this.view = view;\n   }","id":32960,"modified_method":"public void setView(AppPresenter.Display.MainView view)\n   {\n      if (view == null)\n         this.view = DEFAULT_VIEW;\n      else\n         this.view = view;\n   }","commit_id":"4e73570da679178c62b514e1c6477c2418aed181","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @return a token string for use with\n    *         {@link com.google.gwt.user.client.History}\n    */\n   public String toTokenString()\n   {\n      String token = \"\";\n      boolean first = true;\n\n      if (hasView())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_VIEW + DELIMITER_K_V;\n         if (view == AppPresenter.Display.MainView.Editor)\n         {\n            token += VALUE_EDITOR_VIEW;\n         }\n         else if (view == AppPresenter.Display.MainView.Documents)\n         {\n            token += VALUE_DOCLIST_VIEW;\n         }\n      }\n\n      if (!fullDocPath.equals(DEFAULT_DOCUMENT_PATH))\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOCUMENT + DELIMITER_K_V + fullDocPath;\n      }\n\n      if (hasDocFilterExact())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_OPTION + DELIMITER_K_V;\n         token += docFilterExact ? VALUE_DOC_FILTER_EXACT : VALUE_DOC_FILTER_INEXACT;\n      }\n\n      if (hasDocFilterText())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_TEXT + DELIMITER_K_V + docFilterText;\n      }\n\n      return token;\n   }","id":32961,"modified_method":"/**\n    * @return a token string for use with\n    *         {@link com.google.gwt.user.client.History}\n    */\n   public String toTokenString()\n   {\n      String token = \"\";\n      boolean first = true;\n\n      if (view != DEFAULT_VIEW)\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         // editor is the only non-default view\n         token += KEY_VIEW + DELIMITER_K_V + VALUE_EDITOR_VIEW;\n      }\n\n      if (!fullDocPath.equals(DEFAULT_DOCUMENT_PATH))\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOCUMENT + DELIMITER_K_V + fullDocPath;\n      }\n\n      if (hasDocFilterExact())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_OPTION + DELIMITER_K_V;\n         token += docFilterExact ? VALUE_DOC_FILTER_EXACT : VALUE_DOC_FILTER_INEXACT;\n      }\n\n      if (hasDocFilterText())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_TEXT + DELIMITER_K_V + docFilterText;\n      }\n\n      return token;\n   }","commit_id":"4e73570da679178c62b514e1c6477c2418aed181","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void processHistoryEvent(ValueChangeEvent<String> event)\n   {\n\n      // TODO keep track of previous history token like in DocumentListPresenter\n\n      Log.info(\"Responding to history token: \" + event.getValue());\n\n      HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n\n      DocumentId docId = documentListPresenter.getDocumentId(token.getDocumentPath());\n\n      if (token.hasDocumentPath() && (selectedDocument == null || !selectedDocument.getId().equals(docId)))\n      {\n         Log.info(\"Firing document selection event\");\n         try\n         {\n            eventBus.fireEvent(new DocumentSelectionEvent(docId));\n         }\n         catch (Throwable t)\n         {\n            Log.info(\"got exception from document selection event\", t);\n         }\n         Log.info(\"Fired document selection event for \" + docId.getId());\n      }\n\n      if (token.hasView() && token.getView() != display.getCurrentView())\n      {\n         if (display.getCurrentView().equals(MainView.Editor))\n         {\n            translationPresenter.saveEditorPendingChange();\n         }\n         else\n         { // document list view\n            if (selectedDocument != null)\n            {\n               display.setSelectedDocument(selectedDocument);\n            }\n         }\n         display.showInMainView(token.getView());\n      }\n      // TODO set defaults in history rather than having this block.\n      else if (!token.hasView())\n      {\n         // default view.\n         display.showInMainView(MainView.Documents);\n      }\n\n      // TODO use a cloned token below when the current token is stored. Ok to\n      // modify current token for now. (add clone method when doing this)\n\n      // update toggle link with alternate view latest history state\n      if (token.hasView() && token.getView().equals(MainView.Editor))\n      {\n         token.setView(MainView.Documents);\n      }\n      else\n      { // doclist is default\n         token.setView(MainView.Editor);\n      }\n      ((Anchor) display.getDocumentsLink()).setHref(\"#\" + token.toTokenString());\n\n   }","id":32962,"modified_method":"private void processHistoryEvent(ValueChangeEvent<String> event)\n   {\n      Log.info(\"Responding to history token: \" + event.getValue());\n\n      HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n\n      DocumentId docId = documentListPresenter.getDocumentId(token.getDocumentPath());\n\n      if (docId != null && (selectedDocument == null || !selectedDocument.getId().equals(docId)))\n      {\n         Log.info(\"Firing document selection event for document \" + docId.getId());\n         eventBus.fireEvent(new DocumentSelectionEvent(docId));\n      }\n\n\n      if (token.getView() != currentHistoryState.getView())\n      {\n         if (display.getCurrentView().equals(MainView.Editor))\n         {\n            translationPresenter.saveEditorPendingChange();\n         }\n         else\n         { // document list view\n            if (selectedDocument != null)\n            {\n               display.setSelectedDocument(selectedDocument);\n            }\n         }\n         display.showInMainView(token.getView());\n      }\n\n      currentHistoryState = token;\n\n      // update toggle link with alternate view latest history state\n      HistoryToken toggleToken = (HistoryToken) token.clone();\n      if (toggleToken.getView().equals(MainView.Editor))\n      {\n         toggleToken.setView(MainView.Documents);\n      }\n      else\n      {\n         toggleToken.setView(MainView.Editor);\n      }\n      ((Anchor) display.getDocumentsLink()).setHref(\"#\" + toggleToken.toTokenString());\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n\n      registerHandler(display.getDocumentList().addSelectionHandler(new SelectionHandler<DocumentInfo>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<DocumentInfo> event)\n         {\n            // generate history token\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n\n            // prevent feedback loops between history and selection\n            boolean isNewSelection;\n            if (token.hasDocumentPath())\n            {\n               try\n               {\n                  isNewSelection = event.getSelectedItem().getId().getId() != getDocumentId(token.getDocumentPath()).getId();\n               }\n               catch (Throwable t)\n               {\n                  Log.info(\"got exception determining whether selection is new\", t);\n                  isNewSelection = false;\n               }\n            }\n            else\n            {\n               isNewSelection = true;\n            }\n\n            if (isNewSelection)\n            {\n               currentDocument = event.getSelectedItem();\n               token.setDocumentPath(event.getSelectedItem().getPath() + event.getSelectedItem().getName());\n               token.setView(MainView.Editor);\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler()\n      {\n         @Override\n         public void onDocumentSelected(DocumentSelectionEvent event)\n         {\n            // match bookmarked selection, but prevent selection feedback loop\n            // from history\n            if (event.getDocumentId() != (currentDocument == null ? null : currentDocument.getId()))\n            {\n               setSelection(event.getDocumentId());\n            }\n         }\n      }));\n\n      registerHandler(display.getFilterTextBox().addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (event.getValue() != token.getDocFilterText())\n            {\n               token.setDocFilterText(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(display.getExactSearchCheckbox().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (event.getValue() != token.getDocFilterExact())\n            {\n               token.setDocFilterExact(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      History.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            boolean filterChanged = false;\n            HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n            if (token.hasDocFilterText())\n            {\n               // update textbox to match new history state\n               if (!token.getDocFilterText().equals(display.getFilterTextBox().getValue()))\n               {\n                  display.getFilterTextBox().setValue(token.getDocFilterText(), true);\n               }\n\n               boolean patternChanged;\n               if (currentHistoryState == null)\n                  patternChanged = true;\n               else\n                  patternChanged = !token.getDocFilterText().equals(currentHistoryState.getDocFilterText());\n               if (patternChanged)\n               {\n                  filter.setPattern(token.getDocFilterText());\n                  filterChanged = true;\n               }\n            }\n            else\n            {\n               if (currentHistoryState != null && currentHistoryState.hasDocFilterText())\n               {\n                  // not using default\n                  filter.setPattern(\"\");\n                  filterChanged = true;\n               }\n               // else was already using blank filter\n            }\n\n            if (token.hasDocFilterExact())\n            {\n               // update checkbox to match new history state\n               if (token.getDocFilterExact() != display.getExactSearchCheckbox().getValue())\n               {\n                  display.getExactSearchCheckbox().setValue(token.getDocFilterExact());\n               }\n\n               boolean flagChanged;\n               if (currentHistoryState == null)\n                  flagChanged = true;\n               else\n                  flagChanged = !token.getDocFilterExact().equals(currentHistoryState.getDocFilterExact());\n\n               if (flagChanged)\n               {\n                  filter.setFullText(token.getDocFilterExact());\n                  filterChanged = true;\n               }\n            }\n            else\n            {\n               if (currentHistoryState != null && currentHistoryState.hasDocFilterExact() && currentHistoryState.getDocFilterExact() == true)\n               {\n                  // not using default\n                  filter.setFullText(false);\n                  filterChanged = true;\n               }\n               // else was already using substring match\n            }\n\n            currentHistoryState = token;\n\n            if (filterChanged)\n               runFilter();\n         }\n      });\n\n      registerHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler()\n      {\n         @Override\n         public void onTransUnitUpdated(TransUnitUpdatedEvent event)\n         {\n            DocumentId docId = event.getDocumentId();\n            TransUnitUpdatedEventHandler handler = nodes.get(docId);\n            if (handler != null)\n               handler.onTransUnitUpdated(event);\n         }\n      }));\n\n      loadDocumentList();\n   }","id":32963,"modified_method":"@Override\n   protected void onBind()\n   {\n\n      registerHandler(display.getDocumentList().addSelectionHandler(new SelectionHandler<DocumentInfo>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<DocumentInfo> event)\n         {\n            // generate history token\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n\n            // prevent feedback loops between history and selection\n            DocumentId docId = getDocumentId(token.getDocumentPath());\n            if (event.getSelectedItem().getId().equals(docId))\n            {\n               currentDocument = event.getSelectedItem();\n               token.setDocumentPath(event.getSelectedItem().getPath() + event.getSelectedItem().getName());\n               token.setView(MainView.Editor);\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler()\n      {\n         @Override\n         public void onDocumentSelected(DocumentSelectionEvent event)\n         {\n            // match bookmarked selection, but prevent selection feedback loop\n            // from history\n            if (event.getDocumentId() != (currentDocument == null ? null : currentDocument.getId()))\n            {\n               setSelection(event.getDocumentId());\n            }\n         }\n      }));\n\n      registerHandler(display.getFilterTextBox().addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (!token.getDocFilterText().equals(event.getValue()))\n            {\n               token.setDocFilterText(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      registerHandler(display.getExactSearchCheckbox().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(History.getToken());\n            if (event.getValue() != token.getDocFilterExact())\n            {\n               token.setDocFilterExact(event.getValue());\n               History.newItem(token.toTokenString());\n            }\n         }\n      }));\n\n      History.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(event.getValue());\n            // update textbox to match new history state\n            if (!token.getDocFilterText().equals(display.getFilterTextBox().getValue()))\n               display.getFilterTextBox().setValue(token.getDocFilterText(), true);\n\n            boolean patternChanged = true;\n            if (currentHistoryState != null)\n               patternChanged = !token.getDocFilterText().equals(currentHistoryState.getDocFilterText());\n            if (patternChanged)\n               filter.setPattern(token.getDocFilterText());\n\n            // update checkbox to match new history state\n            if (token.getDocFilterExact() != display.getExactSearchCheckbox().getValue())\n               display.getExactSearchCheckbox().setValue(token.getDocFilterExact());\n\n            boolean flagChanged = true;\n            if (currentHistoryState != null)\n               flagChanged = token.getDocFilterExact() != currentHistoryState.getDocFilterExact();\n            if (flagChanged)\n               filter.setFullText(token.getDocFilterExact());\n\n            currentHistoryState = token;\n\n            if (patternChanged || flagChanged)\n               runFilter();\n         }\n      });\n\n      registerHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler()\n      {\n         @Override\n         public void onTransUnitUpdated(TransUnitUpdatedEvent event)\n         {\n            DocumentId docId = event.getDocumentId();\n            TransUnitUpdatedEventHandler handler = nodes.get(docId);\n            if (handler != null)\n               handler.onTransUnitUpdated(event);\n         }\n      }));\n\n      loadDocumentList();\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String getDocFilterText()\n   {\n      return docFilterText;\n   }","id":32964,"modified_method":"/**\n    * \n    * @return the string against which to filter the document list. May be an\n    *         empty string, will never be null.\n    */\n   public String getDocFilterText()\n   {\n      if (docFilterText == null)\n         return DEFAULT_DOC_FILTER_TEXT;\n      return docFilterText;\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @return a token string for use with\n    *         {@link com.google.gwt.user.client.History}\n    */\n   public String toTokenString()\n   {\n      String token = \"\";\n      boolean first = true;\n\n      if (hasView())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_VIEW + DELIMITER_K_V;\n         if (view == AppPresenter.Display.MainView.Editor)\n         {\n            token += VALUE_EDITOR_VIEW;\n         }\n         else if (view == AppPresenter.Display.MainView.Documents)\n         {\n            token += VALUE_DOCLIST_VIEW;\n         }\n      }\n\n      if (hasDocumentPath())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOCUMENT + DELIMITER_K_V + fullDocPath.toString();\n      }\n\n      if (hasDocFilterExact())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_OPTION + DELIMITER_K_V;\n         token += docFilterExact ? VALUE_DOC_FILTER_EXACT : VALUE_DOC_FILTER_INEXACT;\n      }\n\n      if (hasDocFilterText())\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_TEXT + DELIMITER_K_V + docFilterText;\n      }\n\n      return token;\n   }","id":32965,"modified_method":"/**\n    * Generates a token string to represent this {@link HistoryToken}. Fields\n    * that have their default value are not included in the string.\n    * \n    * @return a token string for use with\n    *         {@link com.google.gwt.user.client.History}\n    */\n   public String toTokenString()\n   {\n      String token = \"\";\n      boolean first = true;\n\n      if (getView() != DEFAULT_VIEW)\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_VIEW + DELIMITER_K_V;\n         // this conditional is unnecessary\n         if (view == AppPresenter.Display.MainView.Editor)\n         {\n            token += VALUE_EDITOR_VIEW;\n         }\n      }\n\n      if (!getDocumentPath().equals(DEFAULT_DOCUMENT_PATH))\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOCUMENT + DELIMITER_K_V + fullDocPath;\n      }\n\n      if (getDocFilterExact() != DEFAULT_DOC_FILTER_EXACT)\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_OPTION + DELIMITER_K_V;\n         // this is redundant if defaults don't change\n         token += docFilterExact ? VALUE_DOC_FILTER_EXACT : VALUE_DOC_FILTER_INEXACT;\n      }\n\n      if (!getDocFilterText().equals(DEFAULT_DOC_FILTER_TEXT))\n      {\n         if (first)\n            first = false;\n         else\n            token += PAIR_SEPARATOR;\n         token += KEY_DOC_FILTER_TEXT + DELIMITER_K_V + docFilterText;\n      }\n\n      return token;\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Generate a history token from the given token string\n    * \n    * @param token A GWT history token in the form key1:value1,key2:value2,...\n    */\n   public static HistoryToken fromTokenString(String token)\n   {\n      HistoryToken historyToken = new HistoryToken();\n\n      String[] pair;\n\n      try\n      {\n         for (String pairString : token.split(PAIR_SEPARATOR))\n         {\n            pair = pairString.split(DELIMITER_K_V);\n            String key = pair[0];\n            String value = pair[1];\n\n            if (key == HistoryToken.KEY_DOCUMENT)\n            {\n               try\n               {\n                  historyToken.setDocumentPath((value));\n               }\n               catch (NullPointerException e)\n               {\n                  historyToken.setDocumentPath(null);\n               }\n               catch (NumberFormatException e)\n               {\n                  historyToken.setDocumentPath(null);\n               }\n            }\n            else if (key == HistoryToken.KEY_VIEW)\n            {\n               if (value.equals(VALUE_EDITOR_VIEW))\n               {\n                  historyToken.setView(AppPresenter.Display.MainView.Editor);\n               }\n               else if (value.equals(VALUE_DOCLIST_VIEW))\n               {\n                  historyToken.setView(AppPresenter.Display.MainView.Documents);\n               }\n               else\n               { // invalid view\n                  historyToken.setView(null);\n               }\n            }\n            else if (key == HistoryToken.KEY_DOC_FILTER_OPTION)\n            {\n               if (value == VALUE_DOC_FILTER_EXACT)\n                  historyToken.setDocFilterExact(true);\n               else if (value == VALUE_DOC_FILTER_INEXACT)\n                  historyToken.setDocFilterExact(false);\n            }\n            else if (key == HistoryToken.KEY_DOC_FILTER_TEXT)\n            {\n               historyToken.setDocFilterText(value);\n            }\n\n            else\n               Log.info(\"unrecognised history key: \" + key);\n\n         }\n      }\n      catch (IllegalArgumentException e)\n      {\n         throw new IllegalArgumentException(\"token must be a list of key-value pairs in the form key1:value1,key2:value2,...\", e);\n      }\n\n      return historyToken;\n   }","id":32966,"modified_method":"/**\n    * Generates a history token from the given token string. Default values will\n    * be used for any keys that are not present or do not have a valid value\n    * associated with them.\n    * \n    * @param token A GWT history token in the form key1:value1,key2:value2,...\n    */\n   public static HistoryToken fromTokenString(String token)\n   {\n      HistoryToken historyToken = new HistoryToken();\n\n      String[] pair;\n\n      try\n      {\n         for (String pairString : token.split(PAIR_SEPARATOR))\n         {\n            pair = pairString.split(DELIMITER_K_V);\n            String key = pair[0];\n            String value = pair[1];\n\n            if (key == HistoryToken.KEY_DOCUMENT)\n            {\n               if (value != null && value.length() > 0)\n                  historyToken.setDocumentPath((value));\n            }\n            else if (key == HistoryToken.KEY_VIEW)\n            {\n               if (value.equals(VALUE_EDITOR_VIEW))\n                  historyToken.setView(AppPresenter.Display.MainView.Editor);\n               // else assume document list\n            }\n            else if (key == HistoryToken.KEY_DOC_FILTER_TEXT)\n            {\n               if (value != null && value.length() > 0)\n                  historyToken.setDocFilterText(value);\n            }\n            else if (key == HistoryToken.KEY_DOC_FILTER_OPTION)\n            {\n               if (value == VALUE_DOC_FILTER_EXACT)\n                  historyToken.setDocFilterExact(true);\n            }\n            else\n               Log.info(\"unrecognised history key: \" + key);\n\n         }\n      }\n      catch (IllegalArgumentException e)\n      {\n         throw new IllegalArgumentException(\"token must be a list of key-value pairs in the form key1:value1,key2:value2,...\", e);\n      }\n\n      return historyToken;\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setDocFilterExact(Boolean exactMatch)\n   {\n      docFilterExact = exactMatch;\n   }","id":32967,"modified_method":"public void setDocFilterExact(boolean exactMatch)\n   {\n      docFilterExact = exactMatch;\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Boolean getDocFilterExact()\n   {\n      return docFilterExact;\n   }","id":32968,"modified_method":"/**\n    * \n    * @return true if document filter should accept only an exact match\n    */\n   public boolean getDocFilterExact()\n   {\n      return docFilterExact;\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"public AppPresenter.Display.MainView getView()\n   {\n      return view;\n   }","id":32969,"modified_method":"/**\n    * \n    * @return the current view, will never return null\n    */\n   public AppPresenter.Display.MainView getView()\n   {\n      if (view == null)\n         return DEFAULT_VIEW;\n      return view;\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String getDocumentPath()\n   {\n      return fullDocPath;\n   }","id":32970,"modified_method":"/**\n    * \n    * @return the document path, may be an empty string, will not be null\n    */\n   public String getDocumentPath()\n   {\n      if (fullDocPath == null)\n         return DEFAULT_DOCUMENT_PATH;\n      return fullDocPath;\n   }","commit_id":"1fe8483a38aa89c7a64febcb282225931c614314","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate) throws\n      SystemException, UnsupportedPropertyException, NoSuchResourceException, NoSuchParentResourceException {\n    final Set<Resource> resources = new HashSet<Resource>();\n    final Set<String> requestedIds = getRequestPropertyIds(request, predicate);\n    final Set<Map<String, Object>> propertyMaps = getPropertyMaps(predicate);\n\n    for (Map<String, Object> propertyMap: propertyMaps) {\n      final String hostName = propertyMap.get(HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID).toString();\n      final String clusterName = propertyMap.get(HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID).toString();\n      final Long id;\n      List<HostVersionEntity> requestedEntities = new ArrayList<HostVersionEntity>();\n      if (propertyMap.get(HOST_STACK_VERSION_ID_PROPERTY_ID) == null && propertyMaps.size() == 1) {\n        requestedEntities = hostVersionDAO.findByHost(hostName);\n      } else {\n        try {\n          id = Long.parseLong(propertyMap.get(HOST_STACK_VERSION_ID_PROPERTY_ID).toString());\n        } catch (Exception ex) {\n          throw new SystemException(\"Stack version should have numerical id\");\n        }\n        final HostVersionEntity entity = hostVersionDAO.findByPK(id);\n        if (entity == null) {\n          throw new NoSuchResourceException(\"There is no stack version with id \" + id);\n        } else {\n          requestedEntities.add(entity);\n        }\n      }\n\n      addRequestedEntities(resources, requestedEntities, requestedIds, clusterName);\n\n    }\n\n    return resources;\n  }","id":32971,"modified_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate) throws\n      SystemException, UnsupportedPropertyException, NoSuchResourceException, NoSuchParentResourceException {\n    final Set<Resource> resources = new HashSet<Resource>();\n    final Set<String> requestedIds = getRequestPropertyIds(request, predicate);\n    final Set<Map<String, Object>> propertyMaps = getPropertyMaps(predicate);\n\n    for (Map<String, Object> propertyMap: propertyMaps) {\n      final String hostName = propertyMap.get(HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID).toString();\n      String clusterName = null;\n      if (propertyMap.containsKey(HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID)) {\n        clusterName = propertyMap.get(HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID).toString();\n      }\n      final Long id;\n      List<HostVersionEntity> requestedEntities = new ArrayList<HostVersionEntity>();\n      if (propertyMap.get(HOST_STACK_VERSION_ID_PROPERTY_ID) == null && propertyMaps.size() == 1) {\n        if (clusterName == null) {\n          requestedEntities = hostVersionDAO.findByHost(hostName);\n        } else {\n          requestedEntities = hostVersionDAO.findByClusterAndHost(clusterName, hostName);\n        }\n      } else {\n        try {\n          id = Long.parseLong(propertyMap.get(HOST_STACK_VERSION_ID_PROPERTY_ID).toString());\n        } catch (Exception ex) {\n          throw new SystemException(\"Stack version should have numerical id\");\n        }\n        final HostVersionEntity entity = hostVersionDAO.findByPK(id);\n        if (entity == null) {\n          throw new NoSuchResourceException(\"There is no stack version with id \" + id);\n        } else {\n          requestedEntities.add(entity);\n        }\n      }\n\n      addRequestedEntities(resources, requestedEntities, requestedIds, clusterName);\n\n    }\n\n    return resources;\n  }","commit_id":"f2420f6e164e4372a33eb6699f1c8cb8662d465e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Adds requested entities to resources\n   * @param resources a list of resources to add to\n   * @param requestedEntities requested entities\n   * @param requestedIds\n   * @param clusterName name of cluster or null if no any\n   */\n  public void addRequestedEntities(Set<Resource> resources,\n                                   List<HostVersionEntity> requestedEntities,\n                                   Set<String> requestedIds,\n                                   String clusterName) {\n    for (HostVersionEntity entity: requestedEntities) {\n      StackId stackId = new StackId(entity.getRepositoryVersion().getStack());\n\n      RepositoryVersionEntity repoVerEntity = repositoryVersionDAO.findByStackAndVersion(stackId.getStackId(), entity.getRepositoryVersion().getVersion());\n\n      final Resource resource = new ResourceImpl(Resource.Type.HostStackVersion);\n\n      setResourceProperty(resource, HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID, entity.getHostName(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID, clusterName, requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_ID_PROPERTY_ID, entity.getId(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_STACK_PROPERTY_ID, stackId.getStackName(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_VERSION_PROPERTY_ID, stackId.getStackVersion(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_STATE_PROPERTY_ID, entity.getState().name(), requestedIds);\n\n      if (repoVerEntity!=null) {\n        Long repoVersionId = repoVerEntity.getId();\n        setResourceProperty(resource, HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID, repoVersionId, requestedIds);\n      }\n\n      resources.add(resource);\n    }\n  }","id":32972,"modified_method":"/**\n   * Adds requested entities to resources\n   * @param resources a list of resources to add to\n   * @param requestedEntities requested entities\n   * @param requestedIds\n   * @param clusterName name of cluster or null if no any\n   */\n  public void addRequestedEntities(Set<Resource> resources,\n                                   List<HostVersionEntity> requestedEntities,\n                                   Set<String> requestedIds,\n                                   String clusterName) {\n    for (HostVersionEntity entity: requestedEntities) {\n      StackId stackId = new StackId(entity.getRepositoryVersion().getStack());\n\n      RepositoryVersionEntity repoVerEntity = repositoryVersionDAO.findByStackAndVersion(stackId.getStackId(), entity.getRepositoryVersion().getVersion());\n\n      final Resource resource = new ResourceImpl(Resource.Type.HostStackVersion);\n\n      setResourceProperty(resource, HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID, entity.getHostName(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_ID_PROPERTY_ID, entity.getId(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_STACK_PROPERTY_ID, stackId.getStackName(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_VERSION_PROPERTY_ID, stackId.getStackVersion(), requestedIds);\n      setResourceProperty(resource, HOST_STACK_VERSION_STATE_PROPERTY_ID, entity.getState().name(), requestedIds);\n\n      if (clusterName != null) {\n        setResourceProperty(resource, HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID, clusterName, requestedIds);\n      }\n\n      if (repoVerEntity != null) {\n        Long repoVersionId = repoVerEntity.getId();\n        setResourceProperty(resource, HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID, repoVersionId, requestedIds);\n      }\n\n      resources.add(resource);\n    }\n  }","commit_id":"f2420f6e164e4372a33eb6699f1c8cb8662d465e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Helper function to bootstrap some basic data about clusters, cluster version, host, and host versions.\n   */\n  private void createDefaultData() {\n    // Create the cluster\n    ResourceTypeEntity resourceTypeEntity = new ResourceTypeEntity();\n    resourceTypeEntity.setId(ResourceTypeEntity.CLUSTER_RESOURCE_TYPE);\n    resourceTypeEntity.setName(ResourceTypeEntity.CLUSTER_RESOURCE_TYPE_NAME);\n    resourceTypeEntity = resourceTypeDAO.merge(resourceTypeEntity);\n\n    ResourceEntity resourceEntity = new ResourceEntity();\n    resourceEntity.setResourceType(resourceTypeEntity);\n\n    ClusterEntity clusterEntity = new ClusterEntity();\n    clusterEntity.setClusterName(\"test_cluster1\");\n    clusterEntity.setClusterInfo(\"test_cluster_info1\");\n    clusterEntity.setResource(resourceEntity);\n    clusterDAO.create(clusterEntity);\n\n    // Create the Cluster Version and link it to the cluster\n    ClusterVersionEntity clusterVersionEntity = new ClusterVersionEntity(clusterEntity, helper.getOrCreateRepositoryVersion(\"HDP-2.2\", \"2.2.0.0-995\"), RepositoryVersionState.CURRENT, System.currentTimeMillis(), System.currentTimeMillis(), \"admin\");\n    List<ClusterVersionEntity> clusterVersionEntities = new ArrayList<ClusterVersionEntity>();\n    clusterVersionEntities.add(clusterVersionEntity);\n    clusterEntity.setClusterVersionEntities(clusterVersionEntities);\n\n    clusterVersionDAO.create(clusterVersionEntity);\n    clusterDAO.merge(clusterEntity);\n\n    // Create the hosts\n    HostEntity host1 = new HostEntity();\n    HostEntity host2 = new HostEntity();\n    HostEntity host3 = new HostEntity();\n\n    host1.setHostName(\"test_host1\");\n    host2.setHostName(\"test_host2\");\n    host3.setHostName(\"test_host3\");\n    host1.setIpv4(\"192.168.0.1\");\n    host2.setIpv4(\"192.168.0.2\");\n    host3.setIpv4(\"192.168.0.3\");\n\n    List<HostEntity> hostEntities = new ArrayList<HostEntity>();\n    hostEntities.add(host1);\n    hostEntities.add(host2);\n    hostEntities.add(host3);\n\n    clusterEntity.setHostEntities(hostEntities);\n    // Both sides of relation should be set when modifying in runtime\n    host1.setClusterEntities(Arrays.asList(clusterEntity));\n    host2.setClusterEntities(Arrays.asList(clusterEntity));\n    host2.setClusterEntities(Arrays.asList(clusterEntity));\n\n    hostDAO.create(host1);\n    hostDAO.create(host2);\n    hostDAO.create(host3);\n    clusterDAO.merge(clusterEntity);\n\n    // Create the Host Versions\n    HostVersionEntity hostVersionEntity1 = new HostVersionEntity(host1.getHostName(), clusterVersionEntity.getRepositoryVersion(), RepositoryVersionState.CURRENT);\n    HostVersionEntity hostVersionEntity2 = new HostVersionEntity(host2.getHostName(), clusterVersionEntity.getRepositoryVersion(), RepositoryVersionState.INSTALLED);\n    HostVersionEntity hostVersionEntity3 = new HostVersionEntity(host3.getHostName(), clusterVersionEntity.getRepositoryVersion(), RepositoryVersionState.INSTALLED);\n    hostVersionEntity1.setHostEntity(host1);\n    hostVersionEntity2.setHostEntity(host2);\n    hostVersionEntity3.setHostEntity(host3);\n\n    hostVersionDAO.create(hostVersionEntity1);\n    hostVersionDAO.create(hostVersionEntity2);\n    hostVersionDAO.create(hostVersionEntity3);\n  }","id":32973,"modified_method":"/**\n   * Helper function to bootstrap some basic data about clusters, cluster version, host, and host versions.\n   */\n  private void createDefaultData() {\n    // Create the cluster\n    ResourceTypeEntity resourceTypeEntity = new ResourceTypeEntity();\n    resourceTypeEntity.setId(ResourceTypeEntity.CLUSTER_RESOURCE_TYPE);\n    resourceTypeEntity.setName(ResourceTypeEntity.CLUSTER_RESOURCE_TYPE_NAME);\n    resourceTypeEntity = resourceTypeDAO.merge(resourceTypeEntity);\n\n    ResourceEntity resourceEntity = new ResourceEntity();\n    resourceEntity.setResourceType(resourceTypeEntity);\n\n    ClusterEntity clusterEntity = new ClusterEntity();\n    clusterEntity.setClusterName(\"test_cluster1\");\n    clusterEntity.setClusterInfo(\"test_cluster_info1\");\n    clusterEntity.setResource(resourceEntity);\n    clusterDAO.create(clusterEntity);\n\n    // Create the Cluster Version and link it to the cluster\n    ClusterVersionEntity clusterVersionEntity = new ClusterVersionEntity(clusterEntity, helper.getOrCreateRepositoryVersion(\"HDP-2.2\", \"2.2.0.0-995\"), RepositoryVersionState.CURRENT, System.currentTimeMillis(), System.currentTimeMillis(), \"admin\");\n    List<ClusterVersionEntity> clusterVersionEntities = new ArrayList<ClusterVersionEntity>();\n    clusterVersionEntities.add(clusterVersionEntity);\n    clusterEntity.setClusterVersionEntities(clusterVersionEntities);\n\n    clusterVersionDAO.create(clusterVersionEntity);\n    clusterDAO.merge(clusterEntity);\n\n    // Create the hosts\n    HostEntity host1 = new HostEntity();\n    HostEntity host2 = new HostEntity();\n    HostEntity host3 = new HostEntity();\n\n    host1.setHostName(\"test_host1\");\n    host2.setHostName(\"test_host2\");\n    host3.setHostName(\"test_host3\");\n    host1.setIpv4(\"192.168.0.1\");\n    host2.setIpv4(\"192.168.0.2\");\n    host3.setIpv4(\"192.168.0.3\");\n\n    List<HostEntity> hostEntities = new ArrayList<HostEntity>();\n    hostEntities.add(host1);\n    hostEntities.add(host2);\n    hostEntities.add(host3);\n\n    clusterEntity.setHostEntities(hostEntities);\n    // Both sides of relation should be set when modifying in runtime\n    host1.setClusterEntities(Arrays.asList(clusterEntity));\n    host2.setClusterEntities(Arrays.asList(clusterEntity));\n    host3.setClusterEntities(Arrays.asList(clusterEntity));\n\n    hostDAO.create(host1);\n    hostDAO.create(host2);\n    hostDAO.create(host3);\n    clusterDAO.merge(clusterEntity);\n\n    // Create the Host Versions\n    HostVersionEntity hostVersionEntity1 = new HostVersionEntity(host1.getHostName(), clusterVersionEntity.getRepositoryVersion(), RepositoryVersionState.CURRENT);\n    HostVersionEntity hostVersionEntity2 = new HostVersionEntity(host2.getHostName(), clusterVersionEntity.getRepositoryVersion(), RepositoryVersionState.INSTALLED);\n    HostVersionEntity hostVersionEntity3 = new HostVersionEntity(host3.getHostName(), clusterVersionEntity.getRepositoryVersion(), RepositoryVersionState.INSTALLED);\n    hostVersionEntity1.setHostEntity(host1);\n    hostVersionEntity2.setHostEntity(host2);\n    hostVersionEntity3.setHostEntity(host3);\n\n    hostVersionDAO.create(hostVersionEntity1);\n    hostVersionDAO.create(hostVersionEntity2);\n    hostVersionDAO.create(hostVersionEntity3);\n  }","commit_id":"f2420f6e164e4372a33eb6699f1c8cb8662d465e","url":"https://github.com/apache/ambari"},{"original_method":"private Resource getRequestResource(org.apache.ambari.server.actionmanager.Request request,\n                                      Set<String> requestedPropertyIds) {\n    Resource resource = new ResourceImpl(Resource.Type.Request);\n\n    setResourceProperty(resource, REQUEST_CLUSTER_NAME_PROPERTY_ID, request.getClusterName(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ID_PROPERTY_ID, request.getRequestId(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CONTEXT_ID, request.getRequestContext(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TYPE_ID, request.getRequestType(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_INPUTS_ID, request.getInputs(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TARGET_SERVICE_ID, request.getTargetService(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TARGET_COMPONENT_ID, request.getTargetComponent(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TARGET_HOSTS_ID, request.getTargetHosts(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CREATE_TIME_ID, request.getCreateTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_START_TIME_ID, request.getStartTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_END_TIME_ID, request.getEndTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE_ID, request.getRequestScheduleId(), requestedPropertyIds);\n\n    List<HostRoleCommand> commands = request.getCommands();\n\n    int taskCount = commands.size();\n    int completedTaskCount = 0;\n    int queuedTaskCount = 0;\n    int pendingTaskCount = 0;\n    int failedTaskCount = 0;\n    int abortedTaskCount = 0;\n    int timedOutTaskCount = 0;\n\n    for (HostRoleCommand hostRoleCommand : commands) {\n      HostRoleStatus status = hostRoleCommand.getStatus();\n      if (status.isCompletedState()) {\n        completedTaskCount++;\n\n        switch (status) {\n          case ABORTED:\n            abortedTaskCount++;\n            break;\n          case FAILED:\n            failedTaskCount++;\n            break;\n          case TIMEDOUT:\n            timedOutTaskCount++;\n            break;\n        }\n      } else if (status.equals(HostRoleStatus.QUEUED)) {\n        queuedTaskCount++;\n      } else if (status.equals(HostRoleStatus.PENDING)) {\n        pendingTaskCount++;\n      }\n    }\n\n    int inProgressTaskCount = taskCount - completedTaskCount - queuedTaskCount - pendingTaskCount;\n\n    // determine request status\n    HostRoleStatus requestStatus = failedTaskCount > 0 ? HostRoleStatus.FAILED :\n        abortedTaskCount > 0 ? HostRoleStatus.ABORTED :\n            timedOutTaskCount > 0 ? HostRoleStatus.TIMEDOUT :\n                inProgressTaskCount > 0 ? HostRoleStatus.IN_PROGRESS :\n                    completedTaskCount == taskCount ? HostRoleStatus.COMPLETED :\n                        HostRoleStatus.PENDING;\n    double progressPercent =\n        ((queuedTaskCount * 0.09 + inProgressTaskCount * 0.35 + completedTaskCount) / (double) taskCount) * 100.0;\n\n    setResourceProperty(resource, REQUEST_STATUS_PROPERTY_ID, requestStatus.toString(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TASK_CNT_ID, taskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_FAILED_TASK_CNT_ID, failedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ABORTED_TASK_CNT_ID, abortedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TIMED_OUT_TASK_CNT_ID, timedOutTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_QUEUED_TASK_CNT_ID, queuedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_COMPLETED_TASK_CNT_ID, completedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_PROGRESS_PERCENT_ID, progressPercent, requestedPropertyIds);\n\n    return resource;\n  }","id":32974,"modified_method":"private Resource getRequestResource(final org.apache.ambari.server.actionmanager.Request request,\n                                      Set<String> requestedPropertyIds) {\n    Resource resource = new ResourceImpl(Resource.Type.Request);\n\n    setResourceProperty(resource, REQUEST_CLUSTER_NAME_PROPERTY_ID, request.getClusterName(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ID_PROPERTY_ID, request.getRequestId(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CONTEXT_ID, request.getRequestContext(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TYPE_ID, request.getRequestType(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_INPUTS_ID, request.getInputs(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TARGET_SERVICE_ID, request.getTargetService(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TARGET_COMPONENT_ID, request.getTargetComponent(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TARGET_HOSTS_ID, request.getTargetHosts(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CREATE_TIME_ID, request.getCreateTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_START_TIME_ID, request.getStartTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_END_TIME_ID, request.getEndTime(), requestedPropertyIds);\n    if (request.getRequestScheduleId() != null) {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE_ID, request.getRequestScheduleId(), requestedPropertyIds);\n    } else {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE, null, requestedPropertyIds);\n    }\n\n    List<HostRoleCommand> commands = request.getCommands();\n\n    int taskCount = commands.size();\n    int completedTaskCount = 0;\n    int queuedTaskCount = 0;\n    int pendingTaskCount = 0;\n    int failedTaskCount = 0;\n    int abortedTaskCount = 0;\n    int timedOutTaskCount = 0;\n\n    for (HostRoleCommand hostRoleCommand : commands) {\n      HostRoleStatus status = hostRoleCommand.getStatus();\n      if (status.isCompletedState()) {\n        completedTaskCount++;\n\n        switch (status) {\n          case ABORTED:\n            abortedTaskCount++;\n            break;\n          case FAILED:\n            failedTaskCount++;\n            break;\n          case TIMEDOUT:\n            timedOutTaskCount++;\n            break;\n        }\n      } else if (status.equals(HostRoleStatus.QUEUED)) {\n        queuedTaskCount++;\n      } else if (status.equals(HostRoleStatus.PENDING)) {\n        pendingTaskCount++;\n      }\n    }\n\n    int inProgressTaskCount = taskCount - completedTaskCount - queuedTaskCount - pendingTaskCount;\n\n    // determine request status\n    HostRoleStatus requestStatus = failedTaskCount > 0 ? HostRoleStatus.FAILED :\n        abortedTaskCount > 0 ? HostRoleStatus.ABORTED :\n            timedOutTaskCount > 0 ? HostRoleStatus.TIMEDOUT :\n                inProgressTaskCount > 0 ? HostRoleStatus.IN_PROGRESS :\n                    completedTaskCount == taskCount ? HostRoleStatus.COMPLETED :\n                        HostRoleStatus.PENDING;\n    double progressPercent =\n        ((queuedTaskCount * 0.09 + inProgressTaskCount * 0.35 + completedTaskCount) / (double) taskCount) * 100.0;\n\n    setResourceProperty(resource, REQUEST_STATUS_PROPERTY_ID, requestStatus.toString(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TASK_CNT_ID, taskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_FAILED_TASK_CNT_ID, failedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ABORTED_TASK_CNT_ID, abortedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TIMED_OUT_TASK_CNT_ID, timedOutTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_QUEUED_TASK_CNT_ID, queuedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_COMPLETED_TASK_CNT_ID, completedTaskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_PROGRESS_PERCENT_ID, progressPercent, requestedPropertyIds);\n\n    return resource;\n  }","commit_id":"a0ea66fecae19438267467aed0a2a7a661880bc7","url":"https://github.com/apache/ambari"},{"original_method":"private Resource getRequestResource(RequestEntity entity, String clusterName,\n      Set<String> requestedPropertyIds) {\n    Resource resource = new ResourceImpl(Resource.Type.Request);\n\n    if (null != clusterName)\n      setResourceProperty(resource, REQUEST_CLUSTER_NAME_PROPERTY_ID, clusterName, requestedPropertyIds);\n\n    setResourceProperty(resource, REQUEST_ID_PROPERTY_ID, entity.getRequestId(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CONTEXT_ID, entity.getRequestContext(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TYPE_ID, entity.getRequestType(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_INPUTS_ID, entity.getInputs(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_RESOURCE_FILTER_ID,\n        org.apache.ambari.server.actionmanager.Request.filtersFromEntity(entity),\n        requestedPropertyIds);\n\n    RequestOperationLevel operationLevel = org.apache.ambari.server.actionmanager.Request.operationLevelFromEntity(entity);\n    String opLevelStr = null;\n    if (operationLevel != null) {\n      opLevelStr = RequestOperationLevel.getExternalLevelName(\n              operationLevel.getLevel().toString());\n    }\n    setResourceProperty(resource, REQUEST_OPERATION_LEVEL_ID, opLevelStr, requestedPropertyIds);\n\n    setResourceProperty(resource, REQUEST_CREATE_TIME_ID, entity.getCreateTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_START_TIME_ID, entity.getStartTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_END_TIME_ID, entity.getEndTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_EXCLUSIVE_ID, entity.isExclusive(), requestedPropertyIds);\n\n    if (entity.getRequestScheduleId() != null) {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE_ID, entity.getRequestScheduleId(), requestedPropertyIds);\n    } else {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE, null, requestedPropertyIds);\n    }\n\n\n    Map<Long, HostRoleCommandStatusSummaryDTO> summary = s_hostRoleCommandDAO.findAggregateCounts(entity.getRequestId());\n\n    // get summaries from TopologyManager for logical requests\n    summary.putAll(topologyManager.getStageSummaries(entity.getRequestId()));\n\n    LogicalRequest logicalRequest = topologyManager.getRequest(entity.getRequestId());\n\n    CalculatedStatus status = CalculatedStatus.statusFromStageSummary(summary, summary.keySet());\n    if (summary.isEmpty() && logicalRequest == null) {\n\n      // summary might be empty due to delete host have cleared all HostRoleCommands\n      // or due to hosts haven't registered yet with the cluster when the cluster is provisioned\n      // with a Blueprint\n      status = CalculatedStatus.getCompletedStatus();\n    }\n\n    setResourceProperty(resource, REQUEST_STATUS_PROPERTY_ID, status.getStatus().toString(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_PROGRESS_PERCENT_ID, status.getPercent(), requestedPropertyIds);\n\n    int taskCount = 0;\n    for (HostRoleCommandStatusSummaryDTO dto : summary.values()) {\n      taskCount += dto.getTaskTotal();\n    }\n\n    Map<HostRoleStatus, Integer> hostRoleStatusCounters = CalculatedStatus.calculateTaskStatusCounts(\n        summary, summary.keySet());\n\n    setResourceProperty(resource, REQUEST_TASK_CNT_ID, taskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_FAILED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.FAILED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ABORTED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.ABORTED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TIMED_OUT_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.TIMEDOUT), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_QUEUED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.QUEUED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_COMPLETED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.COMPLETED), requestedPropertyIds);\n\n    return resource;\n  }","id":32975,"modified_method":"private Resource getRequestResource(RequestEntity entity, String clusterName,\n      Set<String> requestedPropertyIds) {\n    Resource resource = new ResourceImpl(Resource.Type.Request);\n\n    if (null != clusterName) {\n      setResourceProperty(resource, REQUEST_CLUSTER_NAME_PROPERTY_ID, clusterName, requestedPropertyIds);\n    } else if (null != entity.getClusterId() && -1L != entity.getClusterId()) {\n      setResourceProperty(resource, REQUEST_CLUSTER_ID_PROPERTY_ID, entity.getClusterId(), requestedPropertyIds);\n    }\n\n    setResourceProperty(resource, REQUEST_ID_PROPERTY_ID, entity.getRequestId(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CONTEXT_ID, entity.getRequestContext(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TYPE_ID, entity.getRequestType(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_INPUTS_ID, entity.getInputs(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_RESOURCE_FILTER_ID,\n        org.apache.ambari.server.actionmanager.Request.filtersFromEntity(entity),\n        requestedPropertyIds);\n\n    RequestOperationLevel operationLevel = org.apache.ambari.server.actionmanager.Request.operationLevelFromEntity(entity);\n    String opLevelStr = null;\n    if (operationLevel != null) {\n      opLevelStr = RequestOperationLevel.getExternalLevelName(\n              operationLevel.getLevel().toString());\n    }\n    setResourceProperty(resource, REQUEST_OPERATION_LEVEL_ID, opLevelStr, requestedPropertyIds);\n\n    setResourceProperty(resource, REQUEST_CREATE_TIME_ID, entity.getCreateTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_START_TIME_ID, entity.getStartTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_END_TIME_ID, entity.getEndTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_EXCLUSIVE_ID, entity.isExclusive(), requestedPropertyIds);\n\n    if (entity.getRequestScheduleId() != null) {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE_ID, entity.getRequestScheduleId(), requestedPropertyIds);\n    } else {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE, null, requestedPropertyIds);\n    }\n\n\n    Map<Long, HostRoleCommandStatusSummaryDTO> summary = s_hostRoleCommandDAO.findAggregateCounts(entity.getRequestId());\n\n    // get summaries from TopologyManager for logical requests\n    summary.putAll(topologyManager.getStageSummaries(entity.getRequestId()));\n\n    LogicalRequest logicalRequest = topologyManager.getRequest(entity.getRequestId());\n\n    CalculatedStatus status = CalculatedStatus.statusFromStageSummary(summary, summary.keySet());\n    if (summary.isEmpty() && logicalRequest == null) {\n\n      // summary might be empty due to delete host have cleared all HostRoleCommands\n      // or due to hosts haven't registered yet with the cluster when the cluster is provisioned\n      // with a Blueprint\n      status = CalculatedStatus.getCompletedStatus();\n    }\n\n    setResourceProperty(resource, REQUEST_STATUS_PROPERTY_ID, status.getStatus().toString(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_PROGRESS_PERCENT_ID, status.getPercent(), requestedPropertyIds);\n\n    int taskCount = 0;\n    for (HostRoleCommandStatusSummaryDTO dto : summary.values()) {\n      taskCount += dto.getTaskTotal();\n    }\n\n    Map<HostRoleStatus, Integer> hostRoleStatusCounters = CalculatedStatus.calculateTaskStatusCounts(\n        summary, summary.keySet());\n\n    setResourceProperty(resource, REQUEST_TASK_CNT_ID, taskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_FAILED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.FAILED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ABORTED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.ABORTED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TIMED_OUT_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.TIMEDOUT), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_QUEUED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.QUEUED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_COMPLETED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.COMPLETED), requestedPropertyIds);\n\n    return resource;\n  }","commit_id":"579982cddbd3d7cbde5e8d8cdbdcf3061afe3017","url":"https://github.com/apache/ambari"},{"original_method":"private Set<Resource> getRequestResources(String clusterName,\n                                            Long requestId,\n                                            String requestStatus,\n                                            Integer maxResults,\n                                            Boolean ascOrder,\n                                            Set<String> requestedPropertyIds)\n      throws NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> response = new HashSet<Resource>();\n    ActionManager actionManager = getManagementController().getActionManager();\n\n    Long clusterId = null;\n\n    if (clusterName != null) {\n      Clusters clusters = getManagementController().getClusters();\n      //validate that cluster exists, throws exception if it doesn't.\n      try {\n        Cluster cluster = clusters.getCluster(clusterName);\n        clusterId = cluster.getClusterId();\n      } catch (AmbariException e) {\n        throw new NoSuchParentResourceException(e.getMessage(), e);\n      }\n    }\n\n    if (requestId == null) {\n      org.apache.ambari.server.actionmanager.RequestStatus status = null;\n      if (requestStatus != null) {\n        status = org.apache.ambari.server.actionmanager.RequestStatus.valueOf(requestStatus);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Received a Get Request Status request\"\n            + \", requestId=null\"\n            + \", requestStatus=\" + status);\n      }\n\n      List<Long> requestIds = actionManager.getRequestsByStatus(status,\n        maxResults != null ? maxResults : BaseRequest.DEFAULT_PAGE_SIZE,\n        ascOrder != null ? ascOrder : false);\n      LOG.debug(\"List<Long> requestIds = actionManager.getRequestsByStatus = {}\", requestIds.size());\n\n      response.addAll(getRequestResources(clusterId, clusterName, requestIds,\n          requestedPropertyIds));\n    } else {\n      Collection<Resource> responses = getRequestResources(\n          clusterId, clusterName, Collections.singletonList(requestId), requestedPropertyIds);\n\n      if (responses.isEmpty()) {\n        throw new NoSuchResourceException(\"Request resource doesn't exist.\");\n      }\n      response.addAll(responses);\n    }\n    return response;\n  }","id":32976,"modified_method":"/**\n   * Gets all of the request resources for the given properties.\n   */\n  private Set<Resource> getRequestResources(String clusterName,\n                                            Long requestId,\n                                            String requestStatus,\n                                            Integer maxResults,\n                                            Boolean ascOrder,\n                                            Set<String> requestedPropertyIds)\n      throws NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> response = new HashSet<Resource>();\n    ActionManager actionManager = getManagementController().getActionManager();\n\n    Long clusterId = null;\n\n    if (clusterName != null) {\n      Clusters clusters = getManagementController().getClusters();\n      //validate that cluster exists, throws exception if it doesn't.\n      try {\n        Cluster cluster = clusters.getCluster(clusterName);\n        clusterId = cluster.getClusterId();\n      } catch (AmbariException e) {\n        throw new NoSuchParentResourceException(e.getMessage(), e);\n      }\n    }\n\n    List<Long> requestIds = Collections.emptyList();\n\n    if (requestId == null) {\n      org.apache.ambari.server.actionmanager.RequestStatus status = null;\n      if (requestStatus != null) {\n        status = org.apache.ambari.server.actionmanager.RequestStatus.valueOf(requestStatus);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Received a Get Request Status request\"\n            + \", requestId=null\"\n            + \", requestStatus=\" + status);\n      }\n\n      maxResults = (maxResults != null) ? maxResults : BaseRequest.DEFAULT_PAGE_SIZE;\n      ascOrder = (ascOrder != null) ? ascOrder : false;\n\n      if (null == status) {\n        if (null != clusterId) {\n          // !!! don't mix results of cluster vs non-cluster\n          requestIds = s_requestDAO.findAllRequestIds(maxResults, ascOrder, clusterId);\n        } else {\n          // !!! not a cluster, so get all requests NOT affiliated with a cluster\n          requestIds = s_requestDAO.findAllRequestIds(maxResults, ascOrder, null);\n        }\n      } else {\n        // !!! this call will result in mixed results of cluster and non-cluster.  this\n        // will get fixed in a future iteration, as the host_role_command table does not\n        // currently have direct cluster affinity, and changing that is a tad destructive.\n        requestIds = actionManager.getRequestsByStatus(status,\n          maxResults != null ? maxResults : BaseRequest.DEFAULT_PAGE_SIZE,\n                ascOrder != null ? ascOrder : false);\n      }\n\n      LOG.debug(\"List<Long> requestIds = actionManager.getRequestsByStatus = {}\", requestIds.size());\n\n      response.addAll(getRequestResources(clusterId, clusterName, requestIds,\n          requestedPropertyIds));\n    } else {\n      Collection<Resource> responses = getRequestResources(\n          clusterId, clusterName, Collections.singletonList(requestId), requestedPropertyIds);\n\n      if (responses.isEmpty()) {\n        throw new NoSuchResourceException(\"Request resource doesn't exist.\");\n      }\n      response.addAll(responses);\n    }\n    return response;\n  }","commit_id":"579982cddbd3d7cbde5e8d8cdbdcf3061afe3017","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesWithRequestInfo() throws Exception {\n    Resource.Type type = Resource.Type.Request;\n\n    expect(requestDAO.findByPks(Collections.<Long> emptyList(), true)).andReturn(Collections.<RequestEntity>emptyList()).anyTimes();\n    replay(requestDAO);\n\n    ActionManager actionManager = createNiceMock(ActionManager.class);\n\n    Cluster cluster = createNiceMock(Cluster.class);\n    expect(cluster.getClusterId()).andReturn(1L).anyTimes();\n    expect(cluster.getResourceId()).andReturn(4L).anyTimes();\n\n    Clusters clusters = createNiceMock(Clusters.class);\n    expect(clusters.getCluster(\"foo_cluster\")).andReturn(cluster).anyTimes();\n\n    AmbariManagementController managementController =\n      createMock(AmbariManagementController.class);\n    expect(managementController.getActionManager()).andReturn(actionManager)\n      .anyTimes();\n    expect(managementController.getClusters()).andReturn(clusters).anyTimes();\n\n    replay(managementController, clusters, cluster);\n\n    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(type,\n      PropertyHelper.getPropertyIds(type), PropertyHelper.getKeyPropertyIds(type),\n      managementController);\n\n    Map<String, String> requestInfoProperties = new HashMap<String, String>();\n    Request request;\n    Predicate predicate = new PredicateBuilder()\n      .property(RequestResourceProvider.REQUEST_CLUSTER_NAME_PROPERTY_ID)\n      .equals(\"foo_cluster\")\n      .and().property(RequestResourceProvider.REQUEST_ID_PROPERTY_ID)\n      .equals(null)\n      .and().property(RequestResourceProvider.REQUEST_STATUS_PROPERTY_ID)\n      .equals(null)\n      .toPredicate();\n\n    request = PropertyHelper.getReadRequest(new HashSet<String>(),\n      requestInfoProperties, null, null, null);\n\n    expect(actionManager.getRequestsByStatus(null, BaseRequest.DEFAULT_PAGE_SIZE, false))\n      .andReturn(Collections.<Long> emptyList());\n\n    replay(actionManager);\n    provider.getResources(request, predicate);\n    verify(actionManager);\n    reset(actionManager);\n\n    requestInfoProperties.put(BaseRequest.PAGE_SIZE_PROPERTY_KEY, \"20\");\n    request = PropertyHelper.getReadRequest(new HashSet<String>(),\n      requestInfoProperties, null, null, null);\n    expect(actionManager.getRequestsByStatus(null, 20, false))\n      .andReturn(Collections.<Long> emptyList());\n    replay(actionManager);\n    provider.getResources(request, predicate);\n    verify(actionManager);\n    reset(actionManager);\n\n    requestInfoProperties.put(BaseRequest.ASC_ORDER_PROPERTY_KEY, \"true\");\n    request = PropertyHelper.getReadRequest(new HashSet<String>(),\n      requestInfoProperties, null, null, null);\n    expect(actionManager.getRequestsByStatus(null, 20, true))\n      .andReturn(Collections.<Long> emptyList());\n    replay(actionManager);\n    provider.getResources(request, predicate);\n    verify(actionManager);\n    reset(actionManager);\n  }","id":32977,"modified_method":"@Test\n  public void testGetResourcesWithRequestInfo() throws Exception {\n    Resource.Type type = Resource.Type.Request;\n\n    expect(requestDAO.findByPks(Collections.<Long> emptyList(), true)).andReturn(Collections.<RequestEntity>emptyList()).anyTimes();\n\n    ActionManager actionManager = createNiceMock(ActionManager.class);\n\n    Cluster cluster = createNiceMock(Cluster.class);\n    expect(cluster.getClusterId()).andReturn(1L).anyTimes();\n    expect(cluster.getResourceId()).andReturn(4L).anyTimes();\n\n    Clusters clusters = createNiceMock(Clusters.class);\n    expect(clusters.getCluster(\"foo_cluster\")).andReturn(cluster).anyTimes();\n\n    AmbariManagementController managementController = createMock(AmbariManagementController.class);\n    expect(managementController.getActionManager()).andReturn(actionManager).anyTimes();\n    expect(managementController.getClusters()).andReturn(clusters).anyTimes();\n    replay(managementController, clusters, cluster);\n\n    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(type,\n      PropertyHelper.getPropertyIds(type), PropertyHelper.getKeyPropertyIds(type),\n      managementController);\n\n    Map<String, String> requestInfoProperties = new HashMap<String, String>();\n    Request request;\n    Predicate predicate = new PredicateBuilder()\n      .property(RequestResourceProvider.REQUEST_CLUSTER_NAME_PROPERTY_ID)\n      .equals(\"foo_cluster\")\n      .and().property(RequestResourceProvider.REQUEST_ID_PROPERTY_ID)\n      .equals(null)\n      .and().property(RequestResourceProvider.REQUEST_STATUS_PROPERTY_ID)\n      .equals(null)\n      .toPredicate();\n\n    request = PropertyHelper.getReadRequest(new HashSet<String>(),\n      requestInfoProperties, null, null, null);\n\n    expect(requestDAO.findAllRequestIds(BaseRequest.DEFAULT_PAGE_SIZE, false, 1L)).andReturn(Collections.<Long> emptyList()).anyTimes();\n    replay(requestDAO);\n\n    provider.getResources(request, predicate);\n    verify(requestDAO);\n\n    requestInfoProperties.put(BaseRequest.PAGE_SIZE_PROPERTY_KEY, \"20\");\n    request = PropertyHelper.getReadRequest(new HashSet<String>(),\n      requestInfoProperties, null, null, null);\n    provider.getResources(request, predicate);\n    verify(requestDAO);\n\n    reset(requestDAO);\n\n    requestInfoProperties.put(BaseRequest.ASC_ORDER_PROPERTY_KEY, \"true\");\n    request = PropertyHelper.getReadRequest(new HashSet<String>(),\n      requestInfoProperties, null, null, null);\n    expect(requestDAO.findByPks(Collections.<Long> emptyList(), true)).andReturn(Collections.<RequestEntity>emptyList()).anyTimes();\n    expect(requestDAO.findAllRequestIds(BaseRequest.DEFAULT_PAGE_SIZE, true, 1L)).andReturn(Collections.<Long> emptyList()).anyTimes();\n    replay(requestDAO);\n\n    provider.getResources(request, predicate);\n    verify(requestDAO);\n  }","commit_id":"579982cddbd3d7cbde5e8d8cdbdcf3061afe3017","url":"https://github.com/apache/ambari"},{"original_method":"public LogEvent map(Message message) {\n        final LogEvent event = new LogEvent();\n        event.setMessageId(getMessageId(message));\n        event.setExchangeId((String)message.getExchange().get(LogEvent.KEY_EXCHANGE_ID));\n        event.setType(getEventType(message));\n        if (!Boolean.TRUE.equals(message.get(Message.DECOUPLED_CHANNEL_MESSAGE))) {\n            // avoid logging the default responseCode 200 for the decoupled responses\n            Integer responseCode = (Integer)message.get(Message.RESPONSE_CODE);\n            if (responseCode != null) {\n                event.setResponseCode(responseCode.toString());\n            }\n        }\n\n        String encoding = (String)message.get(Message.ENCODING);\n\n        if (encoding != null) {\n            event.setEncoding(encoding);\n        }\n        String httpMethod = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        if (httpMethod != null) {\n            event.setHttpMethod(httpMethod);\n        }\n        String ct = (String)message.get(Message.CONTENT_TYPE);\n        if (ct != null) {\n            event.setContentType(ct);\n        }\n        Map<String, String> headerMap = getHeaders(message);\n        event.setHeaders(headerMap);\n\n        String uri = getUri(message);\n        if (uri != null) {\n            event.setAddress(uri);\n        }\n\n        event.setPrincipal(getPrincipal(message));\n        event.setBinaryContent(isBinaryContent(message));\n        setEpInfo(message, event);\n        return event;\n    }","id":32978,"modified_method":"public LogEvent map(Message message) {\n        final LogEvent event = new LogEvent();\n        event.setMessageId(getMessageId(message));\n        event.setExchangeId((String)message.getExchange().get(LogEvent.KEY_EXCHANGE_ID));\n        event.setType(getEventType(message));\n        if (!Boolean.TRUE.equals(message.get(Message.DECOUPLED_CHANNEL_MESSAGE))) {\n            // avoid logging the default responseCode 200 for the decoupled responses\n            Integer responseCode = (Integer)message.get(Message.RESPONSE_CODE);\n            if (responseCode != null) {\n                event.setResponseCode(responseCode.toString());\n            }\n        }\n\n        event.setEncoding(safeGet(message, Message.ENCODING));\n        event.setHttpMethod(safeGet(message, Message.HTTP_REQUEST_METHOD));\n        event.setContentType(safeGet(message, Message.CONTENT_TYPE));\n\n        Map<String, String> headerMap = getHeaders(message);\n        event.setHeaders(headerMap);\n\n        String uri = getUri(message);\n        if (uri != null) {\n            event.setAddress(uri);\n        }\n\n        event.setPrincipal(getPrincipal(message));\n        event.setBinaryContent(isBinaryContent(message));\n        setEpInfo(message, event);\n        return event;\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private void setEpInfo(Message message, final LogEvent event) {\n        EndpointInfo endpoint = getEPInfo(message);\n        event.setPortName(endpoint.getName());\n        event.setPortTypeName(endpoint.getName());\n        event.setOperationName(getRestOperationName(message));\n        String opName = isSOAPMessage(message) ? getOperationName(message) : getRestOperationName(message);\n        event.setOperationName(opName);\n        if (endpoint.getService() != null) {\n            setServiceInfo(endpoint.getService(), event);\n        }\n    }","id":32979,"modified_method":"private void setEpInfo(Message message, final LogEvent event) {\n        EndpointInfo endpoint = getEPInfo(message);\n        event.setPortName(endpoint.getName());\n        event.setPortTypeName(endpoint.getName());\n        String opName = isSOAPMessage(message) ? getOperationName(message) : getRestOperationName(message);\n        event.setOperationName(opName);\n        if (endpoint.getService() != null) {\n            setServiceInfo(endpoint.getService(), event);\n        }\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private boolean isBinaryContent(Message message) {\n        String contentType = (String)message.get(Message.CONTENT_TYPE);\n        return contentType != null && BINARY_CONTENT_MEDIA_TYPES.contains(contentType);\n    }","id":32980,"modified_method":"private boolean isBinaryContent(Message message) {\n        String contentType = safeGet(message, Message.CONTENT_TYPE);\n        return contentType != null && BINARY_CONTENT_MEDIA_TYPES.contains(contentType);\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private Map<String, String> getHeaders(Message message) {\n        Map<String, List<String>> headers = CastUtils.cast((Map<?, ?>)message.get(Message.PROTOCOL_HEADERS));\n        Map<String, String> result = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            if (entry.getValue().size() == 1) {\n                result.put(entry.getKey(), entry.getValue().get(0));\n            } else {\n                String[] valueAr = entry.getValue().toArray(new String[] {});\n                result.put(entry.getKey(), valueAr.toString());\n            }\n        }\n        return result;\n    }","id":32981,"modified_method":"private Map<String, String> getHeaders(Message message) {\n        Map<String, List<String>> headers = CastUtils.cast((Map<?, ?>)message.get(Message.PROTOCOL_HEADERS));\n        Map<String, String> result = new HashMap<>();\n        if (headers == null) {\n            return result;\n        }\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            if (entry.getValue().size() == 1) {\n                result.put(entry.getKey(), entry.getValue().get(0));\n            } else {\n                String[] valueAr = entry.getValue().toArray(new String[] {});\n                result.put(entry.getKey(), valueAr.toString());\n            }\n        }\n        return result;\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private String getRestOperationName(Message curMessage) {\n        Message message = getEffectiveMessage(curMessage);\n        if (message.containsKey(Message.HTTP_REQUEST_METHOD)) {\n            String httpMethod = message.get(Message.HTTP_REQUEST_METHOD).toString();\n\n            String path = \"\";\n            if (message.containsKey(Message.REQUEST_URI)) {\n                String requestUri = message.get(Message.REQUEST_URI).toString();\n                int baseUriLength = (message.containsKey(Message.BASE_PATH)) ? message.get(Message.BASE_PATH)\n                    .toString().length() : 0;\n                path = requestUri.substring(baseUriLength);\n                if (path.isEmpty()) {\n                    path = \"/\";\n                }\n            }\n\n            return new StringBuffer().append(httpMethod).append('[').append(path).append(']').toString();\n        }\n        return \"\";\n    }","id":32982,"modified_method":"private String getRestOperationName(Message curMessage) {\n        Message message = getEffectiveMessage(curMessage);\n        String httpMethod = safeGet(message, Message.HTTP_REQUEST_METHOD);\n        if (httpMethod == null) {\n            return \"\";\n        }\n\n        String path = \"\";\n        String requestUri = safeGet(message, Message.REQUEST_URI);\n        if (requestUri != null) {\n            String basePath = safeGet(message, Message.BASE_PATH);\n            int baseUriLength = (basePath != null) ? basePath.length() : 0;\n            path = requestUri.substring(baseUriLength);\n            if (path.isEmpty()) {\n                path = \"/\";\n            }\n        }\n        return new StringBuffer().append(httpMethod).append('[').append(path).append(']').toString();\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private String getUri(Message message) {\n        String uri = (String)message.get(Message.REQUEST_URL);\n        if (uri == null) {\n            String address = (String)message.get(Message.ENDPOINT_ADDRESS);\n            uri = (String)message.get(Message.REQUEST_URI);\n            if (uri != null && uri.startsWith(\"/\")) {\n                if (address != null && !address.startsWith(uri)) {\n                    if (address.endsWith(\"/\") && address.length() > 1) {\n                        address = address.substring(0, address.length());\n                    }\n                    uri = address + uri;\n                }\n            } else {\n                uri = address;\n            }\n        }\n        String query = (String)message.get(Message.QUERY_STRING);\n        if (query != null) {\n            return uri + \"?\" + query;\n        } else {\n            return uri;\n        }\n    }","id":32983,"modified_method":"private String getUri(Message message) {\n        String uri = safeGet(message, Message.REQUEST_URL);\n        if (uri == null) {\n            String address = safeGet(message, Message.ENDPOINT_ADDRESS);\n            uri = safeGet(message, Message.REQUEST_URI);\n            if (uri != null && uri.startsWith(\"/\")) {\n                if (address != null && !address.startsWith(uri)) {\n                    if (address.endsWith(\"/\") && address.length() > 1) {\n                        address = address.substring(0, address.length());\n                    }\n                    uri = address + uri;\n                }\n            } else {\n                uri = address;\n            }\n        }\n        String query = safeGet(message, Message.QUERY_STRING);\n        if (query != null) {\n            return uri + \"?\" + query;\n        } else {\n            return uri;\n        }\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private EndpointInfo getEPInfo(Message message) {\n        Endpoint ep = message.getExchange().getEndpoint();\n        return (ep == null) ? null : ep.getEndpointInfo();\n    }","id":32984,"modified_method":"private EndpointInfo getEPInfo(Message message) {\n        Endpoint ep = message.getExchange().getEndpoint();\n        return (ep == null) ? new EndpointInfo() : ep.getEndpointInfo();\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private BindingOperationInfo getOperationFromContent(Message message) {\n        BindingOperationInfo boi = null;\n        XMLStreamReader xmlReader = message.getContent(XMLStreamReader.class);\n        if (null != xmlReader) {\n            QName qName = xmlReader.getName();\n            boi = ServiceModelUtil.getOperation(message.getExchange(), qName);\n        }\n        return boi;\n    }","id":32985,"modified_method":"private BindingOperationInfo getOperationFromContent(Message message) {\n        XMLStreamReader xmlReader = message.getContent(XMLStreamReader.class);\n        if (xmlReader != null) {\n            return ServiceModelUtil.getOperation(message.getExchange(), xmlReader.getName());\n        } else {\n            return null;\n        }\n    }","commit_id":"d4de0ced8b53599229a7a3e43ad3bb5cf70b401b","url":"https://github.com/apache/cxf"},{"original_method":"private ScannerTask(final String deploymentName, final File parent, final String inProgressMarkerSuffix) {\n            this.deploymentName = deploymentName;\n            this.parent = parent;\n            this.inProgressMarkerSuffix = inProgressMarkerSuffix;\n            File marker = new File(parent, deploymentName + inProgressMarkerSuffix);\n            createMarkerFile(marker);\n        }","id":32986,"modified_method":"private ScannerTask(final String deploymentName, final File parent, final String inProgressMarkerSuffix) {\n            this.deploymentName = deploymentName;\n            this.parent = parent.getAbsolutePath();\n            this.inProgressMarkerSuffix = inProgressMarkerSuffix;\n            File marker = new File(parent, deploymentName + inProgressMarkerSuffix);\n            createMarkerFile(marker);\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ReplaceTask(String deploymentName, File deploymentFile) {\n            super(deploymentName, deploymentFile);\n        }","id":32987,"modified_method":"private ReplaceTask(String deploymentName, File deploymentFile, long markerTimestamp) {\n            super(deploymentName, deploymentFile, markerTimestamp);\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void removeInProgressMarker() {\n            File marker = new File(parent, deploymentName + inProgressMarkerSuffix);\n            if (marker.exists() && !marker.delete()) {\n                log.warnf(\"Cannot delete deployment progress marker file %s\", marker);\n            }\n        }","id":32988,"modified_method":"protected void removeInProgressMarker() {\n            File marker = new File(new File(parent), deploymentName + inProgressMarkerSuffix);\n            if (marker.exists() && !marker.delete()) {\n                log.warnf(\"Cannot delete deployment progress marker file %s\", marker);\n            }\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"private DeployTask(final String deploymentName, final File deploymentFile) {\n            super(deploymentName, deploymentFile);\n        }","id":32989,"modified_method":"private DeployTask(final String deploymentName, final File deploymentFile, long markerTimestamp) {\n            super(deploymentName, deploymentFile, markerTimestamp);\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void handleSuccessResult() {\n            final File doDeployMarker = new File(parent, deploymentFile.getName() + DO_DEPLOY);\n            if (!doDeployMarker.delete()) {\n                log.errorf(\"Failed to delete deployment marker file %s\", doDeployMarker.getAbsolutePath());\n            }\n\n            // Remove any previous failure marker\n            final File failedMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + FAILED_DEPLOY);\n            if (failedMarker.exists() && !failedMarker.delete()) {\n                log.warnf(\"Unable to remove marger file %s\", failedMarker);\n            }\n\n            // Remove the in-progress marker\n            removeInProgressMarker();\n\n            final File deployedMarker = new File(parent, deploymentFile.getName() + DEPLOYED);\n            createMarkerFile(deployedMarker);\n            if (deployed.containsKey(deploymentName)) {\n                deployed.remove(deploymentName);\n            }\n            deployed.put(deploymentName, new DeploymentMarker(deployedMarker.lastModified()));\n        }","id":32990,"modified_method":"@Override\n        protected void handleSuccessResult() {\n            final File doDeployMarker = new File(new File(parent), deploymentFile.getName() + DO_DEPLOY);\n            if (doDeployMarker.lastModified() <= doDeployTimestamp) {\n                if (!doDeployMarker.delete()) {\n                    log.errorf(\"Failed to delete deployment marker file %s\", doDeployMarker.getAbsolutePath());\n                }\n            }\n            // else they copied it in again while deployment was happening; we'll pick it up next scan\n\n            // Remove any previous failure marker\n            final File failedMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + FAILED_DEPLOY);\n            if (failedMarker.exists() && !failedMarker.delete()) {\n                log.warnf(\"Unable to remove marker file %s\", failedMarker);\n            }\n\n            // Remove the in-progress marker\n            removeInProgressMarker();\n\n            final File deployedMarker = new File(parent, deploymentFile.getName() + DEPLOYED);\n            createMarkerFile(deployedMarker);\n            if (deployed.containsKey(deploymentName)) {\n                deployed.remove(deploymentName);\n            }\n            deployed.put(deploymentName, new DeploymentMarker(deployedMarker.lastModified()));\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ContentAddingTask(final String deploymentName, final File deploymentFile) {\n            super(deploymentName, deploymentFile.getParentFile(), DEPLOYING);\n            this.deploymentFile = deploymentFile;\n        }","id":32991,"modified_method":"protected ContentAddingTask(final String deploymentName, final File deploymentFile, long markerTimestamp) {\n            super(deploymentName, deploymentFile.getParentFile(), DEPLOYING);\n            this.deploymentFile = deploymentFile;\n            this.doDeployTimestamp = markerTimestamp;\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void createMarkerFile(final File deployedMarker) {\n            FileOutputStream fos = null;\n            try {\n                deployedMarker.createNewFile();\n                fos = new FileOutputStream(deployedMarker);\n                fos.write(deploymentName.getBytes());\n            } catch (IOException io) {\n                log.errorf(io, \"Caught exception writing deployment marker file %s\", deployedMarker.getAbsolutePath());\n            } finally {\n                safeClose(fos);\n            }\n        }","id":32992,"modified_method":"protected void createMarkerFile(final File marker) {\n            FileOutputStream fos = null;\n            try {\n                marker.createNewFile();\n                fos = new FileOutputStream(marker);\n                fos.write(deploymentName.getBytes());\n            } catch (IOException io) {\n                log.errorf(io, \"Caught exception writing deployment marker file %s\", marker.getAbsolutePath());\n            } finally {\n                safeClose(fos);\n            }\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Scan the given directory for content changes.\n     *\n     * @param directory             the directory to scan\n     * @param events                the event queue;\n     * @param registeredDeployments the deployments currently registered with the server\n     * @param toRemove              the deployments to be removed, any deployment that needs to stick around should be removed\n     */\n    private void scanDirectory(final File directory, final List<ScannerTask> events, final Set<String> registeredDeployments, final Set<String> toRemove) {\n        final File[] children = directory.listFiles(filter);\n        if (children == null) {\n            return;\n        }\n\n        for (File child : children) {\n            final String fileName = child.getName();\n            if (fileName.endsWith(DEPLOYED)) {\n                final String deploymentName = fileName.substring(0, fileName.length() - DEPLOYED.length());\n                toRemove.remove(deploymentName);\n                if (!deployed.containsKey(deploymentName)) {\n                    if (!child.delete()) {\n                        log.warnf(\"Cannot removed extraneous deployment marker file %s\", fileName);\n                    }\n                }\n                if (deployed.get(deploymentName).lastModified != child.lastModified()) {\n                    events.add(new RedeployTask(deploymentName, child.lastModified(), directory));\n                }\n            } else if (fileName.endsWith(DO_DEPLOY)) {\n                final String deploymentName = fileName.substring(0, fileName.length() - DO_DEPLOY.length());\n                final File deploymentFile = new File(directory, deploymentName);\n                if (!deploymentFile.exists()) {\n                    log.warnf(\"Deployment of '%s' requested, but the deployment is not present\", deploymentFile);\n                    if (!child.delete()) {\n                        log.warnf(\"Cannot removed extraneous deployment marker file %s\", fileName);\n                    }\n                    continue;\n                }\n                if (registeredDeployments.contains(deploymentName)) {\n                    events.add(new ReplaceTask(deploymentName, deploymentFile));\n                } else {\n                    events.add(new DeployTask(deploymentName, deploymentFile));\n                }\n                toRemove.remove(deploymentName);\n            } else if (fileName.endsWith(FAILED_DEPLOY)) {\n                final String deploymentName = fileName.substring(0, fileName.length() - FAILED_DEPLOY.length());\n                toRemove.remove(deploymentName);\n            } else if (child.isDirectory()) {\n                int idx = fileName.lastIndexOf('.');\n                if (idx == -1 || !ARCHIVES.contains(fileName.substring(idx))) {\n                    scanDirectory(child, events, registeredDeployments, toRemove);\n                }\n            }\n        }\n    }","id":32993,"modified_method":"/**\n     * Scan the given directory for content changes.\n     *\n     * @param directory             the directory to scan\n     * @param events                the event queue;\n     * @param registeredDeployments the deployments currently registered with the server\n     * @param toRemove              the deployments to be removed, any deployment that needs to stick around should be removed\n     */\n    private void scanDirectory(final File directory, final List<ScannerTask> events, final Set<String> registeredDeployments, final Set<String> toRemove) {\n        final File[] children = directory.listFiles(filter);\n        if (children == null) {\n            return;\n        }\n\n        for (File child : children) {\n            final String fileName = child.getName();\n            if (fileName.endsWith(DEPLOYED)) {\n                final String deploymentName = fileName.substring(0, fileName.length() - DEPLOYED.length());\n                toRemove.remove(deploymentName);\n                if (!deployed.containsKey(deploymentName)) {\n                    if (!child.delete()) {\n                        log.warnf(\"Cannot removed extraneous deployment marker file %s\", fileName);\n                    }\n                }\n                if (deployed.get(deploymentName).lastModified != child.lastModified()) {\n                    events.add(new RedeployTask(deploymentName, child.lastModified(), directory));\n                }\n            } else if (fileName.endsWith(DO_DEPLOY)) {\n                final String deploymentName = fileName.substring(0, fileName.length() - DO_DEPLOY.length());\n                final File deploymentFile = new File(directory, deploymentName);\n                if (!deploymentFile.exists()) {\n                    log.warnf(\"Deployment of '%s' requested, but the deployment is not present\", deploymentFile);\n                    if (!child.delete()) {\n                        log.warnf(\"Cannot removed extraneous deployment marker file %s\", fileName);\n                    }\n                    continue;\n                }\n                if (registeredDeployments.contains(deploymentName)) {\n                    events.add(new ReplaceTask(deploymentName, deploymentFile, child.lastModified()));\n                } else {\n                    events.add(new DeployTask(deploymentName, deploymentFile, child.lastModified()));\n                }\n                toRemove.remove(deploymentName);\n            } else if (fileName.endsWith(FAILED_DEPLOY)) {\n                final String deploymentName = fileName.substring(0, fileName.length() - FAILED_DEPLOY.length());\n                toRemove.remove(deploymentName);\n            } else if (child.isDirectory()) {\n                int idx = fileName.lastIndexOf('.');\n                if (idx == -1 || !ARCHIVES.contains(fileName.substring(idx))) {\n                    scanDirectory(child, events, registeredDeployments, toRemove);\n                }\n            }\n        }\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeFailedMarker(final File deploymentFile, final ModelNode failureDescription) {\n        final File failedMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + FAILED_DEPLOY);\n        final File deployMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + DO_DEPLOY);\n        if (deployMarker.exists() && !deployMarker.delete()) {\n            log.warnf(\"Unable to remove marger file %s\", deployMarker);\n        }\n        final File deployedMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + DEPLOYED);\n        if (deployedMarker.exists() && !deployedMarker.delete()) {\n            log.warnf(\"Unable to remove marger file %s\", deployMarker);\n        }\n        FileOutputStream fos = null;\n        try {\n            failedMarker.createNewFile();\n            fos = new FileOutputStream(failedMarker);\n            fos.write(failureDescription.asString().getBytes());\n        } catch (IOException io) {\n            log.errorf(io, \"Caught exception writing deployment failed marker file %s\", failedMarker.getAbsolutePath());\n        } finally {\n            safeClose(fos);\n        }\n    }","id":32994,"modified_method":"private void writeFailedMarker(final File deploymentFile, final ModelNode failureDescription) {\n        final File failedMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + FAILED_DEPLOY);\n        final File deployMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + DO_DEPLOY);\n        if (deployMarker.exists() && !deployMarker.delete()) {\n            log.warnf(\"Unable to remove marker file %s\", deployMarker);\n        }\n        final File deployedMarker = new File(deploymentFile.getParent(), deploymentFile.getName() + DEPLOYED);\n        if (deployedMarker.exists() && !deployedMarker.delete()) {\n            log.warnf(\"Unable to remove marker file %s\", deployedMarker);\n        }\n        FileOutputStream fos = null;\n        try {\n            failedMarker.createNewFile();\n            fos = new FileOutputStream(failedMarker);\n            fos.write(failureDescription.asString().getBytes());\n        } catch (IOException io) {\n            log.errorf(io, \"Caught exception writing deployment failed marker file %s\", failedMarker.getAbsolutePath());\n        } finally {\n            safeClose(fos);\n        }\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"MockServerController(String... existingDeployments) {\n            addGetDeploymentNamesResponse(existingDeployments);\n        }","id":32995,"modified_method":"MockServerController(DeploymentRepository repo, String... existingDeployments) {\n            for (String dep : existingDeployments) {\n                try {\n                    added.put(dep, repo.addDeploymentContent(dep, dep, null));\n                } catch (IOException e) {\n                    // impossible\n                }\n            }\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public ModelNode execute(ExecutionContext executionContext) throws CancellationException {\n            if (responses.isEmpty()) {\n                Assert.fail(\"unexpected request \" + executionContext.getOperation());\n                return null; // unreachable\n            }\n            requests.add(executionContext.getOperation());\n            return responses.remove(0);\n        }","id":32996,"modified_method":"@Override\n        public ModelNode execute(ExecutionContext executionContext) throws CancellationException {\n            ModelNode op = executionContext.getOperation();\n            requests.add(op);\n            return processOp(op);\n        }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testCleanSpuriousMarkers() throws Exception {\n        File f1 = createFile(\"spurious\" + FileSystemDeploymentService.DEPLOYED);\n        File f2 = createFile(new File(tmpDir, \"nested\"), \"nested\" + FileSystemDeploymentService.DEPLOYED);\n        File f3 = createFile(\"ok\" + FileSystemDeploymentService.DEPLOYED);\n        File f4 = createFile(new File(tmpDir, \"nested\"), \"nested-ok\" + FileSystemDeploymentService.DEPLOYED);\n\n        // We expect 2 requests for children names due to subdir \"nested\"\n        MockServerController sc = new MockServerController(\"ok\", \"nested-ok\");\n        sc.responses.add(sc.responses.get(0));\n        createTestee(sc);\n\n        Assert.assertFalse(f1.exists());\n        Assert.assertFalse(f2.exists());\n        Assert.assertTrue(f3.exists());\n        Assert.assertTrue(f4.exists());\n    }","id":32997,"modified_method":"@Test\n    public void testCleanSpuriousMarkers() throws Exception {\n        File f1 = createFile(\"spurious\" + FileSystemDeploymentService.DEPLOYED);\n        File f2 = createFile(new File(tmpDir, \"nested\"), \"nested\" + FileSystemDeploymentService.DEPLOYED);\n        File f3 = createFile(\"ok\" + FileSystemDeploymentService.DEPLOYED);\n        File f4 = createFile(new File(tmpDir, \"nested\"), \"nested-ok\" + FileSystemDeploymentService.DEPLOYED);\n\n        // We expect 2 requests for children names due to subdir \"nested\"\n        MockServerController sc = new MockServerController(new MockDeploymentRepository(), \"ok\", \"nested-ok\");\n//        sc.responses.add(sc.responses.get(0));\n        createTestee(sc);\n\n        Assert.assertFalse(f1.exists());\n        Assert.assertFalse(f2.exists());\n        Assert.assertTrue(f3.exists());\n        Assert.assertTrue(f4.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTwoFileRedeploy() throws Exception {\n        File war1 = createFile(\"foo.war\");\n        File dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File war2 = createFile(\"bar.war\");\n        File dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n\n        dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(4, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n    }","id":32998,"modified_method":"@Test\n    public void testTwoFileRedeploy() throws Exception {\n        File war1 = createFile(\"foo.war\");\n        File dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File war2 = createFile(\"bar.war\");\n        File dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n\n        dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(4, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testSuccessfulRetryRedeploy() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n\n        dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry succeeds\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(4, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed1.exists() && deployed2.exists());\n        assertTrue(failed1.exists() || failed2.exists());\n    }","id":32999,"modified_method":"@Test\n    public void testSuccessfulRetryRedeploy() throws Exception {\n        File war1 = createFile(\"bar.war\");\n        File dodeploy1 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed1 = new File(tmpDir, \"bar.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        File war2 = createFile(\"foo.war\");\n        File dodeploy2 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        File deployed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.DEPLOYED);\n        File failed2 = new File(tmpDir, \"foo.war\" + FileSystemDeploymentService.FAILED_DEPLOY);\n        TesteeSet ts = createTestee();\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeSuccessResponse(2);\n        ts.testee.scan();\n        assertEquals(2, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertFalse(dodeploy1.exists());\n        assertTrue(deployed1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy2.exists());\n        assertTrue(deployed2.exists());\n\n        dodeploy1 = createFile(\"foo.war\" + FileSystemDeploymentService.DO_DEPLOY);\n        dodeploy2 = createFile(\"bar.war\" + FileSystemDeploymentService.DO_DEPLOY);\n//        ts.controller.addGetDeploymentNamesResponse();\n        ts.controller.addCompositeFailureResponse(2, 1);\n        // Retry succeeds\n        ts.controller.addCompositeSuccessResponse(1);\n        ts.testee.scan();\n        assertEquals(4, ts.repo.content.size());\n        assertTrue(war1.exists());\n        assertTrue(war2.exists());\n        assertFalse(dodeploy1.exists());\n        assertFalse(dodeploy2.exists());\n        assertFalse(deployed1.exists() && deployed2.exists());\n        assertTrue(failed1.exists() || failed2.exists());\n    }","commit_id":"81d2fa87a7ce0f117466e6e6a2222fb1b0f48866","url":"https://github.com/wildfly/wildfly"}]